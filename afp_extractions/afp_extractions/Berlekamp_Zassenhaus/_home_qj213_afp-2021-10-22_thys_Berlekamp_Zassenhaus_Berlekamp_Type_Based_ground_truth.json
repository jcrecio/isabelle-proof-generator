{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Berlekamp_Type_Based.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma prod_list_map_filter: \"prod_list (map g (filter f xs)) * prod_list (map g (filter (\\<lambda> x. \\<not> f x) xs)) \n  = prod_list (map g xs)\"", "lemma prod_list_map_partition: \n  assumes \"List.partition f xs = (ys, zs)\"\n  shows \"prod_list (map g xs) = prod_list (map g ys) * prod_list (map g zs)\"", "lemma coprime_id_is_unit:\n  fixes a::\"'b::semiring_gcd\"\n  shows \"coprime a a \\<longleftrightarrow> is_unit a\"", "lemma dim_vec_of_list[simp]: \"dim_vec (vec_of_list x) = length x\"", "lemma length_list_of_vec[simp]: \"length (list_of_vec A) = dim_vec A\"", "lemma list_of_vec_vec_of_list[simp]: \"list_of_vec (vec_of_list a) = a\"", "lemma inj_Poly_list_of_vec': \"inj_on (Poly \\<circ> list_of_vec) {v. dim_vec v = n}\"", "lemma list_of_vec_rw_map: \"list_of_vec m = map (\\<lambda>n. m $ n) [0..<dim_vec m]\"", "lemma degree_Poly':\nassumes xs: \"xs \\<noteq> []\"\nshows \"degree (Poly xs) < length xs\"", "lemma vec_of_list_list_of_vec[simp]: \"vec_of_list (list_of_vec a) = a\"", "lemma row_mat_of_rows_list:\nassumes b: \"b < length A\"\nand nc: \"\\<forall>i. i < length A \\<longrightarrow> length (A ! i) = nc\"\nshows \"(row (mat_of_rows_list nc A) b) = vec_of_list (A ! b)\"", "lemma degree_Poly_list_of_vec:\nassumes n: \"x \\<in> carrier_vec n\"\nand n0: \"n > 0\"\nshows \"degree (Poly (list_of_vec x)) < n\"", "lemma list_of_vec_nth:\n  assumes i: \"i < dim_vec x\"\n  shows \"list_of_vec x ! i = x $ i\"", "lemma coeff_Poly_list_of_vec_nth':\n assumes i: \"i < dim_vec x\"\n shows \"coeff (Poly (list_of_vec x)) i = x $ i\"", "lemma list_of_vec_row_nth:\nassumes x: \"x < dim_col A\"\nshows \"list_of_vec (row A i) ! x = A $$ (i, x)\"", "lemma coeff_Poly_list_of_vec_nth:\nassumes x: \"x < dim_col A\"\nshows \"coeff (Poly (list_of_vec (row A i))) x = A $$ (i, x)\"", "lemma inj_on_list_of_vec: \"inj_on list_of_vec (carrier_vec n)\"", "lemma vec_of_list_carrier[simp]: \"vec_of_list x \\<in> carrier_vec (length x)\"", "lemma card_carrier_vec: \"card (carrier_vec n:: 'b::finite vec set) = CARD('b) ^ n\"", "lemma finite_carrier_vec[simp]: \"finite (carrier_vec n:: 'b::finite vec set)\"", "lemma row_echelon_form_dim0_row:\nassumes \"A \\<in> carrier_mat 0 n\"\nshows \"row_echelon_form A\"", "lemma row_echelon_form_dim0_col:\nassumes \"A \\<in> carrier_mat n 0\"\nshows \"row_echelon_form A\"", "lemma row_echelon_form_one_dim0[simp]: \"row_echelon_form (1\\<^sub>m 0)\"", "lemma Poly_list_of_vec_0[simp]: \"Poly (list_of_vec (0\\<^sub>v 0)) = [:0:]\"", "lemma monic_normalize:\nassumes \"(p :: 'b :: {field,euclidean_ring_gcd} poly) \\<noteq> 0\" shows \"monic (normalize p)\"", "lemma exists_factorization_prod_list:\nfixes P::\"'b::field poly list\"\nassumes \"degree (prod_list P) > 0\"\n  and \"\\<And> u. u \\<in> set P \\<Longrightarrow> degree u > 0 \\<and> monic u\"\n  and \"square_free (prod_list P)\"\nshows \"\\<exists>Q. prod_list Q = prod_list P \\<and> length P \\<le> length Q\n           \\<and> (\\<forall>u. u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)\"", "lemma normalize_eq_imp_smult:\n  fixes p :: \"'b :: {euclidean_ring_gcd} poly\"\n  assumes n: \"normalize p = normalize q\"\n  shows \"\\<exists> c. c \\<noteq> 0 \\<and> q = smult c p\"", "lemma prod_list_normalize: \n  fixes P :: \"'b :: {idom_divide,normalization_semidom_multiplicative} poly list\"\n  shows \"normalize (prod_list P) = prod_list (map normalize P)\"", "lemma prod_list_dvd_prod_list_subset:\nfixes A::\"'b::comm_monoid_mult list\"\nassumes dA: \"distinct A\"\n  and dB: \"distinct B\" (*Maybe this condition could be avoided*)\n  and s: \"set A \\<subseteq> set B\"\nshows \"prod_list A dvd prod_list B\"", "lemma gcd_monic_constant:\n  \"gcd f g \\<in> {1, f}\" if \"monic f\" and \"degree g = 0\"\n    for f g :: \"'a :: {field_gcd} poly\"", "lemma distinct_find_base_vectors:\nfixes A::\"'a::field mat\"\nassumes ref: \"row_echelon_form A\"\n  and A: \"A \\<in> carrier_mat nr nc\"\nshows \"distinct (find_base_vectors A)\"", "lemma length_find_base_vectors:\nfixes A::\"'a::field mat\"\nassumes ref: \"row_echelon_form A\"\n  and A: \"A \\<in> carrier_mat nr nc\"\nshows \"length (find_base_vectors A) = card (set (find_base_vectors A))\"", "lemma power_poly_f_mod_binary: \"power_poly_f_mod m a n = (if n = 0 then 1 mod m\n    else let (d, r) = Divides.divmod_nat n 2;\n       rec = power_poly_f_mod m ((a * a) mod m) d in\n    if r = 0 then rec else (rec * a) mod m)\"\n  for m a :: \"'a :: {field_gcd} poly\"", "lemma fermat_theorem_mod_ring [simp]:\n  fixes a::\"'a mod_ring\"\n  shows \"a ^ CARD('a) = a\"", "lemma mod_eq_dvd_iff_poly: \"((x::'a mod_ring poly) mod n = y mod n) = (n dvd x - y)\"", "lemma cong_gcd_eq_poly:\n  \"gcd a m = gcd b m\" if \"[(a::'a mod_ring poly) = b] (mod m)\"", "lemma coprime_h_c_poly:\nfixes h::\"'a mod_ring poly\"\nassumes \"c1 \\<noteq> c2\"\nshows \"coprime (h - [:c1:]) (h - [:c2:])\"", "lemma coprime_h_c_poly2:\nfixes h::\"'a mod_ring poly\"\nassumes \"coprime (h - [:c1:]) (h - [:c2:])\"\nand \"\\<not> is_unit (h - [:c1:])\"\nshows \"c1 \\<noteq> c2\"", "lemma degree_minus_eq_right:\nfixes p::\"'b::ab_group_add poly\"\nshows \"degree q < degree p \\<Longrightarrow> degree (p - q) = degree p\"", "lemma coprime_prod:\n  fixes A::\"'a mod_ring set\" and g::\"'a mod_ring \\<Rightarrow> 'a mod_ring poly\"\n  assumes \"\\<forall>x\\<in>A. coprime (g a) (g x)\"\n  shows \"coprime (g a) (prod (\\<lambda>x. g x) A)\"", "lemma coprime_prod2:\n  fixes A::\"'b::semiring_gcd set\"\n  assumes \"\\<forall>x\\<in>A. coprime (a) (x)\" and f: \"finite A\"\n  shows \"coprime (a) (prod (\\<lambda>x. x) A)\"", "lemma divides_prod:\n  fixes g::\"'a mod_ring \\<Rightarrow> 'a mod_ring poly\"\n  assumes \"\\<forall>c1 c2. c1 \\<in> A \\<and> c2 \\<in> A \\<and> c1 \\<noteq> c2 \\<longrightarrow> coprime (g c1) (g c2)\"\n  assumes \"\\<forall>c\\<in> A. g c dvd f\"\n  shows \"(\\<Prod>c\\<in>A. g c) dvd f\"", "lemma poly_monom_identity_mod_p:\n  \"monom (1::'a mod_ring) (CARD('a)) - monom 1 1 = prod (\\<lambda>x. [:0,1:] - [:x:]) (UNIV::'a mod_ring set)\"\n  (is \"?lhs = ?rhs\")", "lemma poly_identity_mod_p:\n  \"v^(CARD('a)) - v = prod (\\<lambda>x. v - [:x:]) (UNIV::'a mod_ring set)\"", "lemma coprime_gcd:\n  fixes h::\"'a mod_ring poly\"\n  assumes \"Rings.coprime (h-[:c1:]) (h-[:c2:])\"\n  shows \"Rings.coprime (gcd f(h-[:c1:])) (gcd f (h-[:c2:]))\"", "lemma divides_prod_gcd:\n  fixes h::\"'a mod_ring poly\"\n  assumes \"\\<forall>c1 c2. c1 \\<in> A \\<and> c2 \\<in> A \\<and> c1 \\<noteq> c2\\<longrightarrow> coprime (h-[:c1:]) (h-[:c2:])\"\n  shows \"(\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f\"", "lemma monic_prod_gcd:\nassumes f: \"finite A\" and f0: \"(f :: 'b :: {field_gcd} poly) \\<noteq> 0\"\nshows \"monic (\\<Prod>c\\<in>A. gcd f (h - [:c:]))\"", "lemma coprime_not_unit_not_dvd:\nfixes a::\"'b::semiring_gcd\"\nassumes \"a dvd b\"\nand \"coprime b c\"\nand \"\\<not> is_unit a\"\nshows \"\\<not> a dvd c\"", "lemma divides_prod2:\n  fixes A::\"'b::semiring_gcd set\"\n  assumes f: \"finite A\"\n  and \"\\<forall>a\\<in>A. a dvd c\"\n  and \"\\<forall>a1 a2. a1 \\<in> A \\<and> a2 \\<in> A \\<and> a1 \\<noteq> a2 \\<longrightarrow> coprime a1 a2\"\n  shows \"\\<Prod>A dvd c\"", "lemma coprime_polynomial_factorization:\n  fixes a1 :: \"'b :: {field_gcd} poly\"\n  assumes  irr: \"as \\<subseteq> {q. irreducible q \\<and> monic q}\"\n  and \"finite as\" and a1: \"a1 \\<in> as\" and a2: \"a2 \\<in> as\" and a1_not_a2: \"a1 \\<noteq> a2\"\n  shows \"coprime a1 a2\"", "theorem Berlekamp_gcd_step:\nfixes f::\"'a mod_ring poly\" and h::\"'a mod_ring poly\"\nassumes hq_mod_f: \"[h^(CARD('a)) = h] (mod f)\" and monic_f: \"monic f\" and sf_f: \"square_free f\"\nshows \"f = prod (\\<lambda>c. gcd f (h - [:c:])) (UNIV::'a mod_ring set)\"  (is \"?lhs = ?rhs\")", "lemma berlekamp_basis_code[code]: \"berlekamp_basis u =\n  (map (poly_of_list o list_of_vec) (find_base_vectors (berlekamp_resulting_mat u)))\"", "lemma power_polys_works:\nfixes u::\"'b::unique_euclidean_semiring\"\nassumes i: \"i < n\" and c: \"curr_p = curr_p mod u\" (*Equivalent to degree curr_p < degree u*)\nshows \"power_polys mult_p u curr_p n ! i = curr_p * mult_p ^ i mod u\"", "lemma length_power_polys[simp]: \"length (power_polys mult_p u curr_p n) = n\"", "lemma Poly_berlekamp_mat:\nassumes k: \"k < degree u\"\nshows \"Poly (list_of_vec (row (berlekamp_mat u) k)) = [:0,1:]^(CARD('a) * k) mod u\"", "lemma mat_of_rows_list_dim[simp]:\n  \"mat_of_rows_list n vs \\<in> carrier_mat (length vs) n\"\n  \"dim_row (mat_of_rows_list n vs) = length vs\"\n  \"dim_col (mat_of_rows_list n vs) = n\"", "lemma berlekamp_mat_closed[simp]:\n  \"berlekamp_mat u \\<in> carrier_mat (degree u) (degree u)\"\n  \"dim_row (berlekamp_mat u) = degree u\"\n  \"dim_col (berlekamp_mat u) = degree u\"", "lemma vec_of_list_coeffs_nth:\nassumes i: \"i \\<in> {..degree h}\" and h_not0: \"h \\<noteq> 0\"\nshows \"vec_of_list (coeffs h) $ i = coeff h i\"", "lemma poly_mod_sum:\n  fixes x y z :: \"'b::field poly\"\n  assumes f: \"finite A\"\n  shows \"sum f A mod z = sum (\\<lambda>i. f i mod z) A\"", "lemma prime_not_dvd_fact:\nassumes kn: \"k < n\" and prime_n: \"prime n\"\nshows \"\\<not> n dvd fact k\"", "lemma dvd_choose_prime:\nassumes kn: \"k < n\" and k: \"k \\<noteq> 0\" and n: \"n \\<noteq> 0\" and prime_n: \"prime n\"\nshows \"n dvd (n choose k)\"", "lemma add_power_poly_mod_ring:\nfixes x :: \"'a mod_ring poly\"\nshows \"(x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)\"", "lemma power_poly_sum_mod_ring:\nfixes f :: \"'b \\<Rightarrow> 'a mod_ring poly\"\nassumes f: \"finite A\"\nshows \"(sum f A) ^ CARD('a) = sum (\\<lambda>i. (f i) ^ CARD('a)) A\"", "lemma poly_power_card_as_sum_of_monoms:\n  fixes h :: \"'a mod_ring poly\"\n  shows \"h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a)*i))\"", "lemma degree_Poly_berlekamp_le:\nassumes i: \"i < degree u\"\nshows \"degree (Poly (list_of_vec (row (berlekamp_mat u) i))) < degree u\"", "lemma monom_card_pow_mod_sum_berlekamp:\nassumes i: \"i < degree u\"\nshows \"monom 1 (CARD('a) * i) mod u = (\\<Sum>j<degree u. monom ((berlekamp_mat u) $$ (i,j)) j)\"", "lemma col_scalar_prod_as_sum:\nassumes \"dim_vec v = dim_row A\"\nshows \"col A j \\<bullet> v = (\\<Sum>i = 0..<dim_vec v. A $$ (i,j) * v $ i)\"", "lemma row_transpose_scalar_prod_as_sum:\nassumes j: \"j < dim_col A\" and dim_v: \"dim_vec v = dim_row A\"\nshows \"row (transpose_mat A) j \\<bullet> v = (\\<Sum>i = 0..<dim_vec v. A $$ (i,j) * v $ i)\"", "lemma poly_as_sum_eq_monoms:\nassumes ss_eq: \"(\\<Sum>i<n. monom (f i) i) = (\\<Sum>i<n. monom (g i) i)\"\nand a_less_n: \"a<n\"\nshows \"f a = g a\"", "lemma dim_vec_of_list_h:\nassumes \"degree h < degree u\"\nshows \"dim_vec (vec_of_list ((coeffs h) @ replicate (degree u - length (coeffs h)) 0)) = degree u\"", "lemma vec_of_list_coeffs_nth':\nassumes i: \"i \\<in> {..degree h}\" and h_not0: \"h \\<noteq> 0\"\nassumes \"degree h < degree u\"\nshows \"vec_of_list ((coeffs h) @ replicate (degree u - length (coeffs h)) 0) $ i = coeff h i\"", "lemma vec_of_list_coeffs_replicate_nth_0:\nassumes i: \"i \\<in> {..<degree u}\"\nshows \"vec_of_list (coeffs 0 @ replicate (degree u - length (coeffs 0)) 0) $ i = coeff 0 i\"", "lemma vec_of_list_coeffs_replicate_nth:\nassumes i: \"i \\<in> {..<degree u}\"\nassumes \"degree h < degree u\"\nshows \"vec_of_list ((coeffs h) @ replicate (degree u - length (coeffs h)) 0) $ i = coeff h i\"", "lemma equation_13:\n  fixes u h\n  defines H: \"H \\<equiv> vec_of_list ((coeffs h) @ replicate (degree u - length (coeffs h)) 0)\"\n  assumes deg_le: \"degree h < degree u\" (*Mandatory from equation 8*)\n  shows \"[h^CARD('a) = h] (mod u) \\<longleftrightarrow> (transpose_mat (berlekamp_mat u)) *\\<^sub>v H = H\"\n  (is \"?lhs = ?rhs\")", "lemma exists_s_factor_dvd_h_s:\nfixes fi::\"'a mod_ring poly\"\nassumes finite_P: \"finite P\"\n      and f_desc_square_free: \"f = (\\<Prod>a\\<in>P. a)\"\n      and P: \"P \\<subseteq> {q. irreducible q \\<and> monic q}\"\n      and fi_P: \"fi \\<in> P\"\n      and h: \"h \\<in> {v. [v^(CARD('a)) = v] (mod f)}\"\n      shows \"\\<exists>s. fi dvd (h - [:s:])\"", "lemma exists_two_distint: \"\\<exists>a b::'a mod_ring. a \\<noteq> b\"", "lemma coprime_cong_mult_factorization_poly:\n  fixes f::\"'b::{field} poly\"\n    and a b p :: \"'c :: {field_gcd} poly\"\n  assumes finite_P: \"finite P\"\n    and P: \"P \\<subseteq> {q. irreducible q}\"\n    and p: \"\\<forall>p\\<in>P. [a=b] (mod p)\"\n    and coprime_P: \"\\<forall>p1 p2. p1 \\<in> P \\<and> p2 \\<in> P \\<and> p1 \\<noteq> p2 \\<longrightarrow> coprime p1 p2\"\n  shows \"[a = b] (mod (\\<Prod>a\\<in>P. a))\"", "lemma W_eq_berlekamp_mat:\nfixes u::\"'a mod_ring poly\"\nshows \"{v. [v^CARD('a) = v] (mod u) \\<and> degree v < degree u}\n  = {h. let H = vec_of_list ((coeffs h) @ replicate (degree u - length (coeffs h)) 0) in\n    (transpose_mat (berlekamp_mat u)) *\\<^sub>v H = H \\<and> degree h < degree u}\"", "lemma transpose_minus_1:\n  assumes \"dim_row Q = dim_col Q\"\n  shows \"transpose_mat (Q - (1\\<^sub>m (dim_row Q))) =  (transpose_mat Q - (1\\<^sub>m (dim_row Q)))\"", "lemma system_iff:\nfixes v::\"'b::comm_ring_1 vec\"\nassumes sq_Q: \"dim_row Q = dim_col Q\" and v: \"dim_row Q = dim_vec v\"\nshows \"(transpose_mat Q *\\<^sub>v v = v) \\<longleftrightarrow> ((transpose_mat Q - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v = 0\\<^sub>v (dim_vec v))\"", "lemma system_if_mat_kernel:\nassumes sq_Q: \"dim_row Q = dim_col Q\" and v: \"dim_row Q = dim_vec v\"\nshows \"(transpose_mat Q *\\<^sub>v v = v) \\<longleftrightarrow> v \\<in> mat_kernel (transpose_mat (Q - (1\\<^sub>m (dim_row Q))))\"", "lemma degree_u_mod_irreducible\\<^sub>d_factor_0:\nfixes v and u::\"'a mod_ring poly\"\ndefines W: \"W \\<equiv> {v. [v ^ CARD('a) = v] (mod u)}\"\nassumes v: \"v \\<in> W\"\nand finite_U: \"finite U\" and u_U: \"u = \\<Prod>U\" and U_irr_monic: \"U \\<subseteq> {q. irreducible q \\<and> monic q}\"\nand fi_U: \"fi \\<in> U\"\nshows \"degree (v mod fi) = 0\"", "lemma subspace_Berlekamp:\nassumes f: \"degree f \\<noteq> 0\"\nshows \"subspace (class_ring :: 'a mod_ring ring) \n  {v. [v^(CARD('a)) = v] (mod f) \\<and> (degree v < degree f)} poly_abelian_monoid\"", "lemma berlekamp_resulting_mat_closed[simp]:\n  \"berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)\"\n  \"dim_row (berlekamp_resulting_mat u) = degree u\"\n  \"dim_col (berlekamp_resulting_mat u) = degree u\"", "lemma berlekamp_resulting_mat_basis:\n\"kernel.basis (degree u) (berlekamp_resulting_mat u) (set (find_base_vectors (berlekamp_resulting_mat u)))\"", "lemma set_berlekamp_basis_eq: \"(set (berlekamp_basis u))\n  = (Poly \\<circ> list_of_vec)` (set (find_base_vectors (berlekamp_resulting_mat u)))\"", "lemma berlekamp_resulting_mat_constant:\nassumes deg_u: \"degree u = 0\"\nshows \"berlekamp_resulting_mat u = 1\\<^sub>m 0\"", "lemma set_berlekamp_basis_constant:\nassumes deg_u: \"degree u = 0\"\nshows \"set (berlekamp_basis u) = {}\"", "lemma row_echelon_form_berlekamp_resulting_mat: \"row_echelon_form (berlekamp_resulting_mat u)\"", "lemma mat_kernel_berlekamp_resulting_mat_degree_0:\nassumes d: \"degree u = 0\"\nshows \"mat_kernel (berlekamp_resulting_mat u) = {0\\<^sub>v 0}\"", "lemma in_mat_kernel_berlekamp_resulting_mat:\nassumes x: \"transpose_mat (berlekamp_mat u) *\\<^sub>v x = x\"\nand x_dim: \"x \\<in> carrier_vec (degree u)\"\nshows \"x \\<in> mat_kernel (berlekamp_resulting_mat u)\"", "lemma linear_Poly_list_of_vec:\nshows \"(Poly \\<circ> list_of_vec) \\<in> module_hom class_ring V (vector_space_poly.vs {v. [v^(CARD('a)) = v] (mod u)})\"", "lemma linear_Poly_list_of_vec':\n  assumes \"degree u > 0\"\n  shows \"(Poly \\<circ> list_of_vec) \\<in> module_hom R V W\"", "lemma berlekamp_basis_eq_8:\n  assumes v: \"v \\<in> set (berlekamp_basis u)\"\n  shows \"[v ^ CARD('a) = v] (mod u)\"", "lemma surj_Poly_list_of_vec:\n  assumes deg_u: \"degree u > 0\"\n  shows \"(Poly \\<circ> list_of_vec)` (carrier V) = carrier W\"", "lemma card_set_berlekamp_basis: \"card (set (berlekamp_basis u)) = length (berlekamp_basis u)\"", "lemma linear_map_Poly_list_of_vec': \"linear_map class_ring V W (Poly \\<circ> list_of_vec)\"", "lemma berlekamp_basis_basis:\n  \"Berlekamp_subspace.basis (set (berlekamp_basis u))\"", "lemma finsum_sum:\nfixes f::\"'a mod_ring poly\"\nassumes f: \"finite B\"\nand a_Pi: \"a \\<in> B \\<rightarrow> carrier R\"\nand V: \"B \\<subseteq> carrier W\"\nshows \"(\\<Oplus>\\<^bsub>W\\<^esub>v\\<in>B. a v \\<odot>\\<^bsub>W\\<^esub> v) = sum (\\<lambda>v. smult (a v) v) B\"", "lemma exists_vector_in_Berlekamp_subspace_dvd:\nfixes p_i::\"'a mod_ring poly\"\nassumes finite_P: \"finite P\"\n      and f_desc_square_free: \"u = (\\<Prod>a\\<in>P. a)\"\n      and P: \"P \\<subseteq> {q. irreducible q \\<and> monic q}\"\n      and pi: \"p_i \\<in> P\" and pj: \"p_j \\<in> P\" and pi_pj: \"p_i \\<noteq> p_j\"\n      and monic_f: \"monic u\" and sf_f: \"square_free u\"\n      and not_irr_w: \"\\<not> irreducible w\"\n      and w_dvd_f: \"w dvd u\" and monic_w: \"monic w\"\n      and pi_dvd_w: \"p_i dvd w\" and pj_dvd_w: \"p_j dvd w\"\nshows \"\\<exists>v. v \\<in> {h. [h^(CARD('a)) = h] (mod u) \\<and> degree h < degree u}\n  \\<and> v mod p_i \\<noteq> v mod p_j\n  \\<and> degree (v mod p_i) = 0\n  \\<and> degree (v mod p_j) = 0\n\\<comment> \\<open>This implies that the algorithm decreases the degree of the reducible polynomials in each step:\\<close>\n  \\<and> (\\<exists>s. gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)\"", "lemma exists_vector_in_Berlekamp_basis_dvd_aux:\nassumes basis_V: \"Berlekamp_subspace.basis B\"\n  and finite_V: \"finite B\" (*This should be removed, since the Berlekamp subspace is a finite set*)\nassumes finite_P: \"finite P\"\n      and f_desc_square_free: \"u = (\\<Prod>a\\<in>P. a)\"\n      and P: \"P \\<subseteq> {q. irreducible q \\<and> monic q}\"\n      and pi: \"p_i \\<in> P\" and pj: \"p_j \\<in> P\" and pi_pj: \"p_i \\<noteq> p_j\"\n      and monic_f: \"monic u\" and sf_f: \"square_free u\"\n      and not_irr_w: \"\\<not> irreducible w\"\n      and w_dvd_f: \"w dvd u\" and monic_w: \"monic w\"\n      and pi_dvd_w: \"p_i dvd w\" and pj_dvd_w: \"p_j dvd w\"\n    shows \"\\<exists>v \\<in> B. v mod p_i \\<noteq> v mod p_j\"", "lemma exists_vector_in_Berlekamp_basis_dvd:\nassumes basis_V: \"Berlekamp_subspace.basis B\"\nand finite_V: \"finite B\" (*This should be removed, since the Berlekamp subspace is a finite set*)\nassumes finite_P: \"finite P\"\n      and f_desc_square_free: \"u = (\\<Prod>a\\<in>P. a)\"\n      and P: \"P \\<subseteq> {q. irreducible q \\<and> monic q}\"\n      and pi: \"p_i \\<in> P\" and pj: \"p_j \\<in> P\" and pi_pj: \"p_i \\<noteq> p_j\"\n      and monic_f: \"monic u\" and sf_f: \"square_free u\"\n      and not_irr_w: \"\\<not> irreducible w\"\n      and w_dvd_f: \"w dvd u\" and monic_w: \"monic w\"\n      and pi_dvd_w: \"p_i dvd w\" and pj_dvd_w: \"p_j dvd w\"\nshows \"\\<exists>v \\<in> B. v mod p_i \\<noteq> v mod p_j\n  \\<and> degree (v mod p_i) = 0\n  \\<and> degree (v mod p_j) = 0\n\\<comment> \\<open>This implies that the algorithm decreases the degree of the reducible polynomials in each step:\\<close>\n  \\<and> (\\<exists>s. gcd w (v - [:s:]) \\<noteq> w \\<and> \\<not> coprime w (v - [:s:]))\"", "lemma exists_bijective_linear_map_W_vec:\n  assumes finite_P: \"finite P\"\n      and u_desc_square_free: \"u = (\\<Prod>a\\<in>P. a)\"\n      and P: \"P \\<subseteq> {q. irreducible q \\<and> monic q}\"\n  shows \"\\<exists>f. linear_map class_ring W (module_vec TYPE('a mod_ring) (card P)) f\n  \\<and> bij_betw f (carrier W) (carrier_vec (card P)::'a mod_ring vec set)\"", "lemma fin_dim_kernel_berlekamp: \"V.fin_dim\"", "lemma Berlekamp_subspace_fin_dim: \"Berlekamp_subspace.fin_dim\"", "lemma Berlekamp_subspace_eq_dim_vec: \"Berlekamp_subspace.dim = RV.dim\"", "lemma Berlekamp_subspace_dim: \"Berlekamp_subspace.dim = card P\"", "lemma length_berlekamp_basis_numbers_factors: \"length (berlekamp_basis u) = card P\"", "lemma berlekamp_basis_length_factorization: assumes f: \"f = prod_list us\"\n  and d: \"\\<And> u. u \\<in> set us \\<Longrightarrow> degree u > 0\"\n  shows \"length us \\<le> n\"", "lemma berlekamp_basis_irreducible: assumes f: \"f = prod_list us\"\n  and n_us: \"length us = n\"\n  and us: \"\\<And> u. u \\<in> set us \\<Longrightarrow> degree u > 0\"\n  and u: \"u \\<in> set us\"\n  shows \"irreducible u\"", "lemma not_irreducible_factor_yields_prime_factors:\n  assumes uf: \"u dvd (f :: 'b :: {field_gcd} poly)\" and fin: \"finite P\"\n      and fP: \"f = \\<Prod>P\" and P: \"P \\<subseteq> {q. irreducible q \\<and> monic q}\"\n    and u: \"degree u > 0\" \"\\<not> irreducible u\"\n  shows \"\\<exists> pi pj. pi \\<in> P \\<and> pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\"", "lemma berlekamp_factorization_main:\n  fixes f::\"'a mod_ring poly\"\n  assumes sf_f: \"square_free f\"\n    and vs: \"vs = vs1 @ vs2\"\n    and vsf: \"vs = berlekamp_basis f\"\n    and n_bb: \"n = length (berlekamp_basis f)\"\n    and n: \"n = length us1 + n2\"\n    and us: \"us = us1 @ berlekamp_factorization_main d divs vs2 n2\"\n    and us1: \"\\<And> u. u \\<in> set us1 \\<Longrightarrow> monic u \\<and> irreducible u\"\n    and divs: \"\\<And> d. d \\<in> set divs \\<Longrightarrow> monic d \\<and> degree d > 0\"\n    and vs1: \"\\<And> u v i. v \\<in> set vs1 \\<Longrightarrow> u \\<in> set us1 \\<union> set divs\n      \\<Longrightarrow> i < CARD('a) \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1,u}\"\n    and f: \"f = prod_list (us1 @ divs)\"\n    and deg_f: \"degree f > 0\"\n    and d: \"\\<And> g. g dvd f \\<Longrightarrow> degree g = d \\<Longrightarrow> irreducible g\" \n  shows \"f = prod_list us \\<and> (\\<forall> u \\<in> set us. monic u \\<and> irreducible u)\"", "lemma berlekamp_monic_factorization:\n  fixes f::\"'a mod_ring poly\"\n  assumes sf_f: \"square_free f\"\n    and us: \"berlekamp_monic_factorization d f = us\"\n    and d: \"\\<And> g. g dvd f \\<Longrightarrow> degree g = d \\<Longrightarrow> irreducible g\" \n    and deg: \"degree f > 0\" \n    and mon: \"monic f\" \n  shows \"f = prod_list us \\<and> (\\<forall> u \\<in> set us. monic u \\<and> irreducible u)\""], "translations": [["", "lemma prod_list_map_filter: \"prod_list (map g (filter f xs)) * prod_list (map g (filter (\\<lambda> x. \\<not> f x) xs)) \n  = prod_list (map g xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map g (filter f xs)) *\n    prod_list (map g (filter (\\<lambda>x. \\<not> f x) xs)) =\n    prod_list (map g xs)", "by (induct xs, auto simp: ac_simps)"], ["", "lemma prod_list_map_partition: \n  assumes \"List.partition f xs = (ys, zs)\"\n  shows \"prod_list (map g xs) = prod_list (map g ys) * prod_list (map g zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map g xs) = prod_list (map g ys) * prod_list (map g zs)", "using assms"], ["proof (prove)\nusing this:\n  List.partition f xs = (ys, zs)\n\ngoal (1 subgoal):\n 1. prod_list (map g xs) = prod_list (map g ys) * prod_list (map g zs)", "by (subst prod_list_map_filter[symmetric, of _ f], auto simp: o_def)"], ["", "end"], ["", "lemma coprime_id_is_unit:\n  fixes a::\"'b::semiring_gcd\"\n  shows \"coprime a a \\<longleftrightarrow> is_unit a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime a a = is_unit a", "using dvd_unit_imp_unit"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a dvd ?b; is_unit ?b\\<rbrakk> \\<Longrightarrow> is_unit ?a\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime a a = is_unit a", "by auto"], ["", "lemma dim_vec_of_list[simp]: \"dim_vec (vec_of_list x) = length x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec_of_list x) = length x", "by (transfer, auto)"], ["", "lemma length_list_of_vec[simp]: \"length (list_of_vec A) = dim_vec A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (list_of_vec A) = dim_vec A", "by (transfer', auto)"], ["", "lemma list_of_vec_vec_of_list[simp]: \"list_of_vec (vec_of_list a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_vec (vec_of_list a) = a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_of_vec (vec_of_list a) = a", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. list_of_vec (vec_of_list a) = a", "fix aa :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. list_of_vec (vec_of_list a) = a", "have \"map (\\<lambda>n. if n < length aa then aa ! n else undef_vec (n - length aa)) [0..<length aa]\n    = map ((!) aa) [0..<length aa]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>n.\n            if n < length aa then aa ! n else undef_vec (n - length aa))\n     [0..<length aa] =\n    map ((!) aa) [0..<length aa]", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>n.\n          if n < length aa then aa ! n else undef_vec (n - length aa))\n   [0..<length aa] =\n  map ((!) aa) [0..<length aa]\n\ngoal (1 subgoal):\n 1. list_of_vec (vec_of_list a) = a", "hence \"map (\\<lambda>n. if n < length aa then aa ! n else undef_vec (n - length aa)) [0..<length aa] = aa\""], ["proof (prove)\nusing this:\n  map (\\<lambda>n.\n          if n < length aa then aa ! n else undef_vec (n - length aa))\n   [0..<length aa] =\n  map ((!) aa) [0..<length aa]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>n.\n            if n < length aa then aa ! n else undef_vec (n - length aa))\n     [0..<length aa] =\n    aa", "by (simp add: map_nth)"], ["proof (state)\nthis:\n  map (\\<lambda>n.\n          if n < length aa then aa ! n else undef_vec (n - length aa))\n   [0..<length aa] =\n  aa\n\ngoal (1 subgoal):\n 1. list_of_vec (vec_of_list a) = a", "}"], ["proof (state)\nthis:\n  map (\\<lambda>n.\n          if n < length ?aa2 then ?aa2 ! n else undef_vec (n - length ?aa2))\n   [0..<length ?aa2] =\n  ?aa2\n\ngoal (1 subgoal):\n 1. list_of_vec (vec_of_list a) = a", "thus ?thesis"], ["proof (prove)\nusing this:\n  map (\\<lambda>n.\n          if n < length ?aa2 then ?aa2 ! n else undef_vec (n - length ?aa2))\n   [0..<length ?aa2] =\n  ?aa2\n\ngoal (1 subgoal):\n 1. list_of_vec (vec_of_list a) = a", "by (transfer, simp add: mk_vec_def)"], ["proof (state)\nthis:\n  list_of_vec (vec_of_list a) = a\n\ngoal:\nNo subgoals!", "qed"], ["", "context\nassumes \"SORT_CONSTRAINT('a::finite)\"\nbegin"], ["", "lemma inj_Poly_list_of_vec': \"inj_on (Poly \\<circ> list_of_vec) {v. dim_vec v = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (Poly \\<circ> list_of_vec) {v. dim_vec v = n}", "proof (rule comp_inj_on)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on list_of_vec {v. dim_vec v = n}\n 2. inj_on Poly (list_of_vec ` {v. dim_vec v = n})", "show \"inj_on list_of_vec {v. dim_vec v = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on list_of_vec {v. dim_vec v = n}", "by (auto simp add: inj_on_def, transfer, auto simp add: mk_vec_def)"], ["proof (state)\nthis:\n  inj_on list_of_vec {v. dim_vec v = n}\n\ngoal (1 subgoal):\n 1. inj_on Poly (list_of_vec ` {v. dim_vec v = n})", "show \"inj_on Poly (list_of_vec ` {v. dim_vec v = n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Poly (list_of_vec ` {v. dim_vec v = n})", "proof (auto simp add: inj_on_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>n = dim_vec x; dim_vec y = dim_vec x;\n        Poly (list_of_vec x) = Poly (list_of_vec y)\\<rbrakk>\n       \\<Longrightarrow> list_of_vec x = list_of_vec y", "fix x y::\"'c vec\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>n = dim_vec x; dim_vec y = dim_vec x;\n        Poly (list_of_vec x) = Poly (list_of_vec y)\\<rbrakk>\n       \\<Longrightarrow> list_of_vec x = list_of_vec y", "assume \"n = dim_vec x\" and dim_xy: \"dim_vec y = dim_vec x\"\n    and Poly_eq: \"Poly (list_of_vec x) = Poly (list_of_vec y)\""], ["proof (state)\nthis:\n  n = dim_vec x\n  dim_vec y = dim_vec x\n  Poly (list_of_vec x) = Poly (list_of_vec y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>n = dim_vec x; dim_vec y = dim_vec x;\n        Poly (list_of_vec x) = Poly (list_of_vec y)\\<rbrakk>\n       \\<Longrightarrow> list_of_vec x = list_of_vec y", "note [simp del] = nth_list_of_vec"], ["proof (state)\nthis:\n  ?i < dim_vec ?v \\<Longrightarrow> list_of_vec ?v ! ?i = ?v $ ?i\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>n = dim_vec x; dim_vec y = dim_vec x;\n        Poly (list_of_vec x) = Poly (list_of_vec y)\\<rbrakk>\n       \\<Longrightarrow> list_of_vec x = list_of_vec y", "show \"list_of_vec x = list_of_vec y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_vec x = list_of_vec y", "proof (rule nth_equalityI, auto simp: dim_xy)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec x \\<Longrightarrow> list_of_vec x ! i = list_of_vec y ! i", "have length_eq: \"length (list_of_vec x ) = length (list_of_vec y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (list_of_vec x) = length (list_of_vec y)", "using dim_xy"], ["proof (prove)\nusing this:\n  dim_vec y = dim_vec x\n\ngoal (1 subgoal):\n 1. length (list_of_vec x) = length (list_of_vec y)", "by (transfer, auto)"], ["proof (state)\nthis:\n  length (list_of_vec x) = length (list_of_vec y)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec x \\<Longrightarrow> list_of_vec x ! i = list_of_vec y ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec x \\<Longrightarrow> list_of_vec x ! i = list_of_vec y ! i", "assume \"i < dim_vec x\""], ["proof (state)\nthis:\n  i < dim_vec x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec x \\<Longrightarrow> list_of_vec x ! i = list_of_vec y ! i", "thus \"list_of_vec x ! i = list_of_vec y ! i\""], ["proof (prove)\nusing this:\n  i < dim_vec x\n\ngoal (1 subgoal):\n 1. list_of_vec x ! i = list_of_vec y ! i", "using Poly_eq"], ["proof (prove)\nusing this:\n  i < dim_vec x\n  Poly (list_of_vec x) = Poly (list_of_vec y)\n\ngoal (1 subgoal):\n 1. list_of_vec x ! i = list_of_vec y ! i", "unfolding poly_eq_iff coeff_Poly_eq"], ["proof (prove)\nusing this:\n  i < dim_vec x\n  \\<forall>n.\n     nth_default (0::'c) (list_of_vec x) n =\n     nth_default (0::'c) (list_of_vec y) n\n\ngoal (1 subgoal):\n 1. list_of_vec x ! i = list_of_vec y ! i", "using dim_xy"], ["proof (prove)\nusing this:\n  i < dim_vec x\n  \\<forall>n.\n     nth_default (0::'c) (list_of_vec x) n =\n     nth_default (0::'c) (list_of_vec y) n\n  dim_vec y = dim_vec x\n\ngoal (1 subgoal):\n 1. list_of_vec x ! i = list_of_vec y ! i", "unfolding nth_default_def"], ["proof (prove)\nusing this:\n  i < dim_vec x\n  \\<forall>n.\n     (if n < length (list_of_vec x) then list_of_vec x ! n else (0::'c)) =\n     (if n < length (list_of_vec y) then list_of_vec y ! n else (0::'c))\n  dim_vec y = dim_vec x\n\ngoal (1 subgoal):\n 1. list_of_vec x ! i = list_of_vec y ! i", "by (auto, presburger)"], ["proof (state)\nthis:\n  list_of_vec x ! i = list_of_vec y ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_of_vec x = list_of_vec y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on Poly (list_of_vec ` {v. dim_vec v = n})\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary inj_Poly_list_of_vec: \"inj_on (Poly \\<circ> list_of_vec) (carrier_vec n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (Poly \\<circ> list_of_vec) (carrier_vec n)", "using inj_Poly_list_of_vec'"], ["proof (prove)\nusing this:\n  inj_on (Poly \\<circ> list_of_vec) {v. dim_vec v = ?n}\n\ngoal (1 subgoal):\n 1. inj_on (Poly \\<circ> list_of_vec) (carrier_vec n)", "unfolding carrier_vec_def"], ["proof (prove)\nusing this:\n  inj_on (Poly \\<circ> list_of_vec) {v. dim_vec v = ?n}\n\ngoal (1 subgoal):\n 1. inj_on (Poly \\<circ> list_of_vec) {v. dim_vec v = n}", "."], ["", "lemma list_of_vec_rw_map: \"list_of_vec m = map (\\<lambda>n. m $ n) [0..<dim_vec m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_vec m = map (($) m) [0..<dim_vec m]", "by (transfer, auto simp add: mk_vec_def)"], ["", "lemma degree_Poly':\nassumes xs: \"xs \\<noteq> []\"\nshows \"degree (Poly xs) < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Poly xs) < length xs", "using xs"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. degree (Poly xs) < length xs", "by (induct xs, auto intro: Poly.simps(1))"], ["", "lemma vec_of_list_list_of_vec[simp]: \"vec_of_list (list_of_vec a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (list_of_vec a) = a", "by (transfer, auto simp add: mk_vec_def)"], ["", "lemma row_mat_of_rows_list:\nassumes b: \"b < length A\"\nand nc: \"\\<forall>i. i < length A \\<longrightarrow> length (A ! i) = nc\"\nshows \"(row (mat_of_rows_list nc A) b) = vec_of_list (A ! b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_of_rows_list nc A) b = vec_of_list (A ! b)", "proof (auto simp add: vec_eq_iff)"], ["proof (state)\ngoal (2 subgoals):\n 1. dim_col (mat_of_rows_list nc A) = length (A ! b)\n 2. \\<And>i.\n       i < length (A ! b) \\<Longrightarrow>\n       row (mat_of_rows_list nc A) b $ i = vec_of_list (A ! b) $ i", "show \"dim_col (mat_of_rows_list nc A) = length (A ! b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (mat_of_rows_list nc A) = length (A ! b)", "unfolding mat_of_rows_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (mat (length A) nc (\\<lambda>(i, y). A ! i ! y)) =\n    length (A ! b)", "using b nc"], ["proof (prove)\nusing this:\n  b < length A\n  \\<forall>i<length A. length (A ! i) = nc\n\ngoal (1 subgoal):\n 1. dim_col (mat (length A) nc (\\<lambda>(i, y). A ! i ! y)) =\n    length (A ! b)", "by auto"], ["proof (state)\nthis:\n  dim_col (mat_of_rows_list nc A) = length (A ! b)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (A ! b) \\<Longrightarrow>\n       row (mat_of_rows_list nc A) b $ i = vec_of_list (A ! b) $ i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (A ! b) \\<Longrightarrow>\n       row (mat_of_rows_list nc A) b $ i = vec_of_list (A ! b) $ i", "assume i: \"i < length (A ! b)\""], ["proof (state)\nthis:\n  i < length (A ! b)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (A ! b) \\<Longrightarrow>\n       row (mat_of_rows_list nc A) b $ i = vec_of_list (A ! b) $ i", "show \"row (mat_of_rows_list nc A) b $ i = vec_of_list (A ! b) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_of_rows_list nc A) b $ i = vec_of_list (A ! b) $ i", "using i b nc"], ["proof (prove)\nusing this:\n  i < length (A ! b)\n  b < length A\n  \\<forall>i<length A. length (A ! i) = nc\n\ngoal (1 subgoal):\n 1. row (mat_of_rows_list nc A) b $ i = vec_of_list (A ! b) $ i", "unfolding mat_of_rows_list_def row_def"], ["proof (prove)\nusing this:\n  i < length (A ! b)\n  b < length A\n  \\<forall>i<length A. length (A ! i) = nc\n\ngoal (1 subgoal):\n 1. vec (dim_col (mat (length A) nc (\\<lambda>(i, y). A ! i ! y)))\n     (\\<lambda>j.\n         mat (length A) nc (\\<lambda>(i, y). A ! i ! y) $$ (b, j)) $\n    i =\n    vec_of_list (A ! b) $ i", "by (transfer, auto simp add: mk_vec_def mk_mat_def)"], ["proof (state)\nthis:\n  row (mat_of_rows_list nc A) b $ i = vec_of_list (A ! b) $ i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_Poly_list_of_vec:\nassumes n: \"x \\<in> carrier_vec n\"\nand n0: \"n > 0\"\nshows \"degree (Poly (list_of_vec x)) < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec x)) < n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec x)) < n", "have x_dim: \"dim_vec x = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec x = n", "using n"], ["proof (prove)\nusing this:\n  x \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec x = n", "by auto"], ["proof (state)\nthis:\n  dim_vec x = n\n\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec x)) < n", "have l: \"(list_of_vec x) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_vec x \\<noteq> []", "by (auto simp add: list_of_vec_rw_map vec_of_dim_0[symmetric] n0 n x_dim)"], ["proof (state)\nthis:\n  list_of_vec x \\<noteq> []\n\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec x)) < n", "have \"degree (Poly (list_of_vec x)) < length (list_of_vec x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec x)) < length (list_of_vec x)", "by (rule degree_Poly'[OF l])"], ["proof (state)\nthis:\n  degree (Poly (list_of_vec x)) < length (list_of_vec x)\n\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec x)) < n", "also"], ["proof (state)\nthis:\n  degree (Poly (list_of_vec x)) < length (list_of_vec x)\n\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec x)) < n", "have \"... = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (list_of_vec x) = n", "using x_dim"], ["proof (prove)\nusing this:\n  dim_vec x = n\n\ngoal (1 subgoal):\n 1. length (list_of_vec x) = n", "by auto"], ["proof (state)\nthis:\n  length (list_of_vec x) = n\n\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec x)) < n", "finally"], ["proof (chain)\npicking this:\n  degree (Poly (list_of_vec x)) < n", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (Poly (list_of_vec x)) < n\n\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec x)) < n", "."], ["proof (state)\nthis:\n  degree (Poly (list_of_vec x)) < n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_of_vec_nth:\n  assumes i: \"i < dim_vec x\"\n  shows \"list_of_vec x ! i = x $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_vec x ! i = x $ i", "using i"], ["proof (prove)\nusing this:\n  i < dim_vec x\n\ngoal (1 subgoal):\n 1. list_of_vec x ! i = x $ i", "by (transfer, auto simp add: mk_vec_def)"], ["", "lemma coeff_Poly_list_of_vec_nth':\n assumes i: \"i < dim_vec x\"\n shows \"coeff (Poly (list_of_vec x)) i = x $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (Poly (list_of_vec x)) i = x $ i", "using i"], ["proof (prove)\nusing this:\n  i < dim_vec x\n\ngoal (1 subgoal):\n 1. coeff (Poly (list_of_vec x)) i = x $ i", "by (auto simp add: list_of_vec_nth nth_default_def)"], ["", "lemma list_of_vec_row_nth:\nassumes x: \"x < dim_col A\"\nshows \"list_of_vec (row A i) ! x = A $$ (i, x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_vec (row A i) ! x = A $$ (i, x)", "using x"], ["proof (prove)\nusing this:\n  x < dim_col A\n\ngoal (1 subgoal):\n 1. list_of_vec (row A i) ! x = A $$ (i, x)", "unfolding row_def"], ["proof (prove)\nusing this:\n  x < dim_col A\n\ngoal (1 subgoal):\n 1. list_of_vec (vec (dim_col A) (\\<lambda>j. A $$ (i, j))) ! x =\n    A $$ (i, x)", "by (transfer', auto simp add: mk_vec_def)"], ["", "lemma coeff_Poly_list_of_vec_nth:\nassumes x: \"x < dim_col A\"\nshows \"coeff (Poly (list_of_vec (row A i))) x = A $$ (i, x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (Poly (list_of_vec (row A i))) x = A $$ (i, x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (Poly (list_of_vec (row A i))) x = A $$ (i, x)", "have \"coeff (Poly (list_of_vec (row A i))) x  = nth_default 0 (list_of_vec (row A i)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (Poly (list_of_vec (row A i))) x =\n    nth_default (0::'b) (list_of_vec (row A i)) x", "unfolding coeff_Poly_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default (0::'b) (list_of_vec (row A i)) x =\n    nth_default (0::'b) (list_of_vec (row A i)) x", "by simp"], ["proof (state)\nthis:\n  coeff (Poly (list_of_vec (row A i))) x =\n  nth_default (0::'b) (list_of_vec (row A i)) x\n\ngoal (1 subgoal):\n 1. coeff (Poly (list_of_vec (row A i))) x = A $$ (i, x)", "also"], ["proof (state)\nthis:\n  coeff (Poly (list_of_vec (row A i))) x =\n  nth_default (0::'b) (list_of_vec (row A i)) x\n\ngoal (1 subgoal):\n 1. coeff (Poly (list_of_vec (row A i))) x = A $$ (i, x)", "have \"... = A $$ (i, x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default (0::'b) (list_of_vec (row A i)) x = A $$ (i, x)", "using x list_of_vec_row_nth"], ["proof (prove)\nusing this:\n  x < dim_col A\n  ?x < dim_col ?A \\<Longrightarrow>\n  list_of_vec (row ?A ?i) ! ?x = ?A $$ (?i, ?x)\n\ngoal (1 subgoal):\n 1. nth_default (0::'b) (list_of_vec (row A i)) x = A $$ (i, x)", "unfolding nth_default_def"], ["proof (prove)\nusing this:\n  x < dim_col A\n  ?x < dim_col ?A \\<Longrightarrow>\n  list_of_vec (row ?A ?i) ! ?x = ?A $$ (?i, ?x)\n\ngoal (1 subgoal):\n 1. (if x < length (list_of_vec (row A i)) then list_of_vec (row A i) ! x\n     else (0::'b)) =\n    A $$ (i, x)", "by (auto simp del: nth_list_of_vec)"], ["proof (state)\nthis:\n  nth_default (0::'b) (list_of_vec (row A i)) x = A $$ (i, x)\n\ngoal (1 subgoal):\n 1. coeff (Poly (list_of_vec (row A i))) x = A $$ (i, x)", "finally"], ["proof (chain)\npicking this:\n  coeff (Poly (list_of_vec (row A i))) x = A $$ (i, x)", "show ?thesis"], ["proof (prove)\nusing this:\n  coeff (Poly (list_of_vec (row A i))) x = A $$ (i, x)\n\ngoal (1 subgoal):\n 1. coeff (Poly (list_of_vec (row A i))) x = A $$ (i, x)", "."], ["proof (state)\nthis:\n  coeff (Poly (list_of_vec (row A i))) x = A $$ (i, x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_on_list_of_vec: \"inj_on list_of_vec (carrier_vec n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on list_of_vec (carrier_vec n)", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>carrier_vec n.\n       \\<forall>y\\<in>carrier_vec n.\n          list_of_vec x = list_of_vec y \\<longrightarrow> x = y", "unfolding list_of_vec_rw_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>carrier_vec n.\n       \\<forall>y\\<in>carrier_vec n.\n          map (($) x) [0..<dim_vec x] =\n          map (($) y) [0..<dim_vec y] \\<longrightarrow>\n          x = y", "by auto"], ["", "lemma vec_of_list_carrier[simp]: \"vec_of_list x \\<in> carrier_vec (length x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list x \\<in> carrier_vec (length x)", "unfolding carrier_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list x \\<in> {v. dim_vec v = length x}", "by simp"], ["", "lemma card_carrier_vec: \"card (carrier_vec n:: 'b::finite vec set) = CARD('b) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (carrier_vec n) = CARD('b) ^ n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (carrier_vec n) = CARD('b) ^ n", "let ?A = \"UNIV::'b set\""], ["proof (state)\ngoal (1 subgoal):\n 1. card (carrier_vec n) = CARD('b) ^ n", "let ?B = \"{xs. set xs \\<subseteq> ?A \\<and> length xs = n}\""], ["proof (state)\ngoal (1 subgoal):\n 1. card (carrier_vec n) = CARD('b) ^ n", "let ?C = \"(carrier_vec n:: 'b::finite vec set)\""], ["proof (state)\ngoal (1 subgoal):\n 1. card (carrier_vec n) = CARD('b) ^ n", "have \"card ?C = card ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (carrier_vec n) =\n    card {xs. set xs \\<subseteq> UNIV \\<and> length xs = n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (carrier_vec n) =\n    card {xs. set xs \\<subseteq> UNIV \\<and> length xs = n}", "have \"bij_betw (list_of_vec) ?C ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw list_of_vec (carrier_vec n)\n     {xs. set xs \\<subseteq> UNIV \\<and> length xs = n}", "proof (unfold bij_betw_def, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on list_of_vec (carrier_vec n)\n 2. \\<And>x.\n       n = length x \\<Longrightarrow>\n       x \\<in> list_of_vec ` carrier_vec (length x)", "show \"inj_on list_of_vec (carrier_vec n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on list_of_vec (carrier_vec n)", "by (rule inj_on_list_of_vec)"], ["proof (state)\nthis:\n  inj_on list_of_vec (carrier_vec n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       n = length x \\<Longrightarrow>\n       x \\<in> list_of_vec ` carrier_vec (length x)", "fix x::\"'b list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       n = length x \\<Longrightarrow>\n       x \\<in> list_of_vec ` carrier_vec (length x)", "assume n: \"n = length x\""], ["proof (state)\nthis:\n  n = length x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       n = length x \\<Longrightarrow>\n       x \\<in> list_of_vec ` carrier_vec (length x)", "thus \"x \\<in> list_of_vec ` carrier_vec (length x)\""], ["proof (prove)\nusing this:\n  n = length x\n\ngoal (1 subgoal):\n 1. x \\<in> list_of_vec ` carrier_vec (length x)", "unfolding image_def"], ["proof (prove)\nusing this:\n  n = length x\n\ngoal (1 subgoal):\n 1. x \\<in> {y. \\<exists>x\\<in>carrier_vec (length x). y = list_of_vec x}", "by auto (rule bexI[of _ \"vec_of_list x\"], auto)"], ["proof (state)\nthis:\n  x \\<in> list_of_vec ` carrier_vec (length x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bij_betw list_of_vec (carrier_vec n)\n   {xs. set xs \\<subseteq> UNIV \\<and> length xs = n}\n\ngoal (1 subgoal):\n 1. card (carrier_vec n) =\n    card {xs. set xs \\<subseteq> UNIV \\<and> length xs = n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  bij_betw list_of_vec (carrier_vec n)\n   {xs. set xs \\<subseteq> UNIV \\<and> length xs = n}\n\ngoal (1 subgoal):\n 1. card (carrier_vec n) =\n    card {xs. set xs \\<subseteq> UNIV \\<and> length xs = n}", "using bij_betw_same_card"], ["proof (prove)\nusing this:\n  bij_betw list_of_vec (carrier_vec n)\n   {xs. set xs \\<subseteq> UNIV \\<and> length xs = n}\n  bij_betw ?f ?A ?B \\<Longrightarrow> card ?A = card ?B\n\ngoal (1 subgoal):\n 1. card (carrier_vec n) =\n    card {xs. set xs \\<subseteq> UNIV \\<and> length xs = n}", "by blast"], ["proof (state)\nthis:\n  card (carrier_vec n) =\n  card {xs. set xs \\<subseteq> UNIV \\<and> length xs = n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (carrier_vec n) =\n  card {xs. set xs \\<subseteq> UNIV \\<and> length xs = n}\n\ngoal (1 subgoal):\n 1. card (carrier_vec n) = CARD('b) ^ n", "also"], ["proof (state)\nthis:\n  card (carrier_vec n) =\n  card {xs. set xs \\<subseteq> UNIV \\<and> length xs = n}\n\ngoal (1 subgoal):\n 1. card (carrier_vec n) = CARD('b) ^ n", "have \"... = card ?A ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {xs. set xs \\<subseteq> UNIV \\<and> length xs = n} = CARD('b) ^ n", "by (rule card_lists_length_eq, simp)"], ["proof (state)\nthis:\n  card {xs. set xs \\<subseteq> UNIV \\<and> length xs = n} = CARD('b) ^ n\n\ngoal (1 subgoal):\n 1. card (carrier_vec n) = CARD('b) ^ n", "finally"], ["proof (chain)\npicking this:\n  card (carrier_vec n) = CARD('b) ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  card (carrier_vec n) = CARD('b) ^ n\n\ngoal (1 subgoal):\n 1. card (carrier_vec n) = CARD('b) ^ n", "."], ["proof (state)\nthis:\n  card (carrier_vec n) = CARD('b) ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_carrier_vec[simp]: \"finite (carrier_vec n:: 'b::finite vec set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (carrier_vec n)", "by (rule card_ge_0_finite, unfold card_carrier_vec, auto)"], ["", "lemma row_echelon_form_dim0_row:\nassumes \"A \\<in> carrier_mat 0 n\"\nshows \"row_echelon_form A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form A", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat 0 n\n\ngoal (1 subgoal):\n 1. row_echelon_form A", "unfolding row_echelon_form_def pivot_fun_def Let_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat 0 n\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>i<dim_row A.\n          f i \\<le> dim_col A \\<and>\n          (f i < dim_col A \\<longrightarrow>\n           A $$ (i, f i) = (1::'b) \\<and>\n           (\\<forall>i'<dim_row A.\n               i' \\<noteq> i \\<longrightarrow>\n               A $$ (i', f i) = (0::'b))) \\<and>\n          (\\<forall>j<f i. A $$ (i, j) = (0::'b)) \\<and>\n          (Suc i < dim_row A \\<longrightarrow>\n           f i < f (Suc i) \\<or> f (Suc i) = dim_col A)", "by auto"], ["", "lemma row_echelon_form_dim0_col:\nassumes \"A \\<in> carrier_mat n 0\"\nshows \"row_echelon_form A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form A", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n 0\n\ngoal (1 subgoal):\n 1. row_echelon_form A", "unfolding row_echelon_form_def pivot_fun_def Let_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n 0\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>i<dim_row A.\n          f i \\<le> dim_col A \\<and>\n          (f i < dim_col A \\<longrightarrow>\n           A $$ (i, f i) = (1::'b) \\<and>\n           (\\<forall>i'<dim_row A.\n               i' \\<noteq> i \\<longrightarrow>\n               A $$ (i', f i) = (0::'b))) \\<and>\n          (\\<forall>j<f i. A $$ (i, j) = (0::'b)) \\<and>\n          (Suc i < dim_row A \\<longrightarrow>\n           f i < f (Suc i) \\<or> f (Suc i) = dim_col A)", "by auto"], ["", "lemma row_echelon_form_one_dim0[simp]: \"row_echelon_form (1\\<^sub>m 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form (1\\<^sub>m 0)", "unfolding row_echelon_form_def pivot_fun_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>i<dim_row (1\\<^sub>m 0).\n          f i \\<le> dim_col (1\\<^sub>m 0) \\<and>\n          (f i < dim_col (1\\<^sub>m 0) \\<longrightarrow>\n           1\\<^sub>m 0 $$ (i, f i) = (1::'b) \\<and>\n           (\\<forall>i'<dim_row (1\\<^sub>m 0).\n               i' \\<noteq> i \\<longrightarrow>\n               1\\<^sub>m 0 $$ (i', f i) = (0::'b))) \\<and>\n          (\\<forall>j<f i. 1\\<^sub>m 0 $$ (i, j) = (0::'b)) \\<and>\n          (Suc i < dim_row (1\\<^sub>m 0) \\<longrightarrow>\n           f i < f (Suc i) \\<or> f (Suc i) = dim_col (1\\<^sub>m 0))", "by auto"], ["", "lemma Poly_list_of_vec_0[simp]: \"Poly (list_of_vec (0\\<^sub>v 0)) = [:0:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly (list_of_vec (0\\<^sub>v 0)) = [:0::'b:]", "by (simp add: poly_eq_iff nth_default_def)"], ["", "lemma monic_normalize:\nassumes \"(p :: 'b :: {field,euclidean_ring_gcd} poly) \\<noteq> 0\" shows \"monic (normalize p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (normalize p)", "by (simp add: assms normalize_poly_old_def)"], ["", "lemma exists_factorization_prod_list:\nfixes P::\"'b::field poly list\"\nassumes \"degree (prod_list P) > 0\"\n  and \"\\<And> u. u \\<in> set P \\<Longrightarrow> degree u > 0 \\<and> monic u\"\n  and \"square_free (prod_list P)\"\nshows \"\\<exists>Q. prod_list Q = prod_list P \\<and> length P \\<le> length Q\n           \\<and> (\\<forall>u. u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q.\n       prod_list Q = prod_list P \\<and>\n       length P \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "using assms"], ["proof (prove)\nusing this:\n  0 < degree (prod_list P)\n  ?u \\<in> set P \\<Longrightarrow> 0 < degree ?u \\<and> monic ?u\n  square_free (prod_list P)\n\ngoal (1 subgoal):\n 1. \\<exists>Q.\n       prod_list Q = prod_list P \\<and>\n       length P \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "proof (induct P)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < degree (prod_list []);\n     \\<And>u. u \\<in> set [] \\<Longrightarrow> 0 < degree u \\<and> monic u;\n     square_free (prod_list [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Q.\n                         prod_list Q = prod_list [] \\<and>\n                         length [] \\<le> length Q \\<and>\n                         (\\<forall>u.\n                             u \\<in> set Q \\<longrightarrow>\n                             irreducible u \\<and> monic u)\n 2. \\<And>a P.\n       \\<lbrakk>\\<lbrakk>0 < degree (prod_list P);\n                 \\<And>u.\n                    u \\<in> set P \\<Longrightarrow>\n                    0 < degree u \\<and> monic u;\n                 square_free (prod_list P)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Q.\n                                     prod_list Q = prod_list P \\<and>\n                                     length P \\<le> length Q \\<and>\n                                     (\\<forall>u.\n   u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u);\n        0 < degree (prod_list (a # P));\n        \\<And>u.\n           u \\<in> set (a # P) \\<Longrightarrow>\n           0 < degree u \\<and> monic u;\n        square_free (prod_list (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q.\n                            prod_list Q = prod_list (a # P) \\<and>\n                            length (a # P) \\<le> length Q \\<and>\n                            (\\<forall>u.\n                                u \\<in> set Q \\<longrightarrow>\n                                irreducible u \\<and> monic u)", "case Nil"], ["proof (state)\nthis:\n  0 < degree (prod_list [])\n  ?u \\<in> set [] \\<Longrightarrow> 0 < degree ?u \\<and> monic ?u\n  square_free (prod_list [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < degree (prod_list []);\n     \\<And>u. u \\<in> set [] \\<Longrightarrow> 0 < degree u \\<and> monic u;\n     square_free (prod_list [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Q.\n                         prod_list Q = prod_list [] \\<and>\n                         length [] \\<le> length Q \\<and>\n                         (\\<forall>u.\n                             u \\<in> set Q \\<longrightarrow>\n                             irreducible u \\<and> monic u)\n 2. \\<And>a P.\n       \\<lbrakk>\\<lbrakk>0 < degree (prod_list P);\n                 \\<And>u.\n                    u \\<in> set P \\<Longrightarrow>\n                    0 < degree u \\<and> monic u;\n                 square_free (prod_list P)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Q.\n                                     prod_list Q = prod_list P \\<and>\n                                     length P \\<le> length Q \\<and>\n                                     (\\<forall>u.\n   u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u);\n        0 < degree (prod_list (a # P));\n        \\<And>u.\n           u \\<in> set (a # P) \\<Longrightarrow>\n           0 < degree u \\<and> monic u;\n        square_free (prod_list (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q.\n                            prod_list Q = prod_list (a # P) \\<and>\n                            length (a # P) \\<le> length Q \\<and>\n                            (\\<forall>u.\n                                u \\<in> set Q \\<longrightarrow>\n                                irreducible u \\<and> monic u)", "thus ?case"], ["proof (prove)\nusing this:\n  0 < degree (prod_list [])\n  ?u \\<in> set [] \\<Longrightarrow> 0 < degree ?u \\<and> monic ?u\n  square_free (prod_list [])\n\ngoal (1 subgoal):\n 1. \\<exists>Q.\n       prod_list Q = prod_list [] \\<and>\n       length [] \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "by auto"], ["proof (state)\nthis:\n  \\<exists>Q.\n     prod_list Q = prod_list [] \\<and>\n     length [] \\<le> length Q \\<and>\n     (\\<forall>u.\n         u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>\\<lbrakk>0 < degree (prod_list P);\n                 \\<And>u.\n                    u \\<in> set P \\<Longrightarrow>\n                    0 < degree u \\<and> monic u;\n                 square_free (prod_list P)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Q.\n                                     prod_list Q = prod_list P \\<and>\n                                     length P \\<le> length Q \\<and>\n                                     (\\<forall>u.\n   u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u);\n        0 < degree (prod_list (a # P));\n        \\<And>u.\n           u \\<in> set (a # P) \\<Longrightarrow>\n           0 < degree u \\<and> monic u;\n        square_free (prod_list (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q.\n                            prod_list Q = prod_list (a # P) \\<and>\n                            length (a # P) \\<le> length Q \\<and>\n                            (\\<forall>u.\n                                u \\<in> set Q \\<longrightarrow>\n                                irreducible u \\<and> monic u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>\\<lbrakk>0 < degree (prod_list P);\n                 \\<And>u.\n                    u \\<in> set P \\<Longrightarrow>\n                    0 < degree u \\<and> monic u;\n                 square_free (prod_list P)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Q.\n                                     prod_list Q = prod_list P \\<and>\n                                     length P \\<le> length Q \\<and>\n                                     (\\<forall>u.\n   u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u);\n        0 < degree (prod_list (a # P));\n        \\<And>u.\n           u \\<in> set (a # P) \\<Longrightarrow>\n           0 < degree u \\<and> monic u;\n        square_free (prod_list (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q.\n                            prod_list Q = prod_list (a # P) \\<and>\n                            length (a # P) \\<le> length Q \\<and>\n                            (\\<forall>u.\n                                u \\<in> set Q \\<longrightarrow>\n                                irreducible u \\<and> monic u)", "case (Cons x P)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < degree (prod_list P);\n   \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u;\n   square_free (prod_list P)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q.\n                       prod_list Q = prod_list P \\<and>\n                       length P \\<le> length Q \\<and>\n                       (\\<forall>u.\n                           u \\<in> set Q \\<longrightarrow>\n                           irreducible u \\<and> monic u)\n  0 < degree (prod_list (x # P))\n  ?u \\<in> set (x # P) \\<Longrightarrow> 0 < degree ?u \\<and> monic ?u\n  square_free (prod_list (x # P))\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>\\<lbrakk>0 < degree (prod_list P);\n                 \\<And>u.\n                    u \\<in> set P \\<Longrightarrow>\n                    0 < degree u \\<and> monic u;\n                 square_free (prod_list P)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Q.\n                                     prod_list Q = prod_list P \\<and>\n                                     length P \\<le> length Q \\<and>\n                                     (\\<forall>u.\n   u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u);\n        0 < degree (prod_list (a # P));\n        \\<And>u.\n           u \\<in> set (a # P) \\<Longrightarrow>\n           0 < degree u \\<and> monic u;\n        square_free (prod_list (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q.\n                            prod_list Q = prod_list (a # P) \\<and>\n                            length (a # P) \\<le> length Q \\<and>\n                            (\\<forall>u.\n                                u \\<in> set Q \\<longrightarrow>\n                                irreducible u \\<and> monic u)", "have sf_P: \"square_free (prod_list P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (prod_list P)", "by (metis Cons.prems(3) dvd_triv_left prod_list.Cons mult.commute square_free_factor)"], ["proof (state)\nthis:\n  square_free (prod_list P)\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>\\<lbrakk>0 < degree (prod_list P);\n                 \\<And>u.\n                    u \\<in> set P \\<Longrightarrow>\n                    0 < degree u \\<and> monic u;\n                 square_free (prod_list P)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Q.\n                                     prod_list Q = prod_list P \\<and>\n                                     length P \\<le> length Q \\<and>\n                                     (\\<forall>u.\n   u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u);\n        0 < degree (prod_list (a # P));\n        \\<And>u.\n           u \\<in> set (a # P) \\<Longrightarrow>\n           0 < degree u \\<and> monic u;\n        square_free (prod_list (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q.\n                            prod_list Q = prod_list (a # P) \\<and>\n                            length (a # P) \\<le> length Q \\<and>\n                            (\\<forall>u.\n                                u \\<in> set Q \\<longrightarrow>\n                                irreducible u \\<and> monic u)", "have deg_x: \"degree x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree x", "using Cons.prems"], ["proof (prove)\nusing this:\n  0 < degree (prod_list (x # P))\n  ?u \\<in> set (x # P) \\<Longrightarrow> 0 < degree ?u \\<and> monic ?u\n  square_free (prod_list (x # P))\n\ngoal (1 subgoal):\n 1. 0 < degree x", "by auto"], ["proof (state)\nthis:\n  0 < degree x\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>\\<lbrakk>0 < degree (prod_list P);\n                 \\<And>u.\n                    u \\<in> set P \\<Longrightarrow>\n                    0 < degree u \\<and> monic u;\n                 square_free (prod_list P)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Q.\n                                     prod_list Q = prod_list P \\<and>\n                                     length P \\<le> length Q \\<and>\n                                     (\\<forall>u.\n   u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u);\n        0 < degree (prod_list (a # P));\n        \\<And>u.\n           u \\<in> set (a # P) \\<Longrightarrow>\n           0 < degree u \\<and> monic u;\n        square_free (prod_list (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q.\n                            prod_list Q = prod_list (a # P) \\<and>\n                            length (a # P) \\<le> length Q \\<and>\n                            (\\<forall>u.\n                                u \\<in> set Q \\<longrightarrow>\n                                irreducible u \\<and> monic u)", "have distinct_P: \"distinct P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct P", "by (meson Cons.prems(2) Cons.prems(3) distinct.simps(2) square_free_prod_list_distinct)"], ["proof (state)\nthis:\n  distinct P\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>\\<lbrakk>0 < degree (prod_list P);\n                 \\<And>u.\n                    u \\<in> set P \\<Longrightarrow>\n                    0 < degree u \\<and> monic u;\n                 square_free (prod_list P)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Q.\n                                     prod_list Q = prod_list P \\<and>\n                                     length P \\<le> length Q \\<and>\n                                     (\\<forall>u.\n   u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u);\n        0 < degree (prod_list (a # P));\n        \\<And>u.\n           u \\<in> set (a # P) \\<Longrightarrow>\n           0 < degree u \\<and> monic u;\n        square_free (prod_list (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q.\n                            prod_list Q = prod_list (a # P) \\<and>\n                            length (a # P) \\<le> length Q \\<and>\n                            (\\<forall>u.\n                                u \\<in> set Q \\<longrightarrow>\n                                irreducible u \\<and> monic u)", "have \"\\<exists>A. finite A \\<and> x = \\<Prod>A \\<and> A \\<subseteq> {q. irreducible q \\<and> monic q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       finite A \\<and>\n       x = \\<Prod>A \\<and> A \\<subseteq> {q. irreducible q \\<and> monic q}", "proof (rule monic_square_free_irreducible_factorization)"], ["proof (state)\ngoal (2 subgoals):\n 1. monic x\n 2. square_free x", "show \"monic x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic x", "by (simp add: Cons.prems(2))"], ["proof (state)\nthis:\n  monic x\n\ngoal (1 subgoal):\n 1. square_free x", "show \"square_free x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free x", "by (metis Cons.prems(3) dvd_triv_left prod_list.Cons square_free_factor)"], ["proof (state)\nthis:\n  square_free x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>A.\n     finite A \\<and>\n     x = \\<Prod>A \\<and> A \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>\\<lbrakk>0 < degree (prod_list P);\n                 \\<And>u.\n                    u \\<in> set P \\<Longrightarrow>\n                    0 < degree u \\<and> monic u;\n                 square_free (prod_list P)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Q.\n                                     prod_list Q = prod_list P \\<and>\n                                     length P \\<le> length Q \\<and>\n                                     (\\<forall>u.\n   u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u);\n        0 < degree (prod_list (a # P));\n        \\<And>u.\n           u \\<in> set (a # P) \\<Longrightarrow>\n           0 < degree u \\<and> monic u;\n        square_free (prod_list (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q.\n                            prod_list Q = prod_list (a # P) \\<and>\n                            length (a # P) \\<le> length Q \\<and>\n                            (\\<forall>u.\n                                u \\<in> set Q \\<longrightarrow>\n                                irreducible u \\<and> monic u)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>A.\n     finite A \\<and>\n     x = \\<Prod>A \\<and> A \\<subseteq> {q. irreducible q \\<and> monic q}", "obtain A where fin_A: \"finite A\"\n    and xA: \"x = \\<Prod>A\"\n    and A: \"A \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\""], ["proof (prove)\nusing this:\n  \\<exists>A.\n     finite A \\<and>\n     x = \\<Prod>A \\<and> A \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>finite A; x = \\<Prod>A;\n         A \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite A\n  x = \\<Prod>A\n  A \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>\\<lbrakk>0 < degree (prod_list P);\n                 \\<And>u.\n                    u \\<in> set P \\<Longrightarrow>\n                    0 < degree u \\<and> monic u;\n                 square_free (prod_list P)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Q.\n                                     prod_list Q = prod_list P \\<and>\n                                     length P \\<le> length Q \\<and>\n                                     (\\<forall>u.\n   u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u);\n        0 < degree (prod_list (a # P));\n        \\<And>u.\n           u \\<in> set (a # P) \\<Longrightarrow>\n           0 < degree u \\<and> monic u;\n        square_free (prod_list (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q.\n                            prod_list Q = prod_list (a # P) \\<and>\n                            length (a # P) \\<le> length Q \\<and>\n                            (\\<forall>u.\n                                u \\<in> set Q \\<longrightarrow>\n                                irreducible u \\<and> monic u)", "obtain A' where s: \"set A' = A\" and length_A': \"length A' = card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A'.\n        \\<lbrakk>set A' = A; length A' = card A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>finite A\\<close> distinct_card finite_distinct_list"], ["proof (prove)\nusing this:\n  finite A\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n  finite ?A \\<Longrightarrow> \\<exists>xs. set xs = ?A \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>A'.\n        \\<lbrakk>set A' = A; length A' = card A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  set A' = A\n  length A' = card A\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>\\<lbrakk>0 < degree (prod_list P);\n                 \\<And>u.\n                    u \\<in> set P \\<Longrightarrow>\n                    0 < degree u \\<and> monic u;\n                 square_free (prod_list P)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Q.\n                                     prod_list Q = prod_list P \\<and>\n                                     length P \\<le> length Q \\<and>\n                                     (\\<forall>u.\n   u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u);\n        0 < degree (prod_list (a # P));\n        \\<And>u.\n           u \\<in> set (a # P) \\<Longrightarrow>\n           0 < degree u \\<and> monic u;\n        square_free (prod_list (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q.\n                            prod_list Q = prod_list (a # P) \\<and>\n                            length (a # P) \\<le> length Q \\<and>\n                            (\\<forall>u.\n                                u \\<in> set Q \\<longrightarrow>\n                                irreducible u \\<and> monic u)", "have A_not_empty: \"A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {}", "using xA deg_x"], ["proof (prove)\nusing this:\n  x = \\<Prod>A\n  0 < degree x\n\ngoal (1 subgoal):\n 1. A \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>\\<lbrakk>0 < degree (prod_list P);\n                 \\<And>u.\n                    u \\<in> set P \\<Longrightarrow>\n                    0 < degree u \\<and> monic u;\n                 square_free (prod_list P)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Q.\n                                     prod_list Q = prod_list P \\<and>\n                                     length P \\<le> length Q \\<and>\n                                     (\\<forall>u.\n   u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u);\n        0 < degree (prod_list (a # P));\n        \\<And>u.\n           u \\<in> set (a # P) \\<Longrightarrow>\n           0 < degree u \\<and> monic u;\n        square_free (prod_list (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q.\n                            prod_list Q = prod_list (a # P) \\<and>\n                            length (a # P) \\<le> length Q \\<and>\n                            (\\<forall>u.\n                                u \\<in> set Q \\<longrightarrow>\n                                irreducible u \\<and> monic u)", "have x_prod_list_A': \"x = prod_list A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = prod_list A'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = prod_list A'", "have \"x = \\<Prod>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = \\<Prod>A", "using xA"], ["proof (prove)\nusing this:\n  x = \\<Prod>A\n\ngoal (1 subgoal):\n 1. x = \\<Prod>A", "by simp"], ["proof (state)\nthis:\n  x = \\<Prod>A\n\ngoal (1 subgoal):\n 1. x = prod_list A'", "also"], ["proof (state)\nthis:\n  x = \\<Prod>A\n\ngoal (1 subgoal):\n 1. x = prod_list A'", "have \"... = prod id A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>A = prod id A", "by simp"], ["proof (state)\nthis:\n  \\<Prod>A = prod id A\n\ngoal (1 subgoal):\n 1. x = prod_list A'", "also"], ["proof (state)\nthis:\n  \\<Prod>A = prod id A\n\ngoal (1 subgoal):\n 1. x = prod_list A'", "have \"... = prod id (set A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod id A = prod id (set A')", "unfolding s"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod id A = prod id A", "by simp"], ["proof (state)\nthis:\n  prod id A = prod id (set A')\n\ngoal (1 subgoal):\n 1. x = prod_list A'", "also"], ["proof (state)\nthis:\n  prod id A = prod id (set A')\n\ngoal (1 subgoal):\n 1. x = prod_list A'", "have \"... = prod_list (map id A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod id (set A') = prod_list (map id A')", "by (rule prod.distinct_set_conv_list, simp add: card_distinct length_A' s)"], ["proof (state)\nthis:\n  prod id (set A') = prod_list (map id A')\n\ngoal (1 subgoal):\n 1. x = prod_list A'", "also"], ["proof (state)\nthis:\n  prod id (set A') = prod_list (map id A')\n\ngoal (1 subgoal):\n 1. x = prod_list A'", "have \"... =  prod_list A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map id A') = prod_list A'", "by auto"], ["proof (state)\nthis:\n  prod_list (map id A') = prod_list A'\n\ngoal (1 subgoal):\n 1. x = prod_list A'", "finally"], ["proof (chain)\npicking this:\n  x = prod_list A'", "show ?thesis"], ["proof (prove)\nusing this:\n  x = prod_list A'\n\ngoal (1 subgoal):\n 1. x = prod_list A'", "."], ["proof (state)\nthis:\n  x = prod_list A'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = prod_list A'\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>\\<lbrakk>0 < degree (prod_list P);\n                 \\<And>u.\n                    u \\<in> set P \\<Longrightarrow>\n                    0 < degree u \\<and> monic u;\n                 square_free (prod_list P)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>Q.\n                                     prod_list Q = prod_list P \\<and>\n                                     length P \\<le> length Q \\<and>\n                                     (\\<forall>u.\n   u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u);\n        0 < degree (prod_list (a # P));\n        \\<And>u.\n           u \\<in> set (a # P) \\<Longrightarrow>\n           0 < degree u \\<and> monic u;\n        square_free (prod_list (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q.\n                            prod_list Q = prod_list (a # P) \\<and>\n                            length (a # P) \\<le> length Q \\<and>\n                            (\\<forall>u.\n                                u \\<in> set Q \\<longrightarrow>\n                                irreducible u \\<and> monic u)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q.\n       prod_list Q = prod_list (x # P) \\<and>\n       length (x # P) \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "proof (cases \"P = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. P = [] \\<Longrightarrow>\n    \\<exists>Q.\n       prod_list Q = prod_list (x # P) \\<and>\n       length (x # P) \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)\n 2. P \\<noteq> [] \\<Longrightarrow>\n    \\<exists>Q.\n       prod_list Q = prod_list (x # P) \\<and>\n       length (x # P) \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "case True"], ["proof (state)\nthis:\n  P = []\n\ngoal (2 subgoals):\n 1. P = [] \\<Longrightarrow>\n    \\<exists>Q.\n       prod_list Q = prod_list (x # P) \\<and>\n       length (x # P) \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)\n 2. P \\<noteq> [] \\<Longrightarrow>\n    \\<exists>Q.\n       prod_list Q = prod_list (x # P) \\<and>\n       length (x # P) \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q.\n       prod_list Q = prod_list (x # P) \\<and>\n       length (x # P) \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "proof (rule exI[of _ \"A'\"], auto simp add: True)"], ["proof (state)\ngoal (4 subgoals):\n 1. prod_list A' = x\n 2. Suc 0 \\<le> length A'\n 3. \\<And>u. u \\<in> set A' \\<Longrightarrow> irreducible u\n 4. \\<And>u. u \\<in> set A' \\<Longrightarrow> monic u", "show \"prod_list A' = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list A' = x", "using x_prod_list_A'"], ["proof (prove)\nusing this:\n  x = prod_list A'\n\ngoal (1 subgoal):\n 1. prod_list A' = x", "by simp"], ["proof (state)\nthis:\n  prod_list A' = x\n\ngoal (3 subgoals):\n 1. Suc 0 \\<le> length A'\n 2. \\<And>u. u \\<in> set A' \\<Longrightarrow> irreducible u\n 3. \\<And>u. u \\<in> set A' \\<Longrightarrow> monic u", "show \"Suc 0 \\<le> length A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 \\<le> length A'", "using A_not_empty"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Suc 0 \\<le> length A'", "using s length_A'"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n  set A' = A\n  length A' = card A\n\ngoal (1 subgoal):\n 1. Suc 0 \\<le> length A'", "by (simp add: Suc_leI card_gt_0_iff fin_A)"], ["proof (state)\nthis:\n  Suc 0 \\<le> length A'\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> set A' \\<Longrightarrow> irreducible u\n 2. \\<And>u. u \\<in> set A' \\<Longrightarrow> monic u", "show \"\\<And>u. u \\<in> set A' \\<Longrightarrow> irreducible u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set A' \\<Longrightarrow> irreducible u", "using s A"], ["proof (prove)\nusing this:\n  set A' = A\n  A \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set A' \\<Longrightarrow> irreducible u", "by auto"], ["proof (state)\nthis:\n  ?u \\<in> set A' \\<Longrightarrow> irreducible ?u\n\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set A' \\<Longrightarrow> monic u", "show \"\\<And>u. u \\<in> set A' \\<Longrightarrow> monic u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set A' \\<Longrightarrow> monic u", "using s A"], ["proof (prove)\nusing this:\n  set A' = A\n  A \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set A' \\<Longrightarrow> monic u", "by auto"], ["proof (state)\nthis:\n  ?u \\<in> set A' \\<Longrightarrow> monic ?u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q.\n     prod_list Q = prod_list (x # P) \\<and>\n     length (x # P) \\<le> length Q \\<and>\n     (\\<forall>u.\n         u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)\n\ngoal (1 subgoal):\n 1. P \\<noteq> [] \\<Longrightarrow>\n    \\<exists>Q.\n       prod_list Q = prod_list (x # P) \\<and>\n       length (x # P) \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<noteq> [] \\<Longrightarrow>\n    \\<exists>Q.\n       prod_list Q = prod_list (x # P) \\<and>\n       length (x # P) \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "case False"], ["proof (state)\nthis:\n  P \\<noteq> []\n\ngoal (1 subgoal):\n 1. P \\<noteq> [] \\<Longrightarrow>\n    \\<exists>Q.\n       prod_list Q = prod_list (x # P) \\<and>\n       length (x # P) \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "have hyp: \"\\<exists>Q. prod_list Q = prod_list P\n    \\<and> length P \\<le> length Q \\<and> (\\<forall>u. u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q.\n       prod_list Q = prod_list P \\<and>\n       length P \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "proof (rule Cons.hyps[OF _ _ sf_P])"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < degree (prod_list P)\n 2. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "have set_P: \"set P \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set P \\<noteq> {}", "using False"], ["proof (prove)\nusing this:\n  P \\<noteq> []\n\ngoal (1 subgoal):\n 1. set P \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  set P \\<noteq> {}\n\ngoal (2 subgoals):\n 1. 0 < degree (prod_list P)\n 2. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "have \"prod_list P = prod_list (map id P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list P = prod_list (map id P)", "by simp"], ["proof (state)\nthis:\n  prod_list P = prod_list (map id P)\n\ngoal (2 subgoals):\n 1. 0 < degree (prod_list P)\n 2. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "also"], ["proof (state)\nthis:\n  prod_list P = prod_list (map id P)\n\ngoal (2 subgoals):\n 1. 0 < degree (prod_list P)\n 2. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "have \"... = prod id (set P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map id P) = prod id (set P)", "using prod.distinct_set_conv_list[OF distinct_P, of id]"], ["proof (prove)\nusing this:\n  prod id (set P) = prod_list (map id P)\n\ngoal (1 subgoal):\n 1. prod_list (map id P) = prod id (set P)", "by simp"], ["proof (state)\nthis:\n  prod_list (map id P) = prod id (set P)\n\ngoal (2 subgoals):\n 1. 0 < degree (prod_list P)\n 2. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "also"], ["proof (state)\nthis:\n  prod_list (map id P) = prod id (set P)\n\ngoal (2 subgoals):\n 1. 0 < degree (prod_list P)\n 2. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "have \"... = \\<Prod>(set P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod id (set P) = \\<Prod>(set P)", "by simp"], ["proof (state)\nthis:\n  prod id (set P) = \\<Prod>(set P)\n\ngoal (2 subgoals):\n 1. 0 < degree (prod_list P)\n 2. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "finally"], ["proof (chain)\npicking this:\n  prod_list P = \\<Prod>(set P)", "have \"prod_list P = \\<Prod>(set P)\""], ["proof (prove)\nusing this:\n  prod_list P = \\<Prod>(set P)\n\ngoal (1 subgoal):\n 1. prod_list P = \\<Prod>(set P)", "."], ["proof (state)\nthis:\n  prod_list P = \\<Prod>(set P)\n\ngoal (2 subgoals):\n 1. 0 < degree (prod_list P)\n 2. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "hence \"degree (prod_list P) = degree (\\<Prod>(set P))\""], ["proof (prove)\nusing this:\n  prod_list P = \\<Prod>(set P)\n\ngoal (1 subgoal):\n 1. degree (prod_list P) = degree (\\<Prod>(set P))", "by simp"], ["proof (state)\nthis:\n  degree (prod_list P) = degree (\\<Prod>(set P))\n\ngoal (2 subgoals):\n 1. 0 < degree (prod_list P)\n 2. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "also"], ["proof (state)\nthis:\n  degree (prod_list P) = degree (\\<Prod>(set P))\n\ngoal (2 subgoals):\n 1. 0 < degree (prod_list P)\n 2. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "have \"... = degree (prod id (set P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>(set P)) = degree (prod id (set P))", "by simp"], ["proof (state)\nthis:\n  degree (\\<Prod>(set P)) = degree (prod id (set P))\n\ngoal (2 subgoals):\n 1. 0 < degree (prod_list P)\n 2. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "also"], ["proof (state)\nthis:\n  degree (\\<Prod>(set P)) = degree (prod id (set P))\n\ngoal (2 subgoals):\n 1. 0 < degree (prod_list P)\n 2. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "have \"... = (\\<Sum>i\\<in>(set P). degree (id i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod id (set P)) = (\\<Sum>i\\<in>set P. degree (id i))", "proof (rule degree_prod_eq_sum_degree)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set P. id i \\<noteq> 0", "show \"\\<forall>i\\<in>set P. id i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set P. id i \\<noteq> 0", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  ?u \\<in> set (x # P) \\<Longrightarrow> 0 < degree ?u \\<and> monic ?u\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set P. id i \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set P. id i \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (prod id (set P)) = (\\<Sum>i\\<in>set P. degree (id i))\n\ngoal (2 subgoals):\n 1. 0 < degree (prod_list P)\n 2. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "also"], ["proof (state)\nthis:\n  degree (prod id (set P)) = (\\<Sum>i\\<in>set P. degree (id i))\n\ngoal (2 subgoals):\n 1. 0 < degree (prod_list P)\n 2. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "have \"... > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (\\<Sum>i\\<in>set P. degree (id i))", "by (metis Cons.prems(2) List.finite_set set_P gr0I id_apply insert_iff list.set(2) sum_pos)"], ["proof (state)\nthis:\n  0 < (\\<Sum>i\\<in>set P. degree (id i))\n\ngoal (2 subgoals):\n 1. 0 < degree (prod_list P)\n 2. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "finally"], ["proof (chain)\npicking this:\n  0 < degree (prod_list P)", "show \"degree (prod_list P) > 0\""], ["proof (prove)\nusing this:\n  0 < degree (prod_list P)\n\ngoal (1 subgoal):\n 1. 0 < degree (prod_list P)", "by simp"], ["proof (state)\nthis:\n  0 < degree (prod_list P)\n\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "show \"\\<And>u. u \\<in> set P \\<Longrightarrow> degree u > 0 \\<and> monic u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "using Cons.prems"], ["proof (prove)\nusing this:\n  0 < degree (prod_list (x # P))\n  ?u \\<in> set (x # P) \\<Longrightarrow> 0 < degree ?u \\<and> monic ?u\n  square_free (prod_list (x # P))\n\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set P \\<Longrightarrow> 0 < degree u \\<and> monic u", "by auto"], ["proof (state)\nthis:\n  ?u \\<in> set P \\<Longrightarrow> 0 < degree ?u \\<and> monic ?u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q.\n     prod_list Q = prod_list P \\<and>\n     length P \\<le> length Q \\<and>\n     (\\<forall>u.\n         u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)\n\ngoal (1 subgoal):\n 1. P \\<noteq> [] \\<Longrightarrow>\n    \\<exists>Q.\n       prod_list Q = prod_list (x # P) \\<and>\n       length (x # P) \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>Q.\n     prod_list Q = prod_list P \\<and>\n     length P \\<le> length Q \\<and>\n     (\\<forall>u.\n         u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "obtain Q where QP: \"prod_list Q = prod_list P\" and length_PQ: \"length P \\<le> length Q\"\n  and monic_irr_Q: \"(\\<forall>u. u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)\""], ["proof (prove)\nusing this:\n  \\<exists>Q.\n     prod_list Q = prod_list P \\<and>\n     length P \\<le> length Q \\<and>\n     (\\<forall>u.\n         u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>prod_list Q = prod_list P; length P \\<le> length Q;\n         \\<forall>u.\n            u \\<in> set Q \\<longrightarrow>\n            irreducible u \\<and> monic u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  prod_list Q = prod_list P\n  length P \\<le> length Q\n  \\<forall>u. u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u\n\ngoal (1 subgoal):\n 1. P \\<noteq> [] \\<Longrightarrow>\n    \\<exists>Q.\n       prod_list Q = prod_list (x # P) \\<and>\n       length (x # P) \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q.\n       prod_list Q = prod_list (x # P) \\<and>\n       length (x # P) \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "proof (rule exI[of _ \"A' @ Q\"], auto simp add: monic_irr_Q)"], ["proof (state)\ngoal (4 subgoals):\n 1. prod_list A' * prod_list Q = x * prod_list P\n 2. Suc (length P) \\<le> length A' + length Q\n 3. \\<And>u. u \\<in> set A' \\<Longrightarrow> irreducible u\n 4. \\<And>u. u \\<in> set A' \\<Longrightarrow> monic u", "show \"prod_list A' * prod_list Q = x * prod_list P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list A' * prod_list Q = x * prod_list P", "unfolding QP x_prod_list_A'"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list A' * prod_list P = prod_list A' * prod_list P", "by auto"], ["proof (state)\nthis:\n  prod_list A' * prod_list Q = x * prod_list P\n\ngoal (3 subgoals):\n 1. Suc (length P) \\<le> length A' + length Q\n 2. \\<And>u. u \\<in> set A' \\<Longrightarrow> irreducible u\n 3. \\<And>u. u \\<in> set A' \\<Longrightarrow> monic u", "have \"length A' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length A' \\<noteq> 0", "using A_not_empty"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. length A' \\<noteq> 0", "using s length_A'"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n  set A' = A\n  length A' = card A\n\ngoal (1 subgoal):\n 1. length A' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  length A' \\<noteq> 0\n\ngoal (3 subgoals):\n 1. Suc (length P) \\<le> length A' + length Q\n 2. \\<And>u. u \\<in> set A' \\<Longrightarrow> irreducible u\n 3. \\<And>u. u \\<in> set A' \\<Longrightarrow> monic u", "thus \"Suc (length P) \\<le> length A' + length Q\""], ["proof (prove)\nusing this:\n  length A' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Suc (length P) \\<le> length A' + length Q", "using QP length_PQ"], ["proof (prove)\nusing this:\n  length A' \\<noteq> 0\n  prod_list Q = prod_list P\n  length P \\<le> length Q\n\ngoal (1 subgoal):\n 1. Suc (length P) \\<le> length A' + length Q", "by linarith"], ["proof (state)\nthis:\n  Suc (length P) \\<le> length A' + length Q\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> set A' \\<Longrightarrow> irreducible u\n 2. \\<And>u. u \\<in> set A' \\<Longrightarrow> monic u", "show \"\\<And>u. u \\<in> set A' \\<Longrightarrow> irreducible u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set A' \\<Longrightarrow> irreducible u", "using s A"], ["proof (prove)\nusing this:\n  set A' = A\n  A \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set A' \\<Longrightarrow> irreducible u", "by auto"], ["proof (state)\nthis:\n  ?u \\<in> set A' \\<Longrightarrow> irreducible ?u\n\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set A' \\<Longrightarrow> monic u", "show \"\\<And>u. u \\<in> set A' \\<Longrightarrow> monic u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set A' \\<Longrightarrow> monic u", "using s A"], ["proof (prove)\nusing this:\n  set A' = A\n  A \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set A' \\<Longrightarrow> monic u", "by auto"], ["proof (state)\nthis:\n  ?u \\<in> set A' \\<Longrightarrow> monic ?u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q.\n     prod_list Q = prod_list (x # P) \\<and>\n     length (x # P) \\<le> length Q \\<and>\n     (\\<forall>u.\n         u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q.\n     prod_list Q = prod_list (x # P) \\<and>\n     length (x # P) \\<le> length Q \\<and>\n     (\\<forall>u.\n         u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_eq_imp_smult:\n  fixes p :: \"'b :: {euclidean_ring_gcd} poly\"\n  assumes n: \"normalize p = normalize q\"\n  shows \"\\<exists> c. c \\<noteq> 0 \\<and> q = smult c p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "proof(cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "with n"], ["proof (chain)\npicking this:\n  normalize p = normalize q\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  normalize p = normalize q\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "by (auto intro:exI[of _ 1])"], ["proof (state)\nthis:\n  \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "case p0: False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "have degree_eq: \"degree p = degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = degree q", "using n degree_normalize"], ["proof (prove)\nusing this:\n  normalize p = normalize q\n  degree (normalize ?f) = degree ?f\n\ngoal (1 subgoal):\n 1. degree p = degree q", "by metis"], ["proof (state)\nthis:\n  degree p = degree q\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "hence q0:  \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree p = degree q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "using p0 n"], ["proof (prove)\nusing this:\n  degree p = degree q\n  p \\<noteq> 0\n  normalize p = normalize q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "have p_dvd_q: \"p dvd q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p dvd q", "using n"], ["proof (prove)\nusing this:\n  normalize p = normalize q\n\ngoal (1 subgoal):\n 1. p dvd q", "by (simp add: associatedD1)"], ["proof (state)\nthis:\n  p dvd q\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "from p_dvd_q"], ["proof (chain)\npicking this:\n  p dvd q", "obtain k where q: \"q = k * p\""], ["proof (prove)\nusing this:\n  p dvd q\n\ngoal (1 subgoal):\n 1. (\\<And>k. q = k * p \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. q = p * k\n\ngoal (1 subgoal):\n 1. (\\<And>k. q = k * p \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  q = k * p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "with q0"], ["proof (chain)\npicking this:\n  q \\<noteq> 0\n  q = k * p", "have \"k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  q = k * p\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 0", "have \"degree k = 0\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree k = 0", "using degree_eq degree_mult_eq p0 q"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  degree p = degree q\n  \\<lbrakk>?p \\<noteq> 0; ?q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> degree (?p * ?q) = degree ?p + degree ?q\n  p \\<noteq> 0\n  q = k * p\n\ngoal (1 subgoal):\n 1. degree k = 0", "by fastforce"], ["proof (state)\nthis:\n  degree k = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "then"], ["proof (chain)\npicking this:\n  degree k = 0", "obtain c where k: \"k = [: c :]\""], ["proof (prove)\nusing this:\n  degree k = 0\n\ngoal (1 subgoal):\n 1. (\\<And>c. k = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis degree_0_id)"], ["proof (state)\nthis:\n  k = [:c:]\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "with \\<open>k \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  k = [:c:]", "have \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  k = [:c:]\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b)", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "have \"q = smult c p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = Polynomial.smult c p", "unfolding q k"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:c:] * p = Polynomial.smult c p", "by simp"], ["proof (state)\nthis:\n  q = Polynomial.smult c p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "with \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'b)\n  q = Polynomial.smult c p", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b)\n  q = Polynomial.smult c p\n\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p", "by auto"], ["proof (state)\nthis:\n  \\<exists>c. c \\<noteq> (0::'b) \\<and> q = Polynomial.smult c p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_list_normalize: \n  fixes P :: \"'b :: {idom_divide,normalization_semidom_multiplicative} poly list\"\n  shows \"normalize (prod_list P) = prod_list (map normalize P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (prod_list P) = prod_list (map normalize P)", "proof (induct P)"], ["proof (state)\ngoal (2 subgoals):\n 1. normalize (prod_list []) = prod_list (map normalize [])\n 2. \\<And>a P.\n       normalize (prod_list P) =\n       prod_list (map normalize P) \\<Longrightarrow>\n       normalize (prod_list (a # P)) = prod_list (map normalize (a # P))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. normalize (prod_list []) = prod_list (map normalize [])\n 2. \\<And>a P.\n       normalize (prod_list P) =\n       prod_list (map normalize P) \\<Longrightarrow>\n       normalize (prod_list (a # P)) = prod_list (map normalize (a # P))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (prod_list []) = prod_list (map normalize [])", "by auto"], ["proof (state)\nthis:\n  normalize (prod_list []) = prod_list (map normalize [])\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       normalize (prod_list P) =\n       prod_list (map normalize P) \\<Longrightarrow>\n       normalize (prod_list (a # P)) = prod_list (map normalize (a # P))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a P.\n       normalize (prod_list P) =\n       prod_list (map normalize P) \\<Longrightarrow>\n       normalize (prod_list (a # P)) = prod_list (map normalize (a # P))", "case (Cons p P)"], ["proof (state)\nthis:\n  normalize (prod_list P) = prod_list (map normalize P)\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       normalize (prod_list P) =\n       prod_list (map normalize P) \\<Longrightarrow>\n       normalize (prod_list (a # P)) = prod_list (map normalize (a # P))", "have \"normalize (prod_list (p # P)) = normalize p * normalize (prod_list P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (prod_list (p # P)) = normalize p * normalize (prod_list P)", "using normalize_mult"], ["proof (prove)\nusing this:\n  normalize (?a * ?b) = normalize ?a * normalize ?b\n\ngoal (1 subgoal):\n 1. normalize (prod_list (p # P)) = normalize p * normalize (prod_list P)", "by auto"], ["proof (state)\nthis:\n  normalize (prod_list (p # P)) = normalize p * normalize (prod_list P)\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       normalize (prod_list P) =\n       prod_list (map normalize P) \\<Longrightarrow>\n       normalize (prod_list (a # P)) = prod_list (map normalize (a # P))", "also"], ["proof (state)\nthis:\n  normalize (prod_list (p # P)) = normalize p * normalize (prod_list P)\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       normalize (prod_list P) =\n       prod_list (map normalize P) \\<Longrightarrow>\n       normalize (prod_list (a # P)) = prod_list (map normalize (a # P))", "have \"... = normalize p * prod_list (map normalize P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize p * normalize (prod_list P) =\n    normalize p * prod_list (map normalize P)", "using Cons.hyps"], ["proof (prove)\nusing this:\n  normalize (prod_list P) = prod_list (map normalize P)\n\ngoal (1 subgoal):\n 1. normalize p * normalize (prod_list P) =\n    normalize p * prod_list (map normalize P)", "by auto"], ["proof (state)\nthis:\n  normalize p * normalize (prod_list P) =\n  normalize p * prod_list (map normalize P)\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       normalize (prod_list P) =\n       prod_list (map normalize P) \\<Longrightarrow>\n       normalize (prod_list (a # P)) = prod_list (map normalize (a # P))", "also"], ["proof (state)\nthis:\n  normalize p * normalize (prod_list P) =\n  normalize p * prod_list (map normalize P)\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       normalize (prod_list P) =\n       prod_list (map normalize P) \\<Longrightarrow>\n       normalize (prod_list (a # P)) = prod_list (map normalize (a # P))", "have \"... = prod_list (normalize p # (map normalize P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize p * prod_list (map normalize P) =\n    prod_list (normalize p # map normalize P)", "by auto"], ["proof (state)\nthis:\n  normalize p * prod_list (map normalize P) =\n  prod_list (normalize p # map normalize P)\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       normalize (prod_list P) =\n       prod_list (map normalize P) \\<Longrightarrow>\n       normalize (prod_list (a # P)) = prod_list (map normalize (a # P))", "also"], ["proof (state)\nthis:\n  normalize p * prod_list (map normalize P) =\n  prod_list (normalize p # map normalize P)\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       normalize (prod_list P) =\n       prod_list (map normalize P) \\<Longrightarrow>\n       normalize (prod_list (a # P)) = prod_list (map normalize (a # P))", "have \"... = prod_list (map normalize (p # P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (normalize p # map normalize P) =\n    prod_list (map normalize (p # P))", "by auto"], ["proof (state)\nthis:\n  prod_list (normalize p # map normalize P) =\n  prod_list (map normalize (p # P))\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       normalize (prod_list P) =\n       prod_list (map normalize P) \\<Longrightarrow>\n       normalize (prod_list (a # P)) = prod_list (map normalize (a # P))", "finally"], ["proof (chain)\npicking this:\n  normalize (prod_list (p # P)) = prod_list (map normalize (p # P))", "show ?case"], ["proof (prove)\nusing this:\n  normalize (prod_list (p # P)) = prod_list (map normalize (p # P))\n\ngoal (1 subgoal):\n 1. normalize (prod_list (p # P)) = prod_list (map normalize (p # P))", "."], ["proof (state)\nthis:\n  normalize (prod_list (p # P)) = prod_list (map normalize (p # P))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_list_dvd_prod_list_subset:\nfixes A::\"'b::comm_monoid_mult list\"\nassumes dA: \"distinct A\"\n  and dB: \"distinct B\" (*Maybe this condition could be avoided*)\n  and s: \"set A \\<subseteq> set B\"\nshows \"prod_list A dvd prod_list B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list A dvd prod_list B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod_list A dvd prod_list B", "have \"prod_list A = prod_list (map id A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list A = prod_list (map id A)", "by auto"], ["proof (state)\nthis:\n  prod_list A = prod_list (map id A)\n\ngoal (1 subgoal):\n 1. prod_list A dvd prod_list B", "also"], ["proof (state)\nthis:\n  prod_list A = prod_list (map id A)\n\ngoal (1 subgoal):\n 1. prod_list A dvd prod_list B", "have \"... = prod id (set A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map id A) = prod id (set A)", "by (rule prod.distinct_set_conv_list[symmetric, OF dA])"], ["proof (state)\nthis:\n  prod_list (map id A) = prod id (set A)\n\ngoal (1 subgoal):\n 1. prod_list A dvd prod_list B", "also"], ["proof (state)\nthis:\n  prod_list (map id A) = prod id (set A)\n\ngoal (1 subgoal):\n 1. prod_list A dvd prod_list B", "have \"... dvd prod id (set B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod id (set A) dvd prod id (set B)", "by (rule prod_dvd_prod_subset[OF _ s], auto)"], ["proof (state)\nthis:\n  prod id (set A) dvd prod id (set B)\n\ngoal (1 subgoal):\n 1. prod_list A dvd prod_list B", "also"], ["proof (state)\nthis:\n  prod id (set A) dvd prod id (set B)\n\ngoal (1 subgoal):\n 1. prod_list A dvd prod_list B", "have \"... = prod_list (map id B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod id (set B) = prod_list (map id B)", "by (rule prod.distinct_set_conv_list[OF dB])"], ["proof (state)\nthis:\n  prod id (set B) = prod_list (map id B)\n\ngoal (1 subgoal):\n 1. prod_list A dvd prod_list B", "also"], ["proof (state)\nthis:\n  prod id (set B) = prod_list (map id B)\n\ngoal (1 subgoal):\n 1. prod_list A dvd prod_list B", "have \"... = prod_list B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map id B) = prod_list B", "by simp"], ["proof (state)\nthis:\n  prod_list (map id B) = prod_list B\n\ngoal (1 subgoal):\n 1. prod_list A dvd prod_list B", "finally"], ["proof (chain)\npicking this:\n  prod_list A dvd prod_list B", "show ?thesis"], ["proof (prove)\nusing this:\n  prod_list A dvd prod_list B\n\ngoal (1 subgoal):\n 1. prod_list A dvd prod_list B", "."], ["proof (state)\nthis:\n  prod_list A dvd prod_list B\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma gcd_monic_constant:\n  \"gcd f g \\<in> {1, f}\" if \"monic f\" and \"degree g = 0\"\n    for f g :: \"'a :: {field_gcd} poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f g \\<in> {1, f}", "proof (cases \"g = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. g = 0 \\<Longrightarrow> gcd f g \\<in> {1, f}\n 2. g \\<noteq> 0 \\<Longrightarrow> gcd f g \\<in> {1, f}", "case True"], ["proof (state)\nthis:\n  g = 0\n\ngoal (2 subgoals):\n 1. g = 0 \\<Longrightarrow> gcd f g \\<in> {1, f}\n 2. g \\<noteq> 0 \\<Longrightarrow> gcd f g \\<in> {1, f}", "moreover"], ["proof (state)\nthis:\n  g = 0\n\ngoal (2 subgoals):\n 1. g = 0 \\<Longrightarrow> gcd f g \\<in> {1, f}\n 2. g \\<noteq> 0 \\<Longrightarrow> gcd f g \\<in> {1, f}", "from \\<open>monic f\\<close>"], ["proof (chain)\npicking this:\n  monic f", "have \"normalize f = f\""], ["proof (prove)\nusing this:\n  monic f\n\ngoal (1 subgoal):\n 1. normalize f = f", "by (rule normalize_monic)"], ["proof (state)\nthis:\n  normalize f = f\n\ngoal (2 subgoals):\n 1. g = 0 \\<Longrightarrow> gcd f g \\<in> {1, f}\n 2. g \\<noteq> 0 \\<Longrightarrow> gcd f g \\<in> {1, f}", "ultimately"], ["proof (chain)\npicking this:\n  g = 0\n  normalize f = f", "show ?thesis"], ["proof (prove)\nusing this:\n  g = 0\n  normalize f = f\n\ngoal (1 subgoal):\n 1. gcd f g \\<in> {1, f}", "by simp"], ["proof (state)\nthis:\n  gcd f g \\<in> {1, f}\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0 \\<Longrightarrow> gcd f g \\<in> {1, f}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. g \\<noteq> 0 \\<Longrightarrow> gcd f g \\<in> {1, f}", "case False"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0 \\<Longrightarrow> gcd f g \\<in> {1, f}", "with \\<open>degree g = 0\\<close>"], ["proof (chain)\npicking this:\n  degree g = 0\n  g \\<noteq> 0", "have \"is_unit g\""], ["proof (prove)\nusing this:\n  degree g = 0\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_unit g", "by simp"], ["proof (state)\nthis:\n  is_unit g\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0 \\<Longrightarrow> gcd f g \\<in> {1, f}", "then"], ["proof (chain)\npicking this:\n  is_unit g", "have \"Rings.coprime f g\""], ["proof (prove)\nusing this:\n  is_unit g\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f g", "by (rule is_unit_right_imp_coprime)"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime f g\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0 \\<Longrightarrow> gcd f g \\<in> {1, f}", "then"], ["proof (chain)\npicking this:\n  algebraic_semidom_class.coprime f g", "show ?thesis"], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime f g\n\ngoal (1 subgoal):\n 1. gcd f g \\<in> {1, f}", "by simp"], ["proof (state)\nthis:\n  gcd f g \\<in> {1, f}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_find_base_vectors:\nfixes A::\"'a::field mat\"\nassumes ref: \"row_echelon_form A\"\n  and A: \"A \\<in> carrier_mat nr nc\"\nshows \"distinct (find_base_vectors A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (find_base_vectors A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (find_base_vectors A)", "note non_pivot_base = non_pivot_base[OF ref A]"], ["proof (state)\nthis:\n  \\<lbrakk>?qj < nc; ?qj \\<notin> snd ` set (pivot_positions A)\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A (pivot_positions A) ?qj\n                    \\<in> carrier_vec nc\n  \\<lbrakk>?qj < nc; ?qj \\<notin> snd ` set (pivot_positions A)\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A (pivot_positions A) ?qj $ ?qj = (1::'a)\n  \\<lbrakk>?qj < nc; ?qj \\<notin> snd ` set (pivot_positions A)\\<rbrakk>\n  \\<Longrightarrow> A *\\<^sub>v non_pivot_base A (pivot_positions A) ?qj =\n                    0\\<^sub>v nr\n  \\<lbrakk>?qj < nc; ?qj \\<notin> snd ` set (pivot_positions A); ?qj' < nc;\n   ?qj' \\<notin> snd ` set (pivot_positions A); ?qj \\<noteq> ?qj'\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A (pivot_positions A) ?qj $ ?qj' =\n                    (0::'a)\n\ngoal (1 subgoal):\n 1. distinct (find_base_vectors A)", "let ?pp = \"set (pivot_positions A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (find_base_vectors A)", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc", "have dim: \"dim_row A = nr\" \"dim_col A = nc\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. dim_row A = nr &&& dim_col A = nc", "by auto"], ["proof (state)\nthis:\n  dim_row A = nr\n  dim_col A = nc\n\ngoal (1 subgoal):\n 1. distinct (find_base_vectors A)", "{"], ["proof (state)\nthis:\n  dim_row A = nr\n  dim_col A = nc\n\ngoal (1 subgoal):\n 1. distinct (find_base_vectors A)", "fix j j'"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (find_base_vectors A)", "assume j: \"j < nc\" \"j \\<notin> snd ` ?pp\" and j': \"j' < nc\" \"j' \\<notin> snd ` ?pp\" and neq: \"j' \\<noteq> j\""], ["proof (state)\nthis:\n  j < nc\n  j \\<notin> snd ` set (pivot_positions A)\n  j' < nc\n  j' \\<notin> snd ` set (pivot_positions A)\n  j' \\<noteq> j\n\ngoal (1 subgoal):\n 1. distinct (find_base_vectors A)", "from non_pivot_base(2)[OF j] non_pivot_base(4)[OF j' j neq]"], ["proof (chain)\npicking this:\n  non_pivot_base A (pivot_positions A) j $ j = (1::'a)\n  non_pivot_base A (pivot_positions A) j' $ j = (0::'a)", "have \"non_pivot_base A (pivot_positions A) j \\<noteq> non_pivot_base A (pivot_positions A) j'\""], ["proof (prove)\nusing this:\n  non_pivot_base A (pivot_positions A) j $ j = (1::'a)\n  non_pivot_base A (pivot_positions A) j' $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. non_pivot_base A (pivot_positions A) j \\<noteq>\n    non_pivot_base A (pivot_positions A) j'", "by auto"], ["proof (state)\nthis:\n  non_pivot_base A (pivot_positions A) j \\<noteq>\n  non_pivot_base A (pivot_positions A) j'\n\ngoal (1 subgoal):\n 1. distinct (find_base_vectors A)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < nc; ?j2 \\<notin> snd ` set (pivot_positions A); ?j'2 < nc;\n   ?j'2 \\<notin> snd ` set (pivot_positions A); ?j'2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A (pivot_positions A) ?j2 \\<noteq>\n                    non_pivot_base A (pivot_positions A) ?j'2\n\ngoal (1 subgoal):\n 1. distinct (find_base_vectors A)", "hence inj: \"inj_on (non_pivot_base A (pivot_positions A))\n     (set [j\\<leftarrow>[0..<nc] . j \\<notin> snd ` ?pp])\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?j2 < nc; ?j2 \\<notin> snd ` set (pivot_positions A); ?j'2 < nc;\n   ?j'2 \\<notin> snd ` set (pivot_positions A); ?j'2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A (pivot_positions A) ?j2 \\<noteq>\n                    non_pivot_base A (pivot_positions A) ?j'2\n\ngoal (1 subgoal):\n 1. inj_on (non_pivot_base A (pivot_positions A))\n     (set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n            [0..<nc]))", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j2 < nc; ?j2 \\<notin> snd ` set (pivot_positions A); ?j'2 < nc;\n   ?j'2 \\<notin> snd ` set (pivot_positions A); ?j'2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A (pivot_positions A) ?j2 \\<noteq>\n                    non_pivot_base A (pivot_positions A) ?j'2\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (filter\n                         (\\<lambda>j.\n                             j \\<notin> snd ` set (pivot_positions A))\n                         [0..<nc]).\n       \\<forall>y\\<in>set (filter\n                            (\\<lambda>j.\n                                j \\<notin> snd ` set (pivot_positions A))\n                            [0..<nc]).\n          non_pivot_base A (pivot_positions A) x =\n          non_pivot_base A (pivot_positions A) y \\<longrightarrow>\n          x = y", "by auto"], ["proof (state)\nthis:\n  inj_on (non_pivot_base A (pivot_positions A))\n   (set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n          [0..<nc]))\n\ngoal (1 subgoal):\n 1. distinct (find_base_vectors A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  inj_on (non_pivot_base A (pivot_positions A))\n   (set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n          [0..<nc]))\n\ngoal (1 subgoal):\n 1. distinct (find_base_vectors A)", "unfolding  find_base_vectors_def Let_def"], ["proof (prove)\nusing this:\n  inj_on (non_pivot_base A (pivot_positions A))\n   (set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n          [0..<nc]))\n\ngoal (1 subgoal):\n 1. distinct\n     (map (non_pivot_base A (pivot_positions A))\n       (filter (\\<lambda>j. j \\<notin> set (map snd (pivot_positions A)))\n         [0..<dim_col A]))", "unfolding distinct_map dim"], ["proof (prove)\nusing this:\n  inj_on (non_pivot_base A (pivot_positions A))\n   (set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n          [0..<nc]))\n\ngoal (1 subgoal):\n 1. distinct\n     (filter (\\<lambda>j. j \\<notin> set (map snd (pivot_positions A)))\n       [0..<nc]) \\<and>\n    inj_on (non_pivot_base A (pivot_positions A))\n     (set (filter (\\<lambda>j. j \\<notin> set (map snd (pivot_positions A)))\n            [0..<nc]))", "by auto"], ["proof (state)\nthis:\n  distinct (find_base_vectors A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_find_base_vectors:\nfixes A::\"'a::field mat\"\nassumes ref: \"row_echelon_form A\"\n  and A: \"A \\<in> carrier_mat nr nc\"\nshows \"length (find_base_vectors A) = card (set (find_base_vectors A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (find_base_vectors A) = card (set (find_base_vectors A))", "using  distinct_card[OF distinct_find_base_vectors[OF ref A]]"], ["proof (prove)\nusing this:\n  card (set (find_base_vectors A)) = length (find_base_vectors A)\n\ngoal (1 subgoal):\n 1. length (find_base_vectors A) = card (set (find_base_vectors A))", "by auto"], ["", "subsection \\<open>Previous Results\\<close>"], ["", "definition power_poly_f_mod :: \"'a::field poly \\<Rightarrow> 'a poly \\<Rightarrow> nat \\<Rightarrow> 'a poly\" where\n  \"power_poly_f_mod modulus = (\\<lambda>a n. a ^ n mod modulus)\""], ["", "lemma power_poly_f_mod_binary: \"power_poly_f_mod m a n = (if n = 0 then 1 mod m\n    else let (d, r) = Divides.divmod_nat n 2;\n       rec = power_poly_f_mod m ((a * a) mod m) d in\n    if r = 0 then rec else (rec * a) mod m)\"\n  for m a :: \"'a :: {field_gcd} poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "note d = power_poly_f_mod_def"], ["proof (state)\nthis:\n  power_poly_f_mod ?modulus = (\\<lambda>a n. a ^ n mod ?modulus)\n\ngoal (1 subgoal):\n 1. power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "unfolding d"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. a ^ n mod m =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2; rec = (a * a mod m) ^ d mod m\n          in if r = 0 then rec else rec * a mod m)", "by simp"], ["proof (state)\nthis:\n  power_poly_f_mod m a n =\n  (if n = 0 then 1 mod m\n   else let (d, r) = divmod_nat n 2;\n            rec = power_poly_f_mod m (a * a mod m) d\n        in if r = 0 then rec else rec * a mod m)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "obtain q r where div: \"Divides.divmod_nat n 2 = (q,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        divmod_nat n 2 = (q, r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  divmod_nat n 2 = (q, r)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "hence n: \"n = 2 * q + r\" and r: \"r = 0 \\<or> r = 1\""], ["proof (prove)\nusing this:\n  divmod_nat n 2 = (q, r)\n\ngoal (1 subgoal):\n 1. n = 2 * q + r &&& r = 0 \\<or> r = 1", "unfolding divmod_nat_def"], ["proof (prove)\nusing this:\n  (n div 2, n mod 2) = (q, r)\n\ngoal (1 subgoal):\n 1. n = 2 * q + r &&& r = 0 \\<or> r = 1", "by auto"], ["proof (state)\nthis:\n  n = 2 * q + r\n  r = 0 \\<or> r = 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "have id: \"a ^ (2 * q) = (a * a) ^ q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a ^ (2 * q) = (a * a) ^ q", "by (simp add: power_mult_distrib semiring_normalization_rules)"], ["proof (state)\nthis:\n  a ^ (2 * q) = (a * a) ^ q\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "proof (cases \"r = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "case True"], ["proof (state)\nthis:\n  r = 0\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "using power_mod [of \"a * a\" m q]"], ["proof (prove)\nusing this:\n  (a * a mod m) ^ q mod m = (a * a) ^ q mod m\n\ngoal (1 subgoal):\n 1. power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "by (auto simp add: divmod_nat_def Let_def True n d div id)"], ["proof (state)\nthis:\n  power_poly_f_mod m a n =\n  (if n = 0 then 1 mod m\n   else let (d, r) = divmod_nat n 2;\n            rec = power_poly_f_mod m (a * a mod m) d\n        in if r = 0 then rec else rec * a mod m)\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "case False"], ["proof (state)\nthis:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "with r"], ["proof (chain)\npicking this:\n  r = 0 \\<or> r = 1\n  r \\<noteq> 0", "have r: \"r = 1\""], ["proof (prove)\nusing this:\n  r = 0 \\<or> r = 1\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r = 1", "by simp"], ["proof (state)\nthis:\n  r = 1\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. power_poly_f_mod m a n =\n    (if n = 0 then 1 mod m\n     else let (d, r) = divmod_nat n 2;\n              rec = power_poly_f_mod m (a * a mod m) d\n          in if r = 0 then rec else rec * a mod m)", "by (auto simp add: d r div Let_def mod_simps)\n          (simp add: n r mod_simps ac_simps power_mult_distrib power_mult power2_eq_square)"], ["proof (state)\nthis:\n  power_poly_f_mod m a n =\n  (if n = 0 then 1 mod m\n   else let (d, r) = divmod_nat n 2;\n            rec = power_poly_f_mod m (a * a mod m) d\n        in if r = 0 then rec else rec * a mod m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  power_poly_f_mod m a n =\n  (if n = 0 then 1 mod m\n   else let (d, r) = divmod_nat n 2;\n            rec = power_poly_f_mod m (a * a mod m) d\n        in if r = 0 then rec else rec * a mod m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  power_poly_f_mod m a n =\n  (if n = 0 then 1 mod m\n   else let (d, r) = divmod_nat n 2;\n            rec = power_poly_f_mod m (a * a mod m) d\n        in if r = 0 then rec else rec * a mod m)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun power_polys where\n  \"power_polys mul_p u curr_p (Suc i) = curr_p #\n      power_polys mul_p u ((curr_p * mul_p) mod u) i\"\n| \"power_polys mul_p u curr_p 0 = []\""], ["", "context\nassumes \"SORT_CONSTRAINT('a::prime_card)\"\nbegin"], ["", "lemma fermat_theorem_mod_ring [simp]:\n  fixes a::\"'a mod_ring\"\n  shows \"a ^ CARD('a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a ^ CARD('a) = a", "proof (cases \"a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow> a ^ CARD('a) = a\n 2. a \\<noteq> 0 \\<Longrightarrow> a ^ CARD('a) = a", "case True"], ["proof (state)\nthis:\n  a = 0\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow> a ^ CARD('a) = a\n 2. a \\<noteq> 0 \\<Longrightarrow> a ^ CARD('a) = a", "then"], ["proof (chain)\npicking this:\n  a = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a = 0\n\ngoal (1 subgoal):\n 1. a ^ CARD('a) = a", "by auto"], ["proof (state)\nthis:\n  a ^ CARD('a) = a\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> a ^ CARD('a) = a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> a ^ CARD('a) = a", "case False"], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> a ^ CARD('a) = a", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a ^ CARD('a) = a", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a ^ CARD('a) mod int CARD('a) = a", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a ^ CARD('a) mod int CARD('a) = a", "assume \"a \\<in> {0..<int CARD('a)}\" and \"a \\<noteq> 0\""], ["proof (state)\nthis:\n  a \\<in> {0..<int CARD('a)}\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a ^ CARD('a) mod int CARD('a) = a", "then"], ["proof (chain)\npicking this:\n  a \\<in> {0..<int CARD('a)}\n  a \\<noteq> 0", "have a: \"1 \\<le> a\" \"a < int CARD('a)\""], ["proof (prove)\nusing this:\n  a \\<in> {0..<int CARD('a)}\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> a &&& a < int CARD('a)", "by simp_all"], ["proof (state)\nthis:\n  1 \\<le> a\n  a < int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a ^ CARD('a) mod int CARD('a) = a", "then"], ["proof (chain)\npicking this:\n  1 \\<le> a\n  a < int CARD('a)", "have [simp]: \"a mod int CARD('a) = a\""], ["proof (prove)\nusing this:\n  1 \\<le> a\n  a < int CARD('a)\n\ngoal (1 subgoal):\n 1. a mod int CARD('a) = a", "by simp"], ["proof (state)\nthis:\n  a mod int CARD('a) = a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a ^ CARD('a) mod int CARD('a) = a", "from a"], ["proof (chain)\npicking this:\n  1 \\<le> a\n  a < int CARD('a)", "have \"\\<not> int CARD('a) dvd a\""], ["proof (prove)\nusing this:\n  1 \\<le> a\n  a < int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<not> int CARD('a) dvd a", "by (auto simp add: zdvd_not_zless)"], ["proof (state)\nthis:\n  \\<not> int CARD('a) dvd a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a ^ CARD('a) mod int CARD('a) = a", "then"], ["proof (chain)\npicking this:\n  \\<not> int CARD('a) dvd a", "have \"\\<not> CARD('a) dvd nat \\<bar>a\\<bar>\""], ["proof (prove)\nusing this:\n  \\<not> int CARD('a) dvd a\n\ngoal (1 subgoal):\n 1. \\<not> CARD('a) dvd nat \\<bar>a\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<not> CARD('a) dvd nat \\<bar>a\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a ^ CARD('a) mod int CARD('a) = a", "with a"], ["proof (chain)\npicking this:\n  1 \\<le> a\n  a < int CARD('a)\n  \\<not> CARD('a) dvd nat \\<bar>a\\<bar>", "have \"\\<not> CARD('a) dvd nat a\""], ["proof (prove)\nusing this:\n  1 \\<le> a\n  a < int CARD('a)\n  \\<not> CARD('a) dvd nat \\<bar>a\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> CARD('a) dvd nat a", "by simp"], ["proof (state)\nthis:\n  \\<not> CARD('a) dvd nat a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a ^ CARD('a) mod int CARD('a) = a", "with prime_card"], ["proof (chain)\npicking this:\n  prime CARD(?'a)\n  \\<not> CARD('a) dvd nat a", "have \"[nat a ^ (CARD('a) - 1) = 1] (mod CARD('a))\""], ["proof (prove)\nusing this:\n  prime CARD(?'a)\n  \\<not> CARD('a) dvd nat a\n\ngoal (1 subgoal):\n 1. [nat a ^ (CARD('a) - 1) = 1] (mod CARD('a))", "by (rule fermat_theorem)"], ["proof (state)\nthis:\n  [nat a ^ (CARD('a) - 1) = 1] (mod CARD('a))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a ^ CARD('a) mod int CARD('a) = a", "with a"], ["proof (chain)\npicking this:\n  1 \\<le> a\n  a < int CARD('a)\n  [nat a ^ (CARD('a) - 1) = 1] (mod CARD('a))", "have \"int (nat a ^ (CARD('a) - 1) mod CARD('a)) = 1\""], ["proof (prove)\nusing this:\n  1 \\<le> a\n  a < int CARD('a)\n  [nat a ^ (CARD('a) - 1) = 1] (mod CARD('a))\n\ngoal (1 subgoal):\n 1. int (nat a ^ (CARD('a) - 1) mod CARD('a)) = 1", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  int (nat a ^ (CARD('a) - 1) mod CARD('a)) = 1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a ^ CARD('a) mod int CARD('a) = a", "with a"], ["proof (chain)\npicking this:\n  1 \\<le> a\n  a < int CARD('a)\n  int (nat a ^ (CARD('a) - 1) mod CARD('a)) = 1", "have \"a ^ (CARD('a) - 1) mod CARD('a) = 1\""], ["proof (prove)\nusing this:\n  1 \\<le> a\n  a < int CARD('a)\n  int (nat a ^ (CARD('a) - 1) mod CARD('a)) = 1\n\ngoal (1 subgoal):\n 1. a ^ (CARD('a) - 1) mod int CARD('a) = 1", "by (simp add: of_nat_mod)"], ["proof (state)\nthis:\n  a ^ (CARD('a) - 1) mod int CARD('a) = 1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a ^ CARD('a) mod int CARD('a) = a", "then"], ["proof (chain)\npicking this:\n  a ^ (CARD('a) - 1) mod int CARD('a) = 1", "have \"a * (a ^ (CARD('a) - 1) mod int CARD('a)) = a\""], ["proof (prove)\nusing this:\n  a ^ (CARD('a) - 1) mod int CARD('a) = 1\n\ngoal (1 subgoal):\n 1. a * (a ^ (CARD('a) - 1) mod int CARD('a)) = a", "by simp"], ["proof (state)\nthis:\n  a * (a ^ (CARD('a) - 1) mod int CARD('a)) = a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a ^ CARD('a) mod int CARD('a) = a", "then"], ["proof (chain)\npicking this:\n  a * (a ^ (CARD('a) - 1) mod int CARD('a)) = a", "have \"(a * (a ^ (CARD('a) - 1) mod int CARD('a))) mod int CARD('a) = a mod int CARD('a)\""], ["proof (prove)\nusing this:\n  a * (a ^ (CARD('a) - 1) mod int CARD('a)) = a\n\ngoal (1 subgoal):\n 1. a * (a ^ (CARD('a) - 1) mod int CARD('a)) mod int CARD('a) =\n    a mod int CARD('a)", "by (simp only:)"], ["proof (state)\nthis:\n  a * (a ^ (CARD('a) - 1) mod int CARD('a)) mod int CARD('a) =\n  a mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a ^ CARD('a) mod int CARD('a) = a", "then"], ["proof (chain)\npicking this:\n  a * (a ^ (CARD('a) - 1) mod int CARD('a)) mod int CARD('a) =\n  a mod int CARD('a)", "show \"a ^ CARD('a) mod int CARD('a) = a\""], ["proof (prove)\nusing this:\n  a * (a ^ (CARD('a) - 1) mod int CARD('a)) mod int CARD('a) =\n  a mod int CARD('a)\n\ngoal (1 subgoal):\n 1. a ^ CARD('a) mod int CARD('a) = a", "by (simp add: mod_simps semiring_normalization_rules(27))"], ["proof (state)\nthis:\n  a ^ CARD('a) mod int CARD('a) = a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a ^ CARD('a) = a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_eq_dvd_iff_poly: \"((x::'a mod_ring poly) mod n = y mod n) = (n dvd x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x mod n = y mod n) = (n dvd x - y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x mod n = y mod n \\<Longrightarrow> n dvd x - y\n 2. n dvd x - y \\<Longrightarrow> x mod n = y mod n", "assume H: \"x mod n = y mod n\""], ["proof (state)\nthis:\n  x mod n = y mod n\n\ngoal (2 subgoals):\n 1. x mod n = y mod n \\<Longrightarrow> n dvd x - y\n 2. n dvd x - y \\<Longrightarrow> x mod n = y mod n", "hence \"x mod n - y mod n = 0\""], ["proof (prove)\nusing this:\n  x mod n = y mod n\n\ngoal (1 subgoal):\n 1. x mod n - y mod n = 0", "by simp"], ["proof (state)\nthis:\n  x mod n - y mod n = 0\n\ngoal (2 subgoals):\n 1. x mod n = y mod n \\<Longrightarrow> n dvd x - y\n 2. n dvd x - y \\<Longrightarrow> x mod n = y mod n", "hence \"(x mod n - y mod n) mod n = 0\""], ["proof (prove)\nusing this:\n  x mod n - y mod n = 0\n\ngoal (1 subgoal):\n 1. (x mod n - y mod n) mod n = 0", "by simp"], ["proof (state)\nthis:\n  (x mod n - y mod n) mod n = 0\n\ngoal (2 subgoals):\n 1. x mod n = y mod n \\<Longrightarrow> n dvd x - y\n 2. n dvd x - y \\<Longrightarrow> x mod n = y mod n", "hence \"(x - y) mod n = 0\""], ["proof (prove)\nusing this:\n  (x mod n - y mod n) mod n = 0\n\ngoal (1 subgoal):\n 1. (x - y) mod n = 0", "by (simp add: mod_diff_eq)"], ["proof (state)\nthis:\n  (x - y) mod n = 0\n\ngoal (2 subgoals):\n 1. x mod n = y mod n \\<Longrightarrow> n dvd x - y\n 2. n dvd x - y \\<Longrightarrow> x mod n = y mod n", "thus \"n dvd x - y\""], ["proof (prove)\nusing this:\n  (x - y) mod n = 0\n\ngoal (1 subgoal):\n 1. n dvd x - y", "by (simp add: dvd_eq_mod_eq_0)"], ["proof (state)\nthis:\n  n dvd x - y\n\ngoal (1 subgoal):\n 1. n dvd x - y \\<Longrightarrow> x mod n = y mod n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n dvd x - y \\<Longrightarrow> x mod n = y mod n", "assume H: \"n dvd x - y\""], ["proof (state)\nthis:\n  n dvd x - y\n\ngoal (1 subgoal):\n 1. n dvd x - y \\<Longrightarrow> x mod n = y mod n", "then"], ["proof (chain)\npicking this:\n  n dvd x - y", "obtain k where k: \"x-y = n*k\""], ["proof (prove)\nusing this:\n  n dvd x - y\n\ngoal (1 subgoal):\n 1. (\\<And>k. x - y = n * k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. x - y = n * k\n\ngoal (1 subgoal):\n 1. (\\<And>k. x - y = n * k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x - y = n * k\n\ngoal (1 subgoal):\n 1. n dvd x - y \\<Longrightarrow> x mod n = y mod n", "hence \"x = n*k + y\""], ["proof (prove)\nusing this:\n  x - y = n * k\n\ngoal (1 subgoal):\n 1. x = n * k + y", "using diff_eq_eq"], ["proof (prove)\nusing this:\n  x - y = n * k\n  (?a - ?b = ?c) = (?a = ?c + ?b)\n\ngoal (1 subgoal):\n 1. x = n * k + y", "by blast"], ["proof (state)\nthis:\n  x = n * k + y\n\ngoal (1 subgoal):\n 1. n dvd x - y \\<Longrightarrow> x mod n = y mod n", "hence \"x mod n = (n*k + y) mod n\""], ["proof (prove)\nusing this:\n  x = n * k + y\n\ngoal (1 subgoal):\n 1. x mod n = (n * k + y) mod n", "by simp"], ["proof (state)\nthis:\n  x mod n = (n * k + y) mod n\n\ngoal (1 subgoal):\n 1. n dvd x - y \\<Longrightarrow> x mod n = y mod n", "thus \"x mod n = y mod n\""], ["proof (prove)\nusing this:\n  x mod n = (n * k + y) mod n\n\ngoal (1 subgoal):\n 1. x mod n = y mod n", "by (simp add: mod_add_left_eq)"], ["proof (state)\nthis:\n  x mod n = y mod n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cong_gcd_eq_poly:\n  \"gcd a m = gcd b m\" if \"[(a::'a mod_ring poly) = b] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd a m = gcd b m", "using that"], ["proof (prove)\nusing this:\n  [a = b] (mod m)\n\ngoal (1 subgoal):\n 1. gcd a m = gcd b m", "by (simp add: cong_def) (metis gcd_mod_left mod_by_0)"], ["", "lemma coprime_h_c_poly:\nfixes h::\"'a mod_ring poly\"\nassumes \"c1 \\<noteq> c2\"\nshows \"coprime (h - [:c1:]) (h - [:c2:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (h - [:c1:]) (h - [:c2:])", "proof (intro coprimeI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>r dvd h - [:c1:]; r dvd h - [:c2:]\\<rbrakk>\n       \\<Longrightarrow> is_unit r", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>r dvd h - [:c1:]; r dvd h - [:c2:]\\<rbrakk>\n       \\<Longrightarrow> is_unit r", "assume \"d dvd h - [:c1:]\"\n  and \"d dvd h - [:c2:]\""], ["proof (state)\nthis:\n  d dvd h - [:c1:]\n  d dvd h - [:c2:]\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>r dvd h - [:c1:]; r dvd h - [:c2:]\\<rbrakk>\n       \\<Longrightarrow> is_unit r", "hence \"h mod d = [:c1:] mod d\" and \"h mod d = [:c2:] mod d\""], ["proof (prove)\nusing this:\n  d dvd h - [:c1:]\n  d dvd h - [:c2:]\n\ngoal (1 subgoal):\n 1. h mod d = [:c1:] mod d &&& h mod d = [:c2:] mod d", "using mod_eq_dvd_iff_poly"], ["proof (prove)\nusing this:\n  d dvd h - [:c1:]\n  d dvd h - [:c2:]\n  (?x mod ?n = ?y mod ?n) = (?n dvd ?x - ?y)\n\ngoal (1 subgoal):\n 1. h mod d = [:c1:] mod d &&& h mod d = [:c2:] mod d", "by simp+"], ["proof (state)\nthis:\n  h mod d = [:c1:] mod d\n  h mod d = [:c2:] mod d\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>r dvd h - [:c1:]; r dvd h - [:c2:]\\<rbrakk>\n       \\<Longrightarrow> is_unit r", "hence \"[:c1:] mod d = [:c2:] mod d\""], ["proof (prove)\nusing this:\n  h mod d = [:c1:] mod d\n  h mod d = [:c2:] mod d\n\ngoal (1 subgoal):\n 1. [:c1:] mod d = [:c2:] mod d", "by simp"], ["proof (state)\nthis:\n  [:c1:] mod d = [:c2:] mod d\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>r dvd h - [:c1:]; r dvd h - [:c2:]\\<rbrakk>\n       \\<Longrightarrow> is_unit r", "hence \"d dvd [:c2 - c1:]\""], ["proof (prove)\nusing this:\n  [:c1:] mod d = [:c2:] mod d\n\ngoal (1 subgoal):\n 1. d dvd [:c2 - c1:]", "by (metis (no_types) mod_eq_dvd_iff_poly diff_pCons right_minus_eq)"], ["proof (state)\nthis:\n  d dvd [:c2 - c1:]\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>r dvd h - [:c1:]; r dvd h - [:c2:]\\<rbrakk>\n       \\<Longrightarrow> is_unit r", "thus \"is_unit d\""], ["proof (prove)\nusing this:\n  d dvd [:c2 - c1:]\n\ngoal (1 subgoal):\n 1. is_unit d", "by (metis (no_types) assms dvd_trans is_unit_monom_0 monom_0 right_minus_eq)"], ["proof (state)\nthis:\n  is_unit d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coprime_h_c_poly2:\nfixes h::\"'a mod_ring poly\"\nassumes \"coprime (h - [:c1:]) (h - [:c2:])\"\nand \"\\<not> is_unit (h - [:c1:])\"\nshows \"c1 \\<noteq> c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c1 \\<noteq> c2", "using assms coprime_id_is_unit"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (h - [:c1:]) (h - [:c2:])\n  \\<not> is_unit (h - [:c1:])\n  comm_monoid_mult_class.coprime ?a ?a = is_unit ?a\n\ngoal (1 subgoal):\n 1. c1 \\<noteq> c2", "by blast"], ["", "lemma degree_minus_eq_right:\nfixes p::\"'b::ab_group_add poly\"\nshows \"degree q < degree p \\<Longrightarrow> degree (p - q) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q < degree p \\<Longrightarrow> degree (p - q) = degree p", "using degree_add_eq_left[of \"-q\" p] degree_minus"], ["proof (prove)\nusing this:\n  degree (- q) < degree p \\<Longrightarrow> degree (p + - q) = degree p\n  degree (- ?p) = degree ?p\n\ngoal (1 subgoal):\n 1. degree q < degree p \\<Longrightarrow> degree (p - q) = degree p", "by auto"], ["", "lemma coprime_prod:\n  fixes A::\"'a mod_ring set\" and g::\"'a mod_ring \\<Rightarrow> 'a mod_ring poly\"\n  assumes \"\\<forall>x\\<in>A. coprime (g a) (g x)\"\n  shows \"coprime (g a) (prod (\\<lambda>x. g x) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (g a) (prod g A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (g a) (prod g A)", "have f: \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "by simp"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (g a) (prod g A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (g a) (prod g A)", "using f"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (g a) (prod g A)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  \\<forall>x\\<in>A. comm_monoid_mult_class.coprime (g a) (g x)\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (g a) (prod g A)", "proof (induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>{}.\n       comm_monoid_mult_class.coprime (g a) (g x) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime (g a) (prod g {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<forall>x\\<in>F.\n           comm_monoid_mult_class.coprime (g a) (g x) \\<Longrightarrow>\n        comm_monoid_mult_class.coprime (g a) (prod g F);\n        \\<forall>x\\<in>insert x F.\n           comm_monoid_mult_class.coprime (g a) (g x)\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime (g a)\n                          (prod g (insert x F))", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  \\<forall>x\\<in>A.\n     comm_monoid_mult_class.coprime (g a) (g x) \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (g a) (prod g A)\n  \\<forall>x\\<in>insert x A. comm_monoid_mult_class.coprime (g a) (g x)\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>{}.\n       comm_monoid_mult_class.coprime (g a) (g x) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime (g a) (prod g {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<forall>x\\<in>F.\n           comm_monoid_mult_class.coprime (g a) (g x) \\<Longrightarrow>\n        comm_monoid_mult_class.coprime (g a) (prod g F);\n        \\<forall>x\\<in>insert x F.\n           comm_monoid_mult_class.coprime (g a) (g x)\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime (g a)\n                          (prod g (insert x F))", "have \"(\\<Prod>c\\<in>insert x A. g c) = (g x) * (\\<Prod>c\\<in>A. g c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod g (insert x A) = g x * prod g A", "by (simp add: insert.hyps(2))"], ["proof (state)\nthis:\n  prod g (insert x A) = g x * prod g A\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>{}.\n       comm_monoid_mult_class.coprime (g a) (g x) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime (g a) (prod g {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<forall>x\\<in>F.\n           comm_monoid_mult_class.coprime (g a) (g x) \\<Longrightarrow>\n        comm_monoid_mult_class.coprime (g a) (prod g F);\n        \\<forall>x\\<in>insert x F.\n           comm_monoid_mult_class.coprime (g a) (g x)\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime (g a)\n                          (prod g (insert x F))", "with insert.prems"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>insert x A. comm_monoid_mult_class.coprime (g a) (g x)\n  prod g (insert x A) = g x * prod g A", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>insert x A. comm_monoid_mult_class.coprime (g a) (g x)\n  prod g (insert x A) = g x * prod g A\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (g a) (prod g (insert x A))", "by (auto simp: insert.hyps(3) prod_coprime_right)"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (g a) (prod g (insert x A))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{}.\n       comm_monoid_mult_class.coprime (g a) (g x) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime (g a) (prod g {})", "qed auto"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (g a) (prod g A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coprime_prod2:\n  fixes A::\"'b::semiring_gcd set\"\n  assumes \"\\<forall>x\\<in>A. coprime (a) (x)\" and f: \"finite A\"\n  shows \"coprime (a) (prod (\\<lambda>x. x) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime a (\\<Prod>A)", "using f"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime a (\\<Prod>A)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  \\<forall>x\\<in>A. comm_monoid_mult_class.coprime a x\n  finite A\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime a (\\<Prod>A)", "proof (induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Ball {} (comm_monoid_mult_class.coprime a); finite {}\\<rbrakk>\n    \\<Longrightarrow> comm_monoid_mult_class.coprime a (\\<Prod>{})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>Ball F (comm_monoid_mult_class.coprime a);\n         finite F\\<rbrakk>\n        \\<Longrightarrow> comm_monoid_mult_class.coprime a (\\<Prod>F);\n        Ball (insert x F) (comm_monoid_mult_class.coprime a);\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime a\n                          (\\<Prod>(insert x F))", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>\\<forall>b\\<in>A. comm_monoid_mult_class.coprime a b;\n   finite A\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime a (\\<Prod>A)\n  \\<forall>b\\<in>insert x A. comm_monoid_mult_class.coprime a b\n  finite (insert x A)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Ball {} (comm_monoid_mult_class.coprime a); finite {}\\<rbrakk>\n    \\<Longrightarrow> comm_monoid_mult_class.coprime a (\\<Prod>{})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>Ball F (comm_monoid_mult_class.coprime a);\n         finite F\\<rbrakk>\n        \\<Longrightarrow> comm_monoid_mult_class.coprime a (\\<Prod>F);\n        Ball (insert x F) (comm_monoid_mult_class.coprime a);\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime a\n                          (\\<Prod>(insert x F))", "have \"(\\<Prod>c\\<in>insert x A. c) = (x) * (\\<Prod>c\\<in>A. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>(insert x A) = x * \\<Prod>A", "by (simp add: insert.hyps)"], ["proof (state)\nthis:\n  \\<Prod>(insert x A) = x * \\<Prod>A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Ball {} (comm_monoid_mult_class.coprime a); finite {}\\<rbrakk>\n    \\<Longrightarrow> comm_monoid_mult_class.coprime a (\\<Prod>{})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>Ball F (comm_monoid_mult_class.coprime a);\n         finite F\\<rbrakk>\n        \\<Longrightarrow> comm_monoid_mult_class.coprime a (\\<Prod>F);\n        Ball (insert x F) (comm_monoid_mult_class.coprime a);\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime a\n                          (\\<Prod>(insert x F))", "with insert.prems"], ["proof (chain)\npicking this:\n  \\<forall>b\\<in>insert x A. comm_monoid_mult_class.coprime a b\n  finite (insert x A)\n  \\<Prod>(insert x A) = x * \\<Prod>A", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>insert x A. comm_monoid_mult_class.coprime a b\n  finite (insert x A)\n  \\<Prod>(insert x A) = x * \\<Prod>A\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime a (\\<Prod>(insert x A))", "by (simp add: insert.hyps prod_coprime_right)"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime a (\\<Prod>(insert x A))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball {} (comm_monoid_mult_class.coprime a); finite {}\\<rbrakk>\n    \\<Longrightarrow> comm_monoid_mult_class.coprime a (\\<Prod>{})", "qed auto"], ["", "lemma divides_prod:\n  fixes g::\"'a mod_ring \\<Rightarrow> 'a mod_ring poly\"\n  assumes \"\\<forall>c1 c2. c1 \\<in> A \\<and> c2 \\<in> A \\<and> c1 \\<noteq> c2 \\<longrightarrow> coprime (g c1) (g c2)\"\n  assumes \"\\<forall>c\\<in> A. g c dvd f\"\n  shows \"(\\<Prod>c\\<in>A. g c) dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod g A dvd f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod g A dvd f", "have finite_A: \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "using finite[of A]"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite A", "."], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. prod g A dvd f", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. prod g A dvd f", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  \\<forall>c1 c2.\n     c1 \\<in> A \\<and> c2 \\<in> A \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime (g c1) (g c2)\n  \\<forall>c\\<in>A. g c dvd f\n\ngoal (1 subgoal):\n 1. prod g A dvd f", "proof (induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>c1 c2.\n                c1 \\<in> {} \\<and>\n                c2 \\<in> {} \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n                comm_monoid_mult_class.coprime (g c1) (g c2);\n     \\<forall>c\\<in>{}. g c dvd f\\<rbrakk>\n    \\<Longrightarrow> prod g {} dvd f\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>c1 c2.\n                    c1 \\<in> F \\<and>\n                    c2 \\<in> F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n                    comm_monoid_mult_class.coprime (g c1) (g c2);\n         \\<forall>c\\<in>F. g c dvd f\\<rbrakk>\n        \\<Longrightarrow> prod g F dvd f;\n        \\<forall>c1 c2.\n           c1 \\<in> insert x F \\<and>\n           c2 \\<in> insert x F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime (g c1) (g c2);\n        \\<forall>c\\<in>insert x F. g c dvd f\\<rbrakk>\n       \\<Longrightarrow> prod g (insert x F) dvd f", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>\\<forall>c1 c2.\n              c1 \\<in> A \\<and>\n              c2 \\<in> A \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n              comm_monoid_mult_class.coprime (g c1) (g c2);\n   \\<forall>c\\<in>A. g c dvd f\\<rbrakk>\n  \\<Longrightarrow> prod g A dvd f\n  \\<forall>c1 c2.\n     c1 \\<in> insert x A \\<and>\n     c2 \\<in> insert x A \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime (g c1) (g c2)\n  \\<forall>c\\<in>insert x A. g c dvd f\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>c1 c2.\n                c1 \\<in> {} \\<and>\n                c2 \\<in> {} \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n                comm_monoid_mult_class.coprime (g c1) (g c2);\n     \\<forall>c\\<in>{}. g c dvd f\\<rbrakk>\n    \\<Longrightarrow> prod g {} dvd f\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>c1 c2.\n                    c1 \\<in> F \\<and>\n                    c2 \\<in> F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n                    comm_monoid_mult_class.coprime (g c1) (g c2);\n         \\<forall>c\\<in>F. g c dvd f\\<rbrakk>\n        \\<Longrightarrow> prod g F dvd f;\n        \\<forall>c1 c2.\n           c1 \\<in> insert x F \\<and>\n           c2 \\<in> insert x F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime (g c1) (g c2);\n        \\<forall>c\\<in>insert x F. g c dvd f\\<rbrakk>\n       \\<Longrightarrow> prod g (insert x F) dvd f", "have \"(\\<Prod>c\\<in>insert x A. g c) =  g x * (\\<Prod>c\\<in> A. g c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod g (insert x A) = g x * prod g A", "by (simp add: insert.hyps(2))"], ["proof (state)\nthis:\n  prod g (insert x A) = g x * prod g A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>c1 c2.\n                c1 \\<in> {} \\<and>\n                c2 \\<in> {} \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n                comm_monoid_mult_class.coprime (g c1) (g c2);\n     \\<forall>c\\<in>{}. g c dvd f\\<rbrakk>\n    \\<Longrightarrow> prod g {} dvd f\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>c1 c2.\n                    c1 \\<in> F \\<and>\n                    c2 \\<in> F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n                    comm_monoid_mult_class.coprime (g c1) (g c2);\n         \\<forall>c\\<in>F. g c dvd f\\<rbrakk>\n        \\<Longrightarrow> prod g F dvd f;\n        \\<forall>c1 c2.\n           c1 \\<in> insert x F \\<and>\n           c2 \\<in> insert x F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime (g c1) (g c2);\n        \\<forall>c\\<in>insert x F. g c dvd f\\<rbrakk>\n       \\<Longrightarrow> prod g (insert x F) dvd f", "also"], ["proof (state)\nthis:\n  prod g (insert x A) = g x * prod g A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>c1 c2.\n                c1 \\<in> {} \\<and>\n                c2 \\<in> {} \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n                comm_monoid_mult_class.coprime (g c1) (g c2);\n     \\<forall>c\\<in>{}. g c dvd f\\<rbrakk>\n    \\<Longrightarrow> prod g {} dvd f\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>c1 c2.\n                    c1 \\<in> F \\<and>\n                    c2 \\<in> F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n                    comm_monoid_mult_class.coprime (g c1) (g c2);\n         \\<forall>c\\<in>F. g c dvd f\\<rbrakk>\n        \\<Longrightarrow> prod g F dvd f;\n        \\<forall>c1 c2.\n           c1 \\<in> insert x F \\<and>\n           c2 \\<in> insert x F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime (g c1) (g c2);\n        \\<forall>c\\<in>insert x F. g c dvd f\\<rbrakk>\n       \\<Longrightarrow> prod g (insert x F) dvd f", "have \"... dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g x * prod g A dvd f", "proof (rule divides_mult)"], ["proof (state)\ngoal (3 subgoals):\n 1. g x dvd f\n 2. prod g A dvd f\n 3. algebraic_semidom_class.coprime (g x) (prod g A)", "show \"g x dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g x dvd f", "using insert.prems"], ["proof (prove)\nusing this:\n  \\<forall>c1 c2.\n     c1 \\<in> insert x A \\<and>\n     c2 \\<in> insert x A \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime (g c1) (g c2)\n  \\<forall>c\\<in>insert x A. g c dvd f\n\ngoal (1 subgoal):\n 1. g x dvd f", "by auto"], ["proof (state)\nthis:\n  g x dvd f\n\ngoal (2 subgoals):\n 1. prod g A dvd f\n 2. algebraic_semidom_class.coprime (g x) (prod g A)", "show \"prod g A dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod g A dvd f", "using insert.hyps(3) insert.prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>c1 c2.\n              c1 \\<in> A \\<and>\n              c2 \\<in> A \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n              comm_monoid_mult_class.coprime (g c1) (g c2);\n   \\<forall>c\\<in>A. g c dvd f\\<rbrakk>\n  \\<Longrightarrow> prod g A dvd f\n  \\<forall>c1 c2.\n     c1 \\<in> insert x A \\<and>\n     c2 \\<in> insert x A \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime (g c1) (g c2)\n  \\<forall>c\\<in>insert x A. g c dvd f\n\ngoal (1 subgoal):\n 1. prod g A dvd f", "by auto"], ["proof (state)\nthis:\n  prod g A dvd f\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime (g x) (prod g A)", "from insert"], ["proof (chain)\npicking this:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>\\<forall>c1 c2.\n              c1 \\<in> A \\<and>\n              c2 \\<in> A \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n              comm_monoid_mult_class.coprime (g c1) (g c2);\n   \\<forall>c\\<in>A. g c dvd f\\<rbrakk>\n  \\<Longrightarrow> prod g A dvd f\n  \\<forall>c1 c2.\n     c1 \\<in> insert x A \\<and>\n     c2 \\<in> insert x A \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime (g c1) (g c2)\n  \\<forall>c\\<in>insert x A. g c dvd f", "show \"Rings.coprime (g x) (prod g A)\""], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>\\<forall>c1 c2.\n              c1 \\<in> A \\<and>\n              c2 \\<in> A \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n              comm_monoid_mult_class.coprime (g c1) (g c2);\n   \\<forall>c\\<in>A. g c dvd f\\<rbrakk>\n  \\<Longrightarrow> prod g A dvd f\n  \\<forall>c1 c2.\n     c1 \\<in> insert x A \\<and>\n     c2 \\<in> insert x A \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime (g c1) (g c2)\n  \\<forall>c\\<in>insert x A. g c dvd f\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime (g x) (prod g A)", "by (auto intro: prod_coprime_right)"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime (g x) (prod g A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g x * prod g A dvd f\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>c1 c2.\n                c1 \\<in> {} \\<and>\n                c2 \\<in> {} \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n                comm_monoid_mult_class.coprime (g c1) (g c2);\n     \\<forall>c\\<in>{}. g c dvd f\\<rbrakk>\n    \\<Longrightarrow> prod g {} dvd f\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>c1 c2.\n                    c1 \\<in> F \\<and>\n                    c2 \\<in> F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n                    comm_monoid_mult_class.coprime (g c1) (g c2);\n         \\<forall>c\\<in>F. g c dvd f\\<rbrakk>\n        \\<Longrightarrow> prod g F dvd f;\n        \\<forall>c1 c2.\n           c1 \\<in> insert x F \\<and>\n           c2 \\<in> insert x F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime (g c1) (g c2);\n        \\<forall>c\\<in>insert x F. g c dvd f\\<rbrakk>\n       \\<Longrightarrow> prod g (insert x F) dvd f", "finally"], ["proof (chain)\npicking this:\n  prod g (insert x A) dvd f", "show ?case"], ["proof (prove)\nusing this:\n  prod g (insert x A) dvd f\n\ngoal (1 subgoal):\n 1. prod g (insert x A) dvd f", "."], ["proof (state)\nthis:\n  prod g (insert x A) dvd f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c1 c2.\n                c1 \\<in> {} \\<and>\n                c2 \\<in> {} \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n                comm_monoid_mult_class.coprime (g c1) (g c2);\n     \\<forall>c\\<in>{}. g c dvd f\\<rbrakk>\n    \\<Longrightarrow> prod g {} dvd f", "qed auto"], ["proof (state)\nthis:\n  prod g A dvd f\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\n  Proof of equation 9 in the book by Knuth\n  x^p - x = (x-0)(x-1)...(x-(p-1))  (mod p)\n*)"], ["", "lemma poly_monom_identity_mod_p:\n  \"monom (1::'a mod_ring) (CARD('a)) - monom 1 1 = prod (\\<lambda>x. [:0,1:] - [:x:]) (UNIV::'a mod_ring set)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "let ?f=\"(\\<lambda>x::'a mod_ring. [:0,1:] - [:x:])\""], ["proof (state)\ngoal (1 subgoal):\n 1. monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "have \"?rhs dvd ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) dvd monom 1 CARD('a) - monom 1 1", "proof (rule divides_prod)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>c1 c2.\n       c1 \\<in> UNIV \\<and>\n       c2 \\<in> UNIV \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime ([:0, 1:] - [:c1:])\n        ([:0, 1:] - [:c2:])\n 2. \\<forall>x\\<in>UNIV. [:0, 1:] - [:x:] dvd monom 1 CARD('a) - monom 1 1", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>c1 c2.\n       c1 \\<in> UNIV \\<and>\n       c2 \\<in> UNIV \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime ([:0, 1:] - [:c1:])\n        ([:0, 1:] - [:c2:])\n 2. \\<forall>x\\<in>UNIV. [:0, 1:] - [:x:] dvd monom 1 CARD('a) - monom 1 1", "fix a::\"'a mod_ring\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>c1 c2.\n       c1 \\<in> UNIV \\<and>\n       c2 \\<in> UNIV \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime ([:0, 1:] - [:c1:])\n        ([:0, 1:] - [:c2:])\n 2. \\<forall>x\\<in>UNIV. [:0, 1:] - [:x:] dvd monom 1 CARD('a) - monom 1 1", "have \"poly ?lhs a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (monom 1 CARD('a) - monom 1 1) a = 0", "by (simp add: poly_monom)"], ["proof (state)\nthis:\n  poly (monom 1 CARD('a) - monom 1 1) a = 0\n\ngoal (2 subgoals):\n 1. \\<forall>c1 c2.\n       c1 \\<in> UNIV \\<and>\n       c2 \\<in> UNIV \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime ([:0, 1:] - [:c1:])\n        ([:0, 1:] - [:c2:])\n 2. \\<forall>x\\<in>UNIV. [:0, 1:] - [:x:] dvd monom 1 CARD('a) - monom 1 1", "hence \"([:0,1:] - [:a:]) dvd ?lhs\""], ["proof (prove)\nusing this:\n  poly (monom 1 CARD('a) - monom 1 1) a = 0\n\ngoal (1 subgoal):\n 1. [:0, 1:] - [:a:] dvd monom 1 CARD('a) - monom 1 1", "using poly_eq_0_iff_dvd"], ["proof (prove)\nusing this:\n  poly (monom 1 CARD('a) - monom 1 1) a = 0\n  (poly ?p ?c = (0::?'a)) = ([:- ?c, 1::?'a:] dvd ?p)\n\ngoal (1 subgoal):\n 1. [:0, 1:] - [:a:] dvd monom 1 CARD('a) - monom 1 1", "by fastforce"], ["proof (state)\nthis:\n  [:0, 1:] - [:a:] dvd monom 1 CARD('a) - monom 1 1\n\ngoal (2 subgoals):\n 1. \\<forall>c1 c2.\n       c1 \\<in> UNIV \\<and>\n       c2 \\<in> UNIV \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime ([:0, 1:] - [:c1:])\n        ([:0, 1:] - [:c2:])\n 2. \\<forall>x\\<in>UNIV. [:0, 1:] - [:x:] dvd monom 1 CARD('a) - monom 1 1", "}"], ["proof (state)\nthis:\n  [:0, 1:] - [:?a2:] dvd monom 1 CARD('a) - monom 1 1\n\ngoal (2 subgoals):\n 1. \\<forall>c1 c2.\n       c1 \\<in> UNIV \\<and>\n       c2 \\<in> UNIV \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime ([:0, 1:] - [:c1:])\n        ([:0, 1:] - [:c2:])\n 2. \\<forall>x\\<in>UNIV. [:0, 1:] - [:x:] dvd monom 1 CARD('a) - monom 1 1", "thus \"\\<forall>x\\<in>UNIV::'a mod_ring set. [:0, 1:] - [:x:] dvd monom 1 CARD('a) - monom 1 1\""], ["proof (prove)\nusing this:\n  [:0, 1:] - [:?a2:] dvd monom 1 CARD('a) - monom 1 1\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV. [:0, 1:] - [:x:] dvd monom 1 CARD('a) - monom 1 1", "by fast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>UNIV. [:0, 1:] - [:x:] dvd monom 1 CARD('a) - monom 1 1\n\ngoal (1 subgoal):\n 1. \\<forall>c1 c2.\n       c1 \\<in> UNIV \\<and>\n       c2 \\<in> UNIV \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime ([:0, 1:] - [:c1:])\n        ([:0, 1:] - [:c2:])", "show \"\\<forall>c1 c2. c1 \\<in> UNIV \\<and> c2 \\<in> UNIV \\<and> c1 \\<noteq> (c2 :: 'a mod_ring) \\<longrightarrow> coprime ([:0, 1:] - [:c1:]) ([:0, 1:] - [:c2:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c1 c2.\n       c1 \\<in> UNIV \\<and>\n       c2 \\<in> UNIV \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime ([:0, 1:] - [:c1:])\n        ([:0, 1:] - [:c2:])", "by (auto dest!: coprime_h_c_poly[of _ _ \"[:0,1:]\"])"], ["proof (state)\nthis:\n  \\<forall>c1 c2.\n     c1 \\<in> UNIV \\<and>\n     c2 \\<in> UNIV \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime ([:0, 1:] - [:c1:]) ([:0, 1:] - [:c2:])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) dvd monom 1 CARD('a) - monom 1 1\n\ngoal (1 subgoal):\n 1. monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "from this"], ["proof (chain)\npicking this:\n  (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) dvd monom 1 CARD('a) - monom 1 1", "obtain g where g: \"?lhs = ?rhs * g\""], ["proof (prove)\nusing this:\n  (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) dvd monom 1 CARD('a) - monom 1 1\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        monom 1 CARD('a) - monom 1 1 =\n        (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) * g \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using dvdE"], ["proof (prove)\nusing this:\n  (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) dvd monom 1 CARD('a) - monom 1 1\n  \\<lbrakk>?b dvd ?a; \\<And>k. ?a = ?b * k \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        monom 1 CARD('a) - monom 1 1 =\n        (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) * g \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) * g\n\ngoal (1 subgoal):\n 1. monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "have degree_lhs_card: \"degree ?lhs = CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom 1 CARD('a) - monom 1 1) = CARD('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (monom 1 CARD('a) - monom 1 1) = CARD('a)", "have \"degree (monom (1::'a mod_ring) 1) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom 1 1) = 1", "by (simp add: degree_monom_eq)"], ["proof (state)\nthis:\n  degree (monom 1 1) = 1\n\ngoal (1 subgoal):\n 1. degree (monom 1 CARD('a) - monom 1 1) = CARD('a)", "moreover"], ["proof (state)\nthis:\n  degree (monom 1 1) = 1\n\ngoal (1 subgoal):\n 1. degree (monom 1 CARD('a) - monom 1 1) = CARD('a)", "have d_c: \"degree (monom (1::'a mod_ring) CARD('a)) = CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom 1 CARD('a)) = CARD('a)", "by (simp add: degree_monom_eq)"], ["proof (state)\nthis:\n  degree (monom 1 CARD('a)) = CARD('a)\n\ngoal (1 subgoal):\n 1. degree (monom 1 CARD('a) - monom 1 1) = CARD('a)", "ultimately"], ["proof (chain)\npicking this:\n  degree (monom 1 1) = 1\n  degree (monom 1 CARD('a)) = CARD('a)", "have \"degree (monom (1::'a mod_ring) 1) < degree (monom (1::'a mod_ring) CARD('a))\""], ["proof (prove)\nusing this:\n  degree (monom 1 1) = 1\n  degree (monom 1 CARD('a)) = CARD('a)\n\ngoal (1 subgoal):\n 1. degree (monom 1 1) < degree (monom 1 CARD('a))", "using prime_card"], ["proof (prove)\nusing this:\n  degree (monom 1 1) = 1\n  degree (monom 1 CARD('a)) = CARD('a)\n  prime CARD(?'a)\n\ngoal (1 subgoal):\n 1. degree (monom 1 1) < degree (monom 1 CARD('a))", "unfolding prime_nat_iff"], ["proof (prove)\nusing this:\n  degree (monom 1 1) = 1\n  degree (monom 1 CARD('a)) = CARD('a)\n  1 < CARD(?'a) \\<and>\n  (\\<forall>m. m dvd CARD(?'a) \\<longrightarrow> m = 1 \\<or> m = CARD(?'a))\n\ngoal (1 subgoal):\n 1. degree (monom 1 1) < degree (monom 1 CARD('a))", "by auto"], ["proof (state)\nthis:\n  degree (monom 1 1) < degree (monom 1 CARD('a))\n\ngoal (1 subgoal):\n 1. degree (monom 1 CARD('a) - monom 1 1) = CARD('a)", "hence \"degree ?lhs = degree (monom (1::'a mod_ring) CARD('a))\""], ["proof (prove)\nusing this:\n  degree (monom 1 1) < degree (monom 1 CARD('a))\n\ngoal (1 subgoal):\n 1. degree (monom 1 CARD('a) - monom 1 1) = degree (monom 1 CARD('a))", "by (rule degree_minus_eq_right)"], ["proof (state)\nthis:\n  degree (monom 1 CARD('a) - monom 1 1) = degree (monom 1 CARD('a))\n\ngoal (1 subgoal):\n 1. degree (monom 1 CARD('a) - monom 1 1) = CARD('a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree (monom 1 CARD('a) - monom 1 1) = degree (monom 1 CARD('a))\n\ngoal (1 subgoal):\n 1. degree (monom 1 CARD('a) - monom 1 1) = CARD('a)", "unfolding d_c"], ["proof (prove)\nusing this:\n  degree (monom 1 CARD('a) - monom 1 1) = CARD('a)\n\ngoal (1 subgoal):\n 1. degree (monom 1 CARD('a) - monom 1 1) = CARD('a)", "."], ["proof (state)\nthis:\n  degree (monom 1 CARD('a) - monom 1 1) = CARD('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (monom 1 CARD('a) - monom 1 1) = CARD('a)\n\ngoal (1 subgoal):\n 1. monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "have degree_rhs_card: \"degree ?rhs = CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) = CARD('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) = CARD('a)", "have \"degree (prod ?f UNIV) = sum (degree \\<circ> ?f) UNIV\n      \\<and> coeff (prod ?f UNIV) (sum (degree \\<circ> ?f) UNIV) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) =\n    sum (degree \\<circ> (\\<lambda>x. [:0, 1:] - [:x:])) UNIV \\<and>\n    coeff (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])\n     (sum (degree \\<circ> (\\<lambda>x. [:0, 1:] - [:x:])) UNIV) =\n    1", "by (rule degree_prod_sum_monic, auto)"], ["proof (state)\nthis:\n  degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) =\n  sum (degree \\<circ> (\\<lambda>x. [:0, 1:] - [:x:])) UNIV \\<and>\n  coeff (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])\n   (sum (degree \\<circ> (\\<lambda>x. [:0, 1:] - [:x:])) UNIV) =\n  1\n\ngoal (1 subgoal):\n 1. degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) = CARD('a)", "moreover"], ["proof (state)\nthis:\n  degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) =\n  sum (degree \\<circ> (\\<lambda>x. [:0, 1:] - [:x:])) UNIV \\<and>\n  coeff (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])\n   (sum (degree \\<circ> (\\<lambda>x. [:0, 1:] - [:x:])) UNIV) =\n  1\n\ngoal (1 subgoal):\n 1. degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) = CARD('a)", "have \"sum (degree \\<circ> ?f) UNIV = CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (degree \\<circ> (\\<lambda>x. [:0, 1:] - [:x:])) UNIV = CARD('a)", "by auto"], ["proof (state)\nthis:\n  sum (degree \\<circ> (\\<lambda>x. [:0, 1:] - [:x:])) UNIV = CARD('a)\n\ngoal (1 subgoal):\n 1. degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) = CARD('a)", "ultimately"], ["proof (chain)\npicking this:\n  degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) =\n  sum (degree \\<circ> (\\<lambda>x. [:0, 1:] - [:x:])) UNIV \\<and>\n  coeff (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])\n   (sum (degree \\<circ> (\\<lambda>x. [:0, 1:] - [:x:])) UNIV) =\n  1\n  sum (degree \\<circ> (\\<lambda>x. [:0, 1:] - [:x:])) UNIV = CARD('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) =\n  sum (degree \\<circ> (\\<lambda>x. [:0, 1:] - [:x:])) UNIV \\<and>\n  coeff (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])\n   (sum (degree \\<circ> (\\<lambda>x. [:0, 1:] - [:x:])) UNIV) =\n  1\n  sum (degree \\<circ> (\\<lambda>x. [:0, 1:] - [:x:])) UNIV = CARD('a)\n\ngoal (1 subgoal):\n 1. degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) = CARD('a)", "by presburger"], ["proof (state)\nthis:\n  degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) = CARD('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) = CARD('a)\n\ngoal (1 subgoal):\n 1. monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "have monic_lhs: \"monic ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (monom 1 CARD('a) - monom 1 1)", "using degree_lhs_card"], ["proof (prove)\nusing this:\n  degree (monom 1 CARD('a) - monom 1 1) = CARD('a)\n\ngoal (1 subgoal):\n 1. monic (monom 1 CARD('a) - monom 1 1)", "by auto"], ["proof (state)\nthis:\n  monic (monom 1 CARD('a) - monom 1 1)\n\ngoal (1 subgoal):\n 1. monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "have monic_rhs: \"monic ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "by (rule monic_prod, simp)"], ["proof (state)\nthis:\n  monic (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])\n\ngoal (1 subgoal):\n 1. monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "have degree_eq: \"degree ?rhs = degree ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) =\n    degree (monom 1 CARD('a) - monom 1 1)", "unfolding degree_lhs_card degree_rhs_card"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a) = CARD('a)", ".."], ["proof (state)\nthis:\n  degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) =\n  degree (monom 1 CARD('a) - monom 1 1)\n\ngoal (1 subgoal):\n 1. monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "have g_not_0: \"g \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "using g monic_lhs"], ["proof (prove)\nusing this:\n  monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) * g\n  monic (monom 1 CARD('a) - monom 1 1)\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "have degree_g0: \"degree g = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree g = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree g = 0", "have \"degree (?rhs * g) = degree ?rhs + degree g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ((\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) * g) =\n    degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) + degree g", "by (rule degree_monic_mult[OF monic_rhs g_not_0])"], ["proof (state)\nthis:\n  degree ((\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) * g) =\n  degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) + degree g\n\ngoal (1 subgoal):\n 1. degree g = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree ((\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) * g) =\n  degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) + degree g\n\ngoal (1 subgoal):\n 1. degree g = 0", "using degree_eq g"], ["proof (prove)\nusing this:\n  degree ((\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) * g) =\n  degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) + degree g\n  degree (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) =\n  degree (monom 1 CARD('a) - monom 1 1)\n  monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) * g\n\ngoal (1 subgoal):\n 1. degree g = 0", "by simp"], ["proof (state)\nthis:\n  degree g = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree g = 0\n\ngoal (1 subgoal):\n 1. monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "have monic_g: \"monic g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic g", "using monic_factor g monic_lhs monic_rhs"], ["proof (prove)\nusing this:\n  \\<lbrakk>monic (?p * ?q); monic ?p\\<rbrakk> \\<Longrightarrow> monic ?q\n  monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) * g\n  monic (monom 1 CARD('a) - monom 1 1)\n  monic (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])\n\ngoal (1 subgoal):\n 1. monic g", "by auto"], ["proof (state)\nthis:\n  monic g\n\ngoal (1 subgoal):\n 1. monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "have \"g = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = 1", "using monic_degree_0[OF monic_g] degree_g0"], ["proof (prove)\nusing this:\n  (degree g = 0) = (g = 1)\n  degree g = 0\n\ngoal (1 subgoal):\n 1. g = 1", "by simp"], ["proof (state)\nthis:\n  g = 1\n\ngoal (1 subgoal):\n 1. monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "thus ?thesis"], ["proof (prove)\nusing this:\n  g = 1\n\ngoal (1 subgoal):\n 1. monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "using g"], ["proof (prove)\nusing this:\n  g = 1\n  monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) * g\n\ngoal (1 subgoal):\n 1. monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])", "by auto"], ["proof (state)\nthis:\n  monom 1 CARD('a) - monom 1 1 = (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:])\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\n  Proof of equation 10 in the book by Knuth\n  v(x)^p - v(x) = (v(x)-0)(v(x)-1)...(v(x)-(p-1))  (mod p)\n*)"], ["", "lemma poly_identity_mod_p:\n  \"v^(CARD('a)) - v = prod (\\<lambda>x. v - [:x:]) (UNIV::'a mod_ring set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v ^ CARD('a) - v = (\\<Prod>x\\<in>UNIV. v - [:x:])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v ^ CARD('a) - v = (\\<Prod>x\\<in>UNIV. v - [:x:])", "have id: \"monom 1 1 \\<circ>\\<^sub>p v = v\" \"[:0, 1:] \\<circ>\\<^sub>p v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 1 1 \\<circ>\\<^sub>p v = v &&& [:0, 1:] \\<circ>\\<^sub>p v = v", "unfolding pcompose_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold_coeffs (\\<lambda>a c. [:a:] + v * c) (monom 1 1) 0 = v &&&\n    fold_coeffs (\\<lambda>a c. [:a:] + v * c) [:0, 1:] 0 = v", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold_coeffs (\\<lambda>a c. [:a:] + v * c) 1 0 \\<noteq>\n    1 \\<Longrightarrow>\n    v = 0", "by (simp add: fold_coeffs_def)"], ["proof (state)\nthis:\n  monom 1 1 \\<circ>\\<^sub>p v = v\n  [:0, 1:] \\<circ>\\<^sub>p v = v\n\ngoal (1 subgoal):\n 1. v ^ CARD('a) - v = (\\<Prod>x\\<in>UNIV. v - [:x:])", "have id2: \"monom 1 (CARD('a)) \\<circ>\\<^sub>p v = v ^ (CARD('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 1 CARD('a) \\<circ>\\<^sub>p v = v ^ CARD('a)", "by (metis id(1) pcompose_hom.hom_power x_pow_n)"], ["proof (state)\nthis:\n  monom 1 CARD('a) \\<circ>\\<^sub>p v = v ^ CARD('a)\n\ngoal (1 subgoal):\n 1. v ^ CARD('a) - v = (\\<Prod>x\\<in>UNIV. v - [:x:])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. v ^ CARD('a) - v = (\\<Prod>x\\<in>UNIV. v - [:x:])", "using arg_cong[OF poly_monom_identity_mod_p, of \"\\<lambda> f. f \\<circ>\\<^sub>p v\"]"], ["proof (prove)\nusing this:\n  (monom 1 CARD('a) - monom 1 1) \\<circ>\\<^sub>p v =\n  (\\<Prod>x\\<in>UNIV. [:0, 1:] - [:x:]) \\<circ>\\<^sub>p v\n\ngoal (1 subgoal):\n 1. v ^ CARD('a) - v = (\\<Prod>x\\<in>UNIV. v - [:x:])", "unfolding pcompose_hom.hom_minus pcompose_hom.hom_prod id pcompose_const id2"], ["proof (prove)\nusing this:\n  v ^ CARD('a) - v = (\\<Prod>x\\<in>UNIV. v - [:x:])\n\ngoal (1 subgoal):\n 1. v ^ CARD('a) - v = (\\<Prod>x\\<in>UNIV. v - [:x:])", "."], ["proof (state)\nthis:\n  v ^ CARD('a) - v = (\\<Prod>x\\<in>UNIV. v - [:x:])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coprime_gcd:\n  fixes h::\"'a mod_ring poly\"\n  assumes \"Rings.coprime (h-[:c1:]) (h-[:c2:])\"\n  shows \"Rings.coprime (gcd f(h-[:c1:])) (gcd f (h-[:c2:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime (gcd f (h - [:c1:]))\n     (gcd f (h - [:c2:]))", "using assms coprime_divisors"], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime (h - [:c1:]) (h - [:c2:])\n  \\<lbrakk>?a dvd ?c; ?b dvd ?d;\n   algebraic_semidom_class.coprime ?c ?d\\<rbrakk>\n  \\<Longrightarrow> algebraic_semidom_class.coprime ?a ?b\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime (gcd f (h - [:c1:]))\n     (gcd f (h - [:c2:]))", "by blast"], ["", "lemma divides_prod_gcd:\n  fixes h::\"'a mod_ring poly\"\n  assumes \"\\<forall>c1 c2. c1 \\<in> A \\<and> c2 \\<in> A \\<and> c1 \\<noteq> c2\\<longrightarrow> coprime (h-[:c1:]) (h-[:c2:])\"\n  shows \"(\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f", "have finite_A: \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "using finite[of A]"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite A", "."], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  \\<forall>c1 c2.\n     c1 \\<in> A \\<and> c2 \\<in> A \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime (h - [:c1:]) (h - [:c2:])\n\ngoal (1 subgoal):\n 1. (\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f", "proof (induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>c1 c2.\n       c1 \\<in> {} \\<and>\n       c2 \\<in> {} \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime (h - [:c1:])\n        (h - [:c2:]) \\<Longrightarrow>\n    (\\<Prod>c\\<in>{}. gcd f (h - [:c:])) dvd f\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<forall>c1 c2.\n           c1 \\<in> F \\<and>\n           c2 \\<in> F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime (h - [:c1:])\n            (h - [:c2:]) \\<Longrightarrow>\n        (\\<Prod>c\\<in>F. gcd f (h - [:c:])) dvd f;\n        \\<forall>c1 c2.\n           c1 \\<in> insert x F \\<and>\n           c2 \\<in> insert x F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime (h - [:c1:]) (h - [:c2:])\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>c\\<in>insert x F. gcd f (h - [:c:])) dvd f", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  \\<forall>c1 c2.\n     c1 \\<in> A \\<and> c2 \\<in> A \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime (h - [:c1:])\n      (h - [:c2:]) \\<Longrightarrow>\n  (\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f\n  \\<forall>c1 c2.\n     c1 \\<in> insert x A \\<and>\n     c2 \\<in> insert x A \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime (h - [:c1:]) (h - [:c2:])\n\ngoal (2 subgoals):\n 1. \\<forall>c1 c2.\n       c1 \\<in> {} \\<and>\n       c2 \\<in> {} \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime (h - [:c1:])\n        (h - [:c2:]) \\<Longrightarrow>\n    (\\<Prod>c\\<in>{}. gcd f (h - [:c:])) dvd f\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<forall>c1 c2.\n           c1 \\<in> F \\<and>\n           c2 \\<in> F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime (h - [:c1:])\n            (h - [:c2:]) \\<Longrightarrow>\n        (\\<Prod>c\\<in>F. gcd f (h - [:c:])) dvd f;\n        \\<forall>c1 c2.\n           c1 \\<in> insert x F \\<and>\n           c2 \\<in> insert x F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime (h - [:c1:]) (h - [:c2:])\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>c\\<in>insert x F. gcd f (h - [:c:])) dvd f", "have \"(\\<Prod>c\\<in>insert x A. gcd f (h - [:c:])) =  (gcd f (h - [:x:])) * (\\<Prod>c\\<in> A. gcd f (h - [:c:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>c\\<in>insert x A. gcd f (h - [:c:])) =\n    gcd f (h - [:x:]) * (\\<Prod>c\\<in>A. gcd f (h - [:c:]))", "by (simp add: insert.hyps(2))"], ["proof (state)\nthis:\n  (\\<Prod>c\\<in>insert x A. gcd f (h - [:c:])) =\n  gcd f (h - [:x:]) * (\\<Prod>c\\<in>A. gcd f (h - [:c:]))\n\ngoal (2 subgoals):\n 1. \\<forall>c1 c2.\n       c1 \\<in> {} \\<and>\n       c2 \\<in> {} \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime (h - [:c1:])\n        (h - [:c2:]) \\<Longrightarrow>\n    (\\<Prod>c\\<in>{}. gcd f (h - [:c:])) dvd f\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<forall>c1 c2.\n           c1 \\<in> F \\<and>\n           c2 \\<in> F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime (h - [:c1:])\n            (h - [:c2:]) \\<Longrightarrow>\n        (\\<Prod>c\\<in>F. gcd f (h - [:c:])) dvd f;\n        \\<forall>c1 c2.\n           c1 \\<in> insert x F \\<and>\n           c2 \\<in> insert x F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime (h - [:c1:]) (h - [:c2:])\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>c\\<in>insert x F. gcd f (h - [:c:])) dvd f", "also"], ["proof (state)\nthis:\n  (\\<Prod>c\\<in>insert x A. gcd f (h - [:c:])) =\n  gcd f (h - [:x:]) * (\\<Prod>c\\<in>A. gcd f (h - [:c:]))\n\ngoal (2 subgoals):\n 1. \\<forall>c1 c2.\n       c1 \\<in> {} \\<and>\n       c2 \\<in> {} \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime (h - [:c1:])\n        (h - [:c2:]) \\<Longrightarrow>\n    (\\<Prod>c\\<in>{}. gcd f (h - [:c:])) dvd f\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<forall>c1 c2.\n           c1 \\<in> F \\<and>\n           c2 \\<in> F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime (h - [:c1:])\n            (h - [:c2:]) \\<Longrightarrow>\n        (\\<Prod>c\\<in>F. gcd f (h - [:c:])) dvd f;\n        \\<forall>c1 c2.\n           c1 \\<in> insert x F \\<and>\n           c2 \\<in> insert x F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime (h - [:c1:]) (h - [:c2:])\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>c\\<in>insert x F. gcd f (h - [:c:])) dvd f", "have \"... dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f (h - [:x:]) * (\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f", "proof (rule divides_mult)"], ["proof (state)\ngoal (3 subgoals):\n 1. gcd f (h - [:x:]) dvd f\n 2. (\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f\n 3. algebraic_semidom_class.coprime (gcd f (h - [:x:]))\n     (\\<Prod>c\\<in>A. gcd f (h - [:c:]))", "show \"gcd f (h - [:x:]) dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f (h - [:x:]) dvd f", "by simp"], ["proof (state)\nthis:\n  gcd f (h - [:x:]) dvd f\n\ngoal (2 subgoals):\n 1. (\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f\n 2. algebraic_semidom_class.coprime (gcd f (h - [:x:]))\n     (\\<Prod>c\\<in>A. gcd f (h - [:c:]))", "show \"(\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f", "using insert.hyps(3) insert.prems"], ["proof (prove)\nusing this:\n  \\<forall>c1 c2.\n     c1 \\<in> A \\<and> c2 \\<in> A \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime (h - [:c1:])\n      (h - [:c2:]) \\<Longrightarrow>\n  (\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f\n  \\<forall>c1 c2.\n     c1 \\<in> insert x A \\<and>\n     c2 \\<in> insert x A \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime (h - [:c1:]) (h - [:c2:])\n\ngoal (1 subgoal):\n 1. (\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime (gcd f (h - [:x:]))\n     (\\<Prod>c\\<in>A. gcd f (h - [:c:]))", "show \"Rings.coprime (gcd f (h - [:x:])) (\\<Prod>c\\<in>A. gcd f (h - [:c:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime (gcd f (h - [:x:]))\n     (\\<Prod>c\\<in>A. gcd f (h - [:c:]))", "by (rule prod_coprime_right)\n          (metis Berlekamp_Type_Based.coprime_h_c_poly coprime_gcd coprime_iff_coprime insert.hyps(2))"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime (gcd f (h - [:x:]))\n   (\\<Prod>c\\<in>A. gcd f (h - [:c:]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcd f (h - [:x:]) * (\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f\n\ngoal (2 subgoals):\n 1. \\<forall>c1 c2.\n       c1 \\<in> {} \\<and>\n       c2 \\<in> {} \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime (h - [:c1:])\n        (h - [:c2:]) \\<Longrightarrow>\n    (\\<Prod>c\\<in>{}. gcd f (h - [:c:])) dvd f\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<forall>c1 c2.\n           c1 \\<in> F \\<and>\n           c2 \\<in> F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime (h - [:c1:])\n            (h - [:c2:]) \\<Longrightarrow>\n        (\\<Prod>c\\<in>F. gcd f (h - [:c:])) dvd f;\n        \\<forall>c1 c2.\n           c1 \\<in> insert x F \\<and>\n           c2 \\<in> insert x F \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime (h - [:c1:]) (h - [:c2:])\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>c\\<in>insert x F. gcd f (h - [:c:])) dvd f", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>c\\<in>insert x A. gcd f (h - [:c:])) dvd f", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Prod>c\\<in>insert x A. gcd f (h - [:c:])) dvd f\n\ngoal (1 subgoal):\n 1. (\\<Prod>c\\<in>insert x A. gcd f (h - [:c:])) dvd f", "."], ["proof (state)\nthis:\n  (\\<Prod>c\\<in>insert x A. gcd f (h - [:c:])) dvd f\n\ngoal (1 subgoal):\n 1. \\<forall>c1 c2.\n       c1 \\<in> {} \\<and>\n       c2 \\<in> {} \\<and> c1 \\<noteq> c2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime (h - [:c1:])\n        (h - [:c2:]) \\<Longrightarrow>\n    (\\<Prod>c\\<in>{}. gcd f (h - [:c:])) dvd f", "qed auto"], ["proof (state)\nthis:\n  (\\<Prod>c\\<in>A. gcd f (h - [:c:])) dvd f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monic_prod_gcd:\nassumes f: \"finite A\" and f0: \"(f :: 'b :: {field_gcd} poly) \\<noteq> 0\"\nshows \"monic (\\<Prod>c\\<in>A. gcd f (h - [:c:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>c\\<in>A. gcd f (h - [:c:]))", "using f"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. monic (\\<Prod>c\\<in>A. gcd f (h - [:c:]))", "proof (induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. monic (\\<Prod>c\\<in>{}. gcd f (h - [:c:]))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        monic (\\<Prod>c\\<in>F. gcd f (h - [:c:]))\\<rbrakk>\n       \\<Longrightarrow> monic (\\<Prod>c\\<in>insert x F. gcd f (h - [:c:]))", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  monic (\\<Prod>c\\<in>A. gcd f (h - [:c:]))\n\ngoal (2 subgoals):\n 1. monic (\\<Prod>c\\<in>{}. gcd f (h - [:c:]))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        monic (\\<Prod>c\\<in>F. gcd f (h - [:c:]))\\<rbrakk>\n       \\<Longrightarrow> monic (\\<Prod>c\\<in>insert x F. gcd f (h - [:c:]))", "have rw: \"(\\<Prod>c\\<in>insert x A. gcd f (h - [:c:]))\n    = (gcd f (h - [:x:])) * (\\<Prod>c\\<in> A. gcd f (h - [:c:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>c\\<in>insert x A. gcd f (h - [:c:])) =\n    gcd f (h - [:x:]) * (\\<Prod>c\\<in>A. gcd f (h - [:c:]))", "by (simp add: insert.hyps)"], ["proof (state)\nthis:\n  (\\<Prod>c\\<in>insert x A. gcd f (h - [:c:])) =\n  gcd f (h - [:x:]) * (\\<Prod>c\\<in>A. gcd f (h - [:c:]))\n\ngoal (2 subgoals):\n 1. monic (\\<Prod>c\\<in>{}. gcd f (h - [:c:]))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        monic (\\<Prod>c\\<in>F. gcd f (h - [:c:]))\\<rbrakk>\n       \\<Longrightarrow> monic (\\<Prod>c\\<in>insert x F. gcd f (h - [:c:]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>c\\<in>insert x A. gcd f (h - [:c:]))", "proof (unfold rw, rule monic_mult)"], ["proof (state)\ngoal (2 subgoals):\n 1. monic (gcd f (h - [:x:]))\n 2. monic (\\<Prod>c\\<in>A. gcd f (h - [:c:]))", "show \"monic (gcd f (h - [:x:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (gcd f (h - [:x:]))", "using poly_gcd_monic[of f] f0"], ["proof (prove)\nusing this:\n  f \\<noteq> 0 \\<or> ?q \\<noteq> 0 \\<Longrightarrow> monic (gcd f ?q)\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monic (gcd f (h - [:x:]))", "using insert.prems insert_iff"], ["proof (prove)\nusing this:\n  f \\<noteq> 0 \\<or> ?q \\<noteq> 0 \\<Longrightarrow> monic (gcd f ?q)\n  f \\<noteq> 0\n  (?a \\<in> insert ?b ?A) = (?a = ?b \\<or> ?a \\<in> ?A)\n\ngoal (1 subgoal):\n 1. monic (gcd f (h - [:x:]))", "by blast"], ["proof (state)\nthis:\n  monic (gcd f (h - [:x:]))\n\ngoal (1 subgoal):\n 1. monic (\\<Prod>c\\<in>A. gcd f (h - [:c:]))", "show \"monic (\\<Prod>c\\<in>A. gcd f (h - [:c:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>c\\<in>A. gcd f (h - [:c:]))", "using insert.hyps(3) insert.prems"], ["proof (prove)\nusing this:\n  monic (\\<Prod>c\\<in>A. gcd f (h - [:c:]))\n\ngoal (1 subgoal):\n 1. monic (\\<Prod>c\\<in>A. gcd f (h - [:c:]))", "by blast"], ["proof (state)\nthis:\n  monic (\\<Prod>c\\<in>A. gcd f (h - [:c:]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monic (\\<Prod>c\\<in>insert x A. gcd f (h - [:c:]))\n\ngoal (1 subgoal):\n 1. monic (\\<Prod>c\\<in>{}. gcd f (h - [:c:]))", "qed auto"], ["", "lemma coprime_not_unit_not_dvd:\nfixes a::\"'b::semiring_gcd\"\nassumes \"a dvd b\"\nand \"coprime b c\"\nand \"\\<not> is_unit a\"\nshows \"\\<not> a dvd c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> a dvd c", "using assms coprime_divisors coprime_id_is_unit"], ["proof (prove)\nusing this:\n  a dvd b\n  comm_monoid_mult_class.coprime b c\n  \\<not> is_unit a\n  \\<lbrakk>?a dvd ?c; ?b dvd ?d;\n   algebraic_semidom_class.coprime ?c ?d\\<rbrakk>\n  \\<Longrightarrow> algebraic_semidom_class.coprime ?a ?b\n  comm_monoid_mult_class.coprime ?a ?a = is_unit ?a\n\ngoal (1 subgoal):\n 1. \\<not> a dvd c", "by fastforce"], ["", "lemma divides_prod2:\n  fixes A::\"'b::semiring_gcd set\"\n  assumes f: \"finite A\"\n  and \"\\<forall>a\\<in>A. a dvd c\"\n  and \"\\<forall>a1 a2. a1 \\<in> A \\<and> a2 \\<in> A \\<and> a1 \\<noteq> a2 \\<longrightarrow> coprime a1 a2\"\n  shows \"\\<Prod>A dvd c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>A dvd c", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  \\<forall>a\\<in>A. a dvd c\n  \\<forall>a1 a2.\n     a1 \\<in> A \\<and> a2 \\<in> A \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime a1 a2\n\ngoal (1 subgoal):\n 1. \\<Prod>A dvd c", "proof (induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a\\<in>{}. a dvd c;\n     \\<forall>a1 a2.\n        a1 \\<in> {} \\<and>\n        a2 \\<in> {} \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n        comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n    \\<Longrightarrow> \\<Prod>{} dvd c\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>a\\<in>F. a dvd c;\n         \\<forall>a1 a2.\n            a1 \\<in> F \\<and>\n            a2 \\<in> F \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n            comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n        \\<Longrightarrow> \\<Prod>F dvd c;\n        \\<forall>a\\<in>insert x F. a dvd c;\n        \\<forall>a1 a2.\n           a1 \\<in> insert x F \\<and>\n           a2 \\<in> insert x F \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n       \\<Longrightarrow> \\<Prod>(insert x F) dvd c", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>\\<forall>a\\<in>A. a dvd c;\n   \\<forall>a1 a2.\n      a1 \\<in> A \\<and> a2 \\<in> A \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n      comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n  \\<Longrightarrow> \\<Prod>A dvd c\n  \\<forall>a\\<in>insert x A. a dvd c\n  \\<forall>a1 a2.\n     a1 \\<in> insert x A \\<and>\n     a2 \\<in> insert x A \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime a1 a2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a\\<in>{}. a dvd c;\n     \\<forall>a1 a2.\n        a1 \\<in> {} \\<and>\n        a2 \\<in> {} \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n        comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n    \\<Longrightarrow> \\<Prod>{} dvd c\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>a\\<in>F. a dvd c;\n         \\<forall>a1 a2.\n            a1 \\<in> F \\<and>\n            a2 \\<in> F \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n            comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n        \\<Longrightarrow> \\<Prod>F dvd c;\n        \\<forall>a\\<in>insert x F. a dvd c;\n        \\<forall>a1 a2.\n           a1 \\<in> insert x F \\<and>\n           a2 \\<in> insert x F \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n       \\<Longrightarrow> \\<Prod>(insert x F) dvd c", "have \"\\<Prod>(insert x A) = x * \\<Prod>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>(insert x A) = x * \\<Prod>A", "by (simp add: insert.hyps(1) insert.hyps(2))"], ["proof (state)\nthis:\n  \\<Prod>(insert x A) = x * \\<Prod>A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a\\<in>{}. a dvd c;\n     \\<forall>a1 a2.\n        a1 \\<in> {} \\<and>\n        a2 \\<in> {} \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n        comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n    \\<Longrightarrow> \\<Prod>{} dvd c\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>a\\<in>F. a dvd c;\n         \\<forall>a1 a2.\n            a1 \\<in> F \\<and>\n            a2 \\<in> F \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n            comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n        \\<Longrightarrow> \\<Prod>F dvd c;\n        \\<forall>a\\<in>insert x F. a dvd c;\n        \\<forall>a1 a2.\n           a1 \\<in> insert x F \\<and>\n           a2 \\<in> insert x F \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n       \\<Longrightarrow> \\<Prod>(insert x F) dvd c", "also"], ["proof (state)\nthis:\n  \\<Prod>(insert x A) = x * \\<Prod>A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a\\<in>{}. a dvd c;\n     \\<forall>a1 a2.\n        a1 \\<in> {} \\<and>\n        a2 \\<in> {} \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n        comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n    \\<Longrightarrow> \\<Prod>{} dvd c\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>a\\<in>F. a dvd c;\n         \\<forall>a1 a2.\n            a1 \\<in> F \\<and>\n            a2 \\<in> F \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n            comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n        \\<Longrightarrow> \\<Prod>F dvd c;\n        \\<forall>a\\<in>insert x F. a dvd c;\n        \\<forall>a1 a2.\n           a1 \\<in> insert x F \\<and>\n           a2 \\<in> insert x F \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n       \\<Longrightarrow> \\<Prod>(insert x F) dvd c", "have \"... dvd c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<Prod>A dvd c", "proof (rule divides_mult)"], ["proof (state)\ngoal (3 subgoals):\n 1. x dvd c\n 2. \\<Prod>A dvd c\n 3. algebraic_semidom_class.coprime x (\\<Prod>A)", "show \"x dvd c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x dvd c", "by (simp add: insert.prems)"], ["proof (state)\nthis:\n  x dvd c\n\ngoal (2 subgoals):\n 1. \\<Prod>A dvd c\n 2. algebraic_semidom_class.coprime x (\\<Prod>A)", "show \"\\<Prod>A dvd c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>A dvd c", "using insert"], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>\\<forall>a\\<in>A. a dvd c;\n   \\<forall>a1 a2.\n      a1 \\<in> A \\<and> a2 \\<in> A \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n      comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n  \\<Longrightarrow> \\<Prod>A dvd c\n  \\<forall>a\\<in>insert x A. a dvd c\n  \\<forall>a1 a2.\n     a1 \\<in> insert x A \\<and>\n     a2 \\<in> insert x A \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime a1 a2\n\ngoal (1 subgoal):\n 1. \\<Prod>A dvd c", "by auto"], ["proof (state)\nthis:\n  \\<Prod>A dvd c\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime x (\\<Prod>A)", "from insert"], ["proof (chain)\npicking this:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>\\<forall>a\\<in>A. a dvd c;\n   \\<forall>a1 a2.\n      a1 \\<in> A \\<and> a2 \\<in> A \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n      comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n  \\<Longrightarrow> \\<Prod>A dvd c\n  \\<forall>a\\<in>insert x A. a dvd c\n  \\<forall>a1 a2.\n     a1 \\<in> insert x A \\<and>\n     a2 \\<in> insert x A \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime a1 a2", "show \"Rings.coprime x (\\<Prod>A)\""], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>\\<forall>a\\<in>A. a dvd c;\n   \\<forall>a1 a2.\n      a1 \\<in> A \\<and> a2 \\<in> A \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n      comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n  \\<Longrightarrow> \\<Prod>A dvd c\n  \\<forall>a\\<in>insert x A. a dvd c\n  \\<forall>a1 a2.\n     a1 \\<in> insert x A \\<and>\n     a2 \\<in> insert x A \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime a1 a2\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime x (\\<Prod>A)", "by (auto intro: prod_coprime_right)"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime x (\\<Prod>A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x * \\<Prod>A dvd c\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a\\<in>{}. a dvd c;\n     \\<forall>a1 a2.\n        a1 \\<in> {} \\<and>\n        a2 \\<in> {} \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n        comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n    \\<Longrightarrow> \\<Prod>{} dvd c\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>a\\<in>F. a dvd c;\n         \\<forall>a1 a2.\n            a1 \\<in> F \\<and>\n            a2 \\<in> F \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n            comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n        \\<Longrightarrow> \\<Prod>F dvd c;\n        \\<forall>a\\<in>insert x F. a dvd c;\n        \\<forall>a1 a2.\n           a1 \\<in> insert x F \\<and>\n           a2 \\<in> insert x F \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n       \\<Longrightarrow> \\<Prod>(insert x F) dvd c", "finally"], ["proof (chain)\npicking this:\n  \\<Prod>(insert x A) dvd c", "show ?case"], ["proof (prove)\nusing this:\n  \\<Prod>(insert x A) dvd c\n\ngoal (1 subgoal):\n 1. \\<Prod>(insert x A) dvd c", "."], ["proof (state)\nthis:\n  \\<Prod>(insert x A) dvd c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>{}. a dvd c;\n     \\<forall>a1 a2.\n        a1 \\<in> {} \\<and>\n        a2 \\<in> {} \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n        comm_monoid_mult_class.coprime a1 a2\\<rbrakk>\n    \\<Longrightarrow> \\<Prod>{} dvd c", "qed auto"], ["", "lemma coprime_polynomial_factorization:\n  fixes a1 :: \"'b :: {field_gcd} poly\"\n  assumes  irr: \"as \\<subseteq> {q. irreducible q \\<and> monic q}\"\n  and \"finite as\" and a1: \"a1 \\<in> as\" and a2: \"a2 \\<in> as\" and a1_not_a2: \"a1 \\<noteq> a2\"\n  shows \"coprime a1 a2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime a1 a2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime a1 a2 \\<Longrightarrow> False", "assume not_coprime: \"\\<not> coprime a1 a2\""], ["proof (state)\nthis:\n  \\<not> comm_monoid_mult_class.coprime a1 a2\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime a1 a2 \\<Longrightarrow> False", "let ?b= \"gcd a1 a2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime a1 a2 \\<Longrightarrow> False", "have b_dvd_a1: \"?b dvd a1\" and b_dvd_a2: \"?b dvd a2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd a1 a2 dvd a1 &&& gcd a1 a2 dvd a2", "by simp+"], ["proof (state)\nthis:\n  gcd a1 a2 dvd a1\n  gcd a1 a2 dvd a2\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime a1 a2 \\<Longrightarrow> False", "have irr_a1: \"irreducible a1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible a1", "using a1 irr"], ["proof (prove)\nusing this:\n  a1 \\<in> as\n  as \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible a1", "by blast"], ["proof (state)\nthis:\n  irreducible a1\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime a1 a2 \\<Longrightarrow> False", "have irr_a2: \"irreducible a2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible a2", "using a2 irr"], ["proof (prove)\nusing this:\n  a2 \\<in> as\n  as \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible a2", "by blast"], ["proof (state)\nthis:\n  irreducible a2\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime a1 a2 \\<Longrightarrow> False", "have a2_not0: \"a2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a2 \\<noteq> 0", "using a2 irr"], ["proof (prove)\nusing this:\n  a2 \\<in> as\n  as \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. a2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime a1 a2 \\<Longrightarrow> False", "have degree_a1: \"degree a1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree a1 \\<noteq> 0", "using irr_a1"], ["proof (prove)\nusing this:\n  irreducible a1\n\ngoal (1 subgoal):\n 1. degree a1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree a1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime a1 a2 \\<Longrightarrow> False", "have degree_a2: \"degree a2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree a2 \\<noteq> 0", "using irr_a2"], ["proof (prove)\nusing this:\n  irreducible a2\n\ngoal (1 subgoal):\n 1. degree a2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree a2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime a1 a2 \\<Longrightarrow> False", "have not_a2_dvd_a1: \"\\<not> a2 dvd a1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> a2 dvd a1", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. a2 dvd a1 \\<Longrightarrow> False", "assume a2_dvd_a1: \"a2 dvd a1\""], ["proof (state)\nthis:\n  a2 dvd a1\n\ngoal (1 subgoal):\n 1. a2 dvd a1 \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  a2 dvd a1", "obtain k where k: \"a1 = a2 * k\""], ["proof (prove)\nusing this:\n  a2 dvd a1\n\ngoal (1 subgoal):\n 1. (\\<And>k. a1 = a2 * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. a1 = a2 * k\n\ngoal (1 subgoal):\n 1. (\\<And>k. a1 = a2 * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  a1 = a2 * k\n\ngoal (1 subgoal):\n 1. a2 dvd a1 \\<Longrightarrow> False", "have k_not0: \"k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "using degree_a1 k"], ["proof (prove)\nusing this:\n  degree a1 \\<noteq> 0\n  a1 = a2 * k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a2 dvd a1 \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"degree a2 = degree a1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree a2 = degree a1 \\<Longrightarrow> False\n 2. degree a2 \\<noteq> degree a1 \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  degree a2 \\<noteq> degree a1\n\ngoal (2 subgoals):\n 1. degree a2 = degree a1 \\<Longrightarrow> False\n 2. degree a2 \\<noteq> degree a1 \\<Longrightarrow> False", "have \"degree a2 < degree a1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree a2 < degree a1", "using False a2_dvd_a1 degree_a1 divides_degree"], ["proof (prove)\nusing this:\n  degree a2 \\<noteq> degree a1\n  a2 dvd a1\n  degree a1 \\<noteq> 0\n  ?p dvd ?q \\<Longrightarrow> degree ?p \\<le> degree ?q \\<or> ?q = 0\n\ngoal (1 subgoal):\n 1. degree a2 < degree a1", "by fastforce"], ["proof (state)\nthis:\n  degree a2 < degree a1\n\ngoal (2 subgoals):\n 1. degree a2 = degree a1 \\<Longrightarrow> False\n 2. degree a2 \\<noteq> degree a1 \\<Longrightarrow> False", "hence \"\\<not> irreducible a1\""], ["proof (prove)\nusing this:\n  degree a2 < degree a1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible a1", "using degree_a2 a2_dvd_a1 degree_a2"], ["proof (prove)\nusing this:\n  degree a2 < degree a1\n  degree a2 \\<noteq> 0\n  a2 dvd a1\n  degree a2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> irreducible a1", "by (metis degree_a1 irreducible\\<^sub>dD(2) irreducible\\<^sub>d_multD irreducible_connect_field k neq0_conv)"], ["proof (state)\nthis:\n  \\<not> irreducible a1\n\ngoal (2 subgoals):\n 1. degree a2 = degree a1 \\<Longrightarrow> False\n 2. degree a2 \\<noteq> degree a1 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<not> irreducible a1\n\ngoal (1 subgoal):\n 1. False", "using irr_a1"], ["proof (prove)\nusing this:\n  \\<not> irreducible a1\n  irreducible a1\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. degree a2 = degree a1 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree a2 = degree a1 \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  degree a2 = degree a1\n\ngoal (1 subgoal):\n 1. degree a2 = degree a1 \\<Longrightarrow> False", "have \"degree a1 = degree a2 + degree k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree a1 = degree a2 + degree k", "unfolding k"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (a2 * k) = degree a2 + degree k", "using degree_mult_eq[OF a2_not0 k_not0]"], ["proof (prove)\nusing this:\n  degree (a2 * k) = degree a2 + degree k\n\ngoal (1 subgoal):\n 1. degree (a2 * k) = degree a2 + degree k", "by simp"], ["proof (state)\nthis:\n  degree a1 = degree a2 + degree k\n\ngoal (1 subgoal):\n 1. degree a2 = degree a1 \\<Longrightarrow> False", "hence \"degree k = 0\""], ["proof (prove)\nusing this:\n  degree a1 = degree a2 + degree k\n\ngoal (1 subgoal):\n 1. degree k = 0", "using True"], ["proof (prove)\nusing this:\n  degree a1 = degree a2 + degree k\n  degree a2 = degree a1\n\ngoal (1 subgoal):\n 1. degree k = 0", "by simp"], ["proof (state)\nthis:\n  degree k = 0\n\ngoal (1 subgoal):\n 1. degree a2 = degree a1 \\<Longrightarrow> False", "hence \"k = 1\""], ["proof (prove)\nusing this:\n  degree k = 0\n\ngoal (1 subgoal):\n 1. k = 1", "using monic_factor a1 a2 irr k monic_degree_0"], ["proof (prove)\nusing this:\n  degree k = 0\n  \\<lbrakk>monic (?p * ?q); monic ?p\\<rbrakk> \\<Longrightarrow> monic ?q\n  a1 \\<in> as\n  a2 \\<in> as\n  as \\<subseteq> {q. irreducible q \\<and> monic q}\n  a1 = a2 * k\n  monic ?p \\<Longrightarrow> (degree ?p = 0) = (?p = 1)\n\ngoal (1 subgoal):\n 1. k = 1", "by auto"], ["proof (state)\nthis:\n  k = 1\n\ngoal (1 subgoal):\n 1. degree a2 = degree a1 \\<Longrightarrow> False", "hence \"a1 = a2\""], ["proof (prove)\nusing this:\n  k = 1\n\ngoal (1 subgoal):\n 1. a1 = a2", "using k"], ["proof (prove)\nusing this:\n  k = 1\n  a1 = a2 * k\n\ngoal (1 subgoal):\n 1. a1 = a2", "by simp"], ["proof (state)\nthis:\n  a1 = a2\n\ngoal (1 subgoal):\n 1. degree a2 = degree a1 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  a1 = a2\n\ngoal (1 subgoal):\n 1. False", "using a1_not_a2"], ["proof (prove)\nusing this:\n  a1 = a2\n  a1 \\<noteq> a2\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> a2 dvd a1\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime a1 a2 \\<Longrightarrow> False", "have b_not0: \"?b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd a1 a2 \\<noteq> 0", "by (simp add: a2_not0)"], ["proof (state)\nthis:\n  gcd a1 a2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime a1 a2 \\<Longrightarrow> False", "have degree_b: \"degree ?b > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree (gcd a1 a2)", "using not_coprime[simplified] b_not0 is_unit_gcd is_unit_iff_degree"], ["proof (prove)\nusing this:\n  \\<not> algebraic_semidom_class.coprime a1 a2\n  gcd a1 a2 \\<noteq> 0\n  is_unit (gcd ?a ?b) = algebraic_semidom_class.coprime ?a ?b\n  ?p \\<noteq> 0 \\<Longrightarrow> is_unit ?p = (degree ?p = 0)\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd a1 a2)", "by blast"], ["proof (state)\nthis:\n  0 < degree (gcd a1 a2)\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime a1 a2 \\<Longrightarrow> False", "have \"degree ?b < degree a2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (gcd a1 a2) < degree a2", "by (meson b_dvd_a1 b_dvd_a2 irreducibleD' dvd_trans gcd_dvd_1 irr_a2 not_a2_dvd_a1 not_coprime)"], ["proof (state)\nthis:\n  degree (gcd a1 a2) < degree a2\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime a1 a2 \\<Longrightarrow> False", "hence \"\\<not> irreducible\\<^sub>d a2\""], ["proof (prove)\nusing this:\n  degree (gcd a1 a2) < degree a2\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d a2", "using degree_a2 b_dvd_a2 degree_b"], ["proof (prove)\nusing this:\n  degree (gcd a1 a2) < degree a2\n  degree a2 \\<noteq> 0\n  gcd a1 a2 dvd a2\n  0 < degree (gcd a1 a2)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible\\<^sub>d a2", "by (metis degree_smult_eq irreducible\\<^sub>d_dvd_smult less_not_refl3)"], ["proof (state)\nthis:\n  \\<not> irreducible\\<^sub>d a2\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime a1 a2 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<not> irreducible\\<^sub>d a2\n\ngoal (1 subgoal):\n 1. False", "using irr_a2"], ["proof (prove)\nusing this:\n  \\<not> irreducible\\<^sub>d a2\n  irreducible a2\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\n  Proof of equation 14 in the book by Knuth\n*)"], ["", "theorem Berlekamp_gcd_step:\nfixes f::\"'a mod_ring poly\" and h::\"'a mod_ring poly\"\nassumes hq_mod_f: \"[h^(CARD('a)) = h] (mod f)\" and monic_f: \"monic f\" and sf_f: \"square_free f\"\nshows \"f = prod (\\<lambda>c. gcd f (h - [:c:])) (UNIV::'a mod_ring set)\"  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "proof (cases \"f=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow> f = (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    f = (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "case True"], ["proof (state)\nthis:\n  f = 0\n\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow> f = (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    f = (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = 0\n\ngoal (1 subgoal):\n 1. f = (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "using coeff_0 monic_f zero_neq_one"], ["proof (prove)\nusing this:\n  f = 0\n  coeff 0 ?n = (0::?'a)\n  monic f\n  (0::?'a) \\<noteq> (1::?'a)\n\ngoal (1 subgoal):\n 1. f = (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "by auto"], ["proof (state)\nthis:\n  f = (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    f = (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    f = (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "case False"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    f = (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "note f_not_0 = False"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    f = (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "proof (rule poly_dvd_antisym)"], ["proof (state)\ngoal (3 subgoals):\n 1. lead_coeff f = lead_coeff (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n 2. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n 3. (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:])) dvd f", "show \"?rhs dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:])) dvd f", "using coprime_h_c_poly"], ["proof (prove)\nusing this:\n  ?c1.0 \\<noteq> ?c2.0 \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (?h - [:?c1.0:]) (?h - [:?c2.0:])\n\ngoal (1 subgoal):\n 1. (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:])) dvd f", "by (intro divides_prod_gcd, auto)"], ["proof (state)\nthis:\n  (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:])) dvd f\n\ngoal (2 subgoals):\n 1. lead_coeff f = lead_coeff (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n 2. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "have \"monic ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "by (rule monic_prod_gcd[OF _ f_not_0], simp)"], ["proof (state)\nthis:\n  monic (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n\ngoal (2 subgoals):\n 1. lead_coeff f = lead_coeff (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n 2. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "thus \"coeff f (degree f) = coeff ?rhs (degree ?rhs)\""], ["proof (prove)\nusing this:\n  monic (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n\ngoal (1 subgoal):\n 1. lead_coeff f = lead_coeff (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "using monic_f"], ["proof (prove)\nusing this:\n  monic (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n  monic f\n\ngoal (1 subgoal):\n 1. lead_coeff f = lead_coeff (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "by auto"], ["proof (state)\nthis:\n  lead_coeff f = lead_coeff (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n\ngoal (1 subgoal):\n 1. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "show \"f dvd ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "let ?p = \"CARD('a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "obtain P  where finite_P: \"finite P\"\n      and f_desc_square_free: \"f = (\\<Prod>a\\<in>P. a)\"\n      and P: \"P \\<subseteq> {q. irreducible q \\<and> monic q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>finite P; f = \\<Prod>P;\n         P \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using monic_square_free_irreducible_factorization[OF monic_f sf_f]"], ["proof (prove)\nusing this:\n  \\<exists>P.\n     finite P \\<and>\n     f = \\<Prod>P \\<and> P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>finite P; f = \\<Prod>P;\n         P \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite P\n  f = \\<Prod>P\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "have f_dvd_hqh: \"f dvd (h^?p - h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f dvd h ^ CARD('a) - h", "using hq_mod_f"], ["proof (prove)\nusing this:\n  [h ^ CARD('a) = h] (mod f)\n\ngoal (1 subgoal):\n 1. f dvd h ^ CARD('a) - h", "unfolding cong_def"], ["proof (prove)\nusing this:\n  h ^ CARD('a) mod f = h mod f\n\ngoal (1 subgoal):\n 1. f dvd h ^ CARD('a) - h", "using mod_eq_dvd_iff_poly"], ["proof (prove)\nusing this:\n  h ^ CARD('a) mod f = h mod f\n  (?x mod ?n = ?y mod ?n) = (?n dvd ?x - ?y)\n\ngoal (1 subgoal):\n 1. f dvd h ^ CARD('a) - h", "by blast"], ["proof (state)\nthis:\n  f dvd h ^ CARD('a) - h\n\ngoal (1 subgoal):\n 1. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "also"], ["proof (state)\nthis:\n  f dvd h ^ CARD('a) - h\n\ngoal (1 subgoal):\n 1. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "have hq_h_rw: \"... = prod (\\<lambda>c. h - [:c:]) (UNIV::'a mod_ring set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h ^ CARD('a) - h = (\\<Prod>c\\<in>UNIV. h - [:c:])", "by (rule poly_identity_mod_p)"], ["proof (state)\nthis:\n  h ^ CARD('a) - h = (\\<Prod>c\\<in>UNIV. h - [:c:])\n\ngoal (1 subgoal):\n 1. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "finally"], ["proof (chain)\npicking this:\n  f dvd (\\<Prod>c\\<in>UNIV. h - [:c:])", "have f_dvd_hc: \"f dvd prod (\\<lambda>c. h - [:c:]) (UNIV::'a mod_ring set)\""], ["proof (prove)\nusing this:\n  f dvd (\\<Prod>c\\<in>UNIV. h - [:c:])\n\ngoal (1 subgoal):\n 1. f dvd (\\<Prod>c\\<in>UNIV. h - [:c:])", "by simp"], ["proof (state)\nthis:\n  f dvd (\\<Prod>c\\<in>UNIV. h - [:c:])\n\ngoal (1 subgoal):\n 1. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "have \"f = \\<Prod>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = \\<Prod>P", "using f_desc_square_free"], ["proof (prove)\nusing this:\n  f = \\<Prod>P\n\ngoal (1 subgoal):\n 1. f = \\<Prod>P", "by simp"], ["proof (state)\nthis:\n  f = \\<Prod>P\n\ngoal (1 subgoal):\n 1. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "also"], ["proof (state)\nthis:\n  f = \\<Prod>P\n\ngoal (1 subgoal):\n 1. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "have \"... dvd ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>P dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "proof (rule divides_prod2[OF finite_P])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>P. a dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n 2. \\<forall>a1 a2.\n       a1 \\<in> P \\<and> a2 \\<in> P \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime a1 a2", "show \"\\<forall>a1 a2. a1 \\<in> P \\<and> a2 \\<in> P \\<and> a1 \\<noteq> a2 \\<longrightarrow> coprime a1 a2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a1 a2.\n       a1 \\<in> P \\<and> a2 \\<in> P \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime a1 a2", "using coprime_polynomial_factorization[OF P finite_P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a1.0 \\<in> P; ?a2.0 \\<in> P; ?a1.0 \\<noteq> ?a2.0\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?a1.0 ?a2.0\n\ngoal (1 subgoal):\n 1. \\<forall>a1 a2.\n       a1 \\<in> P \\<and> a2 \\<in> P \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime a1 a2", "by simp"], ["proof (state)\nthis:\n  \\<forall>a1 a2.\n     a1 \\<in> P \\<and> a2 \\<in> P \\<and> a1 \\<noteq> a2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime a1 a2\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>P. a dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "show \"\\<forall>a\\<in>P. a dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>P. a dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> P \\<Longrightarrow>\n       a dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "fix fi"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> P \\<Longrightarrow>\n       a dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "assume fi_P: \"fi \\<in> P\""], ["proof (state)\nthis:\n  fi \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> P \\<Longrightarrow>\n       a dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "show \"fi dvd ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fi dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "proof (rule dvd_prod, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. fi dvd f\n 2. \\<exists>b. fi dvd h - [:b:]", "show \"fi dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fi dvd f", "using f_desc_square_free fi_P"], ["proof (prove)\nusing this:\n  f = \\<Prod>P\n  fi \\<in> P\n\ngoal (1 subgoal):\n 1. fi dvd f", "using dvd_prod_eqI finite_P"], ["proof (prove)\nusing this:\n  f = \\<Prod>P\n  fi \\<in> P\n  \\<lbrakk>finite ?A; ?a \\<in> ?A; ?b = ?f ?a\\<rbrakk>\n  \\<Longrightarrow> ?b dvd prod ?f ?A\n  finite P\n\ngoal (1 subgoal):\n 1. fi dvd f", "by blast"], ["proof (state)\nthis:\n  fi dvd f\n\ngoal (1 subgoal):\n 1. \\<exists>b. fi dvd h - [:b:]", "hence \"fi dvd (h^?p - h)\""], ["proof (prove)\nusing this:\n  fi dvd f\n\ngoal (1 subgoal):\n 1. fi dvd h ^ CARD('a) - h", "using dvd_trans f_dvd_hqh"], ["proof (prove)\nusing this:\n  fi dvd f\n  \\<lbrakk>?a dvd ?b; ?b dvd ?c\\<rbrakk> \\<Longrightarrow> ?a dvd ?c\n  f dvd h ^ CARD('a) - h\n\ngoal (1 subgoal):\n 1. fi dvd h ^ CARD('a) - h", "by auto"], ["proof (state)\nthis:\n  fi dvd h ^ CARD('a) - h\n\ngoal (1 subgoal):\n 1. \\<exists>b. fi dvd h - [:b:]", "also"], ["proof (state)\nthis:\n  fi dvd h ^ CARD('a) - h\n\ngoal (1 subgoal):\n 1. \\<exists>b. fi dvd h - [:b:]", "have \"... = prod (\\<lambda>c. h - [:c:]) (UNIV::'a mod_ring set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h ^ CARD('a) - h = (\\<Prod>c\\<in>UNIV. h - [:c:])", "unfolding hq_h_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>c\\<in>UNIV. h - [:c:]) = (\\<Prod>c\\<in>UNIV. h - [:c:])", "by simp"], ["proof (state)\nthis:\n  h ^ CARD('a) - h = (\\<Prod>c\\<in>UNIV. h - [:c:])\n\ngoal (1 subgoal):\n 1. \\<exists>b. fi dvd h - [:b:]", "finally"], ["proof (chain)\npicking this:\n  fi dvd (\\<Prod>c\\<in>UNIV. h - [:c:])", "have fi_dvd_prod_hc: \"fi dvd prod (\\<lambda>c. h - [:c:]) (UNIV::'a mod_ring set)\""], ["proof (prove)\nusing this:\n  fi dvd (\\<Prod>c\\<in>UNIV. h - [:c:])\n\ngoal (1 subgoal):\n 1. fi dvd (\\<Prod>c\\<in>UNIV. h - [:c:])", "."], ["proof (state)\nthis:\n  fi dvd (\\<Prod>c\\<in>UNIV. h - [:c:])\n\ngoal (1 subgoal):\n 1. \\<exists>b. fi dvd h - [:b:]", "have irr_fi: \"irreducible (fi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible fi", "using fi_P P"], ["proof (prove)\nusing this:\n  fi \\<in> P\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible fi", "by blast"], ["proof (state)\nthis:\n  irreducible fi\n\ngoal (1 subgoal):\n 1. \\<exists>b. fi dvd h - [:b:]", "have fi_not_unit: \"\\<not> is_unit fi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_unit fi", "using irr_fi"], ["proof (prove)\nusing this:\n  irreducible fi\n\ngoal (1 subgoal):\n 1. \\<not> is_unit fi", "by (simp add: irreducible\\<^sub>dD(1) poly_dvd_1)"], ["proof (state)\nthis:\n  \\<not> is_unit fi\n\ngoal (1 subgoal):\n 1. \\<exists>b. fi dvd h - [:b:]", "have fi_dvd_hc: \"\\<exists>c\\<in>UNIV::'a mod_ring set. fi dvd (h-[:c:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>UNIV. fi dvd h - [:c:]", "by (rule irreducible_dvd_prod[OF _ fi_dvd_prod_hc], simp add: irr_fi)"], ["proof (state)\nthis:\n  \\<exists>c\\<in>UNIV. fi dvd h - [:c:]\n\ngoal (1 subgoal):\n 1. \\<exists>b. fi dvd h - [:b:]", "thus \"\\<exists>c. fi dvd h - [:c:]\""], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>UNIV. fi dvd h - [:c:]\n\ngoal (1 subgoal):\n 1. \\<exists>c. fi dvd h - [:c:]", "by simp"], ["proof (state)\nthis:\n  \\<exists>c. fi dvd h - [:c:]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fi dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a\\<in>P. a dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Prod>P dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n\ngoal (1 subgoal):\n 1. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "finally"], ["proof (chain)\npicking this:\n  f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "show \"f dvd ?rhs\""], ["proof (prove)\nusing this:\n  f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n\ngoal (1 subgoal):\n 1. f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))", "."], ["proof (state)\nthis:\n  f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f dvd (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = (\\<Prod>c\\<in>UNIV. gcd f (h - [:c:]))\n\ngoal:\nNo subgoals!", "qed"], ["", "(******* Implementation of Berlekamp's algorithm (type-based version) *******)"], ["", "subsection \\<open>Definitions\\<close>"], ["", "definition berlekamp_mat :: \"'a mod_ring poly \\<Rightarrow> 'a mod_ring mat\" where\n  \"berlekamp_mat u = (let n = degree u;\n    mul_p = power_poly_f_mod u [:0,1:] (CARD('a));\n    xks = power_polys mul_p u 1 n\n   in\n    mat_of_rows_list n (map (\\<lambda> cs. let coeffs_cs = (coeffs cs);\n                                        k = n - length (coeffs cs)\n                                   in (coeffs cs) @ replicate k 0) xks))\""], ["", "definition berlekamp_resulting_mat :: \"('a mod_ring) poly \\<Rightarrow> 'a mod_ring mat\" where\n\"berlekamp_resulting_mat u = (let Q = berlekamp_mat u;\n    n = dim_row Q;\n    QI = mat n n (\\<lambda> (i,j). if i = j then Q $$ (i,j) - 1 else Q $$ (i,j))\n    in (gauss_jordan_single (transpose_mat QI)))\""], ["", "definition berlekamp_basis :: \"'a mod_ring poly \\<Rightarrow> 'a mod_ring poly list\" where\n  \"berlekamp_basis u = (map (Poly o list_of_vec) (find_base_vectors (berlekamp_resulting_mat u)))\""], ["", "lemma berlekamp_basis_code[code]: \"berlekamp_basis u =\n  (map (poly_of_list o list_of_vec) (find_base_vectors (berlekamp_resulting_mat u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.berlekamp_basis u =\n    map (poly_of_list \\<circ> list_of_vec)\n     (find_base_vectors (local.berlekamp_resulting_mat u))", "unfolding berlekamp_basis_def poly_of_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (Poly \\<circ> list_of_vec)\n     (find_base_vectors (local.berlekamp_resulting_mat u)) =\n    map (Poly \\<circ> list_of_vec)\n     (find_base_vectors (local.berlekamp_resulting_mat u))", ".."], ["", "primrec berlekamp_factorization_main :: \"nat \\<Rightarrow> 'a mod_ring poly list \\<Rightarrow> 'a mod_ring poly list \\<Rightarrow> nat \\<Rightarrow> 'a mod_ring poly list\" where\n  \"berlekamp_factorization_main i divs (v # vs) n = (if v = 1 then berlekamp_factorization_main i divs vs n else\n    if length divs = n then divs else\n    let facts = [ w . u \\<leftarrow> divs, s \\<leftarrow> [0 ..< CARD('a)], w \\<leftarrow> [gcd u (v - [:of_int s:])], w \\<noteq> 1];\n      (lin,nonlin) = List.partition (\\<lambda> q. degree q = i) facts\n      in lin @ berlekamp_factorization_main i nonlin vs (n - length lin))\"\n  | \"berlekamp_factorization_main i divs [] n = divs\""], ["", "definition berlekamp_monic_factorization :: \"nat \\<Rightarrow> 'a mod_ring poly \\<Rightarrow> 'a mod_ring poly list\" where\n  \"berlekamp_monic_factorization d f = (let\n     vs = berlekamp_basis f;\n     n = length vs;\n     fs = berlekamp_factorization_main d [f] vs n\n    in fs)\""], ["", "subsection \\<open>Properties\\<close>"], ["", "lemma power_polys_works:\nfixes u::\"'b::unique_euclidean_semiring\"\nassumes i: \"i < n\" and c: \"curr_p = curr_p mod u\" (*Equivalent to degree curr_p < degree u*)\nshows \"power_polys mult_p u curr_p n ! i = curr_p * mult_p ^ i mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. power_polys mult_p u curr_p n ! i = curr_p * mult_p ^ i mod u", "using i c"], ["proof (prove)\nusing this:\n  i < n\n  curr_p = curr_p mod u\n\ngoal (1 subgoal):\n 1. power_polys mult_p u curr_p n ! i = curr_p * mult_p ^ i mod u", "proof (induct n arbitrary: curr_p i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>curr_p i.\n       \\<lbrakk>i < 0; curr_p = curr_p mod u\\<rbrakk>\n       \\<Longrightarrow> power_polys mult_p u curr_p 0 ! i =\n                         curr_p * mult_p ^ i mod u\n 2. \\<And>n curr_p i.\n       \\<lbrakk>\\<And>curr_p i.\n                   \\<lbrakk>i < n; curr_p = curr_p mod u\\<rbrakk>\n                   \\<Longrightarrow> power_polys mult_p u curr_p n ! i =\n                                     curr_p * mult_p ^ i mod u;\n        i < Suc n; curr_p = curr_p mod u\\<rbrakk>\n       \\<Longrightarrow> power_polys mult_p u curr_p (Suc n) ! i =\n                         curr_p * mult_p ^ i mod u", "case 0"], ["proof (state)\nthis:\n  i < 0\n  curr_p = curr_p mod u\n\ngoal (2 subgoals):\n 1. \\<And>curr_p i.\n       \\<lbrakk>i < 0; curr_p = curr_p mod u\\<rbrakk>\n       \\<Longrightarrow> power_polys mult_p u curr_p 0 ! i =\n                         curr_p * mult_p ^ i mod u\n 2. \\<And>n curr_p i.\n       \\<lbrakk>\\<And>curr_p i.\n                   \\<lbrakk>i < n; curr_p = curr_p mod u\\<rbrakk>\n                   \\<Longrightarrow> power_polys mult_p u curr_p n ! i =\n                                     curr_p * mult_p ^ i mod u;\n        i < Suc n; curr_p = curr_p mod u\\<rbrakk>\n       \\<Longrightarrow> power_polys mult_p u curr_p (Suc n) ! i =\n                         curr_p * mult_p ^ i mod u", "thus ?case"], ["proof (prove)\nusing this:\n  i < 0\n  curr_p = curr_p mod u\n\ngoal (1 subgoal):\n 1. power_polys mult_p u curr_p 0 ! i = curr_p * mult_p ^ i mod u", "by simp"], ["proof (state)\nthis:\n  power_polys mult_p u curr_p 0 ! i = curr_p * mult_p ^ i mod u\n\ngoal (1 subgoal):\n 1. \\<And>n curr_p i.\n       \\<lbrakk>\\<And>curr_p i.\n                   \\<lbrakk>i < n; curr_p = curr_p mod u\\<rbrakk>\n                   \\<Longrightarrow> power_polys mult_p u curr_p n ! i =\n                                     curr_p * mult_p ^ i mod u;\n        i < Suc n; curr_p = curr_p mod u\\<rbrakk>\n       \\<Longrightarrow> power_polys mult_p u curr_p (Suc n) ! i =\n                         curr_p * mult_p ^ i mod u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n curr_p i.\n       \\<lbrakk>\\<And>curr_p i.\n                   \\<lbrakk>i < n; curr_p = curr_p mod u\\<rbrakk>\n                   \\<Longrightarrow> power_polys mult_p u curr_p n ! i =\n                                     curr_p * mult_p ^ i mod u;\n        i < Suc n; curr_p = curr_p mod u\\<rbrakk>\n       \\<Longrightarrow> power_polys mult_p u curr_p (Suc n) ! i =\n                         curr_p * mult_p ^ i mod u", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < n; ?curr_p = ?curr_p mod u\\<rbrakk>\n  \\<Longrightarrow> power_polys mult_p u ?curr_p n ! ?i =\n                    ?curr_p * mult_p ^ ?i mod u\n  i < Suc n\n  curr_p = curr_p mod u\n\ngoal (1 subgoal):\n 1. \\<And>n curr_p i.\n       \\<lbrakk>\\<And>curr_p i.\n                   \\<lbrakk>i < n; curr_p = curr_p mod u\\<rbrakk>\n                   \\<Longrightarrow> power_polys mult_p u curr_p n ! i =\n                                     curr_p * mult_p ^ i mod u;\n        i < Suc n; curr_p = curr_p mod u\\<rbrakk>\n       \\<Longrightarrow> power_polys mult_p u curr_p (Suc n) ! i =\n                         curr_p * mult_p ^ i mod u", "have p_rw: \"power_polys mult_p u curr_p (Suc n) ! i\n      = (curr_p # power_polys mult_p u (curr_p * mult_p mod u) n) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. power_polys mult_p u curr_p (Suc n) ! i =\n    (curr_p # power_polys mult_p u (curr_p * mult_p mod u) n) ! i", "by simp"], ["proof (state)\nthis:\n  power_polys mult_p u curr_p (Suc n) ! i =\n  (curr_p # power_polys mult_p u (curr_p * mult_p mod u) n) ! i\n\ngoal (1 subgoal):\n 1. \\<And>n curr_p i.\n       \\<lbrakk>\\<And>curr_p i.\n                   \\<lbrakk>i < n; curr_p = curr_p mod u\\<rbrakk>\n                   \\<Longrightarrow> power_polys mult_p u curr_p n ! i =\n                                     curr_p * mult_p ^ i mod u;\n        i < Suc n; curr_p = curr_p mod u\\<rbrakk>\n       \\<Longrightarrow> power_polys mult_p u curr_p (Suc n) ! i =\n                         curr_p * mult_p ^ i mod u", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "proof (cases \"i=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "using Suc.prems"], ["proof (prove)\nusing this:\n  i < Suc n\n  curr_p = curr_p mod u\n\ngoal (1 subgoal):\n 1. power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "unfolding p_rw True"], ["proof (prove)\nusing this:\n  0 < Suc n\n  curr_p = curr_p mod u\n\ngoal (1 subgoal):\n 1. power_polys mult_p u curr_p (Suc n) ! 0 = curr_p * mult_p ^ 0 mod u", "by auto"], ["proof (state)\nthis:\n  power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "note i_not_0 = False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "proof (cases \"i < n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n 2. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "case True"], ["proof (state)\nthis:\n  i < n\n\ngoal (2 subgoals):\n 1. i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n 2. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "note i_less_n = True"], ["proof (state)\nthis:\n  i < n\n\ngoal (2 subgoals):\n 1. i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n 2. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "have \"power_polys mult_p u curr_p (Suc n) ! i = power_polys mult_p u (curr_p * mult_p mod u) n ! (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. power_polys mult_p u curr_p (Suc n) ! i =\n    power_polys mult_p u (curr_p * mult_p mod u) n ! (i - 1)", "unfolding p_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (curr_p # power_polys mult_p u (curr_p * mult_p mod u) n) ! i =\n    power_polys mult_p u (curr_p * mult_p mod u) n ! (i - 1)", "using nth_Cons_pos False"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow> (?x # ?xs) ! ?n = ?xs ! (?n - 1)\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (curr_p # power_polys mult_p u (curr_p * mult_p mod u) n) ! i =\n    power_polys mult_p u (curr_p * mult_p mod u) n ! (i - 1)", "by auto"], ["proof (state)\nthis:\n  power_polys mult_p u curr_p (Suc n) ! i =\n  power_polys mult_p u (curr_p * mult_p mod u) n ! (i - 1)\n\ngoal (2 subgoals):\n 1. i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n 2. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "also"], ["proof (state)\nthis:\n  power_polys mult_p u curr_p (Suc n) ! i =\n  power_polys mult_p u (curr_p * mult_p mod u) n ! (i - 1)\n\ngoal (2 subgoals):\n 1. i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n 2. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "have \"... = (curr_p * mult_p mod u) * mult_p ^ (i-1) mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. power_polys mult_p u (curr_p * mult_p mod u) n ! (i - 1) =\n    curr_p * mult_p mod u * mult_p ^ (i - 1) mod u", "by (rule Suc.hyps) (auto simp add: i_less_n less_imp_diff_less)"], ["proof (state)\nthis:\n  power_polys mult_p u (curr_p * mult_p mod u) n ! (i - 1) =\n  curr_p * mult_p mod u * mult_p ^ (i - 1) mod u\n\ngoal (2 subgoals):\n 1. i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n 2. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "also"], ["proof (state)\nthis:\n  power_polys mult_p u (curr_p * mult_p mod u) n ! (i - 1) =\n  curr_p * mult_p mod u * mult_p ^ (i - 1) mod u\n\ngoal (2 subgoals):\n 1. i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n 2. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "have \"... = curr_p * mult_p ^ i mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. curr_p * mult_p mod u * mult_p ^ (i - 1) mod u =\n    curr_p * mult_p ^ i mod u", "using False"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. curr_p * mult_p mod u * mult_p ^ (i - 1) mod u =\n    curr_p * mult_p ^ i mod u", "by (cases i) (simp_all add: algebra_simps mod_simps)"], ["proof (state)\nthis:\n  curr_p * mult_p mod u * mult_p ^ (i - 1) mod u = curr_p * mult_p ^ i mod u\n\ngoal (2 subgoals):\n 1. i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n 2. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "finally"], ["proof (chain)\npicking this:\n  power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "show ?thesis"], ["proof (prove)\nusing this:\n  power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n\ngoal (1 subgoal):\n 1. power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "."], ["proof (state)\nthis:\n  power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "case False"], ["proof (state)\nthis:\n  \\<not> i < n\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "hence i_n: \"i = n\""], ["proof (prove)\nusing this:\n  \\<not> i < n\n\ngoal (1 subgoal):\n 1. i = n", "using Suc.prems"], ["proof (prove)\nusing this:\n  \\<not> i < n\n  i < Suc n\n  curr_p = curr_p mod u\n\ngoal (1 subgoal):\n 1. i = n", "by auto"], ["proof (state)\nthis:\n  i = n\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "have \"power_polys mult_p u curr_p (Suc n) ! i = power_polys mult_p u (curr_p * mult_p mod u) n ! (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. power_polys mult_p u curr_p (Suc n) ! i =\n    power_polys mult_p u (curr_p * mult_p mod u) n ! (n - 1)", "unfolding p_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (curr_p # power_polys mult_p u (curr_p * mult_p mod u) n) ! i =\n    power_polys mult_p u (curr_p * mult_p mod u) n ! (n - 1)", "using nth_Cons_pos i_n i_not_0"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow> (?x # ?xs) ! ?n = ?xs ! (?n - 1)\n  i = n\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (curr_p # power_polys mult_p u (curr_p * mult_p mod u) n) ! i =\n    power_polys mult_p u (curr_p * mult_p mod u) n ! (n - 1)", "by auto"], ["proof (state)\nthis:\n  power_polys mult_p u curr_p (Suc n) ! i =\n  power_polys mult_p u (curr_p * mult_p mod u) n ! (n - 1)\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "also"], ["proof (state)\nthis:\n  power_polys mult_p u curr_p (Suc n) ! i =\n  power_polys mult_p u (curr_p * mult_p mod u) n ! (n - 1)\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "have \"... = (curr_p * mult_p mod u) * mult_p ^ (n-1) mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. power_polys mult_p u (curr_p * mult_p mod u) n ! (n - 1) =\n    curr_p * mult_p mod u * mult_p ^ (n - 1) mod u", "proof (rule Suc.hyps)"], ["proof (state)\ngoal (2 subgoals):\n 1. n - 1 < n\n 2. curr_p * mult_p mod u = curr_p * mult_p mod u mod u", "show \"n - 1 < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - 1 < n", "using i_n i_not_0"], ["proof (prove)\nusing this:\n  i = n\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n - 1 < n", "by linarith"], ["proof (state)\nthis:\n  n - 1 < n\n\ngoal (1 subgoal):\n 1. curr_p * mult_p mod u = curr_p * mult_p mod u mod u", "show \"curr_p * mult_p mod u = curr_p * mult_p mod u mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. curr_p * mult_p mod u = curr_p * mult_p mod u mod u", "by simp"], ["proof (state)\nthis:\n  curr_p * mult_p mod u = curr_p * mult_p mod u mod u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  power_polys mult_p u (curr_p * mult_p mod u) n ! (n - 1) =\n  curr_p * mult_p mod u * mult_p ^ (n - 1) mod u\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "also"], ["proof (state)\nthis:\n  power_polys mult_p u (curr_p * mult_p mod u) n ! (n - 1) =\n  curr_p * mult_p mod u * mult_p ^ (n - 1) mod u\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "have \"... = curr_p * mult_p ^ i mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. curr_p * mult_p mod u * mult_p ^ (n - 1) mod u =\n    curr_p * mult_p ^ i mod u", "using i_n [symmetric] i_not_0"], ["proof (prove)\nusing this:\n  n = i\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. curr_p * mult_p mod u * mult_p ^ (n - 1) mod u =\n    curr_p * mult_p ^ i mod u", "by (cases i) (simp_all add: algebra_simps mod_simps)"], ["proof (state)\nthis:\n  curr_p * mult_p mod u * mult_p ^ (n - 1) mod u = curr_p * mult_p ^ i mod u\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "finally"], ["proof (chain)\npicking this:\n  power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "show ?thesis"], ["proof (prove)\nusing this:\n  power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n\ngoal (1 subgoal):\n 1. power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u", "."], ["proof (state)\nthis:\n  power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  power_polys mult_p u curr_p (Suc n) ! i = curr_p * mult_p ^ i mod u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_power_polys[simp]: \"length (power_polys mult_p u curr_p n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (power_polys mult_p u curr_p n) = n", "by (induct n arbitrary: curr_p, auto)"], ["", "(*\n  Equation 12\n*)"], ["", "lemma Poly_berlekamp_mat:\nassumes k: \"k < degree u\"\nshows \"Poly (list_of_vec (row (berlekamp_mat u) k)) = [:0,1:]^(CARD('a) * k) mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "let ?map =\"(map (\\<lambda>cs. coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n              (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1 (degree u)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "have \"row (berlekamp_mat u) k = row (mat_of_rows_list (degree u) ?map) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (local.berlekamp_mat u) k =\n    row (mat_of_rows_list (degree u)\n          (map (\\<lambda>cs.\n                   coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n            (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a))))\n              u 1 (degree u))))\n     k", "by (simp add: berlekamp_mat_def Let_def)"], ["proof (state)\nthis:\n  row (local.berlekamp_mat u) k =\n  row (mat_of_rows_list (degree u)\n        (map (\\<lambda>cs.\n                 coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n          (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u\n            1 (degree u))))\n   k\n\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "also"], ["proof (state)\nthis:\n  row (local.berlekamp_mat u) k =\n  row (mat_of_rows_list (degree u)\n        (map (\\<lambda>cs.\n                 coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n          (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u\n            1 (degree u))))\n   k\n\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "have \"... = vec_of_list (?map ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_of_rows_list (degree u)\n          (map (\\<lambda>cs.\n                   coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n            (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a))))\n              u 1 (degree u))))\n     k =\n    vec_of_list\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. row (mat_of_rows_list (degree u)\n          (map (\\<lambda>cs.\n                   coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n            (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a))))\n              u 1 (degree u))))\n     k =\n    vec_of_list\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. row (mat_of_rows_list (degree u)\n          (map (\\<lambda>cs.\n                   coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n            (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a))))\n              u 1 (degree u))))\n     k =\n    vec_of_list\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. row (mat_of_rows_list (degree u)\n          (map (\\<lambda>cs.\n                   coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n            (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a))))\n              u 1 (degree u))))\n     k =\n    vec_of_list\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "assume i: \"i < degree u\""], ["proof (state)\nthis:\n  i < degree u\n\ngoal (1 subgoal):\n 1. row (mat_of_rows_list (degree u)\n          (map (\\<lambda>cs.\n                   coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n            (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a))))\n              u 1 (degree u))))\n     k =\n    vec_of_list\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "let ?c= \"power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i\""], ["proof (state)\ngoal (1 subgoal):\n 1. row (mat_of_rows_list (degree u)\n          (map (\\<lambda>cs.\n                   coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n            (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a))))\n              u 1 (degree u))))\n     k =\n    vec_of_list\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "let ?coeffs_c=\"(coeffs ?c)\""], ["proof (state)\ngoal (1 subgoal):\n 1. row (mat_of_rows_list (degree u)\n          (map (\\<lambda>cs.\n                   coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n            (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a))))\n              u 1 (degree u))))\n     k =\n    vec_of_list\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "have \"?c = 1*([:0, 1:] ^ CARD('a) mod u)^i mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i =\n    1 * ([:0, 1:] ^ CARD('a) mod u) ^ i mod u", "proof (unfold power_poly_f_mod_def, rule power_polys_works[OF i])"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 = 1 mod u", "show \"1 = 1 mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = 1 mod u", "using k mod_poly_less"], ["proof (prove)\nusing this:\n  k < degree u\n  degree ?x < degree ?y \\<Longrightarrow> ?x mod ?y = ?x\n\ngoal (1 subgoal):\n 1. 1 = 1 mod u", "by force"], ["proof (state)\nthis:\n  1 = 1 mod u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i =\n  1 * ([:0, 1:] ^ CARD('a) mod u) ^ i mod u\n\ngoal (1 subgoal):\n 1. row (mat_of_rows_list (degree u)\n          (map (\\<lambda>cs.\n                   coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n            (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a))))\n              u 1 (degree u))))\n     k =\n    vec_of_list\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "also"], ["proof (state)\nthis:\n  power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i =\n  1 * ([:0, 1:] ^ CARD('a) mod u) ^ i mod u\n\ngoal (1 subgoal):\n 1. row (mat_of_rows_list (degree u)\n          (map (\\<lambda>cs.\n                   coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n            (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a))))\n              u 1 (degree u))))\n     k =\n    vec_of_list\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "have \"... = [:0, 1:] ^ (CARD('a) * i) mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * ([:0, 1:] ^ CARD('a) mod u) ^ i mod u =\n    [:0, 1:] ^ (CARD('a) * i) mod u", "by (simp add: power_mod power_mult)"], ["proof (state)\nthis:\n  1 * ([:0, 1:] ^ CARD('a) mod u) ^ i mod u =\n  [:0, 1:] ^ (CARD('a) * i) mod u\n\ngoal (1 subgoal):\n 1. row (mat_of_rows_list (degree u)\n          (map (\\<lambda>cs.\n                   coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n            (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a))))\n              u 1 (degree u))))\n     k =\n    vec_of_list\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "finally"], ["proof (chain)\npicking this:\n  power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i =\n  [:0, 1:] ^ (CARD('a) * i) mod u", "have c_rw: \"?c = [:0, 1:] ^ (CARD('a) * i) mod u\""], ["proof (prove)\nusing this:\n  power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i =\n  [:0, 1:] ^ (CARD('a) * i) mod u\n\ngoal (1 subgoal):\n 1. power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i =\n    [:0, 1:] ^ (CARD('a) * i) mod u", "."], ["proof (state)\nthis:\n  power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i =\n  [:0, 1:] ^ (CARD('a) * i) mod u\n\ngoal (1 subgoal):\n 1. row (mat_of_rows_list (degree u)\n          (map (\\<lambda>cs.\n                   coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n            (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a))))\n              u 1 (degree u))))\n     k =\n    vec_of_list\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "have \"length ?coeffs_c \\<le> degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u", "proof (cases \"?c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i =\n    0 \\<Longrightarrow>\n    length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u\n 2. power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n    i \\<noteq>\n    0 \\<Longrightarrow>\n    length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u", "case True"], ["proof (state)\nthis:\n  power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i = 0\n\ngoal (2 subgoals):\n 1. power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i =\n    0 \\<Longrightarrow>\n    length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u\n 2. power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n    i \\<noteq>\n    0 \\<Longrightarrow>\n    length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u", "thus ?thesis"], ["proof (prove)\nusing this:\n  power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i = 0\n\ngoal (1 subgoal):\n 1. length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u", "by auto"], ["proof (state)\nthis:\n  length\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      i))\n  \\<le> degree u\n\ngoal (1 subgoal):\n 1. power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n    i \\<noteq>\n    0 \\<Longrightarrow>\n    length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n    i \\<noteq>\n    0 \\<Longrightarrow>\n    length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u", "case False"], ["proof (state)\nthis:\n  power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n  i \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n    i \\<noteq>\n    0 \\<Longrightarrow>\n    length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u", "have \"length ?coeffs_c = degree (?c) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i)) =\n    degree\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      i) +\n    1", "by (rule length_coeffs[OF False])"], ["proof (state)\nthis:\n  length\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      i)) =\n  degree\n   (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i) +\n  1\n\ngoal (1 subgoal):\n 1. power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n    i \\<noteq>\n    0 \\<Longrightarrow>\n    length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u", "also"], ["proof (state)\nthis:\n  length\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      i)) =\n  degree\n   (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i) +\n  1\n\ngoal (1 subgoal):\n 1. power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n    i \\<noteq>\n    0 \\<Longrightarrow>\n    length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u", "have \"... = degree ([:0, 1:] ^ (CARD('a) * i) mod u) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      i) +\n    1 =\n    degree ([:0, 1:] ^ (CARD('a) * i) mod u) + 1", "using c_rw"], ["proof (prove)\nusing this:\n  power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i =\n  [:0, 1:] ^ (CARD('a) * i) mod u\n\ngoal (1 subgoal):\n 1. degree\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      i) +\n    1 =\n    degree ([:0, 1:] ^ (CARD('a) * i) mod u) + 1", "by simp"], ["proof (state)\nthis:\n  degree\n   (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i) +\n  1 =\n  degree ([:0, 1:] ^ (CARD('a) * i) mod u) + 1\n\ngoal (1 subgoal):\n 1. power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n    i \\<noteq>\n    0 \\<Longrightarrow>\n    length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u", "also"], ["proof (state)\nthis:\n  degree\n   (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) ! i) +\n  1 =\n  degree ([:0, 1:] ^ (CARD('a) * i) mod u) + 1\n\ngoal (1 subgoal):\n 1. power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n    i \\<noteq>\n    0 \\<Longrightarrow>\n    length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u", "have \"... \\<le> degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ([:0, 1:] ^ (CARD('a) * i) mod u) + 1 \\<le> degree u", "by (metis One_nat_def add.right_neutral add_Suc_right c_rw calculation coeffs_def degree_0\n              degree_mod_less discrete gr_implies_not0 k list.size(3) one_neq_zero)"], ["proof (state)\nthis:\n  degree ([:0, 1:] ^ (CARD('a) * i) mod u) + 1 \\<le> degree u\n\ngoal (1 subgoal):\n 1. power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n    i \\<noteq>\n    0 \\<Longrightarrow>\n    length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u", "finally"], ["proof (chain)\npicking this:\n  length\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      i))\n  \\<le> degree u", "show ?thesis"], ["proof (prove)\nusing this:\n  length\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      i))\n  \\<le> degree u\n\ngoal (1 subgoal):\n 1. length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i))\n    \\<le> degree u", "."], ["proof (state)\nthis:\n  length\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      i))\n  \\<le> degree u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      i))\n  \\<le> degree u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      i))\n  \\<le> degree u\n\ngoal (1 subgoal):\n 1. row (mat_of_rows_list (degree u)\n          (map (\\<lambda>cs.\n                   coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n            (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a))))\n              u 1 (degree u))))\n     k =\n    vec_of_list\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "then"], ["proof (chain)\npicking this:\n  length\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      i))\n  \\<le> degree u", "have \"length ?coeffs_c + (degree u - length ?coeffs_c) = degree u\""], ["proof (prove)\nusing this:\n  length\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      i))\n  \\<le> degree u\n\ngoal (1 subgoal):\n 1. length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n        i)) +\n    (degree u -\n     length\n      (coeffs\n        (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n         i))) =\n    degree u", "by auto"], ["proof (state)\nthis:\n  length\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      i)) +\n  (degree u -\n   length\n    (coeffs\n      (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n       i))) =\n  degree u\n\ngoal (1 subgoal):\n 1. row (mat_of_rows_list (degree u)\n          (map (\\<lambda>cs.\n                   coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n            (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a))))\n              u 1 (degree u))))\n     k =\n    vec_of_list\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "}"], ["proof (state)\nthis:\n  ?i2 < degree u \\<Longrightarrow>\n  length\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      ?i2)) +\n  (degree u -\n   length\n    (coeffs\n      (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n       ?i2))) =\n  degree u\n\ngoal (1 subgoal):\n 1. row (mat_of_rows_list (degree u)\n          (map (\\<lambda>cs.\n                   coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n            (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a))))\n              u 1 (degree u))))\n     k =\n    vec_of_list\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "with k"], ["proof (chain)\npicking this:\n  k < degree u\n  ?i2 < degree u \\<Longrightarrow>\n  length\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      ?i2)) +\n  (degree u -\n   length\n    (coeffs\n      (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n       ?i2))) =\n  degree u", "show ?thesis"], ["proof (prove)\nusing this:\n  k < degree u\n  ?i2 < degree u \\<Longrightarrow>\n  length\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n      ?i2)) +\n  (degree u -\n   length\n    (coeffs\n      (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u) !\n       ?i2))) =\n  degree u\n\ngoal (1 subgoal):\n 1. row (mat_of_rows_list (degree u)\n          (map (\\<lambda>cs.\n                   coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n            (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a))))\n              u 1 (degree u))))\n     k =\n    vec_of_list\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "by (intro row_mat_of_rows_list, auto)"], ["proof (state)\nthis:\n  row (mat_of_rows_list (degree u)\n        (map (\\<lambda>cs.\n                 coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n          (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u\n            1 (degree u))))\n   k =\n  vec_of_list\n   (map (\\<lambda>cs.\n            coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u)) !\n    k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row (mat_of_rows_list (degree u)\n        (map (\\<lambda>cs.\n                 coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n          (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u\n            1 (degree u))))\n   k =\n  vec_of_list\n   (map (\\<lambda>cs.\n            coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u)) !\n    k)\n\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "finally"], ["proof (chain)\npicking this:\n  row (local.berlekamp_mat u) k =\n  vec_of_list\n   (map (\\<lambda>cs.\n            coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u)) !\n    k)", "have row_rw: \"row (berlekamp_mat u) k = vec_of_list (?map ! k)\""], ["proof (prove)\nusing this:\n  row (local.berlekamp_mat u) k =\n  vec_of_list\n   (map (\\<lambda>cs.\n            coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u)) !\n    k)\n\ngoal (1 subgoal):\n 1. row (local.berlekamp_mat u) k =\n    vec_of_list\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "."], ["proof (state)\nthis:\n  row (local.berlekamp_mat u) k =\n  vec_of_list\n   (map (\\<lambda>cs.\n            coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u)) !\n    k)\n\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "have \"Poly (list_of_vec (row (berlekamp_mat u) k)) = Poly (list_of_vec (vec_of_list (?map ! k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n    Poly\n     (list_of_vec\n       (vec_of_list\n         (map (\\<lambda>cs.\n                  coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n           (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u\n             1 (degree u)) !\n          k)))", "unfolding row_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly\n     (list_of_vec\n       (vec_of_list\n         (map (\\<lambda>cs.\n                  coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n           (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u\n             1 (degree u)) !\n          k))) =\n    Poly\n     (list_of_vec\n       (vec_of_list\n         (map (\\<lambda>cs.\n                  coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n           (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u\n             1 (degree u)) !\n          k)))", ".."], ["proof (state)\nthis:\n  Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n  Poly\n   (list_of_vec\n     (vec_of_list\n       (map (\\<lambda>cs.\n                coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n         (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n           (degree u)) !\n        k)))\n\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "also"], ["proof (state)\nthis:\n  Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n  Poly\n   (list_of_vec\n     (vec_of_list\n       (map (\\<lambda>cs.\n                coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n         (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n           (degree u)) !\n        k)))\n\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "have \"... = Poly (?map ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly\n     (list_of_vec\n       (vec_of_list\n         (map (\\<lambda>cs.\n                  coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n           (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u\n             1 (degree u)) !\n          k))) =\n    Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k)", "by simp"], ["proof (state)\nthis:\n  Poly\n   (list_of_vec\n     (vec_of_list\n       (map (\\<lambda>cs.\n                coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n         (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n           (degree u)) !\n        k))) =\n  Poly\n   (map (\\<lambda>cs.\n            coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u)) !\n    k)\n\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "also"], ["proof (state)\nthis:\n  Poly\n   (list_of_vec\n     (vec_of_list\n       (map (\\<lambda>cs.\n                coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n         (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n           (degree u)) !\n        k))) =\n  Poly\n   (map (\\<lambda>cs.\n            coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u)) !\n    k)\n\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "have \"... = [:0,1:]^(CARD('a) * k) mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "let ?cs = \"(power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1 (degree u)) ! k\""], ["proof (state)\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "let ?c = \"coeffs ?cs @ replicate (degree u - length (coeffs ?cs)) 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "have map_k_c: \"?map ! k = ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>cs.\n            coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u)) !\n    k =\n    coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u) !\n      k) @\n    replicate\n     (degree u -\n      length\n       (coeffs\n         (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n           (degree u) !\n          k)))\n     0", "by (rule nth_map, simp add: k)"], ["proof (state)\nthis:\n  map (\\<lambda>cs. coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n   (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n     (degree u)) !\n  k =\n  coeffs\n   (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n     (degree u) !\n    k) @\n  replicate\n   (degree u -\n    length\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u) !\n        k)))\n   0\n\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "have \"(Poly (?map ! k)) = Poly (coeffs ?cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    Poly\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u) !\n        k))", "unfolding map_k_c Poly_append_replicate_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u) !\n        k)) =\n    Poly\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u) !\n        k))", ".."], ["proof (state)\nthis:\n  Poly\n   (map (\\<lambda>cs.\n            coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u)) !\n    k) =\n  Poly\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u) !\n      k))\n\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "also"], ["proof (state)\nthis:\n  Poly\n   (map (\\<lambda>cs.\n            coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u)) !\n    k) =\n  Poly\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u) !\n      k))\n\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "have \"... = ?cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly\n     (coeffs\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u) !\n        k)) =\n    power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n     (degree u) !\n    k", "by simp"], ["proof (state)\nthis:\n  Poly\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u) !\n      k)) =\n  power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n   (degree u) !\n  k\n\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "also"], ["proof (state)\nthis:\n  Poly\n   (coeffs\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u) !\n      k)) =\n  power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n   (degree u) !\n  k\n\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "have \"... = power_polys ([:0, 1:] ^ CARD('a) mod u) u 1 (degree u) ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n     (degree u) !\n    k =\n    power_polys ([:0, 1:] ^ CARD('a) mod u) u 1 (degree u) ! k", "by (simp add: power_poly_f_mod_def)"], ["proof (state)\nthis:\n  power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n   (degree u) !\n  k =\n  power_polys ([:0, 1:] ^ CARD('a) mod u) u 1 (degree u) ! k\n\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "also"], ["proof (state)\nthis:\n  power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n   (degree u) !\n  k =\n  power_polys ([:0, 1:] ^ CARD('a) mod u) u 1 (degree u) ! k\n\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "have \"... = 1* ([:0,1:]^(CARD('a)) mod u) ^ k mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. power_polys ([:0, 1:] ^ CARD('a) mod u) u 1 (degree u) ! k =\n    1 * ([:0, 1:] ^ CARD('a) mod u) ^ k mod u", "proof (rule power_polys_works[OF k])"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 = 1 mod u", "show \"1 = 1 mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = 1 mod u", "using k mod_poly_less"], ["proof (prove)\nusing this:\n  k < degree u\n  degree ?x < degree ?y \\<Longrightarrow> ?x mod ?y = ?x\n\ngoal (1 subgoal):\n 1. 1 = 1 mod u", "by force"], ["proof (state)\nthis:\n  1 = 1 mod u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  power_polys ([:0, 1:] ^ CARD('a) mod u) u 1 (degree u) ! k =\n  1 * ([:0, 1:] ^ CARD('a) mod u) ^ k mod u\n\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "also"], ["proof (state)\nthis:\n  power_polys ([:0, 1:] ^ CARD('a) mod u) u 1 (degree u) ! k =\n  1 * ([:0, 1:] ^ CARD('a) mod u) ^ k mod u\n\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "have \"... = ([:0,1:]^(CARD('a)) mod u) ^ k mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * ([:0, 1:] ^ CARD('a) mod u) ^ k mod u =\n    ([:0, 1:] ^ CARD('a) mod u) ^ k mod u", "by auto"], ["proof (state)\nthis:\n  1 * ([:0, 1:] ^ CARD('a) mod u) ^ k mod u =\n  ([:0, 1:] ^ CARD('a) mod u) ^ k mod u\n\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "also"], ["proof (state)\nthis:\n  1 * ([:0, 1:] ^ CARD('a) mod u) ^ k mod u =\n  ([:0, 1:] ^ CARD('a) mod u) ^ k mod u\n\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "have \"... = [:0,1:]^(CARD('a) * k) mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([:0, 1:] ^ CARD('a) mod u) ^ k mod u = [:0, 1:] ^ (CARD('a) * k) mod u", "by (simp add: power_mod power_mult)"], ["proof (state)\nthis:\n  ([:0, 1:] ^ CARD('a) mod u) ^ k mod u = [:0, 1:] ^ (CARD('a) * k) mod u\n\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "finally"], ["proof (chain)\npicking this:\n  Poly\n   (map (\\<lambda>cs.\n            coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u)) !\n    k) =\n  [:0, 1:] ^ (CARD('a) * k) mod u", "show ?thesis"], ["proof (prove)\nusing this:\n  Poly\n   (map (\\<lambda>cs.\n            coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u)) !\n    k) =\n  [:0, 1:] ^ (CARD('a) * k) mod u\n\ngoal (1 subgoal):\n 1. Poly\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n         (degree u)) !\n      k) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "."], ["proof (state)\nthis:\n  Poly\n   (map (\\<lambda>cs.\n            coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u)) !\n    k) =\n  [:0, 1:] ^ (CARD('a) * k) mod u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Poly\n   (map (\\<lambda>cs.\n            coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n     (power_polys (power_poly_f_mod u [:0, 1:] (nat (int CARD('a)))) u 1\n       (degree u)) !\n    k) =\n  [:0, 1:] ^ (CARD('a) * k) mod u\n\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "finally"], ["proof (chain)\npicking this:\n  Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n  [:0, 1:] ^ (CARD('a) * k) mod u", "show ?thesis"], ["proof (prove)\nusing this:\n  Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n  [:0, 1:] ^ (CARD('a) * k) mod u\n\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "."], ["proof (state)\nthis:\n  Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n  [:0, 1:] ^ (CARD('a) * k) mod u\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary Poly_berlekamp_cong_mat:\nassumes k: \"k < degree u\"\nshows \"[Poly (list_of_vec (row (berlekamp_mat u) k)) = [:0,1:]^(CARD('a) * k)] (mod u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Poly\n      (list_of_vec\n        (row (local.berlekamp_mat u)\n          k)) = [:0, 1:] ^ (CARD('a) * k)] (mod u)", "using Poly_berlekamp_mat[OF k]"], ["proof (prove)\nusing this:\n  Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n  [:0, 1:] ^ (CARD('a) * k) mod u\n\ngoal (1 subgoal):\n 1. [Poly\n      (list_of_vec\n        (row (local.berlekamp_mat u)\n          k)) = [:0, 1:] ^ (CARD('a) * k)] (mod u)", "unfolding cong_def"], ["proof (prove)\nusing this:\n  Poly (list_of_vec (row (local.berlekamp_mat u) k)) =\n  [:0, 1:] ^ (CARD('a) * k) mod u\n\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) k)) mod u =\n    [:0, 1:] ^ (CARD('a) * k) mod u", "by auto"], ["", "lemma mat_of_rows_list_dim[simp]:\n  \"mat_of_rows_list n vs \\<in> carrier_mat (length vs) n\"\n  \"dim_row (mat_of_rows_list n vs) = length vs\"\n  \"dim_col (mat_of_rows_list n vs) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows_list n vs \\<in> carrier_mat (length vs) n &&&\n    dim_row (mat_of_rows_list n vs) = length vs &&&\n    dim_col (mat_of_rows_list n vs) = n", "unfolding mat_of_rows_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length vs) n (\\<lambda>(i, y). vs ! i ! y)\n    \\<in> carrier_mat (length vs) n &&&\n    dim_row (mat (length vs) n (\\<lambda>(i, y). vs ! i ! y)) =\n    length vs &&&\n    dim_col (mat (length vs) n (\\<lambda>(i, y). vs ! i ! y)) = n", "by auto"], ["", "lemma berlekamp_mat_closed[simp]:\n  \"berlekamp_mat u \\<in> carrier_mat (degree u) (degree u)\"\n  \"dim_row (berlekamp_mat u) = degree u\"\n  \"dim_col (berlekamp_mat u) = degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.berlekamp_mat u \\<in> carrier_mat (degree u) (degree u) &&&\n    dim_row (local.berlekamp_mat u) = degree u &&&\n    dim_col (local.berlekamp_mat u) = degree u", "unfolding carrier_mat_def berlekamp_mat_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows_list (degree u)\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1 (degree u)))\n    \\<in> {m. dim_row m = degree u \\<and> dim_col m = degree u} &&&\n    dim_row\n     (mat_of_rows_list (degree u)\n       (map (\\<lambda>cs.\n                coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n         (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1\n           (degree u)))) =\n    degree u &&&\n    dim_col\n     (mat_of_rows_list (degree u)\n       (map (\\<lambda>cs.\n                coeffs cs @ replicate (degree u - length (coeffs cs)) 0)\n         (power_polys (power_poly_f_mod u [:0, 1:] CARD('a)) u 1\n           (degree u)))) =\n    degree u", "by auto"], ["", "lemma vec_of_list_coeffs_nth:\nassumes i: \"i \\<in> {..degree h}\" and h_not0: \"h \\<noteq> 0\"\nshows \"vec_of_list (coeffs h) $ i = coeff h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (coeffs h) $ i = coeff h i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_list (coeffs h) $ i = coeff h i", "have \"vec_of_list (map (coeff h) [0..<degree h] @ [coeff h (degree h)]) $ i = coeff h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (map (coeff h) [0..<degree h] @ [lead_coeff h]) $ i =\n    coeff h i", "using i"], ["proof (prove)\nusing this:\n  i \\<in> {..degree h}\n\ngoal (1 subgoal):\n 1. vec_of_list (map (coeff h) [0..<degree h] @ [lead_coeff h]) $ i =\n    coeff h i", "by (transfer', auto simp add: mk_vec_def)\n         (metis (no_types, lifting) Cons_eq_append_conv coeffs_def coeffs_nth degree_0\n         diff_zero length_upt less_eq_nat.simps(1) list.simps(8) list.simps(9) map_append\n         nth_Cons_0 upt_Suc upt_eq_Nil_conv)"], ["proof (state)\nthis:\n  vec_of_list (map (coeff h) [0..<degree h] @ [lead_coeff h]) $ i =\n  coeff h i\n\ngoal (1 subgoal):\n 1. vec_of_list (coeffs h) $ i = coeff h i", "thus \"vec_of_list (coeffs h) $ i = coeff h i\""], ["proof (prove)\nusing this:\n  vec_of_list (map (coeff h) [0..<degree h] @ [lead_coeff h]) $ i =\n  coeff h i\n\ngoal (1 subgoal):\n 1. vec_of_list (coeffs h) $ i = coeff h i", "using i h_not0"], ["proof (prove)\nusing this:\n  vec_of_list (map (coeff h) [0..<degree h] @ [lead_coeff h]) $ i =\n  coeff h i\n  i \\<in> {..degree h}\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vec_of_list (coeffs h) $ i = coeff h i", "unfolding coeffs_def"], ["proof (prove)\nusing this:\n  vec_of_list (map (coeff h) [0..<degree h] @ [lead_coeff h]) $ i =\n  coeff h i\n  i \\<in> {..degree h}\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vec_of_list (if h = 0 then [] else map (coeff h) [0..<Suc (degree h)]) $\n    i =\n    coeff h i", "by simp"], ["proof (state)\nthis:\n  vec_of_list (coeffs h) $ i = coeff h i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_mod_sum:\n  fixes x y z :: \"'b::field poly\"\n  assumes f: \"finite A\"\n  shows \"sum f A mod z = sum (\\<lambda>i. f i mod z) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f A mod z = (\\<Sum>i\\<in>A. f i mod z)", "using f"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. sum f A mod z = (\\<Sum>i\\<in>A. f i mod z)", "by (induct, auto simp add: poly_mod_add_left)"], ["", "lemma prime_not_dvd_fact:\nassumes kn: \"k < n\" and prime_n: \"prime n\"\nshows \"\\<not> n dvd fact k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> n dvd fact k", "using kn"], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. \\<not> n dvd fact k", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow> \\<not> n dvd fact 0\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> \\<not> n dvd fact k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<not> n dvd fact (Suc k)", "case 0"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow> \\<not> n dvd fact 0\n 2. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> \\<not> n dvd fact k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<not> n dvd fact (Suc k)", "thus ?case"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<not> n dvd fact 0", "using prime_n"], ["proof (prove)\nusing this:\n  0 < n\n  prime n\n\ngoal (1 subgoal):\n 1. \\<not> n dvd fact 0", "unfolding prime_nat_iff"], ["proof (prove)\nusing this:\n  0 < n\n  1 < n \\<and> (\\<forall>m. m dvd n \\<longrightarrow> m = 1 \\<or> m = n)\n\ngoal (1 subgoal):\n 1. \\<not> n dvd fact 0", "by auto"], ["proof (state)\nthis:\n  \\<not> n dvd fact 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> \\<not> n dvd fact k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<not> n dvd fact (Suc k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> \\<not> n dvd fact k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<not> n dvd fact (Suc k)", "case (Suc k)"], ["proof (state)\nthis:\n  k < n \\<Longrightarrow> \\<not> n dvd fact k\n  Suc k < n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n \\<Longrightarrow> \\<not> n dvd fact k;\n        Suc k < n\\<rbrakk>\n       \\<Longrightarrow> \\<not> n dvd fact (Suc k)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> n dvd fact (Suc k)", "proof (rule ccontr, unfold not_not)"], ["proof (state)\ngoal (1 subgoal):\n 1. n dvd fact (Suc k) \\<Longrightarrow> False", "assume \"n dvd fact (Suc k)\""], ["proof (state)\nthis:\n  n dvd fact (Suc k)\n\ngoal (1 subgoal):\n 1. n dvd fact (Suc k) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  n dvd fact (Suc k)\n\ngoal (1 subgoal):\n 1. n dvd fact (Suc k) \\<Longrightarrow> False", "have \"... = Suc k * \\<Prod>{1..k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (Suc k) = Suc k * \\<Prod>{1..k}", "unfolding fact_Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (Suc k) * fact k = Suc k * \\<Prod>{1..k}", "unfolding fact_prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (Suc k) * of_nat (\\<Prod>{1..k}) = Suc k * \\<Prod>{1..k}", "by simp"], ["proof (state)\nthis:\n  fact (Suc k) = Suc k * \\<Prod>{1..k}\n\ngoal (1 subgoal):\n 1. n dvd fact (Suc k) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  n dvd Suc k * \\<Prod>{1..k}", "have \"n dvd Suc k * \\<Prod>{1..k}\""], ["proof (prove)\nusing this:\n  n dvd Suc k * \\<Prod>{1..k}\n\ngoal (1 subgoal):\n 1. n dvd Suc k * \\<Prod>{1..k}", "."], ["proof (state)\nthis:\n  n dvd Suc k * \\<Prod>{1..k}\n\ngoal (1 subgoal):\n 1. n dvd fact (Suc k) \\<Longrightarrow> False", "hence \"n dvd Suc k \\<or> n dvd \\<Prod>{1..k}\""], ["proof (prove)\nusing this:\n  n dvd Suc k * \\<Prod>{1..k}\n\ngoal (1 subgoal):\n 1. n dvd Suc k \\<or> n dvd \\<Prod>{1..k}", "using prime_dvd_mult_eq_nat[OF prime_n]"], ["proof (prove)\nusing this:\n  n dvd Suc k * \\<Prod>{1..k}\n  (n dvd ?a * ?b) = (n dvd ?a \\<or> n dvd ?b)\n\ngoal (1 subgoal):\n 1. n dvd Suc k \\<or> n dvd \\<Prod>{1..k}", "by blast"], ["proof (state)\nthis:\n  n dvd Suc k \\<or> n dvd \\<Prod>{1..k}\n\ngoal (1 subgoal):\n 1. n dvd fact (Suc k) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  n dvd Suc k \\<or> n dvd \\<Prod>{1..k}\n\ngoal (1 subgoal):\n 1. n dvd fact (Suc k) \\<Longrightarrow> False", "have  \"\\<not> n dvd Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> n dvd Suc k", "by (simp add: Suc.prems(1) nat_dvd_not_less)"], ["proof (state)\nthis:\n  \\<not> n dvd Suc k\n\ngoal (1 subgoal):\n 1. n dvd fact (Suc k) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> n dvd Suc k\n\ngoal (1 subgoal):\n 1. n dvd fact (Suc k) \\<Longrightarrow> False", "hence \"\\<not> n dvd \\<Prod>{1..k}\""], ["proof (prove)\nusing this:\n  \\<not> n dvd Suc k\n\ngoal (1 subgoal):\n 1. \\<not> n dvd \\<Prod>{1..k}", "using Suc.hyps Suc.prems"], ["proof (prove)\nusing this:\n  \\<not> n dvd Suc k\n  k < n \\<Longrightarrow> \\<not> n dvd fact k\n  Suc k < n\n\ngoal (1 subgoal):\n 1. \\<not> n dvd \\<Prod>{1..k}", "using Suc_lessD fact_prod[of k]"], ["proof (prove)\nusing this:\n  \\<not> n dvd Suc k\n  k < n \\<Longrightarrow> \\<not> n dvd fact k\n  Suc k < n\n  Suc ?m < ?n \\<Longrightarrow> ?m < ?n\n  fact k = of_nat (\\<Prod>{1..k})\n\ngoal (1 subgoal):\n 1. \\<not> n dvd \\<Prod>{1..k}", "by (metis of_nat_id)"], ["proof (state)\nthis:\n  \\<not> n dvd \\<Prod>{1..k}\n\ngoal (1 subgoal):\n 1. n dvd fact (Suc k) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  n dvd Suc k \\<or> n dvd \\<Prod>{1..k}\n  \\<not> n dvd Suc k\n  \\<not> n dvd \\<Prod>{1..k}", "show False"], ["proof (prove)\nusing this:\n  n dvd Suc k \\<or> n dvd \\<Prod>{1..k}\n  \\<not> n dvd Suc k\n  \\<not> n dvd \\<Prod>{1..k}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> n dvd fact (Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvd_choose_prime:\nassumes kn: \"k < n\" and k: \"k \\<noteq> 0\" and n: \"n \\<noteq> 0\" and prime_n: \"prime n\"\nshows \"n dvd (n choose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n dvd n choose k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n dvd n choose k", "have \"n dvd (fact n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n dvd fact n", "by (simp add: fact_num_eq_if n)"], ["proof (state)\nthis:\n  n dvd fact n\n\ngoal (1 subgoal):\n 1. n dvd n choose k", "moreover"], ["proof (state)\nthis:\n  n dvd fact n\n\ngoal (1 subgoal):\n 1. n dvd n choose k", "have \"\\<not> n dvd (fact k * fact (n-k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> n dvd fact k * fact (n - k)", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. n dvd fact k * fact (n - k) \\<Longrightarrow> False", "assume \"n dvd fact k * fact (n - k)\""], ["proof (state)\nthis:\n  n dvd fact k * fact (n - k)\n\ngoal (1 subgoal):\n 1. n dvd fact k * fact (n - k) \\<Longrightarrow> False", "hence \"n dvd fact k \\<or> n dvd fact (n - k)\""], ["proof (prove)\nusing this:\n  n dvd fact k * fact (n - k)\n\ngoal (1 subgoal):\n 1. n dvd fact k \\<or> n dvd fact (n - k)", "using prime_dvd_mult_eq_nat[OF prime_n]"], ["proof (prove)\nusing this:\n  n dvd fact k * fact (n - k)\n  (n dvd ?a * ?b) = (n dvd ?a \\<or> n dvd ?b)\n\ngoal (1 subgoal):\n 1. n dvd fact k \\<or> n dvd fact (n - k)", "by simp"], ["proof (state)\nthis:\n  n dvd fact k \\<or> n dvd fact (n - k)\n\ngoal (1 subgoal):\n 1. n dvd fact k * fact (n - k) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  n dvd fact k \\<or> n dvd fact (n - k)\n\ngoal (1 subgoal):\n 1. n dvd fact k * fact (n - k) \\<Longrightarrow> False", "have \"\\<not> n dvd (fact k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> n dvd fact k", "by (rule prime_not_dvd_fact[OF kn prime_n])"], ["proof (state)\nthis:\n  \\<not> n dvd fact k\n\ngoal (1 subgoal):\n 1. n dvd fact k * fact (n - k) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> n dvd fact k\n\ngoal (1 subgoal):\n 1. n dvd fact k * fact (n - k) \\<Longrightarrow> False", "have \"\\<not> n dvd fact (n - k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> n dvd fact (n - k)", "using  prime_not_dvd_fact[OF _ prime_n] kn k"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> \\<not> n dvd fact ?k\n  k < n\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> n dvd fact (n - k)", "by simp"], ["proof (state)\nthis:\n  \\<not> n dvd fact (n - k)\n\ngoal (1 subgoal):\n 1. n dvd fact k * fact (n - k) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  n dvd fact k \\<or> n dvd fact (n - k)\n  \\<not> n dvd fact k\n  \\<not> n dvd fact (n - k)", "show False"], ["proof (prove)\nusing this:\n  n dvd fact k \\<or> n dvd fact (n - k)\n  \\<not> n dvd fact k\n  \\<not> n dvd fact (n - k)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> n dvd fact k * fact (n - k)\n\ngoal (1 subgoal):\n 1. n dvd n choose k", "moreover"], ["proof (state)\nthis:\n  \\<not> n dvd fact k * fact (n - k)\n\ngoal (1 subgoal):\n 1. n dvd n choose k", "have \"(fact n::nat) = fact k * fact (n-k) * (n choose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact n = fact k * fact (n - k) * (n choose k)", "using binomial_fact_lemma kn"], ["proof (prove)\nusing this:\n  ?k \\<le> ?n \\<Longrightarrow>\n  fact ?k * fact (?n - ?k) * (?n choose ?k) = fact ?n\n  k < n\n\ngoal (1 subgoal):\n 1. fact n = fact k * fact (n - k) * (n choose k)", "by auto"], ["proof (state)\nthis:\n  fact n = fact k * fact (n - k) * (n choose k)\n\ngoal (1 subgoal):\n 1. n dvd n choose k", "ultimately"], ["proof (chain)\npicking this:\n  n dvd fact n\n  \\<not> n dvd fact k * fact (n - k)\n  fact n = fact k * fact (n - k) * (n choose k)", "show ?thesis"], ["proof (prove)\nusing this:\n  n dvd fact n\n  \\<not> n dvd fact k * fact (n - k)\n  fact n = fact k * fact (n - k) * (n choose k)\n\ngoal (1 subgoal):\n 1. n dvd n choose k", "using prime_n"], ["proof (prove)\nusing this:\n  n dvd fact n\n  \\<not> n dvd fact k * fact (n - k)\n  fact n = fact k * fact (n - k) * (n choose k)\n  prime n\n\ngoal (1 subgoal):\n 1. n dvd n choose k", "by (auto simp add: prime_dvd_mult_iff)"], ["proof (state)\nthis:\n  n dvd n choose k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_power_poly_mod_ring:\nfixes x :: \"'a mod_ring poly\"\nshows \"(x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)", "let ?A=\"{0..CARD('a)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)", "let ?f=\"\\<lambda>k. of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)", "have A_rw: \"?A = insert CARD('a) (insert 0 (?A - {0} - {CARD('a)}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..CARD('a)} =\n    insert CARD('a) (insert 0 ({0..CARD('a)} - {0} - {CARD('a)}))", "by fastforce"], ["proof (state)\nthis:\n  {0..CARD('a)} =\n  insert CARD('a) (insert 0 ({0..CARD('a)} - {0} - {CARD('a)}))\n\ngoal (1 subgoal):\n 1. (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)", "have sum0: \"sum ?f (?A - {0} - {CARD('a)}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>{0..CARD('a)} - {0} - {CARD('a)}.\n       of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k)) =\n    0", "proof (rule sum.neutral, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {0..CARD('a)} - {0} - {CARD('a)} \\<Longrightarrow>\n       of_nat (CARD('a) choose xa) * x ^ xa * y ^ (CARD('a) - xa) = 0", "fix xa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {0..CARD('a)} - {0} - {CARD('a)} \\<Longrightarrow>\n       of_nat (CARD('a) choose xa) * x ^ xa * y ^ (CARD('a) - xa) = 0", "assume xa: \"xa \\<in> {0..CARD('a)} - {0} - {CARD('a)}\""], ["proof (state)\nthis:\n  xa \\<in> {0..CARD('a)} - {0} - {CARD('a)}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {0..CARD('a)} - {0} - {CARD('a)} \\<Longrightarrow>\n       of_nat (CARD('a) choose xa) * x ^ xa * y ^ (CARD('a) - xa) = 0", "have card_dvd_choose: \"CARD('a) dvd  (CARD('a) choose xa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a) dvd CARD('a) choose xa", "proof (rule dvd_choose_prime)"], ["proof (state)\ngoal (4 subgoals):\n 1. xa < CARD('a)\n 2. xa \\<noteq> 0\n 3. CARD('a) \\<noteq> 0\n 4. prime CARD('a)", "show \"xa < CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa < CARD('a)", "using xa"], ["proof (prove)\nusing this:\n  xa \\<in> {0..CARD('a)} - {0} - {CARD('a)}\n\ngoal (1 subgoal):\n 1. xa < CARD('a)", "by simp"], ["proof (state)\nthis:\n  xa < CARD('a)\n\ngoal (3 subgoals):\n 1. xa \\<noteq> 0\n 2. CARD('a) \\<noteq> 0\n 3. prime CARD('a)", "show \"xa \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa \\<noteq> 0", "using xa"], ["proof (prove)\nusing this:\n  xa \\<in> {0..CARD('a)} - {0} - {CARD('a)}\n\ngoal (1 subgoal):\n 1. xa \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  xa \\<noteq> 0\n\ngoal (2 subgoals):\n 1. CARD('a) \\<noteq> 0\n 2. prime CARD('a)", "show \"CARD('a) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a) \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  CARD('a) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prime CARD('a)", "show \"prime CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime CARD('a)", "by (rule prime_card)"], ["proof (state)\nthis:\n  prime CARD('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CARD('a) dvd CARD('a) choose xa\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {0..CARD('a)} - {0} - {CARD('a)} \\<Longrightarrow>\n       of_nat (CARD('a) choose xa) * x ^ xa * y ^ (CARD('a) - xa) = 0", "hence rw0: \"of_int (CARD('a) choose xa) = (0 :: 'a mod_ring)\""], ["proof (prove)\nusing this:\n  CARD('a) dvd CARD('a) choose xa\n\ngoal (1 subgoal):\n 1. of_int (int (CARD('a) choose xa)) = 0", "by transfer simp"], ["proof (state)\nthis:\n  of_int (int (CARD('a) choose xa)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {0..CARD('a)} - {0} - {CARD('a)} \\<Longrightarrow>\n       of_nat (CARD('a) choose xa) * x ^ xa * y ^ (CARD('a) - xa) = 0", "have \"of_nat (CARD('a) choose xa) = [:of_int (CARD('a) choose xa) :: 'a mod_ring:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (CARD('a) choose xa) = [:of_int (int (CARD('a) choose xa)):]", "by (simp add: of_nat_poly)"], ["proof (state)\nthis:\n  of_nat (CARD('a) choose xa) = [:of_int (int (CARD('a) choose xa)):]\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {0..CARD('a)} - {0} - {CARD('a)} \\<Longrightarrow>\n       of_nat (CARD('a) choose xa) * x ^ xa * y ^ (CARD('a) - xa) = 0", "also"], ["proof (state)\nthis:\n  of_nat (CARD('a) choose xa) = [:of_int (int (CARD('a) choose xa)):]\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {0..CARD('a)} - {0} - {CARD('a)} \\<Longrightarrow>\n       of_nat (CARD('a) choose xa) * x ^ xa * y ^ (CARD('a) - xa) = 0", "have \"... = [:0:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:of_int (int (CARD('a) choose xa)):] = [:0:]", "using rw0"], ["proof (prove)\nusing this:\n  of_int (int (CARD('a) choose xa)) = 0\n\ngoal (1 subgoal):\n 1. [:of_int (int (CARD('a) choose xa)):] = [:0:]", "by simp"], ["proof (state)\nthis:\n  [:of_int (int (CARD('a) choose xa)):] = [:0:]\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {0..CARD('a)} - {0} - {CARD('a)} \\<Longrightarrow>\n       of_nat (CARD('a) choose xa) * x ^ xa * y ^ (CARD('a) - xa) = 0", "finally"], ["proof (chain)\npicking this:\n  of_nat (CARD('a) choose xa) = [:0:]", "show \"of_nat (CARD('a) choose xa) * x ^ xa * y ^ (CARD('a) - xa) = 0\""], ["proof (prove)\nusing this:\n  of_nat (CARD('a) choose xa) = [:0:]\n\ngoal (1 subgoal):\n 1. of_nat (CARD('a) choose xa) * x ^ xa * y ^ (CARD('a) - xa) = 0", "by auto"], ["proof (state)\nthis:\n  of_nat (CARD('a) choose xa) * x ^ xa * y ^ (CARD('a) - xa) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>{0..CARD('a)} - {0} - {CARD('a)}.\n     of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k)) =\n  0\n\ngoal (1 subgoal):\n 1. (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)", "have \"(x + y)^CARD('a)\n    = (\\<Sum>k = 0..CARD('a). of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y) ^ CARD('a) =\n    (\\<Sum>k = 0..CARD('a).\n        of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k))", "unfolding binomial_ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>CARD('a).\n        of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k)) =\n    (\\<Sum>k = 0..CARD('a).\n        of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (x + y) ^ CARD('a) =\n  (\\<Sum>k = 0..CARD('a).\n      of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k))\n\ngoal (1 subgoal):\n 1. (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)", "also"], ["proof (state)\nthis:\n  (x + y) ^ CARD('a) =\n  (\\<Sum>k = 0..CARD('a).\n      of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k))\n\ngoal (1 subgoal):\n 1. (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)", "have \"... = sum ?f (insert CARD('a) (insert 0 (?A - {0} - {CARD('a)})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..CARD('a).\n        of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k)) =\n    (\\<Sum>k\\<in>insert CARD('a)\n                  (insert 0 ({0..CARD('a)} - {0} - {CARD('a)})).\n       of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k))", "using A_rw"], ["proof (prove)\nusing this:\n  {0..CARD('a)} =\n  insert CARD('a) (insert 0 ({0..CARD('a)} - {0} - {CARD('a)}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..CARD('a).\n        of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k)) =\n    (\\<Sum>k\\<in>insert CARD('a)\n                  (insert 0 ({0..CARD('a)} - {0} - {CARD('a)})).\n       of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..CARD('a).\n      of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k)) =\n  (\\<Sum>k\\<in>insert CARD('a)\n                (insert 0 ({0..CARD('a)} - {0} - {CARD('a)})).\n     of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k))\n\ngoal (1 subgoal):\n 1. (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..CARD('a).\n      of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k)) =\n  (\\<Sum>k\\<in>insert CARD('a)\n                (insert 0 ({0..CARD('a)} - {0} - {CARD('a)})).\n     of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k))\n\ngoal (1 subgoal):\n 1. (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)", "have \"... = ?f 0 + ?f CARD('a) + sum ?f (?A - {0} - {CARD('a)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>insert CARD('a)\n                  (insert 0 ({0..CARD('a)} - {0} - {CARD('a)})).\n       of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k)) =\n    of_nat (CARD('a) choose 0) * x ^ 0 * y ^ (CARD('a) - 0) +\n    of_nat (CARD('a) choose CARD('a)) * x ^ CARD('a) *\n    y ^ (CARD('a) - CARD('a)) +\n    (\\<Sum>k\\<in>{0..CARD('a)} - {0} - {CARD('a)}.\n       of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert CARD('a)\n                (insert 0 ({0..CARD('a)} - {0} - {CARD('a)})).\n     of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k)) =\n  of_nat (CARD('a) choose 0) * x ^ 0 * y ^ (CARD('a) - 0) +\n  of_nat (CARD('a) choose CARD('a)) * x ^ CARD('a) *\n  y ^ (CARD('a) - CARD('a)) +\n  (\\<Sum>k\\<in>{0..CARD('a)} - {0} - {CARD('a)}.\n     of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k))\n\ngoal (1 subgoal):\n 1. (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert CARD('a)\n                (insert 0 ({0..CARD('a)} - {0} - {CARD('a)})).\n     of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k)) =\n  of_nat (CARD('a) choose 0) * x ^ 0 * y ^ (CARD('a) - 0) +\n  of_nat (CARD('a) choose CARD('a)) * x ^ CARD('a) *\n  y ^ (CARD('a) - CARD('a)) +\n  (\\<Sum>k\\<in>{0..CARD('a)} - {0} - {CARD('a)}.\n     of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k))\n\ngoal (1 subgoal):\n 1. (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)", "have \"... = x^CARD('a) + y^CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (CARD('a) choose 0) * x ^ 0 * y ^ (CARD('a) - 0) +\n    of_nat (CARD('a) choose CARD('a)) * x ^ CARD('a) *\n    y ^ (CARD('a) - CARD('a)) +\n    (\\<Sum>k\\<in>{0..CARD('a)} - {0} - {CARD('a)}.\n       of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k)) =\n    x ^ CARD('a) + y ^ CARD('a)", "unfolding sum0"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (CARD('a) choose 0) * x ^ 0 * y ^ (CARD('a) - 0) +\n    of_nat (CARD('a) choose CARD('a)) * x ^ CARD('a) *\n    y ^ (CARD('a) - CARD('a)) +\n    0 =\n    x ^ CARD('a) + y ^ CARD('a)", "by auto"], ["proof (state)\nthis:\n  of_nat (CARD('a) choose 0) * x ^ 0 * y ^ (CARD('a) - 0) +\n  of_nat (CARD('a) choose CARD('a)) * x ^ CARD('a) *\n  y ^ (CARD('a) - CARD('a)) +\n  (\\<Sum>k\\<in>{0..CARD('a)} - {0} - {CARD('a)}.\n     of_nat (CARD('a) choose k) * x ^ k * y ^ (CARD('a) - k)) =\n  x ^ CARD('a) + y ^ CARD('a)\n\ngoal (1 subgoal):\n 1. (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)", "finally"], ["proof (chain)\npicking this:\n  (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)\n\ngoal (1 subgoal):\n 1. (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)", "."], ["proof (state)\nthis:\n  (x + y) ^ CARD('a) = x ^ CARD('a) + y ^ CARD('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma power_poly_sum_mod_ring:\nfixes f :: \"'b \\<Rightarrow> 'a mod_ring poly\"\nassumes f: \"finite A\"\nshows \"(sum f A) ^ CARD('a) = sum (\\<lambda>i. (f i) ^ CARD('a)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f A ^ CARD('a) = (\\<Sum>i\\<in>A. f i ^ CARD('a))", "using f"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. sum f A ^ CARD('a) = (\\<Sum>i\\<in>A. f i ^ CARD('a))", "by (induct, auto simp add: add_power_poly_mod_ring)"], ["", "lemma poly_power_card_as_sum_of_monoms:\n  fixes h :: \"'a mod_ring poly\"\n  shows \"h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a)*i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "have \"h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) i) ^ CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) i) ^ CARD('a)", "by (simp add: poly_as_sum_of_monoms)"], ["proof (state)\nthis:\n  h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) i) ^ CARD('a)\n\ngoal (1 subgoal):\n 1. h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "also"], ["proof (state)\nthis:\n  h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) i) ^ CARD('a)\n\ngoal (1 subgoal):\n 1. h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "have \"... = (\\<Sum>i\\<le>degree h. (monom (coeff h i) i) ^ CARD('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h. monom (coeff h i) i) ^ CARD('a) =\n    (\\<Sum>i\\<le>degree h. monom (coeff h i) i ^ CARD('a))", "by (simp add: power_poly_sum_mod_ring)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) i) ^ CARD('a) =\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) i ^ CARD('a))\n\ngoal (1 subgoal):\n 1. h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) i) ^ CARD('a) =\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) i ^ CARD('a))\n\ngoal (1 subgoal):\n 1. h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "have \"... = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a)*i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h. monom (coeff h i) i ^ CARD('a)) =\n    (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "proof (rule sum.cong, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree h} \\<Longrightarrow>\n       monom (coeff h x) x ^ CARD('a) = monom (coeff h x) (CARD('a) * x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree h} \\<Longrightarrow>\n       monom (coeff h x) x ^ CARD('a) = monom (coeff h x) (CARD('a) * x)", "assume x: \"x \\<in> {..degree h}\""], ["proof (state)\nthis:\n  x \\<in> {..degree h}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree h} \\<Longrightarrow>\n       monom (coeff h x) x ^ CARD('a) = monom (coeff h x) (CARD('a) * x)", "show \"monom (coeff h x) x ^ CARD('a) = monom (coeff h x) (CARD('a) * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (coeff h x) x ^ CARD('a) = monom (coeff h x) (CARD('a) * x)", "by (unfold poly_eq_iff, auto simp add: monom_power)"], ["proof (state)\nthis:\n  monom (coeff h x) x ^ CARD('a) = monom (coeff h x) (CARD('a) * x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) i ^ CARD('a)) =\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))\n\ngoal (1 subgoal):\n 1. h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "finally"], ["proof (chain)\npicking this:\n  h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "show ?thesis"], ["proof (prove)\nusing this:\n  h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))\n\ngoal (1 subgoal):\n 1. h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "."], ["proof (state)\nthis:\n  h ^ CARD('a) = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_Poly_berlekamp_le:\nassumes i: \"i < degree u\"\nshows \"degree (Poly (list_of_vec (row (berlekamp_mat u) i))) < degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec (row (local.berlekamp_mat u) i))) < degree u", "by (metis Poly_berlekamp_mat degree_0 degree_mod_less gr_implies_not0 i linorder_neqE_nat)"], ["", "(*\n  Equation 12: alternative statement.\n*)"], ["", "lemma monom_card_pow_mod_sum_berlekamp:\nassumes i: \"i < degree u\"\nshows \"monom 1 (CARD('a) * i) mod u = (\\<Sum>j<degree u. monom ((berlekamp_mat u) $$ (i,j)) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "let ?p = \"Poly (list_of_vec (row (berlekamp_mat u) i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "have degree_not_0: \"degree u \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree u \\<noteq> 0", "using i"], ["proof (prove)\nusing this:\n  i < degree u\n\ngoal (1 subgoal):\n 1. degree u \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  degree u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "hence set_rw: \"{..degree u - 1} = {..<degree u}\""], ["proof (prove)\nusing this:\n  degree u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {..degree u - 1} = {..<degree u}", "by auto"], ["proof (state)\nthis:\n  {..degree u - 1} = {..<degree u}\n\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "have degree_le: \"degree ?p < degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec (row (local.berlekamp_mat u) i))) < degree u", "by (rule degree_Poly_berlekamp_le[OF i])"], ["proof (state)\nthis:\n  degree (Poly (list_of_vec (row (local.berlekamp_mat u) i))) < degree u\n\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "hence degree_le2: \"degree ?p \\<le> degree u - 1\""], ["proof (prove)\nusing this:\n  degree (Poly (list_of_vec (row (local.berlekamp_mat u) i))) < degree u\n\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec (row (local.berlekamp_mat u) i)))\n    \\<le> degree u - 1", "by auto"], ["proof (state)\nthis:\n  degree (Poly (list_of_vec (row (local.berlekamp_mat u) i)))\n  \\<le> degree u - 1\n\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "have \"monom 1 (CARD('a) * i) mod u = [:0, 1:] ^ (CARD('a) * i) mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u = [:0, 1:] ^ (CARD('a) * i) mod u", "using x_as_monom x_pow_n"], ["proof (prove)\nusing this:\n  [:0::?'a, 1::?'a:] = monom (1::?'a) 1\n  monom (1::?'a) 1 ^ ?n = monom (1::?'a) ?n\n\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u = [:0, 1:] ^ (CARD('a) * i) mod u", "by metis"], ["proof (state)\nthis:\n  monom 1 (CARD('a) * i) mod u = [:0, 1:] ^ (CARD('a) * i) mod u\n\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "also"], ["proof (state)\nthis:\n  monom 1 (CARD('a) * i) mod u = [:0, 1:] ^ (CARD('a) * i) mod u\n\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "have \"... = ?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0, 1:] ^ (CARD('a) * i) mod u =\n    Poly (list_of_vec (row (local.berlekamp_mat u) i))", "unfolding Poly_berlekamp_mat[OF i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0, 1:] ^ (CARD('a) * i) mod u = [:0, 1:] ^ (CARD('a) * i) mod u", "by simp"], ["proof (state)\nthis:\n  [:0, 1:] ^ (CARD('a) * i) mod u =\n  Poly (list_of_vec (row (local.berlekamp_mat u) i))\n\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "also"], ["proof (state)\nthis:\n  [:0, 1:] ^ (CARD('a) * i) mod u =\n  Poly (list_of_vec (row (local.berlekamp_mat u) i))\n\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "have \"... = (\\<Sum>i\\<le>degree u - 1. monom (coeff ?p i) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) i)) =\n    (\\<Sum>ia\\<le>degree u - 1.\n        monom\n         (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) ia) ia)", "using degree_le2 poly_as_sum_of_monoms'"], ["proof (prove)\nusing this:\n  degree (Poly (list_of_vec (row (local.berlekamp_mat u) i)))\n  \\<le> degree u - 1\n  degree ?p \\<le> ?n \\<Longrightarrow>\n  (\\<Sum>i\\<le>?n. monom (coeff ?p i) i) = ?p\n\ngoal (1 subgoal):\n 1. Poly (list_of_vec (row (local.berlekamp_mat u) i)) =\n    (\\<Sum>ia\\<le>degree u - 1.\n        monom\n         (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) ia) ia)", "by fastforce"], ["proof (state)\nthis:\n  Poly (list_of_vec (row (local.berlekamp_mat u) i)) =\n  (\\<Sum>ia\\<le>degree u - 1.\n      monom (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) ia)\n       ia)\n\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "also"], ["proof (state)\nthis:\n  Poly (list_of_vec (row (local.berlekamp_mat u) i)) =\n  (\\<Sum>ia\\<le>degree u - 1.\n      monom (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) ia)\n       ia)\n\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "have \"... = (\\<Sum>i<degree u. monom (coeff ?p i) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<le>degree u - 1.\n        monom\n         (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) ia)\n         ia) =\n    (\\<Sum>ia<degree u.\n        monom\n         (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) ia) ia)", "using set_rw"], ["proof (prove)\nusing this:\n  {..degree u - 1} = {..<degree u}\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<le>degree u - 1.\n        monom\n         (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) ia)\n         ia) =\n    (\\<Sum>ia<degree u.\n        monom\n         (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) ia) ia)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>ia\\<le>degree u - 1.\n      monom (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) ia)\n       ia) =\n  (\\<Sum>ia<degree u.\n      monom (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) ia)\n       ia)\n\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "also"], ["proof (state)\nthis:\n  (\\<Sum>ia\\<le>degree u - 1.\n      monom (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) ia)\n       ia) =\n  (\\<Sum>ia<degree u.\n      monom (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) ia)\n       ia)\n\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "have \"... = (\\<Sum>j<degree u. monom ((berlekamp_mat u) $$ (i,j)) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia<degree u.\n        monom\n         (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) ia)\n         ia) =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "proof (rule sum.cong, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<degree u} \\<Longrightarrow>\n       monom (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) x)\n        x =\n       monom (local.berlekamp_mat u $$ (i, x)) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<degree u} \\<Longrightarrow>\n       monom (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) x)\n        x =\n       monom (local.berlekamp_mat u $$ (i, x)) x", "assume x: \"x \\<in> {..<degree u}\""], ["proof (state)\nthis:\n  x \\<in> {..<degree u}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<degree u} \\<Longrightarrow>\n       monom (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) x)\n        x =\n       monom (local.berlekamp_mat u $$ (i, x)) x", "have \"coeff ?p x = berlekamp_mat u $$ (i, x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) x =\n    local.berlekamp_mat u $$ (i, x)", "proof (rule coeff_Poly_list_of_vec_nth)"], ["proof (state)\ngoal (1 subgoal):\n 1. x < dim_col (local.berlekamp_mat u)", "show \"x < dim_col (berlekamp_mat u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < dim_col (local.berlekamp_mat u)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> {..<degree u}\n\ngoal (1 subgoal):\n 1. x < dim_col (local.berlekamp_mat u)", "by auto"], ["proof (state)\nthis:\n  x < dim_col (local.berlekamp_mat u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) x =\n  local.berlekamp_mat u $$ (i, x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<degree u} \\<Longrightarrow>\n       monom (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) x)\n        x =\n       monom (local.berlekamp_mat u $$ (i, x)) x", "thus \"monom (coeff ?p x) x = monom (berlekamp_mat u $$ (i, x)) x\""], ["proof (prove)\nusing this:\n  coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) x =\n  local.berlekamp_mat u $$ (i, x)\n\ngoal (1 subgoal):\n 1. monom (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) x) x =\n    monom (local.berlekamp_mat u $$ (i, x)) x", "by (simp add: poly_eq_iff)"], ["proof (state)\nthis:\n  monom (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) x) x =\n  monom (local.berlekamp_mat u $$ (i, x)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>ia<degree u.\n      monom (coeff (Poly (list_of_vec (row (local.berlekamp_mat u) i))) ia)\n       ia) =\n  (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)\n\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "finally"], ["proof (chain)\npicking this:\n  monom 1 (CARD('a) * i) mod u =\n  (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "show ?thesis"], ["proof (prove)\nusing this:\n  monom 1 (CARD('a) * i) mod u =\n  (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)\n\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * i) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)", "."], ["proof (state)\nthis:\n  monom 1 (CARD('a) * i) mod u =\n  (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma col_scalar_prod_as_sum:\nassumes \"dim_vec v = dim_row A\"\nshows \"col A j \\<bullet> v = (\\<Sum>i = 0..<dim_vec v. A $$ (i,j) * v $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col A j \\<bullet> v = (\\<Sum>i = 0..<dim_vec v. A $$ (i, j) * v $ i)", "using assms"], ["proof (prove)\nusing this:\n  dim_vec v = dim_row A\n\ngoal (1 subgoal):\n 1. col A j \\<bullet> v = (\\<Sum>i = 0..<dim_vec v. A $$ (i, j) * v $ i)", "unfolding col_def scalar_prod_def"], ["proof (prove)\nusing this:\n  dim_vec v = dim_row A\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec v.\n        vec (dim_row A) (\\<lambda>i. A $$ (i, j)) $ i * v $ i) =\n    (\\<Sum>i = 0..<dim_vec v. A $$ (i, j) * v $ i)", "by transfer' (rule sum.cong, transfer', auto simp add: mk_vec_def mk_mat_def )"], ["", "lemma row_transpose_scalar_prod_as_sum:\nassumes j: \"j < dim_col A\" and dim_v: \"dim_vec v = dim_row A\"\nshows \"row (transpose_mat A) j \\<bullet> v = (\\<Sum>i = 0..<dim_vec v. A $$ (i,j) * v $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A\\<^sup>T j \\<bullet> v =\n    (\\<Sum>i = 0..<dim_vec v. A $$ (i, j) * v $ i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. row A\\<^sup>T j \\<bullet> v =\n    (\\<Sum>i = 0..<dim_vec v. A $$ (i, j) * v $ i)", "have \"row (transpose_mat A) j \\<bullet> v = col A j \\<bullet> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A\\<^sup>T j \\<bullet> v = col A j \\<bullet> v", "using j row_transpose"], ["proof (prove)\nusing this:\n  j < dim_col A\n  ?j < dim_col ?A \\<Longrightarrow> row ?A\\<^sup>T ?j = col ?A ?j\n\ngoal (1 subgoal):\n 1. row A\\<^sup>T j \\<bullet> v = col A j \\<bullet> v", "by auto"], ["proof (state)\nthis:\n  row A\\<^sup>T j \\<bullet> v = col A j \\<bullet> v\n\ngoal (1 subgoal):\n 1. row A\\<^sup>T j \\<bullet> v =\n    (\\<Sum>i = 0..<dim_vec v. A $$ (i, j) * v $ i)", "also"], ["proof (state)\nthis:\n  row A\\<^sup>T j \\<bullet> v = col A j \\<bullet> v\n\ngoal (1 subgoal):\n 1. row A\\<^sup>T j \\<bullet> v =\n    (\\<Sum>i = 0..<dim_vec v. A $$ (i, j) * v $ i)", "have \"... = (\\<Sum>i = 0..<dim_vec v. A $$ (i,j) * v $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col A j \\<bullet> v = (\\<Sum>i = 0..<dim_vec v. A $$ (i, j) * v $ i)", "by (rule col_scalar_prod_as_sum[OF dim_v])"], ["proof (state)\nthis:\n  col A j \\<bullet> v = (\\<Sum>i = 0..<dim_vec v. A $$ (i, j) * v $ i)\n\ngoal (1 subgoal):\n 1. row A\\<^sup>T j \\<bullet> v =\n    (\\<Sum>i = 0..<dim_vec v. A $$ (i, j) * v $ i)", "finally"], ["proof (chain)\npicking this:\n  row A\\<^sup>T j \\<bullet> v =\n  (\\<Sum>i = 0..<dim_vec v. A $$ (i, j) * v $ i)", "show ?thesis"], ["proof (prove)\nusing this:\n  row A\\<^sup>T j \\<bullet> v =\n  (\\<Sum>i = 0..<dim_vec v. A $$ (i, j) * v $ i)\n\ngoal (1 subgoal):\n 1. row A\\<^sup>T j \\<bullet> v =\n    (\\<Sum>i = 0..<dim_vec v. A $$ (i, j) * v $ i)", "."], ["proof (state)\nthis:\n  row A\\<^sup>T j \\<bullet> v =\n  (\\<Sum>i = 0..<dim_vec v. A $$ (i, j) * v $ i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_as_sum_eq_monoms:\nassumes ss_eq: \"(\\<Sum>i<n. monom (f i) i) = (\\<Sum>i<n. monom (g i) i)\"\nand a_less_n: \"a<n\"\nshows \"f a = g a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a = g a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f a = g a", "let ?f=\"\\<lambda>i. if i = a then f i else 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. f a = g a", "let ?g=\"\\<lambda>i. if i = a then g i else 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. f a = g a", "have sum_f_0: \"sum ?f ({..<n} - {a}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{..<n} - {a}. if i = a then f i else (0::'b)) = (0::'b)", "by (rule sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{..<n} - {a}. if i = a then f i else (0::'b)) = (0::'b)\n\ngoal (1 subgoal):\n 1. f a = g a", "have \"coeff (\\<Sum>i<n. monom (f i) i) a = coeff (\\<Sum>i<n. monom (g i) i) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i<n. monom (f i) i) a = coeff (\\<Sum>i<n. monom (g i) i) a", "using ss_eq"], ["proof (prove)\nusing this:\n  (\\<Sum>i<n. monom (f i) i) = (\\<Sum>i<n. monom (g i) i)\n\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i<n. monom (f i) i) a = coeff (\\<Sum>i<n. monom (g i) i) a", "unfolding poly_eq_iff"], ["proof (prove)\nusing this:\n  \\<forall>na.\n     coeff (\\<Sum>i<n. monom (f i) i) na =\n     coeff (\\<Sum>i<n. monom (g i) i) na\n\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i<n. monom (f i) i) a = coeff (\\<Sum>i<n. monom (g i) i) a", "by simp"], ["proof (state)\nthis:\n  coeff (\\<Sum>i<n. monom (f i) i) a = coeff (\\<Sum>i<n. monom (g i) i) a\n\ngoal (1 subgoal):\n 1. f a = g a", "hence \"(\\<Sum>i<n. coeff (monom (f i) i) a) = (\\<Sum>i<n. coeff (monom (g i) i) a)\""], ["proof (prove)\nusing this:\n  coeff (\\<Sum>i<n. monom (f i) i) a = coeff (\\<Sum>i<n. monom (g i) i) a\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. coeff (monom (f i) i) a) =\n    (\\<Sum>i<n. coeff (monom (g i) i) a)", "by (simp add: coeff_sum)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. coeff (monom (f i) i) a) =\n  (\\<Sum>i<n. coeff (monom (g i) i) a)\n\ngoal (1 subgoal):\n 1. f a = g a", "hence 1: \"(\\<Sum>i<n. if i = a then f i else 0) = (\\<Sum>i<n. if i = a then g i else 0)\""], ["proof (prove)\nusing this:\n  (\\<Sum>i<n. coeff (monom (f i) i) a) =\n  (\\<Sum>i<n. coeff (monom (g i) i) a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. if i = a then f i else (0::'b)) =\n    (\\<Sum>i<n. if i = a then g i else (0::'b))", "unfolding coeff_monom"], ["proof (prove)\nusing this:\n  (\\<Sum>i<n. if i = a then f i else (0::'b)) =\n  (\\<Sum>i<n. if i = a then g i else (0::'b))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. if i = a then f i else (0::'b)) =\n    (\\<Sum>i<n. if i = a then g i else (0::'b))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n. if i = a then f i else (0::'b)) =\n  (\\<Sum>i<n. if i = a then g i else (0::'b))\n\ngoal (1 subgoal):\n 1. f a = g a", "have set_rw: \"{..<n} = (insert a ({..<n} - {a}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<n} = insert a ({..<n} - {a})", "using a_less_n"], ["proof (prove)\nusing this:\n  a < n\n\ngoal (1 subgoal):\n 1. {..<n} = insert a ({..<n} - {a})", "by auto"], ["proof (state)\nthis:\n  {..<n} = insert a ({..<n} - {a})\n\ngoal (1 subgoal):\n 1. f a = g a", "have \"(\\<Sum>i<n. if i = a then f i else 0) = sum ?f (insert a ({..<n} - {a}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. if i = a then f i else (0::'b)) =\n    (\\<Sum>i\\<in>insert a ({..<n} - {a}). if i = a then f i else (0::'b))", "using set_rw"], ["proof (prove)\nusing this:\n  {..<n} = insert a ({..<n} - {a})\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. if i = a then f i else (0::'b)) =\n    (\\<Sum>i\\<in>insert a ({..<n} - {a}). if i = a then f i else (0::'b))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n. if i = a then f i else (0::'b)) =\n  (\\<Sum>i\\<in>insert a ({..<n} - {a}). if i = a then f i else (0::'b))\n\ngoal (1 subgoal):\n 1. f a = g a", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. if i = a then f i else (0::'b)) =\n  (\\<Sum>i\\<in>insert a ({..<n} - {a}). if i = a then f i else (0::'b))\n\ngoal (1 subgoal):\n 1. f a = g a", "have \"... = ?f a + sum ?f ({..<n} - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>insert a ({..<n} - {a}). if i = a then f i else (0::'b)) =\n    (if a = a then f a else (0::'b)) +\n    (\\<Sum>i\\<in>{..<n} - {a}. if i = a then f i else (0::'b))", "by (simp add: sum.insert_remove)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>insert a ({..<n} - {a}). if i = a then f i else (0::'b)) =\n  (if a = a then f a else (0::'b)) +\n  (\\<Sum>i\\<in>{..<n} - {a}. if i = a then f i else (0::'b))\n\ngoal (1 subgoal):\n 1. f a = g a", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>insert a ({..<n} - {a}). if i = a then f i else (0::'b)) =\n  (if a = a then f a else (0::'b)) +\n  (\\<Sum>i\\<in>{..<n} - {a}. if i = a then f i else (0::'b))\n\ngoal (1 subgoal):\n 1. f a = g a", "have \"... = ?f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a = a then f a else (0::'b)) +\n    (\\<Sum>i\\<in>{..<n} - {a}. if i = a then f i else (0::'b)) =\n    (if a = a then f a else (0::'b))", "using sum_f_0"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>{..<n} - {a}. if i = a then f i else (0::'b)) = (0::'b)\n\ngoal (1 subgoal):\n 1. (if a = a then f a else (0::'b)) +\n    (\\<Sum>i\\<in>{..<n} - {a}. if i = a then f i else (0::'b)) =\n    (if a = a then f a else (0::'b))", "by simp"], ["proof (state)\nthis:\n  (if a = a then f a else (0::'b)) +\n  (\\<Sum>i\\<in>{..<n} - {a}. if i = a then f i else (0::'b)) =\n  (if a = a then f a else (0::'b))\n\ngoal (1 subgoal):\n 1. f a = g a", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i<n. if i = a then f i else (0::'b)) =\n  (if a = a then f a else (0::'b))", "have 2: \"(\\<Sum>i<n. if i = a then f i else 0) = ?f a\""], ["proof (prove)\nusing this:\n  (\\<Sum>i<n. if i = a then f i else (0::'b)) =\n  (if a = a then f a else (0::'b))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. if i = a then f i else (0::'b)) =\n    (if a = a then f a else (0::'b))", "."], ["proof (state)\nthis:\n  (\\<Sum>i<n. if i = a then f i else (0::'b)) =\n  (if a = a then f a else (0::'b))\n\ngoal (1 subgoal):\n 1. f a = g a", "have \"sum ?g {..<n} = sum ?g (insert a ({..<n} - {a}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. if i = a then g i else (0::'b)) =\n    (\\<Sum>i\\<in>insert a ({..<n} - {a}). if i = a then g i else (0::'b))", "using set_rw"], ["proof (prove)\nusing this:\n  {..<n} = insert a ({..<n} - {a})\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. if i = a then g i else (0::'b)) =\n    (\\<Sum>i\\<in>insert a ({..<n} - {a}). if i = a then g i else (0::'b))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n. if i = a then g i else (0::'b)) =\n  (\\<Sum>i\\<in>insert a ({..<n} - {a}). if i = a then g i else (0::'b))\n\ngoal (1 subgoal):\n 1. f a = g a", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. if i = a then g i else (0::'b)) =\n  (\\<Sum>i\\<in>insert a ({..<n} - {a}). if i = a then g i else (0::'b))\n\ngoal (1 subgoal):\n 1. f a = g a", "have \"... = ?g a + sum ?g ({..<n} - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>insert a ({..<n} - {a}). if i = a then g i else (0::'b)) =\n    (if a = a then g a else (0::'b)) +\n    (\\<Sum>i\\<in>{..<n} - {a}. if i = a then g i else (0::'b))", "by (simp add: sum.insert_remove)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>insert a ({..<n} - {a}). if i = a then g i else (0::'b)) =\n  (if a = a then g a else (0::'b)) +\n  (\\<Sum>i\\<in>{..<n} - {a}. if i = a then g i else (0::'b))\n\ngoal (1 subgoal):\n 1. f a = g a", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>insert a ({..<n} - {a}). if i = a then g i else (0::'b)) =\n  (if a = a then g a else (0::'b)) +\n  (\\<Sum>i\\<in>{..<n} - {a}. if i = a then g i else (0::'b))\n\ngoal (1 subgoal):\n 1. f a = g a", "have \"... = ?g a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a = a then g a else (0::'b)) +\n    (\\<Sum>i\\<in>{..<n} - {a}. if i = a then g i else (0::'b)) =\n    (if a = a then g a else (0::'b))", "using sum_f_0"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>{..<n} - {a}. if i = a then f i else (0::'b)) = (0::'b)\n\ngoal (1 subgoal):\n 1. (if a = a then g a else (0::'b)) +\n    (\\<Sum>i\\<in>{..<n} - {a}. if i = a then g i else (0::'b)) =\n    (if a = a then g a else (0::'b))", "by simp"], ["proof (state)\nthis:\n  (if a = a then g a else (0::'b)) +\n  (\\<Sum>i\\<in>{..<n} - {a}. if i = a then g i else (0::'b)) =\n  (if a = a then g a else (0::'b))\n\ngoal (1 subgoal):\n 1. f a = g a", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i<n. if i = a then g i else (0::'b)) =\n  (if a = a then g a else (0::'b))", "have 3: \"(\\<Sum>i<n. if i = a then g i else 0) = ?g a\""], ["proof (prove)\nusing this:\n  (\\<Sum>i<n. if i = a then g i else (0::'b)) =\n  (if a = a then g a else (0::'b))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. if i = a then g i else (0::'b)) =\n    (if a = a then g a else (0::'b))", "."], ["proof (state)\nthis:\n  (\\<Sum>i<n. if i = a then g i else (0::'b)) =\n  (if a = a then g a else (0::'b))\n\ngoal (1 subgoal):\n 1. f a = g a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f a = g a", "using 1 2 3"], ["proof (prove)\nusing this:\n  (\\<Sum>i<n. if i = a then f i else (0::'b)) =\n  (\\<Sum>i<n. if i = a then g i else (0::'b))\n  (\\<Sum>i<n. if i = a then f i else (0::'b)) =\n  (if a = a then f a else (0::'b))\n  (\\<Sum>i<n. if i = a then g i else (0::'b)) =\n  (if a = a then g a else (0::'b))\n\ngoal (1 subgoal):\n 1. f a = g a", "by auto"], ["proof (state)\nthis:\n  f a = g a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dim_vec_of_list_h:\nassumes \"degree h < degree u\"\nshows \"dim_vec (vec_of_list ((coeffs h) @ replicate (degree u - length (coeffs h)) 0)) = degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec_of_list\n       (coeffs h @ replicate (degree u - length (coeffs h)) (0::'b))) =\n    degree u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec_of_list\n       (coeffs h @ replicate (degree u - length (coeffs h)) (0::'b))) =\n    degree u", "have \"length (coeffs h) \\<le> degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (coeffs h) \\<le> degree u", "by (metis Suc_leI assms coeffs_0_eq_Nil degree_0 length_coeffs_degree\n        list.size(3) not_le_imp_less order.asym)"], ["proof (state)\nthis:\n  length (coeffs h) \\<le> degree u\n\ngoal (1 subgoal):\n 1. dim_vec\n     (vec_of_list\n       (coeffs h @ replicate (degree u - length (coeffs h)) (0::'b))) =\n    degree u", "thus ?thesis"], ["proof (prove)\nusing this:\n  length (coeffs h) \\<le> degree u\n\ngoal (1 subgoal):\n 1. dim_vec\n     (vec_of_list\n       (coeffs h @ replicate (degree u - length (coeffs h)) (0::'b))) =\n    degree u", "by simp"], ["proof (state)\nthis:\n  dim_vec\n   (vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'b))) =\n  degree u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_of_list_coeffs_nth':\nassumes i: \"i \\<in> {..degree h}\" and h_not0: \"h \\<noteq> 0\"\nassumes \"degree h < degree u\"\nshows \"vec_of_list ((coeffs h) @ replicate (degree u - length (coeffs h)) 0) $ i = coeff h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'b)) $\n    i =\n    coeff h i", "using assms"], ["proof (prove)\nusing this:\n  i \\<in> {..degree h}\n  h \\<noteq> 0\n  degree h < degree u\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'b)) $\n    i =\n    coeff h i", "by (transfer', auto simp add: mk_vec_def coeffs_nth length_coeffs_degree nth_append)"], ["", "lemma vec_of_list_coeffs_replicate_nth_0:\nassumes i: \"i \\<in> {..<degree u}\"\nshows \"vec_of_list (coeffs 0 @ replicate (degree u - length (coeffs 0)) 0) $ i = coeff 0 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs 0 @ replicate (degree u - length (coeffs 0)) (0::'c)) $\n    i =\n    coeff 0 i", "using assms"], ["proof (prove)\nusing this:\n  i \\<in> {..<degree u}\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs 0 @ replicate (degree u - length (coeffs 0)) (0::'c)) $\n    i =\n    coeff 0 i", "by (transfer', auto simp add: mk_vec_def)"], ["", "lemma vec_of_list_coeffs_replicate_nth:\nassumes i: \"i \\<in> {..<degree u}\"\nassumes \"degree h < degree u\"\nshows \"vec_of_list ((coeffs h) @ replicate (degree u - length (coeffs h)) 0) $ i = coeff h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "proof (cases \"h = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. h = 0 \\<Longrightarrow>\n    vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i\n 2. h \\<noteq> 0 \\<Longrightarrow>\n    vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "case True"], ["proof (state)\nthis:\n  h = 0\n\ngoal (2 subgoals):\n 1. h = 0 \\<Longrightarrow>\n    vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i\n 2. h \\<noteq> 0 \\<Longrightarrow>\n    vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "thus ?thesis"], ["proof (prove)\nusing this:\n  h = 0\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "using vec_of_list_coeffs_replicate_nth_0 i"], ["proof (prove)\nusing this:\n  h = 0\n  ?i \\<in> {..<degree ?u} \\<Longrightarrow>\n  vec_of_list\n   (coeffs 0 @ replicate (degree ?u - length (coeffs 0)) (0::?'c)) $\n  ?i =\n  coeff 0 ?i\n  i \\<in> {..<degree u}\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "by auto"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n  i =\n  coeff h i\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow>\n    vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow>\n    vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "case False"], ["proof (state)\nthis:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow>\n    vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "note h_not0 = False"], ["proof (state)\nthis:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow>\n    vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "proof (cases \"i \\<in>{..degree h}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> {..degree h} \\<Longrightarrow>\n    vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i\n 2. i \\<notin> {..degree h} \\<Longrightarrow>\n    vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "case True"], ["proof (state)\nthis:\n  i \\<in> {..degree h}\n\ngoal (2 subgoals):\n 1. i \\<in> {..degree h} \\<Longrightarrow>\n    vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i\n 2. i \\<notin> {..degree h} \\<Longrightarrow>\n    vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> {..degree h}\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "using assms vec_of_list_coeffs_nth' h_not0"], ["proof (prove)\nusing this:\n  i \\<in> {..degree h}\n  i \\<in> {..<degree u}\n  degree h < degree u\n  \\<lbrakk>?i \\<in> {..degree ?h}; ?h \\<noteq> 0;\n   degree ?h < degree ?u\\<rbrakk>\n  \\<Longrightarrow> vec_of_list\n                     (coeffs ?h @\n                      replicate (degree ?u - length (coeffs ?h)) (0::?'b)) $\n                    ?i =\n                    coeff ?h ?i\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "by simp"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n  i =\n  coeff h i\n\ngoal (1 subgoal):\n 1. i \\<notin> {..degree h} \\<Longrightarrow>\n    vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<notin> {..degree h} \\<Longrightarrow>\n    vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "case False"], ["proof (state)\nthis:\n  i \\<notin> {..degree h}\n\ngoal (1 subgoal):\n 1. i \\<notin> {..degree h} \\<Longrightarrow>\n    vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "have c0: \"coeff h i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff h i = (0::'c)", "using False le_degree"], ["proof (prove)\nusing this:\n  i \\<notin> {..degree h}\n  coeff ?p ?n \\<noteq> (0::?'a) \\<Longrightarrow> ?n \\<le> degree ?p\n\ngoal (1 subgoal):\n 1. coeff h i = (0::'c)", "by auto"], ["proof (state)\nthis:\n  coeff h i = (0::'c)\n\ngoal (1 subgoal):\n 1. i \\<notin> {..degree h} \\<Longrightarrow>\n    vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "thus ?thesis"], ["proof (prove)\nusing this:\n  coeff h i = (0::'c)\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "using assms False h_not0"], ["proof (prove)\nusing this:\n  coeff h i = (0::'c)\n  i \\<in> {..<degree u}\n  degree h < degree u\n  i \\<notin> {..degree h}\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n    i =\n    coeff h i", "by (transfer', auto simp add: mk_vec_def length_coeffs_degree nth_append c0)"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n  i =\n  coeff h i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs h @ replicate (degree u - length (coeffs h)) (0::'c)) $\n  i =\n  coeff h i\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\n  Equation 13\n*)"], ["", "lemma equation_13:\n  fixes u h\n  defines H: \"H \\<equiv> vec_of_list ((coeffs h) @ replicate (degree u - length (coeffs h)) 0)\"\n  assumes deg_le: \"degree h < degree u\" (*Mandatory from equation 8*)\n  shows \"[h^CARD('a) = h] (mod u) \\<longleftrightarrow> (transpose_mat (berlekamp_mat u)) *\\<^sub>v H = H\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) =\n    ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) =\n    ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H)", "have f: \"finite {..degree u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {..degree u}", "by auto"], ["proof (state)\nthis:\n  finite {..degree u}\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) =\n    ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H)", "have [simp]: \"dim_vec H = degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec H = degree u", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec_of_list (coeffs h @ replicate (degree u - length (coeffs h)) 0)) =\n    degree u", "using dim_vec_of_list_h deg_le"], ["proof (prove)\nusing this:\n  degree ?h < degree ?u \\<Longrightarrow>\n  dim_vec\n   (vec_of_list\n     (coeffs ?h @ replicate (degree ?u - length (coeffs ?h)) (0::?'b))) =\n  degree ?u\n  degree h < degree u\n\ngoal (1 subgoal):\n 1. dim_vec\n     (vec_of_list (coeffs h @ replicate (degree u - length (coeffs h)) 0)) =\n    degree u", "by simp"], ["proof (state)\nthis:\n  dim_vec H = degree u\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) =\n    ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H)", "let ?B = \"(berlekamp_mat u)\""], ["proof (state)\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) =\n    ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H)", "let ?f = \"\\<lambda>i. (transpose_mat ?B *\\<^sub>v H) $ i\""], ["proof (state)\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) =\n    ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) =\n    ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "assume rhs: ?rhs"], ["proof (state)\nthis:\n  (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have dimv_h_dimr_B: \"dim_vec H = dim_row ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec H = dim_row (local.berlekamp_mat u)", "by (metis berlekamp_mat_closed(2) berlekamp_mat_closed(3)\n        dim_mult_mat_vec index_transpose_mat(2) rhs)"], ["proof (state)\nthis:\n  dim_vec H = dim_row (local.berlekamp_mat u)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have degree_h_less_dim_H: \"degree h < dim_vec H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree h < dim_vec H", "by (auto simp add: deg_le)"], ["proof (state)\nthis:\n  degree h < dim_vec H\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have set_rw: \"{..degree u - 1} = {..<degree u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..degree u - 1} = {..<degree u}", "using deg_le"], ["proof (prove)\nusing this:\n  degree h < degree u\n\ngoal (1 subgoal):\n 1. {..degree u - 1} = {..<degree u}", "by auto"], ["proof (state)\nthis:\n  {..degree u - 1} = {..<degree u}\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have \"degree h \\<le> degree u - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree h \\<le> degree u - 1", "using deg_le"], ["proof (prove)\nusing this:\n  degree h < degree u\n\ngoal (1 subgoal):\n 1. degree h \\<le> degree u - 1", "by simp"], ["proof (state)\nthis:\n  degree h \\<le> degree u - 1\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "hence \"h = (\\<Sum>j\\<le>degree u - 1. monom (coeff h j) j)\""], ["proof (prove)\nusing this:\n  degree h \\<le> degree u - 1\n\ngoal (1 subgoal):\n 1. h = (\\<Sum>j\\<le>degree u - 1. monom (coeff h j) j)", "using poly_as_sum_of_monoms'"], ["proof (prove)\nusing this:\n  degree h \\<le> degree u - 1\n  degree ?p \\<le> ?n \\<Longrightarrow>\n  (\\<Sum>i\\<le>?n. monom (coeff ?p i) i) = ?p\n\ngoal (1 subgoal):\n 1. h = (\\<Sum>j\\<le>degree u - 1. monom (coeff h j) j)", "by fastforce"], ["proof (state)\nthis:\n  h = (\\<Sum>j\\<le>degree u - 1. monom (coeff h j) j)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "also"], ["proof (state)\nthis:\n  h = (\\<Sum>j\\<le>degree u - 1. monom (coeff h j) j)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have \"... = (\\<Sum>j<degree u. monom (coeff h j) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>degree u - 1. monom (coeff h j) j) =\n    (\\<Sum>j<degree u. monom (coeff h j) j)", "using set_rw"], ["proof (prove)\nusing this:\n  {..degree u - 1} = {..<degree u}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>degree u - 1. monom (coeff h j) j) =\n    (\\<Sum>j<degree u. monom (coeff h j) j)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>degree u - 1. monom (coeff h j) j) =\n  (\\<Sum>j<degree u. monom (coeff h j) j)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>degree u - 1. monom (coeff h j) j) =\n  (\\<Sum>j<degree u. monom (coeff h j) j)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have \"... = (\\<Sum>j<degree u. monom (?f j) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<degree u. monom (coeff h j) j) =\n    (\\<Sum>j<degree u.\n        monom (((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ j) j)", "proof (rule sum.cong, rule+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<degree u} \\<Longrightarrow>\n       monom (coeff h x) x =\n       monom (((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ x) x", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<degree u} \\<Longrightarrow>\n       monom (coeff h x) x =\n       monom (((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ x) x", "assume i: \"j \\<in> {..<degree u}\""], ["proof (state)\nthis:\n  j \\<in> {..<degree u}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<degree u} \\<Longrightarrow>\n       monom (coeff h x) x =\n       monom (((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ x) x", "have \"(coeff h j) = ?f j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff h j = ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ j", "using rhs vec_of_list_coeffs_replicate_nth[OF i deg_le]"], ["proof (prove)\nusing this:\n  (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n  vec_of_list (coeffs h @ replicate (degree u - length (coeffs h)) 0) $ j =\n  coeff h j\n\ngoal (1 subgoal):\n 1. coeff h j = ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ j", "unfolding H"], ["proof (prove)\nusing this:\n  (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v\n  vec_of_list (coeffs h @ replicate (degree u - length (coeffs h)) 0) =\n  vec_of_list (coeffs h @ replicate (degree u - length (coeffs h)) 0)\n  vec_of_list (coeffs h @ replicate (degree u - length (coeffs h)) 0) $ j =\n  coeff h j\n\ngoal (1 subgoal):\n 1. coeff h j =\n    ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v\n     vec_of_list (coeffs h @ replicate (degree u - length (coeffs h)) 0)) $\n    j", "by presburger"], ["proof (state)\nthis:\n  coeff h j = ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<degree u} \\<Longrightarrow>\n       monom (coeff h x) x =\n       monom (((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ x) x", "thus \"monom (coeff h j) j = monom (?f j) j\""], ["proof (prove)\nusing this:\n  coeff h j = ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ j\n\ngoal (1 subgoal):\n 1. monom (coeff h j) j =\n    monom (((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ j) j", "by simp"], ["proof (state)\nthis:\n  monom (coeff h j) j =\n  monom (((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ j) j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j<degree u. monom (coeff h j) j) =\n  (\\<Sum>j<degree u.\n      monom (((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ j) j)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j<degree u. monom (coeff h j) j) =\n  (\\<Sum>j<degree u.\n      monom (((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ j) j)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have \"... = (\\<Sum>j<degree u. monom (row (transpose_mat ?B) j \\<bullet> H) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<degree u.\n        monom (((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ j) j) =\n    (\\<Sum>j<degree u.\n        monom (row (local.berlekamp_mat u)\\<^sup>T j \\<bullet> H) j)", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>j<degree u.\n      monom (((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ j) j) =\n  (\\<Sum>j<degree u.\n      monom (row (local.berlekamp_mat u)\\<^sup>T j \\<bullet> H) j)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j<degree u.\n      monom (((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ j) j) =\n  (\\<Sum>j<degree u.\n      monom (row (local.berlekamp_mat u)\\<^sup>T j \\<bullet> H) j)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have \"... = (\\<Sum>j<degree u. monom (\\<Sum>i = 0..<dim_vec H. ?B $$ (i,j) * H $ i) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<degree u.\n        monom (row (local.berlekamp_mat u)\\<^sup>T j \\<bullet> H) j) =\n    (\\<Sum>j<degree u.\n        monom\n         (\\<Sum>i = 0..<dim_vec H. local.berlekamp_mat u $$ (i, j) * H $ i)\n         j)", "proof (rule sum.cong, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<degree u} \\<Longrightarrow>\n       monom (row (local.berlekamp_mat u)\\<^sup>T x \\<bullet> H) x =\n       monom\n        (\\<Sum>i = 0..<dim_vec H. local.berlekamp_mat u $$ (i, x) * H $ i) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<degree u} \\<Longrightarrow>\n       monom (row (local.berlekamp_mat u)\\<^sup>T x \\<bullet> H) x =\n       monom\n        (\\<Sum>i = 0..<dim_vec H. local.berlekamp_mat u $$ (i, x) * H $ i) x", "assume x: \"x \\<in> {..<degree u}\""], ["proof (state)\nthis:\n  x \\<in> {..<degree u}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<degree u} \\<Longrightarrow>\n       monom (row (local.berlekamp_mat u)\\<^sup>T x \\<bullet> H) x =\n       monom\n        (\\<Sum>i = 0..<dim_vec H. local.berlekamp_mat u $$ (i, x) * H $ i) x", "show \"monom (row (transpose_mat ?B) x \\<bullet> H) x =\n      monom (\\<Sum>i = 0..<dim_vec H. ?B $$ (i, x) * H $ i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (row (local.berlekamp_mat u)\\<^sup>T x \\<bullet> H) x =\n    monom (\\<Sum>i = 0..<dim_vec H. local.berlekamp_mat u $$ (i, x) * H $ i)\n     x", "proof (unfold monom_eq_iff, rule row_transpose_scalar_prod_as_sum[OF _ dimv_h_dimr_B])"], ["proof (state)\ngoal (1 subgoal):\n 1. x < dim_col (local.berlekamp_mat u)", "show \"x < dim_col ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < dim_col (local.berlekamp_mat u)", "using x deg_le"], ["proof (prove)\nusing this:\n  x \\<in> {..<degree u}\n  degree h < degree u\n\ngoal (1 subgoal):\n 1. x < dim_col (local.berlekamp_mat u)", "by auto"], ["proof (state)\nthis:\n  x < dim_col (local.berlekamp_mat u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monom (row (local.berlekamp_mat u)\\<^sup>T x \\<bullet> H) x =\n  monom (\\<Sum>i = 0..<dim_vec H. local.berlekamp_mat u $$ (i, x) * H $ i) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j<degree u.\n      monom (row (local.berlekamp_mat u)\\<^sup>T j \\<bullet> H) j) =\n  (\\<Sum>j<degree u.\n      monom\n       (\\<Sum>i = 0..<dim_vec H. local.berlekamp_mat u $$ (i, j) * H $ i) j)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j<degree u.\n      monom (row (local.berlekamp_mat u)\\<^sup>T j \\<bullet> H) j) =\n  (\\<Sum>j<degree u.\n      monom\n       (\\<Sum>i = 0..<dim_vec H. local.berlekamp_mat u $$ (i, j) * H $ i) j)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have \"... = (\\<Sum>j<degree u. \\<Sum>i = 0..<dim_vec H. monom (?B $$ (i,j) * H $ i) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<degree u.\n        monom\n         (\\<Sum>i = 0..<dim_vec H. local.berlekamp_mat u $$ (i, j) * H $ i)\n         j) =\n    (\\<Sum>j<degree u.\n        \\<Sum>i = 0..<dim_vec H.\n           monom (local.berlekamp_mat u $$ (i, j) * H $ i) j)", "by (auto simp add: monom_sum)"], ["proof (state)\nthis:\n  (\\<Sum>j<degree u.\n      monom\n       (\\<Sum>i = 0..<dim_vec H. local.berlekamp_mat u $$ (i, j) * H $ i)\n       j) =\n  (\\<Sum>j<degree u.\n      \\<Sum>i = 0..<dim_vec H.\n         monom (local.berlekamp_mat u $$ (i, j) * H $ i) j)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j<degree u.\n      monom\n       (\\<Sum>i = 0..<dim_vec H. local.berlekamp_mat u $$ (i, j) * H $ i)\n       j) =\n  (\\<Sum>j<degree u.\n      \\<Sum>i = 0..<dim_vec H.\n         monom (local.berlekamp_mat u $$ (i, j) * H $ i) j)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have \"... = (\\<Sum>i = 0..<dim_vec H. \\<Sum>j<degree u. monom (?B $$ (i,j) * H $ i) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<degree u.\n        \\<Sum>i = 0..<dim_vec H.\n           monom (local.berlekamp_mat u $$ (i, j) * H $ i) j) =\n    (\\<Sum>i = 0..<dim_vec H.\n        \\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j) * H $ i) j)", "by (rule sum.swap)"], ["proof (state)\nthis:\n  (\\<Sum>j<degree u.\n      \\<Sum>i = 0..<dim_vec H.\n         monom (local.berlekamp_mat u $$ (i, j) * H $ i) j) =\n  (\\<Sum>i = 0..<dim_vec H.\n      \\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j) * H $ i) j)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j<degree u.\n      \\<Sum>i = 0..<dim_vec H.\n         monom (local.berlekamp_mat u $$ (i, j) * H $ i) j) =\n  (\\<Sum>i = 0..<dim_vec H.\n      \\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j) * H $ i) j)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have \"... = (\\<Sum>i = 0..<dim_vec H. \\<Sum>j<degree u.  monom (H $ i) 0 * monom (?B $$ (i,j)) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec H.\n        \\<Sum>j<degree u.\n           monom (local.berlekamp_mat u $$ (i, j) * H $ i) j) =\n    (\\<Sum>i = 0..<dim_vec H.\n        \\<Sum>j<degree u.\n           monom (H $ i) 0 * monom (local.berlekamp_mat u $$ (i, j)) j)", "proof (rule sum.cong, rule, rule sum.cong, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {0..<dim_vec H}; xa \\<in> {..<degree u}\\<rbrakk>\n       \\<Longrightarrow> monom (local.berlekamp_mat u $$ (x, xa) * H $ x)\n                          xa =\n                         monom (H $ x) 0 *\n                         monom (local.berlekamp_mat u $$ (x, xa)) xa", "fix x xa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {0..<dim_vec H}; xa \\<in> {..<degree u}\\<rbrakk>\n       \\<Longrightarrow> monom (local.berlekamp_mat u $$ (x, xa) * H $ x)\n                          xa =\n                         monom (H $ x) 0 *\n                         monom (local.berlekamp_mat u $$ (x, xa)) xa", "show \"monom (?B $$ (x, xa) * H $ x) xa = monom (H $ x) 0 * monom (?B $$ (x, xa)) xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (local.berlekamp_mat u $$ (x, xa) * H $ x) xa =\n    monom (H $ x) 0 * monom (local.berlekamp_mat u $$ (x, xa)) xa", "by (simp add: mult_monom)"], ["proof (state)\nthis:\n  monom (local.berlekamp_mat u $$ (x, xa) * H $ x) xa =\n  monom (H $ x) 0 * monom (local.berlekamp_mat u $$ (x, xa)) xa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H.\n      \\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j) * H $ i) j) =\n  (\\<Sum>i = 0..<dim_vec H.\n      \\<Sum>j<degree u.\n         monom (H $ i) 0 * monom (local.berlekamp_mat u $$ (i, j)) j)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H.\n      \\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j) * H $ i) j) =\n  (\\<Sum>i = 0..<dim_vec H.\n      \\<Sum>j<degree u.\n         monom (H $ i) 0 * monom (local.berlekamp_mat u $$ (i, j)) j)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have \"... = (\\<Sum>i = 0..<dim_vec H. (monom (H $ i) 0) * (\\<Sum>j<degree u. monom (?B $$ (i,j)) j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec H.\n        \\<Sum>j<degree u.\n           monom (H $ i) 0 * monom (local.berlekamp_mat u $$ (i, j)) j) =\n    (\\<Sum>i = 0..<dim_vec H.\n        monom (H $ i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))", "by (rule sum.cong, auto simp: sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H.\n      \\<Sum>j<degree u.\n         monom (H $ i) 0 * monom (local.berlekamp_mat u $$ (i, j)) j) =\n  (\\<Sum>i = 0..<dim_vec H.\n      monom (H $ i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H.\n      \\<Sum>j<degree u.\n         monom (H $ i) 0 * monom (local.berlekamp_mat u $$ (i, j)) j) =\n  (\\<Sum>i = 0..<dim_vec H.\n      monom (H $ i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have \"... = (\\<Sum>i = 0..<dim_vec H. (monom (H $ i) 0) * (monom 1 (CARD('a) * i) mod u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec H.\n        monom (H $ i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n    (\\<Sum>i = 0..<dim_vec H.\n        monom (H $ i) 0 * (monom 1 (CARD('a) * i) mod u))", "proof (rule sum.cong, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) 0 *\n       (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j) =\n       monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) 0 *\n       (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j) =\n       monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u)", "assume x: \"x \\<in> {0..<dim_vec H}\""], ["proof (state)\nthis:\n  x \\<in> {0..<dim_vec H}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) 0 *\n       (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j) =\n       monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u)", "have \"(\\<Sum>j<degree u. monom (?B $$ (x, j)) j) = (monom 1 (CARD('a) * x) mod u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j) =\n    monom 1 (CARD('a) * x) mod u", "proof (rule monom_card_pow_mod_sum_berlekamp[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. x < degree u", "show \"x < degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < degree u", "using x dimv_h_dimr_B"], ["proof (prove)\nusing this:\n  x \\<in> {0..<dim_vec H}\n  dim_vec H = dim_row (local.berlekamp_mat u)\n\ngoal (1 subgoal):\n 1. x < degree u", "by auto"], ["proof (state)\nthis:\n  x < degree u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j) =\n  monom 1 (CARD('a) * x) mod u\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) 0 *\n       (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j) =\n       monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u)", "thus \"monom (H $ x) 0 * (\\<Sum>j<degree u. monom (?B $$ (x, j)) j) =\n         monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u)\""], ["proof (prove)\nusing this:\n  (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j) =\n  monom 1 (CARD('a) * x) mod u\n\ngoal (1 subgoal):\n 1. monom (H $ x) 0 *\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j) =\n    monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u)", "by presburger"], ["proof (state)\nthis:\n  monom (H $ x) 0 *\n  (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j) =\n  monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H.\n      monom (H $ i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n  (\\<Sum>i = 0..<dim_vec H.\n      monom (H $ i) 0 * (monom 1 (CARD('a) * i) mod u))\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H.\n      monom (H $ i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n  (\\<Sum>i = 0..<dim_vec H.\n      monom (H $ i) 0 * (monom 1 (CARD('a) * i) mod u))\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have \"... =  (\\<Sum>i = 0..<dim_vec H. monom (H $ i) (CARD('a) * i) mod u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec H.\n        monom (H $ i) 0 * (monom 1 (CARD('a) * i) mod u)) =\n    (\\<Sum>i = 0..<dim_vec H. monom (H $ i) (CARD('a) * i) mod u)", "proof (rule sum.cong, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u) =\n       monom (H $ x) (CARD('a) * x) mod u", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u) =\n       monom (H $ x) (CARD('a) * x) mod u", "have h_rw: \"monom (H $ x) 0 mod u = monom (H $ x) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (H $ x) 0 mod u = monom (H $ x) 0", "by (metis deg_le degree_pCons_eq_if gr_implies_not_zero\n           linorder_neqE_nat mod_poly_less monom_0)"], ["proof (state)\nthis:\n  monom (H $ x) 0 mod u = monom (H $ x) 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u) =\n       monom (H $ x) (CARD('a) * x) mod u", "have \"monom (H $ x) (CARD('a) * x) = monom (H $ x) 0 * monom 1 (CARD('a) * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (H $ x) (CARD('a) * x) = monom (H $ x) 0 * monom 1 (CARD('a) * x)", "unfolding mult_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (H $ x) (CARD('a) * x) = monom (H $ x * 1) (0 + CARD('a) * x)", "by simp"], ["proof (state)\nthis:\n  monom (H $ x) (CARD('a) * x) = monom (H $ x) 0 * monom 1 (CARD('a) * x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u) =\n       monom (H $ x) (CARD('a) * x) mod u", "also"], ["proof (state)\nthis:\n  monom (H $ x) (CARD('a) * x) = monom (H $ x) 0 * monom 1 (CARD('a) * x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u) =\n       monom (H $ x) (CARD('a) * x) mod u", "have \"... = smult (H $ x) (monom 1 (CARD('a) * x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (H $ x) 0 * monom 1 (CARD('a) * x) =\n    Polynomial.smult (H $ x) (monom 1 (CARD('a) * x))", "by (simp add: monom_0)"], ["proof (state)\nthis:\n  monom (H $ x) 0 * monom 1 (CARD('a) * x) =\n  Polynomial.smult (H $ x) (monom 1 (CARD('a) * x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u) =\n       monom (H $ x) (CARD('a) * x) mod u", "also"], ["proof (state)\nthis:\n  monom (H $ x) 0 * monom 1 (CARD('a) * x) =\n  Polynomial.smult (H $ x) (monom 1 (CARD('a) * x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u) =\n       monom (H $ x) (CARD('a) * x) mod u", "have \"... mod u =  Polynomial.smult (H $ x) (monom 1 (CARD('a) * x) mod u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (H $ x) (monom 1 (CARD('a) * x)) mod u =\n    Polynomial.smult (H $ x) (monom 1 (CARD('a) * x) mod u)", "using mod_smult_left"], ["proof (prove)\nusing this:\n  Polynomial.smult ?a ?x mod ?y = Polynomial.smult ?a (?x mod ?y)\n\ngoal (1 subgoal):\n 1. Polynomial.smult (H $ x) (monom 1 (CARD('a) * x)) mod u =\n    Polynomial.smult (H $ x) (monom 1 (CARD('a) * x) mod u)", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult (H $ x) (monom 1 (CARD('a) * x)) mod u =\n  Polynomial.smult (H $ x) (monom 1 (CARD('a) * x) mod u)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u) =\n       monom (H $ x) (CARD('a) * x) mod u", "also"], ["proof (state)\nthis:\n  Polynomial.smult (H $ x) (monom 1 (CARD('a) * x)) mod u =\n  Polynomial.smult (H $ x) (monom 1 (CARD('a) * x) mod u)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u) =\n       monom (H $ x) (CARD('a) * x) mod u", "have \"... = monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (H $ x) (monom 1 (CARD('a) * x) mod u) =\n    monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u)", "by (simp add: monom_0)"], ["proof (state)\nthis:\n  Polynomial.smult (H $ x) (monom 1 (CARD('a) * x) mod u) =\n  monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u) =\n       monom (H $ x) (CARD('a) * x) mod u", "finally"], ["proof (chain)\npicking this:\n  monom (H $ x) (CARD('a) * x) mod u =\n  monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u)", "show \"monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u)\n        = monom (H $ x) (CARD('a) * x) mod u\""], ["proof (prove)\nusing this:\n  monom (H $ x) (CARD('a) * x) mod u =\n  monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u)\n\ngoal (1 subgoal):\n 1. monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u) =\n    monom (H $ x) (CARD('a) * x) mod u", ".."], ["proof (state)\nthis:\n  monom (H $ x) 0 * (monom 1 (CARD('a) * x) mod u) =\n  monom (H $ x) (CARD('a) * x) mod u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H.\n      monom (H $ i) 0 * (monom 1 (CARD('a) * i) mod u)) =\n  (\\<Sum>i = 0..<dim_vec H. monom (H $ i) (CARD('a) * i) mod u)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H.\n      monom (H $ i) 0 * (monom 1 (CARD('a) * i) mod u)) =\n  (\\<Sum>i = 0..<dim_vec H. monom (H $ i) (CARD('a) * i) mod u)\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have \"... = (\\<Sum>i = 0..<dim_vec H. monom (H $ i) (CARD('a) * i)) mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec H. monom (H $ i) (CARD('a) * i) mod u) =\n    (\\<Sum>i = 0..<dim_vec H. monom (H $ i) (CARD('a) * i)) mod u", "by (simp add: poly_mod_sum)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H. monom (H $ i) (CARD('a) * i) mod u) =\n  (\\<Sum>i = 0..<dim_vec H. monom (H $ i) (CARD('a) * i)) mod u\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H. monom (H $ i) (CARD('a) * i) mod u) =\n  (\\<Sum>i = 0..<dim_vec H. monom (H $ i) (CARD('a) * i)) mod u\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have \"... = (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec H. monom (H $ i) (CARD('a) * i)) mod u =\n    (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) mod u", "proof (rule arg_cong[of _ _ \"\\<lambda>x. x  mod u\"], rule sum.cong, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) (CARD('a) * x) = monom (coeff h x) (CARD('a) * x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) (CARD('a) * x) = monom (coeff h x) (CARD('a) * x)", "assume x: \"x \\<in> {0..<dim_vec H}\""], ["proof (state)\nthis:\n  x \\<in> {0..<dim_vec H}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) (CARD('a) * x) = monom (coeff h x) (CARD('a) * x)", "have \"H $ x = (coeff h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ x = coeff h x", "proof (unfold H, rule vec_of_list_coeffs_replicate_nth[OF _ deg_le])"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> {..<degree u}", "show \"x \\<in> {..<degree u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {..<degree u}", "using x"], ["proof (prove)\nusing this:\n  x \\<in> {0..<dim_vec H}\n\ngoal (1 subgoal):\n 1. x \\<in> {..<degree u}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {..<degree u}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  H $ x = coeff h x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec H} \\<Longrightarrow>\n       monom (H $ x) (CARD('a) * x) = monom (coeff h x) (CARD('a) * x)", "thus \"monom (H $ x) (CARD('a) * x) = monom (coeff h x) (CARD('a) * x)\""], ["proof (prove)\nusing this:\n  H $ x = coeff h x\n\ngoal (1 subgoal):\n 1. monom (H $ x) (CARD('a) * x) = monom (coeff h x) (CARD('a) * x)", "by simp"], ["proof (state)\nthis:\n  monom (H $ x) (CARD('a) * x) = monom (coeff h x) (CARD('a) * x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H. monom (H $ i) (CARD('a) * i)) mod u =\n  (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) mod u\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H. monom (H $ i) (CARD('a) * i)) mod u =\n  (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) mod u\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have \"... = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i)) mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) mod u =\n    (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i)) mod u", "proof (rule arg_cong[of _ _ \"\\<lambda>x. x mod u\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n    (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "let ?f=\"\\<lambda>i. monom (coeff h i) (CARD('a) * i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n    (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "have ss0: \"(\\<Sum>i = degree h + 1 ..< dim_vec H. ?f i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = degree h + 1..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n    0", "by (rule sum.neutral, simp add: coeff_eq_0)"], ["proof (state)\nthis:\n  (\\<Sum>i = degree h + 1..<dim_vec H. monom (coeff h i) (CARD('a) * i)) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n    (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "have set_rw: \"{0..< dim_vec H} = {0..degree h} \\<union> {degree h + 1 ..< dim_vec H}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<dim_vec H} = {0..degree h} \\<union> {degree h + 1..<dim_vec H}", "using degree_h_less_dim_H"], ["proof (prove)\nusing this:\n  degree h < dim_vec H\n\ngoal (1 subgoal):\n 1. {0..<dim_vec H} = {0..degree h} \\<union> {degree h + 1..<dim_vec H}", "by auto"], ["proof (state)\nthis:\n  {0..<dim_vec H} = {0..degree h} \\<union> {degree h + 1..<dim_vec H}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n    (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "have \"(\\<Sum>i = 0..<dim_vec H. ?f i) = (\\<Sum>i = 0..degree h. ?f i) + (\\<Sum>i = degree h + 1 ..< dim_vec H. ?f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n    (\\<Sum>i = 0..degree h. monom (coeff h i) (CARD('a) * i)) +\n    (\\<Sum>i = degree h + 1..<dim_vec H. monom (coeff h i) (CARD('a) * i))", "unfolding set_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{0..degree h} \\<union> {degree h + 1..<dim_vec H}.\n       monom (coeff h i) (CARD('a) * i)) =\n    (\\<Sum>i = 0..degree h. monom (coeff h i) (CARD('a) * i)) +\n    (\\<Sum>i = degree h + 1..<dim_vec H. monom (coeff h i) (CARD('a) * i))", "by (rule sum.union_disjoint, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n  (\\<Sum>i = 0..degree h. monom (coeff h i) (CARD('a) * i)) +\n  (\\<Sum>i = degree h + 1..<dim_vec H. monom (coeff h i) (CARD('a) * i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n    (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n  (\\<Sum>i = 0..degree h. monom (coeff h i) (CARD('a) * i)) +\n  (\\<Sum>i = degree h + 1..<dim_vec H. monom (coeff h i) (CARD('a) * i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n    (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "have \"... = (\\<Sum>i = 0..degree h. ?f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..degree h. monom (coeff h i) (CARD('a) * i)) +\n    (\\<Sum>i = degree h + 1..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n    (\\<Sum>i = 0..degree h. monom (coeff h i) (CARD('a) * i))", "unfolding ss0"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..degree h. monom (coeff h i) (CARD('a) * i)) + 0 =\n    (\\<Sum>i = 0..degree h. monom (coeff h i) (CARD('a) * i))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..degree h. monom (coeff h i) (CARD('a) * i)) +\n  (\\<Sum>i = degree h + 1..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n  (\\<Sum>i = 0..degree h. monom (coeff h i) (CARD('a) * i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n    (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n  (\\<Sum>i = 0..degree h. monom (coeff h i) (CARD('a) * i))", "show \"(\\<Sum>i = 0..<dim_vec H. ?f i) = (\\<Sum>i\\<le>degree h. ?f i)\""], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n  (\\<Sum>i = 0..degree h. monom (coeff h i) (CARD('a) * i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n    (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))", "by (simp add: atLeast0AtMost)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) =\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) mod u =\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i)) mod u\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec H. monom (coeff h i) (CARD('a) * i)) mod u =\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i)) mod u\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "have \"... = h^CARD('a) mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i)) mod u =\n    h ^ CARD('a) mod u", "using poly_power_card_as_sum_of_monoms"], ["proof (prove)\nusing this:\n  ?h ^ CARD('a) = (\\<Sum>i\\<le>degree ?h. monom (coeff ?h i) (CARD('a) * i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i)) mod u =\n    h ^ CARD('a) mod u", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i)) mod u =\n  h ^ CARD('a) mod u\n\ngoal (2 subgoals):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n 2. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<Longrightarrow>\n    [h ^ CARD('a) = h] (mod u)", "finally"], ["proof (chain)\npicking this:\n  h = h ^ CARD('a) mod u", "show ?lhs"], ["proof (prove)\nusing this:\n  h = h ^ CARD('a) mod u\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u)", "unfolding cong_def"], ["proof (prove)\nusing this:\n  h = h ^ CARD('a) mod u\n\ngoal (1 subgoal):\n 1. h ^ CARD('a) mod u = h mod u", "using deg_le"], ["proof (prove)\nusing this:\n  h = h ^ CARD('a) mod u\n  degree h < degree u\n\ngoal (1 subgoal):\n 1. h ^ CARD('a) mod u = h mod u", "by (simp add: mod_poly_less)"], ["proof (state)\nthis:\n  [h ^ CARD('a) = h] (mod u)\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "assume lhs: ?lhs"], ["proof (state)\nthis:\n  [h ^ CARD('a) = h] (mod u)\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "have deg_le': \"degree h \\<le> degree u - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree h \\<le> degree u - 1", "using deg_le"], ["proof (prove)\nusing this:\n  degree h < degree u\n\ngoal (1 subgoal):\n 1. degree h \\<le> degree u - 1", "by auto"], ["proof (state)\nthis:\n  degree h \\<le> degree u - 1\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "have set_rw: \"{..<degree u} = {..degree u -1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<degree u} = {..degree u - 1}", "using deg_le"], ["proof (prove)\nusing this:\n  degree h < degree u\n\ngoal (1 subgoal):\n 1. {..<degree u} = {..degree u - 1}", "by auto"], ["proof (state)\nthis:\n  {..<degree u} = {..degree u - 1}\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "hence \"(\\<Sum>i<degree u. monom (coeff h i) i) = (\\<Sum>i \\<le> degree u - 1. monom (coeff h i) i)\""], ["proof (prove)\nusing this:\n  {..<degree u} = {..degree u - 1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree u. monom (coeff h i) i) =\n    (\\<Sum>i\\<le>degree u - 1. monom (coeff h i) i)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<degree u. monom (coeff h i) i) =\n  (\\<Sum>i\\<le>degree u - 1. monom (coeff h i) i)\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree u. monom (coeff h i) i) =\n  (\\<Sum>i\\<le>degree u - 1. monom (coeff h i) i)\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "have \"... = (\\<Sum>i\\<le>degree h. monom (coeff h i) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree u - 1. monom (coeff h i) i) =\n    (\\<Sum>i\\<le>degree h. monom (coeff h i) i)", "unfolding poly_as_sum_of_monoms"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree u - 1. monom (coeff h i) i) = h", "using poly_as_sum_of_monoms' deg_le'"], ["proof (prove)\nusing this:\n  degree ?p \\<le> ?n \\<Longrightarrow>\n  (\\<Sum>i\\<le>?n. monom (coeff ?p i) i) = ?p\n  degree h \\<le> degree u - 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree u - 1. monom (coeff h i) i) = h", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree u - 1. monom (coeff h i) i) =\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) i)\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree u - 1. monom (coeff h i) i) =\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) i)\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "have \"... = (\\<Sum>i\\<le>degree h. monom (coeff h i) i) mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h. monom (coeff h i) i) =\n    (\\<Sum>i\\<le>degree h. monom (coeff h i) i) mod u", "by (simp add: deg_le mod_poly_less poly_as_sum_of_monoms)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) i) =\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) i) mod u\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) i) =\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) i) mod u\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "have \"... = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a)*i)) mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h. monom (coeff h i) i) mod u =\n    (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i)) mod u", "using lhs"], ["proof (prove)\nusing this:\n  [h ^ CARD('a) = h] (mod u)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h. monom (coeff h i) i) mod u =\n    (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i)) mod u", "unfolding cong_def poly_as_sum_of_monoms poly_power_card_as_sum_of_monoms"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i)) mod u = h mod u\n\ngoal (1 subgoal):\n 1. h mod u = (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i)) mod u", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) i) mod u =\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i)) mod u\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) i) mod u =\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i)) mod u\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "have \"... = (\\<Sum>i\\<le>degree h. monom (coeff h i) 0 * monom 1 (CARD('a)*i)) mod u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i)) mod u =\n    (\\<Sum>i\\<le>degree h. monom (coeff h i) 0 * monom 1 (CARD('a) * i)) mod\n    u", "by (rule arg_cong[of _ _ \"\\<lambda>x. x mod u\"], rule sum.cong, simp_all add: mult_monom)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i)) mod u =\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) 0 * monom 1 (CARD('a) * i)) mod u\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) (CARD('a) * i)) mod u =\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) 0 * monom 1 (CARD('a) * i)) mod u\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "have \"... = (\\<Sum>i\\<le>degree h. monom (coeff h i) 0 * monom 1 (CARD('a)*i) mod u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h. monom (coeff h i) 0 * monom 1 (CARD('a) * i)) mod\n    u =\n    (\\<Sum>i\\<le>degree h.\n        monom (coeff h i) 0 * monom 1 (CARD('a) * i) mod u)", "by (simp add: poly_mod_sum)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) 0 * monom 1 (CARD('a) * i)) mod\n  u =\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) 0 * monom 1 (CARD('a) * i) mod u)\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) 0 * monom 1 (CARD('a) * i)) mod\n  u =\n  (\\<Sum>i\\<le>degree h. monom (coeff h i) 0 * monom 1 (CARD('a) * i) mod u)\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "have \"... = (\\<Sum>i\\<le>degree h. monom (coeff h i) 0 * (monom 1 (CARD('a)*i) mod u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h.\n        monom (coeff h i) 0 * monom 1 (CARD('a) * i) mod u) =\n    (\\<Sum>i\\<le>degree h.\n        monom (coeff h i) 0 * (monom 1 (CARD('a) * i) mod u))", "proof (rule sum.cong, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree h} \\<Longrightarrow>\n       monom (coeff h x) 0 * monom 1 (CARD('a) * x) mod u =\n       monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree h} \\<Longrightarrow>\n       monom (coeff h x) 0 * monom 1 (CARD('a) * x) mod u =\n       monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)", "assume x: \"x \\<in> {..degree h}\""], ["proof (state)\nthis:\n  x \\<in> {..degree h}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree h} \\<Longrightarrow>\n       monom (coeff h x) 0 * monom 1 (CARD('a) * x) mod u =\n       monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)", "have h_rw: \"monom (coeff h x) 0 mod u = monom (coeff h x) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (coeff h x) 0 mod u = monom (coeff h x) 0", "by (metis deg_le degree_pCons_eq_if gr_implies_not_zero\n           linorder_neqE_nat mod_poly_less monom_0)"], ["proof (state)\nthis:\n  monom (coeff h x) 0 mod u = monom (coeff h x) 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree h} \\<Longrightarrow>\n       monom (coeff h x) 0 * monom 1 (CARD('a) * x) mod u =\n       monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)", "have \"monom (coeff h x) 0 * monom 1 (CARD('a) * x) = smult (coeff h x) (monom 1 (CARD('a) * x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (coeff h x) 0 * monom 1 (CARD('a) * x) =\n    Polynomial.smult (coeff h x) (monom 1 (CARD('a) * x))", "by (simp add: monom_0)"], ["proof (state)\nthis:\n  monom (coeff h x) 0 * monom 1 (CARD('a) * x) =\n  Polynomial.smult (coeff h x) (monom 1 (CARD('a) * x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree h} \\<Longrightarrow>\n       monom (coeff h x) 0 * monom 1 (CARD('a) * x) mod u =\n       monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)", "also"], ["proof (state)\nthis:\n  monom (coeff h x) 0 * monom 1 (CARD('a) * x) =\n  Polynomial.smult (coeff h x) (monom 1 (CARD('a) * x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree h} \\<Longrightarrow>\n       monom (coeff h x) 0 * monom 1 (CARD('a) * x) mod u =\n       monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)", "have \"... mod u =  Polynomial.smult (coeff h x) (monom 1 (CARD('a) * x) mod u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (coeff h x) (monom 1 (CARD('a) * x)) mod u =\n    Polynomial.smult (coeff h x) (monom 1 (CARD('a) * x) mod u)", "using mod_smult_left"], ["proof (prove)\nusing this:\n  Polynomial.smult ?a ?x mod ?y = Polynomial.smult ?a (?x mod ?y)\n\ngoal (1 subgoal):\n 1. Polynomial.smult (coeff h x) (monom 1 (CARD('a) * x)) mod u =\n    Polynomial.smult (coeff h x) (monom 1 (CARD('a) * x) mod u)", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult (coeff h x) (monom 1 (CARD('a) * x)) mod u =\n  Polynomial.smult (coeff h x) (monom 1 (CARD('a) * x) mod u)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree h} \\<Longrightarrow>\n       monom (coeff h x) 0 * monom 1 (CARD('a) * x) mod u =\n       monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)", "also"], ["proof (state)\nthis:\n  Polynomial.smult (coeff h x) (monom 1 (CARD('a) * x)) mod u =\n  Polynomial.smult (coeff h x) (monom 1 (CARD('a) * x) mod u)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree h} \\<Longrightarrow>\n       monom (coeff h x) 0 * monom 1 (CARD('a) * x) mod u =\n       monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)", "have \"... = monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (coeff h x) (monom 1 (CARD('a) * x) mod u) =\n    monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)", "by (simp add: monom_0)"], ["proof (state)\nthis:\n  Polynomial.smult (coeff h x) (monom 1 (CARD('a) * x) mod u) =\n  monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree h} \\<Longrightarrow>\n       monom (coeff h x) 0 * monom 1 (CARD('a) * x) mod u =\n       monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)", "finally"], ["proof (chain)\npicking this:\n  monom (coeff h x) 0 * monom 1 (CARD('a) * x) mod u =\n  monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)", "show \"monom (coeff h x) 0 * monom 1 (CARD('a) * x) mod u\n      = monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)\""], ["proof (prove)\nusing this:\n  monom (coeff h x) 0 * monom 1 (CARD('a) * x) mod u =\n  monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)\n\ngoal (1 subgoal):\n 1. monom (coeff h x) 0 * monom 1 (CARD('a) * x) mod u =\n    monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)", "."], ["proof (state)\nthis:\n  monom (coeff h x) 0 * monom 1 (CARD('a) * x) mod u =\n  monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h.\n      monom (coeff h i) 0 * monom 1 (CARD('a) * i) mod u) =\n  (\\<Sum>i\\<le>degree h.\n      monom (coeff h i) 0 * (monom 1 (CARD('a) * i) mod u))\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h.\n      monom (coeff h i) 0 * monom 1 (CARD('a) * i) mod u) =\n  (\\<Sum>i\\<le>degree h.\n      monom (coeff h i) 0 * (monom 1 (CARD('a) * i) mod u))\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "have \"... = (\\<Sum>i\\<le>degree h. monom (coeff h i) 0 * (\\<Sum>j<degree u. monom (?B $$ (i, j)) j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h.\n        monom (coeff h i) 0 * (monom 1 (CARD('a) * i) mod u)) =\n    (\\<Sum>i\\<le>degree h.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))", "proof (rule sum.cong, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree h} \\<Longrightarrow>\n       monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u) =\n       monom (coeff h x) 0 *\n       (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree h} \\<Longrightarrow>\n       monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u) =\n       monom (coeff h x) 0 *\n       (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j)", "assume x: \"x \\<in> {..degree h}\""], ["proof (state)\nthis:\n  x \\<in> {..degree h}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree h} \\<Longrightarrow>\n       monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u) =\n       monom (coeff h x) 0 *\n       (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j)", "have \"(monom 1 (CARD('a) * x) mod u) = (\\<Sum>j<degree u. monom (?B $$ (x, j)) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 1 (CARD('a) * x) mod u =\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j)", "proof (rule monom_card_pow_mod_sum_berlekamp)"], ["proof (state)\ngoal (1 subgoal):\n 1. x < degree u", "show \" x < degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < degree u", "using x deg_le"], ["proof (prove)\nusing this:\n  x \\<in> {..degree h}\n  degree h < degree u\n\ngoal (1 subgoal):\n 1. x < degree u", "by auto"], ["proof (state)\nthis:\n  x < degree u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monom 1 (CARD('a) * x) mod u =\n  (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..degree h} \\<Longrightarrow>\n       monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u) =\n       monom (coeff h x) 0 *\n       (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j)", "thus \"monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u) =\n         monom (coeff h x) 0 * (\\<Sum>j<degree u. monom (?B $$ (x, j)) j)\""], ["proof (prove)\nusing this:\n  monom 1 (CARD('a) * x) mod u =\n  (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j)\n\ngoal (1 subgoal):\n 1. monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u) =\n    monom (coeff h x) 0 *\n    (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j)", "by simp"], ["proof (state)\nthis:\n  monom (coeff h x) 0 * (monom 1 (CARD('a) * x) mod u) =\n  monom (coeff h x) 0 *\n  (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (x, j)) j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h.\n      monom (coeff h i) 0 * (monom 1 (CARD('a) * i) mod u)) =\n  (\\<Sum>i\\<le>degree h.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h.\n      monom (coeff h i) 0 * (monom 1 (CARD('a) * i) mod u)) =\n  (\\<Sum>i\\<le>degree h.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "have \"... = (\\<Sum>i<degree u. monom (coeff h i) 0 * (\\<Sum>j<degree u. monom (?B $$ (i, j)) j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n    (\\<Sum>i<degree u.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n    (\\<Sum>i<degree u.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))", "let ?f=\"\\<lambda>i. monom (coeff h i) 0 * (\\<Sum>j<degree u. monom (?B $$ (i, j)) j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n    (\\<Sum>i<degree u.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))", "have ss0: \"(\\<Sum>i=degree h+1 ..< degree u. ?f i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = degree h + 1..<degree u.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n    0", "by (rule sum.neutral, simp add: coeff_eq_0)"], ["proof (state)\nthis:\n  (\\<Sum>i = degree h + 1..<degree u.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n    (\\<Sum>i<degree u.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))", "have set_rw: \"{0..<degree u} = {0..degree h} \\<union> {degree h+1..<degree u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<degree u} = {0..degree h} \\<union> {degree h + 1..<degree u}", "using deg_le"], ["proof (prove)\nusing this:\n  degree h < degree u\n\ngoal (1 subgoal):\n 1. {0..<degree u} = {0..degree h} \\<union> {degree h + 1..<degree u}", "by auto"], ["proof (state)\nthis:\n  {0..<degree u} = {0..degree h} \\<union> {degree h + 1..<degree u}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n    (\\<Sum>i<degree u.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))", "have \"(\\<Sum>i=0..<degree u. ?f i) = (\\<Sum>i=0..degree h. ?f i) + (\\<Sum>i=degree h+1 ..< degree u. ?f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<degree u.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n    (\\<Sum>i = 0..degree h.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) +\n    (\\<Sum>i = degree h + 1..<degree u.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))", "unfolding set_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{0..degree h} \\<union> {degree h + 1..<degree u}.\n       monom (coeff h i) 0 *\n       (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n    (\\<Sum>i = 0..degree h.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) +\n    (\\<Sum>i = degree h + 1..<degree u.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))", "by (rule sum.union_disjoint, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<degree u.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n  (\\<Sum>i = 0..degree h.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) +\n  (\\<Sum>i = degree h + 1..<degree u.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n    (\\<Sum>i<degree u.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<degree u.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n  (\\<Sum>i = 0..degree h.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) +\n  (\\<Sum>i = degree h + 1..<degree u.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n    (\\<Sum>i<degree u.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))", "have \"... = (\\<Sum>i=0..degree h. ?f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..degree h.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) +\n    (\\<Sum>i = degree h + 1..<degree u.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n    (\\<Sum>i = 0..degree h.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))", "using ss0"], ["proof (prove)\nusing this:\n  (\\<Sum>i = degree h + 1..<degree u.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..degree h.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) +\n    (\\<Sum>i = degree h + 1..<degree u.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n    (\\<Sum>i = 0..degree h.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..degree h.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) +\n  (\\<Sum>i = degree h + 1..<degree u.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n  (\\<Sum>i = 0..degree h.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n    (\\<Sum>i<degree u.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i = 0..<degree u.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n  (\\<Sum>i = 0..degree h.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<degree u.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n  (\\<Sum>i = 0..degree h.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree h.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n    (\\<Sum>i<degree u.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))", "by (simp add: atLeast0AtMost atLeast0LessThan)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n  (\\<Sum>i<degree u.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n  (\\<Sum>i<degree u.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree h.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n  (\\<Sum>i<degree u.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j))\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "have \"... = (\\<Sum>i<degree u. (\\<Sum>j<degree u. monom (coeff h i) 0 * monom (?B $$ (i, j)) j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree u.\n        monom (coeff h i) 0 *\n        (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n    (\\<Sum>i<degree u.\n        \\<Sum>j<degree u.\n           monom (coeff h i) 0 * monom (local.berlekamp_mat u $$ (i, j)) j)", "by (simp add: sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree u.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n  (\\<Sum>i<degree u.\n      \\<Sum>j<degree u.\n         monom (coeff h i) 0 * monom (local.berlekamp_mat u $$ (i, j)) j)\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree u.\n      monom (coeff h i) 0 *\n      (\\<Sum>j<degree u. monom (local.berlekamp_mat u $$ (i, j)) j)) =\n  (\\<Sum>i<degree u.\n      \\<Sum>j<degree u.\n         monom (coeff h i) 0 * monom (local.berlekamp_mat u $$ (i, j)) j)\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "have \"... = (\\<Sum>i<degree u. (\\<Sum>j<degree u. monom (coeff h i * ?B $$ (i, j)) j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree u.\n        \\<Sum>j<degree u.\n           monom (coeff h i) 0 *\n           monom (local.berlekamp_mat u $$ (i, j)) j) =\n    (\\<Sum>i<degree u.\n        \\<Sum>j<degree u.\n           monom (coeff h i * local.berlekamp_mat u $$ (i, j)) j)", "by (simp add: mult_monom)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree u.\n      \\<Sum>j<degree u.\n         monom (coeff h i) 0 * monom (local.berlekamp_mat u $$ (i, j)) j) =\n  (\\<Sum>i<degree u.\n      \\<Sum>j<degree u.\n         monom (coeff h i * local.berlekamp_mat u $$ (i, j)) j)\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree u.\n      \\<Sum>j<degree u.\n         monom (coeff h i) 0 * monom (local.berlekamp_mat u $$ (i, j)) j) =\n  (\\<Sum>i<degree u.\n      \\<Sum>j<degree u.\n         monom (coeff h i * local.berlekamp_mat u $$ (i, j)) j)\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "have \"... = (\\<Sum>j<degree u. (\\<Sum>i<degree u. monom (coeff h i * ?B $$ (i, j)) j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree u.\n        \\<Sum>j<degree u.\n           monom (coeff h i * local.berlekamp_mat u $$ (i, j)) j) =\n    (\\<Sum>j<degree u.\n        \\<Sum>i<degree u.\n           monom (coeff h i * local.berlekamp_mat u $$ (i, j)) j)", "using sum.swap"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>?A. sum (?g i) ?B) = (\\<Sum>j\\<in>?B. \\<Sum>i\\<in>?A. ?g i j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree u.\n        \\<Sum>j<degree u.\n           monom (coeff h i * local.berlekamp_mat u $$ (i, j)) j) =\n    (\\<Sum>j<degree u.\n        \\<Sum>i<degree u.\n           monom (coeff h i * local.berlekamp_mat u $$ (i, j)) j)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<degree u.\n      \\<Sum>j<degree u.\n         monom (coeff h i * local.berlekamp_mat u $$ (i, j)) j) =\n  (\\<Sum>j<degree u.\n      \\<Sum>i<degree u.\n         monom (coeff h i * local.berlekamp_mat u $$ (i, j)) j)\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree u.\n      \\<Sum>j<degree u.\n         monom (coeff h i * local.berlekamp_mat u $$ (i, j)) j) =\n  (\\<Sum>j<degree u.\n      \\<Sum>i<degree u.\n         monom (coeff h i * local.berlekamp_mat u $$ (i, j)) j)\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "have \"... = (\\<Sum>j<degree u. monom (\\<Sum>i<degree u.  (coeff h i * ?B $$ (i, j))) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<degree u.\n        \\<Sum>i<degree u.\n           monom (coeff h i * local.berlekamp_mat u $$ (i, j)) j) =\n    (\\<Sum>j<degree u.\n        monom\n         (\\<Sum>i<degree u. coeff h i * local.berlekamp_mat u $$ (i, j)) j)", "by (simp add: monom_sum)"], ["proof (state)\nthis:\n  (\\<Sum>j<degree u.\n      \\<Sum>i<degree u.\n         monom (coeff h i * local.berlekamp_mat u $$ (i, j)) j) =\n  (\\<Sum>j<degree u.\n      monom (\\<Sum>i<degree u. coeff h i * local.berlekamp_mat u $$ (i, j))\n       j)\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i<degree u. monom (coeff h i) i) =\n  (\\<Sum>j<degree u.\n      monom (\\<Sum>i<degree u. coeff h i * local.berlekamp_mat u $$ (i, j))\n       j)", "have ss_rw: \"(\\<Sum>i<degree u. monom (coeff h i) i)\n    = (\\<Sum>j<degree u. monom (\\<Sum>i<degree u. coeff h i * ?B $$ (i, j)) j)\""], ["proof (prove)\nusing this:\n  (\\<Sum>i<degree u. monom (coeff h i) i) =\n  (\\<Sum>j<degree u.\n      monom (\\<Sum>i<degree u. coeff h i * local.berlekamp_mat u $$ (i, j))\n       j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree u. monom (coeff h i) i) =\n    (\\<Sum>j<degree u.\n        monom\n         (\\<Sum>i<degree u. coeff h i * local.berlekamp_mat u $$ (i, j)) j)", "."], ["proof (state)\nthis:\n  (\\<Sum>i<degree u. monom (coeff h i) i) =\n  (\\<Sum>j<degree u.\n      monom (\\<Sum>i<degree u. coeff h i * local.berlekamp_mat u $$ (i, j))\n       j)\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "have coeff_eq_sum: \"\\<forall>i. i < degree u \\<longrightarrow> coeff h i = (\\<Sum>j<degree u. coeff h j * ?B $$ (j, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<degree u.\n       coeff h i =\n       (\\<Sum>j<degree u. coeff h j * local.berlekamp_mat u $$ (j, i))", "using poly_as_sum_eq_monoms[OF ss_rw]"], ["proof (prove)\nusing this:\n  ?a < degree u \\<Longrightarrow>\n  coeff h ?a =\n  (\\<Sum>i<degree u. coeff h i * local.berlekamp_mat u $$ (i, ?a))\n\ngoal (1 subgoal):\n 1. \\<forall>i<degree u.\n       coeff h i =\n       (\\<Sum>j<degree u. coeff h j * local.berlekamp_mat u $$ (j, i))", "by fast"], ["proof (state)\nthis:\n  \\<forall>i<degree u.\n     coeff h i =\n     (\\<Sum>j<degree u. coeff h j * local.berlekamp_mat u $$ (j, i))\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "have coeff_eq_sum': \"\\<forall>i. i < degree u \\<longrightarrow> H $ i = (\\<Sum>j<degree u. H $ j * ?B $$ (j, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<degree u.\n       H $ i = (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))", "proof (rule+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < degree u \\<Longrightarrow>\n       H $ i = (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < degree u \\<Longrightarrow>\n       H $ i = (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))", "assume i: \"i < degree u\""], ["proof (state)\nthis:\n  i < degree u\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < degree u \\<Longrightarrow>\n       H $ i = (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))", "have \"H $ i = coeff h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i = coeff h i", "by (simp add: H deg_le i vec_of_list_coeffs_replicate_nth)"], ["proof (state)\nthis:\n  H $ i = coeff h i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < degree u \\<Longrightarrow>\n       H $ i = (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))", "also"], ["proof (state)\nthis:\n  H $ i = coeff h i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < degree u \\<Longrightarrow>\n       H $ i = (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))", "have \"... = (\\<Sum>j<degree u. coeff h j * ?B $$ (j, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff h i =\n    (\\<Sum>j<degree u. coeff h j * local.berlekamp_mat u $$ (j, i))", "using coeff_eq_sum i"], ["proof (prove)\nusing this:\n  \\<forall>i<degree u.\n     coeff h i =\n     (\\<Sum>j<degree u. coeff h j * local.berlekamp_mat u $$ (j, i))\n  i < degree u\n\ngoal (1 subgoal):\n 1. coeff h i =\n    (\\<Sum>j<degree u. coeff h j * local.berlekamp_mat u $$ (j, i))", "by blast"], ["proof (state)\nthis:\n  coeff h i =\n  (\\<Sum>j<degree u. coeff h j * local.berlekamp_mat u $$ (j, i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < degree u \\<Longrightarrow>\n       H $ i = (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))", "also"], ["proof (state)\nthis:\n  coeff h i =\n  (\\<Sum>j<degree u. coeff h j * local.berlekamp_mat u $$ (j, i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < degree u \\<Longrightarrow>\n       H $ i = (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))", "have \"... = (\\<Sum>j<degree u. H $ j * ?B $$ (j, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<degree u. coeff h j * local.berlekamp_mat u $$ (j, i)) =\n    (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))", "by (rule sum.cong, auto simp add: H deg_le vec_of_list_coeffs_replicate_nth)"], ["proof (state)\nthis:\n  (\\<Sum>j<degree u. coeff h j * local.berlekamp_mat u $$ (j, i)) =\n  (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < degree u \\<Longrightarrow>\n       H $ i = (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))", "finally"], ["proof (chain)\npicking this:\n  H $ i = (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))", "show \"H $ i = (\\<Sum>j<degree u. H $ j * ?B $$ (j, i))\""], ["proof (prove)\nusing this:\n  H $ i = (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))\n\ngoal (1 subgoal):\n 1. H $ i = (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))", "."], ["proof (state)\nthis:\n  H $ i = (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<degree u.\n     H $ i = (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))\n\ngoal (1 subgoal):\n 1. [h ^ CARD('a) = h] (mod u) \\<Longrightarrow>\n    (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "show \"(transpose_mat (?B)) *\\<^sub>v H = H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H", "proof (rule eq_vecI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec H \\<Longrightarrow>\n       ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i = H $ i\n 2. dim_vec ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) = dim_vec H", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec H \\<Longrightarrow>\n       ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i = H $ i\n 2. dim_vec ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) = dim_vec H", "show \"dim_vec (transpose_mat ?B *\\<^sub>v H) = dim_vec (H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) = dim_vec H", "by auto"], ["proof (state)\nthis:\n  dim_vec ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) = dim_vec H\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec H \\<Longrightarrow>\n       ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i = H $ i", "assume i: \"i < dim_vec (H)\""], ["proof (state)\nthis:\n  i < dim_vec H\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec H \\<Longrightarrow>\n       ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i = H $ i", "have \"(transpose_mat ?B *\\<^sub>v H) $ i = row (transpose_mat ?B) i \\<bullet> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i =\n    row (local.berlekamp_mat u)\\<^sup>T i \\<bullet> H", "using i"], ["proof (prove)\nusing this:\n  i < dim_vec H\n\ngoal (1 subgoal):\n 1. ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i =\n    row (local.berlekamp_mat u)\\<^sup>T i \\<bullet> H", "by simp"], ["proof (state)\nthis:\n  ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i =\n  row (local.berlekamp_mat u)\\<^sup>T i \\<bullet> H\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec H \\<Longrightarrow>\n       ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i = H $ i", "also"], ["proof (state)\nthis:\n  ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i =\n  row (local.berlekamp_mat u)\\<^sup>T i \\<bullet> H\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec H \\<Longrightarrow>\n       ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i = H $ i", "have \"... = (\\<Sum>j = 0..<dim_vec H. ?B $$ (j, i) * H $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (local.berlekamp_mat u)\\<^sup>T i \\<bullet> H =\n    (\\<Sum>j = 0..<dim_vec H. local.berlekamp_mat u $$ (j, i) * H $ j)", "proof (rule row_transpose_scalar_prod_as_sum)"], ["proof (state)\ngoal (2 subgoals):\n 1. i < dim_col (local.berlekamp_mat u)\n 2. dim_vec H = dim_row (local.berlekamp_mat u)", "show \"i < dim_col ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_col (local.berlekamp_mat u)", "using i"], ["proof (prove)\nusing this:\n  i < dim_vec H\n\ngoal (1 subgoal):\n 1. i < dim_col (local.berlekamp_mat u)", "by simp"], ["proof (state)\nthis:\n  i < dim_col (local.berlekamp_mat u)\n\ngoal (1 subgoal):\n 1. dim_vec H = dim_row (local.berlekamp_mat u)", "show \"dim_vec H = dim_row ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec H = dim_row (local.berlekamp_mat u)", "by simp"], ["proof (state)\nthis:\n  dim_vec H = dim_row (local.berlekamp_mat u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row (local.berlekamp_mat u)\\<^sup>T i \\<bullet> H =\n  (\\<Sum>j = 0..<dim_vec H. local.berlekamp_mat u $$ (j, i) * H $ j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec H \\<Longrightarrow>\n       ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i = H $ i", "also"], ["proof (state)\nthis:\n  row (local.berlekamp_mat u)\\<^sup>T i \\<bullet> H =\n  (\\<Sum>j = 0..<dim_vec H. local.berlekamp_mat u $$ (j, i) * H $ j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec H \\<Longrightarrow>\n       ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i = H $ i", "have \"... = (\\<Sum>j<degree u. H $ j * ?B $$ (j, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_vec H. local.berlekamp_mat u $$ (j, i) * H $ j) =\n    (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_vec H. local.berlekamp_mat u $$ (j, i) * H $ j) =\n  (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec H \\<Longrightarrow>\n       ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i = H $ i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_vec H. local.berlekamp_mat u $$ (j, i) * H $ j) =\n  (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec H \\<Longrightarrow>\n       ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i = H $ i", "have \"... = H $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i)) = H $ i", "using coeff_eq_sum'[rule_format, symmetric, of i] i"], ["proof (prove)\nusing this:\n  i < degree u \\<Longrightarrow>\n  (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i)) = H $ i\n  i < dim_vec H\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i)) = H $ i", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j<degree u. H $ j * local.berlekamp_mat u $$ (j, i)) = H $ i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec H \\<Longrightarrow>\n       ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i = H $ i", "finally"], ["proof (chain)\npicking this:\n  ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i = H $ i", "show \"(transpose_mat ?B *\\<^sub>v H) $ i = H $ i\""], ["proof (prove)\nusing this:\n  ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i = H $ i\n\ngoal (1 subgoal):\n 1. ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i = H $ i", "."], ["proof (state)\nthis:\n  ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H) $ i = H $ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [h ^ CARD('a) = h] (mod u) =\n  ((local.berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context\nassumes \"SORT_CONSTRAINT('a::prime_card)\"\nbegin"], ["", "lemma exists_s_factor_dvd_h_s:\nfixes fi::\"'a mod_ring poly\"\nassumes finite_P: \"finite P\"\n      and f_desc_square_free: \"f = (\\<Prod>a\\<in>P. a)\"\n      and P: \"P \\<subseteq> {q. irreducible q \\<and> monic q}\"\n      and fi_P: \"fi \\<in> P\"\n      and h: \"h \\<in> {v. [v^(CARD('a)) = v] (mod f)}\"\n      shows \"\\<exists>s. fi dvd (h - [:s:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. fi dvd h - [:s:]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s. fi dvd h - [:s:]", "let ?p = \"CARD('a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s. fi dvd h - [:s:]", "have f_dvd_hqh: \"f dvd (h^?p - h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f dvd h ^ CARD('a) - h", "using h"], ["proof (prove)\nusing this:\n  h \\<in> {v. [v ^ CARD('a) = v] (mod f)}\n\ngoal (1 subgoal):\n 1. f dvd h ^ CARD('a) - h", "unfolding cong_def"], ["proof (prove)\nusing this:\n  h \\<in> {v. v ^ CARD('a) mod f = v mod f}\n\ngoal (1 subgoal):\n 1. f dvd h ^ CARD('a) - h", "using mod_eq_dvd_iff_poly"], ["proof (prove)\nusing this:\n  h \\<in> {v. v ^ CARD('a) mod f = v mod f}\n  (?x mod ?n = ?y mod ?n) = (?n dvd ?x - ?y)\n\ngoal (1 subgoal):\n 1. f dvd h ^ CARD('a) - h", "by blast"], ["proof (state)\nthis:\n  f dvd h ^ CARD('a) - h\n\ngoal (1 subgoal):\n 1. \\<exists>s. fi dvd h - [:s:]", "also"], ["proof (state)\nthis:\n  f dvd h ^ CARD('a) - h\n\ngoal (1 subgoal):\n 1. \\<exists>s. fi dvd h - [:s:]", "have hq_h_rw: \"... = prod (\\<lambda>c. h - [:c:]) (UNIV::'a mod_ring set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h ^ CARD('a) - h = (\\<Prod>c\\<in>UNIV. h - [:c:])", "by (rule poly_identity_mod_p)"], ["proof (state)\nthis:\n  h ^ CARD('a) - h = (\\<Prod>c\\<in>UNIV. h - [:c:])\n\ngoal (1 subgoal):\n 1. \\<exists>s. fi dvd h - [:s:]", "finally"], ["proof (chain)\npicking this:\n  f dvd (\\<Prod>c\\<in>UNIV. h - [:c:])", "have f_dvd_hc: \"f dvd prod (\\<lambda>c. h - [:c:]) (UNIV::'a mod_ring set)\""], ["proof (prove)\nusing this:\n  f dvd (\\<Prod>c\\<in>UNIV. h - [:c:])\n\ngoal (1 subgoal):\n 1. f dvd (\\<Prod>c\\<in>UNIV. h - [:c:])", "by simp"], ["proof (state)\nthis:\n  f dvd (\\<Prod>c\\<in>UNIV. h - [:c:])\n\ngoal (1 subgoal):\n 1. \\<exists>s. fi dvd h - [:s:]", "have \"fi dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fi dvd f", "using f_desc_square_free fi_P"], ["proof (prove)\nusing this:\n  f = \\<Prod>P\n  fi \\<in> P\n\ngoal (1 subgoal):\n 1. fi dvd f", "using dvd_prod_eqI finite_P"], ["proof (prove)\nusing this:\n  f = \\<Prod>P\n  fi \\<in> P\n  \\<lbrakk>finite ?A; ?a \\<in> ?A; ?b = ?f ?a\\<rbrakk>\n  \\<Longrightarrow> ?b dvd prod ?f ?A\n  finite P\n\ngoal (1 subgoal):\n 1. fi dvd f", "by blast"], ["proof (state)\nthis:\n  fi dvd f\n\ngoal (1 subgoal):\n 1. \\<exists>s. fi dvd h - [:s:]", "hence \"fi dvd (h^?p - h)\""], ["proof (prove)\nusing this:\n  fi dvd f\n\ngoal (1 subgoal):\n 1. fi dvd h ^ CARD('a) - h", "using dvd_trans f_dvd_hqh"], ["proof (prove)\nusing this:\n  fi dvd f\n  \\<lbrakk>?a dvd ?b; ?b dvd ?c\\<rbrakk> \\<Longrightarrow> ?a dvd ?c\n  f dvd h ^ CARD('a) - h\n\ngoal (1 subgoal):\n 1. fi dvd h ^ CARD('a) - h", "by auto"], ["proof (state)\nthis:\n  fi dvd h ^ CARD('a) - h\n\ngoal (1 subgoal):\n 1. \\<exists>s. fi dvd h - [:s:]", "also"], ["proof (state)\nthis:\n  fi dvd h ^ CARD('a) - h\n\ngoal (1 subgoal):\n 1. \\<exists>s. fi dvd h - [:s:]", "have \"... = prod (\\<lambda>c. h - [:c:]) (UNIV::'a mod_ring set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h ^ CARD('a) - h = (\\<Prod>c\\<in>UNIV. h - [:c:])", "unfolding hq_h_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>c\\<in>UNIV. h - [:c:]) = (\\<Prod>c\\<in>UNIV. h - [:c:])", "by simp"], ["proof (state)\nthis:\n  h ^ CARD('a) - h = (\\<Prod>c\\<in>UNIV. h - [:c:])\n\ngoal (1 subgoal):\n 1. \\<exists>s. fi dvd h - [:s:]", "finally"], ["proof (chain)\npicking this:\n  fi dvd (\\<Prod>c\\<in>UNIV. h - [:c:])", "have fi_dvd_prod_hc: \"fi dvd prod (\\<lambda>c. h - [:c:]) (UNIV::'a mod_ring set)\""], ["proof (prove)\nusing this:\n  fi dvd (\\<Prod>c\\<in>UNIV. h - [:c:])\n\ngoal (1 subgoal):\n 1. fi dvd (\\<Prod>c\\<in>UNIV. h - [:c:])", "."], ["proof (state)\nthis:\n  fi dvd (\\<Prod>c\\<in>UNIV. h - [:c:])\n\ngoal (1 subgoal):\n 1. \\<exists>s. fi dvd h - [:s:]", "have irr_fi: \"irreducible fi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible fi", "using fi_P P"], ["proof (prove)\nusing this:\n  fi \\<in> P\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible fi", "by blast"], ["proof (state)\nthis:\n  irreducible fi\n\ngoal (1 subgoal):\n 1. \\<exists>s. fi dvd h - [:s:]", "have fi_not_unit: \"\\<not> is_unit fi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_unit fi", "using irr_fi"], ["proof (prove)\nusing this:\n  irreducible fi\n\ngoal (1 subgoal):\n 1. \\<not> is_unit fi", "by (simp add: irreducible\\<^sub>dD(1) poly_dvd_1)"], ["proof (state)\nthis:\n  \\<not> is_unit fi\n\ngoal (1 subgoal):\n 1. \\<exists>s. fi dvd h - [:s:]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. fi dvd h - [:s:]", "using irreducible_dvd_prod[OF _ fi_dvd_prod_hc] irr_fi"], ["proof (prove)\nusing this:\n  irreducible fi \\<Longrightarrow> \\<exists>a\\<in>UNIV. fi dvd h - [:a:]\n  irreducible fi\n\ngoal (1 subgoal):\n 1. \\<exists>s. fi dvd h - [:s:]", "by auto"], ["proof (state)\nthis:\n  \\<exists>s. fi dvd h - [:s:]\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary exists_unique_s_factor_dvd_h_s:\n  fixes fi::\"'a mod_ring poly\"\n  assumes finite_P: \"finite P\"\n    and f_desc_square_free: \"f = (\\<Prod>a\\<in>P. a)\"\n    and P: \"P \\<subseteq> {q. irreducible q \\<and> monic q}\"\n    and fi_P: \"fi \\<in> P\"\n    and h: \"h \\<in> {v. [v^(CARD('a)) = v] (mod f)}\"\n    shows \"\\<exists>!s. fi dvd (h - [:s:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!s. fi dvd h - [:s:]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!s. fi dvd h - [:s:]", "obtain c where fi_dvd: \"fi dvd (h - [:c:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c. fi dvd h - [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms exists_s_factor_dvd_h_s"], ["proof (prove)\nusing this:\n  finite P\n  f = \\<Prod>P\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n  fi \\<in> P\n  h \\<in> {v. [v ^ CARD('a) = v] (mod f)}\n  \\<lbrakk>finite ?P; ?f = \\<Prod>?P;\n   ?P \\<subseteq> {q. irreducible q \\<and> monic q}; ?fi \\<in> ?P;\n   ?h \\<in> {v. [v ^ CARD('a) = v] (mod ?f)}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s. ?fi dvd ?h - [:s:]\n\ngoal (1 subgoal):\n 1. (\\<And>c. fi dvd h - [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  fi dvd h - [:c:]\n\ngoal (1 subgoal):\n 1. \\<exists>!s. fi dvd h - [:s:]", "have irr_fi: \"irreducible fi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible fi", "using fi_P P"], ["proof (prove)\nusing this:\n  fi \\<in> P\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible fi", "by blast"], ["proof (state)\nthis:\n  irreducible fi\n\ngoal (1 subgoal):\n 1. \\<exists>!s. fi dvd h - [:s:]", "have fi_not_unit: \"\\<not> is_unit fi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_unit fi", "by (simp add: irr_fi irreducible\\<^sub>dD(1) poly_dvd_1)"], ["proof (state)\nthis:\n  \\<not> is_unit fi\n\ngoal (1 subgoal):\n 1. \\<exists>!s. fi dvd h - [:s:]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!s. fi dvd h - [:s:]", "proof (rule ex1I[of _ c], auto simp add: fi_dvd)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. fi dvd h - [:s:] \\<Longrightarrow> s = c", "fix c2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. fi dvd h - [:s:] \\<Longrightarrow> s = c", "assume fi_dvd_hc2: \"fi dvd h - [:c2:]\""], ["proof (state)\nthis:\n  fi dvd h - [:c2:]\n\ngoal (1 subgoal):\n 1. \\<And>s. fi dvd h - [:s:] \\<Longrightarrow> s = c", "have *: \"fi dvd (h - [:c:]) * (h - [:c2:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fi dvd (h - [:c:]) * (h - [:c2:])", "using fi_dvd"], ["proof (prove)\nusing this:\n  fi dvd h - [:c:]\n\ngoal (1 subgoal):\n 1. fi dvd (h - [:c:]) * (h - [:c2:])", "by auto"], ["proof (state)\nthis:\n  fi dvd (h - [:c:]) * (h - [:c2:])\n\ngoal (1 subgoal):\n 1. \\<And>s. fi dvd h - [:s:] \\<Longrightarrow> s = c", "hence \"fi dvd (h - [:c:]) \\<or> fi dvd (h - [:c2:])\""], ["proof (prove)\nusing this:\n  fi dvd (h - [:c:]) * (h - [:c2:])\n\ngoal (1 subgoal):\n 1. fi dvd h - [:c:] \\<or> fi dvd h - [:c2:]", "using irr_fi"], ["proof (prove)\nusing this:\n  fi dvd (h - [:c:]) * (h - [:c2:])\n  irreducible fi\n\ngoal (1 subgoal):\n 1. fi dvd h - [:c:] \\<or> fi dvd h - [:c2:]", "by auto"], ["proof (state)\nthis:\n  fi dvd h - [:c:] \\<or> fi dvd h - [:c2:]\n\ngoal (1 subgoal):\n 1. \\<And>s. fi dvd h - [:s:] \\<Longrightarrow> s = c", "thus \"c2 = c\""], ["proof (prove)\nusing this:\n  fi dvd h - [:c:] \\<or> fi dvd h - [:c2:]\n\ngoal (1 subgoal):\n 1. c2 = c", "using coprime_h_c_poly coprime_not_unit_not_dvd fi_dvd fi_dvd_hc2 fi_not_unit"], ["proof (prove)\nusing this:\n  fi dvd h - [:c:] \\<or> fi dvd h - [:c2:]\n  ?c1.0 \\<noteq> ?c2.0 \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (?h - [:?c1.0:]) (?h - [:?c2.0:])\n  \\<lbrakk>?a dvd ?b; comm_monoid_mult_class.coprime ?b ?c;\n   \\<not> is_unit ?a\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?a dvd ?c\n  fi dvd h - [:c:]\n  fi dvd h - [:c2:]\n  \\<not> is_unit fi\n\ngoal (1 subgoal):\n 1. c2 = c", "by blast"], ["proof (state)\nthis:\n  c2 = c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!s. fi dvd h - [:s:]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exists_two_distint: \"\\<exists>a b::'a mod_ring. a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b. a \\<noteq> b", "by (rule exI[of _ 0], rule exI[of _ 1], auto)"], ["", "lemma coprime_cong_mult_factorization_poly:\n  fixes f::\"'b::{field} poly\"\n    and a b p :: \"'c :: {field_gcd} poly\"\n  assumes finite_P: \"finite P\"\n    and P: \"P \\<subseteq> {q. irreducible q}\"\n    and p: \"\\<forall>p\\<in>P. [a=b] (mod p)\"\n    and coprime_P: \"\\<forall>p1 p2. p1 \\<in> P \\<and> p2 \\<in> P \\<and> p1 \\<noteq> p2 \\<longrightarrow> coprime p1 p2\"\n  shows \"[a = b] (mod (\\<Prod>a\\<in>P. a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a = b] (mod \\<Prod>P)", "using finite_P P p coprime_P"], ["proof (prove)\nusing this:\n  finite P\n  P \\<subseteq> {q. irreducible q}\n  \\<forall>p\\<in>P. [a = b] (mod p)\n  \\<forall>p1 p2.\n     p1 \\<in> P \\<and> p2 \\<in> P \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime p1 p2\n\ngoal (1 subgoal):\n 1. [a = b] (mod \\<Prod>P)", "proof (induct P)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> Collect irreducible; Ball {} (cong a b);\n     \\<forall>p1 p2.\n        p1 \\<in> {} \\<and>\n        p2 \\<in> {} \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n        comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n    \\<Longrightarrow> [a = b] (mod \\<Prod>{})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> Collect irreducible; Ball F (cong a b);\n         \\<forall>p1 p2.\n            p1 \\<in> F \\<and>\n            p2 \\<in> F \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n            comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n        \\<Longrightarrow> [a = b] (mod \\<Prod>F);\n        insert x F \\<subseteq> Collect irreducible;\n        Ball (insert x F) (cong a b);\n        \\<forall>p1 p2.\n           p1 \\<in> insert x F \\<and>\n           p2 \\<in> insert x F \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n       \\<Longrightarrow> [a = b] (mod \\<Prod>(insert x F))", "case empty"], ["proof (state)\nthis:\n  {} \\<subseteq> {a. irreducible a}\n  \\<forall>c\\<in>{}. [a = b] (mod c)\n  \\<forall>p1 p2.\n     p1 \\<in> {} \\<and> p2 \\<in> {} \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime p1 p2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> Collect irreducible; Ball {} (cong a b);\n     \\<forall>p1 p2.\n        p1 \\<in> {} \\<and>\n        p2 \\<in> {} \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n        comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n    \\<Longrightarrow> [a = b] (mod \\<Prod>{})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> Collect irreducible; Ball F (cong a b);\n         \\<forall>p1 p2.\n            p1 \\<in> F \\<and>\n            p2 \\<in> F \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n            comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n        \\<Longrightarrow> [a = b] (mod \\<Prod>F);\n        insert x F \\<subseteq> Collect irreducible;\n        Ball (insert x F) (cong a b);\n        \\<forall>p1 p2.\n           p1 \\<in> insert x F \\<and>\n           p2 \\<in> insert x F \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n       \\<Longrightarrow> [a = b] (mod \\<Prod>(insert x F))", "thus ?case"], ["proof (prove)\nusing this:\n  {} \\<subseteq> {a. irreducible a}\n  \\<forall>c\\<in>{}. [a = b] (mod c)\n  \\<forall>p1 p2.\n     p1 \\<in> {} \\<and> p2 \\<in> {} \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime p1 p2\n\ngoal (1 subgoal):\n 1. [a = b] (mod \\<Prod>{})", "by simp"], ["proof (state)\nthis:\n  [a = b] (mod \\<Prod>{})\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> Collect irreducible; Ball F (cong a b);\n         \\<forall>p1 p2.\n            p1 \\<in> F \\<and>\n            p2 \\<in> F \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n            comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n        \\<Longrightarrow> [a = b] (mod \\<Prod>F);\n        insert x F \\<subseteq> Collect irreducible;\n        Ball (insert x F) (cong a b);\n        \\<forall>p1 p2.\n           p1 \\<in> insert x F \\<and>\n           p2 \\<in> insert x F \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n       \\<Longrightarrow> [a = b] (mod \\<Prod>(insert x F))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> Collect irreducible; Ball F (cong a b);\n         \\<forall>p1 p2.\n            p1 \\<in> F \\<and>\n            p2 \\<in> F \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n            comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n        \\<Longrightarrow> [a = b] (mod \\<Prod>F);\n        insert x F \\<subseteq> Collect irreducible;\n        Ball (insert x F) (cong a b);\n        \\<forall>p1 p2.\n           p1 \\<in> insert x F \\<and>\n           p2 \\<in> insert x F \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n       \\<Longrightarrow> [a = b] (mod \\<Prod>(insert x F))", "case (insert p P)"], ["proof (state)\nthis:\n  finite P\n  p \\<notin> P\n  \\<lbrakk>P \\<subseteq> {a. irreducible a};\n   \\<forall>c\\<in>P. [a = b] (mod c);\n   \\<forall>p1 p2.\n      p1 \\<in> P \\<and> p2 \\<in> P \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n      comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n  \\<Longrightarrow> [a = b] (mod \\<Prod>P)\n  insert p P \\<subseteq> {a. irreducible a}\n  \\<forall>c\\<in>insert p P. [a = b] (mod c)\n  \\<forall>p1 p2.\n     p1 \\<in> insert p P \\<and>\n     p2 \\<in> insert p P \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime p1 p2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> Collect irreducible; Ball F (cong a b);\n         \\<forall>p1 p2.\n            p1 \\<in> F \\<and>\n            p2 \\<in> F \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n            comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n        \\<Longrightarrow> [a = b] (mod \\<Prod>F);\n        insert x F \\<subseteq> Collect irreducible;\n        Ball (insert x F) (cong a b);\n        \\<forall>p1 p2.\n           p1 \\<in> insert x F \\<and>\n           p2 \\<in> insert x F \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n       \\<Longrightarrow> [a = b] (mod \\<Prod>(insert x F))", "have ab_mod_pP: \"[a=b] (mod (p * \\<Prod>P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a = b] (mod p * \\<Prod>P)", "proof (rule coprime_cong_mult_poly)"], ["proof (state)\ngoal (3 subgoals):\n 1. [a = b] (mod p)\n 2. [a = b] (mod \\<Prod>P)\n 3. algebraic_semidom_class.coprime p (\\<Prod>P)", "show \"[a = b] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a = b] (mod p)", "using insert.prems"], ["proof (prove)\nusing this:\n  insert p P \\<subseteq> {a. irreducible a}\n  \\<forall>c\\<in>insert p P. [a = b] (mod c)\n  \\<forall>p1 p2.\n     p1 \\<in> insert p P \\<and>\n     p2 \\<in> insert p P \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime p1 p2\n\ngoal (1 subgoal):\n 1. [a = b] (mod p)", "by auto"], ["proof (state)\nthis:\n  [a = b] (mod p)\n\ngoal (2 subgoals):\n 1. [a = b] (mod \\<Prod>P)\n 2. algebraic_semidom_class.coprime p (\\<Prod>P)", "show \"[a = b] (mod \\<Prod>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a = b] (mod \\<Prod>P)", "using insert.prems insert.hyps"], ["proof (prove)\nusing this:\n  insert p P \\<subseteq> {a. irreducible a}\n  \\<forall>c\\<in>insert p P. [a = b] (mod c)\n  \\<forall>p1 p2.\n     p1 \\<in> insert p P \\<and>\n     p2 \\<in> insert p P \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime p1 p2\n  finite P\n  p \\<notin> P\n  \\<lbrakk>P \\<subseteq> {a. irreducible a};\n   \\<forall>c\\<in>P. [a = b] (mod c);\n   \\<forall>p1 p2.\n      p1 \\<in> P \\<and> p2 \\<in> P \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n      comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n  \\<Longrightarrow> [a = b] (mod \\<Prod>P)\n\ngoal (1 subgoal):\n 1. [a = b] (mod \\<Prod>P)", "by auto"], ["proof (state)\nthis:\n  [a = b] (mod \\<Prod>P)\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime p (\\<Prod>P)", "from insert"], ["proof (chain)\npicking this:\n  finite P\n  p \\<notin> P\n  \\<lbrakk>P \\<subseteq> {a. irreducible a};\n   \\<forall>c\\<in>P. [a = b] (mod c);\n   \\<forall>p1 p2.\n      p1 \\<in> P \\<and> p2 \\<in> P \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n      comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n  \\<Longrightarrow> [a = b] (mod \\<Prod>P)\n  insert p P \\<subseteq> {a. irreducible a}\n  \\<forall>c\\<in>insert p P. [a = b] (mod c)\n  \\<forall>p1 p2.\n     p1 \\<in> insert p P \\<and>\n     p2 \\<in> insert p P \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime p1 p2", "show \"Rings.coprime p (\\<Prod>P)\""], ["proof (prove)\nusing this:\n  finite P\n  p \\<notin> P\n  \\<lbrakk>P \\<subseteq> {a. irreducible a};\n   \\<forall>c\\<in>P. [a = b] (mod c);\n   \\<forall>p1 p2.\n      p1 \\<in> P \\<and> p2 \\<in> P \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n      comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n  \\<Longrightarrow> [a = b] (mod \\<Prod>P)\n  insert p P \\<subseteq> {a. irreducible a}\n  \\<forall>c\\<in>insert p P. [a = b] (mod c)\n  \\<forall>p1 p2.\n     p1 \\<in> insert p P \\<and>\n     p2 \\<in> insert p P \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime p1 p2\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime p (\\<Prod>P)", "by (auto intro: prod_coprime_right)"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime p (\\<Prod>P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [a = b] (mod p * \\<Prod>P)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> Collect irreducible; Ball F (cong a b);\n         \\<forall>p1 p2.\n            p1 \\<in> F \\<and>\n            p2 \\<in> F \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n            comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n        \\<Longrightarrow> [a = b] (mod \\<Prod>F);\n        insert x F \\<subseteq> Collect irreducible;\n        Ball (insert x F) (cong a b);\n        \\<forall>p1 p2.\n           p1 \\<in> insert x F \\<and>\n           p2 \\<in> insert x F \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n           comm_monoid_mult_class.coprime p1 p2\\<rbrakk>\n       \\<Longrightarrow> [a = b] (mod \\<Prod>(insert x F))", "thus ?case"], ["proof (prove)\nusing this:\n  [a = b] (mod p * \\<Prod>P)\n\ngoal (1 subgoal):\n 1. [a = b] (mod \\<Prod>(insert p P))", "by (simp add: insert.hyps(1) insert.hyps(2))"], ["proof (state)\nthis:\n  [a = b] (mod \\<Prod>(insert p P))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context\nassumes \"SORT_CONSTRAINT('a::prime_card)\"\nbegin"], ["", "lemma W_eq_berlekamp_mat:\nfixes u::\"'a mod_ring poly\"\nshows \"{v. [v^CARD('a) = v] (mod u) \\<and> degree v < degree u}\n  = {h. let H = vec_of_list ((coeffs h) @ replicate (degree u - length (coeffs h)) 0) in\n    (transpose_mat (berlekamp_mat u)) *\\<^sub>v H = H \\<and> degree h < degree u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u} =\n    {h. let H = vec_of_list\n                 (coeffs h @ replicate (degree u - length (coeffs h)) 0)\n        in (berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<and>\n           degree h < degree u}", "using equation_13"], ["proof (prove)\nusing this:\n  degree ?h < degree ?u \\<Longrightarrow>\n  [?h ^ CARD(?'a) = ?h] (mod ?u) =\n  ((berlekamp_mat ?u)\\<^sup>T *\\<^sub>v\n   vec_of_list (coeffs ?h @ replicate (degree ?u - length (coeffs ?h)) 0) =\n   vec_of_list (coeffs ?h @ replicate (degree ?u - length (coeffs ?h)) 0))\n\ngoal (1 subgoal):\n 1. {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u} =\n    {h. let H = vec_of_list\n                 (coeffs h @ replicate (degree u - length (coeffs h)) 0)\n        in (berlekamp_mat u)\\<^sup>T *\\<^sub>v H = H \\<and>\n           degree h < degree u}", "by (auto simp add: Let_def)"], ["", "lemma transpose_minus_1:\n  assumes \"dim_row Q = dim_col Q\"\n  shows \"transpose_mat (Q - (1\\<^sub>m (dim_row Q))) =  (transpose_mat Q - (1\\<^sub>m (dim_row Q)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T = Q\\<^sup>T - 1\\<^sub>m (dim_row Q)", "using assms"], ["proof (prove)\nusing this:\n  dim_row Q = dim_col Q\n\ngoal (1 subgoal):\n 1. (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T = Q\\<^sup>T - 1\\<^sub>m (dim_row Q)", "unfolding mat_eq_iff"], ["proof (prove)\nusing this:\n  dim_row Q = dim_col Q\n\ngoal (1 subgoal):\n 1. dim_row (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T =\n    dim_row (Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) \\<and>\n    dim_col (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T =\n    dim_col (Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) \\<and>\n    (\\<forall>i j.\n        i < dim_row (Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) \\<longrightarrow>\n        j < dim_col (Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) \\<longrightarrow>\n        (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T $$ (i, j) =\n        (Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) $$ (i, j))", "by auto"], ["", "lemma system_iff:\nfixes v::\"'b::comm_ring_1 vec\"\nassumes sq_Q: \"dim_row Q = dim_col Q\" and v: \"dim_row Q = dim_vec v\"\nshows \"(transpose_mat Q *\\<^sub>v v = v) \\<longleftrightarrow> ((transpose_mat Q - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v = 0\\<^sub>v (dim_vec v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v))", "have t1:\"transpose_mat Q *\\<^sub>v v - v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow> (transpose_mat Q - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v = 0\\<^sub>v (dim_vec v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q\\<^sup>T *\\<^sub>v v - v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    (Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v = 0\\<^sub>v (dim_vec v)", "by (subst minus_mult_distrib_mat_vec, insert sq_Q[symmetric] v, auto)"], ["proof (state)\nthis:\n  Q\\<^sup>T *\\<^sub>v v - v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n  (Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v = 0\\<^sub>v (dim_vec v)\n\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v))", "have t2:\"(transpose_mat Q - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow> transpose_mat Q *\\<^sub>v v - v = 0\\<^sub>v (dim_vec v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n    0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    Q\\<^sup>T *\\<^sub>v v - v = 0\\<^sub>v (dim_vec v)", "by (subst (asm) minus_mult_distrib_mat_vec, insert sq_Q[symmetric] v, auto)"], ["proof (state)\nthis:\n  (Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n  0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n  Q\\<^sup>T *\\<^sub>v v - v = 0\\<^sub>v (dim_vec v)\n\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v))", "have \"transpose_mat Q *\\<^sub>v v - v = v - v \\<Longrightarrow> transpose_mat Q *\\<^sub>v v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q\\<^sup>T *\\<^sub>v v - v = v - v \\<Longrightarrow>\n    Q\\<^sup>T *\\<^sub>v v = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Q\\<^sup>T *\\<^sub>v v - v = v - v \\<Longrightarrow>\n    Q\\<^sup>T *\\<^sub>v v = v", "assume a1: \"transpose_mat Q *\\<^sub>v v - v = v - v\""], ["proof (state)\nthis:\n  Q\\<^sup>T *\\<^sub>v v - v = v - v\n\ngoal (1 subgoal):\n 1. Q\\<^sup>T *\\<^sub>v v - v = v - v \\<Longrightarrow>\n    Q\\<^sup>T *\\<^sub>v v = v", "have f2: \"transpose_mat Q *\\<^sub>v v \\<in> carrier_vec (dim_vec v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q\\<^sup>T *\\<^sub>v v \\<in> carrier_vec (dim_vec v)", "by (metis dim_mult_mat_vec index_transpose_mat(2) sq_Q v carrier_vec_dim_vec)"], ["proof (state)\nthis:\n  Q\\<^sup>T *\\<^sub>v v \\<in> carrier_vec (dim_vec v)\n\ngoal (1 subgoal):\n 1. Q\\<^sup>T *\\<^sub>v v - v = v - v \\<Longrightarrow>\n    Q\\<^sup>T *\\<^sub>v v = v", "then"], ["proof (chain)\npicking this:\n  Q\\<^sup>T *\\<^sub>v v \\<in> carrier_vec (dim_vec v)", "have f3: \"0\\<^sub>v (dim_vec v) + transpose_mat Q *\\<^sub>v v = transpose_mat Q *\\<^sub>v v\""], ["proof (prove)\nusing this:\n  Q\\<^sup>T *\\<^sub>v v \\<in> carrier_vec (dim_vec v)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v (dim_vec v) + Q\\<^sup>T *\\<^sub>v v = Q\\<^sup>T *\\<^sub>v v", "by (meson left_zero_vec)"], ["proof (state)\nthis:\n  0\\<^sub>v (dim_vec v) + Q\\<^sup>T *\\<^sub>v v = Q\\<^sup>T *\\<^sub>v v\n\ngoal (1 subgoal):\n 1. Q\\<^sup>T *\\<^sub>v v - v = v - v \\<Longrightarrow>\n    Q\\<^sup>T *\\<^sub>v v = v", "have f4: \"0\\<^sub>v (dim_vec v) = transpose_mat Q *\\<^sub>v v - v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v (dim_vec v) = Q\\<^sup>T *\\<^sub>v v - v", "using a1"], ["proof (prove)\nusing this:\n  Q\\<^sup>T *\\<^sub>v v - v = v - v\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v (dim_vec v) = Q\\<^sup>T *\\<^sub>v v - v", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v (dim_vec v) = Q\\<^sup>T *\\<^sub>v v - v\n\ngoal (1 subgoal):\n 1. Q\\<^sup>T *\\<^sub>v v - v = v - v \\<Longrightarrow>\n    Q\\<^sup>T *\\<^sub>v v = v", "have f5: \"- v \\<in> carrier_vec (dim_vec v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - v \\<in> carrier_vec (dim_vec v)", "by simp"], ["proof (state)\nthis:\n  - v \\<in> carrier_vec (dim_vec v)\n\ngoal (1 subgoal):\n 1. Q\\<^sup>T *\\<^sub>v v - v = v - v \\<Longrightarrow>\n    Q\\<^sup>T *\\<^sub>v v = v", "then"], ["proof (chain)\npicking this:\n  - v \\<in> carrier_vec (dim_vec v)", "have f6: \"- v + transpose_mat Q *\\<^sub>v v = v - v\""], ["proof (prove)\nusing this:\n  - v \\<in> carrier_vec (dim_vec v)\n\ngoal (1 subgoal):\n 1. - v + Q\\<^sup>T *\\<^sub>v v = v - v", "using f2 a1"], ["proof (prove)\nusing this:\n  - v \\<in> carrier_vec (dim_vec v)\n  Q\\<^sup>T *\\<^sub>v v \\<in> carrier_vec (dim_vec v)\n  Q\\<^sup>T *\\<^sub>v v - v = v - v\n\ngoal (1 subgoal):\n 1. - v + Q\\<^sup>T *\\<^sub>v v = v - v", "using comm_add_vec minus_add_uminus_vec"], ["proof (prove)\nusing this:\n  - v \\<in> carrier_vec (dim_vec v)\n  Q\\<^sup>T *\\<^sub>v v \\<in> carrier_vec (dim_vec v)\n  Q\\<^sup>T *\\<^sub>v v - v = v - v\n  \\<lbrakk>?v\\<^sub>1 \\<in> carrier_vec ?n;\n   ?v\\<^sub>2 \\<in> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> ?v\\<^sub>1 + ?v\\<^sub>2 = ?v\\<^sub>2 + ?v\\<^sub>1\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?w \\<in> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> ?v - ?w = ?v + - ?w\n\ngoal (1 subgoal):\n 1. - v + Q\\<^sup>T *\\<^sub>v v = v - v", "by fastforce"], ["proof (state)\nthis:\n  - v + Q\\<^sup>T *\\<^sub>v v = v - v\n\ngoal (1 subgoal):\n 1. Q\\<^sup>T *\\<^sub>v v - v = v - v \\<Longrightarrow>\n    Q\\<^sup>T *\\<^sub>v v = v", "have \"v - v = - v + v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v - v = - v + v", "by auto"], ["proof (state)\nthis:\n  v - v = - v + v\n\ngoal (1 subgoal):\n 1. Q\\<^sup>T *\\<^sub>v v - v = v - v \\<Longrightarrow>\n    Q\\<^sup>T *\\<^sub>v v = v", "then"], ["proof (chain)\npicking this:\n  v - v = - v + v", "have \"transpose_mat Q *\\<^sub>v v = transpose_mat Q *\\<^sub>v v - v + v\""], ["proof (prove)\nusing this:\n  v - v = - v + v\n\ngoal (1 subgoal):\n 1. Q\\<^sup>T *\\<^sub>v v = Q\\<^sup>T *\\<^sub>v v - v + v", "using f6 f4 f3 f2"], ["proof (prove)\nusing this:\n  v - v = - v + v\n  - v + Q\\<^sup>T *\\<^sub>v v = v - v\n  0\\<^sub>v (dim_vec v) = Q\\<^sup>T *\\<^sub>v v - v\n  0\\<^sub>v (dim_vec v) + Q\\<^sup>T *\\<^sub>v v = Q\\<^sup>T *\\<^sub>v v\n  Q\\<^sup>T *\\<^sub>v v \\<in> carrier_vec (dim_vec v)\n\ngoal (1 subgoal):\n 1. Q\\<^sup>T *\\<^sub>v v = Q\\<^sup>T *\\<^sub>v v - v + v", "by (metis (no_types, lifting) a1 assoc_add_vec comm_add_vec f5 carrier_vec_dim_vec)"], ["proof (state)\nthis:\n  Q\\<^sup>T *\\<^sub>v v = Q\\<^sup>T *\\<^sub>v v - v + v\n\ngoal (1 subgoal):\n 1. Q\\<^sup>T *\\<^sub>v v - v = v - v \\<Longrightarrow>\n    Q\\<^sup>T *\\<^sub>v v = v", "then"], ["proof (chain)\npicking this:\n  Q\\<^sup>T *\\<^sub>v v = Q\\<^sup>T *\\<^sub>v v - v + v", "show ?thesis"], ["proof (prove)\nusing this:\n  Q\\<^sup>T *\\<^sub>v v = Q\\<^sup>T *\\<^sub>v v - v + v\n\ngoal (1 subgoal):\n 1. Q\\<^sup>T *\\<^sub>v v = v", "using a1"], ["proof (prove)\nusing this:\n  Q\\<^sup>T *\\<^sub>v v = Q\\<^sup>T *\\<^sub>v v - v + v\n  Q\\<^sup>T *\\<^sub>v v - v = v - v\n\ngoal (1 subgoal):\n 1. Q\\<^sup>T *\\<^sub>v v = v", "by auto"], ["proof (state)\nthis:\n  Q\\<^sup>T *\\<^sub>v v = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Q\\<^sup>T *\\<^sub>v v - v = v - v \\<Longrightarrow>\n  Q\\<^sup>T *\\<^sub>v v = v\n\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v))", "hence \"(transpose_mat Q *\\<^sub>v v = v) = ((transpose_mat Q *\\<^sub>v v) - v = v - v)\""], ["proof (prove)\nusing this:\n  Q\\<^sup>T *\\<^sub>v v - v = v - v \\<Longrightarrow>\n  Q\\<^sup>T *\\<^sub>v v = v\n\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) = (Q\\<^sup>T *\\<^sub>v v - v = v - v)", "by auto"], ["proof (state)\nthis:\n  (Q\\<^sup>T *\\<^sub>v v = v) = (Q\\<^sup>T *\\<^sub>v v - v = v - v)\n\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v))", "also"], ["proof (state)\nthis:\n  (Q\\<^sup>T *\\<^sub>v v = v) = (Q\\<^sup>T *\\<^sub>v v - v = v - v)\n\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v))", "have \"... = ((transpose_mat Q *\\<^sub>v v) - v = 0\\<^sub>v (dim_vec v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v - v = v - v) =\n    (Q\\<^sup>T *\\<^sub>v v - v = 0\\<^sub>v (dim_vec v))", "by auto"], ["proof (state)\nthis:\n  (Q\\<^sup>T *\\<^sub>v v - v = v - v) =\n  (Q\\<^sup>T *\\<^sub>v v - v = 0\\<^sub>v (dim_vec v))\n\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v))", "also"], ["proof (state)\nthis:\n  (Q\\<^sup>T *\\<^sub>v v - v = v - v) =\n  (Q\\<^sup>T *\\<^sub>v v - v = 0\\<^sub>v (dim_vec v))\n\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v))", "have \"... = ((transpose_mat Q - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v = 0\\<^sub>v (dim_vec v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v - v = 0\\<^sub>v (dim_vec v)) =\n    ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v))", "using t1 t2"], ["proof (prove)\nusing this:\n  Q\\<^sup>T *\\<^sub>v v - v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n  (Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v = 0\\<^sub>v (dim_vec v)\n  (Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n  0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n  Q\\<^sup>T *\\<^sub>v v - v = 0\\<^sub>v (dim_vec v)\n\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v - v = 0\\<^sub>v (dim_vec v)) =\n    ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v))", "by auto"], ["proof (state)\nthis:\n  (Q\\<^sup>T *\\<^sub>v v - v = 0\\<^sub>v (dim_vec v)) =\n  ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v = 0\\<^sub>v (dim_vec v))\n\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v))", "finally"], ["proof (chain)\npicking this:\n  (Q\\<^sup>T *\\<^sub>v v = v) =\n  ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v = 0\\<^sub>v (dim_vec v))", "show ?thesis"], ["proof (prove)\nusing this:\n  (Q\\<^sup>T *\\<^sub>v v = v) =\n  ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v = 0\\<^sub>v (dim_vec v))\n\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v))", "."], ["proof (state)\nthis:\n  (Q\\<^sup>T *\\<^sub>v v = v) =\n  ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v = 0\\<^sub>v (dim_vec v))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma system_if_mat_kernel:\nassumes sq_Q: \"dim_row Q = dim_col Q\" and v: \"dim_row Q = dim_vec v\"\nshows \"(transpose_mat Q *\\<^sub>v v = v) \\<longleftrightarrow> v \\<in> mat_kernel (transpose_mat (Q - (1\\<^sub>m (dim_row Q))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    (v \\<in> mat_kernel (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    (v \\<in> mat_kernel (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T)", "have \"(transpose_mat Q *\\<^sub>v v = v) = ((transpose_mat Q - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v = 0\\<^sub>v (dim_vec v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v))", "using assms system_iff"], ["proof (prove)\nusing this:\n  dim_row Q = dim_col Q\n  dim_row Q = dim_vec v\n  \\<lbrakk>dim_row ?Q = dim_col ?Q; dim_row ?Q = dim_vec ?v\\<rbrakk>\n  \\<Longrightarrow> (?Q\\<^sup>T *\\<^sub>v ?v = ?v) =\n                    ((?Q\\<^sup>T - 1\\<^sub>m (dim_row ?Q)) *\\<^sub>v ?v =\n                     0\\<^sub>v (dim_vec ?v))\n\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v))", "by blast"], ["proof (state)\nthis:\n  (Q\\<^sup>T *\\<^sub>v v = v) =\n  ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v = 0\\<^sub>v (dim_vec v))\n\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    (v \\<in> mat_kernel (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T)", "also"], ["proof (state)\nthis:\n  (Q\\<^sup>T *\\<^sub>v v = v) =\n  ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v = 0\\<^sub>v (dim_vec v))\n\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    (v \\<in> mat_kernel (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T)", "have \"... = (v \\<in> mat_kernel (transpose_mat (Q - (1\\<^sub>m (dim_row Q)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v)) =\n    (v \\<in> mat_kernel (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T)", "unfolding mat_kernel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v)) =\n    (v \\<in> {v \\<in> carrier_vec\n                       (dim_col (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T).\n              (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T *\\<^sub>v v =\n              0\\<^sub>v (dim_row (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T)})", "unfolding transpose_minus_1[OF sq_Q]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v)) =\n    (v \\<in> {v \\<in> carrier_vec\n                       (dim_col (Q\\<^sup>T - 1\\<^sub>m (dim_row Q))).\n              (Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n              0\\<^sub>v (dim_row (Q\\<^sup>T - 1\\<^sub>m (dim_row Q)))})", "unfolding v"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Q\\<^sup>T - 1\\<^sub>m (dim_vec v)) *\\<^sub>v v =\n     0\\<^sub>v (dim_vec v)) =\n    (v \\<in> {va \\<in> carrier_vec\n                        (dim_col (Q\\<^sup>T - 1\\<^sub>m (dim_vec v))).\n              (Q\\<^sup>T - 1\\<^sub>m (dim_vec v)) *\\<^sub>v va =\n              0\\<^sub>v (dim_row (Q\\<^sup>T - 1\\<^sub>m (dim_vec v)))})", "by auto"], ["proof (state)\nthis:\n  ((Q\\<^sup>T - 1\\<^sub>m (dim_row Q)) *\\<^sub>v v =\n   0\\<^sub>v (dim_vec v)) =\n  (v \\<in> mat_kernel (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    (v \\<in> mat_kernel (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T)", "finally"], ["proof (chain)\npicking this:\n  (Q\\<^sup>T *\\<^sub>v v = v) =\n  (v \\<in> mat_kernel (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Q\\<^sup>T *\\<^sub>v v = v) =\n  (v \\<in> mat_kernel (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. (Q\\<^sup>T *\\<^sub>v v = v) =\n    (v \\<in> mat_kernel (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T)", "."], ["proof (state)\nthis:\n  (Q\\<^sup>T *\\<^sub>v v = v) =\n  (v \\<in> mat_kernel (Q - 1\\<^sub>m (dim_row Q))\\<^sup>T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_u_mod_irreducible\\<^sub>d_factor_0:\nfixes v and u::\"'a mod_ring poly\"\ndefines W: \"W \\<equiv> {v. [v ^ CARD('a) = v] (mod u)}\"\nassumes v: \"v \\<in> W\"\nand finite_U: \"finite U\" and u_U: \"u = \\<Prod>U\" and U_irr_monic: \"U \\<subseteq> {q. irreducible q \\<and> monic q}\"\nand fi_U: \"fi \\<in> U\"\nshows \"degree (v mod fi) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (v mod fi) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (v mod fi) = 0", "have deg_fi: \"degree fi > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree fi", "using U_irr_monic"], ["proof (prove)\nusing this:\n  U \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. 0 < degree fi", "using fi_U irreducible\\<^sub>dD[of fi]"], ["proof (prove)\nusing this:\n  U \\<subseteq> {q. irreducible q \\<and> monic q}\n  fi \\<in> U\n  irreducible\\<^sub>d fi \\<Longrightarrow> 0 < degree fi\n  \\<lbrakk>irreducible\\<^sub>d fi; degree ?q < degree fi;\n   degree ?r < degree fi\\<rbrakk>\n  \\<Longrightarrow> fi \\<noteq> ?q * ?r\n\ngoal (1 subgoal):\n 1. 0 < degree fi", "by auto"], ["proof (state)\nthis:\n  0 < degree fi\n\ngoal (1 subgoal):\n 1. degree (v mod fi) = 0", "have \"fi dvd u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fi dvd u", "using u_U U_irr_monic finite_U dvd_prod_eqI fi_U"], ["proof (prove)\nusing this:\n  u = \\<Prod>U\n  U \\<subseteq> {q. irreducible q \\<and> monic q}\n  finite U\n  \\<lbrakk>finite ?A; ?a \\<in> ?A; ?b = ?f ?a\\<rbrakk>\n  \\<Longrightarrow> ?b dvd prod ?f ?A\n  fi \\<in> U\n\ngoal (1 subgoal):\n 1. fi dvd u", "by blast"], ["proof (state)\nthis:\n  fi dvd u\n\ngoal (1 subgoal):\n 1. degree (v mod fi) = 0", "moreover"], ["proof (state)\nthis:\n  fi dvd u\n\ngoal (1 subgoal):\n 1. degree (v mod fi) = 0", "have \"u dvd (v^CARD('a) - v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u dvd v ^ CARD('a) - v", "using v"], ["proof (prove)\nusing this:\n  v \\<in> W\n\ngoal (1 subgoal):\n 1. u dvd v ^ CARD('a) - v", "unfolding W cong_def"], ["proof (prove)\nusing this:\n  v \\<in> {v. v ^ CARD('a) mod u = v mod u}\n\ngoal (1 subgoal):\n 1. u dvd v ^ CARD('a) - v", "by (simp add: mod_eq_dvd_iff_poly)"], ["proof (state)\nthis:\n  u dvd v ^ CARD('a) - v\n\ngoal (1 subgoal):\n 1. degree (v mod fi) = 0", "ultimately"], ["proof (chain)\npicking this:\n  fi dvd u\n  u dvd v ^ CARD('a) - v", "have \"fi dvd (v^CARD('a) - v)\""], ["proof (prove)\nusing this:\n  fi dvd u\n  u dvd v ^ CARD('a) - v\n\ngoal (1 subgoal):\n 1. fi dvd v ^ CARD('a) - v", "by (rule dvd_trans)"], ["proof (state)\nthis:\n  fi dvd v ^ CARD('a) - v\n\ngoal (1 subgoal):\n 1. degree (v mod fi) = 0", "then"], ["proof (chain)\npicking this:\n  fi dvd v ^ CARD('a) - v", "have fi_dvd_prod_vc: \"fi dvd prod (\\<lambda>c. v - [:c:]) (UNIV::'a mod_ring set)\""], ["proof (prove)\nusing this:\n  fi dvd v ^ CARD('a) - v\n\ngoal (1 subgoal):\n 1. fi dvd (\\<Prod>c\\<in>UNIV. v - [:c:])", "by (simp add: poly_identity_mod_p)"], ["proof (state)\nthis:\n  fi dvd (\\<Prod>c\\<in>UNIV. v - [:c:])\n\ngoal (1 subgoal):\n 1. degree (v mod fi) = 0", "have irr_fi: \"irreducible fi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible fi", "using fi_U U_irr_monic"], ["proof (prove)\nusing this:\n  fi \\<in> U\n  U \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible fi", "by blast"], ["proof (state)\nthis:\n  irreducible fi\n\ngoal (1 subgoal):\n 1. degree (v mod fi) = 0", "have fi_not_unit: \"\\<not> is_unit fi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_unit fi", "using irr_fi"], ["proof (prove)\nusing this:\n  irreducible fi\n\ngoal (1 subgoal):\n 1. \\<not> is_unit fi", "by (auto simp: poly_dvd_1)"], ["proof (state)\nthis:\n  \\<not> is_unit fi\n\ngoal (1 subgoal):\n 1. degree (v mod fi) = 0", "have fi_dvd_vc: \"\\<exists>c. fi dvd v - [:c:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. fi dvd v - [:c:]", "using irreducible_dvd_prod[OF _ fi_dvd_prod_vc] irr_fi"], ["proof (prove)\nusing this:\n  irreducible fi \\<Longrightarrow> \\<exists>a\\<in>UNIV. fi dvd v - [:a:]\n  irreducible fi\n\ngoal (1 subgoal):\n 1. \\<exists>c. fi dvd v - [:c:]", "by auto"], ["proof (state)\nthis:\n  \\<exists>c. fi dvd v - [:c:]\n\ngoal (1 subgoal):\n 1. degree (v mod fi) = 0", "from this"], ["proof (chain)\npicking this:\n  \\<exists>c. fi dvd v - [:c:]", "obtain a where \"fi dvd v - [:a:]\""], ["proof (prove)\nusing this:\n  \\<exists>c. fi dvd v - [:c:]\n\ngoal (1 subgoal):\n 1. (\\<And>a. fi dvd v - [:a:] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  fi dvd v - [:a:]\n\ngoal (1 subgoal):\n 1. degree (v mod fi) = 0", "hence \"v mod fi = [:a:] mod fi\""], ["proof (prove)\nusing this:\n  fi dvd v - [:a:]\n\ngoal (1 subgoal):\n 1. v mod fi = [:a:] mod fi", "using mod_eq_dvd_iff_poly"], ["proof (prove)\nusing this:\n  fi dvd v - [:a:]\n  (?x mod ?n = ?y mod ?n) = (?n dvd ?x - ?y)\n\ngoal (1 subgoal):\n 1. v mod fi = [:a:] mod fi", "by blast"], ["proof (state)\nthis:\n  v mod fi = [:a:] mod fi\n\ngoal (1 subgoal):\n 1. degree (v mod fi) = 0", "also"], ["proof (state)\nthis:\n  v mod fi = [:a:] mod fi\n\ngoal (1 subgoal):\n 1. degree (v mod fi) = 0", "have \"... = [:a:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:a:] mod fi = [:a:]", "by (simp add: deg_fi mod_poly_less)"], ["proof (state)\nthis:\n  [:a:] mod fi = [:a:]\n\ngoal (1 subgoal):\n 1. degree (v mod fi) = 0", "finally"], ["proof (chain)\npicking this:\n  v mod fi = [:a:]", "show ?thesis"], ["proof (prove)\nusing this:\n  v mod fi = [:a:]\n\ngoal (1 subgoal):\n 1. degree (v mod fi) = 0", "by simp"], ["proof (state)\nthis:\n  degree (v mod fi) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Also polynomials over a field as a vector space in HOL-Algebra.*)"], ["", "definition \"poly_abelian_monoid\n  = \\<lparr>carrier = UNIV::'a mod_ring poly set, monoid.mult = ((*)), one = 1, zero = 0, add = (+), module.smult = smult\\<rparr>\""], ["", "interpretation vector_space_poly: vectorspace class_ring poly_abelian_monoid\n  rewrites [simp]: \"\\<zero>\\<^bsub>poly_abelian_monoid\\<^esub> = 0\"\n       and [simp]: \"\\<one>\\<^bsub>poly_abelian_monoid\\<^esub> = 1\"\n       and [simp]: \"(\\<oplus>\\<^bsub>poly_abelian_monoid\\<^esub>) = (+)\"\n       and [simp]: \"(\\<otimes>\\<^bsub>poly_abelian_monoid\\<^esub>) = (*)\"\n       and [simp]: \"carrier poly_abelian_monoid = UNIV\"\n       and [simp]: \"(\\<odot>\\<^bsub>poly_abelian_monoid\\<^esub>) = smult\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vectorspace class_ring local.poly_abelian_monoid &&&\n     \\<zero>\\<^bsub>local.poly_abelian_monoid\\<^esub> = 0 &&&\n     \\<one>\\<^bsub>local.poly_abelian_monoid\\<^esub> = 1) &&&\n    ((\\<oplus>\\<^bsub>local.poly_abelian_monoid\\<^esub>) = (+) &&&\n     (\\<otimes>\\<^bsub>local.poly_abelian_monoid\\<^esub>) = (*)) &&&\n    carrier local.poly_abelian_monoid = UNIV &&&\n    (\\<odot>\\<^bsub>local.poly_abelian_monoid\\<^esub>) = Polynomial.smult", "apply unfold_locales"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid local.poly_abelian_monoid);\n        y \\<in> carrier (add_monoid local.poly_abelian_monoid)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid local.poly_abelian_monoid\\<^esub>\n                         y\n                         \\<in> carrier\n                                (add_monoid local.poly_abelian_monoid)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier (add_monoid local.poly_abelian_monoid);\n        y \\<in> carrier (add_monoid local.poly_abelian_monoid);\n        z \\<in> carrier (add_monoid local.poly_abelian_monoid)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid local.poly_abelian_monoid\\<^esub>\n                         y \\<otimes>\\<^bsub>add_monoid local.poly_abelian_monoid\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>add_monoid local.poly_abelian_monoid\\<^esub>\n                         (y \\<otimes>\\<^bsub>add_monoid local.poly_abelian_monoid\\<^esub>\n                          z)\n 3. \\<one>\\<^bsub>add_monoid local.poly_abelian_monoid\\<^esub>\n    \\<in> carrier (add_monoid local.poly_abelian_monoid)\n 4. \\<And>x.\n       x \\<in> carrier\n                (add_monoid local.poly_abelian_monoid) \\<Longrightarrow>\n       \\<one>\\<^bsub>add_monoid local.poly_abelian_monoid\\<^esub> \\<otimes>\\<^bsub>add_monoid local.poly_abelian_monoid\\<^esub>\n       x =\n       x\n 5. \\<And>x.\n       x \\<in> carrier\n                (add_monoid local.poly_abelian_monoid) \\<Longrightarrow>\n       x \\<otimes>\\<^bsub>add_monoid local.poly_abelian_monoid\\<^esub>\n       \\<one>\\<^bsub>add_monoid local.poly_abelian_monoid\\<^esub> =\n       x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid local.poly_abelian_monoid);\n        y \\<in> carrier (add_monoid local.poly_abelian_monoid)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid local.poly_abelian_monoid\\<^esub>\n                         y =\n                         y \\<otimes>\\<^bsub>add_monoid local.poly_abelian_monoid\\<^esub>\n                         x\n 7. carrier (add_monoid local.poly_abelian_monoid)\n    \\<subseteq> Units (add_monoid local.poly_abelian_monoid)\n 8. \\<And>a x.\n       \\<lbrakk>a \\<in> carrier class_ring;\n        x \\<in> carrier local.poly_abelian_monoid\\<rbrakk>\n       \\<Longrightarrow> a \\<odot>\\<^bsub>local.poly_abelian_monoid\\<^esub>\n                         x\n                         \\<in> carrier local.poly_abelian_monoid\n 9. \\<And>a b x.\n       \\<lbrakk>a \\<in> carrier class_ring; b \\<in> carrier class_ring;\n        x \\<in> carrier local.poly_abelian_monoid\\<rbrakk>\n       \\<Longrightarrow> (a \\<oplus>\\<^bsub>class_ring\\<^esub>\n                          b) \\<odot>\\<^bsub>local.poly_abelian_monoid\\<^esub>\n                         x =\n                         a \\<odot>\\<^bsub>local.poly_abelian_monoid\\<^esub>\n                         x \\<oplus>\\<^bsub>local.poly_abelian_monoid\\<^esub>\n                         b \\<odot>\\<^bsub>local.poly_abelian_monoid\\<^esub>\n                         x\n 10. \\<And>a x y.\n        \\<lbrakk>a \\<in> carrier class_ring;\n         x \\<in> carrier local.poly_abelian_monoid;\n         y \\<in> carrier local.poly_abelian_monoid\\<rbrakk>\n        \\<Longrightarrow> a \\<odot>\\<^bsub>local.poly_abelian_monoid\\<^esub>\n                          (x \\<oplus>\\<^bsub>local.poly_abelian_monoid\\<^esub>\n                           y) =\n                          a \\<odot>\\<^bsub>local.poly_abelian_monoid\\<^esub>\n                          x \\<oplus>\\<^bsub>local.poly_abelian_monoid\\<^esub>\n                          a \\<odot>\\<^bsub>local.poly_abelian_monoid\\<^esub>\n                          y\nA total of 18 subgoals...", "apply (auto simp: poly_abelian_monoid_def class_field_def smult_add_left smult_add_right Units_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>xa. xa + x = 0 \\<and> x + xa = 0", "by (metis add.commute add.right_inverse)"], ["", "lemma subspace_Berlekamp:\nassumes f: \"degree f \\<noteq> 0\"\nshows \"subspace (class_ring :: 'a mod_ring ring) \n  {v. [v^(CARD('a)) = v] (mod f) \\<and> (degree v < degree f)} poly_abelian_monoid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace class_ring\n     {v. [v ^ CARD('a) = v] (mod f) \\<and> degree v < degree f}\n     local.poly_abelian_monoid", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subspace class_ring\n     {v. [v ^ CARD('a) = v] (mod f) \\<and> degree v < degree f}\n     local.poly_abelian_monoid", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. subspace class_ring\n     {v. [v ^ CARD('a) = v] (mod f) \\<and> degree v < degree f}\n     local.poly_abelian_monoid", "fix v :: \"'a mod_ring poly\" and w :: \"'a mod_ring poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. subspace class_ring\n     {v. [v ^ CARD('a) = v] (mod f) \\<and> degree v < degree f}\n     local.poly_abelian_monoid", "assume a1: \"v ^ card (UNIV::'a set) mod f = v mod f\""], ["proof (state)\nthis:\n  v ^ CARD('a) mod f = v mod f\n\ngoal (1 subgoal):\n 1. subspace class_ring\n     {v. [v ^ CARD('a) = v] (mod f) \\<and> degree v < degree f}\n     local.poly_abelian_monoid", "assume \"w ^ card (UNIV::'a set) mod f = w mod f\""], ["proof (state)\nthis:\n  w ^ CARD('a) mod f = w mod f\n\ngoal (1 subgoal):\n 1. subspace class_ring\n     {v. [v ^ CARD('a) = v] (mod f) \\<and> degree v < degree f}\n     local.poly_abelian_monoid", "then"], ["proof (chain)\npicking this:\n  w ^ CARD('a) mod f = w mod f", "have \"(v ^ card (UNIV::'a set) + w ^ card (UNIV::'a set)) mod f = (v + w) mod f\""], ["proof (prove)\nusing this:\n  w ^ CARD('a) mod f = w mod f\n\ngoal (1 subgoal):\n 1. (v ^ CARD('a) + w ^ CARD('a)) mod f = (v + w) mod f", "using a1"], ["proof (prove)\nusing this:\n  w ^ CARD('a) mod f = w mod f\n  v ^ CARD('a) mod f = v mod f\n\ngoal (1 subgoal):\n 1. (v ^ CARD('a) + w ^ CARD('a)) mod f = (v + w) mod f", "by (meson mod_add_cong)"], ["proof (state)\nthis:\n  (v ^ CARD('a) + w ^ CARD('a)) mod f = (v + w) mod f\n\ngoal (1 subgoal):\n 1. subspace class_ring\n     {v. [v ^ CARD('a) = v] (mod f) \\<and> degree v < degree f}\n     local.poly_abelian_monoid", "then"], ["proof (chain)\npicking this:\n  (v ^ CARD('a) + w ^ CARD('a)) mod f = (v + w) mod f", "have \"(v + w) ^ card (UNIV::'a set) mod f = (v + w) mod f\""], ["proof (prove)\nusing this:\n  (v ^ CARD('a) + w ^ CARD('a)) mod f = (v + w) mod f\n\ngoal (1 subgoal):\n 1. (v + w) ^ CARD('a) mod f = (v + w) mod f", "by (simp add: add_power_poly_mod_ring)"], ["proof (state)\nthis:\n  (v + w) ^ CARD('a) mod f = (v + w) mod f\n\ngoal (1 subgoal):\n 1. subspace class_ring\n     {v. [v ^ CARD('a) = v] (mod f) \\<and> degree v < degree f}\n     local.poly_abelian_monoid", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?v3 ^ CARD('a) mod f = ?v3 mod f;\n   ?w3 ^ CARD('a) mod f = ?w3 mod f\\<rbrakk>\n  \\<Longrightarrow> (?v3 + ?w3) ^ CARD('a) mod f = (?v3 + ?w3) mod f\n\ngoal (1 subgoal):\n 1. subspace class_ring\n     {v. [v ^ CARD('a) = v] (mod f) \\<and> degree v < degree f}\n     local.poly_abelian_monoid", "note r=this"], ["proof (state)\nthis:\n  \\<lbrakk>?v3 ^ CARD('a) mod f = ?v3 mod f;\n   ?w3 ^ CARD('a) mod f = ?w3 mod f\\<rbrakk>\n  \\<Longrightarrow> (?v3 + ?w3) ^ CARD('a) mod f = (?v3 + ?w3) mod f\n\ngoal (1 subgoal):\n 1. subspace class_ring\n     {v. [v ^ CARD('a) = v] (mod f) \\<and> degree v < degree f}\n     local.poly_abelian_monoid", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v3 ^ CARD('a) mod f = ?v3 mod f;\n   ?w3 ^ CARD('a) mod f = ?w3 mod f\\<rbrakk>\n  \\<Longrightarrow> (?v3 + ?w3) ^ CARD('a) mod f = (?v3 + ?w3) mod f\n\ngoal (1 subgoal):\n 1. subspace class_ring\n     {v. [v ^ CARD('a) = v] (mod f) \\<and> degree v < degree f}\n     local.poly_abelian_monoid", "using f"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v3 ^ CARD('a) mod f = ?v3 mod f;\n   ?w3 ^ CARD('a) mod f = ?w3 mod f\\<rbrakk>\n  \\<Longrightarrow> (?v3 + ?w3) ^ CARD('a) mod f = (?v3 + ?w3) mod f\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. subspace class_ring\n     {v. [v ^ CARD('a) = v] (mod f) \\<and> degree v < degree f}\n     local.poly_abelian_monoid", "by (unfold_locales, auto simp: zero_power mod_smult_left smult_power cong_def degree_add_less)"], ["proof (state)\nthis:\n  subspace class_ring\n   {v. [v ^ CARD('a) = v] (mod f) \\<and> degree v < degree f}\n   local.poly_abelian_monoid\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma berlekamp_resulting_mat_closed[simp]:\n  \"berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)\"\n  \"dim_row (berlekamp_resulting_mat u) = degree u\"\n  \"dim_col (berlekamp_resulting_mat u) = degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u) &&&\n    dim_row (berlekamp_resulting_mat u) = degree u &&&\n    dim_col (berlekamp_resulting_mat u) = degree u", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)\n 2. dim_row (berlekamp_resulting_mat u) = degree u\n 3. dim_col (berlekamp_resulting_mat u) = degree u", "let ?A=\"(transpose_mat (mat (degree u) (degree u)\n             (\\<lambda>(i, j). if i = j then berlekamp_mat u $$ (i, j) - 1 else berlekamp_mat u $$ (i, j))))\""], ["proof (state)\ngoal (3 subgoals):\n 1. berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)\n 2. dim_row (berlekamp_resulting_mat u) = degree u\n 3. dim_col (berlekamp_resulting_mat u) = degree u", "let ?G=\"(gauss_jordan_single ?A)\""], ["proof (state)\ngoal (3 subgoals):\n 1. berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)\n 2. dim_row (berlekamp_resulting_mat u) = degree u\n 3. dim_col (berlekamp_resulting_mat u) = degree u", "have \"?G \\<in>carrier_mat (degree u) (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_jordan_single\n     (mat (degree u) (degree u)\n       (\\<lambda>(i, j).\n           if i = j then berlekamp_mat u $$ (i, j) - 1\n           else berlekamp_mat u $$ (i, j)))\\<^sup>T\n    \\<in> carrier_mat (degree u) (degree u)", "by (rule gauss_jordan_single(2)[of ?A], auto)"], ["proof (state)\nthis:\n  gauss_jordan_single\n   (mat (degree u) (degree u)\n     (\\<lambda>(i, j).\n         if i = j then berlekamp_mat u $$ (i, j) - 1\n         else berlekamp_mat u $$ (i, j)))\\<^sup>T\n  \\<in> carrier_mat (degree u) (degree u)\n\ngoal (3 subgoals):\n 1. berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)\n 2. dim_row (berlekamp_resulting_mat u) = degree u\n 3. dim_col (berlekamp_resulting_mat u) = degree u", "thus\n    \"berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)\"\n    \"dim_row (berlekamp_resulting_mat u) = degree u\"\n    \"dim_col (berlekamp_resulting_mat u) = degree u\""], ["proof (prove)\nusing this:\n  gauss_jordan_single\n   (mat (degree u) (degree u)\n     (\\<lambda>(i, j).\n         if i = j then berlekamp_mat u $$ (i, j) - 1\n         else berlekamp_mat u $$ (i, j)))\\<^sup>T\n  \\<in> carrier_mat (degree u) (degree u)\n\ngoal (1 subgoal):\n 1. berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u) &&&\n    dim_row (berlekamp_resulting_mat u) = degree u &&&\n    dim_col (berlekamp_resulting_mat u) = degree u", "unfolding berlekamp_resulting_mat_def Let_def"], ["proof (prove)\nusing this:\n  gauss_jordan_single\n   (mat (degree u) (degree u)\n     (\\<lambda>(i, j).\n         if i = j then berlekamp_mat u $$ (i, j) - 1\n         else berlekamp_mat u $$ (i, j)))\\<^sup>T\n  \\<in> carrier_mat (degree u) (degree u)\n\ngoal (1 subgoal):\n 1. gauss_jordan_single\n     (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n       (\\<lambda>(i, j).\n           if i = j then berlekamp_mat u $$ (i, j) - 1\n           else berlekamp_mat u $$ (i, j)))\\<^sup>T\n    \\<in> carrier_mat (degree u) (degree u) &&&\n    dim_row\n     (gauss_jordan_single\n       (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n         (\\<lambda>(i, j).\n             if i = j then berlekamp_mat u $$ (i, j) - 1\n             else berlekamp_mat u $$ (i, j)))\\<^sup>T) =\n    degree u &&&\n    dim_col\n     (gauss_jordan_single\n       (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n         (\\<lambda>(i, j).\n             if i = j then berlekamp_mat u $$ (i, j) - 1\n             else berlekamp_mat u $$ (i, j)))\\<^sup>T) =\n    degree u", "by auto"], ["proof (state)\nthis:\n  berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)\n  dim_row (berlekamp_resulting_mat u) = degree u\n  dim_col (berlekamp_resulting_mat u) = degree u\n\ngoal:\nNo subgoals!", "qed"], ["", "(*find_base vectors returns a basis:*)"], ["", "lemma berlekamp_resulting_mat_basis:\n\"kernel.basis (degree u) (berlekamp_resulting_mat u) (set (find_base_vectors (berlekamp_resulting_mat u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.basis class_ring\n     (module_vec TYPE('b mod_ring) (degree u)\n      \\<lparr>carrier := mat_kernel (berlekamp_resulting_mat u)\\<rparr>)\n     (set (find_base_vectors (berlekamp_resulting_mat u)))", "proof (rule find_base_vectors(3))"], ["proof (state)\ngoal (2 subgoals):\n 1. row_echelon_form (berlekamp_resulting_mat u)\n 2. berlekamp_resulting_mat u \\<in> carrier_mat ?nr (degree u)", "show \"berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)", "by simp"], ["proof (state)\nthis:\n  berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)\n\ngoal (1 subgoal):\n 1. row_echelon_form (berlekamp_resulting_mat u)", "let ?A=\"(transpose_mat (mat (degree u) (degree u)\n          (\\<lambda>(i, j). if i = j then berlekamp_mat u $$ (i, j) - 1 else berlekamp_mat u $$ (i, j))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. row_echelon_form (berlekamp_resulting_mat u)", "have \"row_echelon_form (gauss_jordan_single ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form\n     (gauss_jordan_single\n       (mat (degree u) (degree u)\n         (\\<lambda>(i, j).\n             if i = j then berlekamp_mat u $$ (i, j) - 1\n             else berlekamp_mat u $$ (i, j)))\\<^sup>T)", "by (rule gauss_jordan_single(3)[of ?A], auto)"], ["proof (state)\nthis:\n  row_echelon_form\n   (gauss_jordan_single\n     (mat (degree u) (degree u)\n       (\\<lambda>(i, j).\n           if i = j then berlekamp_mat u $$ (i, j) - 1\n           else berlekamp_mat u $$ (i, j)))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. row_echelon_form (berlekamp_resulting_mat u)", "thus \"row_echelon_form (berlekamp_resulting_mat u)\""], ["proof (prove)\nusing this:\n  row_echelon_form\n   (gauss_jordan_single\n     (mat (degree u) (degree u)\n       (\\<lambda>(i, j).\n           if i = j then berlekamp_mat u $$ (i, j) - 1\n           else berlekamp_mat u $$ (i, j)))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. row_echelon_form (berlekamp_resulting_mat u)", "unfolding berlekamp_resulting_mat_def Let_def"], ["proof (prove)\nusing this:\n  row_echelon_form\n   (gauss_jordan_single\n     (mat (degree u) (degree u)\n       (\\<lambda>(i, j).\n           if i = j then berlekamp_mat u $$ (i, j) - 1\n           else berlekamp_mat u $$ (i, j)))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. row_echelon_form\n     (gauss_jordan_single\n       (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n         (\\<lambda>(i, j).\n             if i = j then berlekamp_mat u $$ (i, j) - 1\n             else berlekamp_mat u $$ (i, j)))\\<^sup>T)", "by auto"], ["proof (state)\nthis:\n  row_echelon_form (berlekamp_resulting_mat u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_berlekamp_basis_eq: \"(set (berlekamp_basis u))\n  = (Poly \\<circ> list_of_vec)` (set (find_base_vectors (berlekamp_resulting_mat u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (berlekamp_basis u) =\n    (Poly \\<circ> list_of_vec) `\n    set (find_base_vectors (berlekamp_resulting_mat u))", "by (auto simp add: image_def o_def berlekamp_basis_def)"], ["", "lemma berlekamp_resulting_mat_constant:\nassumes deg_u: \"degree u = 0\"\nshows \"berlekamp_resulting_mat u = 1\\<^sub>m 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. berlekamp_resulting_mat u = 1\\<^sub>m 0", "by (unfold mat_eq_iff, auto simp add: deg_u)"], ["", "context\n  fixes u::\"'a::prime_card mod_ring poly\"\nbegin"], ["", "lemma set_berlekamp_basis_constant:\nassumes deg_u: \"degree u = 0\"\nshows \"set (berlekamp_basis u) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (berlekamp_basis u) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (berlekamp_basis u) = {}", "have one_carrier: \"1\\<^sub>m 0 \\<in> carrier_mat 0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m 0 \\<in> carrier_mat 0 0", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m 0 \\<in> carrier_mat 0 0\n\ngoal (1 subgoal):\n 1. set (berlekamp_basis u) = {}", "have m: \"mat_kernel (1\\<^sub>m 0) = {(0\\<^sub>v 0) :: 'a mod_ring vec}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel (1\\<^sub>m 0) = {0\\<^sub>v 0}", "unfolding mat_kernel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v \\<in> carrier_vec (dim_col (1\\<^sub>m 0)).\n     1\\<^sub>m 0 *\\<^sub>v v = 0\\<^sub>v (dim_row (1\\<^sub>m 0))} =\n    {0\\<^sub>v 0}", "by auto"], ["proof (state)\nthis:\n  mat_kernel (1\\<^sub>m 0) = {0\\<^sub>v 0}\n\ngoal (1 subgoal):\n 1. set (berlekamp_basis u) = {}", "have r: \"row_echelon_form (1\\<^sub>m 0 :: 'a mod_ring mat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form (1\\<^sub>m 0)", "unfolding row_echelon_form_def pivot_fun_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>i<dim_row (1\\<^sub>m 0).\n          f i \\<le> dim_col (1\\<^sub>m 0) \\<and>\n          (f i < dim_col (1\\<^sub>m 0) \\<longrightarrow>\n           1\\<^sub>m 0 $$ (i, f i) = 1 \\<and>\n           (\\<forall>i'<dim_row (1\\<^sub>m 0).\n               i' \\<noteq> i \\<longrightarrow>\n               1\\<^sub>m 0 $$ (i', f i) = 0)) \\<and>\n          (\\<forall>j<f i. 1\\<^sub>m 0 $$ (i, j) = 0) \\<and>\n          (Suc i < dim_row (1\\<^sub>m 0) \\<longrightarrow>\n           f i < f (Suc i) \\<or> f (Suc i) = dim_col (1\\<^sub>m 0))", "by auto"], ["proof (state)\nthis:\n  row_echelon_form (1\\<^sub>m 0)\n\ngoal (1 subgoal):\n 1. set (berlekamp_basis u) = {}", "have \"set (find_base_vectors (1\\<^sub>m 0)) \\<subseteq> {0\\<^sub>v 0 :: 'a mod_ring vec}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_base_vectors (1\\<^sub>m 0)) \\<subseteq> {0\\<^sub>v 0}", "using find_base_vectors(1)[OF r one_carrier]"], ["proof (prove)\nusing this:\n  set (find_base_vectors (1\\<^sub>m 0)) \\<subseteq> mat_kernel (1\\<^sub>m 0)\n\ngoal (1 subgoal):\n 1. set (find_base_vectors (1\\<^sub>m 0)) \\<subseteq> {0\\<^sub>v 0}", "unfolding m"], ["proof (prove)\nusing this:\n  set (find_base_vectors (1\\<^sub>m 0)) \\<subseteq> {0\\<^sub>v 0}\n\ngoal (1 subgoal):\n 1. set (find_base_vectors (1\\<^sub>m 0)) \\<subseteq> {0\\<^sub>v 0}", "."], ["proof (state)\nthis:\n  set (find_base_vectors (1\\<^sub>m 0)) \\<subseteq> {0\\<^sub>v 0}\n\ngoal (1 subgoal):\n 1. set (berlekamp_basis u) = {}", "hence \"set (find_base_vectors (1\\<^sub>m 0) :: 'a mod_ring vec list) = {}\""], ["proof (prove)\nusing this:\n  set (find_base_vectors (1\\<^sub>m 0)) \\<subseteq> {0\\<^sub>v 0}\n\ngoal (1 subgoal):\n 1. set (find_base_vectors (1\\<^sub>m 0)) = {}", "using find_base_vectors(2)[OF r one_carrier]"], ["proof (prove)\nusing this:\n  set (find_base_vectors (1\\<^sub>m 0)) \\<subseteq> {0\\<^sub>v 0}\n  0\\<^sub>v 0 \\<notin> set (find_base_vectors (1\\<^sub>m 0))\n\ngoal (1 subgoal):\n 1. set (find_base_vectors (1\\<^sub>m 0)) = {}", "using subset_singletonD"], ["proof (prove)\nusing this:\n  set (find_base_vectors (1\\<^sub>m 0)) \\<subseteq> {0\\<^sub>v 0}\n  0\\<^sub>v 0 \\<notin> set (find_base_vectors (1\\<^sub>m 0))\n  ?A \\<subseteq> {?x} \\<Longrightarrow> ?A = {} \\<or> ?A = {?x}\n\ngoal (1 subgoal):\n 1. set (find_base_vectors (1\\<^sub>m 0)) = {}", "by fastforce"], ["proof (state)\nthis:\n  set (find_base_vectors (1\\<^sub>m 0)) = {}\n\ngoal (1 subgoal):\n 1. set (berlekamp_basis u) = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (find_base_vectors (1\\<^sub>m 0)) = {}\n\ngoal (1 subgoal):\n 1. set (berlekamp_basis u) = {}", "unfolding set_berlekamp_basis_eq"], ["proof (prove)\nusing this:\n  set (find_base_vectors (1\\<^sub>m 0)) = {}\n\ngoal (1 subgoal):\n 1. (Poly \\<circ> list_of_vec) `\n    set (find_base_vectors (berlekamp_resulting_mat u)) =\n    {}", "unfolding berlekamp_resulting_mat_constant[OF deg_u]"], ["proof (prove)\nusing this:\n  set (find_base_vectors (1\\<^sub>m 0)) = {}\n\ngoal (1 subgoal):\n 1. (Poly \\<circ> list_of_vec) ` set (find_base_vectors (1\\<^sub>m 0)) = {}", "by auto"], ["proof (state)\nthis:\n  set (berlekamp_basis u) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "(*Maybe [simp]*)"], ["", "lemma row_echelon_form_berlekamp_resulting_mat: \"row_echelon_form (berlekamp_resulting_mat u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form (berlekamp_resulting_mat u)", "by (rule gauss_jordan_single(3), auto simp add: berlekamp_resulting_mat_def Let_def)"], ["", "lemma mat_kernel_berlekamp_resulting_mat_degree_0:\nassumes d: \"degree u = 0\"\nshows \"mat_kernel (berlekamp_resulting_mat u) = {0\\<^sub>v 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel (berlekamp_resulting_mat u) = {0\\<^sub>v 0}", "by (auto simp add: mat_kernel_def mult_mat_vec_def d)"], ["", "lemma in_mat_kernel_berlekamp_resulting_mat:\nassumes x: \"transpose_mat (berlekamp_mat u) *\\<^sub>v x = x\"\nand x_dim: \"x \\<in> carrier_vec (degree u)\"\nshows \"x \\<in> mat_kernel (berlekamp_resulting_mat u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> mat_kernel (berlekamp_resulting_mat u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> mat_kernel (berlekamp_resulting_mat u)", "let ?QI=\"(mat(dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n         (\\<lambda>(i, j). if i = j then berlekamp_mat u $$ (i, j) - 1 else berlekamp_mat u $$ (i, j)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> mat_kernel (berlekamp_resulting_mat u)", "have *: \"(transpose_mat (berlekamp_mat u) - 1\\<^sub>m (degree u)) = transpose_mat  ?QI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T - 1\\<^sub>m (degree u) =\n    (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T", "by auto"], ["proof (state)\nthis:\n  (berlekamp_mat u)\\<^sup>T - 1\\<^sub>m (degree u) =\n  (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n    (\\<lambda>(i, j).\n        if i = j then berlekamp_mat u $$ (i, j) - 1\n        else berlekamp_mat u $$ (i, j)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. x \\<in> mat_kernel (berlekamp_resulting_mat u)", "have \"(transpose_mat (berlekamp_mat u) - 1\\<^sub>m (dim_row (berlekamp_mat u))) *\\<^sub>v x = 0\\<^sub>v (dim_vec x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((berlekamp_mat u)\\<^sup>T -\n     1\\<^sub>m (dim_row (berlekamp_mat u))) *\\<^sub>v\n    x =\n    0\\<^sub>v (dim_vec x)", "using system_iff[of \"berlekamp_mat u\" x] x_dim x"], ["proof (prove)\nusing this:\n  \\<lbrakk>dim_row (berlekamp_mat u) = dim_col (berlekamp_mat u);\n   dim_row (berlekamp_mat u) = dim_vec x\\<rbrakk>\n  \\<Longrightarrow> ((berlekamp_mat u)\\<^sup>T *\\<^sub>v x = x) =\n                    (((berlekamp_mat u)\\<^sup>T -\n                      1\\<^sub>m (dim_row (berlekamp_mat u))) *\\<^sub>v\n                     x =\n                     0\\<^sub>v (dim_vec x))\n  x \\<in> carrier_vec (degree u)\n  (berlekamp_mat u)\\<^sup>T *\\<^sub>v x = x\n\ngoal (1 subgoal):\n 1. ((berlekamp_mat u)\\<^sup>T -\n     1\\<^sub>m (dim_row (berlekamp_mat u))) *\\<^sub>v\n    x =\n    0\\<^sub>v (dim_vec x)", "by auto"], ["proof (state)\nthis:\n  ((berlekamp_mat u)\\<^sup>T -\n   1\\<^sub>m (dim_row (berlekamp_mat u))) *\\<^sub>v\n  x =\n  0\\<^sub>v (dim_vec x)\n\ngoal (1 subgoal):\n 1. x \\<in> mat_kernel (berlekamp_resulting_mat u)", "hence \"transpose_mat ?QI *\\<^sub>v x = 0\\<^sub>v (degree u)\""], ["proof (prove)\nusing this:\n  ((berlekamp_mat u)\\<^sup>T -\n   1\\<^sub>m (dim_row (berlekamp_mat u))) *\\<^sub>v\n  x =\n  0\\<^sub>v (dim_vec x)\n\ngoal (1 subgoal):\n 1. (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n    x =\n    0\\<^sub>v (degree u)", "using x_dim *"], ["proof (prove)\nusing this:\n  ((berlekamp_mat u)\\<^sup>T -\n   1\\<^sub>m (dim_row (berlekamp_mat u))) *\\<^sub>v\n  x =\n  0\\<^sub>v (dim_vec x)\n  x \\<in> carrier_vec (degree u)\n  (berlekamp_mat u)\\<^sup>T - 1\\<^sub>m (degree u) =\n  (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n    (\\<lambda>(i, j).\n        if i = j then berlekamp_mat u $$ (i, j) - 1\n        else berlekamp_mat u $$ (i, j)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n    x =\n    0\\<^sub>v (degree u)", "by auto"], ["proof (state)\nthis:\n  (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n    (\\<lambda>(i, j).\n        if i = j then berlekamp_mat u $$ (i, j) - 1\n        else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n  x =\n  0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. x \\<in> mat_kernel (berlekamp_resulting_mat u)", "hence \"berlekamp_resulting_mat u *\\<^sub>v x = 0\\<^sub>v (degree u)\""], ["proof (prove)\nusing this:\n  (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n    (\\<lambda>(i, j).\n        if i = j then berlekamp_mat u $$ (i, j) - 1\n        else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n  x =\n  0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. berlekamp_resulting_mat u *\\<^sub>v x = 0\\<^sub>v (degree u)", "unfolding berlekamp_resulting_mat_def Let_def"], ["proof (prove)\nusing this:\n  (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n    (\\<lambda>(i, j).\n        if i = j then berlekamp_mat u $$ (i, j) - 1\n        else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n  x =\n  0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. gauss_jordan_single\n     (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n       (\\<lambda>(i, j).\n           if i = j then berlekamp_mat u $$ (i, j) - 1\n           else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n    x =\n    0\\<^sub>v (degree u)", "using gauss_jordan_single(1)[of \"transpose_mat ?QI\" \"degree u\" \"degree u\" _ x] x_dim"], ["proof (prove)\nusing this:\n  (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n    (\\<lambda>(i, j).\n        if i = j then berlekamp_mat u $$ (i, j) - 1\n        else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n  x =\n  0\\<^sub>v (degree u)\n  \\<lbrakk>(mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n             (\\<lambda>(i, j).\n                 if i = j then berlekamp_mat u $$ (i, j) - 1\n                 else berlekamp_mat u $$ (i, j)))\\<^sup>T\n           \\<in> carrier_mat (degree u) (degree u);\n   gauss_jordan_single\n    (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T =\n   ?C;\n   x \\<in> carrier_vec (degree u)\\<rbrakk>\n  \\<Longrightarrow> ((mat (dim_row (berlekamp_mat u))\n                       (dim_row (berlekamp_mat u))\n                       (\\<lambda>(i, j).\n                           if i = j then berlekamp_mat u $$ (i, j) - 1\n                           else berlekamp_mat u $$\n                                (i, j)))\\<^sup>T *\\<^sub>v\n                     x =\n                     0\\<^sub>v (degree u)) =\n                    (?C *\\<^sub>v x = 0\\<^sub>v (degree u))\n  x \\<in> carrier_vec (degree u)\n\ngoal (1 subgoal):\n 1. gauss_jordan_single\n     (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n       (\\<lambda>(i, j).\n           if i = j then berlekamp_mat u $$ (i, j) - 1\n           else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n    x =\n    0\\<^sub>v (degree u)", "by auto"], ["proof (state)\nthis:\n  berlekamp_resulting_mat u *\\<^sub>v x = 0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. x \\<in> mat_kernel (berlekamp_resulting_mat u)", "thus ?thesis"], ["proof (prove)\nusing this:\n  berlekamp_resulting_mat u *\\<^sub>v x = 0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. x \\<in> mat_kernel (berlekamp_resulting_mat u)", "by (auto simp add: mat_kernel_def x_dim)"], ["proof (state)\nthis:\n  x \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "abbreviation \"V \\<equiv> kernel.VK (degree u) (berlekamp_resulting_mat u)\""], ["", "private"], ["", "abbreviation \"W \\<equiv> vector_space_poly.vs \n  {v. [v^(CARD('a)) = v] (mod u) \\<and> (degree v < degree u)}\""], ["", "interpretation V: vectorspace class_ring V"], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vectorspace class_ring V", "interpret k: kernel \"(degree u)\" \"(degree u)\" \"(berlekamp_resulting_mat u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Kernel.kernel (degree u) (degree u) (berlekamp_resulting_mat u)", "by (unfold_locales; auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. vectorspace class_ring k.VK", "show \"vectorspace class_ring V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring k.VK", "by intro_locales"], ["proof (state)\nthis:\n  vectorspace class_ring k.VK\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linear_Poly_list_of_vec:\nshows \"(Poly \\<circ> list_of_vec) \\<in> module_hom class_ring V (vector_space_poly.vs {v. [v^(CARD('a)) = v] (mod u)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly \\<circ> list_of_vec\n    \\<in> module_hom class_ring V\n           (vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u)})", "proof (auto simp add: LinearCombinations.module_hom_def Matrix.module_vec_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 3. \\<And>r m.\n       m \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n       Polynomial.smult r (Poly (list_of_vec m))", "fix m1 m2::\" 'a mod_ring vec\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 3. \\<And>r m.\n       m \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n       Polynomial.smult r (Poly (list_of_vec m))", "assume m1: \"m1 \\<in> mat_kernel (berlekamp_resulting_mat u)\"\n  and m2: \"m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\""], ["proof (state)\nthis:\n  m1 \\<in> mat_kernel (berlekamp_resulting_mat u)\n  m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 3. \\<And>r m.\n       m \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n       Polynomial.smult r (Poly (list_of_vec m))", "have m1_rw: \"list_of_vec m1 = map (\\<lambda>n. m1 $ n) [0..<dim_vec m1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_vec m1 = map (($) m1) [0..<dim_vec m1]", "by (transfer, auto simp add: mk_vec_def)"], ["proof (state)\nthis:\n  list_of_vec m1 = map (($) m1) [0..<dim_vec m1]\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 3. \\<And>r m.\n       m \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n       Polynomial.smult r (Poly (list_of_vec m))", "have m2_rw: \"list_of_vec m2 = map (\\<lambda>n. m2 $ n) [0..<dim_vec m2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_vec m2 = map (($) m2) [0..<dim_vec m2]", "by (transfer, auto simp add: mk_vec_def)"], ["proof (state)\nthis:\n  list_of_vec m2 = map (($) m2) [0..<dim_vec m2]\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 3. \\<And>r m.\n       m \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n       Polynomial.smult r (Poly (list_of_vec m))", "have \"m1 \\<in> carrier_vec (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 \\<in> carrier_vec (degree u)", "by (rule mat_kernelD(1)[OF _ m1], auto)"], ["proof (state)\nthis:\n  m1 \\<in> carrier_vec (degree u)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 3. \\<And>r m.\n       m \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n       Polynomial.smult r (Poly (list_of_vec m))", "moreover"], ["proof (state)\nthis:\n  m1 \\<in> carrier_vec (degree u)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 3. \\<And>r m.\n       m \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n       Polynomial.smult r (Poly (list_of_vec m))", "have \"m2 \\<in> carrier_vec (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m2 \\<in> carrier_vec (degree u)", "by (rule mat_kernelD(1)[OF _ m2], auto)"], ["proof (state)\nthis:\n  m2 \\<in> carrier_vec (degree u)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 3. \\<And>r m.\n       m \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n       Polynomial.smult r (Poly (list_of_vec m))", "ultimately"], ["proof (chain)\npicking this:\n  m1 \\<in> carrier_vec (degree u)\n  m2 \\<in> carrier_vec (degree u)", "have dim_eq: \"dim_vec m1 = dim_vec m2\""], ["proof (prove)\nusing this:\n  m1 \\<in> carrier_vec (degree u)\n  m2 \\<in> carrier_vec (degree u)\n\ngoal (1 subgoal):\n 1. dim_vec m1 = dim_vec m2", "by auto"], ["proof (state)\nthis:\n  dim_vec m1 = dim_vec m2\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 3. \\<And>r m.\n       m \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n       Polynomial.smult r (Poly (list_of_vec m))", "show \"Poly (list_of_vec (m1 + m2)) = Poly (list_of_vec m1) + Poly (list_of_vec m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly (list_of_vec (m1 + m2)) =\n    Poly (list_of_vec m1) + Poly (list_of_vec m2)", "unfolding poly_eq_iff m1_rw m2_rw plus_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       coeff\n        (Poly\n          (list_of_vec (vec (dim_vec m2) (\\<lambda>i. m1 $ i + m2 $ i))))\n        n =\n       coeff\n        (Poly (map (($) m1) [0..<dim_vec m1]) +\n         Poly (map (($) m2) [0..<dim_vec m2]))\n        n", "using dim_eq"], ["proof (prove)\nusing this:\n  dim_vec m1 = dim_vec m2\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       coeff\n        (Poly\n          (list_of_vec (vec (dim_vec m2) (\\<lambda>i. m1 $ i + m2 $ i))))\n        n =\n       coeff\n        (Poly (map (($) m1) [0..<dim_vec m1]) +\n         Poly (map (($) m2) [0..<dim_vec m2]))\n        n", "by (transfer', auto simp add: mk_vec_def nth_default_def)"], ["proof (state)\nthis:\n  Poly (list_of_vec (m1 + m2)) =\n  Poly (list_of_vec m1) + Poly (list_of_vec m2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>r m.\n       m \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n       Polynomial.smult r (Poly (list_of_vec m))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>r m.\n       m \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n       Polynomial.smult r (Poly (list_of_vec m))", "fix r m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>r m.\n       m \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n       Polynomial.smult r (Poly (list_of_vec m))", "assume m: \"m \\<in> mat_kernel (berlekamp_resulting_mat u)\""], ["proof (state)\nthis:\n  m \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>r m.\n       m \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n       Polynomial.smult r (Poly (list_of_vec m))", "show \"Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) = smult r (Poly (list_of_vec m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n    Polynomial.smult r (Poly (list_of_vec m))", "unfolding poly_eq_iff list_of_vec_rw_map[of m] smult_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       coeff (Poly (list_of_vec (vec (dim_vec m) (\\<lambda>i. r * m $ i))))\n        n =\n       coeff (Polynomial.smult r (Poly (map (($) m) [0..<dim_vec m]))) n", "by (transfer', auto simp add: mk_vec_def nth_default_def)"], ["proof (state)\nthis:\n  Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n  Polynomial.smult r (Poly (list_of_vec m))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "assume x: \"x \\<in> mat_kernel (berlekamp_resulting_mat u)\""], ["proof (state)\nthis:\n  x \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "show \"[Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "proof (cases \"degree u = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree u = 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. degree u \\<noteq> 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "case True"], ["proof (state)\nthis:\n  degree u = 0\n\ngoal (2 subgoals):\n 1. degree u = 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. degree u \\<noteq> 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "have \"mat_kernel (berlekamp_resulting_mat u) = {0\\<^sub>v 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel (berlekamp_resulting_mat u) = {0\\<^sub>v 0}", "by (rule mat_kernel_berlekamp_resulting_mat_degree_0[OF True])"], ["proof (state)\nthis:\n  mat_kernel (berlekamp_resulting_mat u) = {0\\<^sub>v 0}\n\ngoal (2 subgoals):\n 1. degree u = 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. degree u \\<noteq> 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "hence x_0: \"x = 0\\<^sub>v 0\""], ["proof (prove)\nusing this:\n  mat_kernel (berlekamp_resulting_mat u) = {0\\<^sub>v 0}\n\ngoal (1 subgoal):\n 1. x = 0\\<^sub>v 0", "using x"], ["proof (prove)\nusing this:\n  mat_kernel (berlekamp_resulting_mat u) = {0\\<^sub>v 0}\n  x \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (1 subgoal):\n 1. x = 0\\<^sub>v 0", "by blast"], ["proof (state)\nthis:\n  x = 0\\<^sub>v 0\n\ngoal (2 subgoals):\n 1. degree u = 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. degree u \\<noteq> 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "by (auto simp add: zero_power x_0 cong_def)"], ["proof (state)\nthis:\n  [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n\ngoal (1 subgoal):\n 1. degree u \\<noteq> 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree u \\<noteq> 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "case False"], ["proof (state)\nthis:\n  degree u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree u \\<noteq> 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "note deg_u = False"], ["proof (state)\nthis:\n  degree u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree u \\<noteq> 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "let ?QI=\"(mat (degree u) (degree u)\n      (\\<lambda>(i, j). if i = j then berlekamp_mat u $$ (i, j) - 1 else berlekamp_mat u $$ (i, j)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "let ?H=\"vec_of_list (coeffs (Poly (list_of_vec x)) @ replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "have x_dim: \"dim_vec x = degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec x = degree u", "using x"], ["proof (prove)\nusing this:\n  x \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (1 subgoal):\n 1. dim_vec x = degree u", "unfolding mat_kernel_def"], ["proof (prove)\nusing this:\n  x \\<in> {v \\<in> carrier_vec (dim_col (berlekamp_resulting_mat u)).\n           berlekamp_resulting_mat u *\\<^sub>v v =\n           0\\<^sub>v (dim_row (berlekamp_resulting_mat u))}\n\ngoal (1 subgoal):\n 1. dim_vec x = degree u", "by auto"], ["proof (state)\nthis:\n  dim_vec x = degree u\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "hence x_carrier[simp]: \"x \\<in> carrier_vec (degree u)\""], ["proof (prove)\nusing this:\n  dim_vec x = degree u\n\ngoal (1 subgoal):\n 1. x \\<in> carrier_vec (degree u)", "by (metis carrier_vec_dim_vec)"], ["proof (state)\nthis:\n  x \\<in> carrier_vec (degree u)\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "have x_kernel: \"berlekamp_resulting_mat u *\\<^sub>v x = 0\\<^sub>v (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. berlekamp_resulting_mat u *\\<^sub>v x = 0\\<^sub>v (degree u)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (1 subgoal):\n 1. berlekamp_resulting_mat u *\\<^sub>v x = 0\\<^sub>v (degree u)", "unfolding mat_kernel_def"], ["proof (prove)\nusing this:\n  x \\<in> {v \\<in> carrier_vec (dim_col (berlekamp_resulting_mat u)).\n           berlekamp_resulting_mat u *\\<^sub>v v =\n           0\\<^sub>v (dim_row (berlekamp_resulting_mat u))}\n\ngoal (1 subgoal):\n 1. berlekamp_resulting_mat u *\\<^sub>v x = 0\\<^sub>v (degree u)", "by auto"], ["proof (state)\nthis:\n  berlekamp_resulting_mat u *\\<^sub>v x = 0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "have t_QI_x_0: \"(transpose_mat ?QI) *\\<^sub>v x = 0\\<^sub>v (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n    x =\n    0\\<^sub>v (degree u)", "using gauss_jordan_single(1)[of \"(transpose_mat ?QI)\" \"degree u\" \"degree u\" \"gauss_jordan_single (transpose_mat ?QI)\" x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(mat (degree u) (degree u)\n             (\\<lambda>(i, j).\n                 if i = j then berlekamp_mat u $$ (i, j) - 1\n                 else berlekamp_mat u $$ (i, j)))\\<^sup>T\n           \\<in> carrier_mat (degree u) (degree u);\n   gauss_jordan_single\n    (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T =\n   gauss_jordan_single\n    (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T;\n   x \\<in> carrier_vec (degree u)\\<rbrakk>\n  \\<Longrightarrow> ((mat (degree u) (degree u)\n                       (\\<lambda>(i, j).\n                           if i = j then berlekamp_mat u $$ (i, j) - 1\n                           else berlekamp_mat u $$\n                                (i, j)))\\<^sup>T *\\<^sub>v\n                     x =\n                     0\\<^sub>v (degree u)) =\n                    (gauss_jordan_single\n                      (mat (degree u) (degree u)\n                        (\\<lambda>(i, j).\n                            if i = j then berlekamp_mat u $$ (i, j) - 1\n                            else berlekamp_mat u $$\n                                 (i, j)))\\<^sup>T *\\<^sub>v\n                     x =\n                     0\\<^sub>v (degree u))\n\ngoal (1 subgoal):\n 1. (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n    x =\n    0\\<^sub>v (degree u)", "using x_kernel"], ["proof (prove)\nusing this:\n  \\<lbrakk>(mat (degree u) (degree u)\n             (\\<lambda>(i, j).\n                 if i = j then berlekamp_mat u $$ (i, j) - 1\n                 else berlekamp_mat u $$ (i, j)))\\<^sup>T\n           \\<in> carrier_mat (degree u) (degree u);\n   gauss_jordan_single\n    (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T =\n   gauss_jordan_single\n    (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T;\n   x \\<in> carrier_vec (degree u)\\<rbrakk>\n  \\<Longrightarrow> ((mat (degree u) (degree u)\n                       (\\<lambda>(i, j).\n                           if i = j then berlekamp_mat u $$ (i, j) - 1\n                           else berlekamp_mat u $$\n                                (i, j)))\\<^sup>T *\\<^sub>v\n                     x =\n                     0\\<^sub>v (degree u)) =\n                    (gauss_jordan_single\n                      (mat (degree u) (degree u)\n                        (\\<lambda>(i, j).\n                            if i = j then berlekamp_mat u $$ (i, j) - 1\n                            else berlekamp_mat u $$\n                                 (i, j)))\\<^sup>T *\\<^sub>v\n                     x =\n                     0\\<^sub>v (degree u))\n  berlekamp_resulting_mat u *\\<^sub>v x = 0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n    x =\n    0\\<^sub>v (degree u)", "unfolding berlekamp_resulting_mat_def Let_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(mat (degree u) (degree u)\n             (\\<lambda>(i, j).\n                 if i = j then berlekamp_mat u $$ (i, j) - 1\n                 else berlekamp_mat u $$ (i, j)))\\<^sup>T\n           \\<in> carrier_mat (degree u) (degree u);\n   gauss_jordan_single\n    (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T =\n   gauss_jordan_single\n    (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T;\n   x \\<in> carrier_vec (degree u)\\<rbrakk>\n  \\<Longrightarrow> ((mat (degree u) (degree u)\n                       (\\<lambda>(i, j).\n                           if i = j then berlekamp_mat u $$ (i, j) - 1\n                           else berlekamp_mat u $$\n                                (i, j)))\\<^sup>T *\\<^sub>v\n                     x =\n                     0\\<^sub>v (degree u)) =\n                    (gauss_jordan_single\n                      (mat (degree u) (degree u)\n                        (\\<lambda>(i, j).\n                            if i = j then berlekamp_mat u $$ (i, j) - 1\n                            else berlekamp_mat u $$\n                                 (i, j)))\\<^sup>T *\\<^sub>v\n                     x =\n                     0\\<^sub>v (degree u))\n  gauss_jordan_single\n   (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n     (\\<lambda>(i, j).\n         if i = j then berlekamp_mat u $$ (i, j) - 1\n         else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n  x =\n  0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n    x =\n    0\\<^sub>v (degree u)", "by auto"], ["proof (state)\nthis:\n  (mat (degree u) (degree u)\n    (\\<lambda>(i, j).\n        if i = j then berlekamp_mat u $$ (i, j) - 1\n        else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n  x =\n  0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "have l: \"(list_of_vec x) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_vec x \\<noteq> []", "by (auto simp add: list_of_vec_rw_map vec_of_dim_0[symmetric] deg_u x_dim)"], ["proof (state)\nthis:\n  list_of_vec x \\<noteq> []\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "have deg_le: \"degree (Poly (list_of_vec x)) < degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec x)) < degree u", "using degree_Poly_list_of_vec"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier_vec ?n; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> degree (Poly (list_of_vec ?x)) < ?n\n\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec x)) < degree u", "using x_carrier deg_u"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier_vec ?n; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> degree (Poly (list_of_vec ?x)) < ?n\n  x \\<in> carrier_vec (degree u)\n  degree u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec x)) < degree u", "by blast"], ["proof (state)\nthis:\n  degree (Poly (list_of_vec x)) < degree u\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "show \"[Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "proof (unfold equation_13[OF deg_le])"], ["proof (state)\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)", "have QR_rw: \"?QI = berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (degree u) (degree u)\n     (\\<lambda>(i, j).\n         if i = j then berlekamp_mat u $$ (i, j) - 1\n         else berlekamp_mat u $$ (i, j)) =\n    berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u))", "by auto"], ["proof (state)\nthis:\n  mat (degree u) (degree u)\n   (\\<lambda>(i, j).\n       if i = j then berlekamp_mat u $$ (i, j) - 1\n       else berlekamp_mat u $$ (i, j)) =\n  berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u))\n\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)", "have \"dim_row (berlekamp_mat u) = dim_vec ?H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (berlekamp_mat u) =\n    dim_vec\n     (vec_of_list\n       (coeffs (Poly (list_of_vec x)) @\n        replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0))", "by (auto, metis le_add_diff_inverse length_list_of_vec length_strip_while_le x_dim)"], ["proof (state)\nthis:\n  dim_row (berlekamp_mat u) =\n  dim_vec\n   (vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0))\n\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)", "moreover"], ["proof (state)\nthis:\n  dim_row (berlekamp_mat u) =\n  dim_vec\n   (vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0))\n\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)", "have \"?H \\<in> mat_kernel (transpose_mat (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> mat_kernel\n           (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> mat_kernel\n           (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T", "have Hx: \"?H = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    x", "proof (unfold vec_eq_iff, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (strip_while ((=) 0) (list_of_vec x)) +\n    (degree u - length (strip_while ((=) 0) (list_of_vec x))) =\n    dim_vec x\n 2. \\<And>i.\n       i < dim_vec x \\<Longrightarrow>\n       vec_of_list\n        (strip_while ((=) 0) (list_of_vec x) @\n         replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n          0) $\n       i =\n       x $ i", "let ?H'=\"vec_of_list (strip_while ((=) 0) (list_of_vec x)\n              @ replicate (degree u - length (strip_while ((=) 0) (list_of_vec x))) 0)\""], ["proof (state)\ngoal (2 subgoals):\n 1. length (strip_while ((=) 0) (list_of_vec x)) +\n    (degree u - length (strip_while ((=) 0) (list_of_vec x))) =\n    dim_vec x\n 2. \\<And>i.\n       i < dim_vec x \\<Longrightarrow>\n       vec_of_list\n        (strip_while ((=) 0) (list_of_vec x) @\n         replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n          0) $\n       i =\n       x $ i", "show \"length (strip_while ((=) 0) (list_of_vec x))\n              + (degree u - length (strip_while ((=) 0) (list_of_vec x))) = dim_vec x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (strip_while ((=) 0) (list_of_vec x)) +\n    (degree u - length (strip_while ((=) 0) (list_of_vec x))) =\n    dim_vec x", "by (metis le_add_diff_inverse length_list_of_vec length_strip_while_le x_dim)"], ["proof (state)\nthis:\n  length (strip_while ((=) 0) (list_of_vec x)) +\n  (degree u - length (strip_while ((=) 0) (list_of_vec x))) =\n  dim_vec x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec x \\<Longrightarrow>\n       vec_of_list\n        (strip_while ((=) 0) (list_of_vec x) @\n         replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n          0) $\n       i =\n       x $ i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec x \\<Longrightarrow>\n       vec_of_list\n        (strip_while ((=) 0) (list_of_vec x) @\n         replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n          0) $\n       i =\n       x $ i", "assume i: \"i < dim_vec x\""], ["proof (state)\nthis:\n  i < dim_vec x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec x \\<Longrightarrow>\n       vec_of_list\n        (strip_while ((=) 0) (list_of_vec x) @\n         replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n          0) $\n       i =\n       x $ i", "have \"?H $ i =  coeff (Poly (list_of_vec x)) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) $\n    i =\n    coeff (Poly (list_of_vec x)) i", "proof (rule vec_of_list_coeffs_replicate_nth[OF _ deg_le])"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<in> {..<degree u}", "show \"i \\<in> {..<degree u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> {..<degree u}", "using x_dim i"], ["proof (prove)\nusing this:\n  dim_vec x = degree u\n  i < dim_vec x\n\ngoal (1 subgoal):\n 1. i \\<in> {..<degree u}", "by (auto, linarith)"], ["proof (state)\nthis:\n  i \\<in> {..<degree u}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) $\n  i =\n  coeff (Poly (list_of_vec x)) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec x \\<Longrightarrow>\n       vec_of_list\n        (strip_while ((=) 0) (list_of_vec x) @\n         replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n          0) $\n       i =\n       x $ i", "also"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) $\n  i =\n  coeff (Poly (list_of_vec x)) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec x \\<Longrightarrow>\n       vec_of_list\n        (strip_while ((=) 0) (list_of_vec x) @\n         replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n          0) $\n       i =\n       x $ i", "have \"... = x $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (Poly (list_of_vec x)) i = x $ i", "by (rule coeff_Poly_list_of_vec_nth'[OF i])"], ["proof (state)\nthis:\n  coeff (Poly (list_of_vec x)) i = x $ i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec x \\<Longrightarrow>\n       vec_of_list\n        (strip_while ((=) 0) (list_of_vec x) @\n         replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n          0) $\n       i =\n       x $ i", "finally"], ["proof (chain)\npicking this:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) $\n  i =\n  x $ i", "show \"?H' $ i = x $ i\""], ["proof (prove)\nusing this:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) $\n  i =\n  x $ i\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (strip_while ((=) 0) (list_of_vec x) @\n      replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n       0) $\n    i =\n    x $ i", "by auto"], ["proof (state)\nthis:\n  vec_of_list\n   (strip_while ((=) 0) (list_of_vec x) @\n    replicate (degree u - length (strip_while ((=) 0) (list_of_vec x))) 0) $\n  i =\n  x $ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n  x\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> mat_kernel\n           (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T", "have \"?H \\<in> carrier_vec (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> carrier_vec (degree u)", "using deg_le dim_vec_of_list_h Hx"], ["proof (prove)\nusing this:\n  degree (Poly (list_of_vec x)) < degree u\n  degree ?h < degree ?u \\<Longrightarrow>\n  dim_vec\n   (vec_of_list\n     (coeffs ?h @ replicate (degree ?u - length (coeffs ?h)) (0::?'b))) =\n  degree ?u\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n  x\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> carrier_vec (degree u)", "by auto"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> carrier_vec (degree u)\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> mat_kernel\n           (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T", "moreover"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> carrier_vec (degree u)\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> mat_kernel\n           (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T", "have \"transpose_mat (berlekamp_mat u - 1\\<^sub>m (degree u)) *\\<^sub>v ?H = 0\\<^sub>v (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (berlekamp_mat u - 1\\<^sub>m (degree u))\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    0\\<^sub>v (degree u)", "using t_QI_x_0 Hx QR_rw"], ["proof (prove)\nusing this:\n  (mat (degree u) (degree u)\n    (\\<lambda>(i, j).\n        if i = j then berlekamp_mat u $$ (i, j) - 1\n        else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n  x =\n  0\\<^sub>v (degree u)\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n  x\n  mat (degree u) (degree u)\n   (\\<lambda>(i, j).\n       if i = j then berlekamp_mat u $$ (i, j) - 1\n       else berlekamp_mat u $$ (i, j)) =\n  berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u))\n\ngoal (1 subgoal):\n 1. (berlekamp_mat u - 1\\<^sub>m (degree u))\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    0\\<^sub>v (degree u)", "by auto"], ["proof (state)\nthis:\n  (berlekamp_mat u - 1\\<^sub>m (degree u))\\<^sup>T *\\<^sub>v\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n  0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> mat_kernel\n           (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T", "ultimately"], ["proof (chain)\npicking this:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> carrier_vec (degree u)\n  (berlekamp_mat u - 1\\<^sub>m (degree u))\\<^sup>T *\\<^sub>v\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n  0\\<^sub>v (degree u)", "show ?thesis"], ["proof (prove)\nusing this:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> carrier_vec (degree u)\n  (berlekamp_mat u - 1\\<^sub>m (degree u))\\<^sup>T *\\<^sub>v\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n  0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> mat_kernel\n           (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T", "by (auto simp add: mat_kernel_def)"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> mat_kernel\n         (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> mat_kernel\n         (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)", "ultimately"], ["proof (chain)\npicking this:\n  dim_row (berlekamp_mat u) =\n  dim_vec\n   (vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0))\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> mat_kernel\n         (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T", "show \"transpose_mat (berlekamp_mat u) *\\<^sub>v ?H = ?H\""], ["proof (prove)\nusing this:\n  dim_row (berlekamp_mat u) =\n  dim_vec\n   (vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0))\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> mat_kernel\n         (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)", "using system_if_mat_kernel[of \"berlekamp_mat u\" ?H]"], ["proof (prove)\nusing this:\n  dim_row (berlekamp_mat u) =\n  dim_vec\n   (vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0))\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> mat_kernel\n         (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T\n  \\<lbrakk>dim_row (berlekamp_mat u) = dim_col (berlekamp_mat u);\n   dim_row (berlekamp_mat u) =\n   dim_vec\n    (vec_of_list\n      (coeffs (Poly (list_of_vec x)) @\n       replicate (degree u - length (coeffs (Poly (list_of_vec x))))\n        0))\\<rbrakk>\n  \\<Longrightarrow> ((berlekamp_mat u)\\<^sup>T *\\<^sub>v\n                     vec_of_list\n                      (coeffs (Poly (list_of_vec x)) @\n                       replicate\n                        (degree u - length (coeffs (Poly (list_of_vec x))))\n                        0) =\n                     vec_of_list\n                      (coeffs (Poly (list_of_vec x)) @\n                       replicate\n                        (degree u - length (coeffs (Poly (list_of_vec x))))\n                        0)) =\n                    (vec_of_list\n                      (coeffs (Poly (list_of_vec x)) @\n                       replicate\n                        (degree u - length (coeffs (Poly (list_of_vec x))))\n                        0)\n                     \\<in> mat_kernel\n                            (berlekamp_mat u -\n                             1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)", "by auto"], ["proof (state)\nthis:\n  (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linear_Poly_list_of_vec':\n  assumes \"degree u > 0\"\n  shows \"(Poly \\<circ> list_of_vec) \\<in> module_hom R V W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly \\<circ> list_of_vec\n    \\<in> module_hom R V\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "proof (auto simp add: LinearCombinations.module_hom_def Matrix.module_vec_def)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u\n 3. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 4. \\<And>r m.\n       \\<lbrakk>r \\<in> carrier R;\n        m \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n                         Polynomial.smult r (Poly (list_of_vec m))", "fix m1 m2::\" 'a mod_ring vec\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u\n 3. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 4. \\<And>r m.\n       \\<lbrakk>r \\<in> carrier R;\n        m \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n                         Polynomial.smult r (Poly (list_of_vec m))", "assume m1: \"m1 \\<in> mat_kernel (berlekamp_resulting_mat u)\"\n  and m2: \"m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\""], ["proof (state)\nthis:\n  m1 \\<in> mat_kernel (berlekamp_resulting_mat u)\n  m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u\n 3. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 4. \\<And>r m.\n       \\<lbrakk>r \\<in> carrier R;\n        m \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n                         Polynomial.smult r (Poly (list_of_vec m))", "have m1_rw: \"list_of_vec m1 = map (\\<lambda>n. m1 $ n) [0..<dim_vec m1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_vec m1 = map (($) m1) [0..<dim_vec m1]", "by (transfer, auto simp add: mk_vec_def)"], ["proof (state)\nthis:\n  list_of_vec m1 = map (($) m1) [0..<dim_vec m1]\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u\n 3. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 4. \\<And>r m.\n       \\<lbrakk>r \\<in> carrier R;\n        m \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n                         Polynomial.smult r (Poly (list_of_vec m))", "have m2_rw: \"list_of_vec m2 = map (\\<lambda>n. m2 $ n) [0..<dim_vec m2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_vec m2 = map (($) m2) [0..<dim_vec m2]", "by (transfer, auto simp add: mk_vec_def)"], ["proof (state)\nthis:\n  list_of_vec m2 = map (($) m2) [0..<dim_vec m2]\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u\n 3. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 4. \\<And>r m.\n       \\<lbrakk>r \\<in> carrier R;\n        m \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n                         Polynomial.smult r (Poly (list_of_vec m))", "have \"m1 \\<in> carrier_vec (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 \\<in> carrier_vec (degree u)", "by (rule mat_kernelD(1)[OF _ m1], auto)"], ["proof (state)\nthis:\n  m1 \\<in> carrier_vec (degree u)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u\n 3. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 4. \\<And>r m.\n       \\<lbrakk>r \\<in> carrier R;\n        m \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n                         Polynomial.smult r (Poly (list_of_vec m))", "moreover"], ["proof (state)\nthis:\n  m1 \\<in> carrier_vec (degree u)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u\n 3. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 4. \\<And>r m.\n       \\<lbrakk>r \\<in> carrier R;\n        m \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n                         Polynomial.smult r (Poly (list_of_vec m))", "have \"m2 \\<in> carrier_vec (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m2 \\<in> carrier_vec (degree u)", "by (rule mat_kernelD(1)[OF _ m2], auto)"], ["proof (state)\nthis:\n  m2 \\<in> carrier_vec (degree u)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u\n 3. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 4. \\<And>r m.\n       \\<lbrakk>r \\<in> carrier R;\n        m \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n                         Polynomial.smult r (Poly (list_of_vec m))", "ultimately"], ["proof (chain)\npicking this:\n  m1 \\<in> carrier_vec (degree u)\n  m2 \\<in> carrier_vec (degree u)", "have dim_eq: \"dim_vec m1 = dim_vec m2\""], ["proof (prove)\nusing this:\n  m1 \\<in> carrier_vec (degree u)\n  m2 \\<in> carrier_vec (degree u)\n\ngoal (1 subgoal):\n 1. dim_vec m1 = dim_vec m2", "by auto"], ["proof (state)\nthis:\n  dim_vec m1 = dim_vec m2\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u\n 3. \\<And>m1 m2.\n       \\<lbrakk>m1 \\<in> mat_kernel (berlekamp_resulting_mat u);\n        m2 \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (m1 + m2)) =\n                         Poly (list_of_vec m1) + Poly (list_of_vec m2)\n 4. \\<And>r m.\n       \\<lbrakk>r \\<in> carrier R;\n        m \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n                         Polynomial.smult r (Poly (list_of_vec m))", "show \"Poly (list_of_vec (m1 + m2)) = Poly (list_of_vec m1) + Poly (list_of_vec m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly (list_of_vec (m1 + m2)) =\n    Poly (list_of_vec m1) + Poly (list_of_vec m2)", "unfolding poly_eq_iff m1_rw m2_rw plus_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       coeff\n        (Poly\n          (list_of_vec (vec (dim_vec m2) (\\<lambda>i. m1 $ i + m2 $ i))))\n        n =\n       coeff\n        (Poly (map (($) m1) [0..<dim_vec m1]) +\n         Poly (map (($) m2) [0..<dim_vec m2]))\n        n", "using dim_eq"], ["proof (prove)\nusing this:\n  dim_vec m1 = dim_vec m2\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       coeff\n        (Poly\n          (list_of_vec (vec (dim_vec m2) (\\<lambda>i. m1 $ i + m2 $ i))))\n        n =\n       coeff\n        (Poly (map (($) m1) [0..<dim_vec m1]) +\n         Poly (map (($) m2) [0..<dim_vec m2]))\n        n", "by (transfer', auto simp add: mk_vec_def nth_default_def)"], ["proof (state)\nthis:\n  Poly (list_of_vec (m1 + m2)) =\n  Poly (list_of_vec m1) + Poly (list_of_vec m2)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u\n 3. \\<And>r m.\n       \\<lbrakk>r \\<in> carrier R;\n        m \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n                         Polynomial.smult r (Poly (list_of_vec m))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u\n 3. \\<And>r m.\n       \\<lbrakk>r \\<in> carrier R;\n        m \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n                         Polynomial.smult r (Poly (list_of_vec m))", "fix r m"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u\n 3. \\<And>r m.\n       \\<lbrakk>r \\<in> carrier R;\n        m \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n                         Polynomial.smult r (Poly (list_of_vec m))", "assume m: \"m \\<in> mat_kernel (berlekamp_resulting_mat u)\""], ["proof (state)\nthis:\n  m \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u\n 3. \\<And>r m.\n       \\<lbrakk>r \\<in> carrier R;\n        m \\<in> mat_kernel (berlekamp_resulting_mat u)\\<rbrakk>\n       \\<Longrightarrow> Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n                         Polynomial.smult r (Poly (list_of_vec m))", "show \"Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) = smult r (Poly (list_of_vec m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n    Polynomial.smult r (Poly (list_of_vec m))", "unfolding poly_eq_iff list_of_vec_rw_map[of m] smult_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       coeff (Poly (list_of_vec (vec (dim_vec m) (\\<lambda>i. r * m $ i))))\n        n =\n       coeff (Polynomial.smult r (Poly (map (($) m) [0..<dim_vec m]))) n", "by (transfer', auto simp add: mk_vec_def nth_default_def)"], ["proof (state)\nthis:\n  Poly (list_of_vec (r \\<cdot>\\<^sub>v m)) =\n  Polynomial.smult r (Poly (list_of_vec m))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u", "assume x: \"x \\<in> mat_kernel (berlekamp_resulting_mat u)\""], ["proof (state)\nthis:\n  x \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u", "show \"[Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "proof (cases \"degree u = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree u = 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. degree u \\<noteq> 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "case True"], ["proof (state)\nthis:\n  degree u = 0\n\ngoal (2 subgoals):\n 1. degree u = 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. degree u \\<noteq> 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "have \"mat_kernel (berlekamp_resulting_mat u) = {0\\<^sub>v 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel (berlekamp_resulting_mat u) = {0\\<^sub>v 0}", "by (rule mat_kernel_berlekamp_resulting_mat_degree_0[OF True])"], ["proof (state)\nthis:\n  mat_kernel (berlekamp_resulting_mat u) = {0\\<^sub>v 0}\n\ngoal (2 subgoals):\n 1. degree u = 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. degree u \\<noteq> 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "hence x_0: \"x = 0\\<^sub>v 0\""], ["proof (prove)\nusing this:\n  mat_kernel (berlekamp_resulting_mat u) = {0\\<^sub>v 0}\n\ngoal (1 subgoal):\n 1. x = 0\\<^sub>v 0", "using x"], ["proof (prove)\nusing this:\n  mat_kernel (berlekamp_resulting_mat u) = {0\\<^sub>v 0}\n  x \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (1 subgoal):\n 1. x = 0\\<^sub>v 0", "by blast"], ["proof (state)\nthis:\n  x = 0\\<^sub>v 0\n\ngoal (2 subgoals):\n 1. degree u = 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n 2. degree u \\<noteq> 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "by (auto simp add: zero_power x_0 cong_def)"], ["proof (state)\nthis:\n  [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n\ngoal (1 subgoal):\n 1. degree u \\<noteq> 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree u \\<noteq> 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "case False"], ["proof (state)\nthis:\n  degree u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree u \\<noteq> 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "note deg_u = False"], ["proof (state)\nthis:\n  degree u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree u \\<noteq> 0 \\<Longrightarrow>\n    [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "let ?QI=\"(mat (degree u) (degree u)\n      (\\<lambda>(i, j). if i = j then berlekamp_mat u $$ (i, j) - 1 else berlekamp_mat u $$ (i, j)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "let ?H=\"vec_of_list (coeffs (Poly (list_of_vec x)) @ replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "have x_dim: \"dim_vec x = degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec x = degree u", "using x"], ["proof (prove)\nusing this:\n  x \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (1 subgoal):\n 1. dim_vec x = degree u", "unfolding mat_kernel_def"], ["proof (prove)\nusing this:\n  x \\<in> {v \\<in> carrier_vec (dim_col (berlekamp_resulting_mat u)).\n           berlekamp_resulting_mat u *\\<^sub>v v =\n           0\\<^sub>v (dim_row (berlekamp_resulting_mat u))}\n\ngoal (1 subgoal):\n 1. dim_vec x = degree u", "by auto"], ["proof (state)\nthis:\n  dim_vec x = degree u\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "hence x_carrier[simp]: \"x \\<in> carrier_vec (degree u)\""], ["proof (prove)\nusing this:\n  dim_vec x = degree u\n\ngoal (1 subgoal):\n 1. x \\<in> carrier_vec (degree u)", "by (metis carrier_vec_dim_vec)"], ["proof (state)\nthis:\n  x \\<in> carrier_vec (degree u)\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "have x_kernel: \"berlekamp_resulting_mat u *\\<^sub>v x = 0\\<^sub>v (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. berlekamp_resulting_mat u *\\<^sub>v x = 0\\<^sub>v (degree u)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (1 subgoal):\n 1. berlekamp_resulting_mat u *\\<^sub>v x = 0\\<^sub>v (degree u)", "unfolding mat_kernel_def"], ["proof (prove)\nusing this:\n  x \\<in> {v \\<in> carrier_vec (dim_col (berlekamp_resulting_mat u)).\n           berlekamp_resulting_mat u *\\<^sub>v v =\n           0\\<^sub>v (dim_row (berlekamp_resulting_mat u))}\n\ngoal (1 subgoal):\n 1. berlekamp_resulting_mat u *\\<^sub>v x = 0\\<^sub>v (degree u)", "by auto"], ["proof (state)\nthis:\n  berlekamp_resulting_mat u *\\<^sub>v x = 0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "have t_QI_x_0: \"(transpose_mat ?QI) *\\<^sub>v x = 0\\<^sub>v (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n    x =\n    0\\<^sub>v (degree u)", "using gauss_jordan_single(1)[of \"(transpose_mat ?QI)\" \"degree u\" \"degree u\" \"gauss_jordan_single (transpose_mat ?QI)\" x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(mat (degree u) (degree u)\n             (\\<lambda>(i, j).\n                 if i = j then berlekamp_mat u $$ (i, j) - 1\n                 else berlekamp_mat u $$ (i, j)))\\<^sup>T\n           \\<in> carrier_mat (degree u) (degree u);\n   gauss_jordan_single\n    (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T =\n   gauss_jordan_single\n    (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T;\n   x \\<in> carrier_vec (degree u)\\<rbrakk>\n  \\<Longrightarrow> ((mat (degree u) (degree u)\n                       (\\<lambda>(i, j).\n                           if i = j then berlekamp_mat u $$ (i, j) - 1\n                           else berlekamp_mat u $$\n                                (i, j)))\\<^sup>T *\\<^sub>v\n                     x =\n                     0\\<^sub>v (degree u)) =\n                    (gauss_jordan_single\n                      (mat (degree u) (degree u)\n                        (\\<lambda>(i, j).\n                            if i = j then berlekamp_mat u $$ (i, j) - 1\n                            else berlekamp_mat u $$\n                                 (i, j)))\\<^sup>T *\\<^sub>v\n                     x =\n                     0\\<^sub>v (degree u))\n\ngoal (1 subgoal):\n 1. (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n    x =\n    0\\<^sub>v (degree u)", "using x_kernel"], ["proof (prove)\nusing this:\n  \\<lbrakk>(mat (degree u) (degree u)\n             (\\<lambda>(i, j).\n                 if i = j then berlekamp_mat u $$ (i, j) - 1\n                 else berlekamp_mat u $$ (i, j)))\\<^sup>T\n           \\<in> carrier_mat (degree u) (degree u);\n   gauss_jordan_single\n    (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T =\n   gauss_jordan_single\n    (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T;\n   x \\<in> carrier_vec (degree u)\\<rbrakk>\n  \\<Longrightarrow> ((mat (degree u) (degree u)\n                       (\\<lambda>(i, j).\n                           if i = j then berlekamp_mat u $$ (i, j) - 1\n                           else berlekamp_mat u $$\n                                (i, j)))\\<^sup>T *\\<^sub>v\n                     x =\n                     0\\<^sub>v (degree u)) =\n                    (gauss_jordan_single\n                      (mat (degree u) (degree u)\n                        (\\<lambda>(i, j).\n                            if i = j then berlekamp_mat u $$ (i, j) - 1\n                            else berlekamp_mat u $$\n                                 (i, j)))\\<^sup>T *\\<^sub>v\n                     x =\n                     0\\<^sub>v (degree u))\n  berlekamp_resulting_mat u *\\<^sub>v x = 0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n    x =\n    0\\<^sub>v (degree u)", "unfolding berlekamp_resulting_mat_def Let_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(mat (degree u) (degree u)\n             (\\<lambda>(i, j).\n                 if i = j then berlekamp_mat u $$ (i, j) - 1\n                 else berlekamp_mat u $$ (i, j)))\\<^sup>T\n           \\<in> carrier_mat (degree u) (degree u);\n   gauss_jordan_single\n    (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T =\n   gauss_jordan_single\n    (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T;\n   x \\<in> carrier_vec (degree u)\\<rbrakk>\n  \\<Longrightarrow> ((mat (degree u) (degree u)\n                       (\\<lambda>(i, j).\n                           if i = j then berlekamp_mat u $$ (i, j) - 1\n                           else berlekamp_mat u $$\n                                (i, j)))\\<^sup>T *\\<^sub>v\n                     x =\n                     0\\<^sub>v (degree u)) =\n                    (gauss_jordan_single\n                      (mat (degree u) (degree u)\n                        (\\<lambda>(i, j).\n                            if i = j then berlekamp_mat u $$ (i, j) - 1\n                            else berlekamp_mat u $$\n                                 (i, j)))\\<^sup>T *\\<^sub>v\n                     x =\n                     0\\<^sub>v (degree u))\n  gauss_jordan_single\n   (mat (dim_row (berlekamp_mat u)) (dim_row (berlekamp_mat u))\n     (\\<lambda>(i, j).\n         if i = j then berlekamp_mat u $$ (i, j) - 1\n         else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n  x =\n  0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. (mat (degree u) (degree u)\n      (\\<lambda>(i, j).\n          if i = j then berlekamp_mat u $$ (i, j) - 1\n          else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n    x =\n    0\\<^sub>v (degree u)", "by auto"], ["proof (state)\nthis:\n  (mat (degree u) (degree u)\n    (\\<lambda>(i, j).\n        if i = j then berlekamp_mat u $$ (i, j) - 1\n        else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n  x =\n  0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "have l: \"(list_of_vec x) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_vec x \\<noteq> []", "by (auto simp add: list_of_vec_rw_map vec_of_dim_0[symmetric] deg_u x_dim)"], ["proof (state)\nthis:\n  list_of_vec x \\<noteq> []\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "have deg_le: \"degree (Poly (list_of_vec x)) < degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec x)) < degree u", "using degree_Poly_list_of_vec"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier_vec ?n; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> degree (Poly (list_of_vec ?x)) < ?n\n\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec x)) < degree u", "using x_carrier deg_u"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier_vec ?n; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> degree (Poly (list_of_vec ?x)) < ?n\n  x \\<in> carrier_vec (degree u)\n  degree u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec x)) < degree u", "by blast"], ["proof (state)\nthis:\n  degree (Poly (list_of_vec x)) < degree u\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "show \"[Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "proof (unfold equation_13[OF deg_le])"], ["proof (state)\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)", "have QR_rw: \"?QI = berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (degree u) (degree u)\n     (\\<lambda>(i, j).\n         if i = j then berlekamp_mat u $$ (i, j) - 1\n         else berlekamp_mat u $$ (i, j)) =\n    berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u))", "by auto"], ["proof (state)\nthis:\n  mat (degree u) (degree u)\n   (\\<lambda>(i, j).\n       if i = j then berlekamp_mat u $$ (i, j) - 1\n       else berlekamp_mat u $$ (i, j)) =\n  berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u))\n\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)", "have \"dim_row (berlekamp_mat u) = dim_vec ?H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (berlekamp_mat u) =\n    dim_vec\n     (vec_of_list\n       (coeffs (Poly (list_of_vec x)) @\n        replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0))", "by (auto, metis le_add_diff_inverse length_list_of_vec length_strip_while_le x_dim)"], ["proof (state)\nthis:\n  dim_row (berlekamp_mat u) =\n  dim_vec\n   (vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0))\n\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)", "moreover"], ["proof (state)\nthis:\n  dim_row (berlekamp_mat u) =\n  dim_vec\n   (vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0))\n\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)", "have \"?H \\<in> mat_kernel (transpose_mat (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> mat_kernel\n           (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> mat_kernel\n           (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T", "have Hx: \"?H = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    x", "proof (unfold vec_eq_iff, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (strip_while ((=) 0) (list_of_vec x)) +\n    (degree u - length (strip_while ((=) 0) (list_of_vec x))) =\n    dim_vec x\n 2. \\<And>i.\n       i < dim_vec x \\<Longrightarrow>\n       vec_of_list\n        (strip_while ((=) 0) (list_of_vec x) @\n         replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n          0) $\n       i =\n       x $ i", "let ?H'=\"vec_of_list (strip_while ((=) 0) (list_of_vec x)\n              @ replicate (degree u - length (strip_while ((=) 0) (list_of_vec x))) 0)\""], ["proof (state)\ngoal (2 subgoals):\n 1. length (strip_while ((=) 0) (list_of_vec x)) +\n    (degree u - length (strip_while ((=) 0) (list_of_vec x))) =\n    dim_vec x\n 2. \\<And>i.\n       i < dim_vec x \\<Longrightarrow>\n       vec_of_list\n        (strip_while ((=) 0) (list_of_vec x) @\n         replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n          0) $\n       i =\n       x $ i", "show \"length (strip_while ((=) 0) (list_of_vec x))\n              + (degree u - length (strip_while ((=) 0) (list_of_vec x))) = dim_vec x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (strip_while ((=) 0) (list_of_vec x)) +\n    (degree u - length (strip_while ((=) 0) (list_of_vec x))) =\n    dim_vec x", "by (metis le_add_diff_inverse length_list_of_vec length_strip_while_le x_dim)"], ["proof (state)\nthis:\n  length (strip_while ((=) 0) (list_of_vec x)) +\n  (degree u - length (strip_while ((=) 0) (list_of_vec x))) =\n  dim_vec x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec x \\<Longrightarrow>\n       vec_of_list\n        (strip_while ((=) 0) (list_of_vec x) @\n         replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n          0) $\n       i =\n       x $ i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec x \\<Longrightarrow>\n       vec_of_list\n        (strip_while ((=) 0) (list_of_vec x) @\n         replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n          0) $\n       i =\n       x $ i", "assume i: \"i < dim_vec x\""], ["proof (state)\nthis:\n  i < dim_vec x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec x \\<Longrightarrow>\n       vec_of_list\n        (strip_while ((=) 0) (list_of_vec x) @\n         replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n          0) $\n       i =\n       x $ i", "have \"?H $ i =  coeff (Poly (list_of_vec x)) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) $\n    i =\n    coeff (Poly (list_of_vec x)) i", "proof (rule vec_of_list_coeffs_replicate_nth[OF _ deg_le])"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<in> {..<degree u}", "show \"i \\<in> {..<degree u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> {..<degree u}", "using x_dim i"], ["proof (prove)\nusing this:\n  dim_vec x = degree u\n  i < dim_vec x\n\ngoal (1 subgoal):\n 1. i \\<in> {..<degree u}", "by (auto, linarith)"], ["proof (state)\nthis:\n  i \\<in> {..<degree u}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) $\n  i =\n  coeff (Poly (list_of_vec x)) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec x \\<Longrightarrow>\n       vec_of_list\n        (strip_while ((=) 0) (list_of_vec x) @\n         replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n          0) $\n       i =\n       x $ i", "also"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) $\n  i =\n  coeff (Poly (list_of_vec x)) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec x \\<Longrightarrow>\n       vec_of_list\n        (strip_while ((=) 0) (list_of_vec x) @\n         replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n          0) $\n       i =\n       x $ i", "have \"... = x $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (Poly (list_of_vec x)) i = x $ i", "by (rule coeff_Poly_list_of_vec_nth'[OF i])"], ["proof (state)\nthis:\n  coeff (Poly (list_of_vec x)) i = x $ i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec x \\<Longrightarrow>\n       vec_of_list\n        (strip_while ((=) 0) (list_of_vec x) @\n         replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n          0) $\n       i =\n       x $ i", "finally"], ["proof (chain)\npicking this:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) $\n  i =\n  x $ i", "show \"?H' $ i = x $ i\""], ["proof (prove)\nusing this:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) $\n  i =\n  x $ i\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (strip_while ((=) 0) (list_of_vec x) @\n      replicate (degree u - length (strip_while ((=) 0) (list_of_vec x)))\n       0) $\n    i =\n    x $ i", "by auto"], ["proof (state)\nthis:\n  vec_of_list\n   (strip_while ((=) 0) (list_of_vec x) @\n    replicate (degree u - length (strip_while ((=) 0) (list_of_vec x))) 0) $\n  i =\n  x $ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n  x\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> mat_kernel\n           (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T", "have \"?H \\<in> carrier_vec (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> carrier_vec (degree u)", "using deg_le dim_vec_of_list_h Hx"], ["proof (prove)\nusing this:\n  degree (Poly (list_of_vec x)) < degree u\n  degree ?h < degree ?u \\<Longrightarrow>\n  dim_vec\n   (vec_of_list\n     (coeffs ?h @ replicate (degree ?u - length (coeffs ?h)) (0::?'b))) =\n  degree ?u\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n  x\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> carrier_vec (degree u)", "by auto"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> carrier_vec (degree u)\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> mat_kernel\n           (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T", "moreover"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> carrier_vec (degree u)\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> mat_kernel\n           (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T", "have \"transpose_mat (berlekamp_mat u - 1\\<^sub>m (degree u)) *\\<^sub>v ?H = 0\\<^sub>v (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (berlekamp_mat u - 1\\<^sub>m (degree u))\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    0\\<^sub>v (degree u)", "using t_QI_x_0 Hx QR_rw"], ["proof (prove)\nusing this:\n  (mat (degree u) (degree u)\n    (\\<lambda>(i, j).\n        if i = j then berlekamp_mat u $$ (i, j) - 1\n        else berlekamp_mat u $$ (i, j)))\\<^sup>T *\\<^sub>v\n  x =\n  0\\<^sub>v (degree u)\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n  x\n  mat (degree u) (degree u)\n   (\\<lambda>(i, j).\n       if i = j then berlekamp_mat u $$ (i, j) - 1\n       else berlekamp_mat u $$ (i, j)) =\n  berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u))\n\ngoal (1 subgoal):\n 1. (berlekamp_mat u - 1\\<^sub>m (degree u))\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    0\\<^sub>v (degree u)", "by auto"], ["proof (state)\nthis:\n  (berlekamp_mat u - 1\\<^sub>m (degree u))\\<^sup>T *\\<^sub>v\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n  0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> mat_kernel\n           (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T", "ultimately"], ["proof (chain)\npicking this:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> carrier_vec (degree u)\n  (berlekamp_mat u - 1\\<^sub>m (degree u))\\<^sup>T *\\<^sub>v\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n  0\\<^sub>v (degree u)", "show ?thesis"], ["proof (prove)\nusing this:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> carrier_vec (degree u)\n  (berlekamp_mat u - 1\\<^sub>m (degree u))\\<^sup>T *\\<^sub>v\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n  0\\<^sub>v (degree u)\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n    \\<in> mat_kernel\n           (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T", "by (auto simp add: mat_kernel_def)"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> mat_kernel\n         (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> mat_kernel\n         (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)", "ultimately"], ["proof (chain)\npicking this:\n  dim_row (berlekamp_mat u) =\n  dim_vec\n   (vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0))\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> mat_kernel\n         (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T", "show \"transpose_mat (berlekamp_mat u) *\\<^sub>v ?H = ?H\""], ["proof (prove)\nusing this:\n  dim_row (berlekamp_mat u) =\n  dim_vec\n   (vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0))\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> mat_kernel\n         (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)", "using system_if_mat_kernel[of \"berlekamp_mat u\" ?H]"], ["proof (prove)\nusing this:\n  dim_row (berlekamp_mat u) =\n  dim_vec\n   (vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0))\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n  \\<in> mat_kernel\n         (berlekamp_mat u - 1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T\n  \\<lbrakk>dim_row (berlekamp_mat u) = dim_col (berlekamp_mat u);\n   dim_row (berlekamp_mat u) =\n   dim_vec\n    (vec_of_list\n      (coeffs (Poly (list_of_vec x)) @\n       replicate (degree u - length (coeffs (Poly (list_of_vec x))))\n        0))\\<rbrakk>\n  \\<Longrightarrow> ((berlekamp_mat u)\\<^sup>T *\\<^sub>v\n                     vec_of_list\n                      (coeffs (Poly (list_of_vec x)) @\n                       replicate\n                        (degree u - length (coeffs (Poly (list_of_vec x))))\n                        0) =\n                     vec_of_list\n                      (coeffs (Poly (list_of_vec x)) @\n                       replicate\n                        (degree u - length (coeffs (Poly (list_of_vec x))))\n                        0)) =\n                    (vec_of_list\n                      (coeffs (Poly (list_of_vec x)) @\n                       replicate\n                        (degree u - length (coeffs (Poly (list_of_vec x))))\n                        0)\n                     \\<in> mat_kernel\n                            (berlekamp_mat u -\n                             1\\<^sub>m (dim_row (berlekamp_mat u)))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n    vec_of_list\n     (coeffs (Poly (list_of_vec x)) @\n      replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)", "by auto"], ["proof (state)\nthis:\n  (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0) =\n  vec_of_list\n   (coeffs (Poly (list_of_vec x)) @\n    replicate (degree u - length (coeffs (Poly (list_of_vec x)))) 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u", "assume x: \"x \\<in> mat_kernel (berlekamp_resulting_mat u)\""], ["proof (state)\nthis:\n  x \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec x)) < degree u", "show \"degree (Poly (list_of_vec x)) < degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec x)) < degree u", "by (rule degree_Poly_list_of_vec, insert assms x, auto simp: mat_kernel_def)"], ["proof (state)\nthis:\n  degree (Poly (list_of_vec x)) < degree u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma berlekamp_basis_eq_8:\n  assumes v: \"v \\<in> set (berlekamp_basis u)\"\n  shows \"[v ^ CARD('a) = v] (mod u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod u)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod u)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod u)", "assume x: \"x \\<in> set (find_base_vectors (berlekamp_resulting_mat u))\""], ["proof (state)\nthis:\n  x \\<in> set (find_base_vectors (berlekamp_resulting_mat u))\n\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod u)", "have \"set (find_base_vectors (berlekamp_resulting_mat u)) \\<subseteq> mat_kernel (berlekamp_resulting_mat u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_base_vectors (berlekamp_resulting_mat u))\n    \\<subseteq> mat_kernel (berlekamp_resulting_mat u)", "proof (rule find_base_vectors(1))"], ["proof (state)\ngoal (2 subgoals):\n 1. row_echelon_form (berlekamp_resulting_mat u)\n 2. berlekamp_resulting_mat u \\<in> carrier_mat ?nr ?nc", "show \"row_echelon_form (berlekamp_resulting_mat u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form (berlekamp_resulting_mat u)", "by (rule row_echelon_form_berlekamp_resulting_mat)"], ["proof (state)\nthis:\n  row_echelon_form (berlekamp_resulting_mat u)\n\ngoal (1 subgoal):\n 1. berlekamp_resulting_mat u \\<in> carrier_mat ?nr ?nc", "show \"berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)", "by simp"], ["proof (state)\nthis:\n  berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (find_base_vectors (berlekamp_resulting_mat u))\n  \\<subseteq> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod u)", "hence \"x \\<in> mat_kernel (berlekamp_resulting_mat u)\""], ["proof (prove)\nusing this:\n  set (find_base_vectors (berlekamp_resulting_mat u))\n  \\<subseteq> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (1 subgoal):\n 1. x \\<in> mat_kernel (berlekamp_resulting_mat u)", "using x"], ["proof (prove)\nusing this:\n  set (find_base_vectors (berlekamp_resulting_mat u))\n  \\<subseteq> mat_kernel (berlekamp_resulting_mat u)\n  x \\<in> set (find_base_vectors (berlekamp_resulting_mat u))\n\ngoal (1 subgoal):\n 1. x \\<in> mat_kernel (berlekamp_resulting_mat u)", "by auto"], ["proof (state)\nthis:\n  x \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod u)", "hence \"[Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\""], ["proof (prove)\nusing this:\n  x \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "using linear_Poly_list_of_vec"], ["proof (prove)\nusing this:\n  x \\<in> mat_kernel (berlekamp_resulting_mat u)\n  Poly \\<circ> list_of_vec\n  \\<in> module_hom class_ring V\n         (vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u)})\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "unfolding LinearCombinations.module_hom_def Matrix.module_vec_def"], ["proof (prove)\nusing this:\n  x \\<in> mat_kernel (berlekamp_resulting_mat u)\n  Poly \\<circ> list_of_vec\n  \\<in> {f \\<in> carrier\n                  (\\<lparr>carrier = carrier_vec (degree u),\n                      monoid.mult = undefined, one = undefined,\n                      zero = 0\\<^sub>v (degree u), add = (+),\n                      module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                   \\<lparr>carrier :=\n                             mat_kernel\n                              (berlekamp_resulting_mat\n                                u)\\<rparr>) \\<rightarrow>\n                 carrier\n                  (vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u)}).\n         (\\<forall>m1 m2.\n             m1 \\<in> carrier\n                       (\\<lparr>carrier = carrier_vec (degree u),\n                           monoid.mult = undefined, one = undefined,\n                           zero = 0\\<^sub>v (degree u), add = (+),\n                           module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                        \\<lparr>carrier :=\n                                  mat_kernel\n                                   (berlekamp_resulting_mat\n                                     u)\\<rparr>) \\<and>\n             m2 \\<in> carrier\n                       (\\<lparr>carrier = carrier_vec (degree u),\n                           monoid.mult = undefined, one = undefined,\n                           zero = 0\\<^sub>v (degree u), add = (+),\n                           module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                        \\<lparr>carrier :=\n                                  mat_kernel\n                                   (berlekamp_resulting_mat\n                                     u)\\<rparr>) \\<longrightarrow>\n             f (m1 \\<oplus>\\<^bsub>\\<lparr>carrier = carrier_vec (degree u), monoid.mult = undefined, one = undefined, zero = 0\\<^sub>v (degree u), add = (+), module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<lparr>carrier := mat_kernel (berlekamp_resulting_mat u)\\<rparr>\\<^esub>\n                m2) =\n             f m1 \\<oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u)}\\<^esub>\n             f m2) \\<and>\n         (\\<forall>r m.\n             r \\<in> carrier class_ring \\<and>\n             m \\<in> carrier\n                      (\\<lparr>carrier = carrier_vec (degree u),\n                          monoid.mult = undefined, one = undefined,\n                          zero = 0\\<^sub>v (degree u), add = (+),\n                          module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                       \\<lparr>carrier :=\n                                 mat_kernel\n                                  (berlekamp_resulting_mat\n                                    u)\\<rparr>) \\<longrightarrow>\n             f (r \\<odot>\\<^bsub>\\<lparr>carrier = carrier_vec (degree u), monoid.mult = undefined, one = undefined, zero = 0\\<^sub>v (degree u), add = (+), module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<lparr>carrier := mat_kernel (berlekamp_resulting_mat u)\\<rparr>\\<^esub>\n                m) =\n             r \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u)}\\<^esub>\n             f m)}\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)", "by auto"], ["proof (state)\nthis:\n  [Poly (list_of_vec x) ^ CARD('a) = Poly (list_of_vec x)] (mod u)\n\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod u)", "}"], ["proof (state)\nthis:\n  ?x3\n  \\<in> set (find_base_vectors\n              (berlekamp_resulting_mat u)) \\<Longrightarrow>\n  [Poly (list_of_vec ?x3) ^ CARD('a) = Poly (list_of_vec ?x3)] (mod u)\n\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod u)", "thus \"[v ^ CARD('a) = v] (mod u)\""], ["proof (prove)\nusing this:\n  ?x3\n  \\<in> set (find_base_vectors\n              (berlekamp_resulting_mat u)) \\<Longrightarrow>\n  [Poly (list_of_vec ?x3) ^ CARD('a) = Poly (list_of_vec ?x3)] (mod u)\n\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod u)", "using v"], ["proof (prove)\nusing this:\n  ?x3\n  \\<in> set (find_base_vectors\n              (berlekamp_resulting_mat u)) \\<Longrightarrow>\n  [Poly (list_of_vec ?x3) ^ CARD('a) = Poly (list_of_vec ?x3)] (mod u)\n  v \\<in> set (berlekamp_basis u)\n\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod u)", "unfolding set_berlekamp_basis_eq"], ["proof (prove)\nusing this:\n  ?x3\n  \\<in> set (find_base_vectors\n              (berlekamp_resulting_mat u)) \\<Longrightarrow>\n  [Poly (list_of_vec ?x3) ^ CARD('a) = Poly (list_of_vec ?x3)] (mod u)\n  v \\<in> (Poly \\<circ> list_of_vec) `\n          set (find_base_vectors (berlekamp_resulting_mat u))\n\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod u)", "by auto"], ["proof (state)\nthis:\n  [v ^ CARD('a) = v] (mod u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma surj_Poly_list_of_vec:\n  assumes deg_u: \"degree u > 0\"\n  shows \"(Poly \\<circ> list_of_vec)` (carrier V) = carrier W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Poly \\<circ> list_of_vec) ` carrier V =\n    carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "proof (auto simp add: image_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       xa \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec xa) ^ CARD('a) = Poly (list_of_vec xa)] (mod u)\n 2. \\<And>xa.\n       xa \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec xa)) < degree u\n 3. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>mat_kernel\n    (berlekamp_resulting_mat u).\n                            x = Poly (list_of_vec xa)", "fix xa"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       xa \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec xa) ^ CARD('a) = Poly (list_of_vec xa)] (mod u)\n 2. \\<And>xa.\n       xa \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec xa)) < degree u\n 3. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>mat_kernel\n    (berlekamp_resulting_mat u).\n                            x = Poly (list_of_vec xa)", "assume xa: \"xa \\<in> mat_kernel (berlekamp_resulting_mat u)\""], ["proof (state)\nthis:\n  xa \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (3 subgoals):\n 1. \\<And>xa.\n       xa \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       [Poly (list_of_vec xa) ^ CARD('a) = Poly (list_of_vec xa)] (mod u)\n 2. \\<And>xa.\n       xa \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec xa)) < degree u\n 3. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>mat_kernel\n    (berlekamp_resulting_mat u).\n                            x = Poly (list_of_vec xa)", "thus \"[Poly (list_of_vec xa) ^ CARD('a) = Poly (list_of_vec xa)] (mod u)\""], ["proof (prove)\nusing this:\n  xa \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec xa) ^ CARD('a) = Poly (list_of_vec xa)] (mod u)", "using linear_Poly_list_of_vec"], ["proof (prove)\nusing this:\n  xa \\<in> mat_kernel (berlekamp_resulting_mat u)\n  Poly \\<circ> list_of_vec\n  \\<in> module_hom class_ring V\n         (vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u)})\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec xa) ^ CARD('a) = Poly (list_of_vec xa)] (mod u)", "unfolding LinearCombinations.module_hom_def Matrix.module_vec_def"], ["proof (prove)\nusing this:\n  xa \\<in> mat_kernel (berlekamp_resulting_mat u)\n  Poly \\<circ> list_of_vec\n  \\<in> {f \\<in> carrier\n                  (\\<lparr>carrier = carrier_vec (degree u),\n                      monoid.mult = undefined, one = undefined,\n                      zero = 0\\<^sub>v (degree u), add = (+),\n                      module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                   \\<lparr>carrier :=\n                             mat_kernel\n                              (berlekamp_resulting_mat\n                                u)\\<rparr>) \\<rightarrow>\n                 carrier\n                  (vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u)}).\n         (\\<forall>m1 m2.\n             m1 \\<in> carrier\n                       (\\<lparr>carrier = carrier_vec (degree u),\n                           monoid.mult = undefined, one = undefined,\n                           zero = 0\\<^sub>v (degree u), add = (+),\n                           module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                        \\<lparr>carrier :=\n                                  mat_kernel\n                                   (berlekamp_resulting_mat\n                                     u)\\<rparr>) \\<and>\n             m2 \\<in> carrier\n                       (\\<lparr>carrier = carrier_vec (degree u),\n                           monoid.mult = undefined, one = undefined,\n                           zero = 0\\<^sub>v (degree u), add = (+),\n                           module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                        \\<lparr>carrier :=\n                                  mat_kernel\n                                   (berlekamp_resulting_mat\n                                     u)\\<rparr>) \\<longrightarrow>\n             f (m1 \\<oplus>\\<^bsub>\\<lparr>carrier = carrier_vec (degree u), monoid.mult = undefined, one = undefined, zero = 0\\<^sub>v (degree u), add = (+), module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<lparr>carrier := mat_kernel (berlekamp_resulting_mat u)\\<rparr>\\<^esub>\n                m2) =\n             f m1 \\<oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u)}\\<^esub>\n             f m2) \\<and>\n         (\\<forall>r m.\n             r \\<in> carrier class_ring \\<and>\n             m \\<in> carrier\n                      (\\<lparr>carrier = carrier_vec (degree u),\n                          monoid.mult = undefined, one = undefined,\n                          zero = 0\\<^sub>v (degree u), add = (+),\n                          module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                       \\<lparr>carrier :=\n                                 mat_kernel\n                                  (berlekamp_resulting_mat\n                                    u)\\<rparr>) \\<longrightarrow>\n             f (r \\<odot>\\<^bsub>\\<lparr>carrier = carrier_vec (degree u), monoid.mult = undefined, one = undefined, zero = 0\\<^sub>v (degree u), add = (+), module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<lparr>carrier := mat_kernel (berlekamp_resulting_mat u)\\<rparr>\\<^esub>\n                m) =\n             r \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u)}\\<^esub>\n             f m)}\n\ngoal (1 subgoal):\n 1. [Poly (list_of_vec xa) ^ CARD('a) = Poly (list_of_vec xa)] (mod u)", "by auto"], ["proof (state)\nthis:\n  [Poly (list_of_vec xa) ^ CARD('a) = Poly (list_of_vec xa)] (mod u)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> mat_kernel (berlekamp_resulting_mat u) \\<Longrightarrow>\n       degree (Poly (list_of_vec xa)) < degree u\n 2. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>mat_kernel\n    (berlekamp_resulting_mat u).\n                            x = Poly (list_of_vec xa)", "show \"degree (Poly (list_of_vec xa)) < degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Poly (list_of_vec xa)) < degree u", "proof (rule degree_Poly_list_of_vec[OF _ deg_u])"], ["proof (state)\ngoal (1 subgoal):\n 1. xa \\<in> carrier_vec (degree u)", "show \"xa \\<in> carrier_vec (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa \\<in> carrier_vec (degree u)", "using xa"], ["proof (prove)\nusing this:\n  xa \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (1 subgoal):\n 1. xa \\<in> carrier_vec (degree u)", "unfolding mat_kernel_def"], ["proof (prove)\nusing this:\n  xa \\<in> {v \\<in> carrier_vec (dim_col (berlekamp_resulting_mat u)).\n            berlekamp_resulting_mat u *\\<^sub>v v =\n            0\\<^sub>v (dim_row (berlekamp_resulting_mat u))}\n\ngoal (1 subgoal):\n 1. xa \\<in> carrier_vec (degree u)", "by simp"], ["proof (state)\nthis:\n  xa \\<in> carrier_vec (degree u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (Poly (list_of_vec xa)) < degree u\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>mat_kernel\n    (berlekamp_resulting_mat u).\n                            x = Poly (list_of_vec xa)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>mat_kernel\n    (berlekamp_resulting_mat u).\n                            x = Poly (list_of_vec xa)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>mat_kernel\n    (berlekamp_resulting_mat u).\n                            x = Poly (list_of_vec xa)", "assume x: \"[x ^ CARD('a) = x] (mod u)\"\n  and deg_x: \"degree x < degree u\""], ["proof (state)\nthis:\n  [x ^ CARD('a) = x] (mod u)\n  degree x < degree u\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>mat_kernel\n    (berlekamp_resulting_mat u).\n                            x = Poly (list_of_vec xa)", "show \"\\<exists>xa \\<in> mat_kernel (berlekamp_resulting_mat u). x = Poly (list_of_vec xa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xa\\<in>mat_kernel (berlekamp_resulting_mat u).\n       x = Poly (list_of_vec xa)", "proof (rule bexI[of _ \"vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. x =\n    Poly\n     (list_of_vec\n       (vec_of_list\n         (coeffs x @ replicate (degree u - length (coeffs x)) 0)))\n 2. vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)\n    \\<in> mat_kernel (berlekamp_resulting_mat u)", "let ?X = \"vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)\""], ["proof (state)\ngoal (2 subgoals):\n 1. x =\n    Poly\n     (list_of_vec\n       (vec_of_list\n         (coeffs x @ replicate (degree u - length (coeffs x)) 0)))\n 2. vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)\n    \\<in> mat_kernel (berlekamp_resulting_mat u)", "show \"x = Poly (list_of_vec (vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x =\n    Poly\n     (list_of_vec\n       (vec_of_list\n         (coeffs x @ replicate (degree u - length (coeffs x)) 0)))", "by auto"], ["proof (state)\nthis:\n  x =\n  Poly\n   (list_of_vec\n     (vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)))\n\ngoal (1 subgoal):\n 1. vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)\n    \\<in> mat_kernel (berlekamp_resulting_mat u)", "have X: \"?X \\<in> carrier_vec (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)\n    \\<in> carrier_vec (degree u)", "unfolding carrier_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)\n    \\<in> {v. dim_vec v = degree u}", "by (auto, metis Suc_leI coeffs_0_eq_Nil deg_x degree_0 le_add_diff_inverse\n        length_coeffs_degree linordered_semidom_class.add_diff_inverse list.size(3) order.asym)"], ["proof (state)\nthis:\n  vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)\n  \\<in> carrier_vec (degree u)\n\ngoal (1 subgoal):\n 1. vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)\n    \\<in> mat_kernel (berlekamp_resulting_mat u)", "have t: \"transpose_mat (berlekamp_mat u) *\\<^sub>v ?X = ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n    vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0) =\n    vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)", "using equation_13[OF deg_x] x"], ["proof (prove)\nusing this:\n  [x ^ CARD('a) = x] (mod u) =\n  ((berlekamp_mat u)\\<^sup>T *\\<^sub>v\n   vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0) =\n   vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0))\n  [x ^ CARD('a) = x] (mod u)\n\ngoal (1 subgoal):\n 1. (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n    vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0) =\n    vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)", "by auto"], ["proof (state)\nthis:\n  (berlekamp_mat u)\\<^sup>T *\\<^sub>v\n  vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0) =\n  vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)\n\ngoal (1 subgoal):\n 1. vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)\n    \\<in> mat_kernel (berlekamp_resulting_mat u)", "show \"vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)\n      \\<in> mat_kernel (berlekamp_resulting_mat u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)\n    \\<in> mat_kernel (berlekamp_resulting_mat u)", "by (rule in_mat_kernel_berlekamp_resulting_mat[OF t X])"], ["proof (state)\nthis:\n  vec_of_list (coeffs x @ replicate (degree u - length (coeffs x)) 0)\n  \\<in> mat_kernel (berlekamp_resulting_mat u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xa\\<in>mat_kernel (berlekamp_resulting_mat u).\n     x = Poly (list_of_vec xa)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_set_berlekamp_basis: \"card (set (berlekamp_basis u)) = length (berlekamp_basis u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (berlekamp_basis u)) = length (berlekamp_basis u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (set (berlekamp_basis u)) = length (berlekamp_basis u)", "have b: \"berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)", "by auto"], ["proof (state)\nthis:\n  berlekamp_resulting_mat u \\<in> carrier_mat (degree u) (degree u)\n\ngoal (1 subgoal):\n 1. card (set (berlekamp_basis u)) = length (berlekamp_basis u)", "have \"(set (berlekamp_basis u)) = (Poly \\<circ> list_of_vec) ` set (find_base_vectors (berlekamp_resulting_mat u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (berlekamp_basis u) =\n    (Poly \\<circ> list_of_vec) `\n    set (find_base_vectors (berlekamp_resulting_mat u))", "unfolding set_berlekamp_basis_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Poly \\<circ> list_of_vec) `\n    set (find_base_vectors (berlekamp_resulting_mat u)) =\n    (Poly \\<circ> list_of_vec) `\n    set (find_base_vectors (berlekamp_resulting_mat u))", ".."], ["proof (state)\nthis:\n  set (berlekamp_basis u) =\n  (Poly \\<circ> list_of_vec) `\n  set (find_base_vectors (berlekamp_resulting_mat u))\n\ngoal (1 subgoal):\n 1. card (set (berlekamp_basis u)) = length (berlekamp_basis u)", "also"], ["proof (state)\nthis:\n  set (berlekamp_basis u) =\n  (Poly \\<circ> list_of_vec) `\n  set (find_base_vectors (berlekamp_resulting_mat u))\n\ngoal (1 subgoal):\n 1. card (set (berlekamp_basis u)) = length (berlekamp_basis u)", "have \" card ... = card (set (find_base_vectors (berlekamp_resulting_mat u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ((Poly \\<circ> list_of_vec) `\n      set (find_base_vectors (berlekamp_resulting_mat u))) =\n    card (set (find_base_vectors (berlekamp_resulting_mat u)))", "proof (rule card_image, rule subset_inj_on[OF inj_Poly_list_of_vec])"], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_base_vectors (berlekamp_resulting_mat u))\n    \\<subseteq> carrier_vec ?n3", "show \"set (find_base_vectors (berlekamp_resulting_mat u)) \\<subseteq> carrier_vec (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_base_vectors (berlekamp_resulting_mat u))\n    \\<subseteq> carrier_vec (degree u)", "using find_base_vectors(1)[OF row_echelon_form_berlekamp_resulting_mat b]"], ["proof (prove)\nusing this:\n  set (find_base_vectors (berlekamp_resulting_mat u))\n  \\<subseteq> mat_kernel (berlekamp_resulting_mat u)\n\ngoal (1 subgoal):\n 1. set (find_base_vectors (berlekamp_resulting_mat u))\n    \\<subseteq> carrier_vec (degree u)", "unfolding carrier_vec_def mat_kernel_def"], ["proof (prove)\nusing this:\n  set (find_base_vectors (berlekamp_resulting_mat u))\n  \\<subseteq> {v \\<in> {v. dim_vec v = dim_col (berlekamp_resulting_mat u)}.\n               berlekamp_resulting_mat u *\\<^sub>v v =\n               0\\<^sub>v (dim_row (berlekamp_resulting_mat u))}\n\ngoal (1 subgoal):\n 1. set (find_base_vectors (berlekamp_resulting_mat u))\n    \\<subseteq> {v. dim_vec v = degree u}", "by auto"], ["proof (state)\nthis:\n  set (find_base_vectors (berlekamp_resulting_mat u))\n  \\<subseteq> carrier_vec (degree u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card\n   ((Poly \\<circ> list_of_vec) `\n    set (find_base_vectors (berlekamp_resulting_mat u))) =\n  card (set (find_base_vectors (berlekamp_resulting_mat u)))\n\ngoal (1 subgoal):\n 1. card (set (berlekamp_basis u)) = length (berlekamp_basis u)", "also"], ["proof (state)\nthis:\n  card\n   ((Poly \\<circ> list_of_vec) `\n    set (find_base_vectors (berlekamp_resulting_mat u))) =\n  card (set (find_base_vectors (berlekamp_resulting_mat u)))\n\ngoal (1 subgoal):\n 1. card (set (berlekamp_basis u)) = length (berlekamp_basis u)", "have \"... =  length (find_base_vectors (berlekamp_resulting_mat u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (find_base_vectors (berlekamp_resulting_mat u))) =\n    length (find_base_vectors (berlekamp_resulting_mat u))", "by (rule length_find_base_vectors[symmetric, OF row_echelon_form_berlekamp_resulting_mat b])"], ["proof (state)\nthis:\n  card (set (find_base_vectors (berlekamp_resulting_mat u))) =\n  length (find_base_vectors (berlekamp_resulting_mat u))\n\ngoal (1 subgoal):\n 1. card (set (berlekamp_basis u)) = length (berlekamp_basis u)", "finally"], ["proof (chain)\npicking this:\n  card (set (berlekamp_basis u)) =\n  length (find_base_vectors (berlekamp_resulting_mat u))", "show ?thesis"], ["proof (prove)\nusing this:\n  card (set (berlekamp_basis u)) =\n  length (find_base_vectors (berlekamp_resulting_mat u))\n\ngoal (1 subgoal):\n 1. card (set (berlekamp_basis u)) = length (berlekamp_basis u)", "unfolding berlekamp_basis_def"], ["proof (prove)\nusing this:\n  card\n   (set (map (Poly \\<circ> list_of_vec)\n          (find_base_vectors (berlekamp_resulting_mat u)))) =\n  length (find_base_vectors (berlekamp_resulting_mat u))\n\ngoal (1 subgoal):\n 1. card\n     (set (map (Poly \\<circ> list_of_vec)\n            (find_base_vectors (berlekamp_resulting_mat u)))) =\n    length\n     (map (Poly \\<circ> list_of_vec)\n       (find_base_vectors (berlekamp_resulting_mat u)))", "by auto"], ["proof (state)\nthis:\n  card (set (berlekamp_basis u)) = length (berlekamp_basis u)\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  assumes deg_u0[simp]: \"degree u > 0\"\nbegin"], ["", "interpretation Berlekamp_subspace: vectorspace class_ring W"], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "by (rule vector_space_poly.subspace_is_vs[OF subspace_Berlekamp], simp)"], ["", "lemma linear_map_Poly_list_of_vec': \"linear_map class_ring V W (Poly \\<circ> list_of_vec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_map class_ring V\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n     (Poly \\<circ> list_of_vec)", "proof (auto simp add: linear_map_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. vectorspace class_ring V\n 2. vectorspace class_ring\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n 3. mod_hom class_ring V\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n     (Poly \\<circ> list_of_vec)", "show \"vectorspace class_ring V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring V", "by intro_locales"], ["proof (state)\nthis:\n  vectorspace class_ring V\n\ngoal (2 subgoals):\n 1. vectorspace class_ring\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n 2. mod_hom class_ring V\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n     (Poly \\<circ> list_of_vec)", "show \"vectorspace class_ring W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "by (rule Berlekamp_subspace.vectorspace_axioms)"], ["proof (state)\nthis:\n  vectorspace class_ring\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. mod_hom class_ring V\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n     (Poly \\<circ> list_of_vec)", "show \"mod_hom class_ring V W (Poly \\<circ> list_of_vec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_hom class_ring V\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n     (Poly \\<circ> list_of_vec)", "proof (rule mod_hom.intro, unfold mod_hom_axioms_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. module class_ring V\n 2. module class_ring\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n 3. Poly \\<circ> list_of_vec\n    \\<in> module_hom class_ring V\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "show \"module class_ring V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module class_ring V", "by intro_locales"], ["proof (state)\nthis:\n  module class_ring V\n\ngoal (2 subgoals):\n 1. module class_ring\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n 2. Poly \\<circ> list_of_vec\n    \\<in> module_hom class_ring V\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "show \"module class_ring W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module class_ring\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "using Berlekamp_subspace.vectorspace_axioms"], ["proof (prove)\nusing this:\n  vectorspace class_ring\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. module class_ring\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "by intro_locales"], ["proof (state)\nthis:\n  module class_ring\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. Poly \\<circ> list_of_vec\n    \\<in> module_hom class_ring V\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "show \"Poly \\<circ> list_of_vec \\<in> module_hom class_ring V W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly \\<circ> list_of_vec\n    \\<in> module_hom class_ring V\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "by (rule linear_Poly_list_of_vec'[OF deg_u0])"], ["proof (state)\nthis:\n  Poly \\<circ> list_of_vec\n  \\<in> module_hom class_ring V\n         (vector_space_poly.vs\n           {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_hom class_ring V\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n   (Poly \\<circ> list_of_vec)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma berlekamp_basis_basis:\n  \"Berlekamp_subspace.basis (set (berlekamp_basis u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Berlekamp_subspace.basis (set (berlekamp_basis u))", "proof (unfold set_berlekamp_basis_eq, rule linear_map.linear_inj_image_is_basis)"], ["proof (state)\ngoal (5 subgoals):\n 1. linear_map class_ring ?V\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n     (Poly \\<circ> list_of_vec)\n 2. inj_on (Poly \\<circ> list_of_vec) (carrier ?V)\n 3. (Poly \\<circ> list_of_vec) ` carrier ?V =\n    carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n 4. vectorspace.basis class_ring ?V\n     (set (find_base_vectors (berlekamp_resulting_mat u)))\n 5. vectorspace.fin_dim class_ring ?V", "show \"linear_map class_ring V W (Poly \\<circ> list_of_vec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_map class_ring V\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n     (Poly \\<circ> list_of_vec)", "by (rule linear_map_Poly_list_of_vec')"], ["proof (state)\nthis:\n  linear_map class_ring V\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n   (Poly \\<circ> list_of_vec)\n\ngoal (4 subgoals):\n 1. inj_on (Poly \\<circ> list_of_vec) (carrier V)\n 2. (Poly \\<circ> list_of_vec) ` carrier V =\n    carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n 3. V.basis (set (find_base_vectors (berlekamp_resulting_mat u)))\n 4. V.fin_dim", "show \"inj_on (Poly \\<circ> list_of_vec) (carrier V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (Poly \\<circ> list_of_vec) (carrier V)", "proof (rule subset_inj_on[OF inj_Poly_list_of_vec])"], ["proof (state)\ngoal (1 subgoal):\n 1. carrier V \\<subseteq> carrier_vec ?n1", "show \"carrier V \\<subseteq> carrier_vec (degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier V \\<subseteq> carrier_vec (degree u)", "by (auto simp add: mat_kernel_def)"], ["proof (state)\nthis:\n  carrier V \\<subseteq> carrier_vec (degree u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (Poly \\<circ> list_of_vec) (carrier V)\n\ngoal (3 subgoals):\n 1. (Poly \\<circ> list_of_vec) ` carrier V =\n    carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n 2. V.basis (set (find_base_vectors (berlekamp_resulting_mat u)))\n 3. V.fin_dim", "show \"(Poly \\<circ> list_of_vec) ` carrier V = carrier W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Poly \\<circ> list_of_vec) ` carrier V =\n    carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "using surj_Poly_list_of_vec[OF deg_u0]"], ["proof (prove)\nusing this:\n  (Poly \\<circ> list_of_vec) ` carrier V =\n  carrier\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. (Poly \\<circ> list_of_vec) ` carrier V =\n    carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "by auto"], ["proof (state)\nthis:\n  (Poly \\<circ> list_of_vec) ` carrier V =\n  carrier\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (2 subgoals):\n 1. V.basis (set (find_base_vectors (berlekamp_resulting_mat u)))\n 2. V.fin_dim", "show b: \"V.basis (set (find_base_vectors (berlekamp_resulting_mat u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V.basis (set (find_base_vectors (berlekamp_resulting_mat u)))", "by (rule berlekamp_resulting_mat_basis)"], ["proof (state)\nthis:\n  V.basis (set (find_base_vectors (berlekamp_resulting_mat u)))\n\ngoal (1 subgoal):\n 1. V.fin_dim", "show \"V.fin_dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V.fin_dim", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. V.fin_dim", "have \"finite (set (find_base_vectors (berlekamp_resulting_mat u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set (find_base_vectors (berlekamp_resulting_mat u)))", "by auto"], ["proof (state)\nthis:\n  finite (set (find_base_vectors (berlekamp_resulting_mat u)))\n\ngoal (1 subgoal):\n 1. V.fin_dim", "moreover"], ["proof (state)\nthis:\n  finite (set (find_base_vectors (berlekamp_resulting_mat u)))\n\ngoal (1 subgoal):\n 1. V.fin_dim", "have \"set (find_base_vectors (berlekamp_resulting_mat u)) \\<subseteq> carrier V\"\n    and \"V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_base_vectors (berlekamp_resulting_mat u))\n    \\<subseteq> carrier V &&&\n    V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u)))", "using b"], ["proof (prove)\nusing this:\n  V.basis (set (find_base_vectors (berlekamp_resulting_mat u)))\n\ngoal (1 subgoal):\n 1. set (find_base_vectors (berlekamp_resulting_mat u))\n    \\<subseteq> carrier V &&&\n    V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u)))", "unfolding V.basis_def"], ["proof (prove)\nusing this:\n  V.lin_indpt (set (find_base_vectors (berlekamp_resulting_mat u))) \\<and>\n  V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u))) \\<and>\n  set (find_base_vectors (berlekamp_resulting_mat u)) \\<subseteq> carrier V\n\ngoal (1 subgoal):\n 1. set (find_base_vectors (berlekamp_resulting_mat u))\n    \\<subseteq> carrier V &&&\n    V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u)))", "by auto"], ["proof (state)\nthis:\n  set (find_base_vectors (berlekamp_resulting_mat u)) \\<subseteq> carrier V\n  V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u)))\n\ngoal (1 subgoal):\n 1. V.fin_dim", "ultimately"], ["proof (chain)\npicking this:\n  finite (set (find_base_vectors (berlekamp_resulting_mat u)))\n  set (find_base_vectors (berlekamp_resulting_mat u)) \\<subseteq> carrier V\n  V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u)))", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (set (find_base_vectors (berlekamp_resulting_mat u)))\n  set (find_base_vectors (berlekamp_resulting_mat u)) \\<subseteq> carrier V\n  V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u)))\n\ngoal (1 subgoal):\n 1. V.fin_dim", "unfolding V.fin_dim_def"], ["proof (prove)\nusing this:\n  finite (set (find_base_vectors (berlekamp_resulting_mat u)))\n  set (find_base_vectors (berlekamp_resulting_mat u)) \\<subseteq> carrier V\n  V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u)))\n\ngoal (1 subgoal):\n 1. \\<exists>A. finite A \\<and> A \\<subseteq> carrier V \\<and> V.gen_set A", "by auto"], ["proof (state)\nthis:\n  V.fin_dim\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  V.fin_dim\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finsum_sum:\nfixes f::\"'a mod_ring poly\"\nassumes f: \"finite B\"\nand a_Pi: \"a \\<in> B \\<rightarrow> carrier R\"\nand V: \"B \\<subseteq> carrier W\"\nshows \"(\\<Oplus>\\<^bsub>W\\<^esub>v\\<in>B. a v \\<odot>\\<^bsub>W\\<^esub> v) = sum (\\<lambda>v. smult (a v) v) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n   v) =\n    (\\<Sum>v\\<in>B. Polynomial.smult (a v) v)", "using f a_Pi V"], ["proof (prove)\nusing this:\n  finite B\n  a \\<in> B \\<rightarrow> carrier R\n  B \\<subseteq> carrier\n                 (vector_space_poly.vs\n                   {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                       degree v < degree u})\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n   v) =\n    (\\<Sum>v\\<in>B. Polynomial.smult (a v) v)", "proof (induct B)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> {} \\<rightarrow> carrier R;\n     {} \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n    \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>{}. a\n                       v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                      v) =\n                      (\\<Sum>v\\<in>{}. Polynomial.smult (a v) v)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>a \\<in> F \\<rightarrow> carrier R;\n         F \\<subseteq> carrier\n                        (vector_space_poly.vs\n                          {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                              degree v < degree u})\\<rbrakk>\n        \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>F. a\n                          v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                         v) =\n                          (\\<Sum>v\\<in>F. Polynomial.smult (a v) v);\n        a \\<in> insert x F \\<rightarrow> carrier R;\n        insert x F\n        \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n       \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                      x F. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                           v) =\n                         (\\<Sum>v\\<in>insert x F. Polynomial.smult (a v) v)", "case empty"], ["proof (state)\nthis:\n  a \\<in> {} \\<rightarrow> carrier R\n  {} \\<subseteq> carrier\n                  (vector_space_poly.vs\n                    {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                        degree v < degree u})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> {} \\<rightarrow> carrier R;\n     {} \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n    \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>{}. a\n                       v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                      v) =\n                      (\\<Sum>v\\<in>{}. Polynomial.smult (a v) v)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>a \\<in> F \\<rightarrow> carrier R;\n         F \\<subseteq> carrier\n                        (vector_space_poly.vs\n                          {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                              degree v < degree u})\\<rbrakk>\n        \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>F. a\n                          v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                         v) =\n                          (\\<Sum>v\\<in>F. Polynomial.smult (a v) v);\n        a \\<in> insert x F \\<rightarrow> carrier R;\n        insert x F\n        \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n       \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                      x F. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                           v) =\n                         (\\<Sum>v\\<in>insert x F. Polynomial.smult (a v) v)", "thus ?case"], ["proof (prove)\nusing this:\n  a \\<in> {} \\<rightarrow> carrier R\n  {} \\<subseteq> carrier\n                  (vector_space_poly.vs\n                    {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                        degree v < degree u})\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>{}. a\n     v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    v) =\n    (\\<Sum>v\\<in>{}. Polynomial.smult (a v) v)", "unfolding Berlekamp_subspace.module.M.finsum_empty"], ["proof (prove)\nusing this:\n  a \\<in> {} \\<rightarrow> carrier R\n  {} \\<subseteq> carrier\n                  (vector_space_poly.vs\n                    {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                        degree v < degree u})\n\ngoal (1 subgoal):\n 1. \\<zero>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub> =\n    (\\<Sum>v\\<in>{}. Polynomial.smult (a v) v)", "by auto"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>{}. a\n   v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  v) =\n  (\\<Sum>v\\<in>{}. Polynomial.smult (a v) v)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>a \\<in> F \\<rightarrow> carrier R;\n         F \\<subseteq> carrier\n                        (vector_space_poly.vs\n                          {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                              degree v < degree u})\\<rbrakk>\n        \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>F. a\n                          v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                         v) =\n                          (\\<Sum>v\\<in>F. Polynomial.smult (a v) v);\n        a \\<in> insert x F \\<rightarrow> carrier R;\n        insert x F\n        \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n       \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                      x F. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                           v) =\n                         (\\<Sum>v\\<in>insert x F. Polynomial.smult (a v) v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>a \\<in> F \\<rightarrow> carrier R;\n         F \\<subseteq> carrier\n                        (vector_space_poly.vs\n                          {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                              degree v < degree u})\\<rbrakk>\n        \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>F. a\n                          v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                         v) =\n                          (\\<Sum>v\\<in>F. Polynomial.smult (a v) v);\n        a \\<in> insert x F \\<rightarrow> carrier R;\n        insert x F\n        \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n       \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                      x F. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                           v) =\n                         (\\<Sum>v\\<in>insert x F. Polynomial.smult (a v) v)", "case (insert x V)"], ["proof (state)\nthis:\n  finite V\n  x \\<notin> V\n  \\<lbrakk>a \\<in> V \\<rightarrow> carrier R;\n   V \\<subseteq> carrier\n                  (vector_space_poly.vs\n                    {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                        degree v < degree u})\\<rbrakk>\n  \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>V. a\n                    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                   v) =\n                    (\\<Sum>v\\<in>V. Polynomial.smult (a v) v)\n  a \\<in> insert x V \\<rightarrow> carrier R\n  insert x V\n  \\<subseteq> carrier\n               (vector_space_poly.vs\n                 {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>a \\<in> F \\<rightarrow> carrier R;\n         F \\<subseteq> carrier\n                        (vector_space_poly.vs\n                          {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                              degree v < degree u})\\<rbrakk>\n        \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>F. a\n                          v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                         v) =\n                          (\\<Sum>v\\<in>F. Polynomial.smult (a v) v);\n        a \\<in> insert x F \\<rightarrow> carrier R;\n        insert x F\n        \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n       \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                      x F. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                           v) =\n                         (\\<Sum>v\\<in>insert x F. Polynomial.smult (a v) v)", "have hyp: \"(\\<Oplus>\\<^bsub>W\\<^esub>v \\<in> V. a v \\<odot>\\<^bsub>W\\<^esub> v) = sum (\\<lambda>v. smult (a v) v) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>V. a\n    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n   v) =\n    (\\<Sum>v\\<in>V. Polynomial.smult (a v) v)", "proof (rule insert.hyps)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> V \\<rightarrow> carrier R\n 2. V \\<subseteq> carrier\n                   (vector_space_poly.vs\n                     {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                         degree v < degree u})", "show \"a \\<in> V \\<rightarrow> carrier R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> V \\<rightarrow> carrier R", "using insert.prems"], ["proof (prove)\nusing this:\n  a \\<in> insert x V \\<rightarrow> carrier R\n  insert x V\n  \\<subseteq> carrier\n               (vector_space_poly.vs\n                 {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. a \\<in> V \\<rightarrow> carrier R", "unfolding class_field_def"], ["proof (prove)\nusing this:\n  a \\<in> insert x V \\<rightarrow> carrier R\n  insert x V\n  \\<subseteq> carrier\n               (vector_space_poly.vs\n                 {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. a \\<in> V \\<rightarrow> carrier R", "by auto"], ["proof (state)\nthis:\n  a \\<in> V \\<rightarrow> carrier R\n\ngoal (1 subgoal):\n 1. V \\<subseteq> carrier\n                   (vector_space_poly.vs\n                     {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                         degree v < degree u})", "show \"V \\<subseteq> carrier W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<subseteq> carrier\n                   (vector_space_poly.vs\n                     {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                         degree v < degree u})", "using insert.prems"], ["proof (prove)\nusing this:\n  a \\<in> insert x V \\<rightarrow> carrier R\n  insert x V\n  \\<subseteq> carrier\n               (vector_space_poly.vs\n                 {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. V \\<subseteq> carrier\n                   (vector_space_poly.vs\n                     {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                         degree v < degree u})", "by simp"], ["proof (state)\nthis:\n  V \\<subseteq> carrier\n                 (vector_space_poly.vs\n                   {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                       degree v < degree u})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>V. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v) =\n  (\\<Sum>v\\<in>V. Polynomial.smult (a v) v)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>a \\<in> F \\<rightarrow> carrier R;\n         F \\<subseteq> carrier\n                        (vector_space_poly.vs\n                          {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                              degree v < degree u})\\<rbrakk>\n        \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>F. a\n                          v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                         v) =\n                          (\\<Sum>v\\<in>F. Polynomial.smult (a v) v);\n        a \\<in> insert x F \\<rightarrow> carrier R;\n        insert x F\n        \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n       \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                      x F. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                           v) =\n                         (\\<Sum>v\\<in>insert x F. Polynomial.smult (a v) v)", "have \"(\\<Oplus>\\<^bsub>W\\<^esub>v\\<in>insert x V. a v \\<odot>\\<^bsub>W\\<^esub> v) =  (a x \\<odot>\\<^bsub>W\\<^esub> x) \\<oplus>\\<^bsub>W\\<^esub> (\\<Oplus>\\<^bsub>W\\<^esub>v \\<in> V. a v \\<odot>\\<^bsub>W\\<^esub> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n x V. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n      v) =\n    a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    x \\<oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>V. a\n    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n   v)", "proof (rule abelian_monoid.finsum_insert)"], ["proof (state)\ngoal (5 subgoals):\n 1. abelian_monoid\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n 2. finite V\n 3. x \\<notin> V\n 4. (\\<lambda>v.\n        a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n        v)\n    \\<in> V \\<rightarrow>\n          carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n 5. a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    x\n    \\<in> carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "show \"abelian_monoid W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abelian_monoid\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "by (unfold_locales)"], ["proof (state)\nthis:\n  abelian_monoid\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (4 subgoals):\n 1. finite V\n 2. x \\<notin> V\n 3. (\\<lambda>v.\n        a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n        v)\n    \\<in> V \\<rightarrow>\n          carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n 4. a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    x\n    \\<in> carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "show \"finite V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite V", "by fact"], ["proof (state)\nthis:\n  finite V\n\ngoal (3 subgoals):\n 1. x \\<notin> V\n 2. (\\<lambda>v.\n        a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n        v)\n    \\<in> V \\<rightarrow>\n          carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n 3. a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    x\n    \\<in> carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "show \"x \\<notin> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> V", "by fact"], ["proof (state)\nthis:\n  x \\<notin> V\n\ngoal (2 subgoals):\n 1. (\\<lambda>v.\n        a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n        v)\n    \\<in> V \\<rightarrow>\n          carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n 2. a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    x\n    \\<in> carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "show \"(\\<lambda>v. a v \\<odot>\\<^bsub>W\\<^esub> v) \\<in> V \\<rightarrow> carrier W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n        v)\n    \\<in> V \\<rightarrow>\n          carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "proof (unfold Pi_def, rule, rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> V \\<Longrightarrow>\n       a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n       x\n       \\<in> carrier\n              (vector_space_poly.vs\n                {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> V \\<Longrightarrow>\n       a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n       x\n       \\<in> carrier\n              (vector_space_poly.vs\n                {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "assume v: \"v\\<in>V\""], ["proof (state)\nthis:\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> V \\<Longrightarrow>\n       a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n       x\n       \\<in> carrier\n              (vector_space_poly.vs\n                {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "show \"a v \\<odot>\\<^bsub>W\\<^esub> v \\<in> carrier W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    v\n    \\<in> carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "proof (rule Berlekamp_subspace.smult_closed)"], ["proof (state)\ngoal (2 subgoals):\n 1. a v \\<in> carrier class_ring\n 2. v \\<in> carrier\n             (vector_space_poly.vs\n               {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "show \"a v \\<in> carrier class_ring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a v \\<in> carrier class_ring", "using insert.prems v"], ["proof (prove)\nusing this:\n  a \\<in> insert x V \\<rightarrow> carrier R\n  insert x V\n  \\<subseteq> carrier\n               (vector_space_poly.vs\n                 {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. a v \\<in> carrier class_ring", "unfolding Pi_def"], ["proof (prove)\nusing this:\n  a \\<in> {f. \\<forall>xa.\n                 xa \\<in> insert x V \\<longrightarrow> f xa \\<in> carrier R}\n  insert x V\n  \\<subseteq> carrier\n               (vector_space_poly.vs\n                 {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. a v \\<in> carrier class_ring", "by (simp add: class_field_def)"], ["proof (state)\nthis:\n  a v \\<in> carrier class_ring\n\ngoal (1 subgoal):\n 1. v \\<in> carrier\n             (vector_space_poly.vs\n               {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "show \"v \\<in> carrier W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> carrier\n             (vector_space_poly.vs\n               {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "using v insert.prems"], ["proof (prove)\nusing this:\n  v \\<in> V\n  a \\<in> insert x V \\<rightarrow> carrier R\n  insert x V\n  \\<subseteq> carrier\n               (vector_space_poly.vs\n                 {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. v \\<in> carrier\n             (vector_space_poly.vs\n               {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  v\n  \\<in> carrier\n         (vector_space_poly.vs\n           {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>v.\n      a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n      v)\n  \\<in> V \\<rightarrow>\n        carrier\n         (vector_space_poly.vs\n           {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    x\n    \\<in> carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "show \"a x \\<odot>\\<^bsub>W\\<^esub> x \\<in> carrier W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    x\n    \\<in> carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "proof (rule Berlekamp_subspace.smult_closed)"], ["proof (state)\ngoal (2 subgoals):\n 1. a x \\<in> carrier class_ring\n 2. x \\<in> carrier\n             (vector_space_poly.vs\n               {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "show \"a x \\<in> carrier class_ring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x \\<in> carrier class_ring", "using insert.prems"], ["proof (prove)\nusing this:\n  a \\<in> insert x V \\<rightarrow> carrier R\n  insert x V\n  \\<subseteq> carrier\n               (vector_space_poly.vs\n                 {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. a x \\<in> carrier class_ring", "unfolding Pi_def"], ["proof (prove)\nusing this:\n  a \\<in> {f. \\<forall>xa.\n                 xa \\<in> insert x V \\<longrightarrow> f xa \\<in> carrier R}\n  insert x V\n  \\<subseteq> carrier\n               (vector_space_poly.vs\n                 {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. a x \\<in> carrier class_ring", "by (simp add: class_field_def)"], ["proof (state)\nthis:\n  a x \\<in> carrier class_ring\n\ngoal (1 subgoal):\n 1. x \\<in> carrier\n             (vector_space_poly.vs\n               {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "show \"x \\<in> carrier W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> carrier\n             (vector_space_poly.vs\n               {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "using insert.prems"], ["proof (prove)\nusing this:\n  a \\<in> insert x V \\<rightarrow> carrier R\n  insert x V\n  \\<subseteq> carrier\n               (vector_space_poly.vs\n                 {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. x \\<in> carrier\n             (vector_space_poly.vs\n               {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "by auto"], ["proof (state)\nthis:\n  x \\<in> carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  x\n  \\<in> carrier\n         (vector_space_poly.vs\n           {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                                     x V. a\n     v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    v) =\n  a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  x \\<oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>V. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>a \\<in> F \\<rightarrow> carrier R;\n         F \\<subseteq> carrier\n                        (vector_space_poly.vs\n                          {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                              degree v < degree u})\\<rbrakk>\n        \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>F. a\n                          v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                         v) =\n                          (\\<Sum>v\\<in>F. Polynomial.smult (a v) v);\n        a \\<in> insert x F \\<rightarrow> carrier R;\n        insert x F\n        \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n       \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                      x F. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                           v) =\n                         (\\<Sum>v\\<in>insert x F. Polynomial.smult (a v) v)", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                                     x V. a\n     v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    v) =\n  a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  x \\<oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>V. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>a \\<in> F \\<rightarrow> carrier R;\n         F \\<subseteq> carrier\n                        (vector_space_poly.vs\n                          {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                              degree v < degree u})\\<rbrakk>\n        \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>F. a\n                          v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                         v) =\n                          (\\<Sum>v\\<in>F. Polynomial.smult (a v) v);\n        a \\<in> insert x F \\<rightarrow> carrier R;\n        insert x F\n        \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n       \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                      x F. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                           v) =\n                         (\\<Sum>v\\<in>insert x F. Polynomial.smult (a v) v)", "have \"... = (a x \\<odot>\\<^bsub>W\\<^esub> x) + (\\<Oplus>\\<^bsub>W\\<^esub>v \\<in> V. a v \\<odot>\\<^bsub>W\\<^esub> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    x \\<oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>V. a\n    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n   v) =\n    a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    x +\n    (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>V. a\n    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n   v)", "by auto"], ["proof (state)\nthis:\n  a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  x \\<oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>V. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v) =\n  a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  x +\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>V. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>a \\<in> F \\<rightarrow> carrier R;\n         F \\<subseteq> carrier\n                        (vector_space_poly.vs\n                          {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                              degree v < degree u})\\<rbrakk>\n        \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>F. a\n                          v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                         v) =\n                          (\\<Sum>v\\<in>F. Polynomial.smult (a v) v);\n        a \\<in> insert x F \\<rightarrow> carrier R;\n        insert x F\n        \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n       \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                      x F. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                           v) =\n                         (\\<Sum>v\\<in>insert x F. Polynomial.smult (a v) v)", "also"], ["proof (state)\nthis:\n  a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  x \\<oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>V. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v) =\n  a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  x +\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>V. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>a \\<in> F \\<rightarrow> carrier R;\n         F \\<subseteq> carrier\n                        (vector_space_poly.vs\n                          {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                              degree v < degree u})\\<rbrakk>\n        \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>F. a\n                          v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                         v) =\n                          (\\<Sum>v\\<in>F. Polynomial.smult (a v) v);\n        a \\<in> insert x F \\<rightarrow> carrier R;\n        insert x F\n        \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n       \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                      x F. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                           v) =\n                         (\\<Sum>v\\<in>insert x F. Polynomial.smult (a v) v)", "have \"... = (a x \\<odot>\\<^bsub>W\\<^esub> x) + sum (\\<lambda>v. smult (a v) v) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    x +\n    (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>V. a\n    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n   v) =\n    a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    x +\n    (\\<Sum>v\\<in>V. Polynomial.smult (a v) v)", "unfolding hyp"], ["proof (prove)\ngoal (1 subgoal):\n 1. a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    x +\n    (\\<Sum>v\\<in>V. Polynomial.smult (a v) v) =\n    a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    x +\n    (\\<Sum>v\\<in>V. Polynomial.smult (a v) v)", "by simp"], ["proof (state)\nthis:\n  a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  x +\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>V. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v) =\n  a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  x +\n  (\\<Sum>v\\<in>V. Polynomial.smult (a v) v)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>a \\<in> F \\<rightarrow> carrier R;\n         F \\<subseteq> carrier\n                        (vector_space_poly.vs\n                          {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                              degree v < degree u})\\<rbrakk>\n        \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>F. a\n                          v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                         v) =\n                          (\\<Sum>v\\<in>F. Polynomial.smult (a v) v);\n        a \\<in> insert x F \\<rightarrow> carrier R;\n        insert x F\n        \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n       \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                      x F. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                           v) =\n                         (\\<Sum>v\\<in>insert x F. Polynomial.smult (a v) v)", "also"], ["proof (state)\nthis:\n  a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  x +\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>V. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v) =\n  a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  x +\n  (\\<Sum>v\\<in>V. Polynomial.smult (a v) v)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>a \\<in> F \\<rightarrow> carrier R;\n         F \\<subseteq> carrier\n                        (vector_space_poly.vs\n                          {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                              degree v < degree u})\\<rbrakk>\n        \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>F. a\n                          v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                         v) =\n                          (\\<Sum>v\\<in>F. Polynomial.smult (a v) v);\n        a \\<in> insert x F \\<rightarrow> carrier R;\n        insert x F\n        \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n       \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                      x F. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                           v) =\n                         (\\<Sum>v\\<in>insert x F. Polynomial.smult (a v) v)", "have \"... = (smult (a x) x) + sum (\\<lambda>v. smult (a v) v) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    x +\n    (\\<Sum>v\\<in>V. Polynomial.smult (a v) v) =\n    Polynomial.smult (a x) x + (\\<Sum>v\\<in>V. Polynomial.smult (a v) v)", "by simp"], ["proof (state)\nthis:\n  a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  x +\n  (\\<Sum>v\\<in>V. Polynomial.smult (a v) v) =\n  Polynomial.smult (a x) x + (\\<Sum>v\\<in>V. Polynomial.smult (a v) v)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>a \\<in> F \\<rightarrow> carrier R;\n         F \\<subseteq> carrier\n                        (vector_space_poly.vs\n                          {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                              degree v < degree u})\\<rbrakk>\n        \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>F. a\n                          v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                         v) =\n                          (\\<Sum>v\\<in>F. Polynomial.smult (a v) v);\n        a \\<in> insert x F \\<rightarrow> carrier R;\n        insert x F\n        \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n       \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                      x F. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                           v) =\n                         (\\<Sum>v\\<in>insert x F. Polynomial.smult (a v) v)", "also"], ["proof (state)\nthis:\n  a x \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n  x +\n  (\\<Sum>v\\<in>V. Polynomial.smult (a v) v) =\n  Polynomial.smult (a x) x + (\\<Sum>v\\<in>V. Polynomial.smult (a v) v)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>a \\<in> F \\<rightarrow> carrier R;\n         F \\<subseteq> carrier\n                        (vector_space_poly.vs\n                          {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                              degree v < degree u})\\<rbrakk>\n        \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>F. a\n                          v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                         v) =\n                          (\\<Sum>v\\<in>F. Polynomial.smult (a v) v);\n        a \\<in> insert x F \\<rightarrow> carrier R;\n        insert x F\n        \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n       \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                      x F. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                           v) =\n                         (\\<Sum>v\\<in>insert x F. Polynomial.smult (a v) v)", "have \"... = sum (\\<lambda>v. smult (a v) v) (insert x V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (a x) x + (\\<Sum>v\\<in>V. Polynomial.smult (a v) v) =\n    (\\<Sum>v\\<in>insert x V. Polynomial.smult (a v) v)", "by (simp add: insert.hyps(1) insert.hyps(2))"], ["proof (state)\nthis:\n  Polynomial.smult (a x) x + (\\<Sum>v\\<in>V. Polynomial.smult (a v) v) =\n  (\\<Sum>v\\<in>insert x V. Polynomial.smult (a v) v)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>a \\<in> F \\<rightarrow> carrier R;\n         F \\<subseteq> carrier\n                        (vector_space_poly.vs\n                          {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                              degree v < degree u})\\<rbrakk>\n        \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>F. a\n                          v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                         v) =\n                          (\\<Sum>v\\<in>F. Polynomial.smult (a v) v);\n        a \\<in> insert x F \\<rightarrow> carrier R;\n        insert x F\n        \\<subseteq> carrier\n                     (vector_space_poly.vs\n                       {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                           degree v < degree u})\\<rbrakk>\n       \\<Longrightarrow> (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                      x F. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n                           v) =\n                         (\\<Sum>v\\<in>insert x F. Polynomial.smult (a v) v)", "finally"], ["proof (chain)\npicking this:\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                                     x V. a\n     v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    v) =\n  (\\<Sum>v\\<in>insert x V. Polynomial.smult (a v) v)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                                     x V. a\n     v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    v) =\n  (\\<Sum>v\\<in>insert x V. Polynomial.smult (a v) v)\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n x V. a v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n      v) =\n    (\\<Sum>v\\<in>insert x V. Polynomial.smult (a v) v)", "."], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>insert\n                                     x V. a\n     v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n    v) =\n  (\\<Sum>v\\<in>insert x V. Polynomial.smult (a v) v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exists_vector_in_Berlekamp_subspace_dvd:\nfixes p_i::\"'a mod_ring poly\"\nassumes finite_P: \"finite P\"\n      and f_desc_square_free: \"u = (\\<Prod>a\\<in>P. a)\"\n      and P: \"P \\<subseteq> {q. irreducible q \\<and> monic q}\"\n      and pi: \"p_i \\<in> P\" and pj: \"p_j \\<in> P\" and pi_pj: \"p_i \\<noteq> p_j\"\n      and monic_f: \"monic u\" and sf_f: \"square_free u\"\n      and not_irr_w: \"\\<not> irreducible w\"\n      and w_dvd_f: \"w dvd u\" and monic_w: \"monic w\"\n      and pi_dvd_w: \"p_i dvd w\" and pj_dvd_w: \"p_j dvd w\"\nshows \"\\<exists>v. v \\<in> {h. [h^(CARD('a)) = h] (mod u) \\<and> degree h < degree u}\n  \\<and> v mod p_i \\<noteq> v mod p_j\n  \\<and> degree (v mod p_i) = 0\n  \\<and> degree (v mod p_j) = 0\n\\<comment> \\<open>This implies that the algorithm decreases the degree of the reducible polynomials in each step:\\<close>\n  \\<and> (\\<exists>s. gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "have f_not_0: \"u \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "using monic_f"], ["proof (prove)\nusing this:\n  monic u\n\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "have irr_pi: \"irreducible p_i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible p_i", "using pi P"], ["proof (prove)\nusing this:\n  p_i \\<in> P\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible p_i", "by auto"], ["proof (state)\nthis:\n  irreducible p_i\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "have irr_pj: \"irreducible p_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible p_j", "using pj P"], ["proof (prove)\nusing this:\n  p_j \\<in> P\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible p_j", "by auto"], ["proof (state)\nthis:\n  irreducible p_j\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "obtain m and n::nat where P_m: \"P = m ` {i. i < n}\" and inj_on_m: \"inj_on m {i. i < n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>P = m ` {i. i < n}; inj_on m {i. i < n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using finite_imp_nat_seg_image_inj_on[OF finite_P]"], ["proof (prove)\nusing this:\n  \\<exists>n f. P = f ` {i. i < n} \\<and> inj_on f {i. i < n}\n\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>P = m ` {i. i < n}; inj_on m {i. i < n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P = m ` {i. i < n}\n  inj_on m {i. i < n}\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "hence \"n = card P\""], ["proof (prove)\nusing this:\n  P = m ` {i. i < n}\n  inj_on m {i. i < n}\n\ngoal (1 subgoal):\n 1. n = card P", "by (simp add: card_image)"], ["proof (state)\nthis:\n  n = card P\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "have degree_prod: \"degree (prod m {i. i < n}) = degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod m {i. i < n}) = degree u", "by (metis P_m f_desc_square_free inj_on_m prod.reindex_cong)"], ["proof (state)\nthis:\n  degree (prod m {i. i < n}) = degree u\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "have not_zero: \"\\<forall>i\\<in>{i. i < n}. m i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{i. i < n}. m i \\<noteq> 0", "using P_m f_desc_square_free f_not_0"], ["proof (prove)\nusing this:\n  P = m ` {i. i < n}\n  u = \\<Prod>P\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{i. i < n}. m i \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{i. i < n}. m i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "obtain i where mi: \"m i = p_i\" and i: \"i < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>m i = p_i; i < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using P_m pi"], ["proof (prove)\nusing this:\n  P = m ` {i. i < n}\n  p_i \\<in> P\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>m i = p_i; i < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m i = p_i\n  i < n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "obtain j where mj: \"m j = p_j\" and j: \"j < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>m j = p_j; j < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using P_m pj"], ["proof (prove)\nusing this:\n  P = m ` {i. i < n}\n  p_j \\<in> P\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>m j = p_j; j < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m j = p_j\n  j < n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "have ij: \"i \\<noteq> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> j", "using  mi mj pi_pj"], ["proof (prove)\nusing this:\n  m i = p_i\n  m j = p_j\n  p_i \\<noteq> p_j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "obtain s_i and s_j::\"'a mod_ring\" where si_sj: \"s_i \\<noteq> s_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s_i s_j.\n        s_i \\<noteq> s_j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using exists_two_distint"], ["proof (prove)\nusing this:\n  \\<exists>a b. a \\<noteq> b\n\ngoal (1 subgoal):\n 1. (\\<And>s_i s_j.\n        s_i \\<noteq> s_j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s_i \\<noteq> s_j\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "let ?u=\"\\<lambda>x. if x = i then [:s_i:] else if x = j then [:s_j:] else [:0:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "have degree_si: \"degree [:s_i:] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree [:s_i:] = 0", "by auto"], ["proof (state)\nthis:\n  degree [:s_i:] = 0\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "have degree_sj: \"degree [:s_j:] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree [:s_j:] = 0", "by auto"], ["proof (state)\nthis:\n  degree [:s_j:] = 0\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "have \"\\<exists>!v. degree v < (\\<Sum>i\\<in>{i. i < n}. degree (m i)) \\<and> (\\<forall>a\\<in>{i. i < n}. [v = ?u a] (mod m a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!v.\n       degree v < (\\<Sum>i | i < n. degree (m i)) \\<and>\n       (\\<forall>a\\<in>{i. i < n}.\n           [v = if a = i then [:s_i:]\n                else if a = j then [:s_j:] else [:0:]] (mod m a))", "proof (rule chinese_remainder_unique_poly)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>i\\<in>{i. i < n}. m i \\<noteq> 0\n 2. \\<forall>i\\<in>{i. i < n}.\n       \\<forall>j\\<in>{i. i < n}.\n          i \\<noteq> j \\<longrightarrow>\n          algebraic_semidom_class.coprime (m i) (m j)\n 3. 0 < degree (prod m {i. i < n})", "show \"\\<forall>a\\<in>{i. i < n}. \\<forall>b\\<in>{i. i < n}. a \\<noteq> b \\<longrightarrow> Rings.coprime (m a) (m b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{i. i < n}.\n       \\<forall>b\\<in>{i. i < n}.\n          a \\<noteq> b \\<longrightarrow>\n          algebraic_semidom_class.coprime (m a) (m b)", "proof (rule+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> {i. i < n}; b \\<in> {i. i < n};\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime (m a) (m b)", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> {i. i < n}; b \\<in> {i. i < n};\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime (m a) (m b)", "assume \"a \\<in> {i. i < n}\" and \"b \\<in> {i. i < n}\" and \"a \\<noteq> b\""], ["proof (state)\nthis:\n  a \\<in> {i. i < n}\n  b \\<in> {i. i < n}\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> {i. i < n}; b \\<in> {i. i < n};\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime (m a) (m b)", "thus \"Rings.coprime (m a) (m b)\""], ["proof (prove)\nusing this:\n  a \\<in> {i. i < n}\n  b \\<in> {i. i < n}\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime (m a) (m b)", "using coprime_polynomial_factorization[OF P finite_P, simplified] P_m"], ["proof (prove)\nusing this:\n  a \\<in> {i. i < n}\n  b \\<in> {i. i < n}\n  a \\<noteq> b\n  \\<lbrakk>?a1.0 \\<in> P; ?a2.0 \\<in> P; ?a1.0 \\<noteq> ?a2.0\\<rbrakk>\n  \\<Longrightarrow> algebraic_semidom_class.coprime ?a1.0 ?a2.0\n  P = m ` {i. i < n}\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime (m a) (m b)", "by (metis image_eqI inj_onD inj_on_m)"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime (m a) (m b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a\\<in>{i. i < n}.\n     \\<forall>b\\<in>{i. i < n}.\n        a \\<noteq> b \\<longrightarrow>\n        algebraic_semidom_class.coprime (m a) (m b)\n\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>{i. i < n}. m i \\<noteq> 0\n 2. 0 < degree (prod m {i. i < n})", "show \"\\<forall>i\\<in>{i. i < n}. m i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{i. i < n}. m i \\<noteq> 0", "by (rule not_zero)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{i. i < n}. m i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree (prod m {i. i < n})", "show \"0 < degree (prod m {i. i < n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree (prod m {i. i < n})", "unfolding degree_prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree u", "using deg_u0"], ["proof (prove)\nusing this:\n  0 < degree u\n\ngoal (1 subgoal):\n 1. 0 < degree u", "by blast"], ["proof (state)\nthis:\n  0 < degree (prod m {i. i < n})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!v.\n     degree v < (\\<Sum>i | i < n. degree (m i)) \\<and>\n     (\\<forall>a\\<in>{i. i < n}.\n         [v = if a = i then [:s_i:]\n              else if a = j then [:s_j:] else [:0:]] (mod m a))\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>!v.\n     degree v < (\\<Sum>i | i < n. degree (m i)) \\<and>\n     (\\<forall>a\\<in>{i. i < n}.\n         [v = if a = i then [:s_i:]\n              else if a = j then [:s_j:] else [:0:]] (mod m a))", "obtain v where v: \"\\<forall>a\\<in>{i. i < n}. [v = ?u a] (mod m a)\"\n  and degree_v: \"degree v < (\\<Sum>i\\<in>{i. i < n}. degree (m i))\""], ["proof (prove)\nusing this:\n  \\<exists>!v.\n     degree v < (\\<Sum>i | i < n. degree (m i)) \\<and>\n     (\\<forall>a\\<in>{i. i < n}.\n         [v = if a = i then [:s_i:]\n              else if a = j then [:s_j:] else [:0:]] (mod m a))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<forall>a\\<in>{i. i < n}.\n                    [v = if a = i then [:s_i:]\n                         else if a = j then [:s_j:] else [:0:]] (mod m a);\n         degree v < (\\<Sum>i | i < n. degree (m i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>a\\<in>{i. i < n}.\n     [v = if a = i then [:s_i:]\n          else if a = j then [:s_j:] else [:0:]] (mod m a)\n  degree v < (\\<Sum>i | i < n. degree (m i))\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                   degree h < degree u} \\<and>\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)", "proof (rule exI[of _ v], auto)"], ["proof (state)\ngoal (6 subgoals):\n 1. [v ^ CARD('a) = v] (mod u)\n 2. degree v < degree u\n 3. v mod p_i = v mod p_j \\<Longrightarrow> False\n 4. degree (v mod p_i) = 0\n 5. degree (v mod p_j) = 0\n 6. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1", "show vp_v_mod: \"[v ^ CARD('a) = v] (mod u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod u)", "proof (unfold f_desc_square_free, rule coprime_cong_mult_factorization_poly[OF finite_P])"], ["proof (state)\ngoal (3 subgoals):\n 1. P \\<subseteq> Collect irreducible\n 2. Ball P (cong (v ^ CARD('a)) v)\n 3. \\<forall>p1 p2.\n       p1 \\<in> P \\<and> p2 \\<in> P \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime p1 p2", "show \"P \\<subseteq> {q. irreducible q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> {q. irreducible q}", "using P"], ["proof (prove)\nusing this:\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. P \\<subseteq> {q. irreducible q}", "by blast"], ["proof (state)\nthis:\n  P \\<subseteq> {q. irreducible q}\n\ngoal (2 subgoals):\n 1. Ball P (cong (v ^ CARD('a)) v)\n 2. \\<forall>p1 p2.\n       p1 \\<in> P \\<and> p2 \\<in> P \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime p1 p2", "show \"\\<forall>p\\<in>P. [v ^ CARD('a) = v] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>P. [v ^ CARD('a) = v] (mod p)", "proof (rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "assume p: \"p \\<in> P\""], ["proof (state)\nthis:\n  p \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "hence irr_p: \"irreducible\\<^sub>d p\""], ["proof (prove)\nusing this:\n  p \\<in> P\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "using P"], ["proof (prove)\nusing this:\n  p \\<in> P\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "by auto"], ["proof (state)\nthis:\n  irreducible\\<^sub>d p\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "obtain k where mk: \"m k = p\" and k: \"k < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>m k = p; k < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using P_m p"], ["proof (prove)\nusing this:\n  P = m ` {i. i < n}\n  p \\<in> P\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>m k = p; k < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m k = p\n  k < n\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "have \"[v = ?u k] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [v = if k = i then [:s_i:]\n         else if k = j then [:s_j:] else [:0:]] (mod p)", "using v mk k"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>{i. i < n}.\n     [v = if a = i then [:s_i:]\n          else if a = j then [:s_j:] else [:0:]] (mod m a)\n  m k = p\n  k < n\n\ngoal (1 subgoal):\n 1. [v = if k = i then [:s_i:]\n         else if k = j then [:s_j:] else [:0:]] (mod p)", "by auto"], ["proof (state)\nthis:\n  [v = if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:]] (mod p)\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "moreover"], ["proof (state)\nthis:\n  [v = if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:]] (mod p)\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "have \"?u k mod p = ?u k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:]) mod p =\n    (if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:])", "apply (rule mod_poly_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:])\n    < degree p", "using irreducible\\<^sub>dD(1)[OF irr_p]"], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. degree (if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:])\n    < degree p", "by auto"], ["proof (state)\nthis:\n  (if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:]) mod p =\n  (if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:])\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "ultimately"], ["proof (chain)\npicking this:\n  [v = if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:]] (mod p)\n  (if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:]) mod p =\n  (if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:])", "obtain s where v_mod_p: \"v mod p = [:s:]\""], ["proof (prove)\nusing this:\n  [v = if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:]] (mod p)\n  (if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:]) mod p =\n  (if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:])\n\ngoal (1 subgoal):\n 1. (\\<And>s. v mod p = [:s:] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding cong_def"], ["proof (prove)\nusing this:\n  v mod p =\n  (if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:]) mod p\n  (if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:]) mod p =\n  (if k = i then [:s_i:] else if k = j then [:s_j:] else [:0:])\n\ngoal (1 subgoal):\n 1. (\\<And>s. v mod p = [:s:] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  v mod p = [:s:]\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "hence deg_v_p: \"degree (v mod p) = 0\""], ["proof (prove)\nusing this:\n  v mod p = [:s:]\n\ngoal (1 subgoal):\n 1. degree (v mod p) = 0", "by auto"], ["proof (state)\nthis:\n  degree (v mod p) = 0\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "have \"v mod p = [:s:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v mod p = [:s:]", "by (rule v_mod_p)"], ["proof (state)\nthis:\n  v mod p = [:s:]\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "also"], ["proof (state)\nthis:\n  v mod p = [:s:]\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "have \"... = [:s:]^CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:s:] = [:s:] ^ CARD('a)", "unfolding poly_const_pow"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:s:] = [:s ^ CARD('a):]", "by auto"], ["proof (state)\nthis:\n  [:s:] = [:s:] ^ CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "also"], ["proof (state)\nthis:\n  [:s:] = [:s:] ^ CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "have \"... = (v mod p) ^ CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:s:] ^ CARD('a) = (v mod p) ^ CARD('a)", "using v_mod_p"], ["proof (prove)\nusing this:\n  v mod p = [:s:]\n\ngoal (1 subgoal):\n 1. [:s:] ^ CARD('a) = (v mod p) ^ CARD('a)", "by auto"], ["proof (state)\nthis:\n  [:s:] ^ CARD('a) = (v mod p) ^ CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "also"], ["proof (state)\nthis:\n  [:s:] ^ CARD('a) = (v mod p) ^ CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "have \"... = (v mod p) ^ CARD('a) mod p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v mod p) ^ CARD('a) = (v mod p) ^ CARD('a) mod p", "using calculation"], ["proof (prove)\nusing this:\n  v mod p = (v mod p) ^ CARD('a)\n\ngoal (1 subgoal):\n 1. (v mod p) ^ CARD('a) = (v mod p) ^ CARD('a) mod p", "by auto"], ["proof (state)\nthis:\n  (v mod p) ^ CARD('a) = (v mod p) ^ CARD('a) mod p\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "also"], ["proof (state)\nthis:\n  (v mod p) ^ CARD('a) = (v mod p) ^ CARD('a) mod p\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "have \"... = v^CARD('a) mod p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v mod p) ^ CARD('a) mod p = v ^ CARD('a) mod p", "using power_mod"], ["proof (prove)\nusing this:\n  (?a mod ?b) ^ ?n mod ?b = ?a ^ ?n mod ?b\n\ngoal (1 subgoal):\n 1. (v mod p) ^ CARD('a) mod p = v ^ CARD('a) mod p", "by blast"], ["proof (state)\nthis:\n  (v mod p) ^ CARD('a) mod p = v ^ CARD('a) mod p\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod p)", "finally"], ["proof (chain)\npicking this:\n  v mod p = v ^ CARD('a) mod p", "show \"[v ^ CARD('a) = v] (mod p)\""], ["proof (prove)\nusing this:\n  v mod p = v ^ CARD('a) mod p\n\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod p)", "unfolding cong_def"], ["proof (prove)\nusing this:\n  v mod p = v ^ CARD('a) mod p\n\ngoal (1 subgoal):\n 1. v ^ CARD('a) mod p = v mod p", ".."], ["proof (state)\nthis:\n  [v ^ CARD('a) = v] (mod p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p\\<in>P. [v ^ CARD('a) = v] (mod p)\n\ngoal (1 subgoal):\n 1. \\<forall>p1 p2.\n       p1 \\<in> P \\<and> p2 \\<in> P \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime p1 p2", "show \"\\<forall>p1 p2. p1 \\<in> P \\<and> p2 \\<in> P \\<and> p1 \\<noteq> p2 \\<longrightarrow> coprime p1 p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p1 p2.\n       p1 \\<in> P \\<and> p2 \\<in> P \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime p1 p2", "using P coprime_polynomial_factorization finite_P"], ["proof (prove)\nusing this:\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n  \\<lbrakk>?as \\<subseteq> {q. irreducible q \\<and> monic q}; finite ?as;\n   ?a1.0 \\<in> ?as; ?a2.0 \\<in> ?as; ?a1.0 \\<noteq> ?a2.0\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?a1.0 ?a2.0\n  finite P\n\ngoal (1 subgoal):\n 1. \\<forall>p1 p2.\n       p1 \\<in> P \\<and> p2 \\<in> P \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime p1 p2", "by auto"], ["proof (state)\nthis:\n  \\<forall>p1 p2.\n     p1 \\<in> P \\<and> p2 \\<in> P \\<and> p1 \\<noteq> p2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime p1 p2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [v ^ CARD('a) = v] (mod u)\n\ngoal (5 subgoals):\n 1. degree v < degree u\n 2. v mod p_i = v mod p_j \\<Longrightarrow> False\n 3. degree (v mod p_i) = 0\n 4. degree (v mod p_j) = 0\n 5. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1", "have \"[v = ?u i] (mod m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [v = if i = i then [:s_i:]\n         else if i = j then [:s_j:] else [:0:]] (mod m i)", "using v i"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>{i. i < n}.\n     [v = if a = i then [:s_i:]\n          else if a = j then [:s_j:] else [:0:]] (mod m a)\n  i < n\n\ngoal (1 subgoal):\n 1. [v = if i = i then [:s_i:]\n         else if i = j then [:s_j:] else [:0:]] (mod m i)", "by auto"], ["proof (state)\nthis:\n  [v = if i = i then [:s_i:]\n       else if i = j then [:s_j:] else [:0:]] (mod m i)\n\ngoal (5 subgoals):\n 1. degree v < degree u\n 2. v mod p_i = v mod p_j \\<Longrightarrow> False\n 3. degree (v mod p_i) = 0\n 4. degree (v mod p_j) = 0\n 5. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1", "hence v_pi_si_mod: \"v mod p_i = [:s_i:] mod p_i\""], ["proof (prove)\nusing this:\n  [v = if i = i then [:s_i:]\n       else if i = j then [:s_j:] else [:0:]] (mod m i)\n\ngoal (1 subgoal):\n 1. v mod p_i = [:s_i:] mod p_i", "unfolding cong_def mi"], ["proof (prove)\nusing this:\n  v mod p_i =\n  (if i = i then [:s_i:] else if i = j then [:s_j:] else [:0:]) mod p_i\n\ngoal (1 subgoal):\n 1. v mod p_i = [:s_i:] mod p_i", "by auto"], ["proof (state)\nthis:\n  v mod p_i = [:s_i:] mod p_i\n\ngoal (5 subgoals):\n 1. degree v < degree u\n 2. v mod p_i = v mod p_j \\<Longrightarrow> False\n 3. degree (v mod p_i) = 0\n 4. degree (v mod p_j) = 0\n 5. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1", "also"], ["proof (state)\nthis:\n  v mod p_i = [:s_i:] mod p_i\n\ngoal (5 subgoals):\n 1. degree v < degree u\n 2. v mod p_i = v mod p_j \\<Longrightarrow> False\n 3. degree (v mod p_i) = 0\n 4. degree (v mod p_j) = 0\n 5. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1", "have \"... = [:s_i:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:s_i:] mod p_i = [:s_i:]", "apply (rule mod_poly_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree [:s_i:] < degree p_i", "using irr_pi"], ["proof (prove)\nusing this:\n  irreducible p_i\n\ngoal (1 subgoal):\n 1. degree [:s_i:] < degree p_i", "by auto"], ["proof (state)\nthis:\n  [:s_i:] mod p_i = [:s_i:]\n\ngoal (5 subgoals):\n 1. degree v < degree u\n 2. v mod p_i = v mod p_j \\<Longrightarrow> False\n 3. degree (v mod p_i) = 0\n 4. degree (v mod p_j) = 0\n 5. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1", "finally"], ["proof (chain)\npicking this:\n  v mod p_i = [:s_i:]", "have v_pi_si: \"v mod p_i = [:s_i:]\""], ["proof (prove)\nusing this:\n  v mod p_i = [:s_i:]\n\ngoal (1 subgoal):\n 1. v mod p_i = [:s_i:]", "."], ["proof (state)\nthis:\n  v mod p_i = [:s_i:]\n\ngoal (5 subgoals):\n 1. degree v < degree u\n 2. v mod p_i = v mod p_j \\<Longrightarrow> False\n 3. degree (v mod p_i) = 0\n 4. degree (v mod p_j) = 0\n 5. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1", "have \"[v = ?u j] (mod m j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [v = if j = i then [:s_i:]\n         else if j = j then [:s_j:] else [:0:]] (mod m j)", "using v j"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>{i. i < n}.\n     [v = if a = i then [:s_i:]\n          else if a = j then [:s_j:] else [:0:]] (mod m a)\n  j < n\n\ngoal (1 subgoal):\n 1. [v = if j = i then [:s_i:]\n         else if j = j then [:s_j:] else [:0:]] (mod m j)", "by auto"], ["proof (state)\nthis:\n  [v = if j = i then [:s_i:]\n       else if j = j then [:s_j:] else [:0:]] (mod m j)\n\ngoal (5 subgoals):\n 1. degree v < degree u\n 2. v mod p_i = v mod p_j \\<Longrightarrow> False\n 3. degree (v mod p_i) = 0\n 4. degree (v mod p_j) = 0\n 5. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1", "hence v_pj_sj_mod: \"v mod p_j = [:s_j:] mod p_j\""], ["proof (prove)\nusing this:\n  [v = if j = i then [:s_i:]\n       else if j = j then [:s_j:] else [:0:]] (mod m j)\n\ngoal (1 subgoal):\n 1. v mod p_j = [:s_j:] mod p_j", "unfolding cong_def mj"], ["proof (prove)\nusing this:\n  v mod p_j =\n  (if j = i then [:s_i:] else if j = j then [:s_j:] else [:0:]) mod p_j\n\ngoal (1 subgoal):\n 1. v mod p_j = [:s_j:] mod p_j", "using ij"], ["proof (prove)\nusing this:\n  v mod p_j =\n  (if j = i then [:s_i:] else if j = j then [:s_j:] else [:0:]) mod p_j\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. v mod p_j = [:s_j:] mod p_j", "by auto"], ["proof (state)\nthis:\n  v mod p_j = [:s_j:] mod p_j\n\ngoal (5 subgoals):\n 1. degree v < degree u\n 2. v mod p_i = v mod p_j \\<Longrightarrow> False\n 3. degree (v mod p_i) = 0\n 4. degree (v mod p_j) = 0\n 5. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1", "also"], ["proof (state)\nthis:\n  v mod p_j = [:s_j:] mod p_j\n\ngoal (5 subgoals):\n 1. degree v < degree u\n 2. v mod p_i = v mod p_j \\<Longrightarrow> False\n 3. degree (v mod p_i) = 0\n 4. degree (v mod p_j) = 0\n 5. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1", "have \"... = [:s_j:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:s_j:] mod p_j = [:s_j:]", "apply (rule mod_poly_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree [:s_j:] < degree p_j", "using irr_pj"], ["proof (prove)\nusing this:\n  irreducible p_j\n\ngoal (1 subgoal):\n 1. degree [:s_j:] < degree p_j", "by auto"], ["proof (state)\nthis:\n  [:s_j:] mod p_j = [:s_j:]\n\ngoal (5 subgoals):\n 1. degree v < degree u\n 2. v mod p_i = v mod p_j \\<Longrightarrow> False\n 3. degree (v mod p_i) = 0\n 4. degree (v mod p_j) = 0\n 5. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1", "finally"], ["proof (chain)\npicking this:\n  v mod p_j = [:s_j:]", "have v_pj_sj: \"v mod p_j = [:s_j:]\""], ["proof (prove)\nusing this:\n  v mod p_j = [:s_j:]\n\ngoal (1 subgoal):\n 1. v mod p_j = [:s_j:]", "."], ["proof (state)\nthis:\n  v mod p_j = [:s_j:]\n\ngoal (5 subgoals):\n 1. degree v < degree u\n 2. v mod p_i = v mod p_j \\<Longrightarrow> False\n 3. degree (v mod p_i) = 0\n 4. degree (v mod p_j) = 0\n 5. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1", "show \"v mod p_i = v mod p_j \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v mod p_i = v mod p_j \\<Longrightarrow> False", "using si_sj v_pi_si v_pj_sj"], ["proof (prove)\nusing this:\n  s_i \\<noteq> s_j\n  v mod p_i = [:s_i:]\n  v mod p_j = [:s_j:]\n\ngoal (1 subgoal):\n 1. v mod p_i = v mod p_j \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  v mod p_i = v mod p_j \\<Longrightarrow> False\n\ngoal (4 subgoals):\n 1. degree v < degree u\n 2. degree (v mod p_i) = 0\n 3. degree (v mod p_j) = 0\n 4. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1", "show \"degree (v mod p_i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (v mod p_i) = 0", "unfolding v_pi_si"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree [:s_i:] = 0", "by simp"], ["proof (state)\nthis:\n  degree (v mod p_i) = 0\n\ngoal (3 subgoals):\n 1. degree v < degree u\n 2. degree (v mod p_j) = 0\n 3. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1", "show \"degree (v mod p_j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (v mod p_j) = 0", "unfolding v_pj_sj"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree [:s_j:] = 0", "by simp"], ["proof (state)\nthis:\n  degree (v mod p_j) = 0\n\ngoal (2 subgoals):\n 1. degree v < degree u\n 2. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1", "show \"\\<exists>s. gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1", "proof (rule exI[of _ s_i], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. gcd w (v - [:s_i:]) \\<noteq> w\n 2. gcd w (v - [:s_i:]) \\<noteq> 1", "have pi_dvd_v_si: \"p_i dvd v - [:s_i:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_i dvd v - [:s_i:]", "using v_pi_si_mod mod_eq_dvd_iff_poly"], ["proof (prove)\nusing this:\n  v mod p_i = [:s_i:] mod p_i\n  (?x mod ?n = ?y mod ?n) = (?n dvd ?x - ?y)\n\ngoal (1 subgoal):\n 1. p_i dvd v - [:s_i:]", "by blast"], ["proof (state)\nthis:\n  p_i dvd v - [:s_i:]\n\ngoal (2 subgoals):\n 1. gcd w (v - [:s_i:]) \\<noteq> w\n 2. gcd w (v - [:s_i:]) \\<noteq> 1", "have pj_dvd_v_sj: \"p_j dvd v - [:s_j:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_j dvd v - [:s_j:]", "using v_pj_sj_mod mod_eq_dvd_iff_poly"], ["proof (prove)\nusing this:\n  v mod p_j = [:s_j:] mod p_j\n  (?x mod ?n = ?y mod ?n) = (?n dvd ?x - ?y)\n\ngoal (1 subgoal):\n 1. p_j dvd v - [:s_j:]", "by blast"], ["proof (state)\nthis:\n  p_j dvd v - [:s_j:]\n\ngoal (2 subgoals):\n 1. gcd w (v - [:s_i:]) \\<noteq> w\n 2. gcd w (v - [:s_i:]) \\<noteq> 1", "have w_eq: \"w = prod (\\<lambda>c. gcd w (v - [:c:])) (UNIV::'a mod_ring set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = (\\<Prod>c\\<in>UNIV. gcd w (v - [:c:]))", "proof (rule Berlekamp_gcd_step)"], ["proof (state)\ngoal (3 subgoals):\n 1. [v ^ CARD('a) = v] (mod w)\n 2. monic w\n 3. square_free w", "show \"[v ^ CARD('a) = v] (mod w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod w)", "using vp_v_mod cong_dvd_modulus_poly w_dvd_f"], ["proof (prove)\nusing this:\n  [v ^ CARD('a) = v] (mod u)\n  \\<lbrakk>[?x = ?y] (mod ?m); ?n dvd ?m\\<rbrakk>\n  \\<Longrightarrow> [?x = ?y] (mod ?n)\n  w dvd u\n\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod w)", "by blast"], ["proof (state)\nthis:\n  [v ^ CARD('a) = v] (mod w)\n\ngoal (2 subgoals):\n 1. monic w\n 2. square_free w", "show \"square_free w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free w", "by (rule square_free_factor[OF w_dvd_f sf_f])"], ["proof (state)\nthis:\n  square_free w\n\ngoal (1 subgoal):\n 1. monic w", "show \"monic w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic w", "by (rule monic_w)"], ["proof (state)\nthis:\n  monic w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w = (\\<Prod>c\\<in>UNIV. gcd w (v - [:c:]))\n\ngoal (2 subgoals):\n 1. gcd w (v - [:s_i:]) \\<noteq> w\n 2. gcd w (v - [:s_i:]) \\<noteq> 1", "show \"gcd w (v - [:s_i:]) \\<noteq> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd w (v - [:s_i:]) \\<noteq> w", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd w (v - [:s_i:]) = w \\<Longrightarrow> False", "assume gcd_w: \"gcd w (v - [:s_i:]) = w\""], ["proof (state)\nthis:\n  gcd w (v - [:s_i:]) = w\n\ngoal (1 subgoal):\n 1. gcd w (v - [:s_i:]) = w \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "apply (rule \\<open>v mod p_i = v mod p_j \\<Longrightarrow> False\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. v mod p_i = v mod p_j", "by (metis irreducibleE \\<open>degree (v mod p_i) = 0\\<close> gcd_greatest_iff gcd_w irr_pj is_unit_field_poly mod_eq_dvd_iff_poly mod_poly_less neq0_conv pj_dvd_w v_pi_si)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcd w (v - [:s_i:]) \\<noteq> w\n\ngoal (1 subgoal):\n 1. gcd w (v - [:s_i:]) \\<noteq> 1", "show \"gcd w (v - [:s_i:]) \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd w (v - [:s_i:]) \\<noteq> 1", "by (metis irreducibleE gcd_greatest_iff irr_pi pi_dvd_v_si pi_dvd_w)"], ["proof (state)\nthis:\n  gcd w (v - [:s_i:]) \\<noteq> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s.\n     gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. degree v < degree u", "show \"degree v < degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree v < degree u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree v < degree u", "have \"(\\<Sum>i | i < n. degree (m i)) = degree (prod m {i. i < n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < n. degree (m i)) = degree (prod m {i. i < n})", "by (rule degree_prod_eq_sum_degree[symmetric, OF not_zero])"], ["proof (state)\nthis:\n  (\\<Sum>i | i < n. degree (m i)) = degree (prod m {i. i < n})\n\ngoal (1 subgoal):\n 1. degree v < degree u", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i | i < n. degree (m i)) = degree (prod m {i. i < n})\n\ngoal (1 subgoal):\n 1. degree v < degree u", "using degree_v"], ["proof (prove)\nusing this:\n  (\\<Sum>i | i < n. degree (m i)) = degree (prod m {i. i < n})\n  degree v < (\\<Sum>i | i < n. degree (m i))\n\ngoal (1 subgoal):\n 1. degree v < degree u", "unfolding degree_prod"], ["proof (prove)\nusing this:\n  (\\<Sum>i | i < n. degree (m i)) = degree u\n  degree v < (\\<Sum>i | i < n. degree (m i))\n\ngoal (1 subgoal):\n 1. degree v < degree u", "by auto"], ["proof (state)\nthis:\n  degree v < degree u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree v < degree u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>v.\n     v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                 degree h < degree u} \\<and>\n     v mod p_i \\<noteq> v mod p_j \\<and>\n     degree (v mod p_i) = 0 \\<and>\n     degree (v mod p_j) = 0 \\<and>\n     (\\<exists>s.\n         gcd w (v - [:s:]) \\<noteq> w \\<and> gcd w (v - [:s:]) \\<noteq> 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exists_vector_in_Berlekamp_basis_dvd_aux:\nassumes basis_V: \"Berlekamp_subspace.basis B\"\n  and finite_V: \"finite B\" (*This should be removed, since the Berlekamp subspace is a finite set*)\nassumes finite_P: \"finite P\"\n      and f_desc_square_free: \"u = (\\<Prod>a\\<in>P. a)\"\n      and P: \"P \\<subseteq> {q. irreducible q \\<and> monic q}\"\n      and pi: \"p_i \\<in> P\" and pj: \"p_j \\<in> P\" and pi_pj: \"p_i \\<noteq> p_j\"\n      and monic_f: \"monic u\" and sf_f: \"square_free u\"\n      and not_irr_w: \"\\<not> irreducible w\"\n      and w_dvd_f: \"w dvd u\" and monic_w: \"monic w\"\n      and pi_dvd_w: \"p_i dvd w\" and pj_dvd_w: \"p_j dvd w\"\n    shows \"\\<exists>v \\<in> B. v mod p_i \\<noteq> v mod p_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>B. v mod p_i \\<noteq> v mod p_j", "proof (rule ccontr, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "have V_in_carrier: \"B \\<subseteq> carrier W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<subseteq> carrier\n                   (vector_space_poly.vs\n                     {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                         degree v < degree u})", "using basis_V"], ["proof (prove)\nusing this:\n  Berlekamp_subspace.basis B\n\ngoal (1 subgoal):\n 1. B \\<subseteq> carrier\n                   (vector_space_poly.vs\n                     {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                         degree v < degree u})", "unfolding Berlekamp_subspace.basis_def"], ["proof (prove)\nusing this:\n  Berlekamp_subspace.lin_indpt B \\<and>\n  Berlekamp_subspace.gen_set B \\<and>\n  B \\<subseteq> carrier\n                 (vector_space_poly.vs\n                   {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                       degree v < degree u})\n\ngoal (1 subgoal):\n 1. B \\<subseteq> carrier\n                   (vector_space_poly.vs\n                     {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                         degree v < degree u})", "by auto"], ["proof (state)\nthis:\n  B \\<subseteq> carrier\n                 (vector_space_poly.vs\n                   {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                       degree v < degree u})\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "assume all_eq: \"\\<forall>v\\<in>B. v mod p_i = v mod p_j\""], ["proof (state)\nthis:\n  \\<forall>v\\<in>B. v mod p_i = v mod p_j\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "obtain x where x: \"x \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and> degree h < degree u}\"\n      and x_pi_pj: \"x mod p_i \\<noteq> x mod p_j\" and \"degree (x mod p_i) = 0\" and \"degree (x mod p_j) = 0\"\n      \"(\\<exists>s. gcd w (x - [:s:]) \\<noteq> w \\<and> gcd w (x - [:s:]) \\<noteq> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                             degree h < degree u};\n         x mod p_i \\<noteq> x mod p_j; degree (x mod p_i) = 0;\n         degree (x mod p_j) = 0;\n         \\<exists>s.\n            gcd w (x - [:s:]) \\<noteq> w \\<and>\n            gcd w (x - [:s:]) \\<noteq> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using exists_vector_in_Berlekamp_subspace_dvd[OF _ _ _ pi pj _ _ _ _ w_dvd_f monic_w pi_dvd_w]\n      assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite P; u = \\<Prod>P;\n   P \\<subseteq> {q. irreducible q \\<and> monic q}; p_i \\<noteq> p_j;\n   monic u; square_free u; \\<not> irreducible w; p_j dvd w\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v.\n                       v \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                                   degree h < degree u} \\<and>\n                       v mod p_i \\<noteq> v mod p_j \\<and>\n                       degree (v mod p_i) = 0 \\<and>\n                       degree (v mod p_j) = 0 \\<and>\n                       (\\<exists>s.\n                           gcd w (v - [:s:]) \\<noteq> w \\<and>\n                           gcd w (v - [:s:]) \\<noteq> 1)\n  Berlekamp_subspace.basis B\n  finite B\n  finite P\n  u = \\<Prod>P\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n  p_i \\<in> P\n  p_j \\<in> P\n  p_i \\<noteq> p_j\n  monic u\n  square_free u\n  \\<not> irreducible w\n  w dvd u\n  monic w\n  p_i dvd w\n  p_j dvd w\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and>\n                             degree h < degree u};\n         x mod p_i \\<noteq> x mod p_j; degree (x mod p_i) = 0;\n         degree (x mod p_j) = 0;\n         \\<exists>s.\n            gcd w (x - [:s:]) \\<noteq> w \\<and>\n            gcd w (x - [:s:]) \\<noteq> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  x \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and> degree h < degree u}\n  x mod p_i \\<noteq> x mod p_j\n  degree (x mod p_i) = 0\n  degree (x mod p_j) = 0\n  \\<exists>s.\n     gcd w (x - [:s:]) \\<noteq> w \\<and> gcd w (x - [:s:]) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "have x_in: \"x \\<in> carrier W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> carrier\n             (vector_space_poly.vs\n               {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "using x"], ["proof (prove)\nusing this:\n  x \\<in> {h. [h ^ CARD('a) = h] (mod u) \\<and> degree h < degree u}\n\ngoal (1 subgoal):\n 1. x \\<in> carrier\n             (vector_space_poly.vs\n               {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "by auto"], ["proof (state)\nthis:\n  x \\<in> carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "hence \"(\\<exists>!a. a \\<in> B \\<rightarrow>\\<^sub>E carrier class_ring \\<and> Berlekamp_subspace.lincomb a B = x)\""], ["proof (prove)\nusing this:\n  x \\<in> carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. \\<exists>!a.\n       a \\<in> B \\<rightarrow>\\<^sub>E carrier class_ring \\<and>\n       Berlekamp_subspace.lincomb a B = x", "using Berlekamp_subspace.basis_criterion[OF finite_V V_in_carrier]"], ["proof (prove)\nusing this:\n  x \\<in> carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n  Berlekamp_subspace.basis B =\n  (\\<forall>v.\n      v \\<in> carrier\n               (vector_space_poly.vs\n                 {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                     degree v < degree u}) \\<longrightarrow>\n      (\\<exists>!a.\n          a \\<in> B \\<rightarrow>\\<^sub>E carrier class_ring \\<and>\n          Berlekamp_subspace.lincomb a B = v))\n\ngoal (1 subgoal):\n 1. \\<exists>!a.\n       a \\<in> B \\<rightarrow>\\<^sub>E carrier class_ring \\<and>\n       Berlekamp_subspace.lincomb a B = x", "using basis_V"], ["proof (prove)\nusing this:\n  x \\<in> carrier\n           (vector_space_poly.vs\n             {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n  Berlekamp_subspace.basis B =\n  (\\<forall>v.\n      v \\<in> carrier\n               (vector_space_poly.vs\n                 {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                     degree v < degree u}) \\<longrightarrow>\n      (\\<exists>!a.\n          a \\<in> B \\<rightarrow>\\<^sub>E carrier class_ring \\<and>\n          Berlekamp_subspace.lincomb a B = v))\n  Berlekamp_subspace.basis B\n\ngoal (1 subgoal):\n 1. \\<exists>!a.\n       a \\<in> B \\<rightarrow>\\<^sub>E carrier class_ring \\<and>\n       Berlekamp_subspace.lincomb a B = x", "by (simp add: class_field_def)"], ["proof (state)\nthis:\n  \\<exists>!a.\n     a \\<in> B \\<rightarrow>\\<^sub>E carrier class_ring \\<and>\n     Berlekamp_subspace.lincomb a B = x\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>!a.\n     a \\<in> B \\<rightarrow>\\<^sub>E carrier class_ring \\<and>\n     Berlekamp_subspace.lincomb a B = x", "obtain a where a_Pi: \"a \\<in> B \\<rightarrow>\\<^sub>E carrier class_ring\"\n    and lincomb_x: \"Berlekamp_subspace.lincomb a B = x\""], ["proof (prove)\nusing this:\n  \\<exists>!a.\n     a \\<in> B \\<rightarrow>\\<^sub>E carrier class_ring \\<and>\n     Berlekamp_subspace.lincomb a B = x\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> B \\<rightarrow>\\<^sub>E carrier class_ring;\n         Berlekamp_subspace.lincomb a B = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> B \\<rightarrow>\\<^sub>E carrier class_ring\n  Berlekamp_subspace.lincomb a B = x\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "have fs_ss: \"(\\<Oplus>\\<^bsub>W\\<^esub>v\\<in>B. a v \\<odot>\\<^bsub>W\\<^esub> v) = sum (\\<lambda>v. smult (a v) v) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n   v) =\n    (\\<Sum>v\\<in>B. Polynomial.smult (a v) v)", "proof (rule finsum_sum)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite B\n 2. a \\<in> B \\<rightarrow> carrier ?R\n 3. B \\<subseteq> carrier\n                   (vector_space_poly.vs\n                     {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                         degree v < degree u})", "show \"finite B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite B", "by fact"], ["proof (state)\nthis:\n  finite B\n\ngoal (2 subgoals):\n 1. a \\<in> B \\<rightarrow> carrier ?R\n 2. B \\<subseteq> carrier\n                   (vector_space_poly.vs\n                     {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                         degree v < degree u})", "show \"a \\<in> B \\<rightarrow> carrier class_ring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> B \\<rightarrow> carrier class_ring", "using a_Pi"], ["proof (prove)\nusing this:\n  a \\<in> B \\<rightarrow>\\<^sub>E carrier class_ring\n\ngoal (1 subgoal):\n 1. a \\<in> B \\<rightarrow> carrier class_ring", "by auto"], ["proof (state)\nthis:\n  a \\<in> B \\<rightarrow> carrier class_ring\n\ngoal (1 subgoal):\n 1. B \\<subseteq> carrier\n                   (vector_space_poly.vs\n                     {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                         degree v < degree u})", "show \"B \\<subseteq> carrier W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<subseteq> carrier\n                   (vector_space_poly.vs\n                     {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                         degree v < degree u})", "by (rule V_in_carrier)"], ["proof (state)\nthis:\n  B \\<subseteq> carrier\n                 (vector_space_poly.vs\n                   {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                       degree v < degree u})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v) =\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "have \"x mod p_i = Berlekamp_subspace.lincomb a B mod p_i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod p_i = Berlekamp_subspace.lincomb a B mod p_i", "using lincomb_x"], ["proof (prove)\nusing this:\n  Berlekamp_subspace.lincomb a B = x\n\ngoal (1 subgoal):\n 1. x mod p_i = Berlekamp_subspace.lincomb a B mod p_i", "by simp"], ["proof (state)\nthis:\n  x mod p_i = Berlekamp_subspace.lincomb a B mod p_i\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  x mod p_i = Berlekamp_subspace.lincomb a B mod p_i\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "have \" ... = (\\<Oplus>\\<^bsub>W\\<^esub>v\\<in>B. a v \\<odot>\\<^bsub>W\\<^esub> v) mod p_i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Berlekamp_subspace.lincomb a B mod p_i =\n    (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n   v) mod\n    p_i", "unfolding Berlekamp_subspace.lincomb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n   v) mod\n    p_i =\n    (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n   v) mod\n    p_i", ".."], ["proof (state)\nthis:\n  Berlekamp_subspace.lincomb a B mod p_i =\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v) mod\n  p_i\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Berlekamp_subspace.lincomb a B mod p_i =\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v) mod\n  p_i\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "have \"... = (sum (\\<lambda>v. smult (a v) v) B) mod p_i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n   v) mod\n    p_i =\n    (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_i", "unfolding fs_ss"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_i =\n    (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_i", ".."], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v) mod\n  p_i =\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_i\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v) mod\n  p_i =\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_i\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "have \"... = sum (\\<lambda>v. smult (a v) v mod p_i) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_i =\n    (\\<Sum>v\\<in>B. Polynomial.smult (a v) v mod p_i)", "using finite_V poly_mod_sum"], ["proof (prove)\nusing this:\n  finite B\n  finite ?A \\<Longrightarrow>\n  sum ?f ?A mod ?z = (\\<Sum>i\\<in>?A. ?f i mod ?z)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_i =\n    (\\<Sum>v\\<in>B. Polynomial.smult (a v) v mod p_i)", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_i =\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v mod p_i)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_i =\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v mod p_i)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "have \"... = sum (\\<lambda>v. smult (a v) (v mod p_i)) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. Polynomial.smult (a v) v mod p_i) =\n    (\\<Sum>v\\<in>B. Polynomial.smult (a v) (v mod p_i))", "by (meson mod_smult_left)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v mod p_i) =\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) (v mod p_i))\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v mod p_i) =\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) (v mod p_i))\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "have \"... = sum (\\<lambda>v. smult (a v) (v mod p_j)) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. Polynomial.smult (a v) (v mod p_i)) =\n    (\\<Sum>v\\<in>B. Polynomial.smult (a v) (v mod p_j))", "using all_eq"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>B. v mod p_i = v mod p_j\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. Polynomial.smult (a v) (v mod p_i)) =\n    (\\<Sum>v\\<in>B. Polynomial.smult (a v) (v mod p_j))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) (v mod p_i)) =\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) (v mod p_j))\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) (v mod p_i)) =\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) (v mod p_j))\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "have \"... = sum (\\<lambda>v. smult (a v) v mod p_j) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. Polynomial.smult (a v) (v mod p_j)) =\n    (\\<Sum>v\\<in>B. Polynomial.smult (a v) v mod p_j)", "by (metis mod_smult_left)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) (v mod p_j)) =\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v mod p_j)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) (v mod p_j)) =\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v mod p_j)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "have \"... = (sum (\\<lambda>v. smult (a v) v) B) mod p_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. Polynomial.smult (a v) v mod p_j) =\n    (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_j", "by (metis (mono_tags, lifting) finite_V poly_mod_sum sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v mod p_j) =\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_j\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v mod p_j) =\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_j\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "have \"... = (\\<Oplus>\\<^bsub>W\\<^esub>v\\<in>B. a v \\<odot>\\<^bsub>W\\<^esub> v) mod p_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_j =\n    (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n   v) mod\n    p_j", "unfolding fs_ss"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_j =\n    (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_j", ".."], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_j =\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v) mod\n  p_j\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. Polynomial.smult (a v) v) mod p_j =\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v) mod\n  p_j\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "have \"... = Berlekamp_subspace.lincomb a B mod p_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n   v) mod\n    p_j =\n    Berlekamp_subspace.lincomb a B mod p_j", "unfolding Berlekamp_subspace.lincomb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n   v) mod\n    p_j =\n    (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n    v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n   v) mod\n    p_j", ".."], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v) mod\n  p_j =\n  Berlekamp_subspace.lincomb a B mod p_j\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>v\\<in>B. a\n  v \\<odot>\\<^bsub>vector_space_poly.vs {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}\\<^esub>\n v) mod\n  p_j =\n  Berlekamp_subspace.lincomb a B mod p_j\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "have \"... = x mod p_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Berlekamp_subspace.lincomb a B mod p_j = x mod p_j", "using lincomb_x"], ["proof (prove)\nusing this:\n  Berlekamp_subspace.lincomb a B = x\n\ngoal (1 subgoal):\n 1. Berlekamp_subspace.lincomb a B mod p_j = x mod p_j", "by simp"], ["proof (state)\nthis:\n  Berlekamp_subspace.lincomb a B mod p_j = x mod p_j\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  x mod p_i = x mod p_j", "have \"x mod p_i = x mod p_j\""], ["proof (prove)\nusing this:\n  x mod p_i = x mod p_j\n\ngoal (1 subgoal):\n 1. x mod p_i = x mod p_j", "."], ["proof (state)\nthis:\n  x mod p_i = x mod p_j\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>B. v mod p_i = v mod p_j \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  x mod p_i = x mod p_j\n\ngoal (1 subgoal):\n 1. False", "using x_pi_pj"], ["proof (prove)\nusing this:\n  x mod p_i = x mod p_j\n  x mod p_i \\<noteq> x mod p_j\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exists_vector_in_Berlekamp_basis_dvd:\nassumes basis_V: \"Berlekamp_subspace.basis B\"\nand finite_V: \"finite B\" (*This should be removed, since the Berlekamp subspace is a finite set*)\nassumes finite_P: \"finite P\"\n      and f_desc_square_free: \"u = (\\<Prod>a\\<in>P. a)\"\n      and P: \"P \\<subseteq> {q. irreducible q \\<and> monic q}\"\n      and pi: \"p_i \\<in> P\" and pj: \"p_j \\<in> P\" and pi_pj: \"p_i \\<noteq> p_j\"\n      and monic_f: \"monic u\" and sf_f: \"square_free u\"\n      and not_irr_w: \"\\<not> irreducible w\"\n      and w_dvd_f: \"w dvd u\" and monic_w: \"monic w\"\n      and pi_dvd_w: \"p_i dvd w\" and pj_dvd_w: \"p_j dvd w\"\nshows \"\\<exists>v \\<in> B. v mod p_i \\<noteq> v mod p_j\n  \\<and> degree (v mod p_i) = 0\n  \\<and> degree (v mod p_j) = 0\n\\<comment> \\<open>This implies that the algorithm decreases the degree of the reducible polynomials in each step:\\<close>\n  \\<and> (\\<exists>s. gcd w (v - [:s:]) \\<noteq> w \\<and> \\<not> coprime w (v - [:s:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>B.\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and>\n           \\<not> comm_monoid_mult_class.coprime w (v - [:s:]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>B.\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and>\n           \\<not> comm_monoid_mult_class.coprime w (v - [:s:]))", "have f_not_0: \"u \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "using monic_f"], ["proof (prove)\nusing this:\n  monic u\n\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>B.\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and>\n           \\<not> comm_monoid_mult_class.coprime w (v - [:s:]))", "have irr_pi: \"irreducible p_i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible p_i", "using pi P"], ["proof (prove)\nusing this:\n  p_i \\<in> P\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible p_i", "by fast"], ["proof (state)\nthis:\n  irreducible p_i\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>B.\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and>\n           \\<not> comm_monoid_mult_class.coprime w (v - [:s:]))", "have irr_pj: \"irreducible p_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible p_j", "using pj P"], ["proof (prove)\nusing this:\n  p_j \\<in> P\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible p_j", "by fast"], ["proof (state)\nthis:\n  irreducible p_j\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>B.\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and>\n           \\<not> comm_monoid_mult_class.coprime w (v - [:s:]))", "obtain v where vV: \"v \\<in> B\" and v_pi_pj: \"v mod p_i \\<noteq> v mod p_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> B; v mod p_i \\<noteq> v mod p_j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms exists_vector_in_Berlekamp_basis_dvd_aux"], ["proof (prove)\nusing this:\n  Berlekamp_subspace.basis B\n  finite B\n  finite P\n  u = \\<Prod>P\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n  p_i \\<in> P\n  p_j \\<in> P\n  p_i \\<noteq> p_j\n  monic u\n  square_free u\n  \\<not> irreducible w\n  w dvd u\n  monic w\n  p_i dvd w\n  p_j dvd w\n  \\<lbrakk>Berlekamp_subspace.basis ?B; finite ?B; finite ?P; u = \\<Prod>?P;\n   ?P \\<subseteq> {q. irreducible q \\<and> monic q}; ?p_i \\<in> ?P;\n   ?p_j \\<in> ?P; ?p_i \\<noteq> ?p_j; monic u; square_free u;\n   \\<not> irreducible ?w; ?w dvd u; monic ?w; ?p_i dvd ?w;\n   ?p_j dvd ?w\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<in>?B. v mod ?p_i \\<noteq> v mod ?p_j\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> B; v mod p_i \\<noteq> v mod p_j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<in> B\n  v mod p_i \\<noteq> v mod p_j\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>B.\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and>\n           \\<not> comm_monoid_mult_class.coprime w (v - [:s:]))", "have v: \"v \\<in> {v. [v ^ CARD('a) = v] (mod u)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> {v. [v ^ CARD('a) = v] (mod u)}", "using basis_V vV"], ["proof (prove)\nusing this:\n  Berlekamp_subspace.basis B\n  v \\<in> B\n\ngoal (1 subgoal):\n 1. v \\<in> {v. [v ^ CARD('a) = v] (mod u)}", "unfolding Berlekamp_subspace.basis_def"], ["proof (prove)\nusing this:\n  Berlekamp_subspace.lin_indpt B \\<and>\n  Berlekamp_subspace.gen_set B \\<and>\n  B \\<subseteq> carrier\n                 (vector_space_poly.vs\n                   {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                       degree v < degree u})\n  v \\<in> B\n\ngoal (1 subgoal):\n 1. v \\<in> {v. [v ^ CARD('a) = v] (mod u)}", "by auto"], ["proof (state)\nthis:\n  v \\<in> {v. [v ^ CARD('a) = v] (mod u)}\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>B.\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and>\n           \\<not> comm_monoid_mult_class.coprime w (v - [:s:]))", "have deg_v_pi: \"degree (v mod p_i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (v mod p_i) = 0", "by (rule degree_u_mod_irreducible\\<^sub>d_factor_0[OF v finite_P f_desc_square_free P pi])"], ["proof (state)\nthis:\n  degree (v mod p_i) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>B.\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and>\n           \\<not> comm_monoid_mult_class.coprime w (v - [:s:]))", "from this"], ["proof (chain)\npicking this:\n  degree (v mod p_i) = 0", "obtain s_i where v_pi_si: \"v mod p_i = [:s_i:]\""], ["proof (prove)\nusing this:\n  degree (v mod p_i) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>s_i.\n        v mod p_i = [:s_i:] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using degree_eq_zeroE"], ["proof (prove)\nusing this:\n  degree (v mod p_i) = 0\n  \\<lbrakk>degree ?p = 0;\n   \\<And>a. ?p = [:a:] \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>s_i.\n        v mod p_i = [:s_i:] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v mod p_i = [:s_i:]\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>B.\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and>\n           \\<not> comm_monoid_mult_class.coprime w (v - [:s:]))", "have deg_v_pj: \"degree (v mod p_j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (v mod p_j) = 0", "by (rule degree_u_mod_irreducible\\<^sub>d_factor_0[OF v finite_P f_desc_square_free P pj])"], ["proof (state)\nthis:\n  degree (v mod p_j) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>B.\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and>\n           \\<not> comm_monoid_mult_class.coprime w (v - [:s:]))", "from this"], ["proof (chain)\npicking this:\n  degree (v mod p_j) = 0", "obtain s_j where v_pj_sj: \"v mod p_j = [:s_j:]\""], ["proof (prove)\nusing this:\n  degree (v mod p_j) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>s_j.\n        v mod p_j = [:s_j:] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using degree_eq_zeroE"], ["proof (prove)\nusing this:\n  degree (v mod p_j) = 0\n  \\<lbrakk>degree ?p = 0;\n   \\<And>a. ?p = [:a:] \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>s_j.\n        v mod p_j = [:s_j:] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v mod p_j = [:s_j:]\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>B.\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and>\n           \\<not> comm_monoid_mult_class.coprime w (v - [:s:]))", "have si_sj: \"s_i \\<noteq> s_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_i \\<noteq> s_j", "using v_pi_si v_pj_sj v_pi_pj"], ["proof (prove)\nusing this:\n  v mod p_i = [:s_i:]\n  v mod p_j = [:s_j:]\n  v mod p_i \\<noteq> v mod p_j\n\ngoal (1 subgoal):\n 1. s_i \\<noteq> s_j", "by auto"], ["proof (state)\nthis:\n  s_i \\<noteq> s_j\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>B.\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and>\n           \\<not> comm_monoid_mult_class.coprime w (v - [:s:]))", "have \"(\\<exists>s. gcd w (v - [:s:]) \\<noteq> w \\<and> \\<not> Rings.coprime w (v - [:s:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s.\n       gcd w (v - [:s:]) \\<noteq> w \\<and>\n       \\<not> algebraic_semidom_class.coprime w (v - [:s:])", "proof (rule exI[of _ s_i], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. gcd w (v - [:s_i:]) \\<noteq> w\n 2. \\<not> algebraic_semidom_class.coprime w (v - [:s_i:])", "have pi_dvd_v_si: \"p_i dvd v - [:s_i:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_i dvd v - [:s_i:]", "by (metis mod_eq_dvd_iff_poly mod_mod_trivial v_pi_si)"], ["proof (state)\nthis:\n  p_i dvd v - [:s_i:]\n\ngoal (2 subgoals):\n 1. gcd w (v - [:s_i:]) \\<noteq> w\n 2. \\<not> algebraic_semidom_class.coprime w (v - [:s_i:])", "have pj_dvd_v_sj: \"p_j dvd v - [:s_j:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_j dvd v - [:s_j:]", "by (metis mod_eq_dvd_iff_poly mod_mod_trivial v_pj_sj)"], ["proof (state)\nthis:\n  p_j dvd v - [:s_j:]\n\ngoal (2 subgoals):\n 1. gcd w (v - [:s_i:]) \\<noteq> w\n 2. \\<not> algebraic_semidom_class.coprime w (v - [:s_i:])", "have w_eq: \"w = prod (\\<lambda>c. gcd w (v - [:c:])) (UNIV::'a mod_ring set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = (\\<Prod>c\\<in>UNIV. gcd w (v - [:c:]))", "proof (rule Berlekamp_gcd_step)"], ["proof (state)\ngoal (3 subgoals):\n 1. [v ^ CARD('a) = v] (mod w)\n 2. monic w\n 3. square_free w", "show \"[v ^ CARD('a) = v] (mod w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod w)", "using v cong_dvd_modulus_poly w_dvd_f"], ["proof (prove)\nusing this:\n  v \\<in> {v. [v ^ CARD('a) = v] (mod u)}\n  \\<lbrakk>[?x = ?y] (mod ?m); ?n dvd ?m\\<rbrakk>\n  \\<Longrightarrow> [?x = ?y] (mod ?n)\n  w dvd u\n\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod w)", "by blast"], ["proof (state)\nthis:\n  [v ^ CARD('a) = v] (mod w)\n\ngoal (2 subgoals):\n 1. monic w\n 2. square_free w", "show \"square_free w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free w", "by (rule square_free_factor[OF w_dvd_f sf_f])"], ["proof (state)\nthis:\n  square_free w\n\ngoal (1 subgoal):\n 1. monic w", "show \"monic w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic w", "by (rule monic_w)"], ["proof (state)\nthis:\n  monic w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w = (\\<Prod>c\\<in>UNIV. gcd w (v - [:c:]))\n\ngoal (2 subgoals):\n 1. gcd w (v - [:s_i:]) \\<noteq> w\n 2. \\<not> algebraic_semidom_class.coprime w (v - [:s_i:])", "show \"gcd w (v - [:s_i:]) \\<noteq> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd w (v - [:s_i:]) \\<noteq> w", "by (metis irreducibleE deg_v_pi gcd_greatest_iff irr_pj is_unit_field_poly mod_eq_dvd_iff_poly mod_poly_less neq0_conv pj_dvd_w v_pi_pj v_pi_si)"], ["proof (state)\nthis:\n  gcd w (v - [:s_i:]) \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<not> algebraic_semidom_class.coprime w (v - [:s_i:])", "show \"\\<not> Rings.coprime w (v - [:s_i:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic_semidom_class.coprime w (v - [:s_i:])", "using irr_pi pi_dvd_v_si pi_dvd_w"], ["proof (prove)\nusing this:\n  irreducible p_i\n  p_i dvd v - [:s_i:]\n  p_i dvd w\n\ngoal (1 subgoal):\n 1. \\<not> algebraic_semidom_class.coprime w (v - [:s_i:])", "by (simp add: irreducible\\<^sub>dD(1) not_coprimeI)"], ["proof (state)\nthis:\n  \\<not> algebraic_semidom_class.coprime w (v - [:s_i:])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s.\n     gcd w (v - [:s:]) \\<noteq> w \\<and>\n     \\<not> algebraic_semidom_class.coprime w (v - [:s:])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>B.\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and>\n           \\<not> comm_monoid_mult_class.coprime w (v - [:s:]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s.\n     gcd w (v - [:s:]) \\<noteq> w \\<and>\n     \\<not> algebraic_semidom_class.coprime w (v - [:s:])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>B.\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and>\n           \\<not> comm_monoid_mult_class.coprime w (v - [:s:]))", "using v_pi_pj vV deg_v_pi deg_v_pj"], ["proof (prove)\nusing this:\n  \\<exists>s.\n     gcd w (v - [:s:]) \\<noteq> w \\<and>\n     \\<not> algebraic_semidom_class.coprime w (v - [:s:])\n  v mod p_i \\<noteq> v mod p_j\n  v \\<in> B\n  degree (v mod p_i) = 0\n  degree (v mod p_j) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>B.\n       v mod p_i \\<noteq> v mod p_j \\<and>\n       degree (v mod p_i) = 0 \\<and>\n       degree (v mod p_j) = 0 \\<and>\n       (\\<exists>s.\n           gcd w (v - [:s:]) \\<noteq> w \\<and>\n           \\<not> comm_monoid_mult_class.coprime w (v - [:s:]))", "by auto"], ["proof (state)\nthis:\n  \\<exists>v\\<in>B.\n     v mod p_i \\<noteq> v mod p_j \\<and>\n     degree (v mod p_i) = 0 \\<and>\n     degree (v mod p_j) = 0 \\<and>\n     (\\<exists>s.\n         gcd w (v - [:s:]) \\<noteq> w \\<and>\n         \\<not> comm_monoid_mult_class.coprime w (v - [:s:]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exists_bijective_linear_map_W_vec:\n  assumes finite_P: \"finite P\"\n      and u_desc_square_free: \"u = (\\<Prod>a\\<in>P. a)\"\n      and P: \"P \\<subseteq> {q. irreducible q \\<and> monic q}\"\n  shows \"\\<exists>f. linear_map class_ring W (module_vec TYPE('a mod_ring) (card P)) f\n  \\<and> bij_betw f (carrier W) (carrier_vec (card P)::'a mod_ring vec set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "let ?B=\"carrier_vec (card P)::'a mod_ring vec set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "have u_not_0: \"u \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "using deg_u0 degree_0"], ["proof (prove)\nusing this:\n  0 < degree u\n  degree 0 = 0\n\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "obtain m and n::nat where P_m: \"P = m ` {i. i < n}\" and inj_on_m: \"inj_on m {i. i < n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>P = m ` {i. i < n}; inj_on m {i. i < n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using finite_imp_nat_seg_image_inj_on[OF finite_P]"], ["proof (prove)\nusing this:\n  \\<exists>n f. P = f ` {i. i < n} \\<and> inj_on f {i. i < n}\n\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>P = m ` {i. i < n}; inj_on m {i. i < n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P = m ` {i. i < n}\n  inj_on m {i. i < n}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "hence n: \"n = card P\""], ["proof (prove)\nusing this:\n  P = m ` {i. i < n}\n  inj_on m {i. i < n}\n\ngoal (1 subgoal):\n 1. n = card P", "by (simp add: card_image)"], ["proof (state)\nthis:\n  n = card P\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "have degree_prod: \"degree (prod m {i. i < n}) = degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod m {i. i < n}) = degree u", "by (metis P_m u_desc_square_free inj_on_m prod.reindex_cong)"], ["proof (state)\nthis:\n  degree (prod m {i. i < n}) = degree u\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "have not_zero: \"\\<forall>i\\<in>{i. i < n}. m i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{i. i < n}. m i \\<noteq> 0", "using P_m u_desc_square_free u_not_0"], ["proof (prove)\nusing this:\n  P = m ` {i. i < n}\n  u = \\<Prod>P\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{i. i < n}. m i \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{i. i < n}. m i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "have deg_sum_eq: \"(\\<Sum>i\\<in>{i. i < n}. degree (m i)) = degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < n. degree (m i)) = degree u", "by (metis degree_prod degree_prod_eq_sum_degree not_zero)"], ["proof (state)\nthis:\n  (\\<Sum>i | i < n. degree (m i)) = degree u\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "have coprime_mi_mj:\"\\<forall>i\\<in>{i. i < n}. \\<forall>j\\<in>{i. i < n}. i \\<noteq> j \\<longrightarrow> coprime (m i) (m j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{i. i < n}.\n       \\<forall>j\\<in>{i. i < n}.\n          i \\<noteq> j \\<longrightarrow>\n          comm_monoid_mult_class.coprime (m i) (m j)", "proof (rule+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i \\<in> {i. i < n}; j \\<in> {i. i < n};\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime (m i) (m j)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i \\<in> {i. i < n}; j \\<in> {i. i < n};\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime (m i) (m j)", "assume i: \"i \\<in> {i. i < n}\"\n    and j: \"j \\<in> {i. i < n}\" and ij: \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i \\<in> {i. i < n}\n  j \\<in> {i. i < n}\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i \\<in> {i. i < n}; j \\<in> {i. i < n};\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime (m i) (m j)", "show \"coprime (m i) (m j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (m i) (m j)", "proof (rule coprime_polynomial_factorization[OF P finite_P])"], ["proof (state)\ngoal (3 subgoals):\n 1. m i \\<in> P\n 2. m j \\<in> P\n 3. m i \\<noteq> m j", "show \"m i \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m i \\<in> P", "using i P_m"], ["proof (prove)\nusing this:\n  i \\<in> {i. i < n}\n  P = m ` {i. i < n}\n\ngoal (1 subgoal):\n 1. m i \\<in> P", "by auto"], ["proof (state)\nthis:\n  m i \\<in> P\n\ngoal (2 subgoals):\n 1. m j \\<in> P\n 2. m i \\<noteq> m j", "show \"m j \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m j \\<in> P", "using j P_m"], ["proof (prove)\nusing this:\n  j \\<in> {i. i < n}\n  P = m ` {i. i < n}\n\ngoal (1 subgoal):\n 1. m j \\<in> P", "by auto"], ["proof (state)\nthis:\n  m j \\<in> P\n\ngoal (1 subgoal):\n 1. m i \\<noteq> m j", "show \"m i \\<noteq> m j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m i \\<noteq> m j", "using inj_on_m i ij j"], ["proof (prove)\nusing this:\n  inj_on m {i. i < n}\n  i \\<in> {i. i < n}\n  i \\<noteq> j\n  j \\<in> {i. i < n}\n\ngoal (1 subgoal):\n 1. m i \\<noteq> m j", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{i. i < n}.\n     \\<forall>y\\<in>{i. i < n}. m x = m y \\<longrightarrow> x = y\n  i \\<in> {i. i < n}\n  i \\<noteq> j\n  j \\<in> {i. i < n}\n\ngoal (1 subgoal):\n 1. m i \\<noteq> m j", "by blast"], ["proof (state)\nthis:\n  m i \\<noteq> m j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (m i) (m j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{i. i < n}.\n     \\<forall>j\\<in>{i. i < n}.\n        i \\<noteq> j \\<longrightarrow>\n        comm_monoid_mult_class.coprime (m i) (m j)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "let ?f = \"\\<lambda>v. vec n (\\<lambda>i. coeff (v mod (m i)) 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "interpret vec_VS: vectorspace class_ring \"(module_vec TYPE('a mod_ring) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (module_vec TYPE('a mod_ring) n)", "by (rule VS_Connect.vec_vs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "interpret linear_map class_ring W \"(module_vec TYPE('a mod_ring) n)\" ?f"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_map class_ring\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n     (module_vec TYPE('a mod_ring) n)\n     (\\<lambda>v. vec n (\\<lambda>i. coeff (v mod m i) 0))", "by (intro_locales, unfold mod_hom_axioms_def LinearCombinations.module_hom_def,\n        auto simp add: vec_eq_iff module_vec_def mod_smult_left poly_mod_add_left)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "have \"linear_map class_ring W (module_vec TYPE('a mod_ring) n) ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_map class_ring\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n     (module_vec TYPE('a mod_ring) n)\n     (\\<lambda>v. vec n (\\<lambda>i. coeff (v mod m i) 0))", "by (intro_locales)"], ["proof (state)\nthis:\n  linear_map class_ring\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n   (module_vec TYPE('a mod_ring) n)\n   (\\<lambda>v. vec n (\\<lambda>i. coeff (v mod m i) 0))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "moreover"], ["proof (state)\nthis:\n  linear_map class_ring\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n   (module_vec TYPE('a mod_ring) n)\n   (\\<lambda>v. vec n (\\<lambda>i. coeff (v mod m i) 0))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "have inj_f: \"inj_on ?f (carrier W)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>v. vec n (\\<lambda>i. coeff (v mod m i) 0))\n     (carrier\n       (vector_space_poly.vs\n         {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))", "proof (rule Ke0_imp_inj, auto simp add: mod_hom.ker_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u;\n        vec n (\\<lambda>i. coeff (x mod m i) 0) =\n        \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x = 0\n 2. [0 ^ CARD('a) = 0] (mod u)\n 3. vec n (\\<lambda>i. 0) =\n    \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>", "show \"[0 ^ CARD('a) = 0] (mod u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0 ^ CARD('a) = 0] (mod u)", "by (simp add: cong_def zero_power)"], ["proof (state)\nthis:\n  [0 ^ CARD('a) = 0] (mod u)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u;\n        vec n (\\<lambda>i. coeff (x mod m i) 0) =\n        \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x = 0\n 2. vec n (\\<lambda>i. 0) =\n    \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>", "show \"vec n (\\<lambda>i. 0) = \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n (\\<lambda>i. 0) =\n    \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>", "by (auto simp add: module_vec_def)"], ["proof (state)\nthis:\n  vec n (\\<lambda>i. 0) =\n  \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u;\n        vec n (\\<lambda>i. coeff (x mod m i) 0) =\n        \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x = 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u;\n        vec n (\\<lambda>i. coeff (x mod m i) 0) =\n        \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x = 0", "assume x: \"[x ^ CARD('a) = x] (mod u)\" and deg_x: \"degree x < degree u\"\n     and v: \"vec n (\\<lambda>i. coeff (x mod m i) 0) = \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\""], ["proof (state)\nthis:\n  [x ^ CARD('a) = x] (mod u)\n  degree x < degree u\n  vec n (\\<lambda>i. coeff (x mod m i) 0) =\n  \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u;\n        vec n (\\<lambda>i. coeff (x mod m i) 0) =\n        \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x = 0", "have cong_0: \"\\<forall>i\\<in>{i. i < n}. [x = (\\<lambda>i. 0) i] (mod m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{i. i < n}. [x = 0] (mod m i)", "proof (rule, unfold cong_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> {i. i < n} \\<Longrightarrow> x mod m i = 0 mod m i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> {i. i < n} \\<Longrightarrow> x mod m i = 0 mod m i", "assume i: \"i \\<in> {i. i < n}\""], ["proof (state)\nthis:\n  i \\<in> {i. i < n}\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> {i. i < n} \\<Longrightarrow> x mod m i = 0 mod m i", "have deg_x_mod_mi: \"degree (x mod m i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (x mod m i) = 0", "proof (rule degree_u_mod_irreducible\\<^sub>d_factor_0[OF _ finite_P u_desc_square_free P])"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> {v. [v ^ CARD('a) = v] (mod u)}\n 2. m i \\<in> P", "show \"x \\<in> {v. [v ^ CARD('a) = v] (mod u)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {v. [v ^ CARD('a) = v] (mod u)}", "using x"], ["proof (prove)\nusing this:\n  [x ^ CARD('a) = x] (mod u)\n\ngoal (1 subgoal):\n 1. x \\<in> {v. [v ^ CARD('a) = v] (mod u)}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {v. [v ^ CARD('a) = v] (mod u)}\n\ngoal (1 subgoal):\n 1. m i \\<in> P", "show \"m i \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m i \\<in> P", "using P_m i"], ["proof (prove)\nusing this:\n  P = m ` {i. i < n}\n  i \\<in> {i. i < n}\n\ngoal (1 subgoal):\n 1. m i \\<in> P", "by auto"], ["proof (state)\nthis:\n  m i \\<in> P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (x mod m i) = 0\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> {i. i < n} \\<Longrightarrow> x mod m i = 0 mod m i", "thus \"x mod m i = 0 mod m i\""], ["proof (prove)\nusing this:\n  degree (x mod m i) = 0\n\ngoal (1 subgoal):\n 1. x mod m i = 0 mod m i", "using v"], ["proof (prove)\nusing this:\n  degree (x mod m i) = 0\n  vec n (\\<lambda>i. coeff (x mod m i) 0) =\n  \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\n\ngoal (1 subgoal):\n 1. x mod m i = 0 mod m i", "unfolding module_vec_def"], ["proof (prove)\nusing this:\n  degree (x mod m i) = 0\n  vec n (\\<lambda>i. coeff (x mod m i) 0) =\n  \\<zero>\\<^bsub>\\<lparr>carrier = carrier_vec n, monoid.mult = undefined, one = undefined, zero = 0\\<^sub>v n, add = (+), module.smult = (\\<cdot>\\<^sub>v)\\<rparr>\\<^esub>\n\ngoal (1 subgoal):\n 1. x mod m i = 0 mod m i", "by (auto, metis i leading_coeff_neq_0 mem_Collect_eq index_vec index_zero_vec(1))"], ["proof (state)\nthis:\n  x mod m i = 0 mod m i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{i. i < n}. [x = 0] (mod m i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u;\n        vec n (\\<lambda>i. coeff (x mod m i) 0) =\n        \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x = 0", "moreover"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{i. i < n}. [x = 0] (mod m i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u;\n        vec n (\\<lambda>i. coeff (x mod m i) 0) =\n        \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x = 0", "have deg_x2: \"degree x < (\\<Sum>i\\<in>{i. i < n}. degree (m i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree x < (\\<Sum>i | i < n. degree (m i))", "using deg_sum_eq deg_x"], ["proof (prove)\nusing this:\n  (\\<Sum>i | i < n. degree (m i)) = degree u\n  degree x < degree u\n\ngoal (1 subgoal):\n 1. degree x < (\\<Sum>i | i < n. degree (m i))", "by simp"], ["proof (state)\nthis:\n  degree x < (\\<Sum>i | i < n. degree (m i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u;\n        vec n (\\<lambda>i. coeff (x mod m i) 0) =\n        \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x = 0", "moreover"], ["proof (state)\nthis:\n  degree x < (\\<Sum>i | i < n. degree (m i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u;\n        vec n (\\<lambda>i. coeff (x mod m i) 0) =\n        \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x = 0", "have \"\\<forall>i\\<in>{i. i < n}. [0 = (\\<lambda>i. 0) i] (mod m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{i. i < n}. [0 = 0] (mod m i)", "by (auto simp add: cong_def)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{i. i < n}. [0 = 0] (mod m i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u;\n        vec n (\\<lambda>i. coeff (x mod m i) 0) =\n        \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x = 0", "moreover"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{i. i < n}. [0 = 0] (mod m i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u;\n        vec n (\\<lambda>i. coeff (x mod m i) 0) =\n        \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x = 0", "have \"degree 0 < (\\<Sum>i\\<in>{i. i < n}. degree (m i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree 0 < (\\<Sum>i | i < n. degree (m i))", "using degree_prod deg_sum_eq deg_u0"], ["proof (prove)\nusing this:\n  degree (prod m {i. i < n}) = degree u\n  (\\<Sum>i | i < n. degree (m i)) = degree u\n  0 < degree u\n\ngoal (1 subgoal):\n 1. degree 0 < (\\<Sum>i | i < n. degree (m i))", "by force"], ["proof (state)\nthis:\n  degree 0 < (\\<Sum>i | i < n. degree (m i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u;\n        vec n (\\<lambda>i. coeff (x mod m i) 0) =\n        \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x = 0", "moreover"], ["proof (state)\nthis:\n  degree 0 < (\\<Sum>i | i < n. degree (m i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u;\n        vec n (\\<lambda>i. coeff (x mod m i) 0) =\n        \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x = 0", "have \"\\<exists>!x. degree x < (\\<Sum>i\\<in>{i. i < n}. degree (m i))\n        \\<and> (\\<forall>i\\<in>{i. i < n}. [x = (\\<lambda>i. 0) i] (mod m i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       degree x < (\\<Sum>i | i < n. degree (m i)) \\<and>\n       (\\<forall>i\\<in>{i. i < n}. [x = 0] (mod m i))", "proof (rule chinese_remainder_unique_poly[OF not_zero])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>{i. i < n}.\n       \\<forall>j\\<in>{i. i < n}.\n          i \\<noteq> j \\<longrightarrow>\n          algebraic_semidom_class.coprime (m i) (m j)\n 2. 0 < degree (prod m {i. i < n})", "show \"0 < degree (prod m {i. i < n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree (prod m {i. i < n})", "using deg_u0 degree_prod"], ["proof (prove)\nusing this:\n  0 < degree u\n  degree (prod m {i. i < n}) = degree u\n\ngoal (1 subgoal):\n 1. 0 < degree (prod m {i. i < n})", "by linarith"], ["proof (state)\nthis:\n  0 < degree (prod m {i. i < n})\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{i. i < n}.\n       \\<forall>j\\<in>{i. i < n}.\n          i \\<noteq> j \\<longrightarrow>\n          algebraic_semidom_class.coprime (m i) (m j)", "qed (insert coprime_mi_mj, auto)"], ["proof (state)\nthis:\n  \\<exists>!x.\n     degree x < (\\<Sum>i | i < n. degree (m i)) \\<and>\n     (\\<forall>i\\<in>{i. i < n}. [x = 0] (mod m i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[x ^ CARD('a) = x] (mod u); degree x < degree u;\n        vec n (\\<lambda>i. coeff (x mod m i) 0) =\n        \\<zero>\\<^bsub>module_vec TYPE('a mod_ring) n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x = 0", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>{i. i < n}. [x = 0] (mod m i)\n  degree x < (\\<Sum>i | i < n. degree (m i))\n  \\<forall>i\\<in>{i. i < n}. [0 = 0] (mod m i)\n  degree 0 < (\\<Sum>i | i < n. degree (m i))\n  \\<exists>!x.\n     degree x < (\\<Sum>i | i < n. degree (m i)) \\<and>\n     (\\<forall>i\\<in>{i. i < n}. [x = 0] (mod m i))", "show \"x = 0\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{i. i < n}. [x = 0] (mod m i)\n  degree x < (\\<Sum>i | i < n. degree (m i))\n  \\<forall>i\\<in>{i. i < n}. [0 = 0] (mod m i)\n  degree 0 < (\\<Sum>i | i < n. degree (m i))\n  \\<exists>!x.\n     degree x < (\\<Sum>i | i < n. degree (m i)) \\<and>\n     (\\<forall>i\\<in>{i. i < n}. [x = 0] (mod m i))\n\ngoal (1 subgoal):\n 1. x = 0", "by blast"], ["proof (state)\nthis:\n  x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (\\<lambda>v. vec n (\\<lambda>i. coeff (v mod m i) 0))\n   (carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "moreover"], ["proof (state)\nthis:\n  inj_on (\\<lambda>v. vec n (\\<lambda>i. coeff (v mod m i) 0))\n   (carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "have \"?f ` (carrier W) = ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v. vec n (\\<lambda>i. coeff (v mod m i) 0)) `\n    carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}) =\n    carrier_vec (card P)", "proof (auto simp add: image_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>[xa ^ CARD('a) = xa] (mod u); degree xa < degree u\\<rbrakk>\n       \\<Longrightarrow> n = card P\n 2. \\<And>x.\n       x \\<in> carrier_vec (card P) \\<Longrightarrow>\n       \\<exists>xa.\n          [xa ^ CARD('a) = xa] (mod u) \\<and>\n          degree xa < degree u \\<and>\n          x = vec n (\\<lambda>i. coeff (xa mod m i) 0)", "fix xa"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>[xa ^ CARD('a) = xa] (mod u); degree xa < degree u\\<rbrakk>\n       \\<Longrightarrow> n = card P\n 2. \\<And>x.\n       x \\<in> carrier_vec (card P) \\<Longrightarrow>\n       \\<exists>xa.\n          [xa ^ CARD('a) = xa] (mod u) \\<and>\n          degree xa < degree u \\<and>\n          x = vec n (\\<lambda>i. coeff (xa mod m i) 0)", "show \"n = card P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = card P", "by (auto simp add: n)"], ["proof (state)\nthis:\n  n = card P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier_vec (card P) \\<Longrightarrow>\n       \\<exists>xa.\n          [xa ^ CARD('a) = xa] (mod u) \\<and>\n          degree xa < degree u \\<and>\n          x = vec n (\\<lambda>i. coeff (xa mod m i) 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier_vec (card P) \\<Longrightarrow>\n       \\<exists>xa.\n          [xa ^ CARD('a) = xa] (mod u) \\<and>\n          degree xa < degree u \\<and>\n          x = vec n (\\<lambda>i. coeff (xa mod m i) 0)", "fix x::\"'a mod_ring vec\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier_vec (card P) \\<Longrightarrow>\n       \\<exists>xa.\n          [xa ^ CARD('a) = xa] (mod u) \\<and>\n          degree xa < degree u \\<and>\n          x = vec n (\\<lambda>i. coeff (xa mod m i) 0)", "assume x: \"x \\<in> carrier_vec (card P)\""], ["proof (state)\nthis:\n  x \\<in> carrier_vec (card P)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier_vec (card P) \\<Longrightarrow>\n       \\<exists>xa.\n          [xa ^ CARD('a) = xa] (mod u) \\<and>\n          degree xa < degree u \\<and>\n          x = vec n (\\<lambda>i. coeff (xa mod m i) 0)", "have \" \\<exists>!v. degree v < (\\<Sum>i\\<in>{i. i < n}. degree (m i)) \\<and> (\\<forall>i\\<in>{i. i < n}. [v = (\\<lambda>i. [:x $ i:]) i] (mod m i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!v.\n       degree v < (\\<Sum>i | i < n. degree (m i)) \\<and>\n       (\\<forall>i\\<in>{i. i < n}. [v = [:x $ i:]] (mod m i))", "proof (rule chinese_remainder_unique_poly[OF not_zero])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>{i. i < n}.\n       \\<forall>j\\<in>{i. i < n}.\n          i \\<noteq> j \\<longrightarrow>\n          algebraic_semidom_class.coprime (m i) (m j)\n 2. 0 < degree (prod m {i. i < n})", "show \"0 < degree (prod m {i. i < n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree (prod m {i. i < n})", "using deg_u0 degree_prod"], ["proof (prove)\nusing this:\n  0 < degree u\n  degree (prod m {i. i < n}) = degree u\n\ngoal (1 subgoal):\n 1. 0 < degree (prod m {i. i < n})", "by linarith"], ["proof (state)\nthis:\n  0 < degree (prod m {i. i < n})\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{i. i < n}.\n       \\<forall>j\\<in>{i. i < n}.\n          i \\<noteq> j \\<longrightarrow>\n          algebraic_semidom_class.coprime (m i) (m j)", "qed (insert coprime_mi_mj, auto)"], ["proof (state)\nthis:\n  \\<exists>!v.\n     degree v < (\\<Sum>i | i < n. degree (m i)) \\<and>\n     (\\<forall>i\\<in>{i. i < n}. [v = [:x $ i:]] (mod m i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier_vec (card P) \\<Longrightarrow>\n       \\<exists>xa.\n          [xa ^ CARD('a) = xa] (mod u) \\<and>\n          degree xa < degree u \\<and>\n          x = vec n (\\<lambda>i. coeff (xa mod m i) 0)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>!v.\n     degree v < (\\<Sum>i | i < n. degree (m i)) \\<and>\n     (\\<forall>i\\<in>{i. i < n}. [v = [:x $ i:]] (mod m i))", "obtain v where deg_v: \"degree v < (\\<Sum>i\\<in>{i. i < n}. degree (m i))\"\n      and v_x_cong: \"(\\<forall>i \\<in> {i. i < n}. [v = (\\<lambda>i. [:x $ i:]) i] (mod m i))\""], ["proof (prove)\nusing this:\n  \\<exists>!v.\n     degree v < (\\<Sum>i | i < n. degree (m i)) \\<and>\n     (\\<forall>i\\<in>{i. i < n}. [v = [:x $ i:]] (mod m i))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>degree v < (\\<Sum>i | i < n. degree (m i));\n         \\<forall>i\\<in>{i. i < n}. [v = [:x $ i:]] (mod m i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  degree v < (\\<Sum>i | i < n. degree (m i))\n  \\<forall>i\\<in>{i. i < n}. [v = [:x $ i:]] (mod m i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier_vec (card P) \\<Longrightarrow>\n       \\<exists>xa.\n          [xa ^ CARD('a) = xa] (mod u) \\<and>\n          degree xa < degree u \\<and>\n          x = vec n (\\<lambda>i. coeff (xa mod m i) 0)", "show \"\\<exists>xa. [xa ^ CARD('a) = xa] (mod u) \\<and> degree xa < degree u\n      \\<and> x = vec n (\\<lambda>i. coeff (xa mod m i) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xa.\n       [xa ^ CARD('a) = xa] (mod u) \\<and>\n       degree xa < degree u \\<and>\n       x = vec n (\\<lambda>i. coeff (xa mod m i) 0)", "proof (rule exI[of _ v], auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. [v ^ CARD('a) = v] (mod u)\n 2. degree v < degree u\n 3. x = vec n (\\<lambda>i. coeff (v mod m i) 0)", "show v: \"[v ^ CARD('a) = v] (mod u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod u)", "proof (unfold u_desc_square_free, rule coprime_cong_mult_factorization_poly[OF finite_P], auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> irreducible x\n 2. \\<And>x. x \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod x)\n 3. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<in> P; p2 \\<in> P; p1 \\<noteq> p2\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime p1 p2", "fix y"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> irreducible x\n 2. \\<And>x. x \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod x)\n 3. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<in> P; p2 \\<in> P; p1 \\<noteq> p2\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime p1 p2", "assume y: \"y \\<in> P\""], ["proof (state)\nthis:\n  y \\<in> P\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> irreducible x\n 2. \\<And>x. x \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod x)\n 3. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<in> P; p2 \\<in> P; p1 \\<noteq> p2\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime p1 p2", "thus \"irreducible y\""], ["proof (prove)\nusing this:\n  y \\<in> P\n\ngoal (1 subgoal):\n 1. irreducible y", "using P"], ["proof (prove)\nusing this:\n  y \\<in> P\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible y", "by blast"], ["proof (state)\nthis:\n  irreducible y\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod x)\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<in> P; p2 \\<in> P; p1 \\<noteq> p2\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime p1 p2", "obtain i where i: \"i \\<in> {i. i < n}\" and mi: \"y = m i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> {i. i < n}; y = m i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using P_m y"], ["proof (prove)\nusing this:\n  P = m ` {i. i < n}\n  y \\<in> P\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> {i. i < n}; y = m i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i \\<in> {i. i < n}\n  y = m i\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod x)\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<in> P; p2 \\<in> P; p1 \\<noteq> p2\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime p1 p2", "have \"irreducible (m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible (m i)", "using i P_m P"], ["proof (prove)\nusing this:\n  i \\<in> {i. i < n}\n  P = m ` {i. i < n}\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible (m i)", "by auto"], ["proof (state)\nthis:\n  irreducible (m i)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod x)\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<in> P; p2 \\<in> P; p1 \\<noteq> p2\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime p1 p2", "moreover"], ["proof (state)\nthis:\n  irreducible (m i)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod x)\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<in> P; p2 \\<in> P; p1 \\<noteq> p2\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime p1 p2", "have \"[v = [:x $ i:]] (mod m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [v = [:x $ i:]] (mod m i)", "using v_x_cong i"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{i. i < n}. [v = [:x $ i:]] (mod m i)\n  i \\<in> {i. i < n}\n\ngoal (1 subgoal):\n 1. [v = [:x $ i:]] (mod m i)", "by auto"], ["proof (state)\nthis:\n  [v = [:x $ i:]] (mod m i)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod x)\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<in> P; p2 \\<in> P; p1 \\<noteq> p2\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime p1 p2", "ultimately"], ["proof (chain)\npicking this:\n  irreducible (m i)\n  [v = [:x $ i:]] (mod m i)", "have v_mi_eq_xi: \"v mod m i = [:x $ i:]\""], ["proof (prove)\nusing this:\n  irreducible (m i)\n  [v = [:x $ i:]] (mod m i)\n\ngoal (1 subgoal):\n 1. v mod m i = [:x $ i:]", "by (auto simp: cong_def intro!: mod_poly_less)"], ["proof (state)\nthis:\n  v mod m i = [:x $ i:]\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod x)\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<in> P; p2 \\<in> P; p1 \\<noteq> p2\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime p1 p2", "have xi_pow_xi: \"[:x $ i:]^CARD('a) = [:x $ i:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:x $ i:] ^ CARD('a) = [:x $ i:]", "by (simp add: poly_const_pow)"], ["proof (state)\nthis:\n  [:x $ i:] ^ CARD('a) = [:x $ i:]\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod x)\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<in> P; p2 \\<in> P; p1 \\<noteq> p2\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime p1 p2", "hence \"(v mod m i)^CARD('a) = v mod m i\""], ["proof (prove)\nusing this:\n  [:x $ i:] ^ CARD('a) = [:x $ i:]\n\ngoal (1 subgoal):\n 1. (v mod m i) ^ CARD('a) = v mod m i", "using v_mi_eq_xi"], ["proof (prove)\nusing this:\n  [:x $ i:] ^ CARD('a) = [:x $ i:]\n  v mod m i = [:x $ i:]\n\ngoal (1 subgoal):\n 1. (v mod m i) ^ CARD('a) = v mod m i", "by auto"], ["proof (state)\nthis:\n  (v mod m i) ^ CARD('a) = v mod m i\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod x)\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<in> P; p2 \\<in> P; p1 \\<noteq> p2\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime p1 p2", "hence \"(v mod m i)^CARD('a) = (v^CARD('a) mod m i)\""], ["proof (prove)\nusing this:\n  (v mod m i) ^ CARD('a) = v mod m i\n\ngoal (1 subgoal):\n 1. (v mod m i) ^ CARD('a) = v ^ CARD('a) mod m i", "by (metis mod_mod_trivial power_mod)"], ["proof (state)\nthis:\n  (v mod m i) ^ CARD('a) = v ^ CARD('a) mod m i\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> [v ^ CARD('a) = v] (mod x)\n 2. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<in> P; p2 \\<in> P; p1 \\<noteq> p2\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime p1 p2", "thus \"[v ^ CARD('a) = v] (mod y)\""], ["proof (prove)\nusing this:\n  (v mod m i) ^ CARD('a) = v ^ CARD('a) mod m i\n\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod y)", "unfolding mi cong_def v_mi_eq_xi xi_pow_xi"], ["proof (prove)\nusing this:\n  [:x $ i:] = v ^ CARD('a) mod m i\n\ngoal (1 subgoal):\n 1. v ^ CARD('a) mod m i = [:x $ i:]", "by simp"], ["proof (state)\nthis:\n  [v ^ CARD('a) = v] (mod y)\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<in> P; p2 \\<in> P; p1 \\<noteq> p2\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime p1 p2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<in> P; p2 \\<in> P; p1 \\<noteq> p2\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime p1 p2", "fix p1 p2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<in> P; p2 \\<in> P; p1 \\<noteq> p2\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime p1 p2", "assume \"p1 \\<in> P\" and \"p2 \\<in> P\" and \"p1 \\<noteq> p2\""], ["proof (state)\nthis:\n  p1 \\<in> P\n  p2 \\<in> P\n  p1 \\<noteq> p2\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>p1 \\<in> P; p2 \\<in> P; p1 \\<noteq> p2\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime p1 p2", "then"], ["proof (chain)\npicking this:\n  p1 \\<in> P\n  p2 \\<in> P\n  p1 \\<noteq> p2", "show \"Rings.coprime p1 p2\""], ["proof (prove)\nusing this:\n  p1 \\<in> P\n  p2 \\<in> P\n  p1 \\<noteq> p2\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime p1 p2", "using coprime_polynomial_factorization[OF P finite_P]"], ["proof (prove)\nusing this:\n  p1 \\<in> P\n  p2 \\<in> P\n  p1 \\<noteq> p2\n  \\<lbrakk>?a1.0 \\<in> P; ?a2.0 \\<in> P; ?a1.0 \\<noteq> ?a2.0\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?a1.0 ?a2.0\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime p1 p2", "by auto"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime p1 p2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [v ^ CARD('a) = v] (mod u)\n\ngoal (2 subgoals):\n 1. degree v < degree u\n 2. x = vec n (\\<lambda>i. coeff (v mod m i) 0)", "show \"degree v < degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree v < degree u", "using deg_v deg_sum_eq degree_prod"], ["proof (prove)\nusing this:\n  degree v < (\\<Sum>i | i < n. degree (m i))\n  (\\<Sum>i | i < n. degree (m i)) = degree u\n  degree (prod m {i. i < n}) = degree u\n\ngoal (1 subgoal):\n 1. degree v < degree u", "by presburger"], ["proof (state)\nthis:\n  degree v < degree u\n\ngoal (1 subgoal):\n 1. x = vec n (\\<lambda>i. coeff (v mod m i) 0)", "show \"x = vec n (\\<lambda>i. coeff (v mod m i) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = vec n (\\<lambda>i. coeff (v mod m i) 0)", "proof (unfold vec_eq_iff, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. dim_vec x = dim_vec (vec n (\\<lambda>i. coeff (v mod m i) 0))\n 2. \\<forall>i<dim_vec (vec n (\\<lambda>i. coeff (v mod m i) 0)).\n       x $ i = vec n (\\<lambda>i. coeff (v mod m i) 0) $ i", "show \"dim_vec x = dim_vec (vec n (\\<lambda>i. coeff (v mod m i) 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec x = dim_vec (vec n (\\<lambda>i. coeff (v mod m i) 0))", "using x n"], ["proof (prove)\nusing this:\n  x \\<in> carrier_vec (card P)\n  n = card P\n\ngoal (1 subgoal):\n 1. dim_vec x = dim_vec (vec n (\\<lambda>i. coeff (v mod m i) 0))", "by simp"], ["proof (state)\nthis:\n  dim_vec x = dim_vec (vec n (\\<lambda>i. coeff (v mod m i) 0))\n\ngoal (1 subgoal):\n 1. \\<forall>i<dim_vec (vec n (\\<lambda>i. coeff (v mod m i) 0)).\n       x $ i = vec n (\\<lambda>i. coeff (v mod m i) 0) $ i", "show \"\\<forall>i<dim_vec (vec n (\\<lambda>i. coeff (v mod m i) 0)). x $ i = vec n (\\<lambda>i. coeff (v mod m i) 0) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<dim_vec (vec n (\\<lambda>i. coeff (v mod m i) 0)).\n       x $ i = vec n (\\<lambda>i. coeff (v mod m i) 0) $ i", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> x $ i = coeff (v mod m i) 0", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> x $ i = coeff (v mod m i) 0", "assume i: \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> x $ i = coeff (v mod m i) 0", "have deg_mi: \"irreducible (m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible (m i)", "using i P_m P"], ["proof (prove)\nusing this:\n  i < n\n  P = m ` {i. i < n}\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible (m i)", "by auto"], ["proof (state)\nthis:\n  irreducible (m i)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> x $ i = coeff (v mod m i) 0", "have deg_v_mi: \"degree (v mod m i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (v mod m i) = 0", "proof (rule degree_u_mod_irreducible\\<^sub>d_factor_0[OF _ finite_P u_desc_square_free P])"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> {v. [v ^ CARD('a) = v] (mod u)}\n 2. m i \\<in> P", "show \"v \\<in> {v. [v ^ CARD('a) = v] (mod u)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> {v. [v ^ CARD('a) = v] (mod u)}", "using v"], ["proof (prove)\nusing this:\n  [v ^ CARD('a) = v] (mod u)\n\ngoal (1 subgoal):\n 1. v \\<in> {v. [v ^ CARD('a) = v] (mod u)}", "by fast"], ["proof (state)\nthis:\n  v \\<in> {v. [v ^ CARD('a) = v] (mod u)}\n\ngoal (1 subgoal):\n 1. m i \\<in> P", "show \"m i \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m i \\<in> P", "using P_m i"], ["proof (prove)\nusing this:\n  P = m ` {i. i < n}\n  i < n\n\ngoal (1 subgoal):\n 1. m i \\<in> P", "by auto"], ["proof (state)\nthis:\n  m i \\<in> P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (v mod m i) = 0\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> x $ i = coeff (v mod m i) 0", "have \"v mod m i = [:x $ i:] mod m i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v mod m i = [:x $ i:] mod m i", "using v_x_cong i"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{i. i < n}. [v = [:x $ i:]] (mod m i)\n  i < n\n\ngoal (1 subgoal):\n 1. v mod m i = [:x $ i:] mod m i", "unfolding cong_def"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{i. i < n}. v mod m i = [:x $ i:] mod m i\n  i < n\n\ngoal (1 subgoal):\n 1. v mod m i = [:x $ i:] mod m i", "by auto"], ["proof (state)\nthis:\n  v mod m i = [:x $ i:] mod m i\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> x $ i = coeff (v mod m i) 0", "also"], ["proof (state)\nthis:\n  v mod m i = [:x $ i:] mod m i\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> x $ i = coeff (v mod m i) 0", "have \"... = [:x $ i:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:x $ i:] mod m i = [:x $ i:]", "using deg_mi"], ["proof (prove)\nusing this:\n  irreducible (m i)\n\ngoal (1 subgoal):\n 1. [:x $ i:] mod m i = [:x $ i:]", "by (auto intro!: mod_poly_less)"], ["proof (state)\nthis:\n  [:x $ i:] mod m i = [:x $ i:]\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> x $ i = coeff (v mod m i) 0", "finally"], ["proof (chain)\npicking this:\n  v mod m i = [:x $ i:]", "show \"x $ i = coeff (v mod m i) 0\""], ["proof (prove)\nusing this:\n  v mod m i = [:x $ i:]\n\ngoal (1 subgoal):\n 1. x $ i = coeff (v mod m i) 0", "by simp"], ["proof (state)\nthis:\n  x $ i = coeff (v mod m i) 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<dim_vec (vec n (\\<lambda>i. coeff (v mod m i) 0)).\n     x $ i = vec n (\\<lambda>i. coeff (v mod m i) 0) $ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = vec n (\\<lambda>i. coeff (v mod m i) 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xa.\n     [xa ^ CARD('a) = xa] (mod u) \\<and>\n     degree xa < degree u \\<and>\n     x = vec n (\\<lambda>i. coeff (xa mod m i) 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>v. vec n (\\<lambda>i. coeff (v mod m i) 0)) `\n  carrier\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}) =\n  carrier_vec (card P)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "ultimately"], ["proof (chain)\npicking this:\n  linear_map class_ring\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n   (module_vec TYPE('a mod_ring) n)\n   (\\<lambda>v. vec n (\\<lambda>i. coeff (v mod m i) 0))\n  inj_on (\\<lambda>v. vec n (\\<lambda>i. coeff (v mod m i) 0))\n   (carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n  (\\<lambda>v. vec n (\\<lambda>i. coeff (v mod m i) 0)) `\n  carrier\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}) =\n  carrier_vec (card P)", "show ?thesis"], ["proof (prove)\nusing this:\n  linear_map class_ring\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n   (module_vec TYPE('a mod_ring) n)\n   (\\<lambda>v. vec n (\\<lambda>i. coeff (v mod m i) 0))\n  inj_on (\\<lambda>v. vec n (\\<lambda>i. coeff (v mod m i) 0))\n   (carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n  (\\<lambda>v. vec n (\\<lambda>i. coeff (v mod m i) 0)) `\n  carrier\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}) =\n  carrier_vec (card P)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       bij_betw f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n        (carrier_vec (card P))", "unfolding bij_betw_def n"], ["proof (prove)\nusing this:\n  linear_map class_ring\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n   (module_vec TYPE('a mod_ring) (card P))\n   (\\<lambda>v. vec (card P) (\\<lambda>i. coeff (v mod m i) 0))\n  inj_on (\\<lambda>v. vec (card P) (\\<lambda>i. coeff (v mod m i) 0))\n   (carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n  (\\<lambda>v. vec (card P) (\\<lambda>i. coeff (v mod m i) 0)) `\n  carrier\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}) =\n  carrier_vec (card P)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       linear_map class_ring\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n        (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n       inj_on f\n        (carrier\n          (vector_space_poly.vs\n            {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                degree v < degree u})) \\<and>\n       f `\n       carrier\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}) =\n       carrier_vec (card P)", "by auto"], ["proof (state)\nthis:\n  \\<exists>f.\n     linear_map class_ring\n      (vector_space_poly.vs\n        {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n      (module_vec TYPE('a mod_ring) (card P)) f \\<and>\n     bij_betw f\n      (carrier\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n      (carrier_vec (card P))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fin_dim_kernel_berlekamp: \"V.fin_dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V.fin_dim", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. V.fin_dim", "have \"finite (set (find_base_vectors (berlekamp_resulting_mat u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set (find_base_vectors (berlekamp_resulting_mat u)))", "by auto"], ["proof (state)\nthis:\n  finite (set (find_base_vectors (berlekamp_resulting_mat u)))\n\ngoal (1 subgoal):\n 1. V.fin_dim", "moreover"], ["proof (state)\nthis:\n  finite (set (find_base_vectors (berlekamp_resulting_mat u)))\n\ngoal (1 subgoal):\n 1. V.fin_dim", "have \"set (find_base_vectors (berlekamp_resulting_mat u)) \\<subseteq> carrier V\"\n  and \"V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_base_vectors (berlekamp_resulting_mat u))\n    \\<subseteq> carrier V &&&\n    V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u)))", "using berlekamp_resulting_mat_basis[of u]"], ["proof (prove)\nusing this:\n  V.basis (set (find_base_vectors (berlekamp_resulting_mat u)))\n\ngoal (1 subgoal):\n 1. set (find_base_vectors (berlekamp_resulting_mat u))\n    \\<subseteq> carrier V &&&\n    V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u)))", "unfolding V.basis_def"], ["proof (prove)\nusing this:\n  V.lin_indpt (set (find_base_vectors (berlekamp_resulting_mat u))) \\<and>\n  V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u))) \\<and>\n  set (find_base_vectors (berlekamp_resulting_mat u)) \\<subseteq> carrier V\n\ngoal (1 subgoal):\n 1. set (find_base_vectors (berlekamp_resulting_mat u))\n    \\<subseteq> carrier V &&&\n    V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u)))", "by auto"], ["proof (state)\nthis:\n  set (find_base_vectors (berlekamp_resulting_mat u)) \\<subseteq> carrier V\n  V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u)))\n\ngoal (1 subgoal):\n 1. V.fin_dim", "ultimately"], ["proof (chain)\npicking this:\n  finite (set (find_base_vectors (berlekamp_resulting_mat u)))\n  set (find_base_vectors (berlekamp_resulting_mat u)) \\<subseteq> carrier V\n  V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u)))", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (set (find_base_vectors (berlekamp_resulting_mat u)))\n  set (find_base_vectors (berlekamp_resulting_mat u)) \\<subseteq> carrier V\n  V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u)))\n\ngoal (1 subgoal):\n 1. V.fin_dim", "unfolding V.fin_dim_def"], ["proof (prove)\nusing this:\n  finite (set (find_base_vectors (berlekamp_resulting_mat u)))\n  set (find_base_vectors (berlekamp_resulting_mat u)) \\<subseteq> carrier V\n  V.gen_set (set (find_base_vectors (berlekamp_resulting_mat u)))\n\ngoal (1 subgoal):\n 1. \\<exists>A. finite A \\<and> A \\<subseteq> carrier V \\<and> V.gen_set A", "by auto"], ["proof (state)\nthis:\n  V.fin_dim\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Berlekamp_subspace_fin_dim: \"Berlekamp_subspace.fin_dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Berlekamp_subspace.fin_dim", "proof (rule linear_map.surj_fin_dim[OF linear_map_Poly_list_of_vec'])"], ["proof (state)\ngoal (2 subgoals):\n 1. V.fin_dim\n 2. (Poly \\<circ> list_of_vec) ` carrier V =\n    carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "show \"(Poly \\<circ> list_of_vec) ` carrier V = carrier W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Poly \\<circ> list_of_vec) ` carrier V =\n    carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "using surj_Poly_list_of_vec[OF deg_u0]"], ["proof (prove)\nusing this:\n  (Poly \\<circ> list_of_vec) ` carrier V =\n  carrier\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. (Poly \\<circ> list_of_vec) ` carrier V =\n    carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})", "by auto"], ["proof (state)\nthis:\n  (Poly \\<circ> list_of_vec) ` carrier V =\n  carrier\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n\ngoal (1 subgoal):\n 1. V.fin_dim", "show \"V.fin_dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V.fin_dim", "by (rule fin_dim_kernel_berlekamp)"], ["proof (state)\nthis:\n  V.fin_dim\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes P\n  assumes finite_P: \"finite P\"\n  and u_desc_square_free: \"u = (\\<Prod>a\\<in>P. a)\"\n  and P: \"P \\<subseteq> {q. irreducible q \\<and> monic q}\"\nbegin"], ["", "interpretation RV: vec_space \"TYPE('a mod_ring)\" \"card P\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Berlekamp_subspace_eq_dim_vec: \"Berlekamp_subspace.dim = RV.dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Berlekamp_subspace.dim = RV.dim", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Berlekamp_subspace.dim = RV.dim", "obtain f where lm_f: \"linear_map class_ring W (module_vec TYPE('a mod_ring) (card P)) f\"\n  and bij_f: \"bij_betw f (carrier W) (carrier_vec (card P)::'a mod_ring vec set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>linear_map class_ring\n                  (vector_space_poly.vs\n                    {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                        degree v < degree u})\n                  RV.V f;\n         bij_betw f\n          (carrier\n            (vector_space_poly.vs\n              {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n          (carrier_vec (card P))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using exists_bijective_linear_map_W_vec[OF finite_P u_desc_square_free P]"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     linear_map class_ring\n      (vector_space_poly.vs\n        {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n      RV.V f \\<and>\n     bij_betw f\n      (carrier\n        (vector_space_poly.vs\n          {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n      (carrier_vec (card P))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>linear_map class_ring\n                  (vector_space_poly.vs\n                    {v. [v ^ CARD('a) = v] (mod u) \\<and>\n                        degree v < degree u})\n                  RV.V f;\n         bij_betw f\n          (carrier\n            (vector_space_poly.vs\n              {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n          (carrier_vec (card P))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  linear_map class_ring\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})\n   RV.V f\n  bij_betw f\n   (carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n   (carrier_vec (card P))\n\ngoal (1 subgoal):\n 1. Berlekamp_subspace.dim = RV.dim", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Berlekamp_subspace.dim = RV.dim", "proof (rule linear_map.dim_eq[OF lm_f Berlekamp_subspace_fin_dim])"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on f\n     (carrier\n       (vector_space_poly.vs\n         {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n 2. f `\n    carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}) =\n    carrier RV.V", "show \"inj_on f (carrier W)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f\n     (carrier\n       (vector_space_poly.vs\n         {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))", "by (rule bij_betw_imp_inj_on[OF bij_f])"], ["proof (state)\nthis:\n  inj_on f\n   (carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n\ngoal (1 subgoal):\n 1. f `\n    carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}) =\n    carrier RV.V", "show \" f ` carrier W = carrier RV.V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f `\n    carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}) =\n    carrier RV.V", "using bij_f"], ["proof (prove)\nusing this:\n  bij_betw f\n   (carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}))\n   (carrier_vec (card P))\n\ngoal (1 subgoal):\n 1. f `\n    carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}) =\n    carrier RV.V", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj_on f\n   (carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u})) \\<and>\n  f `\n  carrier\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}) =\n  carrier_vec (card P)\n\ngoal (1 subgoal):\n 1. f `\n    carrier\n     (vector_space_poly.vs\n       {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}) =\n    carrier RV.V", "by auto"], ["proof (state)\nthis:\n  f `\n  carrier\n   (vector_space_poly.vs\n     {v. [v ^ CARD('a) = v] (mod u) \\<and> degree v < degree u}) =\n  carrier RV.V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Berlekamp_subspace.dim = RV.dim\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Berlekamp_subspace_dim: \"Berlekamp_subspace.dim = card P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Berlekamp_subspace.dim = card P", "using Berlekamp_subspace_eq_dim_vec RV.dim_is_n"], ["proof (prove)\nusing this:\n  Berlekamp_subspace.dim = RV.dim\n  RV.dim = card P\n\ngoal (1 subgoal):\n 1. Berlekamp_subspace.dim = card P", "by simp"], ["", "corollary card_berlekamp_basis_number_factors: \"card (set (berlekamp_basis u)) = card P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (berlekamp_basis u)) = card P", "unfolding Berlekamp_subspace_dim[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (berlekamp_basis u)) = Berlekamp_subspace.dim", "by (rule Berlekamp_subspace.dim_basis[symmetric], auto simp add: berlekamp_basis_basis)"], ["", "lemma length_berlekamp_basis_numbers_factors: \"length (berlekamp_basis u) = card P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (berlekamp_basis u) = card P", "using card_set_berlekamp_basis card_berlekamp_basis_number_factors"], ["proof (prove)\nusing this:\n  card (set (berlekamp_basis u)) = length (berlekamp_basis u)\n  card (set (berlekamp_basis u)) = card P\n\ngoal (1 subgoal):\n 1. length (berlekamp_basis u) = card P", "by auto"], ["", "end"], ["", "end"], ["", "end"], ["", "end"], ["", "context\n  assumes \"SORT_CONSTRAINT('a :: prime_card)\"\nbegin"], ["", "context\n  fixes f :: \"'a mod_ring poly\" and n\n  assumes sf: \"square_free f\"\n  and n: \"n = length (berlekamp_basis f)\"\n  and monic_f: \"monic f\"\nbegin"], ["", "lemma berlekamp_basis_length_factorization: assumes f: \"f = prod_list us\"\n  and d: \"\\<And> u. u \\<in> set us \\<Longrightarrow> degree u > 0\"\n  shows \"length us \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length us \\<le> n", "proof (cases \"degree f = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree f = 0 \\<Longrightarrow> length us \\<le> n\n 2. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "case True"], ["proof (state)\nthis:\n  degree f = 0\n\ngoal (2 subgoals):\n 1. degree f = 0 \\<Longrightarrow> length us \\<le> n\n 2. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "have \"us = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us = []", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. us \\<noteq> [] \\<Longrightarrow> False", "assume \"us \\<noteq> []\""], ["proof (state)\nthis:\n  us \\<noteq> []\n\ngoal (1 subgoal):\n 1. us \\<noteq> [] \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  us \\<noteq> []", "obtain u where u: \"u \\<in> set us\""], ["proof (prove)\nusing this:\n  us \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>u. u \\<in> set us \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  u \\<in> set us\n\ngoal (1 subgoal):\n 1. us \\<noteq> [] \\<Longrightarrow> False", "hence deg_u: \"degree u > 0\""], ["proof (prove)\nusing this:\n  u \\<in> set us\n\ngoal (1 subgoal):\n 1. 0 < degree u", "using d"], ["proof (prove)\nusing this:\n  u \\<in> set us\n  ?u \\<in> set us \\<Longrightarrow> 0 < degree ?u\n\ngoal (1 subgoal):\n 1. 0 < degree u", "by auto"], ["proof (state)\nthis:\n  0 < degree u\n\ngoal (1 subgoal):\n 1. us \\<noteq> [] \\<Longrightarrow> False", "have \"degree f = degree (prod_list us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f = degree (prod_list us)", "unfolding f"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod_list us) = degree (prod_list us)", ".."], ["proof (state)\nthis:\n  degree f = degree (prod_list us)\n\ngoal (1 subgoal):\n 1. us \\<noteq> [] \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree f = degree (prod_list us)\n\ngoal (1 subgoal):\n 1. us \\<noteq> [] \\<Longrightarrow> False", "have \"... = sum_list (map degree us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod_list us) = sum_list (map degree us)", "proof (rule degree_prod_list_eq)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> set us \\<Longrightarrow> p \\<noteq> 0", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> set us \\<Longrightarrow> p \\<noteq> 0", "assume p: \"p \\<in> set us\""], ["proof (state)\nthis:\n  p \\<in> set us\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> set us \\<Longrightarrow> p \\<noteq> 0", "show \"p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using d[OF p] degree_0"], ["proof (prove)\nusing this:\n  0 < degree p\n  degree 0 = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (prod_list us) = sum_list (map degree us)\n\ngoal (1 subgoal):\n 1. us \\<noteq> [] \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree (prod_list us) = sum_list (map degree us)\n\ngoal (1 subgoal):\n 1. us \\<noteq> [] \\<Longrightarrow> False", "have \" ... \\<ge> degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree u \\<le> sum_list (map degree us)", "by (simp add: member_le_sum_list u)"], ["proof (state)\nthis:\n  degree u \\<le> sum_list (map degree us)\n\ngoal (1 subgoal):\n 1. us \\<noteq> [] \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  degree u \\<le> degree f", "have \"degree f > 0\""], ["proof (prove)\nusing this:\n  degree u \\<le> degree f\n\ngoal (1 subgoal):\n 1. 0 < degree f", "using deg_u"], ["proof (prove)\nusing this:\n  degree u \\<le> degree f\n  0 < degree u\n\ngoal (1 subgoal):\n 1. 0 < degree f", "by auto"], ["proof (state)\nthis:\n  0 < degree f\n\ngoal (1 subgoal):\n 1. us \\<noteq> [] \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  0 < degree f\n\ngoal (1 subgoal):\n 1. False", "using True"], ["proof (prove)\nusing this:\n  0 < degree f\n  degree f = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  us = []\n\ngoal (2 subgoals):\n 1. degree f = 0 \\<Longrightarrow> length us \\<le> n\n 2. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "thus ?thesis"], ["proof (prove)\nusing this:\n  us = []\n\ngoal (1 subgoal):\n 1. length us \\<le> n", "by simp"], ["proof (state)\nthis:\n  length us \\<le> n\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "case False"], ["proof (state)\nthis:\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "hence f_not_0: \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "using degree_0"], ["proof (prove)\nusing this:\n  degree f \\<noteq> 0\n  degree 0 = 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "obtain P where fin_P: \"finite P\" and f_P: \"f = \\<Prod>P\" and P: \"P \\<subseteq> {p. irreducible p \\<and> monic p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>finite P; f = \\<Prod>P;\n         P \\<subseteq> {p. irreducible p \\<and> monic p}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using monic_square_free_irreducible_factorization[OF monic_f sf]"], ["proof (prove)\nusing this:\n  \\<exists>P.\n     finite P \\<and>\n     f = \\<Prod>P \\<and> P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>finite P; f = \\<Prod>P;\n         P \\<subseteq> {p. irreducible p \\<and> monic p}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite P\n  f = \\<Prod>P\n  P \\<subseteq> {p. irreducible p \\<and> monic p}\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "have n_card_P: \"n = card P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = card P", "using P False f_P fin_P length_berlekamp_basis_numbers_factors n"], ["proof (prove)\nusing this:\n  P \\<subseteq> {p. irreducible p \\<and> monic p}\n  degree f \\<noteq> 0\n  f = \\<Prod>P\n  finite P\n  \\<lbrakk>0 < degree ?u; finite ?P; ?u = \\<Prod>?P;\n   ?P \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n  \\<Longrightarrow> length (berlekamp_basis ?u) = card ?P\n  n = length (berlekamp_basis f)\n\ngoal (1 subgoal):\n 1. n = card P", "by blast"], ["proof (state)\nthis:\n  n = card P\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "have distinct_us: \"distinct us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct us", "using d f sf square_free_prod_list_distinct"], ["proof (prove)\nusing this:\n  ?u \\<in> set us \\<Longrightarrow> 0 < degree ?u\n  f = prod_list us\n  square_free f\n  \\<lbrakk>square_free (prod_list ?us);\n   \\<And>u. u \\<in> set ?us \\<Longrightarrow> 0 < degree u\\<rbrakk>\n  \\<Longrightarrow> distinct ?us\n\ngoal (1 subgoal):\n 1. distinct us", "by blast"], ["proof (state)\nthis:\n  distinct us\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "let ?us'=\"(map normalize us)\""], ["proof (state)\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "have distinct_us': \"distinct ?us'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map normalize us)", "proof (auto simp add: distinct_map)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct us\n 2. inj_on normalize (set us)", "show \"distinct us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct us", "by (rule distinct_us)"], ["proof (state)\nthis:\n  distinct us\n\ngoal (1 subgoal):\n 1. inj_on normalize (set us)", "show \"inj_on normalize (set us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on normalize (set us)", "proof (auto simp add: inj_on_def, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set us; y \\<in> set us; normalize x = normalize y;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set us; y \\<in> set us; normalize x = normalize y;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "assume x: \"x \\<in> set us\" and y: \"y \\<in> set us\" and n: \"normalize x = normalize y\"\n       and x_not_y: \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<in> set us\n  y \\<in> set us\n  normalize x = normalize y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set us; y \\<in> set us; normalize x = normalize y;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "from normalize_eq_imp_smult[OF n]"], ["proof (chain)\npicking this:\n  \\<exists>c. c \\<noteq> 0 \\<and> y = Polynomial.smult c x", "obtain c where c0: \"c \\<noteq> 0\" and y_smult: \"y = smult c x\""], ["proof (prove)\nusing this:\n  \\<exists>c. c \\<noteq> 0 \\<and> y = Polynomial.smult c x\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<noteq> 0; y = Polynomial.smult c x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c \\<noteq> 0\n  y = Polynomial.smult c x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set us; y \\<in> set us; normalize x = normalize y;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have sf_xy: \"square_free (x*y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (x * y)", "proof (rule square_free_factor[OF _ sf])"], ["proof (state)\ngoal (1 subgoal):\n 1. x * y dvd f", "have \"x*y = prod_list [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = prod_list [x, y]", "by simp"], ["proof (state)\nthis:\n  x * y = prod_list [x, y]\n\ngoal (1 subgoal):\n 1. x * y dvd f", "also"], ["proof (state)\nthis:\n  x * y = prod_list [x, y]\n\ngoal (1 subgoal):\n 1. x * y dvd f", "have \"... dvd prod_list us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list [x, y] dvd prod_list us", "by (rule prod_list_dvd_prod_list_subset, auto simp add: x y x_not_y distinct_us)"], ["proof (state)\nthis:\n  prod_list [x, y] dvd prod_list us\n\ngoal (1 subgoal):\n 1. x * y dvd f", "also"], ["proof (state)\nthis:\n  prod_list [x, y] dvd prod_list us\n\ngoal (1 subgoal):\n 1. x * y dvd f", "have \"... = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list us = f", "unfolding f"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list us = prod_list us", ".."], ["proof (state)\nthis:\n  prod_list us = f\n\ngoal (1 subgoal):\n 1. x * y dvd f", "finally"], ["proof (chain)\npicking this:\n  x * y dvd f", "show \"x * y dvd f\""], ["proof (prove)\nusing this:\n  x * y dvd f\n\ngoal (1 subgoal):\n 1. x * y dvd f", "."], ["proof (state)\nthis:\n  x * y dvd f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  square_free (x * y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set us; y \\<in> set us; normalize x = normalize y;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have \"x * y = smult c (x*x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = Polynomial.smult c (x * x)", "using y_smult mult_smult_right"], ["proof (prove)\nusing this:\n  y = Polynomial.smult c x\n  ?p * Polynomial.smult ?a ?q = Polynomial.smult ?a (?p * ?q)\n\ngoal (1 subgoal):\n 1. x * y = Polynomial.smult c (x * x)", "by auto"], ["proof (state)\nthis:\n  x * y = Polynomial.smult c (x * x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set us; y \\<in> set us; normalize x = normalize y;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "hence sf_smult: \"square_free (smult c (x*x))\""], ["proof (prove)\nusing this:\n  x * y = Polynomial.smult c (x * x)\n\ngoal (1 subgoal):\n 1. square_free (Polynomial.smult c (x * x))", "using sf_xy"], ["proof (prove)\nusing this:\n  x * y = Polynomial.smult c (x * x)\n  square_free (x * y)\n\ngoal (1 subgoal):\n 1. square_free (Polynomial.smult c (x * x))", "by auto"], ["proof (state)\nthis:\n  square_free (Polynomial.smult c (x * x))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set us; y \\<in> set us; normalize x = normalize y;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have \"x*x dvd (smult c (x*x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * x dvd Polynomial.smult c (x * x)", "by (simp add: dvd_smult)"], ["proof (state)\nthis:\n  x * x dvd Polynomial.smult c (x * x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set us; y \\<in> set us; normalize x = normalize y;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"\\<not> square_free (smult c (x*x))\""], ["proof (prove)\nusing this:\n  x * x dvd Polynomial.smult c (x * x)\n\ngoal (1 subgoal):\n 1. \\<not> square_free (Polynomial.smult c (x * x))", "by (metis d square_free_def x)"], ["proof (state)\nthis:\n  \\<not> square_free (Polynomial.smult c (x * x))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set us; y \\<in> set us; normalize x = normalize y;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  \\<not> square_free (Polynomial.smult c (x * x))\n\ngoal (1 subgoal):\n 1. False", "using sf_smult"], ["proof (prove)\nusing this:\n  \\<not> square_free (Polynomial.smult c (x * x))\n  square_free (Polynomial.smult c (x * x))\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on normalize (set us)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (map normalize us)\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "have length_us_us': \"length us = length ?us'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length us = length (map normalize us)", "by simp"], ["proof (state)\nthis:\n  length us = length (map normalize us)\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "have f_us': \"f = prod_list ?us'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list (map normalize us)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list (map normalize us)", "have \"f = normalize f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = normalize f", "using monic_f f_not_0"], ["proof (prove)\nusing this:\n  monic f\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f = normalize f", "by (simp add: normalize_monic)"], ["proof (state)\nthis:\n  f = normalize f\n\ngoal (1 subgoal):\n 1. f = prod_list (map normalize us)", "also"], ["proof (state)\nthis:\n  f = normalize f\n\ngoal (1 subgoal):\n 1. f = prod_list (map normalize us)", "have \"... = prod_list ?us'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize f = prod_list (map normalize us)", "by (unfold f, rule prod_list_normalize[of us])"], ["proof (state)\nthis:\n  normalize f = prod_list (map normalize us)\n\ngoal (1 subgoal):\n 1. f = prod_list (map normalize us)", "finally"], ["proof (chain)\npicking this:\n  f = prod_list (map normalize us)", "show ?thesis"], ["proof (prove)\nusing this:\n  f = prod_list (map normalize us)\n\ngoal (1 subgoal):\n 1. f = prod_list (map normalize us)", "."], ["proof (state)\nthis:\n  f = prod_list (map normalize us)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = prod_list (map normalize us)\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "have \"\\<exists>Q. prod_list Q = prod_list ?us' \\<and> length ?us' \\<le> length Q\n           \\<and> (\\<forall>u. u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q.\n       prod_list Q = prod_list (map normalize us) \\<and>\n       length (map normalize us) \\<le> length Q \\<and>\n       (\\<forall>u.\n           u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "proof (rule exists_factorization_prod_list)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < degree (prod_list (map normalize us))\n 2. \\<And>u.\n       u \\<in> set (map normalize us) \\<Longrightarrow>\n       0 < degree u \\<and> monic u\n 3. square_free (prod_list (map normalize us))", "show \"degree (prod_list ?us') > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree (prod_list (map normalize us))", "using False f_us'"], ["proof (prove)\nusing this:\n  degree f \\<noteq> 0\n  f = prod_list (map normalize us)\n\ngoal (1 subgoal):\n 1. 0 < degree (prod_list (map normalize us))", "by auto"], ["proof (state)\nthis:\n  0 < degree (prod_list (map normalize us))\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       u \\<in> set (map normalize us) \\<Longrightarrow>\n       0 < degree u \\<and> monic u\n 2. square_free (prod_list (map normalize us))", "show \"square_free (prod_list ?us')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (prod_list (map normalize us))", "using f_us' sf"], ["proof (prove)\nusing this:\n  f = prod_list (map normalize us)\n  square_free f\n\ngoal (1 subgoal):\n 1. square_free (prod_list (map normalize us))", "by auto"], ["proof (state)\nthis:\n  square_free (prod_list (map normalize us))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> set (map normalize us) \\<Longrightarrow>\n       0 < degree u \\<and> monic u", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> set (map normalize us) \\<Longrightarrow>\n       0 < degree u \\<and> monic u", "assume u: \"u \\<in> set ?us'\""], ["proof (state)\nthis:\n  u \\<in> set (map normalize us)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> set (map normalize us) \\<Longrightarrow>\n       0 < degree u \\<and> monic u", "have u_not0: \"u \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "using d u degree_0"], ["proof (prove)\nusing this:\n  ?u \\<in> set us \\<Longrightarrow> 0 < degree ?u\n  u \\<in> set (map normalize us)\n  degree 0 = 0\n\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> set (map normalize us) \\<Longrightarrow>\n       0 < degree u \\<and> monic u", "have \"degree u > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree u", "using d u"], ["proof (prove)\nusing this:\n  ?u \\<in> set us \\<Longrightarrow> 0 < degree ?u\n  u \\<in> set (map normalize us)\n\ngoal (1 subgoal):\n 1. 0 < degree u", "by auto"], ["proof (state)\nthis:\n  0 < degree u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> set (map normalize us) \\<Longrightarrow>\n       0 < degree u \\<and> monic u", "moreover"], ["proof (state)\nthis:\n  0 < degree u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> set (map normalize us) \\<Longrightarrow>\n       0 < degree u \\<and> monic u", "have \"monic u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic u", "using u monic_normalize[OF u_not0]"], ["proof (prove)\nusing this:\n  u \\<in> set (map normalize us)\n  monic (normalize u)\n\ngoal (1 subgoal):\n 1. monic u", "by auto"], ["proof (state)\nthis:\n  monic u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> set (map normalize us) \\<Longrightarrow>\n       0 < degree u \\<and> monic u", "ultimately"], ["proof (chain)\npicking this:\n  0 < degree u\n  monic u", "show \"degree u > 0 \\<and> monic u\""], ["proof (prove)\nusing this:\n  0 < degree u\n  monic u\n\ngoal (1 subgoal):\n 1. 0 < degree u \\<and> monic u", "by simp"], ["proof (state)\nthis:\n  0 < degree u \\<and> monic u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q.\n     prod_list Q = prod_list (map normalize us) \\<and>\n     length (map normalize us) \\<le> length Q \\<and>\n     (\\<forall>u.\n         u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "from this"], ["proof (chain)\npicking this:\n  \\<exists>Q.\n     prod_list Q = prod_list (map normalize us) \\<and>\n     length (map normalize us) \\<le> length Q \\<and>\n     (\\<forall>u.\n         u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)", "obtain Q\n  where Q_us': \"prod_list Q = prod_list ?us'\"\n  and length_us'_Q: \"length ?us' \\<le> length Q\"\n  and Q: \"(\\<forall>u. u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)\""], ["proof (prove)\nusing this:\n  \\<exists>Q.\n     prod_list Q = prod_list (map normalize us) \\<and>\n     length (map normalize us) \\<le> length Q \\<and>\n     (\\<forall>u.\n         u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u)\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>prod_list Q = prod_list (map normalize us);\n         length (map normalize us) \\<le> length Q;\n         \\<forall>u.\n            u \\<in> set Q \\<longrightarrow>\n            irreducible u \\<and> monic u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  prod_list Q = prod_list (map normalize us)\n  length (map normalize us) \\<le> length Q\n  \\<forall>u. u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "have distinct_Q: \"distinct Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct Q", "proof (rule square_free_prod_list_distinct)"], ["proof (state)\ngoal (2 subgoals):\n 1. square_free (prod_list Q)\n 2. \\<And>u. u \\<in> set Q \\<Longrightarrow> 0 < degree u", "show \"square_free (prod_list Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (prod_list Q)", "using Q_us' f_us' sf"], ["proof (prove)\nusing this:\n  prod_list Q = prod_list (map normalize us)\n  f = prod_list (map normalize us)\n  square_free f\n\ngoal (1 subgoal):\n 1. square_free (prod_list Q)", "by auto"], ["proof (state)\nthis:\n  square_free (prod_list Q)\n\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set Q \\<Longrightarrow> 0 < degree u", "show \"\\<And>u. u \\<in> set Q \\<Longrightarrow> degree u > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set Q \\<Longrightarrow> 0 < degree u", "using Q irreducible_degree_field"], ["proof (prove)\nusing this:\n  \\<forall>u. u \\<in> set Q \\<longrightarrow> irreducible u \\<and> monic u\n  irreducible ?p \\<Longrightarrow> 0 < degree ?p\n\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set Q \\<Longrightarrow> 0 < degree u", "by auto"], ["proof (state)\nthis:\n  ?u \\<in> set Q \\<Longrightarrow> 0 < degree ?u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct Q\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "have set_Q_P: \"set Q = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set Q = P", "proof (rule monic_factorization_uniqueness)"], ["proof (state)\ngoal (5 subgoals):\n 1. finite (set Q)\n 2. \\<Prod>(set Q) = \\<Prod>P\n 3. set Q \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n 4. finite P\n 5. P \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}", "show \"\\<Prod>(set Q) = \\<Prod>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>(set Q) = \\<Prod>P", "using Q_us'"], ["proof (prove)\nusing this:\n  prod_list Q = prod_list (map normalize us)\n\ngoal (1 subgoal):\n 1. \\<Prod>(set Q) = \\<Prod>P", "by (metis distinct_Q f_P f_us' list.map_ident prod.distinct_set_conv_list)"], ["proof (state)\nthis:\n  \\<Prod>(set Q) = \\<Prod>P\n\ngoal (4 subgoals):\n 1. finite (set Q)\n 2. set Q \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}\n 3. finite P\n 4. P \\<subseteq> {q. irreducible\\<^sub>d q \\<and> monic q}", "qed (insert P Q fin_P, auto)"], ["proof (state)\nthis:\n  set Q = P\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "hence \"length Q = card P\""], ["proof (prove)\nusing this:\n  set Q = P\n\ngoal (1 subgoal):\n 1. length Q = card P", "using distinct_Q distinct_card"], ["proof (prove)\nusing this:\n  set Q = P\n  distinct Q\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. length Q = card P", "by fastforce"], ["proof (state)\nthis:\n  length Q = card P\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "have \"length us = length ?us'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length us = length (map normalize us)", "by (rule length_us_us')"], ["proof (state)\nthis:\n  length us = length (map normalize us)\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "also"], ["proof (state)\nthis:\n  length us = length (map normalize us)\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "have \"... \\<le> length Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map normalize us) \\<le> length Q", "using length_us'_Q"], ["proof (prove)\nusing this:\n  length (map normalize us) \\<le> length Q\n\ngoal (1 subgoal):\n 1. length (map normalize us) \\<le> length Q", "by auto"], ["proof (state)\nthis:\n  length (map normalize us) \\<le> length Q\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "also"], ["proof (state)\nthis:\n  length (map normalize us) \\<le> length Q\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "have \"... = card (set Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length Q = card (set Q)", "using distinct_card[OF distinct_Q]"], ["proof (prove)\nusing this:\n  card (set Q) = length Q\n\ngoal (1 subgoal):\n 1. length Q = card (set Q)", "by simp"], ["proof (state)\nthis:\n  length Q = card (set Q)\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "also"], ["proof (state)\nthis:\n  length Q = card (set Q)\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "have \"... = card P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set Q) = card P", "using set_Q_P"], ["proof (prove)\nusing this:\n  set Q = P\n\ngoal (1 subgoal):\n 1. card (set Q) = card P", "by simp"], ["proof (state)\nthis:\n  card (set Q) = card P\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0 \\<Longrightarrow> length us \\<le> n", "finally"], ["proof (chain)\npicking this:\n  length us \\<le> card P", "show ?thesis"], ["proof (prove)\nusing this:\n  length us \\<le> card P\n\ngoal (1 subgoal):\n 1. length us \\<le> n", "using n_card_P"], ["proof (prove)\nusing this:\n  length us \\<le> card P\n  n = card P\n\ngoal (1 subgoal):\n 1. length us \\<le> n", "by simp"], ["proof (state)\nthis:\n  length us \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma berlekamp_basis_irreducible: assumes f: \"f = prod_list us\"\n  and n_us: \"length us = n\"\n  and us: \"\\<And> u. u \\<in> set us \\<Longrightarrow> degree u > 0\"\n  and u: \"u \\<in> set us\"\n  shows \"irreducible u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible u", "proof (fold irreducible_connect_field, intro irreducible\\<^sub>dI[OF us[OF u]])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "fix q r :: \"'a mod_ring poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "assume dq: \"degree q > 0\" and qu: \"degree q < degree u\" and dr: \"degree r > 0\" and uqr: \"u = q * r\""], ["proof (state)\nthis:\n  0 < degree q\n  degree q < degree u\n  0 < degree r\n  u = q * r\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "with us[OF u]"], ["proof (chain)\npicking this:\n  0 < degree u\n  0 < degree q\n  degree q < degree u\n  0 < degree r\n  u = q * r", "have q: \"q \\<noteq> 0\" and r: \"r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree u\n  0 < degree q\n  degree q < degree u\n  0 < degree r\n  u = q * r\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from split_list[OF u]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. us = ys @ u # zs", "obtain xs ys where id: \"us = xs @ u # ys\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. us = ys @ u # zs\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        us = xs @ u # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  us = xs @ u # ys\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "let ?us = \"xs @ q # r # ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "have f: \"f = prod_list ?us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list (xs @ q # r # ys)", "unfolding f id uqr"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (xs @ q * r # ys) = prod_list (xs @ q # r # ys)", "by simp"], ["proof (state)\nthis:\n  f = prod_list (xs @ q # r # ys)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  f = prod_list (xs @ q # r # ys)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"x \\<in> set ?us\""], ["proof (state)\nthis:\n  x \\<in> set (xs @ q # r # ys)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "with us[unfolded id] dr dq"], ["proof (chain)\npicking this:\n  ?u \\<in> set (xs @ u # ys) \\<Longrightarrow> 0 < degree ?u\n  0 < degree r\n  0 < degree q\n  x \\<in> set (xs @ q # r # ys)", "have \"degree x > 0\""], ["proof (prove)\nusing this:\n  ?u \\<in> set (xs @ u # ys) \\<Longrightarrow> 0 < degree ?u\n  0 < degree r\n  0 < degree q\n  x \\<in> set (xs @ q # r # ys)\n\ngoal (1 subgoal):\n 1. 0 < degree x", "by auto"], ["proof (state)\nthis:\n  0 < degree x\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> set (xs @ q # r # ys) \\<Longrightarrow> 0 < degree ?x2\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from berlekamp_basis_length_factorization[OF f this]"], ["proof (chain)\npicking this:\n  (\\<And>u.\n      u \\<in> set (xs @ q # r # ys) \\<Longrightarrow>\n      u \\<in> set (xs @ q # r # ys)) \\<Longrightarrow>\n  length (xs @ q # r # ys) \\<le> n", "have \"length ?us \\<le> n\""], ["proof (prove)\nusing this:\n  (\\<And>u.\n      u \\<in> set (xs @ q # r # ys) \\<Longrightarrow>\n      u \\<in> set (xs @ q # r # ys)) \\<Longrightarrow>\n  length (xs @ q # r # ys) \\<le> n\n\ngoal (1 subgoal):\n 1. length (xs @ q # r # ys) \\<le> n", "by simp"], ["proof (state)\nthis:\n  length (xs @ q # r # ys) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  length (xs @ q # r # ys) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> = length us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = length us", "unfolding n_us"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = n", "by simp"], ["proof (state)\nthis:\n  n = length us\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  n = length us\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> < length ?us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length us < length (xs @ q # r # ys)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (xs @ u # ys) < length (xs @ q # r # ys)", "by simp"], ["proof (state)\nthis:\n  length us < length (xs @ q # r # ys)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  length (xs @ q # r # ys) < length (xs @ q # r # ys)", "show False"], ["proof (prove)\nusing this:\n  length (xs @ q # r # ys) < length (xs @ q # r # ys)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma not_irreducible_factor_yields_prime_factors:\n  assumes uf: \"u dvd (f :: 'b :: {field_gcd} poly)\" and fin: \"finite P\"\n      and fP: \"f = \\<Prod>P\" and P: \"P \\<subseteq> {q. irreducible q \\<and> monic q}\"\n    and u: \"degree u > 0\" \"\\<not> irreducible u\"\n  shows \"\\<exists> pi pj. pi \\<in> P \\<and> pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "from finite_distinct_list[OF fin]"], ["proof (chain)\npicking this:\n  \\<exists>xs. set xs = P \\<and> distinct xs", "obtain ps where Pps: \"P = set ps\" and dist: \"distinct ps\""], ["proof (prove)\nusing this:\n  \\<exists>xs. set xs = P \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>P = set ps; distinct ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P = set ps\n  distinct ps\n\ngoal (1 subgoal):\n 1. \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "have fP: \"f = prod_list ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list ps", "unfolding fP Pps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>(set ps) = prod_list ps", "using dist"], ["proof (prove)\nusing this:\n  distinct ps\n\ngoal (1 subgoal):\n 1. \\<Prod>(set ps) = prod_list ps", "by (simp add: prod.distinct_set_conv_list)"], ["proof (state)\nthis:\n  f = prod_list ps\n\ngoal (1 subgoal):\n 1. \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "note P = P[unfolded Pps]"], ["proof (state)\nthis:\n  set ps \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "have \"set ps \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ps \\<subseteq> P", "unfolding Pps"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ps \\<subseteq> set ps", "by auto"], ["proof (state)\nthis:\n  set ps \\<subseteq> P\n\ngoal (1 subgoal):\n 1. \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "from uf[unfolded fP] P dist this"], ["proof (chain)\npicking this:\n  u dvd prod_list ps\n  set ps \\<subseteq> {q. irreducible q \\<and> monic q}\n  distinct ps\n  set ps \\<subseteq> P", "show ?thesis"], ["proof (prove)\nusing this:\n  u dvd prod_list ps\n  set ps \\<subseteq> {q. irreducible q \\<and> monic q}\n  distinct ps\n  set ps \\<subseteq> P\n\ngoal (1 subgoal):\n 1. \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "proof (induct ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>u dvd prod_list [];\n     set [] \\<subseteq> {q. irreducible q \\<and> monic q}; distinct [];\n     set [] \\<subseteq> P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pi pj.\n                         pi \\<in> P \\<and>\n                         pj \\<in> P \\<and>\n                         pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\n 2. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>u dvd prod_list ps;\n                 set ps \\<subseteq> {q. irreducible q \\<and> monic q};\n                 distinct ps; set ps \\<subseteq> P\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pi pj.\n                                     pi \\<in> P \\<and>\n                                     pj \\<in> P \\<and>\n                                     pi \\<noteq> pj \\<and>\n                                     pi dvd u \\<and> pj dvd u;\n        u dvd prod_list (a # ps);\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        distinct (a # ps); set (a # ps) \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pi pj.\n                            pi \\<in> P \\<and>\n                            pj \\<in> P \\<and>\n                            pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "case Nil"], ["proof (state)\nthis:\n  u dvd prod_list []\n  set [] \\<subseteq> {q. irreducible q \\<and> monic q}\n  distinct []\n  set [] \\<subseteq> P\n\ngoal (2 subgoals):\n 1. \\<lbrakk>u dvd prod_list [];\n     set [] \\<subseteq> {q. irreducible q \\<and> monic q}; distinct [];\n     set [] \\<subseteq> P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pi pj.\n                         pi \\<in> P \\<and>\n                         pj \\<in> P \\<and>\n                         pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\n 2. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>u dvd prod_list ps;\n                 set ps \\<subseteq> {q. irreducible q \\<and> monic q};\n                 distinct ps; set ps \\<subseteq> P\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pi pj.\n                                     pi \\<in> P \\<and>\n                                     pj \\<in> P \\<and>\n                                     pi \\<noteq> pj \\<and>\n                                     pi dvd u \\<and> pj dvd u;\n        u dvd prod_list (a # ps);\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        distinct (a # ps); set (a # ps) \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pi pj.\n                            pi \\<in> P \\<and>\n                            pj \\<in> P \\<and>\n                            pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "with u"], ["proof (chain)\npicking this:\n  0 < degree u\n  \\<not> irreducible u\n  u dvd prod_list []\n  set [] \\<subseteq> {q. irreducible q \\<and> monic q}\n  distinct []\n  set [] \\<subseteq> P", "show ?case"], ["proof (prove)\nusing this:\n  0 < degree u\n  \\<not> irreducible u\n  u dvd prod_list []\n  set [] \\<subseteq> {q. irreducible q \\<and> monic q}\n  distinct []\n  set [] \\<subseteq> P\n\ngoal (1 subgoal):\n 1. \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "using divides_degree[of u 1]"], ["proof (prove)\nusing this:\n  0 < degree u\n  \\<not> irreducible u\n  u dvd prod_list []\n  set [] \\<subseteq> {q. irreducible q \\<and> monic q}\n  distinct []\n  set [] \\<subseteq> P\n  is_unit u \\<Longrightarrow> degree u \\<le> degree 1 \\<or> 1 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "by auto"], ["proof (state)\nthis:\n  \\<exists>pi pj.\n     pi \\<in> P \\<and>\n     pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>u dvd prod_list ps;\n                 set ps \\<subseteq> {q. irreducible q \\<and> monic q};\n                 distinct ps; set ps \\<subseteq> P\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pi pj.\n                                     pi \\<in> P \\<and>\n                                     pj \\<in> P \\<and>\n                                     pi \\<noteq> pj \\<and>\n                                     pi dvd u \\<and> pj dvd u;\n        u dvd prod_list (a # ps);\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        distinct (a # ps); set (a # ps) \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pi pj.\n                            pi \\<in> P \\<and>\n                            pj \\<in> P \\<and>\n                            pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>u dvd prod_list ps;\n                 set ps \\<subseteq> {q. irreducible q \\<and> monic q};\n                 distinct ps; set ps \\<subseteq> P\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pi pj.\n                                     pi \\<in> P \\<and>\n                                     pj \\<in> P \\<and>\n                                     pi \\<noteq> pj \\<and>\n                                     pi dvd u \\<and> pj dvd u;\n        u dvd prod_list (a # ps);\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        distinct (a # ps); set (a # ps) \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pi pj.\n                            pi \\<in> P \\<and>\n                            pj \\<in> P \\<and>\n                            pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "case (Cons p ps)"], ["proof (state)\nthis:\n  \\<lbrakk>u dvd prod_list ps;\n   set ps \\<subseteq> {q. irreducible q \\<and> monic q}; distinct ps;\n   set ps \\<subseteq> P\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pi pj.\n                       pi \\<in> P \\<and>\n                       pj \\<in> P \\<and>\n                       pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\n  u dvd prod_list (p # ps)\n  set (p # ps) \\<subseteq> {q. irreducible q \\<and> monic q}\n  distinct (p # ps)\n  set (p # ps) \\<subseteq> P\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>u dvd prod_list ps;\n                 set ps \\<subseteq> {q. irreducible q \\<and> monic q};\n                 distinct ps; set ps \\<subseteq> P\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pi pj.\n                                     pi \\<in> P \\<and>\n                                     pj \\<in> P \\<and>\n                                     pi \\<noteq> pj \\<and>\n                                     pi dvd u \\<and> pj dvd u;\n        u dvd prod_list (a # ps);\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        distinct (a # ps); set (a # ps) \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pi pj.\n                            pi \\<in> P \\<and>\n                            pj \\<in> P \\<and>\n                            pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "from Cons(3)"], ["proof (chain)\npicking this:\n  set (p # ps) \\<subseteq> {q. irreducible q \\<and> monic q}", "have ps: \"set ps \\<subseteq> {q. irreducible q \\<and> monic q}\""], ["proof (prove)\nusing this:\n  set (p # ps) \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. set ps \\<subseteq> {q. irreducible q \\<and> monic q}", "by auto"], ["proof (state)\nthis:\n  set ps \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>u dvd prod_list ps;\n                 set ps \\<subseteq> {q. irreducible q \\<and> monic q};\n                 distinct ps; set ps \\<subseteq> P\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pi pj.\n                                     pi \\<in> P \\<and>\n                                     pj \\<in> P \\<and>\n                                     pi \\<noteq> pj \\<and>\n                                     pi dvd u \\<and> pj dvd u;\n        u dvd prod_list (a # ps);\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        distinct (a # ps); set (a # ps) \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pi pj.\n                            pi \\<in> P \\<and>\n                            pj \\<in> P \\<and>\n                            pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "from Cons(2)"], ["proof (chain)\npicking this:\n  u dvd prod_list (p # ps)", "have dvd: \"u dvd p * prod_list ps\""], ["proof (prove)\nusing this:\n  u dvd prod_list (p # ps)\n\ngoal (1 subgoal):\n 1. u dvd p * prod_list ps", "by simp"], ["proof (state)\nthis:\n  u dvd p * prod_list ps\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>u dvd prod_list ps;\n                 set ps \\<subseteq> {q. irreducible q \\<and> monic q};\n                 distinct ps; set ps \\<subseteq> P\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pi pj.\n                                     pi \\<in> P \\<and>\n                                     pj \\<in> P \\<and>\n                                     pi \\<noteq> pj \\<and>\n                                     pi dvd u \\<and> pj dvd u;\n        u dvd prod_list (a # ps);\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        distinct (a # ps); set (a # ps) \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pi pj.\n                            pi \\<in> P \\<and>\n                            pj \\<in> P \\<and>\n                            pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "obtain k where gcd: \"u = gcd p u * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k. u = gcd p u * k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson dvd_def gcd_dvd2)"], ["proof (state)\nthis:\n  u = gcd p u * k\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>u dvd prod_list ps;\n                 set ps \\<subseteq> {q. irreducible q \\<and> monic q};\n                 distinct ps; set ps \\<subseteq> P\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pi pj.\n                                     pi \\<in> P \\<and>\n                                     pj \\<in> P \\<and>\n                                     pi \\<noteq> pj \\<and>\n                                     pi dvd u \\<and> pj dvd u;\n        u dvd prod_list (a # ps);\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        distinct (a # ps); set (a # ps) \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pi pj.\n                            pi \\<in> P \\<and>\n                            pj \\<in> P \\<and>\n                            pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "from Cons(3)"], ["proof (chain)\npicking this:\n  set (p # ps) \\<subseteq> {q. irreducible q \\<and> monic q}", "have *: \"monic p\" \"irreducible p\" \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  set (p # ps) \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. monic p &&& irreducible p &&& p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  monic p\n  irreducible p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>u dvd prod_list ps;\n                 set ps \\<subseteq> {q. irreducible q \\<and> monic q};\n                 distinct ps; set ps \\<subseteq> P\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pi pj.\n                                     pi \\<in> P \\<and>\n                                     pj \\<in> P \\<and>\n                                     pi \\<noteq> pj \\<and>\n                                     pi dvd u \\<and> pj dvd u;\n        u dvd prod_list (a # ps);\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        distinct (a # ps); set (a # ps) \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pi pj.\n                            pi \\<in> P \\<and>\n                            pj \\<in> P \\<and>\n                            pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "from monic_irreducible_gcd[OF *(1), of u] *(2)"], ["proof (chain)\npicking this:\n  irreducible p \\<Longrightarrow> gcd p u \\<in> {1, p}\n  irreducible p", "have \"gcd p u = 1 \\<or> gcd p u = p\""], ["proof (prove)\nusing this:\n  irreducible p \\<Longrightarrow> gcd p u \\<in> {1, p}\n  irreducible p\n\ngoal (1 subgoal):\n 1. gcd p u = 1 \\<or> gcd p u = p", "by auto"], ["proof (state)\nthis:\n  gcd p u = 1 \\<or> gcd p u = p\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>u dvd prod_list ps;\n                 set ps \\<subseteq> {q. irreducible q \\<and> monic q};\n                 distinct ps; set ps \\<subseteq> P\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pi pj.\n                                     pi \\<in> P \\<and>\n                                     pj \\<in> P \\<and>\n                                     pi \\<noteq> pj \\<and>\n                                     pi dvd u \\<and> pj dvd u;\n        u dvd prod_list (a # ps);\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        distinct (a # ps); set (a # ps) \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pi pj.\n                            pi \\<in> P \\<and>\n                            pj \\<in> P \\<and>\n                            pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "thus ?case"], ["proof (prove)\nusing this:\n  gcd p u = 1 \\<or> gcd p u = p\n\ngoal (1 subgoal):\n 1. \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. gcd p u = 1 \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\n 2. gcd p u = p \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "assume \"gcd p u = 1\""], ["proof (state)\nthis:\n  gcd p u = 1\n\ngoal (2 subgoals):\n 1. gcd p u = 1 \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\n 2. gcd p u = p \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "then"], ["proof (chain)\npicking this:\n  gcd p u = 1", "have \"Rings.coprime p u\""], ["proof (prove)\nusing this:\n  gcd p u = 1\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime p u", "by (rule gcd_eq_1_imp_coprime)"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime p u\n\ngoal (2 subgoals):\n 1. gcd p u = 1 \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\n 2. gcd p u = p \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "with dvd"], ["proof (chain)\npicking this:\n  u dvd p * prod_list ps\n  algebraic_semidom_class.coprime p u", "have \"u dvd prod_list ps\""], ["proof (prove)\nusing this:\n  u dvd p * prod_list ps\n  algebraic_semidom_class.coprime p u\n\ngoal (1 subgoal):\n 1. u dvd prod_list ps", "using coprime_dvd_mult_right_iff coprime_imp_coprime"], ["proof (prove)\nusing this:\n  u dvd p * prod_list ps\n  algebraic_semidom_class.coprime p u\n  algebraic_semidom_class.coprime ?a ?c \\<Longrightarrow>\n  (?a dvd ?c * ?b) = (?a dvd ?b)\n  \\<lbrakk>algebraic_semidom_class.coprime ?c ?d;\n   \\<And>e.\n      \\<lbrakk>\\<not> is_unit e; e dvd ?a; e dvd ?b\\<rbrakk>\n      \\<Longrightarrow> e dvd ?c;\n   \\<And>e.\n      \\<lbrakk>\\<not> is_unit e; e dvd ?a; e dvd ?b\\<rbrakk>\n      \\<Longrightarrow> e dvd ?d\\<rbrakk>\n  \\<Longrightarrow> algebraic_semidom_class.coprime ?a ?b\n\ngoal (1 subgoal):\n 1. u dvd prod_list ps", "by blast"], ["proof (state)\nthis:\n  u dvd prod_list ps\n\ngoal (2 subgoals):\n 1. gcd p u = 1 \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\n 2. gcd p u = p \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "from Cons(1)[OF this ps] Cons(4-5)"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct ps; set ps \\<subseteq> P\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pi pj.\n                       pi \\<in> P \\<and>\n                       pj \\<in> P \\<and>\n                       pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\n  distinct (p # ps)\n  set (p # ps) \\<subseteq> P", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ps; set ps \\<subseteq> P\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pi pj.\n                       pi \\<in> P \\<and>\n                       pj \\<in> P \\<and>\n                       pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\n  distinct (p # ps)\n  set (p # ps) \\<subseteq> P\n\ngoal (1 subgoal):\n 1. \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "by auto"], ["proof (state)\nthis:\n  \\<exists>pi pj.\n     pi \\<in> P \\<and>\n     pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\n\ngoal (1 subgoal):\n 1. gcd p u = p \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd p u = p \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "assume \"gcd p u = p\""], ["proof (state)\nthis:\n  gcd p u = p\n\ngoal (1 subgoal):\n 1. gcd p u = p \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "with gcd"], ["proof (chain)\npicking this:\n  u = gcd p u * k\n  gcd p u = p", "have upk: \"u = p * k\""], ["proof (prove)\nusing this:\n  u = gcd p u * k\n  gcd p u = p\n\ngoal (1 subgoal):\n 1. u = p * k", "by auto"], ["proof (state)\nthis:\n  u = p * k\n\ngoal (1 subgoal):\n 1. gcd p u = p \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "hence p: \"p dvd u\""], ["proof (prove)\nusing this:\n  u = p * k\n\ngoal (1 subgoal):\n 1. p dvd u", "by auto"], ["proof (state)\nthis:\n  p dvd u\n\ngoal (1 subgoal):\n 1. gcd p u = p \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "from dvd[unfolded upk] *(3)"], ["proof (chain)\npicking this:\n  p * k dvd p * prod_list ps\n  p \\<noteq> 0", "have kps: \"k dvd prod_list ps\""], ["proof (prove)\nusing this:\n  p * k dvd p * prod_list ps\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k dvd prod_list ps", "by auto"], ["proof (state)\nthis:\n  k dvd prod_list ps\n\ngoal (1 subgoal):\n 1. gcd p u = p \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "from dvd u *"], ["proof (chain)\npicking this:\n  u dvd p * prod_list ps\n  0 < degree u\n  \\<not> irreducible u\n  monic p\n  irreducible p\n  p \\<noteq> 0", "have dk: \"degree k > 0\""], ["proof (prove)\nusing this:\n  u dvd p * prod_list ps\n  0 < degree u\n  \\<not> irreducible u\n  monic p\n  irreducible p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree k", "by (metis gr0I irreducible_mult_unit_right is_unit_iff_degree mult_zero_right upk)"], ["proof (state)\nthis:\n  0 < degree k\n\ngoal (1 subgoal):\n 1. gcd p u = p \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "from ps kps"], ["proof (chain)\npicking this:\n  set ps \\<subseteq> {q. irreducible q \\<and> monic q}\n  k dvd prod_list ps", "have \"\\<exists> q \\<in> set ps. q dvd k\""], ["proof (prove)\nusing this:\n  set ps \\<subseteq> {q. irreducible q \\<and> monic q}\n  k dvd prod_list ps\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set ps. q dvd k", "proof (induct ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> {q. irreducible q \\<and> monic q};\n     k dvd prod_list []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q\\<in>set []. q dvd k\n 2. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>set ps\n                         \\<subseteq> {q. irreducible q \\<and> monic q};\n                 k dvd prod_list ps\\<rbrakk>\n                \\<Longrightarrow> \\<exists>q\\<in>set ps. q dvd k;\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        k dvd prod_list (a # ps)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>set (a # ps). q dvd k", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> {q. irreducible q \\<and> monic q}\n  k dvd prod_list []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>set [] \\<subseteq> {q. irreducible q \\<and> monic q};\n     k dvd prod_list []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q\\<in>set []. q dvd k\n 2. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>set ps\n                         \\<subseteq> {q. irreducible q \\<and> monic q};\n                 k dvd prod_list ps\\<rbrakk>\n                \\<Longrightarrow> \\<exists>q\\<in>set ps. q dvd k;\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        k dvd prod_list (a # ps)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>set (a # ps). q dvd k", "with dk"], ["proof (chain)\npicking this:\n  0 < degree k\n  set [] \\<subseteq> {q. irreducible q \\<and> monic q}\n  k dvd prod_list []", "show ?case"], ["proof (prove)\nusing this:\n  0 < degree k\n  set [] \\<subseteq> {q. irreducible q \\<and> monic q}\n  k dvd prod_list []\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set []. q dvd k", "using divides_degree[of k 1]"], ["proof (prove)\nusing this:\n  0 < degree k\n  set [] \\<subseteq> {q. irreducible q \\<and> monic q}\n  k dvd prod_list []\n  is_unit k \\<Longrightarrow> degree k \\<le> degree 1 \\<or> 1 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set []. q dvd k", "by auto"], ["proof (state)\nthis:\n  \\<exists>q\\<in>set []. q dvd k\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>set ps\n                         \\<subseteq> {q. irreducible q \\<and> monic q};\n                 k dvd prod_list ps\\<rbrakk>\n                \\<Longrightarrow> \\<exists>q\\<in>set ps. q dvd k;\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        k dvd prod_list (a # ps)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>set (a # ps). q dvd k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>set ps\n                         \\<subseteq> {q. irreducible q \\<and> monic q};\n                 k dvd prod_list ps\\<rbrakk>\n                \\<Longrightarrow> \\<exists>q\\<in>set ps. q dvd k;\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        k dvd prod_list (a # ps)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>set (a # ps). q dvd k", "case (Cons p ps)"], ["proof (state)\nthis:\n  \\<lbrakk>set ps \\<subseteq> {q. irreducible q \\<and> monic q};\n   k dvd prod_list ps\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q\\<in>set ps. q dvd k\n  set (p # ps) \\<subseteq> {q. irreducible q \\<and> monic q}\n  k dvd prod_list (p # ps)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>set ps\n                         \\<subseteq> {q. irreducible q \\<and> monic q};\n                 k dvd prod_list ps\\<rbrakk>\n                \\<Longrightarrow> \\<exists>q\\<in>set ps. q dvd k;\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        k dvd prod_list (a # ps)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>set (a # ps). q dvd k", "from Cons(3)"], ["proof (chain)\npicking this:\n  k dvd prod_list (p # ps)", "have dvd: \"k dvd p * prod_list ps\""], ["proof (prove)\nusing this:\n  k dvd prod_list (p # ps)\n\ngoal (1 subgoal):\n 1. k dvd p * prod_list ps", "by simp"], ["proof (state)\nthis:\n  k dvd p * prod_list ps\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>set ps\n                         \\<subseteq> {q. irreducible q \\<and> monic q};\n                 k dvd prod_list ps\\<rbrakk>\n                \\<Longrightarrow> \\<exists>q\\<in>set ps. q dvd k;\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        k dvd prod_list (a # ps)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>set (a # ps). q dvd k", "obtain l where gcd: \"k = gcd p k * l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l. k = gcd p k * l \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson dvd_def gcd_dvd2)"], ["proof (state)\nthis:\n  k = gcd p k * l\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>set ps\n                         \\<subseteq> {q. irreducible q \\<and> monic q};\n                 k dvd prod_list ps\\<rbrakk>\n                \\<Longrightarrow> \\<exists>q\\<in>set ps. q dvd k;\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        k dvd prod_list (a # ps)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>set (a # ps). q dvd k", "from Cons(2)"], ["proof (chain)\npicking this:\n  set (p # ps) \\<subseteq> {q. irreducible q \\<and> monic q}", "have *: \"monic p\" \"irreducible p\" \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  set (p # ps) \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. monic p &&& irreducible p &&& p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  monic p\n  irreducible p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>set ps\n                         \\<subseteq> {q. irreducible q \\<and> monic q};\n                 k dvd prod_list ps\\<rbrakk>\n                \\<Longrightarrow> \\<exists>q\\<in>set ps. q dvd k;\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        k dvd prod_list (a # ps)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>set (a # ps). q dvd k", "from monic_irreducible_gcd[OF *(1), of k] *(2)"], ["proof (chain)\npicking this:\n  irreducible p \\<Longrightarrow> gcd p k \\<in> {1, p}\n  irreducible p", "have \"gcd p k = 1 \\<or> gcd p k = p\""], ["proof (prove)\nusing this:\n  irreducible p \\<Longrightarrow> gcd p k \\<in> {1, p}\n  irreducible p\n\ngoal (1 subgoal):\n 1. gcd p k = 1 \\<or> gcd p k = p", "by auto"], ["proof (state)\nthis:\n  gcd p k = 1 \\<or> gcd p k = p\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>\\<lbrakk>set ps\n                         \\<subseteq> {q. irreducible q \\<and> monic q};\n                 k dvd prod_list ps\\<rbrakk>\n                \\<Longrightarrow> \\<exists>q\\<in>set ps. q dvd k;\n        set (a # ps) \\<subseteq> {q. irreducible q \\<and> monic q};\n        k dvd prod_list (a # ps)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>set (a # ps). q dvd k", "thus ?case"], ["proof (prove)\nusing this:\n  gcd p k = 1 \\<or> gcd p k = p\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set (p # ps). q dvd k", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. gcd p k = 1 \\<Longrightarrow> \\<exists>q\\<in>set (p # ps). q dvd k\n 2. gcd p k = p \\<Longrightarrow> \\<exists>q\\<in>set (p # ps). q dvd k", "assume \"gcd p k = 1\""], ["proof (state)\nthis:\n  gcd p k = 1\n\ngoal (2 subgoals):\n 1. gcd p k = 1 \\<Longrightarrow> \\<exists>q\\<in>set (p # ps). q dvd k\n 2. gcd p k = p \\<Longrightarrow> \\<exists>q\\<in>set (p # ps). q dvd k", "with dvd"], ["proof (chain)\npicking this:\n  k dvd p * prod_list ps\n  gcd p k = 1", "have \"k dvd prod_list ps\""], ["proof (prove)\nusing this:\n  k dvd p * prod_list ps\n  gcd p k = 1\n\ngoal (1 subgoal):\n 1. k dvd prod_list ps", "by (metis dvd_triv_left gcd_greatest_mult mult.left_neutral)"], ["proof (state)\nthis:\n  k dvd prod_list ps\n\ngoal (2 subgoals):\n 1. gcd p k = 1 \\<Longrightarrow> \\<exists>q\\<in>set (p # ps). q dvd k\n 2. gcd p k = p \\<Longrightarrow> \\<exists>q\\<in>set (p # ps). q dvd k", "from Cons(1)[OF _ this] Cons(2)"], ["proof (chain)\npicking this:\n  set ps \\<subseteq> {q. irreducible q \\<and> monic q} \\<Longrightarrow>\n  \\<exists>q\\<in>set ps. q dvd k\n  set (p # ps) \\<subseteq> {q. irreducible q \\<and> monic q}", "show ?thesis"], ["proof (prove)\nusing this:\n  set ps \\<subseteq> {q. irreducible q \\<and> monic q} \\<Longrightarrow>\n  \\<exists>q\\<in>set ps. q dvd k\n  set (p # ps) \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set (p # ps). q dvd k", "by auto"], ["proof (state)\nthis:\n  \\<exists>q\\<in>set (p # ps). q dvd k\n\ngoal (1 subgoal):\n 1. gcd p k = p \\<Longrightarrow> \\<exists>q\\<in>set (p # ps). q dvd k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd p k = p \\<Longrightarrow> \\<exists>q\\<in>set (p # ps). q dvd k", "assume \"gcd p k = p\""], ["proof (state)\nthis:\n  gcd p k = p\n\ngoal (1 subgoal):\n 1. gcd p k = p \\<Longrightarrow> \\<exists>q\\<in>set (p # ps). q dvd k", "with gcd"], ["proof (chain)\npicking this:\n  k = gcd p k * l\n  gcd p k = p", "have upk: \"k = p * l\""], ["proof (prove)\nusing this:\n  k = gcd p k * l\n  gcd p k = p\n\ngoal (1 subgoal):\n 1. k = p * l", "by auto"], ["proof (state)\nthis:\n  k = p * l\n\ngoal (1 subgoal):\n 1. gcd p k = p \\<Longrightarrow> \\<exists>q\\<in>set (p # ps). q dvd k", "hence p: \"p dvd k\""], ["proof (prove)\nusing this:\n  k = p * l\n\ngoal (1 subgoal):\n 1. p dvd k", "by auto"], ["proof (state)\nthis:\n  p dvd k\n\ngoal (1 subgoal):\n 1. gcd p k = p \\<Longrightarrow> \\<exists>q\\<in>set (p # ps). q dvd k", "thus ?thesis"], ["proof (prove)\nusing this:\n  p dvd k\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set (p # ps). q dvd k", "by auto"], ["proof (state)\nthis:\n  \\<exists>q\\<in>set (p # ps). q dvd k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>q\\<in>set (p # ps). q dvd k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>q\\<in>set ps. q dvd k\n\ngoal (1 subgoal):\n 1. gcd p u = p \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "then"], ["proof (chain)\npicking this:\n  \\<exists>q\\<in>set ps. q dvd k", "obtain q where q: \"q \\<in> set ps\" and dvd: \"q dvd k\""], ["proof (prove)\nusing this:\n  \\<exists>q\\<in>set ps. q dvd k\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set ps; q dvd k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q \\<in> set ps\n  q dvd k\n\ngoal (1 subgoal):\n 1. gcd p u = p \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "from dvd upk"], ["proof (chain)\npicking this:\n  q dvd k\n  u = p * k", "have qu: \"q dvd u\""], ["proof (prove)\nusing this:\n  q dvd k\n  u = p * k\n\ngoal (1 subgoal):\n 1. q dvd u", "by auto"], ["proof (state)\nthis:\n  q dvd u\n\ngoal (1 subgoal):\n 1. gcd p u = p \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "from Cons(4) q"], ["proof (chain)\npicking this:\n  distinct (p # ps)\n  q \\<in> set ps", "have \"p \\<noteq> q\""], ["proof (prove)\nusing this:\n  distinct (p # ps)\n  q \\<in> set ps\n\ngoal (1 subgoal):\n 1. p \\<noteq> q", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. gcd p u = p \\<Longrightarrow>\n    \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "using q p qu Cons(5)"], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  q \\<in> set ps\n  p dvd u\n  q dvd u\n  set (p # ps) \\<subseteq> P\n\ngoal (1 subgoal):\n 1. \\<exists>pi pj.\n       pi \\<in> P \\<and>\n       pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "by auto"], ["proof (state)\nthis:\n  \\<exists>pi pj.\n     pi \\<in> P \\<and>\n     pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>pi pj.\n     pi \\<in> P \\<and>\n     pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>pi pj.\n     pi \\<in> P \\<and>\n     pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma berlekamp_factorization_main:\n  fixes f::\"'a mod_ring poly\"\n  assumes sf_f: \"square_free f\"\n    and vs: \"vs = vs1 @ vs2\"\n    and vsf: \"vs = berlekamp_basis f\"\n    and n_bb: \"n = length (berlekamp_basis f)\"\n    and n: \"n = length us1 + n2\"\n    and us: \"us = us1 @ berlekamp_factorization_main d divs vs2 n2\"\n    and us1: \"\\<And> u. u \\<in> set us1 \\<Longrightarrow> monic u \\<and> irreducible u\"\n    and divs: \"\\<And> d. d \\<in> set divs \\<Longrightarrow> monic d \\<and> degree d > 0\"\n    and vs1: \"\\<And> u v i. v \\<in> set vs1 \\<Longrightarrow> u \\<in> set us1 \\<union> set divs\n      \\<Longrightarrow> i < CARD('a) \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1,u}\"\n    and f: \"f = prod_list (us1 @ divs)\"\n    and deg_f: \"degree f > 0\"\n    and d: \"\\<And> g. g dvd f \\<Longrightarrow> degree g = d \\<Longrightarrow> irreducible g\" \n  shows \"f = prod_list us \\<and> (\\<forall> u \\<in> set us. monic u \\<and> irreducible u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have mon_f: \"monic f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic f", "unfolding f"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (prod_list (us1 @ divs))", "by (rule monic_prod_list, insert divs us1, auto)"], ["proof (state)\nthis:\n  monic f\n\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from monic_square_free_irreducible_factorization[OF mon_f sf_f]"], ["proof (chain)\npicking this:\n  \\<exists>P.\n     finite P \\<and>\n     f = \\<Prod>P \\<and> P \\<subseteq> {q. irreducible q \\<and> monic q}", "obtain P where\n    P: \"finite P\" \"f = \\<Prod> P\" \"P \\<subseteq> {q. irreducible q \\<and> monic q}\""], ["proof (prove)\nusing this:\n  \\<exists>P.\n     finite P \\<and>\n     f = \\<Prod>P \\<and> P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>finite P; f = \\<Prod>P;\n         P \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite P\n  f = \\<Prod>P\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "hence f0: \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  finite P\n  f = \\<Prod>P\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "using vs n us divs f us1 vs1"], ["proof (prove)\nusing this:\n  vs = vs1 @ vs2\n  n = length us1 + n2\n  us = us1 @ berlekamp_factorization_main d divs vs2 n2\n  ?d \\<in> set divs \\<Longrightarrow> monic ?d \\<and> 0 < degree ?d\n  f = prod_list (us1 @ divs)\n  ?u \\<in> set us1 \\<Longrightarrow> monic ?u \\<and> irreducible ?u\n  \\<lbrakk>?v \\<in> set vs1; ?u \\<in> set us1 \\<union> set divs;\n   ?i < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> gcd ?u (?v - [:of_nat ?i:]) \\<in> {1, ?u}\n\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "proof (induct vs2 arbitrary: divs n2 us1 vs1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>divs n2 us1 vs1.\n       \\<lbrakk>vs = vs1 @ []; n = length us1 + n2;\n        us = us1 @ berlekamp_factorization_main d divs [] n2;\n        \\<And>d.\n           d \\<in> set divs \\<Longrightarrow> monic d \\<and> 0 < degree d;\n        f = prod_list (us1 @ divs);\n        \\<And>u.\n           u \\<in> set us1 \\<Longrightarrow> monic u \\<and> irreducible u;\n        \\<And>v u i.\n           \\<lbrakk>v \\<in> set vs1; u \\<in> set us1 \\<union> set divs;\n            i < CARD('a)\\<rbrakk>\n           \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\\<rbrakk>\n       \\<Longrightarrow> f = prod_list us \\<and>\n                         (\\<forall>u\\<in>set us.\n                             monic u \\<and> irreducible u)\n 2. \\<And>a vs2 divs n2 us1 vs1.\n       \\<lbrakk>\\<And>divs n2 us1 vs1.\n                   \\<lbrakk>vs = vs1 @ vs2; n = length us1 + n2;\n                    us = us1 @ berlekamp_factorization_main d divs vs2 n2;\n                    \\<And>d.\n                       d \\<in> set divs \\<Longrightarrow>\n                       monic d \\<and> 0 < degree d;\n                    f = prod_list (us1 @ divs);\n                    \\<And>u.\n                       u \\<in> set us1 \\<Longrightarrow>\n                       monic u \\<and> irreducible u;\n                    \\<And>v u i.\n                       \\<lbrakk>v \\<in> set vs1;\n                        u \\<in> set us1 \\<union> set divs;\n                        i < CARD('a)\\<rbrakk>\n                       \\<Longrightarrow> gcd u (v - [:of_nat i:])\n   \\<in> {1, u}\\<rbrakk>\n                   \\<Longrightarrow> f = prod_list us \\<and>\n                                     (\\<forall>u\\<in>set us.\n   monic u \\<and> irreducible u);\n        vs = vs1 @ a # vs2; n = length us1 + n2;\n        us = us1 @ berlekamp_factorization_main d divs (a # vs2) n2;\n        \\<And>d.\n           d \\<in> set divs \\<Longrightarrow> monic d \\<and> 0 < degree d;\n        f = prod_list (us1 @ divs);\n        \\<And>u.\n           u \\<in> set us1 \\<Longrightarrow> monic u \\<and> irreducible u;\n        \\<And>v u i.\n           \\<lbrakk>v \\<in> set vs1; u \\<in> set us1 \\<union> set divs;\n            i < CARD('a)\\<rbrakk>\n           \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\\<rbrakk>\n       \\<Longrightarrow> f = prod_list us \\<and>\n                         (\\<forall>u\\<in>set us.\n                             monic u \\<and> irreducible u)", "case (Cons v vs2)"], ["proof (state)\nthis:\n  \\<lbrakk>vs = ?vs1.0 @ vs2; n = length ?us1.0 + ?n2.0;\n   us = ?us1.0 @ berlekamp_factorization_main d ?divs vs2 ?n2.0;\n   \\<And>d. d \\<in> set ?divs \\<Longrightarrow> monic d \\<and> 0 < degree d;\n   f = prod_list (?us1.0 @ ?divs);\n   \\<And>u.\n      u \\<in> set ?us1.0 \\<Longrightarrow> monic u \\<and> irreducible u;\n   \\<And>v u i.\n      \\<lbrakk>v \\<in> set ?vs1.0; u \\<in> set ?us1.0 \\<union> set ?divs;\n       i < CARD('a)\\<rbrakk>\n      \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\\<rbrakk>\n  \\<Longrightarrow> f = prod_list us \\<and>\n                    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n  vs = vs1 @ v # vs2\n  n = length us1 + n2\n  us = us1 @ berlekamp_factorization_main d divs (v # vs2) n2\n  ?d \\<in> set divs \\<Longrightarrow> monic ?d \\<and> 0 < degree ?d\n  f = prod_list (us1 @ divs)\n  ?u \\<in> set us1 \\<Longrightarrow> monic ?u \\<and> irreducible ?u\n  \\<lbrakk>?v \\<in> set vs1; ?u \\<in> set us1 \\<union> set divs;\n   ?i < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> gcd ?u (?v - [:of_nat ?i:]) \\<in> {1, ?u}\n\ngoal (2 subgoals):\n 1. \\<And>divs n2 us1 vs1.\n       \\<lbrakk>vs = vs1 @ []; n = length us1 + n2;\n        us = us1 @ berlekamp_factorization_main d divs [] n2;\n        \\<And>d.\n           d \\<in> set divs \\<Longrightarrow> monic d \\<and> 0 < degree d;\n        f = prod_list (us1 @ divs);\n        \\<And>u.\n           u \\<in> set us1 \\<Longrightarrow> monic u \\<and> irreducible u;\n        \\<And>v u i.\n           \\<lbrakk>v \\<in> set vs1; u \\<in> set us1 \\<union> set divs;\n            i < CARD('a)\\<rbrakk>\n           \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\\<rbrakk>\n       \\<Longrightarrow> f = prod_list us \\<and>\n                         (\\<forall>u\\<in>set us.\n                             monic u \\<and> irreducible u)\n 2. \\<And>a vs2 divs n2 us1 vs1.\n       \\<lbrakk>\\<And>divs n2 us1 vs1.\n                   \\<lbrakk>vs = vs1 @ vs2; n = length us1 + n2;\n                    us = us1 @ berlekamp_factorization_main d divs vs2 n2;\n                    \\<And>d.\n                       d \\<in> set divs \\<Longrightarrow>\n                       monic d \\<and> 0 < degree d;\n                    f = prod_list (us1 @ divs);\n                    \\<And>u.\n                       u \\<in> set us1 \\<Longrightarrow>\n                       monic u \\<and> irreducible u;\n                    \\<And>v u i.\n                       \\<lbrakk>v \\<in> set vs1;\n                        u \\<in> set us1 \\<union> set divs;\n                        i < CARD('a)\\<rbrakk>\n                       \\<Longrightarrow> gcd u (v - [:of_nat i:])\n   \\<in> {1, u}\\<rbrakk>\n                   \\<Longrightarrow> f = prod_list us \\<and>\n                                     (\\<forall>u\\<in>set us.\n   monic u \\<and> irreducible u);\n        vs = vs1 @ a # vs2; n = length us1 + n2;\n        us = us1 @ berlekamp_factorization_main d divs (a # vs2) n2;\n        \\<And>d.\n           d \\<in> set divs \\<Longrightarrow> monic d \\<and> 0 < degree d;\n        f = prod_list (us1 @ divs);\n        \\<And>u.\n           u \\<in> set us1 \\<Longrightarrow> monic u \\<and> irreducible u;\n        \\<And>v u i.\n           \\<lbrakk>v \\<in> set vs1; u \\<in> set us1 \\<union> set divs;\n            i < CARD('a)\\<rbrakk>\n           \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\\<rbrakk>\n       \\<Longrightarrow> f = prod_list us \\<and>\n                         (\\<forall>u\\<in>set us.\n                             monic u \\<and> irreducible u)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "proof (cases \"v = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "case False"], ["proof (state)\nthis:\n  v \\<noteq> 1\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from Cons(2) vsf"], ["proof (chain)\npicking this:\n  vs = vs1 @ v # vs2\n  vs = berlekamp_basis f", "have v: \"v \\<in> set (berlekamp_basis f)\""], ["proof (prove)\nusing this:\n  vs = vs1 @ v # vs2\n  vs = berlekamp_basis f\n\ngoal (1 subgoal):\n 1. v \\<in> set (berlekamp_basis f)", "by auto"], ["proof (state)\nthis:\n  v \\<in> set (berlekamp_basis f)\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from berlekamp_basis_eq_8[OF this]"], ["proof (chain)\npicking this:\n  [v ^ CARD('a) = v] (mod f)", "have vf: \"[v ^ CARD('a) = v] (mod f)\""], ["proof (prove)\nusing this:\n  [v ^ CARD('a) = v] (mod f)\n\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod f)", "."], ["proof (state)\nthis:\n  [v ^ CARD('a) = v] (mod f)\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "let ?gcd = \"\\<lambda> u i. gcd u (v - [:of_int i:])\""], ["proof (state)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "let ?gcdn = \"\\<lambda> u i. gcd u (v - [:of_nat i:])\""], ["proof (state)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "let ?map = \"\\<lambda> u. (map (\\<lambda> i. ?gcd u i) [0 ..< CARD('a)])\""], ["proof (state)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "define udivs where \"udivs \\<equiv> \\<lambda> u. filter (\\<lambda> w. w \\<noteq> 1) (?map u)\""], ["proof (state)\nthis:\n  udivs \\<equiv>\n  \\<lambda>u.\n     filter (\\<lambda>w. w \\<noteq> 1)\n      (map (\\<lambda>i. gcd u (v - [:of_int i:])) (map int [0..<CARD('a)]))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "{"], ["proof (state)\nthis:\n  udivs \\<equiv>\n  \\<lambda>u.\n     filter (\\<lambda>w. w \\<noteq> 1)\n      (map (\\<lambda>i. gcd u (v - [:of_int i:])) (map int [0..<CARD('a)]))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "obtain xs where xs: \"[0..<CARD('a)] = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        [0..<CARD('a)] = xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  [0..<CARD('a)] = xs\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have \"udivs = (\\<lambda> u. [w. i \\<leftarrow> [0 ..< CARD('a)], w \\<leftarrow> [?gcd u i], w \\<noteq> 1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. udivs =\n    (\\<lambda>u.\n        concat\n         (map (\\<lambda>i.\n                  concat\n                   (map (\\<lambda>w. if w \\<noteq> 1 then [w] else [])\n                     [gcd u (v - [:of_int i:])]))\n           (map int [0..<CARD('a)])))", "unfolding udivs_def xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>u.\n        filter (\\<lambda>w. w \\<noteq> 1)\n         (map (\\<lambda>i. gcd u (v - [:of_int i:])) (map int xs))) =\n    (\\<lambda>u.\n        concat\n         (map (\\<lambda>i.\n                  concat\n                   (map (\\<lambda>w. if w \\<noteq> 1 then [w] else [])\n                     [gcd u (v - [:of_int i:])]))\n           (map int xs)))", "by (intro ext, auto simp: o_def, induct xs, auto)"], ["proof (state)\nthis:\n  udivs =\n  (\\<lambda>u.\n      concat\n       (map (\\<lambda>i.\n                concat\n                 (map (\\<lambda>w. if w \\<noteq> 1 then [w] else [])\n                   [gcd u (v - [:of_int i:])]))\n         (map int [0..<CARD('a)])))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "}"], ["proof (state)\nthis:\n  udivs =\n  (\\<lambda>u.\n      concat\n       (map (\\<lambda>i.\n                concat\n                 (map (\\<lambda>w. if w \\<noteq> 1 then [w] else [])\n                   [gcd u (v - [:of_int i:])]))\n         (map int [0..<CARD('a)])))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "note udivs_def' = this"], ["proof (state)\nthis:\n  udivs =\n  (\\<lambda>u.\n      concat\n       (map (\\<lambda>i.\n                concat\n                 (map (\\<lambda>w. if w \\<noteq> 1 then [w] else [])\n                   [gcd u (v - [:of_int i:])]))\n         (map int [0..<CARD('a)])))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "define facts where \"facts \\<equiv> [ w . u \\<leftarrow> divs, w \\<leftarrow> udivs u]\""], ["proof (state)\nthis:\n  facts \\<equiv>\n  concat (map (\\<lambda>u. map (\\<lambda>w. w) (udivs u)) divs)\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "{"], ["proof (state)\nthis:\n  facts \\<equiv>\n  concat (map (\\<lambda>u. map (\\<lambda>w. w) (udivs u)) divs)\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "assume u: \"u \\<in> set divs\""], ["proof (state)\nthis:\n  u \\<in> set divs\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "then"], ["proof (chain)\npicking this:\n  u \\<in> set divs", "obtain bef aft where divs: \"divs = bef @ u # aft\""], ["proof (prove)\nusing this:\n  u \\<in> set divs\n\ngoal (1 subgoal):\n 1. (\\<And>bef aft.\n        divs = bef @ u # aft \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  divs = bef @ u # aft\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from Cons(5)[OF u]"], ["proof (chain)\npicking this:\n  monic u \\<and> 0 < degree u", "have mon_u: \"monic u\""], ["proof (prove)\nusing this:\n  monic u \\<and> 0 < degree u\n\ngoal (1 subgoal):\n 1. monic u", "by simp"], ["proof (state)\nthis:\n  monic u\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have uf: \"u dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u dvd f", "unfolding Cons(6) divs"], ["proof (prove)\ngoal (1 subgoal):\n 1. u dvd prod_list (us1 @ bef @ u # aft)", "by auto"], ["proof (state)\nthis:\n  u dvd f\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from vf uf"], ["proof (chain)\npicking this:\n  [v ^ CARD('a) = v] (mod f)\n  u dvd f", "have vu: \"[v ^ CARD('a) = v] (mod u)\""], ["proof (prove)\nusing this:\n  [v ^ CARD('a) = v] (mod f)\n  u dvd f\n\ngoal (1 subgoal):\n 1. [v ^ CARD('a) = v] (mod u)", "by (rule cong_dvd_modulus_poly)"], ["proof (state)\nthis:\n  [v ^ CARD('a) = v] (mod u)\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from square_free_factor[OF uf sf_f]"], ["proof (chain)\npicking this:\n  square_free u", "have sf_u: \"square_free u\""], ["proof (prove)\nusing this:\n  square_free u\n\ngoal (1 subgoal):\n 1. square_free u", "."], ["proof (state)\nthis:\n  square_free u\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "let ?g = \"?gcd u\""], ["proof (state)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from mon_u"], ["proof (chain)\npicking this:\n  monic u", "have u0: \"u \\<noteq> 0\""], ["proof (prove)\nusing this:\n  monic u\n\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> 0\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have \"u = (\\<Prod>c\\<in>UNIV. gcd u (v - [:c:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = (\\<Prod>c\\<in>UNIV. gcd u (v - [:c:]))", "using Berlekamp_gcd_step[OF vu mon_u sf_u]"], ["proof (prove)\nusing this:\n  u = (\\<Prod>c\\<in>UNIV. gcd u (v - [:c:]))\n\ngoal (1 subgoal):\n 1. u = (\\<Prod>c\\<in>UNIV. gcd u (v - [:c:]))", "."], ["proof (state)\nthis:\n  u = (\\<Prod>c\\<in>UNIV. gcd u (v - [:c:]))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "also"], ["proof (state)\nthis:\n  u = (\\<Prod>c\\<in>UNIV. gcd u (v - [:c:]))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have \"\\<dots> = (\\<Prod>i \\<in> {0..< int CARD('a)}. ?g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>c\\<in>UNIV. gcd u (v - [:c:])) =\n    (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:]))", "by (rule sym, rule prod.reindex_cong[OF to_int_mod_ring_hom.inj_f range_to_int_mod_ring[symmetric]],\n          simp add: of_int_of_int_mod_ring)"], ["proof (state)\nthis:\n  (\\<Prod>c\\<in>UNIV. gcd u (v - [:c:])) =\n  (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:]))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "finally"], ["proof (chain)\npicking this:\n  u = (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:]))", "have u_prod: \"u = (\\<Prod>i \\<in> {0..< int CARD('a)}. ?g i)\""], ["proof (prove)\nusing this:\n  u = (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:]))\n\ngoal (1 subgoal):\n 1. u = (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:]))", "."], ["proof (state)\nthis:\n  u = (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:]))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "let ?S = \"{0..<int CARD('a)} - {i. ?g i = 1}\""], ["proof (state)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "assume \"i \\<in> ?S\""], ["proof (state)\nthis:\n  i \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "hence \"?g i \\<noteq> 1\""], ["proof (prove)\nusing this:\n  i \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n\ngoal (1 subgoal):\n 1. gcd u (v - [:of_int i:]) \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  gcd u (v - [:of_int i:]) \\<noteq> 1\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "moreover"], ["proof (state)\nthis:\n  gcd u (v - [:of_int i:]) \\<noteq> 1\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have mgi: \"monic (?g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (gcd u (v - [:of_int i:]))", "by (rule poly_gcd_monic, insert u0, auto)"], ["proof (state)\nthis:\n  monic (gcd u (v - [:of_int i:]))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "ultimately"], ["proof (chain)\npicking this:\n  gcd u (v - [:of_int i:]) \\<noteq> 1\n  monic (gcd u (v - [:of_int i:]))", "have \"degree (?g i) > 0\""], ["proof (prove)\nusing this:\n  gcd u (v - [:of_int i:]) \\<noteq> 1\n  monic (gcd u (v - [:of_int i:]))\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd u (v - [:of_int i:]))", "using monic_degree_0"], ["proof (prove)\nusing this:\n  gcd u (v - [:of_int i:]) \\<noteq> 1\n  monic (gcd u (v - [:of_int i:]))\n  monic ?p \\<Longrightarrow> (degree ?p = 0) = (?p = 1)\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd u (v - [:of_int i:]))", "by blast"], ["proof (state)\nthis:\n  0 < degree (gcd u (v - [:of_int i:]))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "note this mgi"], ["proof (state)\nthis:\n  0 < degree (gcd u (v - [:of_int i:]))\n  monic (gcd u (v - [:of_int i:]))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "}"], ["proof (state)\nthis:\n  ?i2\n  \\<in> {0..<int CARD('a)} -\n        {i. gcd u (v - [:of_int i:]) = 1} \\<Longrightarrow>\n  0 < degree (gcd u (v - [:of_int ?i2:]))\n  ?i2\n  \\<in> {0..<int CARD('a)} -\n        {i. gcd u (v - [:of_int i:]) = 1} \\<Longrightarrow>\n  monic (gcd u (v - [:of_int ?i2:]))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "note gS = this"], ["proof (state)\nthis:\n  ?i2\n  \\<in> {0..<int CARD('a)} -\n        {i. gcd u (v - [:of_int i:]) = 1} \\<Longrightarrow>\n  0 < degree (gcd u (v - [:of_int ?i2:]))\n  ?i2\n  \\<in> {0..<int CARD('a)} -\n        {i. gcd u (v - [:of_int i:]) = 1} \\<Longrightarrow>\n  monic (gcd u (v - [:of_int ?i2:]))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have int_set: \"int ` set [0..<CARD('a)] = {0 ..< int CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int ` set [0..<CARD('a)] = {0..<int CARD('a)}", "by (simp add: image_int_atLeastLessThan)"], ["proof (state)\nthis:\n  int ` set [0..<CARD('a)] = {0..<int CARD('a)}\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have inj: \"inj_on ?g ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>i. gcd u (v - [:of_int i:]))\n     ({0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1})", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}.\n       \\<forall>y\\<in>{0..<int CARD('a)} -\n                      {i. gcd u (v - [:of_int i:]) = 1}.\n          gcd u (v - [:of_int x:]) =\n          gcd u (v - [:of_int y:]) \\<longrightarrow>\n          x = y", "proof (intro ballI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<int CARD('a)} -\n                        {i. gcd u (v - [:of_int i:]) = 1};\n        y \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1};\n        gcd u (v - [:of_int x:]) = gcd u (v - [:of_int y:])\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<int CARD('a)} -\n                        {i. gcd u (v - [:of_int i:]) = 1};\n        y \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1};\n        gcd u (v - [:of_int x:]) = gcd u (v - [:of_int y:])\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume i: \"i \\<in> ?S\" and j: \"j \\<in> ?S\" and gij: \"?g i = ?g j\""], ["proof (state)\nthis:\n  i \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n  j \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n  gcd u (v - [:of_int i:]) = gcd u (v - [:of_int j:])\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<int CARD('a)} -\n                        {i. gcd u (v - [:of_int i:]) = 1};\n        y \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1};\n        gcd u (v - [:of_int x:]) = gcd u (v - [:of_int y:])\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> False", "define S where \"S = {0..<int CARD('a)} - {i,j}\""], ["proof (state)\nthis:\n  S = {0..<int CARD('a)} - {i, j}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> False", "have id: \"{0..<int CARD('a)} = (insert i (insert j S))\" and S: \"i \\<notin> S\" \"j \\<notin> S\" \"finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<int CARD('a)} = insert i (insert j S) &&&\n    i \\<notin> S &&& j \\<notin> S &&& finite S", "using i j"], ["proof (prove)\nusing this:\n  i \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n  j \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n\ngoal (1 subgoal):\n 1. {0..<int CARD('a)} = insert i (insert j S) &&&\n    i \\<notin> S &&& j \\<notin> S &&& finite S", "unfolding S_def"], ["proof (prove)\nusing this:\n  i \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n  j \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n\ngoal (1 subgoal):\n 1. {0..<int CARD('a)} =\n    insert i (insert j ({0..<int CARD('a)} - {i, j})) &&&\n    i \\<notin> {0..<int CARD('a)} - {i, j} &&&\n    j \\<notin> {0..<int CARD('a)} - {i, j} &&&\n    finite ({0..<int CARD('a)} - {i, j})", "by auto"], ["proof (state)\nthis:\n  {0..<int CARD('a)} = insert i (insert j S)\n  i \\<notin> S\n  j \\<notin> S\n  finite S\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> False", "assume ij: \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> False", "have \"u = (\\<Prod>i \\<in> {0..< int CARD('a)}. ?g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:]))", "by fact"], ["proof (state)\nthis:\n  u = (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:]))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  u = (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:]))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> False", "have \"\\<dots> = ?g i * ?g j * (\\<Prod>i \\<in> S. ?g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:])) =\n    gcd u (v - [:of_int i:]) * gcd u (v - [:of_int j:]) *\n    (\\<Prod>i\\<in>S. gcd u (v - [:of_int i:]))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>insert i (insert j S). gcd u (v - [:of_int i:])) =\n    gcd u (v - [:of_int i:]) * gcd u (v - [:of_int j:]) *\n    (\\<Prod>i\\<in>S. gcd u (v - [:of_int i:]))", "using S ij"], ["proof (prove)\nusing this:\n  i \\<notin> S\n  j \\<notin> S\n  finite S\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>insert i (insert j S). gcd u (v - [:of_int i:])) =\n    gcd u (v - [:of_int i:]) * gcd u (v - [:of_int j:]) *\n    (\\<Prod>i\\<in>S. gcd u (v - [:of_int i:]))", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:])) =\n  gcd u (v - [:of_int i:]) * gcd u (v - [:of_int j:]) *\n  (\\<Prod>i\\<in>S. gcd u (v - [:of_int i:]))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:])) =\n  gcd u (v - [:of_int i:]) * gcd u (v - [:of_int j:]) *\n  (\\<Prod>i\\<in>S. gcd u (v - [:of_int i:]))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> False", "have \"\\<dots> = ?g i * ?g i * (\\<Prod>i \\<in> S. ?g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd u (v - [:of_int i:]) * gcd u (v - [:of_int j:]) *\n    (\\<Prod>i\\<in>S. gcd u (v - [:of_int i:])) =\n    gcd u (v - [:of_int i:]) * gcd u (v - [:of_int i:]) *\n    (\\<Prod>i\\<in>S. gcd u (v - [:of_int i:]))", "unfolding gij"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd u (v - [:of_int j:]) * gcd u (v - [:of_int j:]) *\n    (\\<Prod>i\\<in>S. gcd u (v - [:of_int i:])) =\n    gcd u (v - [:of_int j:]) * gcd u (v - [:of_int j:]) *\n    (\\<Prod>i\\<in>S. gcd u (v - [:of_int i:]))", "by simp"], ["proof (state)\nthis:\n  gcd u (v - [:of_int i:]) * gcd u (v - [:of_int j:]) *\n  (\\<Prod>i\\<in>S. gcd u (v - [:of_int i:])) =\n  gcd u (v - [:of_int i:]) * gcd u (v - [:of_int i:]) *\n  (\\<Prod>i\\<in>S. gcd u (v - [:of_int i:]))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  u =\n  gcd u (v - [:of_int i:]) * gcd u (v - [:of_int i:]) *\n  (\\<Prod>i\\<in>S. gcd u (v - [:of_int i:]))", "have dvd: \"?g i * ?g i dvd u\""], ["proof (prove)\nusing this:\n  u =\n  gcd u (v - [:of_int i:]) * gcd u (v - [:of_int i:]) *\n  (\\<Prod>i\\<in>S. gcd u (v - [:of_int i:]))\n\ngoal (1 subgoal):\n 1. gcd u (v - [:of_int i:]) * gcd u (v - [:of_int i:]) dvd u", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  u =\n  gcd u (v - [:of_int i:]) * gcd u (v - [:of_int i:]) *\n  (\\<Prod>i\\<in>S. gcd u (v - [:of_int i:]))\n\ngoal (1 subgoal):\n 1. \\<exists>k. u = gcd u (v - [:of_int i:]) * gcd u (v - [:of_int i:]) * k", "by auto"], ["proof (state)\nthis:\n  gcd u (v - [:of_int i:]) * gcd u (v - [:of_int i:]) dvd u\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> False", "with sf_u[unfolded square_free_def, THEN conjunct2, rule_format, OF gS(1)[OF i]]"], ["proof (chain)\npicking this:\n  \\<not> gcd u (v - [:of_int i:]) * gcd u (v - [:of_int i:]) dvd u\n  gcd u (v - [:of_int i:]) * gcd u (v - [:of_int i:]) dvd u", "show False"], ["proof (prove)\nusing this:\n  \\<not> gcd u (v - [:of_int i:]) * gcd u (v - [:of_int i:]) dvd u\n  gcd u (v - [:of_int i:]) * gcd u (v - [:of_int i:]) dvd u\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i = j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (\\<lambda>i. gcd u (v - [:of_int i:]))\n   ({0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1})\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have \"u = (\\<Prod>i \\<in> {0..< int CARD('a)}. ?g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:]))", "by fact"], ["proof (state)\nthis:\n  u = (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:]))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "also"], ["proof (state)\nthis:\n  u = (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:]))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have \"\\<dots> = (\\<Prod>i \\<in> ?S. ?g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:])) =\n    (\\<Prod>i\\<in>{0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}.\n       gcd u (v - [:of_int i:]))", "by (rule sym, rule prod.setdiff_irrelevant, auto)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:])) =\n  (\\<Prod>i\\<in>{0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}.\n     gcd u (v - [:of_int i:]))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<int CARD('a). gcd u (v - [:of_int i:])) =\n  (\\<Prod>i\\<in>{0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}.\n     gcd u (v - [:of_int i:]))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have \"\\<dots> = \\<Prod> (set (udivs u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}.\n       gcd u (v - [:of_int i:])) =\n    \\<Prod>(set (udivs u))", "unfolding udivs_def set_filter set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}.\n       gcd u (v - [:of_int i:])) =\n    \\<Prod>{x \\<in> (\\<lambda>i. gcd u (v - [:of_int i:])) `\n                    int ` set [0..<CARD('a)].\n            x \\<noteq> 1}", "by (rule sym, rule prod.reindex_cong[of ?g, OF inj _ refl], auto simp: int_set[symmetric])"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>{0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}.\n     gcd u (v - [:of_int i:])) =\n  \\<Prod>(set (udivs u))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "finally"], ["proof (chain)\npicking this:\n  u = \\<Prod>(set (udivs u))", "have u_udivs: \"u = \\<Prod>(set (udivs u))\""], ["proof (prove)\nusing this:\n  u = \\<Prod>(set (udivs u))\n\ngoal (1 subgoal):\n 1. u = \\<Prod>(set (udivs u))", "."], ["proof (state)\nthis:\n  u = \\<Prod>(set (udivs u))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "{"], ["proof (state)\nthis:\n  u = \\<Prod>(set (udivs u))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "fix w"], ["proof (state)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "assume mem: \"w \\<in> set (udivs u)\""], ["proof (state)\nthis:\n  w \\<in> set (udivs u)\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "then"], ["proof (chain)\npicking this:\n  w \\<in> set (udivs u)", "obtain i where w: \"w = ?g i\" and i: \"i \\<in> ?S\""], ["proof (prove)\nusing this:\n  w \\<in> set (udivs u)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>w = gcd u (v - [:of_int i:]);\n         i \\<in> {0..<int CARD('a)} -\n                 {i. gcd u (v - [:of_int i:]) = 1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding udivs_def set_filter set_map int_set"], ["proof (prove)\nusing this:\n  w \\<in> {x \\<in> (\\<lambda>i. gcd u (v - [:of_int i:])) `\n                   {0..<int CARD('a)}.\n           x \\<noteq> 1}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>w = gcd u (v - [:of_int i:]);\n         i \\<in> {0..<int CARD('a)} -\n                 {i. gcd u (v - [:of_int i:]) = 1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w = gcd u (v - [:of_int i:])\n  i \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have wu: \"w dvd u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w dvd u", "by (simp add: w)"], ["proof (state)\nthis:\n  w dvd u\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "let ?v = \"\\<lambda> j. v - [:of_nat j:]\""], ["proof (state)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "define j where \"j = nat i\""], ["proof (state)\nthis:\n  j = nat i\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from i"], ["proof (chain)\npicking this:\n  i \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}", "have j: \"of_int i = (of_nat j :: 'a mod_ring)\" \"j < CARD('a)\""], ["proof (prove)\nusing this:\n  i \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n\ngoal (1 subgoal):\n 1. of_int i = of_nat j &&& j < CARD('a)", "unfolding j_def"], ["proof (prove)\nusing this:\n  i \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n\ngoal (1 subgoal):\n 1. of_int i = of_nat (nat i) &&& nat i < CARD('a)", "by auto"], ["proof (state)\nthis:\n  of_int i = of_nat j\n  j < CARD('a)\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from gS[OF i, folded w]"], ["proof (chain)\npicking this:\n  0 < degree w\n  monic w", "have *: \"degree w > 0\" \"monic w\" \"w \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree w\n  monic w\n\ngoal (1 subgoal):\n 1. 0 < degree w &&& monic w &&& w \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  0 < degree w\n  monic w\n  w \\<noteq> 0\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from w"], ["proof (chain)\npicking this:\n  w = gcd u (v - [:of_int i:])", "have \"w dvd ?v j\""], ["proof (prove)\nusing this:\n  w = gcd u (v - [:of_int i:])\n\ngoal (1 subgoal):\n 1. w dvd v - [:of_nat j:]", "using j"], ["proof (prove)\nusing this:\n  w = gcd u (v - [:of_int i:])\n  of_int i = of_nat j\n  j < CARD('a)\n\ngoal (1 subgoal):\n 1. w dvd v - [:of_nat j:]", "by simp"], ["proof (state)\nthis:\n  w dvd v - [:of_nat j:]\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "hence gcdj: \"?gcdn w j = w\""], ["proof (prove)\nusing this:\n  w dvd v - [:of_nat j:]\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j:]) = w", "by (metis gcd.commute gcd_left_idem j(1) w)"], ["proof (state)\nthis:\n  gcd w (v - [:of_nat j:]) = w\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "{"], ["proof (state)\nthis:\n  gcd w (v - [:of_nat j:]) = w\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "fix j'"], ["proof (state)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "assume j': \"j' < CARD('a)\""], ["proof (state)\nthis:\n  j' < CARD('a)\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have \"?gcdn w j' \\<in> {1,w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<in> {1, w}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "assume not: \"?gcdn w j' \\<notin> {1,w}\""], ["proof (state)\nthis:\n  gcd w (v - [:of_nat j':]) \\<notin> {1, w}\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "with gcdj"], ["proof (chain)\npicking this:\n  gcd w (v - [:of_nat j:]) = w\n  gcd w (v - [:of_nat j':]) \\<notin> {1, w}", "have neq: \"int j' \\<noteq> int j\""], ["proof (prove)\nusing this:\n  gcd w (v - [:of_nat j:]) = w\n  gcd w (v - [:of_nat j':]) \\<notin> {1, w}\n\ngoal (1 subgoal):\n 1. int j' \\<noteq> int j", "by auto"], ["proof (state)\nthis:\n  int j' \\<noteq> int j\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "(* next step will yield contradiction to square_free u *)"], ["proof (state)\nthis:\n  int j' \\<noteq> int j\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "let ?h = \"?gcdn w j'\""], ["proof (state)\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "from *(3) not"], ["proof (chain)\npicking this:\n  w \\<noteq> 0\n  gcd w (v - [:of_nat j':]) \\<notin> {1, w}", "have deg: \"degree ?h > 0\""], ["proof (prove)\nusing this:\n  w \\<noteq> 0\n  gcd w (v - [:of_nat j':]) \\<notin> {1, w}\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd w (v - [:of_nat j':]))", "using monic_degree_0 poly_gcd_monic"], ["proof (prove)\nusing this:\n  w \\<noteq> 0\n  gcd w (v - [:of_nat j':]) \\<notin> {1, w}\n  monic ?p \\<Longrightarrow> (degree ?p = 0) = (?p = 1)\n  ?p \\<noteq> 0 \\<or> ?q \\<noteq> 0 \\<Longrightarrow> monic (gcd ?p ?q)\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd w (v - [:of_nat j':]))", "by auto"], ["proof (state)\nthis:\n  0 < degree (gcd w (v - [:of_nat j':]))\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "have hw: \"?h dvd w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) dvd w", "by auto"], ["proof (state)\nthis:\n  gcd w (v - [:of_nat j':]) dvd w\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "have \"?h dvd ?gcdn u j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) dvd gcd u (v - [:of_nat j':])", "using wu"], ["proof (prove)\nusing this:\n  w dvd u\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) dvd gcd u (v - [:of_nat j':])", "using dvd_trans"], ["proof (prove)\nusing this:\n  w dvd u\n  \\<lbrakk>?a dvd ?b; ?b dvd ?c\\<rbrakk> \\<Longrightarrow> ?a dvd ?c\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) dvd gcd u (v - [:of_nat j':])", "by auto"], ["proof (state)\nthis:\n  gcd w (v - [:of_nat j':]) dvd gcd u (v - [:of_nat j':])\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  gcd w (v - [:of_nat j':]) dvd gcd u (v - [:of_nat j':])\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "have \"?gcdn u j' = ?g j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd u (v - [:of_nat j':]) = gcd u (v - [:of_int (int j'):])", "by simp"], ["proof (state)\nthis:\n  gcd u (v - [:of_nat j':]) = gcd u (v - [:of_int (int j'):])\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  gcd w (v - [:of_nat j':]) dvd gcd u (v - [:of_int (int j'):])", "have hj': \"?h dvd ?g j'\""], ["proof (prove)\nusing this:\n  gcd w (v - [:of_nat j':]) dvd gcd u (v - [:of_int (int j'):])\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) dvd gcd u (v - [:of_int (int j'):])", "by auto"], ["proof (state)\nthis:\n  gcd w (v - [:of_nat j':]) dvd gcd u (v - [:of_int (int j'):])\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "from divides_degree[OF this] deg u0"], ["proof (chain)\npicking this:\n  degree (gcd w (v - [:of_nat j':]))\n  \\<le> degree (gcd u (v - [:of_int (int j'):])) \\<or>\n  gcd u (v - [:of_int (int j'):]) = 0\n  0 < degree (gcd w (v - [:of_nat j':]))\n  u \\<noteq> 0", "have degj': \"degree (?g j') > 0\""], ["proof (prove)\nusing this:\n  degree (gcd w (v - [:of_nat j':]))\n  \\<le> degree (gcd u (v - [:of_int (int j'):])) \\<or>\n  gcd u (v - [:of_int (int j'):]) = 0\n  0 < degree (gcd w (v - [:of_nat j':]))\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd u (v - [:of_int (int j'):]))", "by auto"], ["proof (state)\nthis:\n  0 < degree (gcd u (v - [:of_int (int j'):]))\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "hence j'1: \"?g j' \\<noteq> 1\""], ["proof (prove)\nusing this:\n  0 < degree (gcd u (v - [:of_int (int j'):]))\n\ngoal (1 subgoal):\n 1. gcd u (v - [:of_int (int j'):]) \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  gcd u (v - [:of_int (int j'):]) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "with j'"], ["proof (chain)\npicking this:\n  j' < CARD('a)\n  gcd u (v - [:of_int (int j'):]) \\<noteq> 1", "have mem': \"?g j' \\<in> set (udivs u)\""], ["proof (prove)\nusing this:\n  j' < CARD('a)\n  gcd u (v - [:of_int (int j'):]) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. gcd u (v - [:of_int (int j'):]) \\<in> set (udivs u)", "unfolding udivs_def"], ["proof (prove)\nusing this:\n  j' < CARD('a)\n  gcd u (v - [:of_int (int j'):]) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. gcd u (v - [:of_int (int j'):])\n    \\<in> set (filter (\\<lambda>w. w \\<noteq> 1)\n                (map (\\<lambda>i. gcd u (v - [:of_int i:]))\n                  (map int [0..<CARD('a)])))", "by auto"], ["proof (state)\nthis:\n  gcd u (v - [:of_int (int j'):]) \\<in> set (udivs u)\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "from degj' j'"], ["proof (chain)\npicking this:\n  0 < degree (gcd u (v - [:of_int (int j'):]))\n  j' < CARD('a)", "have j'S: \"int j' \\<in> ?S\""], ["proof (prove)\nusing this:\n  0 < degree (gcd u (v - [:of_int (int j'):]))\n  j' < CARD('a)\n\ngoal (1 subgoal):\n 1. int j' \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}", "by auto"], ["proof (state)\nthis:\n  int j' \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "from i j"], ["proof (chain)\npicking this:\n  i \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n  of_int i = of_nat j\n  j < CARD('a)", "have jS: \"int j \\<in> ?S\""], ["proof (prove)\nusing this:\n  i \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n  of_int i = of_nat j\n  j < CARD('a)\n\ngoal (1 subgoal):\n 1. int j \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}", "by auto"], ["proof (state)\nthis:\n  int j \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "from inj_on_contraD[OF inj neq j'S jS]"], ["proof (chain)\npicking this:\n  gcd u (v - [:of_int (int j'):]) \\<noteq> gcd u (v - [:of_int (int j):])", "have neq: \"w \\<noteq> ?g j'\""], ["proof (prove)\nusing this:\n  gcd u (v - [:of_int (int j'):]) \\<noteq> gcd u (v - [:of_int (int j):])\n\ngoal (1 subgoal):\n 1. w \\<noteq> gcd u (v - [:of_int (int j'):])", "using w j"], ["proof (prove)\nusing this:\n  gcd u (v - [:of_int (int j'):]) \\<noteq> gcd u (v - [:of_int (int j):])\n  w = gcd u (v - [:of_int i:])\n  of_int i = of_nat j\n  j < CARD('a)\n\ngoal (1 subgoal):\n 1. w \\<noteq> gcd u (v - [:of_int (int j'):])", "by auto"], ["proof (state)\nthis:\n  w \\<noteq> gcd u (v - [:of_int (int j'):])\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "have cop: \"\\<not> coprime w (?g j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime w\n            (gcd u (v - [:of_int (int j'):]))", "using hj' hw deg"], ["proof (prove)\nusing this:\n  gcd w (v - [:of_nat j':]) dvd gcd u (v - [:of_int (int j'):])\n  gcd w (v - [:of_nat j':]) dvd w\n  0 < degree (gcd w (v - [:of_nat j':]))\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime w\n            (gcd u (v - [:of_int (int j'):]))", "by (metis coprime_not_unit_not_dvd poly_dvd_1 Nat.neq0_conv)"], ["proof (state)\nthis:\n  \\<not> comm_monoid_mult_class.coprime w (gcd u (v - [:of_int (int j'):]))\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "obtain w' where w': \"?g j' = w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w'.\n        gcd u (v - [:of_int (int j'):]) = w' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  gcd u (v - [:of_int (int j'):]) = w'\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "from u_udivs sf_u"], ["proof (chain)\npicking this:\n  u = \\<Prod>(set (udivs u))\n  square_free u", "have \"square_free (\\<Prod>(set (udivs u)))\""], ["proof (prove)\nusing this:\n  u = \\<Prod>(set (udivs u))\n  square_free u\n\ngoal (1 subgoal):\n 1. square_free (\\<Prod>(set (udivs u)))", "by simp"], ["proof (state)\nthis:\n  square_free (\\<Prod>(set (udivs u)))\n\ngoal (1 subgoal):\n 1. gcd w (v - [:of_nat j':]) \\<notin> {1, w} \\<Longrightarrow> False", "from square_free_prodD[OF this finite_set mem mem'] cop neq"], ["proof (chain)\npicking this:\n  w \\<noteq> gcd u (v - [:of_int (int j'):]) \\<Longrightarrow>\n  algebraic_semidom_class.coprime w (gcd u (v - [:of_int (int j'):]))\n  \\<not> comm_monoid_mult_class.coprime w (gcd u (v - [:of_int (int j'):]))\n  w \\<noteq> gcd u (v - [:of_int (int j'):])", "show False"], ["proof (prove)\nusing this:\n  w \\<noteq> gcd u (v - [:of_int (int j'):]) \\<Longrightarrow>\n  algebraic_semidom_class.coprime w (gcd u (v - [:of_int (int j'):]))\n  \\<not> comm_monoid_mult_class.coprime w (gcd u (v - [:of_int (int j'):]))\n  w \\<noteq> gcd u (v - [:of_int (int j'):])\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcd w (v - [:of_nat j':]) \\<in> {1, w}\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "}"], ["proof (state)\nthis:\n  ?j'2 < CARD('a) \\<Longrightarrow> gcd w (v - [:of_nat ?j'2:]) \\<in> {1, w}\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from gS[OF i, folded w] i this"], ["proof (chain)\npicking this:\n  0 < degree w\n  monic w\n  i \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n  ?j'2 < CARD('a) \\<Longrightarrow> gcd w (v - [:of_nat ?j'2:]) \\<in> {1, w}", "have \"degree w > 0\" \"monic w\" \"\\<And> j. j < CARD('a) \\<Longrightarrow> ?gcdn w j \\<in> {1,w}\""], ["proof (prove)\nusing this:\n  0 < degree w\n  monic w\n  i \\<in> {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1}\n  ?j'2 < CARD('a) \\<Longrightarrow> gcd w (v - [:of_nat ?j'2:]) \\<in> {1, w}\n\ngoal (1 subgoal):\n 1. 0 < degree w &&&\n    monic w &&&\n    (\\<And>j.\n        j < CARD('a) \\<Longrightarrow>\n        gcd w (v - [:of_nat j:]) \\<in> {1, w})", "by auto"], ["proof (state)\nthis:\n  0 < degree w\n  monic w\n  ?j < CARD('a) \\<Longrightarrow> gcd w (v - [:of_nat ?j:]) \\<in> {1, w}\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "}"], ["proof (state)\nthis:\n  ?w8 \\<in> set (udivs u) \\<Longrightarrow> 0 < degree ?w8\n  ?w8 \\<in> set (udivs u) \\<Longrightarrow> monic ?w8\n  \\<lbrakk>?w8 \\<in> set (udivs u); ?j5 < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> gcd ?w8 (v - [:of_nat ?j5:]) \\<in> {1, ?w8}\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "note udivs = this"], ["proof (state)\nthis:\n  ?w8 \\<in> set (udivs u) \\<Longrightarrow> 0 < degree ?w8\n  ?w8 \\<in> set (udivs u) \\<Longrightarrow> monic ?w8\n  \\<lbrakk>?w8 \\<in> set (udivs u); ?j5 < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> gcd ?w8 (v - [:of_nat ?j5:]) \\<in> {1, ?w8}\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "let ?is = \"filter (\\<lambda> i. ?g i \\<noteq> 1) (map int [0 ..< CARD('a)])\""], ["proof (state)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have id: \"udivs u = map ?g ?is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. udivs u =\n    map (\\<lambda>i. gcd u (v - [:of_int i:]))\n     (filter (\\<lambda>i. gcd u (v - [:of_int i:]) \\<noteq> 1)\n       (map int [0..<CARD('a)]))", "unfolding udivs_def filter_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. gcd u (v - [:of_int i:]))\n     (map int\n       (filter (\\<lambda>x. gcd u (v - [:of_int (int x):]) \\<noteq> 1)\n         [0..<CARD('a)])) =\n    map (\\<lambda>i. gcd u (v - [:of_int i:]))\n     (map int\n       (filter (\\<lambda>x. gcd u (v - [:of_int (int x):]) \\<noteq> 1)\n         [0..<CARD('a)]))", ".."], ["proof (state)\nthis:\n  udivs u =\n  map (\\<lambda>i. gcd u (v - [:of_int i:]))\n   (filter (\\<lambda>i. gcd u (v - [:of_int i:]) \\<noteq> 1)\n     (map int [0..<CARD('a)]))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have dist: \"distinct (udivs u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (udivs u)", "unfolding id distinct_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (filter (\\<lambda>i. gcd u (v - [:of_int i:]) \\<noteq> 1)\n       (map int [0..<CARD('a)])) \\<and>\n    inj_on (\\<lambda>i. gcd u (v - [:of_int i:]))\n     (set (filter (\\<lambda>i. gcd u (v - [:of_int i:]) \\<noteq> 1)\n            (map int [0..<CARD('a)])))", "proof (rule conjI[OF distinct_filter], unfold distinct_map)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct [0..<CARD('a)] \\<and> inj_on int (set [0..<CARD('a)])\n 2. inj_on (\\<lambda>i. gcd u (v - [:of_int i:]))\n     (set (filter (\\<lambda>i. gcd u (v - [:of_int i:]) \\<noteq> 1)\n            (map int [0..<CARD('a)])))", "have \"?S = set ?is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1} =\n    set (filter (\\<lambda>i. gcd u (v - [:of_int i:]) \\<noteq> 1)\n          (map int [0..<CARD('a)]))", "unfolding int_set[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. int ` set [0..<CARD('a)] - {i. gcd u (v - [:of_int i:]) = 1} =\n    set (filter (\\<lambda>i. gcd u (v - [:of_int i:]) \\<noteq> 1)\n          (map int [0..<CARD('a)]))", "by auto"], ["proof (state)\nthis:\n  {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1} =\n  set (filter (\\<lambda>i. gcd u (v - [:of_int i:]) \\<noteq> 1)\n        (map int [0..<CARD('a)]))\n\ngoal (2 subgoals):\n 1. distinct [0..<CARD('a)] \\<and> inj_on int (set [0..<CARD('a)])\n 2. inj_on (\\<lambda>i. gcd u (v - [:of_int i:]))\n     (set (filter (\\<lambda>i. gcd u (v - [:of_int i:]) \\<noteq> 1)\n            (map int [0..<CARD('a)])))", "thus \"inj_on ?g (set ?is)\""], ["proof (prove)\nusing this:\n  {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1} =\n  set (filter (\\<lambda>i. gcd u (v - [:of_int i:]) \\<noteq> 1)\n        (map int [0..<CARD('a)]))\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>i. gcd u (v - [:of_int i:]))\n     (set (filter (\\<lambda>i. gcd u (v - [:of_int i:]) \\<noteq> 1)\n            (map int [0..<CARD('a)])))", "using inj"], ["proof (prove)\nusing this:\n  {0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1} =\n  set (filter (\\<lambda>i. gcd u (v - [:of_int i:]) \\<noteq> 1)\n        (map int [0..<CARD('a)]))\n  inj_on (\\<lambda>i. gcd u (v - [:of_int i:]))\n   ({0..<int CARD('a)} - {i. gcd u (v - [:of_int i:]) = 1})\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>i. gcd u (v - [:of_int i:]))\n     (set (filter (\\<lambda>i. gcd u (v - [:of_int i:]) \\<noteq> 1)\n            (map int [0..<CARD('a)])))", "by auto"], ["proof (state)\nthis:\n  inj_on (\\<lambda>i. gcd u (v - [:of_int i:]))\n   (set (filter (\\<lambda>i. gcd u (v - [:of_int i:]) \\<noteq> 1)\n          (map int [0..<CARD('a)])))\n\ngoal (1 subgoal):\n 1. distinct [0..<CARD('a)] \\<and> inj_on int (set [0..<CARD('a)])", "qed (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  distinct (udivs u)\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from u_udivs prod.distinct_set_conv_list[OF dist, of id]"], ["proof (chain)\npicking this:\n  u = \\<Prod>(set (udivs u))\n  prod id (set (udivs u)) = prod_list (map id (udivs u))", "have \"prod_list (udivs u) = u\""], ["proof (prove)\nusing this:\n  u = \\<Prod>(set (udivs u))\n  prod id (set (udivs u)) = prod_list (map id (udivs u))\n\ngoal (1 subgoal):\n 1. prod_list (udivs u) = u", "by auto"], ["proof (state)\nthis:\n  prod_list (udivs u) = u\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "note udivs this dist"], ["proof (state)\nthis:\n  ?w8 \\<in> set (udivs u) \\<Longrightarrow> 0 < degree ?w8\n  ?w8 \\<in> set (udivs u) \\<Longrightarrow> monic ?w8\n  \\<lbrakk>?w8 \\<in> set (udivs u); ?j5 < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> gcd ?w8 (v - [:of_nat ?j5:]) \\<in> {1, ?w8}\n  prod_list (udivs u) = u\n  distinct (udivs u)\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?u8 \\<in> set divs; ?w5 \\<in> set (udivs ?u8)\\<rbrakk>\n  \\<Longrightarrow> 0 < degree ?w5\n  \\<lbrakk>?u8 \\<in> set divs; ?w5 \\<in> set (udivs ?u8)\\<rbrakk>\n  \\<Longrightarrow> monic ?w5\n  \\<lbrakk>?u8 \\<in> set divs; ?w5 \\<in> set (udivs ?u8);\n   ?j5 < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> gcd ?w5 (v - [:of_nat ?j5:]) \\<in> {1, ?w5}\n  ?u8 \\<in> set divs \\<Longrightarrow> prod_list (udivs ?u8) = ?u8\n  ?u8 \\<in> set divs \\<Longrightarrow> distinct (udivs ?u8)\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "note udivs = this"], ["proof (state)\nthis:\n  \\<lbrakk>?u8 \\<in> set divs; ?w5 \\<in> set (udivs ?u8)\\<rbrakk>\n  \\<Longrightarrow> 0 < degree ?w5\n  \\<lbrakk>?u8 \\<in> set divs; ?w5 \\<in> set (udivs ?u8)\\<rbrakk>\n  \\<Longrightarrow> monic ?w5\n  \\<lbrakk>?u8 \\<in> set divs; ?w5 \\<in> set (udivs ?u8);\n   ?j5 < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> gcd ?w5 (v - [:of_nat ?j5:]) \\<in> {1, ?w5}\n  ?u8 \\<in> set divs \\<Longrightarrow> prod_list (udivs ?u8) = ?u8\n  ?u8 \\<in> set divs \\<Longrightarrow> distinct (udivs ?u8)\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have facts: \"facts = concat (map udivs divs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. facts = concat (map udivs divs)", "unfolding facts_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>u. map (\\<lambda>w. w) (udivs u)) divs) =\n    concat (map udivs divs)", "by auto"], ["proof (state)\nthis:\n  facts = concat (map udivs divs)\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "obtain lin nonlin where part: \"List.partition (\\<lambda> q. degree q = d) facts = (lin,nonlin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lin nonlin.\n        List.partition (\\<lambda>q. degree q = d) facts =\n        (lin, nonlin) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  List.partition (\\<lambda>q. degree q = d) facts = (lin, nonlin)\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from Cons(6)"], ["proof (chain)\npicking this:\n  f = prod_list (us1 @ divs)", "have \"f = prod_list us1 * prod_list divs\""], ["proof (prove)\nusing this:\n  f = prod_list (us1 @ divs)\n\ngoal (1 subgoal):\n 1. f = prod_list us1 * prod_list divs", "by auto"], ["proof (state)\nthis:\n  f = prod_list us1 * prod_list divs\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "also"], ["proof (state)\nthis:\n  f = prod_list us1 * prod_list divs\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have \"prod_list divs = prod_list facts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list divs = prod_list facts", "unfolding facts"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list divs = prod_list (concat (map udivs divs))", "using udivs(4)"], ["proof (prove)\nusing this:\n  ?u8 \\<in> set divs \\<Longrightarrow> prod_list (udivs ?u8) = ?u8\n\ngoal (1 subgoal):\n 1. prod_list divs = prod_list (concat (map udivs divs))", "by (induct divs, auto)"], ["proof (state)\nthis:\n  prod_list divs = prod_list facts\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "finally"], ["proof (chain)\npicking this:\n  f = prod_list us1 * prod_list facts", "have f: \"f = prod_list us1 * prod_list facts\""], ["proof (prove)\nusing this:\n  f = prod_list us1 * prod_list facts\n\ngoal (1 subgoal):\n 1. f = prod_list us1 * prod_list facts", "."], ["proof (state)\nthis:\n  f = prod_list us1 * prod_list facts\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "note facts' = facts"], ["proof (state)\nthis:\n  facts = concat (map udivs divs)\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "{"], ["proof (state)\nthis:\n  facts = concat (map udivs divs)\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "assume u: \"u \\<in> set facts\""], ["proof (state)\nthis:\n  u \\<in> set facts\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from u[unfolded facts]"], ["proof (chain)\npicking this:\n  u \\<in> set (concat (map udivs divs))", "obtain u' where u': \"u' \\<in> set divs\" and u: \"u \\<in> set (udivs u')\""], ["proof (prove)\nusing this:\n  u \\<in> set (concat (map udivs divs))\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>u' \\<in> set divs; u \\<in> set (udivs u')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u' \\<in> set divs\n  u \\<in> set (udivs u')\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from u' udivs(1-2)[OF u' u] prod_list_dvd[OF u, unfolded udivs(4)[OF u']]"], ["proof (chain)\npicking this:\n  u' \\<in> set divs\n  0 < degree u\n  monic u\n  u dvd u'", "have \"degree u > 0\" \"monic u\" \"\\<exists> u' \\<in> set divs. u dvd u'\""], ["proof (prove)\nusing this:\n  u' \\<in> set divs\n  0 < degree u\n  monic u\n  u dvd u'\n\ngoal (1 subgoal):\n 1. 0 < degree u &&& monic u &&& \\<exists>u'\\<in>set divs. u dvd u'", "by auto"], ["proof (state)\nthis:\n  0 < degree u\n  monic u\n  \\<exists>u'\\<in>set divs. u dvd u'\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "}"], ["proof (state)\nthis:\n  ?u2 \\<in> set facts \\<Longrightarrow> 0 < degree ?u2\n  ?u2 \\<in> set facts \\<Longrightarrow> monic ?u2\n  ?u2 \\<in> set facts \\<Longrightarrow> \\<exists>u'\\<in>set divs. ?u2 dvd u'\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "note facts = this"], ["proof (state)\nthis:\n  ?u2 \\<in> set facts \\<Longrightarrow> 0 < degree ?u2\n  ?u2 \\<in> set facts \\<Longrightarrow> monic ?u2\n  ?u2 \\<in> set facts \\<Longrightarrow> \\<exists>u'\\<in>set divs. ?u2 dvd u'\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have not1: \"(v = 1) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v = 1) = False", "using False"], ["proof (prove)\nusing this:\n  v \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (v = 1) = False", "by auto"], ["proof (state)\nthis:\n  (v = 1) = False\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have \"us = us1 @ (if length divs = n2 then divs\n          else let (lin, nonlin) = List.partition (\\<lambda>q. degree q = d) facts\n               in lin @ berlekamp_factorization_main d nonlin vs2 (n2 - length lin))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us =\n    us1 @\n    (if length divs = n2 then divs\n     else let (lin, nonlin) =\n                List.partition (\\<lambda>q. degree q = d) facts\n          in lin @\n             berlekamp_factorization_main d nonlin vs2 (n2 - length lin))", "unfolding Cons(4) facts_def udivs_def' berlekamp_factorization_main.simps Let_def not1 if_False"], ["proof (prove)\ngoal (1 subgoal):\n 1. us1 @\n    (if length divs = n2 then divs\n     else case List.partition (\\<lambda>q. degree q = d)\n                (concat\n                  (map (\\<lambda>u.\n                           concat\n                            (map (\\<lambda>s.\n                                     concat\n(map (\\<lambda>w. if w \\<noteq> 1 then [w] else [])\n  [gcd u (v - [:of_int s:])]))\n                              (map int [0..<CARD('a)])))\n                    divs)) of\n          (lin, nonlin) \\<Rightarrow>\n            lin @\n            berlekamp_factorization_main d nonlin vs2 (n2 - length lin)) =\n    us1 @\n    (if length divs = n2 then divs\n     else case List.partition (\\<lambda>q. degree q = d)\n                (concat\n                  (map (\\<lambda>u.\n                           map (\\<lambda>w. w)\n                            (concat\n                              (map (\\<lambda>i.\n concat\n  (map (\\<lambda>w. if w \\<noteq> 1 then [w] else [])\n    [gcd u (v - [:of_int i:])]))\n                                (map int [0..<CARD('a)]))))\n                    divs)) of\n          (lin, nonlin) \\<Rightarrow>\n            lin @\n            berlekamp_factorization_main d nonlin vs2 (n2 - length lin))", "by (rule arg_cong[where f = \"\\<lambda> x. us1 @ x\"], rule if_cong, simp_all)"], ["proof (state)\nthis:\n  us =\n  us1 @\n  (if length divs = n2 then divs\n   else let (lin, nonlin) = List.partition (\\<lambda>q. degree q = d) facts\n        in lin @\n           berlekamp_factorization_main d nonlin vs2 (n2 - length lin))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "(* takes time *)"], ["proof (state)\nthis:\n  us =\n  us1 @\n  (if length divs = n2 then divs\n   else let (lin, nonlin) = List.partition (\\<lambda>q. degree q = d) facts\n        in lin @\n           berlekamp_factorization_main d nonlin vs2 (n2 - length lin))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "hence res: \"us = us1 @ (if length divs = n2 then divs else\n               lin @ berlekamp_factorization_main d nonlin vs2 (n2 - length lin))\""], ["proof (prove)\nusing this:\n  us =\n  us1 @\n  (if length divs = n2 then divs\n   else let (lin, nonlin) = List.partition (\\<lambda>q. degree q = d) facts\n        in lin @\n           berlekamp_factorization_main d nonlin vs2 (n2 - length lin))\n\ngoal (1 subgoal):\n 1. us =\n    us1 @\n    (if length divs = n2 then divs\n     else lin @ berlekamp_factorization_main d nonlin vs2 (n2 - length lin))", "unfolding part"], ["proof (prove)\nusing this:\n  us =\n  us1 @\n  (if length divs = n2 then divs\n   else let (lin, nonlin) = (lin, nonlin)\n        in lin @\n           berlekamp_factorization_main d nonlin vs2 (n2 - length lin))\n\ngoal (1 subgoal):\n 1. us =\n    us1 @\n    (if length divs = n2 then divs\n     else lin @ berlekamp_factorization_main d nonlin vs2 (n2 - length lin))", "by auto"], ["proof (state)\nthis:\n  us =\n  us1 @\n  (if length divs = n2 then divs\n   else lin @ berlekamp_factorization_main d nonlin vs2 (n2 - length lin))\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "proof (cases \"length divs = n2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. length divs \\<noteq> n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "case False"], ["proof (state)\nthis:\n  length divs \\<noteq> n2\n\ngoal (2 subgoals):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. length divs \\<noteq> n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "with res"], ["proof (chain)\npicking this:\n  us =\n  us1 @\n  (if length divs = n2 then divs\n   else lin @ berlekamp_factorization_main d nonlin vs2 (n2 - length lin))\n  length divs \\<noteq> n2", "have us: \"us = (us1 @ lin) @ berlekamp_factorization_main d nonlin vs2 (n2 - length lin)\""], ["proof (prove)\nusing this:\n  us =\n  us1 @\n  (if length divs = n2 then divs\n   else lin @ berlekamp_factorization_main d nonlin vs2 (n2 - length lin))\n  length divs \\<noteq> n2\n\ngoal (1 subgoal):\n 1. us =\n    (us1 @ lin) @\n    berlekamp_factorization_main d nonlin vs2 (n2 - length lin)", "by auto"], ["proof (state)\nthis:\n  us =\n  (us1 @ lin) @ berlekamp_factorization_main d nonlin vs2 (n2 - length lin)\n\ngoal (2 subgoals):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. length divs \\<noteq> n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from Cons(2)"], ["proof (chain)\npicking this:\n  vs = vs1 @ v # vs2", "have vs: \"vs = (vs1 @ [v]) @ vs2\""], ["proof (prove)\nusing this:\n  vs = vs1 @ v # vs2\n\ngoal (1 subgoal):\n 1. vs = (vs1 @ [v]) @ vs2", "by auto"], ["proof (state)\nthis:\n  vs = (vs1 @ [v]) @ vs2\n\ngoal (2 subgoals):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. length divs \\<noteq> n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have f: \"f = prod_list ((us1 @ lin) @ nonlin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list ((us1 @ lin) @ nonlin)", "unfolding f"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list us1 * prod_list facts = prod_list ((us1 @ lin) @ nonlin)", "using prod_list_partition[OF part]"], ["proof (prove)\nusing this:\n  prod_list facts = prod_list lin * prod_list nonlin\n\ngoal (1 subgoal):\n 1. prod_list us1 * prod_list facts = prod_list ((us1 @ lin) @ nonlin)", "by simp"], ["proof (state)\nthis:\n  f = prod_list ((us1 @ lin) @ nonlin)\n\ngoal (2 subgoals):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. length divs \\<noteq> n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "{"], ["proof (state)\nthis:\n  f = prod_list ((us1 @ lin) @ nonlin)\n\ngoal (2 subgoals):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. length divs \\<noteq> n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. length divs \\<noteq> n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "assume \"u \\<in> set ((us1 @ lin) @ nonlin)\""], ["proof (state)\nthis:\n  u \\<in> set ((us1 @ lin) @ nonlin)\n\ngoal (2 subgoals):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. length divs \\<noteq> n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "with part"], ["proof (chain)\npicking this:\n  List.partition (\\<lambda>q. degree q = d) facts = (lin, nonlin)\n  u \\<in> set ((us1 @ lin) @ nonlin)", "have \"u \\<in> set facts \\<union> set us1\""], ["proof (prove)\nusing this:\n  List.partition (\\<lambda>q. degree q = d) facts = (lin, nonlin)\n  u \\<in> set ((us1 @ lin) @ nonlin)\n\ngoal (1 subgoal):\n 1. u \\<in> set facts \\<union> set us1", "by auto"], ["proof (state)\nthis:\n  u \\<in> set facts \\<union> set us1\n\ngoal (2 subgoals):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. length divs \\<noteq> n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "with facts Cons(7)"], ["proof (chain)\npicking this:\n  ?u2 \\<in> set facts \\<Longrightarrow> 0 < degree ?u2\n  ?u2 \\<in> set facts \\<Longrightarrow> monic ?u2\n  ?u2 \\<in> set facts \\<Longrightarrow> \\<exists>u'\\<in>set divs. ?u2 dvd u'\n  ?u \\<in> set us1 \\<Longrightarrow> monic ?u \\<and> irreducible ?u\n  u \\<in> set facts \\<union> set us1", "have \"degree u > 0\""], ["proof (prove)\nusing this:\n  ?u2 \\<in> set facts \\<Longrightarrow> 0 < degree ?u2\n  ?u2 \\<in> set facts \\<Longrightarrow> monic ?u2\n  ?u2 \\<in> set facts \\<Longrightarrow> \\<exists>u'\\<in>set divs. ?u2 dvd u'\n  ?u \\<in> set us1 \\<Longrightarrow> monic ?u \\<and> irreducible ?u\n  u \\<in> set facts \\<union> set us1\n\ngoal (1 subgoal):\n 1. 0 < degree u", "by (auto simp: irreducible_degree_field)"], ["proof (state)\nthis:\n  0 < degree u\n\ngoal (2 subgoals):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. length divs \\<noteq> n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "}"], ["proof (state)\nthis:\n  ?u2 \\<in> set ((us1 @ lin) @ nonlin) \\<Longrightarrow> 0 < degree ?u2\n\ngoal (2 subgoals):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. length divs \\<noteq> n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "note deg = this"], ["proof (state)\nthis:\n  ?u2 \\<in> set ((us1 @ lin) @ nonlin) \\<Longrightarrow> 0 < degree ?u2\n\ngoal (2 subgoals):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. length divs \\<noteq> n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from berlekamp_basis_length_factorization[OF sf_f n_bb mon_f f deg, unfolded Cons(3)]"], ["proof (chain)\npicking this:\n  (\\<And>u.\n      u \\<in> set ((us1 @ lin) @ nonlin) \\<Longrightarrow>\n      u \\<in> set ((us1 @ lin) @ nonlin)) \\<Longrightarrow>\n  length ((us1 @ lin) @ nonlin) \\<le> length us1 + n2", "have \"n2 \\<ge> length lin\""], ["proof (prove)\nusing this:\n  (\\<And>u.\n      u \\<in> set ((us1 @ lin) @ nonlin) \\<Longrightarrow>\n      u \\<in> set ((us1 @ lin) @ nonlin)) \\<Longrightarrow>\n  length ((us1 @ lin) @ nonlin) \\<le> length us1 + n2\n\ngoal (1 subgoal):\n 1. length lin \\<le> n2", "by auto"], ["proof (state)\nthis:\n  length lin \\<le> n2\n\ngoal (2 subgoals):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. length divs \\<noteq> n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "hence n: \"n = length (us1 @ lin) + (n2 - length lin)\""], ["proof (prove)\nusing this:\n  length lin \\<le> n2\n\ngoal (1 subgoal):\n 1. n = length (us1 @ lin) + (n2 - length lin)", "unfolding Cons(3)"], ["proof (prove)\nusing this:\n  length lin \\<le> n2\n\ngoal (1 subgoal):\n 1. length us1 + n2 = length (us1 @ lin) + (n2 - length lin)", "by auto"], ["proof (state)\nthis:\n  n = length (us1 @ lin) + (n2 - length lin)\n\ngoal (2 subgoals):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n 2. length divs \\<noteq> n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "proof (rule Cons(1)[OF vs n us _ f])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>d.\n       d \\<in> set nonlin \\<Longrightarrow> monic d \\<and> 0 < degree d\n 2. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 3. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "fix u"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>d.\n       d \\<in> set nonlin \\<Longrightarrow> monic d \\<and> 0 < degree d\n 2. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 3. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "assume \"u \\<in> set nonlin\""], ["proof (state)\nthis:\n  u \\<in> set nonlin\n\ngoal (3 subgoals):\n 1. \\<And>d.\n       d \\<in> set nonlin \\<Longrightarrow> monic d \\<and> 0 < degree d\n 2. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 3. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "with part"], ["proof (chain)\npicking this:\n  List.partition (\\<lambda>q. degree q = d) facts = (lin, nonlin)\n  u \\<in> set nonlin", "have \"u \\<in> set facts\""], ["proof (prove)\nusing this:\n  List.partition (\\<lambda>q. degree q = d) facts = (lin, nonlin)\n  u \\<in> set nonlin\n\ngoal (1 subgoal):\n 1. u \\<in> set facts", "by auto"], ["proof (state)\nthis:\n  u \\<in> set facts\n\ngoal (3 subgoals):\n 1. \\<And>d.\n       d \\<in> set nonlin \\<Longrightarrow> monic d \\<and> 0 < degree d\n 2. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 3. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "from facts[OF this]"], ["proof (chain)\npicking this:\n  0 < degree u\n  monic u\n  \\<exists>u'\\<in>set divs. u dvd u'", "show \"monic u \\<and> degree u > 0\""], ["proof (prove)\nusing this:\n  0 < degree u\n  monic u\n  \\<exists>u'\\<in>set divs. u dvd u'\n\ngoal (1 subgoal):\n 1. monic u \\<and> 0 < degree u", "by auto"], ["proof (state)\nthis:\n  monic u \\<and> 0 < degree u\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 2. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 2. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 2. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "assume u: \"u \\<in> set (us1 @ lin)\""], ["proof (state)\nthis:\n  u \\<in> set (us1 @ lin)\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 2. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "{"], ["proof (state)\nthis:\n  u \\<in> set (us1 @ lin)\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 2. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "assume *: \"\\<not> (monic u \\<and> irreducible\\<^sub>d u)\""], ["proof (state)\nthis:\n  \\<not> (monic u \\<and> irreducible\\<^sub>d u)\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 2. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "with Cons(7) u"], ["proof (chain)\npicking this:\n  ?u \\<in> set us1 \\<Longrightarrow> monic ?u \\<and> irreducible ?u\n  u \\<in> set (us1 @ lin)\n  \\<not> (monic u \\<and> irreducible\\<^sub>d u)", "have \"u \\<in> set lin\""], ["proof (prove)\nusing this:\n  ?u \\<in> set us1 \\<Longrightarrow> monic ?u \\<and> irreducible ?u\n  u \\<in> set (us1 @ lin)\n  \\<not> (monic u \\<and> irreducible\\<^sub>d u)\n\ngoal (1 subgoal):\n 1. u \\<in> set lin", "by auto"], ["proof (state)\nthis:\n  u \\<in> set lin\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 2. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "with part"], ["proof (chain)\npicking this:\n  List.partition (\\<lambda>q. degree q = d) facts = (lin, nonlin)\n  u \\<in> set lin", "have uf: \"u \\<in> set facts\" and deg: \"degree u = d\""], ["proof (prove)\nusing this:\n  List.partition (\\<lambda>q. degree q = d) facts = (lin, nonlin)\n  u \\<in> set lin\n\ngoal (1 subgoal):\n 1. u \\<in> set facts &&& degree u = d", "by auto"], ["proof (state)\nthis:\n  u \\<in> set facts\n  degree u = d\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 2. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "from facts[OF uf]"], ["proof (chain)\npicking this:\n  0 < degree u\n  monic u\n  \\<exists>u'\\<in>set divs. u dvd u'", "obtain u' where \"u' \\<in> set divs\" and uu': \"u dvd u'\""], ["proof (prove)\nusing this:\n  0 < degree u\n  monic u\n  \\<exists>u'\\<in>set divs. u dvd u'\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>u' \\<in> set divs; u dvd u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u' \\<in> set divs\n  u dvd u'\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 2. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "from this(1)"], ["proof (chain)\npicking this:\n  u' \\<in> set divs", "have \"u' dvd f\""], ["proof (prove)\nusing this:\n  u' \\<in> set divs\n\ngoal (1 subgoal):\n 1. u' dvd f", "unfolding Cons(6)"], ["proof (prove)\nusing this:\n  u' \\<in> set divs\n\ngoal (1 subgoal):\n 1. u' dvd prod_list (us1 @ divs)", "using prod_list_dvd[of u']"], ["proof (prove)\nusing this:\n  u' \\<in> set divs\n  u' \\<in> set ?xs \\<Longrightarrow> u' dvd prod_list ?xs\n\ngoal (1 subgoal):\n 1. u' dvd prod_list (us1 @ divs)", "by auto"], ["proof (state)\nthis:\n  u' dvd f\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 2. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "with uu'"], ["proof (chain)\npicking this:\n  u dvd u'\n  u' dvd f", "have \"u dvd f\""], ["proof (prove)\nusing this:\n  u dvd u'\n  u' dvd f\n\ngoal (1 subgoal):\n 1. u dvd f", "by (rule dvd_trans)"], ["proof (state)\nthis:\n  u dvd f\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 2. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "from facts[OF uf] d[OF this deg] *"], ["proof (chain)\npicking this:\n  0 < degree u\n  monic u\n  \\<exists>u'\\<in>set divs. u dvd u'\n  irreducible u\n  \\<not> (monic u \\<and> irreducible\\<^sub>d u)", "have False"], ["proof (prove)\nusing this:\n  0 < degree u\n  monic u\n  \\<exists>u'\\<in>set divs. u dvd u'\n  irreducible u\n  \\<not> (monic u \\<and> irreducible\\<^sub>d u)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 2. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "}"], ["proof (state)\nthis:\n  \\<not> (monic u \\<and> irreducible\\<^sub>d u) \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       u \\<in> set (us1 @ lin) \\<Longrightarrow>\n       monic u \\<and> irreducible u\n 2. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "thus \"monic u \\<and> irreducible u\""], ["proof (prove)\nusing this:\n  \\<not> (monic u \\<and> irreducible\\<^sub>d u) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. monic u \\<and> irreducible u", "by auto"], ["proof (state)\nthis:\n  monic u \\<and> irreducible u\n\ngoal (1 subgoal):\n 1. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "fix w u i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "assume w: \"w \\<in> set (vs1 @ [v])\"\n            and u: \"u \\<in> set (us1 @ lin) \\<union> set nonlin\"\n            and i: \"i < CARD('a)\""], ["proof (state)\nthis:\n  w \\<in> set (vs1 @ [v])\n  u \\<in> set (us1 @ lin) \\<union> set nonlin\n  i < CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "from u part"], ["proof (chain)\npicking this:\n  u \\<in> set (us1 @ lin) \\<union> set nonlin\n  List.partition (\\<lambda>q. degree q = d) facts = (lin, nonlin)", "have u: \"u \\<in> set us1 \\<union> set facts\""], ["proof (prove)\nusing this:\n  u \\<in> set (us1 @ lin) \\<union> set nonlin\n  List.partition (\\<lambda>q. degree q = d) facts = (lin, nonlin)\n\ngoal (1 subgoal):\n 1. u \\<in> set us1 \\<union> set facts", "by auto"], ["proof (state)\nthis:\n  u \\<in> set us1 \\<union> set facts\n\ngoal (1 subgoal):\n 1. \\<And>va u i.\n       \\<lbrakk>va \\<in> set (vs1 @ [v]);\n        u \\<in> set (us1 @ lin) \\<union> set nonlin; i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (va - [:of_nat i:]) \\<in> {1, u}", "show \"gcd u (w - [:of_nat i:]) \\<in> {1, u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd u (w - [:of_nat i:]) \\<in> {1, u}", "proof (cases \"u \\<in> set us1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> set us1 \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}\n 2. u \\<notin> set us1 \\<Longrightarrow>\n    gcd u (w - [:of_nat i:]) \\<in> {1, u}", "case True"], ["proof (state)\nthis:\n  u \\<in> set us1\n\ngoal (2 subgoals):\n 1. u \\<in> set us1 \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}\n 2. u \\<notin> set us1 \\<Longrightarrow>\n    gcd u (w - [:of_nat i:]) \\<in> {1, u}", "from Cons(7)[OF this]"], ["proof (chain)\npicking this:\n  monic u \\<and> irreducible u", "have \"monic u\" \"irreducible u\""], ["proof (prove)\nusing this:\n  monic u \\<and> irreducible u\n\ngoal (1 subgoal):\n 1. monic u &&& irreducible u", "by auto"], ["proof (state)\nthis:\n  monic u\n  irreducible u\n\ngoal (2 subgoals):\n 1. u \\<in> set us1 \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}\n 2. u \\<notin> set us1 \\<Longrightarrow>\n    gcd u (w - [:of_nat i:]) \\<in> {1, u}", "thus ?thesis"], ["proof (prove)\nusing this:\n  monic u\n  irreducible u\n\ngoal (1 subgoal):\n 1. gcd u (w - [:of_nat i:]) \\<in> {1, u}", "by (rule monic_irreducible_gcd)"], ["proof (state)\nthis:\n  gcd u (w - [:of_nat i:]) \\<in> {1, u}\n\ngoal (1 subgoal):\n 1. u \\<notin> set us1 \\<Longrightarrow>\n    gcd u (w - [:of_nat i:]) \\<in> {1, u}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<notin> set us1 \\<Longrightarrow>\n    gcd u (w - [:of_nat i:]) \\<in> {1, u}", "case False"], ["proof (state)\nthis:\n  u \\<notin> set us1\n\ngoal (1 subgoal):\n 1. u \\<notin> set us1 \\<Longrightarrow>\n    gcd u (w - [:of_nat i:]) \\<in> {1, u}", "with u"], ["proof (chain)\npicking this:\n  u \\<in> set us1 \\<union> set facts\n  u \\<notin> set us1", "have u: \"u \\<in> set facts\""], ["proof (prove)\nusing this:\n  u \\<in> set us1 \\<union> set facts\n  u \\<notin> set us1\n\ngoal (1 subgoal):\n 1. u \\<in> set facts", "by auto"], ["proof (state)\nthis:\n  u \\<in> set facts\n\ngoal (1 subgoal):\n 1. u \\<notin> set us1 \\<Longrightarrow>\n    gcd u (w - [:of_nat i:]) \\<in> {1, u}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd u (w - [:of_nat i:]) \\<in> {1, u}", "proof (cases \"w = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}\n 2. w \\<noteq> v \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}", "case True"], ["proof (state)\nthis:\n  w = v\n\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}\n 2. w \\<noteq> v \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}", "from u[unfolded facts']"], ["proof (chain)\npicking this:\n  u \\<in> set (concat (map udivs divs))", "obtain u' where u: \"u \\<in> set (udivs u')\"\n                and u': \"u' \\<in> set divs\""], ["proof (prove)\nusing this:\n  u \\<in> set (concat (map udivs divs))\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>u \\<in> set (udivs u'); u' \\<in> set divs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<in> set (udivs u')\n  u' \\<in> set divs\n\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}\n 2. w \\<noteq> v \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}", "from udivs(3)[OF u' u i]"], ["proof (chain)\npicking this:\n  gcd u (v - [:of_nat i:]) \\<in> {1, u}", "show ?thesis"], ["proof (prove)\nusing this:\n  gcd u (v - [:of_nat i:]) \\<in> {1, u}\n\ngoal (1 subgoal):\n 1. gcd u (w - [:of_nat i:]) \\<in> {1, u}", "unfolding True"], ["proof (prove)\nusing this:\n  gcd u (v - [:of_nat i:]) \\<in> {1, u}\n\ngoal (1 subgoal):\n 1. gcd u (v - [:of_nat i:]) \\<in> {1, u}", "."], ["proof (state)\nthis:\n  gcd u (w - [:of_nat i:]) \\<in> {1, u}\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}", "case False"], ["proof (state)\nthis:\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}", "with w"], ["proof (chain)\npicking this:\n  w \\<in> set (vs1 @ [v])\n  w \\<noteq> v", "have w: \"w \\<in> set vs1\""], ["proof (prove)\nusing this:\n  w \\<in> set (vs1 @ [v])\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. w \\<in> set vs1", "by auto"], ["proof (state)\nthis:\n  w \\<in> set vs1\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}", "from u"], ["proof (chain)\npicking this:\n  u \\<in> set facts", "obtain u' where u': \"u' \\<in> set divs\" and dvd: \"u dvd u'\""], ["proof (prove)\nusing this:\n  u \\<in> set facts\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>u' \\<in> set divs; u dvd u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using facts(3)[of u] dvd_refl[of u]"], ["proof (prove)\nusing this:\n  u \\<in> set facts\n  u \\<in> set facts \\<Longrightarrow> \\<exists>u'\\<in>set divs. u dvd u'\n  u dvd u\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>u' \\<in> set divs; u dvd u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u' \\<in> set divs\n  u dvd u'\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}", "from w"], ["proof (chain)\npicking this:\n  w \\<in> set vs1", "have \"w \\<in> set vs1 \\<or> w = v\""], ["proof (prove)\nusing this:\n  w \\<in> set vs1\n\ngoal (1 subgoal):\n 1. w \\<in> set vs1 \\<or> w = v", "by auto"], ["proof (state)\nthis:\n  w \\<in> set vs1 \\<or> w = v\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}", "from facts(1-2)[OF u]"], ["proof (chain)\npicking this:\n  0 < degree u\n  monic u", "have u: \"monic u\""], ["proof (prove)\nusing this:\n  0 < degree u\n  monic u\n\ngoal (1 subgoal):\n 1. monic u", "by auto"], ["proof (state)\nthis:\n  monic u\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}", "from Cons(8)[OF w _ i] u'"], ["proof (chain)\npicking this:\n  ?u \\<in> set us1 \\<union> set divs \\<Longrightarrow>\n  gcd ?u (w - [:of_nat i:]) \\<in> {1, ?u}\n  u' \\<in> set divs", "have \"gcd u' (w - [:of_nat i:]) \\<in> {1, u'}\""], ["proof (prove)\nusing this:\n  ?u \\<in> set us1 \\<union> set divs \\<Longrightarrow>\n  gcd ?u (w - [:of_nat i:]) \\<in> {1, ?u}\n  u' \\<in> set divs\n\ngoal (1 subgoal):\n 1. gcd u' (w - [:of_nat i:]) \\<in> {1, u'}", "by auto"], ["proof (state)\nthis:\n  gcd u' (w - [:of_nat i:]) \\<in> {1, u'}\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> gcd u (w - [:of_nat i:]) \\<in> {1, u}", "with dvd u"], ["proof (chain)\npicking this:\n  u dvd u'\n  monic u\n  gcd u' (w - [:of_nat i:]) \\<in> {1, u'}", "show ?thesis"], ["proof (prove)\nusing this:\n  u dvd u'\n  monic u\n  gcd u' (w - [:of_nat i:]) \\<in> {1, u'}\n\ngoal (1 subgoal):\n 1. gcd u (w - [:of_nat i:]) \\<in> {1, u}", "by (rule monic_gcd_dvd)"], ["proof (state)\nthis:\n  gcd u (w - [:of_nat i:]) \\<in> {1, u}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcd u (w - [:of_nat i:]) \\<in> {1, u}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcd u (w - [:of_nat i:]) \\<in> {1, u}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = prod_list us \\<and>\n  (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n\ngoal (1 subgoal):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "case True"], ["proof (state)\nthis:\n  length divs = n2\n\ngoal (1 subgoal):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "with res"], ["proof (chain)\npicking this:\n  us =\n  us1 @\n  (if length divs = n2 then divs\n   else lin @ berlekamp_factorization_main d nonlin vs2 (n2 - length lin))\n  length divs = n2", "have us: \"us = us1 @ divs\""], ["proof (prove)\nusing this:\n  us =\n  us1 @\n  (if length divs = n2 then divs\n   else lin @ berlekamp_factorization_main d nonlin vs2 (n2 - length lin))\n  length divs = n2\n\ngoal (1 subgoal):\n 1. us = us1 @ divs", "by auto"], ["proof (state)\nthis:\n  us = us1 @ divs\n\ngoal (1 subgoal):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from Cons(3) True"], ["proof (chain)\npicking this:\n  n = length us1 + n2\n  length divs = n2", "have n: \"n = length us\""], ["proof (prove)\nusing this:\n  n = length us1 + n2\n  length divs = n2\n\ngoal (1 subgoal):\n 1. n = length us", "unfolding us"], ["proof (prove)\nusing this:\n  n = length us1 + n2\n  length divs = n2\n\ngoal (1 subgoal):\n 1. n = length (us1 @ divs)", "by auto"], ["proof (state)\nthis:\n  n = length us\n\ngoal (1 subgoal):\n 1. length divs = n2 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "unfolding us[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "proof (intro conjI ballI)"], ["proof (state)\ngoal (3 subgoals):\n 1. f = prod_list us\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u\n 3. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "show f: \"f = prod_list us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list us", "unfolding us"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list (us1 @ divs)", "using Cons(6)"], ["proof (prove)\nusing this:\n  f = prod_list (us1 @ divs)\n\ngoal (1 subgoal):\n 1. f = prod_list (us1 @ divs)", "by simp"], ["proof (state)\nthis:\n  f = prod_list us\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "{"], ["proof (state)\nthis:\n  f = prod_list us\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "assume \"u \\<in> set us\""], ["proof (state)\nthis:\n  u \\<in> set us\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "hence \"degree u > 0\""], ["proof (prove)\nusing this:\n  u \\<in> set us\n\ngoal (1 subgoal):\n 1. 0 < degree u", "using Cons(5) Cons(7)[unfolded irreducible\\<^sub>d_def]"], ["proof (prove)\nusing this:\n  u \\<in> set us\n  ?d \\<in> set divs \\<Longrightarrow> monic ?d \\<and> 0 < degree ?d\n  ?u \\<in> set us1 \\<Longrightarrow> monic ?u \\<and> irreducible ?u\n\ngoal (1 subgoal):\n 1. 0 < degree u", "unfolding us"], ["proof (prove)\nusing this:\n  u \\<in> set (us1 @ divs)\n  ?d \\<in> set divs \\<Longrightarrow> monic ?d \\<and> 0 < degree ?d\n  ?u \\<in> set us1 \\<Longrightarrow> monic ?u \\<and> irreducible ?u\n\ngoal (1 subgoal):\n 1. 0 < degree u", "by (auto simp: irreducible_degree_field)"], ["proof (state)\nthis:\n  0 < degree u\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "}"], ["proof (state)\nthis:\n  ?u2 \\<in> set us \\<Longrightarrow> 0 < degree ?u2\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "note deg = this"], ["proof (state)\nthis:\n  ?u2 \\<in> set us \\<Longrightarrow> 0 < degree ?u2\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "assume u: \"u \\<in> set us\""], ["proof (state)\nthis:\n  u \\<in> set us\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "thus \"monic u\""], ["proof (prove)\nusing this:\n  u \\<in> set us\n\ngoal (1 subgoal):\n 1. monic u", "unfolding us"], ["proof (prove)\nusing this:\n  u \\<in> set (us1 @ divs)\n\ngoal (1 subgoal):\n 1. monic u", "using Cons(5) Cons(7)"], ["proof (prove)\nusing this:\n  u \\<in> set (us1 @ divs)\n  ?d \\<in> set divs \\<Longrightarrow> monic ?d \\<and> 0 < degree ?d\n  ?u \\<in> set us1 \\<Longrightarrow> monic ?u \\<and> irreducible ?u\n\ngoal (1 subgoal):\n 1. monic u", "by auto"], ["proof (state)\nthis:\n  monic u\n\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "show \"irreducible u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible u", "by (rule berlekamp_basis_irreducible[OF sf_f n_bb mon_f f n[symmetric] deg u])"], ["proof (state)\nthis:\n  irreducible u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = prod_list us \\<and>\n  (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = prod_list us \\<and>\n  (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n\ngoal (1 subgoal):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "case True"], ["proof (state)\nthis:\n  v = 1\n\ngoal (1 subgoal):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "(* v = 1 *)"], ["proof (state)\nthis:\n  v = 1\n\ngoal (1 subgoal):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "with Cons(4)"], ["proof (chain)\npicking this:\n  us = us1 @ berlekamp_factorization_main d divs (v # vs2) n2\n  v = 1", "have us: \"us = us1 @ berlekamp_factorization_main d divs vs2 n2\""], ["proof (prove)\nusing this:\n  us = us1 @ berlekamp_factorization_main d divs (v # vs2) n2\n  v = 1\n\ngoal (1 subgoal):\n 1. us = us1 @ berlekamp_factorization_main d divs vs2 n2", "by simp"], ["proof (state)\nthis:\n  us = us1 @ berlekamp_factorization_main d divs vs2 n2\n\ngoal (1 subgoal):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from Cons(2) True"], ["proof (chain)\npicking this:\n  vs = vs1 @ v # vs2\n  v = 1", "have vs: \"vs = (vs1 @ [1]) @ vs2\""], ["proof (prove)\nusing this:\n  vs = vs1 @ v # vs2\n  v = 1\n\ngoal (1 subgoal):\n 1. vs = (vs1 @ [1]) @ vs2", "by auto"], ["proof (state)\nthis:\n  vs = (vs1 @ [1]) @ vs2\n\ngoal (1 subgoal):\n 1. v = 1 \\<Longrightarrow>\n    f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "proof (rule Cons(1)[OF vs Cons(3) us Cons(5-7)], goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>d. d \\<in> set divs \\<Longrightarrow> d \\<in> set divs\n 2. \\<And>u. u \\<in> set us1 \\<Longrightarrow> u \\<in> set us1\n 3. \\<And>v u i.\n       \\<lbrakk>v \\<in> set (vs1 @ [1]); u \\<in> set us1 \\<union> set divs;\n        i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}", "case (3 v u i)"], ["proof (state)\nthis:\n  v \\<in> set (vs1 @ [1])\n  u \\<in> set us1 \\<union> set divs\n  i < CARD('a)\n\ngoal (3 subgoals):\n 1. \\<And>d. d \\<in> set divs \\<Longrightarrow> d \\<in> set divs\n 2. \\<And>u. u \\<in> set us1 \\<Longrightarrow> u \\<in> set us1\n 3. \\<And>v u i.\n       \\<lbrakk>v \\<in> set (vs1 @ [1]); u \\<in> set us1 \\<union> set divs;\n        i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd u (v - [:of_nat i:]) \\<in> {1, u}", "proof (cases \"v = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\n 2. v \\<noteq> 1 \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}", "case False"], ["proof (state)\nthis:\n  v \\<noteq> 1\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\n 2. v \\<noteq> 1 \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}", "with 3 Cons(8)[of v u i]"], ["proof (chain)\npicking this:\n  v \\<in> set (vs1 @ [1])\n  u \\<in> set us1 \\<union> set divs\n  i < CARD('a)\n  \\<lbrakk>v \\<in> set vs1; u \\<in> set us1 \\<union> set divs;\n   i < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\n  v \\<noteq> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> set (vs1 @ [1])\n  u \\<in> set us1 \\<union> set divs\n  i < CARD('a)\n  \\<lbrakk>v \\<in> set vs1; u \\<in> set us1 \\<union> set divs;\n   i < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\n  v \\<noteq> 1\n\ngoal (1 subgoal):\n 1. gcd u (v - [:of_nat i:]) \\<in> {1, u}", "by auto"], ["proof (state)\nthis:\n  gcd u (v - [:of_nat i:]) \\<in> {1, u}\n\ngoal (1 subgoal):\n 1. v = 1 \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v = 1 \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}", "case True"], ["proof (state)\nthis:\n  v = 1\n\ngoal (1 subgoal):\n 1. v = 1 \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}", "hence deg: \"degree (v - [: of_nat i :]) = 0\""], ["proof (prove)\nusing this:\n  v = 1\n\ngoal (1 subgoal):\n 1. degree (v - [:of_nat i:]) = 0", "by (metis (no_types, hide_lams) degree_pCons_0 diff_pCons diff_zero pCons_one)"], ["proof (state)\nthis:\n  degree (v - [:of_nat i:]) = 0\n\ngoal (1 subgoal):\n 1. v = 1 \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}", "from 3(2) Cons(5,7)[of u]"], ["proof (chain)\npicking this:\n  u \\<in> set us1 \\<union> set divs\n  u \\<in> set divs \\<Longrightarrow> monic u \\<and> 0 < degree u\n  u \\<in> set us1 \\<Longrightarrow> monic u \\<and> irreducible u", "have \"monic u\""], ["proof (prove)\nusing this:\n  u \\<in> set us1 \\<union> set divs\n  u \\<in> set divs \\<Longrightarrow> monic u \\<and> 0 < degree u\n  u \\<in> set us1 \\<Longrightarrow> monic u \\<and> irreducible u\n\ngoal (1 subgoal):\n 1. monic u", "by auto"], ["proof (state)\nthis:\n  monic u\n\ngoal (1 subgoal):\n 1. v = 1 \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}", "from gcd_monic_constant[OF this deg]"], ["proof (chain)\npicking this:\n  gcd u (v - [:of_nat i:]) \\<in> {1, u}", "show ?thesis"], ["proof (prove)\nusing this:\n  gcd u (v - [:of_nat i:]) \\<in> {1, u}\n\ngoal (1 subgoal):\n 1. gcd u (v - [:of_nat i:]) \\<in> {1, u}", "."], ["proof (state)\nthis:\n  gcd u (v - [:of_nat i:]) \\<in> {1, u}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcd u (v - [:of_nat i:]) \\<in> {1, u}\n\ngoal (2 subgoals):\n 1. \\<And>d. d \\<in> set divs \\<Longrightarrow> d \\<in> set divs\n 2. \\<And>u. u \\<in> set us1 \\<Longrightarrow> u \\<in> set us1", "qed"], ["proof (state)\nthis:\n  f = prod_list us \\<and>\n  (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = prod_list us \\<and>\n  (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n\ngoal (1 subgoal):\n 1. \\<And>divs n2 us1 vs1.\n       \\<lbrakk>vs = vs1 @ []; n = length us1 + n2;\n        us = us1 @ berlekamp_factorization_main d divs [] n2;\n        \\<And>d.\n           d \\<in> set divs \\<Longrightarrow> monic d \\<and> 0 < degree d;\n        f = prod_list (us1 @ divs);\n        \\<And>u.\n           u \\<in> set us1 \\<Longrightarrow> monic u \\<and> irreducible u;\n        \\<And>v u i.\n           \\<lbrakk>v \\<in> set vs1; u \\<in> set us1 \\<union> set divs;\n            i < CARD('a)\\<rbrakk>\n           \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\\<rbrakk>\n       \\<Longrightarrow> f = prod_list us \\<and>\n                         (\\<forall>u\\<in>set us.\n                             monic u \\<and> irreducible u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>divs n2 us1 vs1.\n       \\<lbrakk>vs = vs1 @ []; n = length us1 + n2;\n        us = us1 @ berlekamp_factorization_main d divs [] n2;\n        \\<And>d.\n           d \\<in> set divs \\<Longrightarrow> monic d \\<and> 0 < degree d;\n        f = prod_list (us1 @ divs);\n        \\<And>u.\n           u \\<in> set us1 \\<Longrightarrow> monic u \\<and> irreducible u;\n        \\<And>v u i.\n           \\<lbrakk>v \\<in> set vs1; u \\<in> set us1 \\<union> set divs;\n            i < CARD('a)\\<rbrakk>\n           \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\\<rbrakk>\n       \\<Longrightarrow> f = prod_list us \\<and>\n                         (\\<forall>u\\<in>set us.\n                             monic u \\<and> irreducible u)", "case Nil"], ["proof (state)\nthis:\n  vs = vs1 @ []\n  n = length us1 + n2\n  us = us1 @ berlekamp_factorization_main d divs [] n2\n  ?d \\<in> set divs \\<Longrightarrow> monic ?d \\<and> 0 < degree ?d\n  f = prod_list (us1 @ divs)\n  ?u \\<in> set us1 \\<Longrightarrow> monic ?u \\<and> irreducible ?u\n  \\<lbrakk>?v \\<in> set vs1; ?u \\<in> set us1 \\<union> set divs;\n   ?i < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> gcd ?u (?v - [:of_nat ?i:]) \\<in> {1, ?u}\n\ngoal (1 subgoal):\n 1. \\<And>divs n2 us1 vs1.\n       \\<lbrakk>vs = vs1 @ []; n = length us1 + n2;\n        us = us1 @ berlekamp_factorization_main d divs [] n2;\n        \\<And>d.\n           d \\<in> set divs \\<Longrightarrow> monic d \\<and> 0 < degree d;\n        f = prod_list (us1 @ divs);\n        \\<And>u.\n           u \\<in> set us1 \\<Longrightarrow> monic u \\<and> irreducible u;\n        \\<And>v u i.\n           \\<lbrakk>v \\<in> set vs1; u \\<in> set us1 \\<union> set divs;\n            i < CARD('a)\\<rbrakk>\n           \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\\<rbrakk>\n       \\<Longrightarrow> f = prod_list us \\<and>\n                         (\\<forall>u\\<in>set us.\n                             monic u \\<and> irreducible u)", "with vsf"], ["proof (chain)\npicking this:\n  vs = berlekamp_basis f\n  vs = vs1 @ []\n  n = length us1 + n2\n  us = us1 @ berlekamp_factorization_main d divs [] n2\n  ?d \\<in> set divs \\<Longrightarrow> monic ?d \\<and> 0 < degree ?d\n  f = prod_list (us1 @ divs)\n  ?u \\<in> set us1 \\<Longrightarrow> monic ?u \\<and> irreducible ?u\n  \\<lbrakk>?v \\<in> set vs1; ?u \\<in> set us1 \\<union> set divs;\n   ?i < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> gcd ?u (?v - [:of_nat ?i:]) \\<in> {1, ?u}", "have vs1: \"vs1 = berlekamp_basis f\""], ["proof (prove)\nusing this:\n  vs = berlekamp_basis f\n  vs = vs1 @ []\n  n = length us1 + n2\n  us = us1 @ berlekamp_factorization_main d divs [] n2\n  ?d \\<in> set divs \\<Longrightarrow> monic ?d \\<and> 0 < degree ?d\n  f = prod_list (us1 @ divs)\n  ?u \\<in> set us1 \\<Longrightarrow> monic ?u \\<and> irreducible ?u\n  \\<lbrakk>?v \\<in> set vs1; ?u \\<in> set us1 \\<union> set divs;\n   ?i < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> gcd ?u (?v - [:of_nat ?i:]) \\<in> {1, ?u}\n\ngoal (1 subgoal):\n 1. vs1 = berlekamp_basis f", "by auto"], ["proof (state)\nthis:\n  vs1 = berlekamp_basis f\n\ngoal (1 subgoal):\n 1. \\<And>divs n2 us1 vs1.\n       \\<lbrakk>vs = vs1 @ []; n = length us1 + n2;\n        us = us1 @ berlekamp_factorization_main d divs [] n2;\n        \\<And>d.\n           d \\<in> set divs \\<Longrightarrow> monic d \\<and> 0 < degree d;\n        f = prod_list (us1 @ divs);\n        \\<And>u.\n           u \\<in> set us1 \\<Longrightarrow> monic u \\<and> irreducible u;\n        \\<And>v u i.\n           \\<lbrakk>v \\<in> set vs1; u \\<in> set us1 \\<union> set divs;\n            i < CARD('a)\\<rbrakk>\n           \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\\<rbrakk>\n       \\<Longrightarrow> f = prod_list us \\<and>\n                         (\\<forall>u\\<in>set us.\n                             monic u \\<and> irreducible u)", "from Nil(3)"], ["proof (chain)\npicking this:\n  us = us1 @ berlekamp_factorization_main d divs [] n2", "have us: \"us = us1 @ divs\""], ["proof (prove)\nusing this:\n  us = us1 @ berlekamp_factorization_main d divs [] n2\n\ngoal (1 subgoal):\n 1. us = us1 @ divs", "by auto"], ["proof (state)\nthis:\n  us = us1 @ divs\n\ngoal (1 subgoal):\n 1. \\<And>divs n2 us1 vs1.\n       \\<lbrakk>vs = vs1 @ []; n = length us1 + n2;\n        us = us1 @ berlekamp_factorization_main d divs [] n2;\n        \\<And>d.\n           d \\<in> set divs \\<Longrightarrow> monic d \\<and> 0 < degree d;\n        f = prod_list (us1 @ divs);\n        \\<And>u.\n           u \\<in> set us1 \\<Longrightarrow> monic u \\<and> irreducible u;\n        \\<And>v u i.\n           \\<lbrakk>v \\<in> set vs1; u \\<in> set us1 \\<union> set divs;\n            i < CARD('a)\\<rbrakk>\n           \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\\<rbrakk>\n       \\<Longrightarrow> f = prod_list us \\<and>\n                         (\\<forall>u\\<in>set us.\n                             monic u \\<and> irreducible u)", "from Nil(4,6)"], ["proof (chain)\npicking this:\n  ?d \\<in> set divs \\<Longrightarrow> monic ?d \\<and> 0 < degree ?d\n  ?u \\<in> set us1 \\<Longrightarrow> monic ?u \\<and> irreducible ?u", "have md: \"\\<And> u. u \\<in> set us \\<Longrightarrow> monic u \\<and> degree u > 0\""], ["proof (prove)\nusing this:\n  ?d \\<in> set divs \\<Longrightarrow> monic ?d \\<and> 0 < degree ?d\n  ?u \\<in> set us1 \\<Longrightarrow> monic ?u \\<and> irreducible ?u\n\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u \\<and> 0 < degree u", "unfolding us"], ["proof (prove)\nusing this:\n  ?d \\<in> set divs \\<Longrightarrow> monic ?d \\<and> 0 < degree ?d\n  ?u \\<in> set us1 \\<Longrightarrow> monic ?u \\<and> irreducible ?u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> set (us1 @ divs) \\<Longrightarrow>\n       monic u \\<and> 0 < degree u", "by (auto simp: irreducible_degree_field)"], ["proof (state)\nthis:\n  ?u \\<in> set us \\<Longrightarrow> monic ?u \\<and> 0 < degree ?u\n\ngoal (1 subgoal):\n 1. \\<And>divs n2 us1 vs1.\n       \\<lbrakk>vs = vs1 @ []; n = length us1 + n2;\n        us = us1 @ berlekamp_factorization_main d divs [] n2;\n        \\<And>d.\n           d \\<in> set divs \\<Longrightarrow> monic d \\<and> 0 < degree d;\n        f = prod_list (us1 @ divs);\n        \\<And>u.\n           u \\<in> set us1 \\<Longrightarrow> monic u \\<and> irreducible u;\n        \\<And>v u i.\n           \\<lbrakk>v \\<in> set vs1; u \\<in> set us1 \\<union> set divs;\n            i < CARD('a)\\<rbrakk>\n           \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\\<rbrakk>\n       \\<Longrightarrow> f = prod_list us \\<and>\n                         (\\<forall>u\\<in>set us.\n                             monic u \\<and> irreducible u)", "from Nil(7)[unfolded vs1] us"], ["proof (chain)\npicking this:\n  \\<lbrakk>?v \\<in> set (berlekamp_basis f);\n   ?u \\<in> set us1 \\<union> set divs; ?i < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> gcd ?u (?v - [:of_nat ?i:]) \\<in> {1, ?u}\n  us = us1 @ divs", "have no_further_splitting_possible:\n      \"\\<And> u v i. v \\<in> set (berlekamp_basis f) \\<Longrightarrow> u \\<in> set us\n      \\<Longrightarrow> i < CARD('a) \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> set (berlekamp_basis f);\n   ?u \\<in> set us1 \\<union> set divs; ?i < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> gcd ?u (?v - [:of_nat ?i:]) \\<in> {1, ?u}\n  us = us1 @ divs\n\ngoal (1 subgoal):\n 1. \\<And>u v i.\n       \\<lbrakk>v \\<in> set (berlekamp_basis f); u \\<in> set us;\n        i < CARD('a)\\<rbrakk>\n       \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?v \\<in> set (berlekamp_basis f); ?u \\<in> set us;\n   ?i < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> gcd ?u (?v - [:of_nat ?i:]) \\<in> {1, ?u}\n\ngoal (1 subgoal):\n 1. \\<And>divs n2 us1 vs1.\n       \\<lbrakk>vs = vs1 @ []; n = length us1 + n2;\n        us = us1 @ berlekamp_factorization_main d divs [] n2;\n        \\<And>d.\n           d \\<in> set divs \\<Longrightarrow> monic d \\<and> 0 < degree d;\n        f = prod_list (us1 @ divs);\n        \\<And>u.\n           u \\<in> set us1 \\<Longrightarrow> monic u \\<and> irreducible u;\n        \\<And>v u i.\n           \\<lbrakk>v \\<in> set vs1; u \\<in> set us1 \\<union> set divs;\n            i < CARD('a)\\<rbrakk>\n           \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\\<rbrakk>\n       \\<Longrightarrow> f = prod_list us \\<and>\n                         (\\<forall>u\\<in>set us.\n                             monic u \\<and> irreducible u)", "from Nil(5) us"], ["proof (chain)\npicking this:\n  f = prod_list (us1 @ divs)\n  us = us1 @ divs", "have prod: \"f = prod_list us\""], ["proof (prove)\nusing this:\n  f = prod_list (us1 @ divs)\n  us = us1 @ divs\n\ngoal (1 subgoal):\n 1. f = prod_list us", "by simp"], ["proof (state)\nthis:\n  f = prod_list us\n\ngoal (1 subgoal):\n 1. \\<And>divs n2 us1 vs1.\n       \\<lbrakk>vs = vs1 @ []; n = length us1 + n2;\n        us = us1 @ berlekamp_factorization_main d divs [] n2;\n        \\<And>d.\n           d \\<in> set divs \\<Longrightarrow> monic d \\<and> 0 < degree d;\n        f = prod_list (us1 @ divs);\n        \\<And>u.\n           u \\<in> set us1 \\<Longrightarrow> monic u \\<and> irreducible u;\n        \\<And>v u i.\n           \\<lbrakk>v \\<in> set vs1; u \\<in> set us1 \\<union> set divs;\n            i < CARD('a)\\<rbrakk>\n           \\<Longrightarrow> gcd u (v - [:of_nat i:]) \\<in> {1, u}\\<rbrakk>\n       \\<Longrightarrow> f = prod_list us \\<and>\n                         (\\<forall>u\\<in>set us.\n                             monic u \\<and> irreducible u)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "proof (intro conjI ballI)"], ["proof (state)\ngoal (3 subgoals):\n 1. f = prod_list us\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u\n 3. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "fix u"], ["proof (state)\ngoal (3 subgoals):\n 1. f = prod_list us\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u\n 3. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "assume u: \"u \\<in> set us\""], ["proof (state)\nthis:\n  u \\<in> set us\n\ngoal (3 subgoals):\n 1. f = prod_list us\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u\n 3. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "from md[OF this]"], ["proof (chain)\npicking this:\n  monic u \\<and> 0 < degree u", "have mon_u: \"monic u\" and deg_u: \"degree u > 0\""], ["proof (prove)\nusing this:\n  monic u \\<and> 0 < degree u\n\ngoal (1 subgoal):\n 1. monic u &&& 0 < degree u", "by auto"], ["proof (state)\nthis:\n  monic u\n  0 < degree u\n\ngoal (3 subgoals):\n 1. f = prod_list us\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u\n 3. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "from prod u"], ["proof (chain)\npicking this:\n  f = prod_list us\n  u \\<in> set us", "have uf: \"u dvd f\""], ["proof (prove)\nusing this:\n  f = prod_list us\n  u \\<in> set us\n\ngoal (1 subgoal):\n 1. u dvd f", "by (simp add: prod_list_dvd)"], ["proof (state)\nthis:\n  u dvd f\n\ngoal (3 subgoals):\n 1. f = prod_list us\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u\n 3. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "from monic_square_free_irreducible_factorization[OF mon_f sf_f]"], ["proof (chain)\npicking this:\n  \\<exists>P.\n     finite P \\<and>\n     f = \\<Prod>P \\<and> P \\<subseteq> {q. irreducible q \\<and> monic q}", "obtain P where\n        P: \"finite P\" \"f = \\<Prod>P\" \"P \\<subseteq> {q. irreducible q \\<and> monic q}\""], ["proof (prove)\nusing this:\n  \\<exists>P.\n     finite P \\<and>\n     f = \\<Prod>P \\<and> P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>finite P; f = \\<Prod>P;\n         P \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite P\n  f = \\<Prod>P\n  P \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (3 subgoals):\n 1. f = prod_list us\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u\n 3. \\<And>u. u \\<in> set us \\<Longrightarrow> irreducible u", "show \"irreducible u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible u", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> irreducible u \\<Longrightarrow> False", "assume irr_u: \"\\<not> irreducible u\""], ["proof (state)\nthis:\n  \\<not> irreducible u\n\ngoal (1 subgoal):\n 1. \\<not> irreducible u \\<Longrightarrow> False", "from not_irreducible_factor_yields_prime_factors[OF uf P deg_u this]"], ["proof (chain)\npicking this:\n  \\<exists>pi pj.\n     pi \\<in> P \\<and>\n     pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u", "obtain pi pj where pij: \"pi \\<in> P\" \"pj \\<in> P\" \"pi \\<noteq> pj\" \"pi dvd u\" \"pj dvd u\""], ["proof (prove)\nusing this:\n  \\<exists>pi pj.\n     pi \\<in> P \\<and>\n     pj \\<in> P \\<and> pi \\<noteq> pj \\<and> pi dvd u \\<and> pj dvd u\n\ngoal (1 subgoal):\n 1. (\\<And>pi pj.\n        \\<lbrakk>pi \\<in> P; pj \\<in> P; pi \\<noteq> pj; pi dvd u;\n         pj dvd u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pi \\<in> P\n  pj \\<in> P\n  pi \\<noteq> pj\n  pi dvd u\n  pj dvd u\n\ngoal (1 subgoal):\n 1. \\<not> irreducible u \\<Longrightarrow> False", "from exists_vector_in_Berlekamp_basis_dvd[OF\n          deg_f berlekamp_basis_basis[OF deg_f, folded vs1] finite_set\n          P pij(1-3) mon_f sf_f irr_u uf mon_u pij(4-5), unfolded vs1]"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>set (berlekamp_basis f).\n     v mod pi \\<noteq> v mod pj \\<and>\n     degree (v mod pi) = 0 \\<and>\n     degree (v mod pj) = 0 \\<and>\n     (\\<exists>s.\n         gcd u (v - [:s:]) \\<noteq> u \\<and>\n         \\<not> comm_monoid_mult_class.coprime u (v - [:s:]))", "obtain v s where v: \"v \\<in> set (berlekamp_basis f)\" \n          and gcd: \"gcd u (v - [:s:]) \\<notin> {1,u}\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>set (berlekamp_basis f).\n     v mod pi \\<noteq> v mod pj \\<and>\n     degree (v mod pi) = 0 \\<and>\n     degree (v mod pj) = 0 \\<and>\n     (\\<exists>s.\n         gcd u (v - [:s:]) \\<noteq> u \\<and>\n         \\<not> comm_monoid_mult_class.coprime u (v - [:s:]))\n\ngoal (1 subgoal):\n 1. (\\<And>v s.\n        \\<lbrakk>v \\<in> set (berlekamp_basis f);\n         gcd u (v - [:s:]) \\<notin> {1, u}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using is_unit_gcd"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>set (berlekamp_basis f).\n     v mod pi \\<noteq> v mod pj \\<and>\n     degree (v mod pi) = 0 \\<and>\n     degree (v mod pj) = 0 \\<and>\n     (\\<exists>s.\n         gcd u (v - [:s:]) \\<noteq> u \\<and>\n         \\<not> comm_monoid_mult_class.coprime u (v - [:s:]))\n  is_unit (gcd ?a ?b) = algebraic_semidom_class.coprime ?a ?b\n\ngoal (1 subgoal):\n 1. (\\<And>v s.\n        \\<lbrakk>v \\<in> set (berlekamp_basis f);\n         gcd u (v - [:s:]) \\<notin> {1, u}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> set (berlekamp_basis f)\n  gcd u (v - [:s:]) \\<notin> {1, u}\n\ngoal (1 subgoal):\n 1. \\<not> irreducible u \\<Longrightarrow> False", "from surj_of_nat_mod_ring[of s]"], ["proof (chain)\npicking this:\n  \\<exists>i<CARD('a). s = of_nat i", "obtain i where i: \"i < CARD('a)\" and s: \"s = of_nat i\""], ["proof (prove)\nusing this:\n  \\<exists>i<CARD('a). s = of_nat i\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < CARD('a); s = of_nat i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < CARD('a)\n  s = of_nat i\n\ngoal (1 subgoal):\n 1. \\<not> irreducible u \\<Longrightarrow> False", "from no_further_splitting_possible[OF v u i] gcd[unfolded s]"], ["proof (chain)\npicking this:\n  gcd u (v - [:of_nat i:]) \\<in> {1, u}\n  gcd u (v - [:of_nat i:]) \\<notin> {1, u}", "show False"], ["proof (prove)\nusing this:\n  gcd u (v - [:of_nat i:]) \\<in> {1, u}\n  gcd u (v - [:of_nat i:]) \\<notin> {1, u}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  irreducible u\n\ngoal (2 subgoals):\n 1. f = prod_list us\n 2. \\<And>u. u \\<in> set us \\<Longrightarrow> monic u", "qed (insert prod md, auto)"], ["proof (state)\nthis:\n  f = prod_list us \\<and>\n  (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = prod_list us \\<and>\n  (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma berlekamp_monic_factorization:\n  fixes f::\"'a mod_ring poly\"\n  assumes sf_f: \"square_free f\"\n    and us: \"berlekamp_monic_factorization d f = us\"\n    and d: \"\\<And> g. g dvd f \\<Longrightarrow> degree g = d \\<Longrightarrow> irreducible g\" \n    and deg: \"degree f > 0\" \n    and mon: \"monic f\" \n  shows \"f = prod_list us \\<and> (\\<forall> u \\<in> set us. monic u \\<and> irreducible u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "from us[unfolded berlekamp_monic_factorization_def Let_def] deg"], ["proof (chain)\npicking this:\n  berlekamp_factorization_main d [f] (berlekamp_basis f)\n   (length (berlekamp_basis f)) =\n  us\n  0 < degree f", "have us: \"us = [] @ berlekamp_factorization_main d [f] (berlekamp_basis f) (length (berlekamp_basis f))\""], ["proof (prove)\nusing this:\n  berlekamp_factorization_main d [f] (berlekamp_basis f)\n   (length (berlekamp_basis f)) =\n  us\n  0 < degree f\n\ngoal (1 subgoal):\n 1. us =\n    [] @\n    berlekamp_factorization_main d [f] (berlekamp_basis f)\n     (length (berlekamp_basis f))", "by (auto)"], ["proof (state)\nthis:\n  us =\n  [] @\n  berlekamp_factorization_main d [f] (berlekamp_basis f)\n   (length (berlekamp_basis f))\n\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "have id: \"berlekamp_basis f = [] @ berlekamp_basis f\"\n    \"length (berlekamp_basis f) = length [] + length (berlekamp_basis f)\"\n    \"f = prod_list ([] @ [f])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. berlekamp_basis f = [] @ berlekamp_basis f &&&\n    length (berlekamp_basis f) = length [] + length (berlekamp_basis f) &&&\n    f = prod_list ([] @ [f])", "by auto"], ["proof (state)\nthis:\n  berlekamp_basis f = [] @ berlekamp_basis f\n  length (berlekamp_basis f) = length [] + length (berlekamp_basis f)\n  f = prod_list ([] @ [f])\n\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "show \"f = prod_list us \\<and> (\\<forall> u \\<in> set us. monic u \\<and> irreducible u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list us \\<and>\n    (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)", "by (rule berlekamp_factorization_main[OF sf_f id(1) refl refl id(2) us _ _ _ id(3)],\n    insert mon deg d, auto)"], ["proof (state)\nthis:\n  f = prod_list us \\<and>\n  (\\<forall>u\\<in>set us. monic u \\<and> irreducible u)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}