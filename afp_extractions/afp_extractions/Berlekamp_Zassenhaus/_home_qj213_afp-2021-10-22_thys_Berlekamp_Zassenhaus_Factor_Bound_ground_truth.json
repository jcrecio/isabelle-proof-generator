{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Factor_Bound.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma binomial_mono_left: \"n \\<le> N \\<Longrightarrow> n choose k \\<le> N choose k\"", "lemma choose_int_suc[simp]:\n  \"choose_int (Suc n) i = choose_int n (i-1) + choose_int n i\"", "lemma sum_le_1_prod: assumes d: \"1 \\<le> d\" and c: \"1 \\<le> c\"\n  shows \"c + d \\<le> 1 + c * (d :: real)\"", "lemma mignotte_helper_coeff_int: \"cmod (coeff_int (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) i)\n    \\<le> choose_int (length lst - 1) i * (\\<Prod>a\\<leftarrow>lst. (max 1 (cmod a))) \n    + choose_int (length lst - 1) (i - 1)\"", "lemma mignotte_helper_coeff_int': \"cmod (coeff_int (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) i)\n    \\<le> ((length lst - 1) choose i) * (\\<Prod>a\\<leftarrow>lst. (max 1 (cmod a))) \n    + min i 1 * ((length lst - 1) choose (nat (i - 1)))\"", "lemma mignotte_helper_coeff: \n  \"cmod (coeff h i) \\<le> (degree h - 1 choose i) * mahler_measure_poly h \n      + min i 1 * (degree h - 1 choose (i - 1)) * cmod (lead_coeff h)\"", "lemma mignotte_coeff_helper:\n  \"abs (coeff h i) \\<le> \n   (degree h - 1 choose i) * mahler_measure h +\n   (min i 1 * (degree h - 1 choose (i - 1)) * abs (lead_coeff h))\"", "lemma cmod_through_lead_coeff[simp]:\n  \"cmod (lead_coeff (of_int_poly h)) = abs (lead_coeff h)\"", "lemma choose_approx: \"n \\<le> N \\<Longrightarrow> n choose k \\<le> N choose (N div 2)\"", "lemma mignotte_bound_main:  \n  assumes \"f \\<noteq> 0\" \"g dvd f\" \"degree g \\<le> n\"\n  shows \"\\<bar>coeff g k\\<bar> \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n       int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>\"", "lemma Mignotte_bound: \n  shows \"of_int \\<bar>coeff g k\\<bar> \\<le> (degree g choose k) * mahler_measure g\"", "lemma mignotte_bound:  \n  assumes \"f \\<noteq> 0\" \"g dvd f\" \"degree g \\<le> n\"\n  shows \"\\<bar>coeff g k\\<bar> \\<le> mignotte_bound f n\"", "lemma factor_bound: assumes \"f \\<noteq> 0\" \"g dvd f\" \"degree g \\<le> n\"\n  shows \"\\<bar>coeff g k\\<bar> \\<le> factor_bound f n\"", "lemma factor_bound_ge_0: \"f \\<noteq> 0 \\<Longrightarrow> factor_bound f n \\<ge> 0\"", "lemma factor_bound_smult: assumes f: \"f \\<noteq> 0\" and d: \"d \\<noteq> 0\" \n  and dvd: \"g dvd smult d f\" and deg: \"degree g \\<le> n\" \n  shows \"\\<bar>coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n\""], "translations": [["", "lemma binomial_mono_left: \"n \\<le> N \\<Longrightarrow> n choose k \\<le> N choose k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> N \\<Longrightarrow> n choose k \\<le> N choose k", "proof (induct n arbitrary: k N)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k N. 0 \\<le> N \\<Longrightarrow> 0 choose k \\<le> N choose k\n 2. \\<And>n k N.\n       \\<lbrakk>\\<And>k N.\n                   n \\<le> N \\<Longrightarrow> n choose k \\<le> N choose k;\n        Suc n \\<le> N\\<rbrakk>\n       \\<Longrightarrow> Suc n choose k \\<le> N choose k", "case (0 k N)"], ["proof (state)\nthis:\n  0 \\<le> N\n\ngoal (2 subgoals):\n 1. \\<And>k N. 0 \\<le> N \\<Longrightarrow> 0 choose k \\<le> N choose k\n 2. \\<And>n k N.\n       \\<lbrakk>\\<And>k N.\n                   n \\<le> N \\<Longrightarrow> n choose k \\<le> N choose k;\n        Suc n \\<le> N\\<rbrakk>\n       \\<Longrightarrow> Suc n choose k \\<le> N choose k", "thus ?case"], ["proof (prove)\nusing this:\n  0 \\<le> N\n\ngoal (1 subgoal):\n 1. 0 choose k \\<le> N choose k", "by (cases k, auto)"], ["proof (state)\nthis:\n  0 choose k \\<le> N choose k\n\ngoal (1 subgoal):\n 1. \\<And>n k N.\n       \\<lbrakk>\\<And>k N.\n                   n \\<le> N \\<Longrightarrow> n choose k \\<le> N choose k;\n        Suc n \\<le> N\\<rbrakk>\n       \\<Longrightarrow> Suc n choose k \\<le> N choose k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n k N.\n       \\<lbrakk>\\<And>k N.\n                   n \\<le> N \\<Longrightarrow> n choose k \\<le> N choose k;\n        Suc n \\<le> N\\<rbrakk>\n       \\<Longrightarrow> Suc n choose k \\<le> N choose k", "case (Suc n k N)"], ["proof (state)\nthis:\n  n \\<le> ?N \\<Longrightarrow> n choose ?k \\<le> ?N choose ?k\n  Suc n \\<le> N\n\ngoal (1 subgoal):\n 1. \\<And>n k N.\n       \\<lbrakk>\\<And>k N.\n                   n \\<le> N \\<Longrightarrow> n choose k \\<le> N choose k;\n        Suc n \\<le> N\\<rbrakk>\n       \\<Longrightarrow> Suc n choose k \\<le> N choose k", "note IH = this"], ["proof (state)\nthis:\n  n \\<le> ?N \\<Longrightarrow> n choose ?k \\<le> ?N choose ?k\n  Suc n \\<le> N\n\ngoal (1 subgoal):\n 1. \\<And>n k N.\n       \\<lbrakk>\\<And>k N.\n                   n \\<le> N \\<Longrightarrow> n choose k \\<le> N choose k;\n        Suc n \\<le> N\\<rbrakk>\n       \\<Longrightarrow> Suc n choose k \\<le> N choose k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n choose k \\<le> N choose k", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> Suc n choose k \\<le> N choose k\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> Suc n choose k \\<le> N choose k", "case (Suc kk)"], ["proof (state)\nthis:\n  k = Suc kk\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> Suc n choose k \\<le> N choose k\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> Suc n choose k \\<le> N choose k", "from IH"], ["proof (chain)\npicking this:\n  n \\<le> ?N \\<Longrightarrow> n choose ?k \\<le> ?N choose ?k\n  Suc n \\<le> N", "obtain NN where N: \"N = Suc NN\" and le: \"n \\<le> NN\""], ["proof (prove)\nusing this:\n  n \\<le> ?N \\<Longrightarrow> n choose ?k \\<le> ?N choose ?k\n  Suc n \\<le> N\n\ngoal (1 subgoal):\n 1. (\\<And>NN.\n        \\<lbrakk>N = Suc NN; n \\<le> NN\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases N, auto)"], ["proof (state)\nthis:\n  N = Suc NN\n  n \\<le> NN\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> Suc n choose k \\<le> N choose k\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> Suc n choose k \\<le> N choose k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n choose k \\<le> N choose k", "unfolding N Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n choose Suc kk \\<le> Suc NN choose Suc kk", "using IH(1)[OF le]"], ["proof (prove)\nusing this:\n  n choose ?k \\<le> NN choose ?k\n\ngoal (1 subgoal):\n 1. Suc n choose Suc kk \\<le> Suc NN choose Suc kk", "by (simp add: add_le_mono)"], ["proof (state)\nthis:\n  Suc n choose k \\<le> N choose k\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> Suc n choose k \\<le> N choose k", "qed auto"], ["proof (state)\nthis:\n  Suc n choose k \\<le> N choose k\n\ngoal:\nNo subgoals!", "qed"], ["", "definition choose_int where \"choose_int m n = (if n < 0 then 0 else m choose (nat n))\""], ["", "lemma choose_int_suc[simp]:\n  \"choose_int (Suc n) i = choose_int n (i-1) + choose_int n i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_int (Suc n) i = choose_int n (i - 1) + choose_int n i", "proof(cases \"nat i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. nat i = 0 \\<Longrightarrow>\n    choose_int (Suc n) i = choose_int n (i - 1) + choose_int n i\n 2. \\<And>nata.\n       nat i = Suc nata \\<Longrightarrow>\n       choose_int (Suc n) i = choose_int n (i - 1) + choose_int n i", "case 0"], ["proof (state)\nthis:\n  nat i = 0\n\ngoal (2 subgoals):\n 1. nat i = 0 \\<Longrightarrow>\n    choose_int (Suc n) i = choose_int n (i - 1) + choose_int n i\n 2. \\<And>nata.\n       nat i = Suc nata \\<Longrightarrow>\n       choose_int (Suc n) i = choose_int n (i - 1) + choose_int n i", "thus ?thesis"], ["proof (prove)\nusing this:\n  nat i = 0\n\ngoal (1 subgoal):\n 1. choose_int (Suc n) i = choose_int n (i - 1) + choose_int n i", "by (simp add:choose_int_def)"], ["proof (state)\nthis:\n  choose_int (Suc n) i = choose_int n (i - 1) + choose_int n i\n\ngoal (1 subgoal):\n 1. \\<And>nata.\n       nat i = Suc nata \\<Longrightarrow>\n       choose_int (Suc n) i = choose_int n (i - 1) + choose_int n i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nata.\n       nat i = Suc nata \\<Longrightarrow>\n       choose_int (Suc n) i = choose_int n (i - 1) + choose_int n i", "case (Suc v)"], ["proof (state)\nthis:\n  nat i = Suc v\n\ngoal (1 subgoal):\n 1. \\<And>nata.\n       nat i = Suc nata \\<Longrightarrow>\n       choose_int (Suc n) i = choose_int n (i - 1) + choose_int n i", "hence \"nat (i - 1) = v\" \"i\\<noteq>0\""], ["proof (prove)\nusing this:\n  nat i = Suc v\n\ngoal (1 subgoal):\n 1. nat (i - 1) = v &&& i \\<noteq> 0", "by simp_all"], ["proof (state)\nthis:\n  nat (i - 1) = v\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>nata.\n       nat i = Suc nata \\<Longrightarrow>\n       choose_int (Suc n) i = choose_int n (i - 1) + choose_int n i", "thus ?thesis"], ["proof (prove)\nusing this:\n  nat (i - 1) = v\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. choose_int (Suc n) i = choose_int n (i - 1) + choose_int n i", "unfolding choose_int_def Suc"], ["proof (prove)\nusing this:\n  nat (i - 1) = v\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if i < 0 then 0 else Suc n choose Suc v) =\n    (if i - 1 < 0 then 0 else n choose nat (i - 1)) +\n    (if i < 0 then 0 else n choose Suc v)", "by simp"], ["proof (state)\nthis:\n  choose_int (Suc n) i = choose_int n (i - 1) + choose_int n i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_le_1_prod: assumes d: \"1 \\<le> d\" and c: \"1 \\<le> c\"\n  shows \"c + d \\<le> 1 + c * (d :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c + d \\<le> 1 + c * d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c + d \\<le> 1 + c * d", "from d c"], ["proof (chain)\npicking this:\n  1 \\<le> d\n  1 \\<le> c", "have \"(c - 1) * (d - 1) \\<ge> 0\""], ["proof (prove)\nusing this:\n  1 \\<le> d\n  1 \\<le> c\n\ngoal (1 subgoal):\n 1. 0 \\<le> (c - 1) * (d - 1)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (c - 1) * (d - 1)\n\ngoal (1 subgoal):\n 1. c + d \\<le> 1 + c * d", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> (c - 1) * (d - 1)\n\ngoal (1 subgoal):\n 1. c + d \\<le> 1 + c * d", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  c + d \\<le> 1 + c * d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mignotte_helper_coeff_int: \"cmod (coeff_int (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) i)\n    \\<le> choose_int (length lst - 1) i * (\\<Prod>a\\<leftarrow>lst. (max 1 (cmod a))) \n    + choose_int (length lst - 1) (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (coeff_int (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) i)\n    \\<le> real (choose_int (length lst - 1) i) *\n          (\\<Prod>a\\<leftarrow>lst. max 1 (cmod a)) +\n          real (choose_int (length lst - 1) (i - 1))", "proof(induct lst arbitrary:i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       cmod (coeff_int (\\<Prod>a\\<leftarrow>[]. [:- a, 1:]) i)\n       \\<le> real (choose_int (length [] - 1) i) *\n             (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a)) +\n             real (choose_int (length [] - 1) (i - 1))\n 2. \\<And>a lst i.\n       (\\<And>i.\n           cmod (coeff_int (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) i)\n           \\<le> real (choose_int (length lst - 1) i) *\n                 (\\<Prod>a\\<leftarrow>lst. max 1 (cmod a)) +\n                 real\n                  (choose_int (length lst - 1) (i - 1))) \\<Longrightarrow>\n       cmod (coeff_int (\\<Prod>a\\<leftarrow>a # lst. [:- a, 1:]) i)\n       \\<le> real (choose_int (length (a # lst) - 1) i) *\n             (\\<Prod>a\\<leftarrow>a # lst. max 1 (cmod a)) +\n             real (choose_int (length (a # lst) - 1) (i - 1))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>i.\n       cmod (coeff_int (\\<Prod>a\\<leftarrow>[]. [:- a, 1:]) i)\n       \\<le> real (choose_int (length [] - 1) i) *\n             (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a)) +\n             real (choose_int (length [] - 1) (i - 1))\n 2. \\<And>a lst i.\n       (\\<And>i.\n           cmod (coeff_int (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) i)\n           \\<le> real (choose_int (length lst - 1) i) *\n                 (\\<Prod>a\\<leftarrow>lst. max 1 (cmod a)) +\n                 real\n                  (choose_int (length lst - 1) (i - 1))) \\<Longrightarrow>\n       cmod (coeff_int (\\<Prod>a\\<leftarrow>a # lst. [:- a, 1:]) i)\n       \\<le> real (choose_int (length (a # lst) - 1) i) *\n             (\\<Prod>a\\<leftarrow>a # lst. max 1 (cmod a)) +\n             real (choose_int (length (a # lst) - 1) (i - 1))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (coeff_int (\\<Prod>a\\<leftarrow>[]. [:- a, 1:]) i)\n    \\<le> real (choose_int (length [] - 1) i) *\n          (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a)) +\n          real (choose_int (length [] - 1) (i - 1))", "by (auto simp:coeff_int_def choose_int_def)"], ["proof (state)\nthis:\n  cmod (coeff_int (\\<Prod>a\\<leftarrow>[]. [:- a, 1:]) i)\n  \\<le> real (choose_int (length [] - 1) i) *\n        (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a)) +\n        real (choose_int (length [] - 1) (i - 1))\n\ngoal (1 subgoal):\n 1. \\<And>a lst i.\n       (\\<And>i.\n           cmod (coeff_int (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) i)\n           \\<le> real (choose_int (length lst - 1) i) *\n                 (\\<Prod>a\\<leftarrow>lst. max 1 (cmod a)) +\n                 real\n                  (choose_int (length lst - 1) (i - 1))) \\<Longrightarrow>\n       cmod (coeff_int (\\<Prod>a\\<leftarrow>a # lst. [:- a, 1:]) i)\n       \\<le> real (choose_int (length (a # lst) - 1) i) *\n             (\\<Prod>a\\<leftarrow>a # lst. max 1 (cmod a)) +\n             real (choose_int (length (a # lst) - 1) (i - 1))", "case (Cons v xs i)"], ["proof (state)\nthis:\n  cmod (coeff_int (\\<Prod>a\\<leftarrow>xs. [:- a, 1:]) ?i)\n  \\<le> real (choose_int (length xs - 1) ?i) *\n        (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n        real (choose_int (length xs - 1) (?i - 1))\n\ngoal (1 subgoal):\n 1. \\<And>a lst i.\n       (\\<And>i.\n           cmod (coeff_int (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) i)\n           \\<le> real (choose_int (length lst - 1) i) *\n                 (\\<Prod>a\\<leftarrow>lst. max 1 (cmod a)) +\n                 real\n                  (choose_int (length lst - 1) (i - 1))) \\<Longrightarrow>\n       cmod (coeff_int (\\<Prod>a\\<leftarrow>a # lst. [:- a, 1:]) i)\n       \\<le> real (choose_int (length (a # lst) - 1) i) *\n             (\\<Prod>a\\<leftarrow>a # lst. max 1 (cmod a)) +\n             real (choose_int (length (a # lst) - 1) (i - 1))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "case True"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (coeff_int (\\<Prod>a\\<leftarrow>[v]. [:- a, 1:]) i)\n    \\<le> real (choose_int (length [v] - 1) i) *\n          (\\<Prod>a\\<leftarrow>[v]. max 1 (cmod a)) +\n          real (choose_int (length [v] - 1) (i - 1))", "by (cases \"nat i\", cases \"nat (i - 1)\", auto simp: coeff_int_def choose_int_def)"], ["proof (state)\nthis:\n  cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n  \\<le> real (choose_int (length (v # xs) - 1) i) *\n        (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n        real (choose_int (length (v # xs) - 1) (i - 1))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "hence id: \"length (v # xs) - 1 = Suc (length xs - 1)\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. length (v # xs) - 1 = Suc (length xs - 1)", "by auto"], ["proof (state)\nthis:\n  length (v # xs) - 1 = Suc (length xs - 1)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "have id': \"choose_int (length xs) i = choose_int (Suc (length xs - 1)) i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_int (length xs) i = choose_int (Suc (length xs - 1)) i", "using False"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. choose_int (length xs) i = choose_int (Suc (length xs - 1)) i", "by (cases xs, auto)"], ["proof (state)\nthis:\n  choose_int (length xs) ?i = choose_int (Suc (length xs - 1)) ?i\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "let ?r = \"(\\<Prod>a\\<leftarrow>xs. [:- a, 1:])\""], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "let ?mv = \"(\\<Prod>a\\<leftarrow>xs. (max 1 (cmod a)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "let ?c1 = \"real (choose_int (length xs - 1) (i - 1 - 1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "let ?c2 = \"real (choose_int (length (v # xs) - 1) i - choose_int (length xs - 1) i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "let \"?m xs n\" = \"choose_int (length xs - 1) n * (\\<Prod>a\\<leftarrow>xs. (max 1 (cmod a)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "have le1:\"1 \\<le> max 1 (cmod v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> max 1 (cmod v)", "by auto"], ["proof (state)\nthis:\n  1 \\<le> max 1 (cmod v)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "have le2:\"cmod v \\<le> max 1 (cmod v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod v \\<le> max 1 (cmod v)", "by auto"], ["proof (state)\nthis:\n  cmod v \\<le> max 1 (cmod v)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "have mv_ge_1:\"1 \\<le> ?mv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a))", "by (rule prod_list_ge1, auto)"], ["proof (state)\nthis:\n  1 \\<le> (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "obtain a b c d where abcd : \n      \"a = real (choose_int (length xs - 1) i)\" \n      \"b = real (choose_int (length xs - 1) (i - 1))\" \n      \"c = (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a))\" \n      \"d = cmod v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b c d.\n        \\<lbrakk>a = real (choose_int (length xs - 1) i);\n         b = real (choose_int (length xs - 1) (i - 1));\n         c = (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)); d = cmod v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a = real (choose_int (length xs - 1) i)\n  b = real (choose_int (length xs - 1) (i - 1))\n  c = (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a))\n  d = cmod v\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "{"], ["proof (state)\nthis:\n  a = real (choose_int (length xs - 1) i)\n  b = real (choose_int (length xs - 1) (i - 1))\n  c = (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a))\n  d = cmod v\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "have c1: \"c \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> c", "unfolding abcd"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a))", "by (rule mv_ge_1)"], ["proof (state)\nthis:\n  1 \\<le> c\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "have b: \"b = 0 \\<or> b \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = 0 \\<or> 1 \\<le> b", "unfolding abcd"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (choose_int (length xs - 1) (i - 1)) = 0 \\<or>\n    1 \\<le> real (choose_int (length xs - 1) (i - 1))", "by auto"], ["proof (state)\nthis:\n  b = 0 \\<or> 1 \\<le> b\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "have a: \"a = 0 \\<or> a \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = 0 \\<or> 1 \\<le> a", "unfolding abcd"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (choose_int (length xs - 1) i) = 0 \\<or>\n    1 \\<le> real (choose_int (length xs - 1) i)", "by auto"], ["proof (state)\nthis:\n  a = 0 \\<or> 1 \\<le> a\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "hence a0: \"a \\<ge> 0\""], ["proof (prove)\nusing this:\n  a = 0 \\<or> 1 \\<le> a\n\ngoal (1 subgoal):\n 1. 0 \\<le> a", "by auto"], ["proof (state)\nthis:\n  0 \\<le> a\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "have acd: \"a * (c * d) \\<le> a * (c * max 1 d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * (c * d) \\<le> a * (c * max 1 d)", "using a0 c1"], ["proof (prove)\nusing this:\n  0 \\<le> a\n  1 \\<le> c\n\ngoal (1 subgoal):\n 1. a * (c * d) \\<le> a * (c * max 1 d)", "by (simp add: mult_left_mono)"], ["proof (state)\nthis:\n  a * (c * d) \\<le> a * (c * max 1 d)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "from b"], ["proof (chain)\npicking this:\n  b = 0 \\<or> 1 \\<le> b", "have \"b * (c + d) \\<le> b * (1  + (c * max 1 d))\""], ["proof (prove)\nusing this:\n  b = 0 \\<or> 1 \\<le> b\n\ngoal (1 subgoal):\n 1. b * (c + d) \\<le> b * (1 + c * max 1 d)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> b * (c + d) \\<le> b * (1 + c * max 1 d)\n 2. 1 \\<le> b \\<Longrightarrow> b * (c + d) \\<le> b * (1 + c * max 1 d)", "assume \"b \\<ge> 1\""], ["proof (state)\nthis:\n  1 \\<le> b\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> b * (c + d) \\<le> b * (1 + c * max 1 d)\n 2. 1 \\<le> b \\<Longrightarrow> b * (c + d) \\<le> b * (1 + c * max 1 d)", "hence \"?thesis = (c + d \\<le> 1 + c * max 1 d)\""], ["proof (prove)\nusing this:\n  1 \\<le> b\n\ngoal (1 subgoal):\n 1. (b * (c + d) \\<le> b * (1 + c * max 1 d)) =\n    (c + d \\<le> 1 + c * max 1 d)", "by simp"], ["proof (state)\nthis:\n  (b * (c + d) \\<le> b * (1 + c * max 1 d)) = (c + d \\<le> 1 + c * max 1 d)\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> b * (c + d) \\<le> b * (1 + c * max 1 d)\n 2. 1 \\<le> b \\<Longrightarrow> b * (c + d) \\<le> b * (1 + c * max 1 d)", "also"], ["proof (state)\nthis:\n  (b * (c + d) \\<le> b * (1 + c * max 1 d)) = (c + d \\<le> 1 + c * max 1 d)\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> b * (c + d) \\<le> b * (1 + c * max 1 d)\n 2. 1 \\<le> b \\<Longrightarrow> b * (c + d) \\<le> b * (1 + c * max 1 d)", "have \\<dots>"], ["proof (prove)\ngoal (1 subgoal):\n 1. c + d \\<le> 1 + c * max 1 d", "proof (cases \"d \\<ge> 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 \\<le> d \\<Longrightarrow> c + d \\<le> 1 + c * max 1 d\n 2. \\<not> 1 \\<le> d \\<Longrightarrow> c + d \\<le> 1 + c * max 1 d", "case False"], ["proof (state)\nthis:\n  \\<not> 1 \\<le> d\n\ngoal (2 subgoals):\n 1. 1 \\<le> d \\<Longrightarrow> c + d \\<le> 1 + c * max 1 d\n 2. \\<not> 1 \\<le> d \\<Longrightarrow> c + d \\<le> 1 + c * max 1 d", "hence id: \"max 1 d = 1\""], ["proof (prove)\nusing this:\n  \\<not> 1 \\<le> d\n\ngoal (1 subgoal):\n 1. max 1 d = 1", "by simp"], ["proof (state)\nthis:\n  max 1 d = 1\n\ngoal (2 subgoals):\n 1. 1 \\<le> d \\<Longrightarrow> c + d \\<le> 1 + c * max 1 d\n 2. \\<not> 1 \\<le> d \\<Longrightarrow> c + d \\<le> 1 + c * max 1 d", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. c + d \\<le> 1 + c * max 1 d", "using False"], ["proof (prove)\nusing this:\n  \\<not> 1 \\<le> d\n\ngoal (1 subgoal):\n 1. c + d \\<le> 1 + c * max 1 d", "unfolding id"], ["proof (prove)\nusing this:\n  \\<not> 1 \\<le> d\n\ngoal (1 subgoal):\n 1. c + d \\<le> 1 + c * 1", "by simp"], ["proof (state)\nthis:\n  c + d \\<le> 1 + c * max 1 d\n\ngoal (1 subgoal):\n 1. 1 \\<le> d \\<Longrightarrow> c + d \\<le> 1 + c * max 1 d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> d \\<Longrightarrow> c + d \\<le> 1 + c * max 1 d", "case True"], ["proof (state)\nthis:\n  1 \\<le> d\n\ngoal (1 subgoal):\n 1. 1 \\<le> d \\<Longrightarrow> c + d \\<le> 1 + c * max 1 d", "hence id: \"max 1 d = d\""], ["proof (prove)\nusing this:\n  1 \\<le> d\n\ngoal (1 subgoal):\n 1. max 1 d = d", "by simp"], ["proof (state)\nthis:\n  max 1 d = d\n\ngoal (1 subgoal):\n 1. 1 \\<le> d \\<Longrightarrow> c + d \\<le> 1 + c * max 1 d", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. c + d \\<le> 1 + c * max 1 d", "using True c1"], ["proof (prove)\nusing this:\n  1 \\<le> d\n  1 \\<le> c\n\ngoal (1 subgoal):\n 1. c + d \\<le> 1 + c * max 1 d", "unfolding id"], ["proof (prove)\nusing this:\n  1 \\<le> d\n  1 \\<le> c\n\ngoal (1 subgoal):\n 1. c + d \\<le> 1 + c * d", "by (rule sum_le_1_prod)"], ["proof (state)\nthis:\n  c + d \\<le> 1 + c * max 1 d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c + d \\<le> 1 + c * max 1 d\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> b * (c + d) \\<le> b * (1 + c * max 1 d)\n 2. 1 \\<le> b \\<Longrightarrow> b * (c + d) \\<le> b * (1 + c * max 1 d)", "finally"], ["proof (chain)\npicking this:\n  b * (c + d) \\<le> b * (1 + c * max 1 d)", "show ?thesis"], ["proof (prove)\nusing this:\n  b * (c + d) \\<le> b * (1 + c * max 1 d)\n\ngoal (1 subgoal):\n 1. b * (c + d) \\<le> b * (1 + c * max 1 d)", "."], ["proof (state)\nthis:\n  b * (c + d) \\<le> b * (1 + c * max 1 d)\n\ngoal (1 subgoal):\n 1. b = 0 \\<Longrightarrow> b * (c + d) \\<le> b * (1 + c * max 1 d)", "qed auto"], ["proof (state)\nthis:\n  b * (c + d) \\<le> b * (1 + c * max 1 d)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "with acd"], ["proof (chain)\npicking this:\n  a * (c * d) \\<le> a * (c * max 1 d)\n  b * (c + d) \\<le> b * (1 + c * max 1 d)", "have \"b * c + (b * d + a * (c * d)) \\<le> b + (a * (c * max 1 d) + b * (c * max 1 d))\""], ["proof (prove)\nusing this:\n  a * (c * d) \\<le> a * (c * max 1 d)\n  b * (c + d) \\<le> b * (1 + c * max 1 d)\n\ngoal (1 subgoal):\n 1. b * c + (b * d + a * (c * d))\n    \\<le> b + (a * (c * max 1 d) + b * (c * max 1 d))", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  b * c + (b * d + a * (c * d))\n  \\<le> b + (a * (c * max 1 d) + b * (c * max 1 d))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "}"], ["proof (state)\nthis:\n  b * c + (b * d + a * (c * d))\n  \\<le> b + (a * (c * max 1 d) + b * (c * max 1 d))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "note abcd_main = this"], ["proof (state)\nthis:\n  b * c + (b * d + a * (c * d))\n  \\<le> b + (a * (c * max 1 d) + b * (c * max 1 d))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "have \"cmod (coeff_int ([:- v, 1:] * ?r) i) \\<le> cmod (coeff_int ?r (i - 1)) + cmod (coeff_int (smult v ?r) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (coeff_int ([:- v, 1:] * (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n    \\<le> cmod (coeff_int (\\<Prod>a\\<leftarrow>xs. [:- a, 1:]) (i - 1)) +\n          cmod\n           (coeff_int\n             (Polynomial.smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)", "using norm_triangle_ineq4"], ["proof (prove)\nusing this:\n  norm (?a - ?b) \\<le> norm ?a + norm ?b\n\ngoal (1 subgoal):\n 1. cmod (coeff_int ([:- v, 1:] * (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n    \\<le> cmod (coeff_int (\\<Prod>a\\<leftarrow>xs. [:- a, 1:]) (i - 1)) +\n          cmod\n           (coeff_int\n             (Polynomial.smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)", "by auto"], ["proof (state)\nthis:\n  cmod (coeff_int ([:- v, 1:] * (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n  \\<le> cmod (coeff_int (\\<Prod>a\\<leftarrow>xs. [:- a, 1:]) (i - 1)) +\n        cmod\n         (coeff_int\n           (Polynomial.smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "also"], ["proof (state)\nthis:\n  cmod (coeff_int ([:- v, 1:] * (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n  \\<le> cmod (coeff_int (\\<Prod>a\\<leftarrow>xs. [:- a, 1:]) (i - 1)) +\n        cmod\n         (coeff_int\n           (Polynomial.smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "have \"\\<dots> \\<le> ?m xs (i - 1) + (choose_int (length xs - 1) (i - 1 - 1)) + cmod (coeff_int (smult v ?r) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (coeff_int (\\<Prod>a\\<leftarrow>xs. [:- a, 1:]) (i - 1)) +\n    cmod\n     (coeff_int (Polynomial.smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n    \\<le> real (choose_int (length xs - 1) (i - 1)) *\n          (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n          real (choose_int (length xs - 1) (i - 1 - 1)) +\n          cmod\n           (coeff_int\n             (Polynomial.smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)", "using Cons[of \"i-1\"]"], ["proof (prove)\nusing this:\n  cmod (coeff_int (\\<Prod>a\\<leftarrow>xs. [:- a, 1:]) (i - 1))\n  \\<le> real (choose_int (length xs - 1) (i - 1)) *\n        (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n        real (choose_int (length xs - 1) (i - 1 - 1))\n\ngoal (1 subgoal):\n 1. cmod (coeff_int (\\<Prod>a\\<leftarrow>xs. [:- a, 1:]) (i - 1)) +\n    cmod\n     (coeff_int (Polynomial.smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n    \\<le> real (choose_int (length xs - 1) (i - 1)) *\n          (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n          real (choose_int (length xs - 1) (i - 1 - 1)) +\n          cmod\n           (coeff_int\n             (Polynomial.smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)", "by auto"], ["proof (state)\nthis:\n  cmod (coeff_int (\\<Prod>a\\<leftarrow>xs. [:- a, 1:]) (i - 1)) +\n  cmod\n   (coeff_int (Polynomial.smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n  \\<le> real (choose_int (length xs - 1) (i - 1)) *\n        (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n        real (choose_int (length xs - 1) (i - 1 - 1)) +\n        cmod\n         (coeff_int\n           (Polynomial.smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "also"], ["proof (state)\nthis:\n  cmod (coeff_int (\\<Prod>a\\<leftarrow>xs. [:- a, 1:]) (i - 1)) +\n  cmod\n   (coeff_int (Polynomial.smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n  \\<le> real (choose_int (length xs - 1) (i - 1)) *\n        (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n        real (choose_int (length xs - 1) (i - 1 - 1)) +\n        cmod\n         (coeff_int\n           (Polynomial.smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "have \"choose_int (length xs - 1) (i - 1) = choose_int (length (v # xs) - 1) i - choose_int (length xs - 1) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_int (length xs - 1) (i - 1) =\n    choose_int (length (v # xs) - 1) i - choose_int (length xs - 1) i", "unfolding id choose_int_suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_int (length xs - 1) (i - 1) =\n    choose_int (length xs - 1) (i - 1) + choose_int (length xs - 1) i -\n    choose_int (length xs - 1) i", "by auto"], ["proof (state)\nthis:\n  choose_int (length xs - 1) (i - 1) =\n  choose_int (length (v # xs) - 1) i - choose_int (length xs - 1) i\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "also"], ["proof (state)\nthis:\n  choose_int (length xs - 1) (i - 1) =\n  choose_int (length (v # xs) - 1) i - choose_int (length xs - 1) i\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "have \"?c2 * (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) + ?c1 +\n       cmod (coeff_int (smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i) \\<le> \n       ?c2 * (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) + ?c1 + cmod v * (\n         real (choose_int (length xs - 1) i) * (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) + \n         real (choose_int (length xs - 1) (i - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real\n     (choose_int (length (v # xs) - 1) i - choose_int (length xs - 1) i) *\n    (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n    real (choose_int (length xs - 1) (i - 1 - 1)) +\n    cmod\n     (coeff_int (Polynomial.smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n    \\<le> real\n           (choose_int (length (v # xs) - 1) i -\n            choose_int (length xs - 1) i) *\n          (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n          real (choose_int (length xs - 1) (i - 1 - 1)) +\n          cmod v *\n          (real (choose_int (length xs - 1) i) *\n           (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n           real (choose_int (length xs - 1) (i - 1)))", "using mult_mono'[OF order_refl Cons, of \"cmod v\" i, simplified]"], ["proof (prove)\nusing this:\n  cmod v * cmod (coeff_int (\\<Prod>a\\<leftarrow>xs. pCons (- a) 1) i)\n  \\<le> cmod v *\n        (real (choose_int (length xs - Suc 0) i) *\n         (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n         real (choose_int (length xs - Suc 0) (i - 1)))\n\ngoal (1 subgoal):\n 1. real\n     (choose_int (length (v # xs) - 1) i - choose_int (length xs - 1) i) *\n    (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n    real (choose_int (length xs - 1) (i - 1 - 1)) +\n    cmod\n     (coeff_int (Polynomial.smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n    \\<le> real\n           (choose_int (length (v # xs) - 1) i -\n            choose_int (length xs - 1) i) *\n          (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n          real (choose_int (length xs - 1) (i - 1 - 1)) +\n          cmod v *\n          (real (choose_int (length xs - 1) i) *\n           (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n           real (choose_int (length xs - 1) (i - 1)))", "by (auto simp: norm_mult)"], ["proof (state)\nthis:\n  real (choose_int (length (v # xs) - 1) i - choose_int (length xs - 1) i) *\n  (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n  real (choose_int (length xs - 1) (i - 1 - 1)) +\n  cmod\n   (coeff_int (Polynomial.smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n  \\<le> real\n         (choose_int (length (v # xs) - 1) i -\n          choose_int (length xs - 1) i) *\n        (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n        real (choose_int (length xs - 1) (i - 1 - 1)) +\n        cmod v *\n        (real (choose_int (length xs - 1) i) *\n         (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n         real (choose_int (length xs - 1) (i - 1)))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "also"], ["proof (state)\nthis:\n  real (choose_int (length (v # xs) - 1) i - choose_int (length xs - 1) i) *\n  (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n  real (choose_int (length xs - 1) (i - 1 - 1)) +\n  cmod\n   (coeff_int (Polynomial.smult v (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n  \\<le> real\n         (choose_int (length (v # xs) - 1) i -\n          choose_int (length xs - 1) i) *\n        (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n        real (choose_int (length xs - 1) (i - 1 - 1)) +\n        cmod v *\n        (real (choose_int (length xs - 1) i) *\n         (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n         real (choose_int (length xs - 1) (i - 1)))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "have \"\\<dots> \\<le> ?m (v # xs) i + (choose_int (length xs) (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real\n     (choose_int (length (v # xs) - 1) i - choose_int (length xs - 1) i) *\n    (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n    real (choose_int (length xs - 1) (i - 1 - 1)) +\n    cmod v *\n    (real (choose_int (length xs - 1) i) *\n     (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n     real (choose_int (length xs - 1) (i - 1)))\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length xs) (i - 1))", "using abcd_main[unfolded abcd]"], ["proof (prove)\nusing this:\n  real (choose_int (length xs - 1) (i - 1)) *\n  (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n  (real (choose_int (length xs - 1) (i - 1)) * cmod v +\n   real (choose_int (length xs - 1) i) *\n   ((\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) * cmod v))\n  \\<le> real (choose_int (length xs - 1) (i - 1)) +\n        (real (choose_int (length xs - 1) i) *\n         ((\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) * max 1 (cmod v)) +\n         real (choose_int (length xs - 1) (i - 1)) *\n         ((\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) * max 1 (cmod v)))\n\ngoal (1 subgoal):\n 1. real\n     (choose_int (length (v # xs) - 1) i - choose_int (length xs - 1) i) *\n    (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n    real (choose_int (length xs - 1) (i - 1 - 1)) +\n    cmod v *\n    (real (choose_int (length xs - 1) i) *\n     (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n     real (choose_int (length xs - 1) (i - 1)))\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length xs) (i - 1))", "by (simp add: field_simps id')"], ["proof (state)\nthis:\n  real (choose_int (length (v # xs) - 1) i - choose_int (length xs - 1) i) *\n  (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n  real (choose_int (length xs - 1) (i - 1 - 1)) +\n  cmod v *\n  (real (choose_int (length xs - 1) i) *\n   (\\<Prod>a\\<leftarrow>xs. max 1 (cmod a)) +\n   real (choose_int (length xs - 1) (i - 1)))\n  \\<le> real (choose_int (length (v # xs) - 1) i) *\n        (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n        real (choose_int (length xs) (i - 1))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "finally"], ["proof (chain)\npicking this:\n  cmod (coeff_int ([:- v, 1:] * (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n  \\<le> real (choose_int (length (v # xs) - 1) i) *\n        (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n        real (choose_int (length xs) (i - 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod (coeff_int ([:- v, 1:] * (\\<Prod>a\\<leftarrow>xs. [:- a, 1:])) i)\n  \\<le> real (choose_int (length (v # xs) - 1) i) *\n        (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n        real (choose_int (length xs) (i - 1))\n\ngoal (1 subgoal):\n 1. cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n    \\<le> real (choose_int (length (v # xs) - 1) i) *\n          (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n          real (choose_int (length (v # xs) - 1) (i - 1))", "by simp"], ["proof (state)\nthis:\n  cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n  \\<le> real (choose_int (length (v # xs) - 1) i) *\n        (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n        real (choose_int (length (v # xs) - 1) (i - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cmod (coeff_int (\\<Prod>a\\<leftarrow>v # xs. [:- a, 1:]) i)\n  \\<le> real (choose_int (length (v # xs) - 1) i) *\n        (\\<Prod>a\\<leftarrow>v # xs. max 1 (cmod a)) +\n        real (choose_int (length (v # xs) - 1) (i - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mignotte_helper_coeff_int': \"cmod (coeff_int (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) i)\n    \\<le> ((length lst - 1) choose i) * (\\<Prod>a\\<leftarrow>lst. (max 1 (cmod a))) \n    + min i 1 * ((length lst - 1) choose (nat (i - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (coeff_int (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) (int i))\n    \\<le> real (length lst - 1 choose i) *\n          (\\<Prod>a\\<leftarrow>lst. max 1 (cmod a)) +\n          real (min i 1 * (length lst - 1 choose nat (int i - 1)))", "by (rule order.trans[OF mignotte_helper_coeff_int], auto simp: choose_int_def min_def)"], ["", "lemma mignotte_helper_coeff: \n  \"cmod (coeff h i) \\<le> (degree h - 1 choose i) * mahler_measure_poly h \n      + min i 1 * (degree h - 1 choose (i - 1)) * cmod (lead_coeff h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (poly.coeff h i)\n    \\<le> real (degree h - 1 choose i) * mahler_measure_poly h +\n          real (min i 1 * (degree h - 1 choose (i - 1))) *\n          cmod (lead_coeff h)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (poly.coeff h i)\n    \\<le> real (degree h - 1 choose i) * mahler_measure_poly h +\n          real (min i 1 * (degree h - 1 choose (i - 1))) *\n          cmod (lead_coeff h)", "let ?r = \"complex_roots_complex h\""], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (poly.coeff h i)\n    \\<le> real (degree h - 1 choose i) * mahler_measure_poly h +\n          real (min i 1 * (degree h - 1 choose (i - 1))) *\n          cmod (lead_coeff h)", "have \"cmod (coeff h i) = cmod (coeff (smult (lead_coeff h) (\\<Prod>a\\<leftarrow>?r. [:- a, 1:])) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (poly.coeff h i) =\n    cmod\n     (poly.coeff\n       (Polynomial.smult (lead_coeff h)\n         (\\<Prod>a\\<leftarrow>complex_roots_complex h. [:- a, 1:]))\n       i)", "unfolding complex_roots"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (poly.coeff h i) = cmod (poly.coeff h i)", "by auto"], ["proof (state)\nthis:\n  cmod (poly.coeff h i) =\n  cmod\n   (poly.coeff\n     (Polynomial.smult (lead_coeff h)\n       (\\<Prod>a\\<leftarrow>complex_roots_complex h. [:- a, 1:]))\n     i)\n\ngoal (1 subgoal):\n 1. cmod (poly.coeff h i)\n    \\<le> real (degree h - 1 choose i) * mahler_measure_poly h +\n          real (min i 1 * (degree h - 1 choose (i - 1))) *\n          cmod (lead_coeff h)", "also"], ["proof (state)\nthis:\n  cmod (poly.coeff h i) =\n  cmod\n   (poly.coeff\n     (Polynomial.smult (lead_coeff h)\n       (\\<Prod>a\\<leftarrow>complex_roots_complex h. [:- a, 1:]))\n     i)\n\ngoal (1 subgoal):\n 1. cmod (poly.coeff h i)\n    \\<le> real (degree h - 1 choose i) * mahler_measure_poly h +\n          real (min i 1 * (degree h - 1 choose (i - 1))) *\n          cmod (lead_coeff h)", "have \"\\<dots> = cmod (lead_coeff h) * cmod (coeff (\\<Prod>a\\<leftarrow>?r. [:- a, 1:]) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (poly.coeff\n       (Polynomial.smult (lead_coeff h)\n         (\\<Prod>a\\<leftarrow>complex_roots_complex h. [:- a, 1:]))\n       i) =\n    cmod (lead_coeff h) *\n    cmod\n     (poly.coeff (\\<Prod>a\\<leftarrow>complex_roots_complex h. [:- a, 1:])\n       i)", "by(simp add:norm_mult)"], ["proof (state)\nthis:\n  cmod\n   (poly.coeff\n     (Polynomial.smult (lead_coeff h)\n       (\\<Prod>a\\<leftarrow>complex_roots_complex h. [:- a, 1:]))\n     i) =\n  cmod (lead_coeff h) *\n  cmod\n   (poly.coeff (\\<Prod>a\\<leftarrow>complex_roots_complex h. [:- a, 1:]) i)\n\ngoal (1 subgoal):\n 1. cmod (poly.coeff h i)\n    \\<le> real (degree h - 1 choose i) * mahler_measure_poly h +\n          real (min i 1 * (degree h - 1 choose (i - 1))) *\n          cmod (lead_coeff h)", "also"], ["proof (state)\nthis:\n  cmod\n   (poly.coeff\n     (Polynomial.smult (lead_coeff h)\n       (\\<Prod>a\\<leftarrow>complex_roots_complex h. [:- a, 1:]))\n     i) =\n  cmod (lead_coeff h) *\n  cmod\n   (poly.coeff (\\<Prod>a\\<leftarrow>complex_roots_complex h. [:- a, 1:]) i)\n\ngoal (1 subgoal):\n 1. cmod (poly.coeff h i)\n    \\<le> real (degree h - 1 choose i) * mahler_measure_poly h +\n          real (min i 1 * (degree h - 1 choose (i - 1))) *\n          cmod (lead_coeff h)", "have \"\\<dots> \\<le> cmod (lead_coeff h) * ((degree h - 1 choose i) * mahler_measure_monic h + \n    (min i 1 * ((degree h - 1) choose nat (int i - 1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (lead_coeff h) *\n    cmod\n     (poly.coeff (\\<Prod>a\\<leftarrow>complex_roots_complex h. [:- a, 1:])\n       i)\n    \\<le> cmod (lead_coeff h) *\n          (real (degree h - 1 choose i) * mahler_measure_monic h +\n           real (min i 1 * (degree h - 1 choose nat (int i - 1))))", "unfolding mahler_measure_monic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (lead_coeff h) *\n    cmod\n     (poly.coeff (\\<Prod>a\\<leftarrow>complex_roots_complex h. [:- a, 1:])\n       i)\n    \\<le> cmod (lead_coeff h) *\n          (real (degree h - 1 choose i) *\n           (\\<Prod>a\\<leftarrow>complex_roots_complex h. max 1 (cmod a)) +\n           real (min i 1 * (degree h - 1 choose nat (int i - 1))))", "by (rule mult_left_mono, insert mignotte_helper_coeff_int'[of ?r i], auto)"], ["proof (state)\nthis:\n  cmod (lead_coeff h) *\n  cmod\n   (poly.coeff (\\<Prod>a\\<leftarrow>complex_roots_complex h. [:- a, 1:]) i)\n  \\<le> cmod (lead_coeff h) *\n        (real (degree h - 1 choose i) * mahler_measure_monic h +\n         real (min i 1 * (degree h - 1 choose nat (int i - 1))))\n\ngoal (1 subgoal):\n 1. cmod (poly.coeff h i)\n    \\<le> real (degree h - 1 choose i) * mahler_measure_poly h +\n          real (min i 1 * (degree h - 1 choose (i - 1))) *\n          cmod (lead_coeff h)", "also"], ["proof (state)\nthis:\n  cmod (lead_coeff h) *\n  cmod\n   (poly.coeff (\\<Prod>a\\<leftarrow>complex_roots_complex h. [:- a, 1:]) i)\n  \\<le> cmod (lead_coeff h) *\n        (real (degree h - 1 choose i) * mahler_measure_monic h +\n         real (min i 1 * (degree h - 1 choose nat (int i - 1))))\n\ngoal (1 subgoal):\n 1. cmod (poly.coeff h i)\n    \\<le> real (degree h - 1 choose i) * mahler_measure_poly h +\n          real (min i 1 * (degree h - 1 choose (i - 1))) *\n          cmod (lead_coeff h)", "have \"\\<dots> = (degree h - 1 choose i) * mahler_measure_poly h + cmod (lead_coeff h) * (\n    min i 1 * ((degree h - 1) choose nat (int i - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (lead_coeff h) *\n    (real (degree h - 1 choose i) * mahler_measure_monic h +\n     real (min i 1 * (degree h - 1 choose nat (int i - 1)))) =\n    real (degree h - 1 choose i) * mahler_measure_poly h +\n    cmod (lead_coeff h) *\n    real (min i 1 * (degree h - 1 choose nat (int i - 1)))", "unfolding mahler_measure_poly_via_monic"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (lead_coeff h) *\n    (real (degree h - 1 choose i) * mahler_measure_monic h +\n     real (min i 1 * (degree h - 1 choose nat (int i - 1)))) =\n    real (degree h - 1 choose i) *\n    (cmod (lead_coeff h) * mahler_measure_monic h) +\n    cmod (lead_coeff h) *\n    real (min i 1 * (degree h - 1 choose nat (int i - 1)))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  cmod (lead_coeff h) *\n  (real (degree h - 1 choose i) * mahler_measure_monic h +\n   real (min i 1 * (degree h - 1 choose nat (int i - 1)))) =\n  real (degree h - 1 choose i) * mahler_measure_poly h +\n  cmod (lead_coeff h) *\n  real (min i 1 * (degree h - 1 choose nat (int i - 1)))\n\ngoal (1 subgoal):\n 1. cmod (poly.coeff h i)\n    \\<le> real (degree h - 1 choose i) * mahler_measure_poly h +\n          real (min i 1 * (degree h - 1 choose (i - 1))) *\n          cmod (lead_coeff h)", "also"], ["proof (state)\nthis:\n  cmod (lead_coeff h) *\n  (real (degree h - 1 choose i) * mahler_measure_monic h +\n   real (min i 1 * (degree h - 1 choose nat (int i - 1)))) =\n  real (degree h - 1 choose i) * mahler_measure_poly h +\n  cmod (lead_coeff h) *\n  real (min i 1 * (degree h - 1 choose nat (int i - 1)))\n\ngoal (1 subgoal):\n 1. cmod (poly.coeff h i)\n    \\<le> real (degree h - 1 choose i) * mahler_measure_poly h +\n          real (min i 1 * (degree h - 1 choose (i - 1))) *\n          cmod (lead_coeff h)", "have \"nat (int i - 1) = i - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (int i - 1) = i - 1", "by (cases i, auto)"], ["proof (state)\nthis:\n  nat (int i - 1) = i - 1\n\ngoal (1 subgoal):\n 1. cmod (poly.coeff h i)\n    \\<le> real (degree h - 1 choose i) * mahler_measure_poly h +\n          real (min i 1 * (degree h - 1 choose (i - 1))) *\n          cmod (lead_coeff h)", "finally"], ["proof (chain)\npicking this:\n  cmod (poly.coeff h i)\n  \\<le> real (degree h - 1 choose i) * mahler_measure_poly h +\n        cmod (lead_coeff h) * real (min i 1 * (degree h - 1 choose (i - 1)))", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod (poly.coeff h i)\n  \\<le> real (degree h - 1 choose i) * mahler_measure_poly h +\n        cmod (lead_coeff h) * real (min i 1 * (degree h - 1 choose (i - 1)))\n\ngoal (1 subgoal):\n 1. cmod (poly.coeff h i)\n    \\<le> real (degree h - 1 choose i) * mahler_measure_poly h +\n          real (min i 1 * (degree h - 1 choose (i - 1))) *\n          cmod (lead_coeff h)", "by (simp add: ac_simps split: if_splits)"], ["proof (state)\nthis:\n  cmod (poly.coeff h i)\n  \\<le> real (degree h - 1 choose i) * mahler_measure_poly h +\n        real (min i 1 * (degree h - 1 choose (i - 1))) * cmod (lead_coeff h)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mignotte_coeff_helper:\n  \"abs (coeff h i) \\<le> \n   (degree h - 1 choose i) * mahler_measure h +\n   (min i 1 * (degree h - 1 choose (i - 1)) * abs (lead_coeff h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>poly.coeff h i\\<bar>\n    \\<le> real (degree h - 1 choose i) * mahler_measure h +\n          real_of_int\n           (int (min i 1 * (degree h - 1 choose (i - 1))) *\n            \\<bar>lead_coeff h\\<bar>)", "unfolding mahler_measure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>poly.coeff h i\\<bar>\n    \\<le> real (degree h - 1 choose i) *\n          mahler_measure_poly (of_int_poly h) +\n          real_of_int\n           (int (min i 1 * (degree h - 1 choose (i - 1))) *\n            \\<bar>lead_coeff h\\<bar>)", "using mignotte_helper_coeff[of \"of_int_poly h\" i]"], ["proof (prove)\nusing this:\n  cmod (poly.coeff (of_int_poly h) i)\n  \\<le> real (degree (of_int_poly h) - 1 choose i) *\n        mahler_measure_poly (of_int_poly h) +\n        real (min i 1 * (degree (of_int_poly h) - 1 choose (i - 1))) *\n        cmod (lead_coeff (of_int_poly h))\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>poly.coeff h i\\<bar>\n    \\<le> real (degree h - 1 choose i) *\n          mahler_measure_poly (of_int_poly h) +\n          real_of_int\n           (int (min i 1 * (degree h - 1 choose (i - 1))) *\n            \\<bar>lead_coeff h\\<bar>)", "by auto"], ["", "lemma cmod_through_lead_coeff[simp]:\n  \"cmod (lead_coeff (of_int_poly h)) = abs (lead_coeff h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (lead_coeff (of_int_poly h)) = real_of_int \\<bar>lead_coeff h\\<bar>", "by simp"], ["", "lemma choose_approx: \"n \\<le> N \\<Longrightarrow> n choose k \\<le> N choose (N div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> N \\<Longrightarrow> n choose k \\<le> N choose N div 2", "by (rule order.trans[OF binomial_mono_left binomial_maximum])"], ["", "text \\<open>For Mignotte's factor bound, we currently do not support queries for individual coefficients,\n  as we do not have a combined factor bound algorithm.\\<close>"], ["", "definition mignotte_bound :: \"int poly \\<Rightarrow> nat \\<Rightarrow> int\" where\n  \"mignotte_bound f d = (let d' = d - 1; d2 = d' div 2; binom = (d' choose d2) in\n     (mahler_approximation 2 binom f + binom * abs (lead_coeff f)))\""], ["", "lemma mignotte_bound_main:  \n  assumes \"f \\<noteq> 0\" \"g dvd f\" \"degree g \\<le> n\"\n  shows \"\\<bar>coeff g k\\<bar> \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n       int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "let ?bnd = 2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "let ?n = \"(n - 1) choose k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "let ?n' = \"min k 1 * ((n - 1) choose (k - 1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "let ?approx = \"mahler_approximation ?bnd ?n f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "obtain h where gh:\"g * h = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h. g * h = f \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  g dvd f\n  degree g \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>h. g * h = f \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis dvdE)"], ["proof (state)\nthis:\n  g * h = f\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "have nz:\"g\\<noteq>0\" \"h\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<noteq> 0 &&& h \\<noteq> 0", "using gh assms(1)"], ["proof (prove)\nusing this:\n  g * h = f\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0 &&& h \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g \\<noteq> 0\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "have g1:\"(1::real) \\<le> mahler_measure h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> mahler_measure h", "using mahler_measure_poly_ge_1 gh assms(1)"], ["proof (prove)\nusing this:\n  ?h \\<noteq> 0 \\<Longrightarrow> 1 \\<le> mahler_measure ?h\n  g * h = f\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> mahler_measure h", "by auto"], ["proof (state)\nthis:\n  1 \\<le> mahler_measure h\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "note g0 = mahler_measure_ge_0"], ["proof (state)\nthis:\n  0 \\<le> mahler_measure ?h\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "have to_n: \"(degree g - 1 choose k) \\<le> real ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (degree g - 1 choose k) \\<le> real (n - 1 choose k)", "using binomial_mono_left[of \"degree g - 1\" \"n - 1\" k] assms(3)"], ["proof (prove)\nusing this:\n  degree g - 1 \\<le> n - 1 \\<Longrightarrow>\n  degree g - 1 choose k \\<le> n - 1 choose k\n  degree g \\<le> n\n\ngoal (1 subgoal):\n 1. real (degree g - 1 choose k) \\<le> real (n - 1 choose k)", "by auto"], ["proof (state)\nthis:\n  real (degree g - 1 choose k) \\<le> real (n - 1 choose k)\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "have to_n': \"min k 1 * (degree g - 1 choose (k - 1)) \\<le> real ?n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (min k 1 * (degree g - 1 choose (k - 1)))\n    \\<le> real (min k 1 * (n - 1 choose (k - 1)))", "using binomial_mono_left[of \"degree g - 1\" \"n - 1\" \"k - 1\"] assms(3)"], ["proof (prove)\nusing this:\n  degree g - 1 \\<le> n - 1 \\<Longrightarrow>\n  degree g - 1 choose (k - 1) \\<le> n - 1 choose (k - 1)\n  degree g \\<le> n\n\ngoal (1 subgoal):\n 1. real (min k 1 * (degree g - 1 choose (k - 1)))\n    \\<le> real (min k 1 * (n - 1 choose (k - 1)))", "by (simp add: min_def)"], ["proof (state)\nthis:\n  real (min k 1 * (degree g - 1 choose (k - 1)))\n  \\<le> real (min k 1 * (n - 1 choose (k - 1)))\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "have \"\\<bar>coeff g k\\<bar> \\<le> (degree g - 1 choose k) * mahler_measure g\n    + (real (min k 1 * (degree g - 1 choose (k - 1))) * \\<bar>lead_coeff g\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g - 1 choose k) * mahler_measure g +\n          real (min k 1 * (degree g - 1 choose (k - 1))) *\n          real_of_int \\<bar>lead_coeff g\\<bar>", "using mignotte_coeff_helper[of g k]"], ["proof (prove)\nusing this:\n  real_of_int \\<bar>poly.coeff g k\\<bar>\n  \\<le> real (degree g - 1 choose k) * mahler_measure g +\n        real_of_int\n         (int (min k 1 * (degree g - 1 choose (k - 1))) *\n          \\<bar>lead_coeff g\\<bar>)\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g - 1 choose k) * mahler_measure g +\n          real (min k 1 * (degree g - 1 choose (k - 1))) *\n          real_of_int \\<bar>lead_coeff g\\<bar>", "by simp"], ["proof (state)\nthis:\n  real_of_int \\<bar>poly.coeff g k\\<bar>\n  \\<le> real (degree g - 1 choose k) * mahler_measure g +\n        real (min k 1 * (degree g - 1 choose (k - 1))) *\n        real_of_int \\<bar>lead_coeff g\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "also"], ["proof (state)\nthis:\n  real_of_int \\<bar>poly.coeff g k\\<bar>\n  \\<le> real (degree g - 1 choose k) * mahler_measure g +\n        real (min k 1 * (degree g - 1 choose (k - 1))) *\n        real_of_int \\<bar>lead_coeff g\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "have \"\\<dots> \\<le> ?n * mahler_measure f + real ?n' * \\<bar>lead_coeff f\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (degree g - 1 choose k) * mahler_measure g +\n    real (min k 1 * (degree g - 1 choose (k - 1))) *\n    real_of_int \\<bar>lead_coeff g\\<bar>\n    \\<le> real (n - 1 choose k) * mahler_measure f +\n          real (min k 1 * (n - 1 choose (k - 1))) *\n          real_of_int \\<bar>lead_coeff f\\<bar>", "proof (rule add_mono[OF mult_mono[OF to_n] mult_mono[OF to_n']])"], ["proof (state)\ngoal (6 subgoals):\n 1. mahler_measure g \\<le> mahler_measure f\n 2. 0 \\<le> real (n - 1 choose k)\n 3. 0 \\<le> mahler_measure g\n 4. real_of_int \\<bar>lead_coeff g\\<bar>\n    \\<le> real_of_int \\<bar>lead_coeff f\\<bar>\n 5. 0 \\<le> real (min k 1 * (n - 1 choose (k - 1)))\n 6. 0 \\<le> real_of_int \\<bar>lead_coeff g\\<bar>", "have \"mahler_measure g  \\<le> mahler_measure g * mahler_measure h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure g \\<le> mahler_measure g * mahler_measure h", "using g1 g0[of g]"], ["proof (prove)\nusing this:\n  1 \\<le> mahler_measure h\n  0 \\<le> mahler_measure g\n\ngoal (1 subgoal):\n 1. mahler_measure g \\<le> mahler_measure g * mahler_measure h", "using mahler_measure_poly_ge_1 nz(1)"], ["proof (prove)\nusing this:\n  1 \\<le> mahler_measure h\n  0 \\<le> mahler_measure g\n  ?h \\<noteq> 0 \\<Longrightarrow> 1 \\<le> mahler_measure ?h\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. mahler_measure g \\<le> mahler_measure g * mahler_measure h", "by force"], ["proof (state)\nthis:\n  mahler_measure g \\<le> mahler_measure g * mahler_measure h\n\ngoal (6 subgoals):\n 1. mahler_measure g \\<le> mahler_measure f\n 2. 0 \\<le> real (n - 1 choose k)\n 3. 0 \\<le> mahler_measure g\n 4. real_of_int \\<bar>lead_coeff g\\<bar>\n    \\<le> real_of_int \\<bar>lead_coeff f\\<bar>\n 5. 0 \\<le> real (min k 1 * (n - 1 choose (k - 1)))\n 6. 0 \\<le> real_of_int \\<bar>lead_coeff g\\<bar>", "thus \"mahler_measure g \\<le> mahler_measure f\""], ["proof (prove)\nusing this:\n  mahler_measure g \\<le> mahler_measure g * mahler_measure h\n\ngoal (1 subgoal):\n 1. mahler_measure g \\<le> mahler_measure f", "using measure_eq_prod[of \"of_int_poly g\" \"of_int_poly h\"]"], ["proof (prove)\nusing this:\n  mahler_measure g \\<le> mahler_measure g * mahler_measure h\n  mahler_measure_poly (of_int_poly g * of_int_poly h) =\n  mahler_measure_poly (of_int_poly g) * mahler_measure_poly (of_int_poly h)\n\ngoal (1 subgoal):\n 1. mahler_measure g \\<le> mahler_measure f", "unfolding mahler_measure_def gh[symmetric]"], ["proof (prove)\nusing this:\n  mahler_measure_poly (of_int_poly g)\n  \\<le> mahler_measure_poly (of_int_poly g) *\n        mahler_measure_poly (of_int_poly h)\n  mahler_measure_poly (of_int_poly g * of_int_poly h) =\n  mahler_measure_poly (of_int_poly g) * mahler_measure_poly (of_int_poly h)\n\ngoal (1 subgoal):\n 1. mahler_measure_poly (of_int_poly g)\n    \\<le> mahler_measure_poly (of_int_poly (g * h))", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  mahler_measure g \\<le> mahler_measure f\n\ngoal (5 subgoals):\n 1. 0 \\<le> real (n - 1 choose k)\n 2. 0 \\<le> mahler_measure g\n 3. real_of_int \\<bar>lead_coeff g\\<bar>\n    \\<le> real_of_int \\<bar>lead_coeff f\\<bar>\n 4. 0 \\<le> real (min k 1 * (n - 1 choose (k - 1)))\n 5. 0 \\<le> real_of_int \\<bar>lead_coeff g\\<bar>", "have *: \"lead_coeff f = lead_coeff g * lead_coeff h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff f = lead_coeff g * lead_coeff h", "unfolding arg_cong[OF gh, of lead_coeff, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (g * h) = lead_coeff g * lead_coeff h", "by (rule lead_coeff_mult)"], ["proof (state)\nthis:\n  lead_coeff f = lead_coeff g * lead_coeff h\n\ngoal (5 subgoals):\n 1. 0 \\<le> real (n - 1 choose k)\n 2. 0 \\<le> mahler_measure g\n 3. real_of_int \\<bar>lead_coeff g\\<bar>\n    \\<le> real_of_int \\<bar>lead_coeff f\\<bar>\n 4. 0 \\<le> real (min k 1 * (n - 1 choose (k - 1)))\n 5. 0 \\<le> real_of_int \\<bar>lead_coeff g\\<bar>", "have \"\\<bar>lead_coeff h\\<bar> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>lead_coeff h\\<bar> \\<noteq> 0", "using nz(2)"], ["proof (prove)\nusing this:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>lead_coeff h\\<bar> \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<bar>lead_coeff h\\<bar> \\<noteq> 0\n\ngoal (5 subgoals):\n 1. 0 \\<le> real (n - 1 choose k)\n 2. 0 \\<le> mahler_measure g\n 3. real_of_int \\<bar>lead_coeff g\\<bar>\n    \\<le> real_of_int \\<bar>lead_coeff f\\<bar>\n 4. 0 \\<le> real (min k 1 * (n - 1 choose (k - 1)))\n 5. 0 \\<le> real_of_int \\<bar>lead_coeff g\\<bar>", "hence lh: \"\\<bar>lead_coeff h\\<bar> \\<ge> 1\""], ["proof (prove)\nusing this:\n  \\<bar>lead_coeff h\\<bar> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<bar>lead_coeff h\\<bar>", "by linarith"], ["proof (state)\nthis:\n  1 \\<le> \\<bar>lead_coeff h\\<bar>\n\ngoal (5 subgoals):\n 1. 0 \\<le> real (n - 1 choose k)\n 2. 0 \\<le> mahler_measure g\n 3. real_of_int \\<bar>lead_coeff g\\<bar>\n    \\<le> real_of_int \\<bar>lead_coeff f\\<bar>\n 4. 0 \\<le> real (min k 1 * (n - 1 choose (k - 1)))\n 5. 0 \\<le> real_of_int \\<bar>lead_coeff g\\<bar>", "have \"\\<bar>lead_coeff f\\<bar> = \\<bar>lead_coeff g\\<bar> * \\<bar>lead_coeff h\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>lead_coeff f\\<bar> =\n    \\<bar>lead_coeff g\\<bar> * \\<bar>lead_coeff h\\<bar>", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>lead_coeff g * lead_coeff h\\<bar> =\n    \\<bar>lead_coeff g\\<bar> * \\<bar>lead_coeff h\\<bar>", "by (rule abs_mult)"], ["proof (state)\nthis:\n  \\<bar>lead_coeff f\\<bar> =\n  \\<bar>lead_coeff g\\<bar> * \\<bar>lead_coeff h\\<bar>\n\ngoal (5 subgoals):\n 1. 0 \\<le> real (n - 1 choose k)\n 2. 0 \\<le> mahler_measure g\n 3. real_of_int \\<bar>lead_coeff g\\<bar>\n    \\<le> real_of_int \\<bar>lead_coeff f\\<bar>\n 4. 0 \\<le> real (min k 1 * (n - 1 choose (k - 1)))\n 5. 0 \\<le> real_of_int \\<bar>lead_coeff g\\<bar>", "also"], ["proof (state)\nthis:\n  \\<bar>lead_coeff f\\<bar> =\n  \\<bar>lead_coeff g\\<bar> * \\<bar>lead_coeff h\\<bar>\n\ngoal (5 subgoals):\n 1. 0 \\<le> real (n - 1 choose k)\n 2. 0 \\<le> mahler_measure g\n 3. real_of_int \\<bar>lead_coeff g\\<bar>\n    \\<le> real_of_int \\<bar>lead_coeff f\\<bar>\n 4. 0 \\<le> real (min k 1 * (n - 1 choose (k - 1)))\n 5. 0 \\<le> real_of_int \\<bar>lead_coeff g\\<bar>", "have \"\\<dots> \\<ge> \\<bar>lead_coeff g\\<bar> * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>lead_coeff g\\<bar> * 1\n    \\<le> \\<bar>lead_coeff g\\<bar> * \\<bar>lead_coeff h\\<bar>", "by (rule mult_mono, insert lh, auto)"], ["proof (state)\nthis:\n  \\<bar>lead_coeff g\\<bar> * 1\n  \\<le> \\<bar>lead_coeff g\\<bar> * \\<bar>lead_coeff h\\<bar>\n\ngoal (5 subgoals):\n 1. 0 \\<le> real (n - 1 choose k)\n 2. 0 \\<le> mahler_measure g\n 3. real_of_int \\<bar>lead_coeff g\\<bar>\n    \\<le> real_of_int \\<bar>lead_coeff f\\<bar>\n 4. 0 \\<le> real (min k 1 * (n - 1 choose (k - 1)))\n 5. 0 \\<le> real_of_int \\<bar>lead_coeff g\\<bar>", "finally"], ["proof (chain)\npicking this:\n  \\<bar>lead_coeff g\\<bar> * 1 \\<le> \\<bar>lead_coeff f\\<bar>", "have \"\\<bar>lead_coeff g\\<bar> \\<le> \\<bar>lead_coeff f\\<bar>\""], ["proof (prove)\nusing this:\n  \\<bar>lead_coeff g\\<bar> * 1 \\<le> \\<bar>lead_coeff f\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>lead_coeff g\\<bar> \\<le> \\<bar>lead_coeff f\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>lead_coeff g\\<bar> \\<le> \\<bar>lead_coeff f\\<bar>\n\ngoal (5 subgoals):\n 1. 0 \\<le> real (n - 1 choose k)\n 2. 0 \\<le> mahler_measure g\n 3. real_of_int \\<bar>lead_coeff g\\<bar>\n    \\<le> real_of_int \\<bar>lead_coeff f\\<bar>\n 4. 0 \\<le> real (min k 1 * (n - 1 choose (k - 1)))\n 5. 0 \\<le> real_of_int \\<bar>lead_coeff g\\<bar>", "thus \"real_of_int \\<bar>lead_coeff g\\<bar> \\<le> real_of_int \\<bar>lead_coeff f\\<bar>\""], ["proof (prove)\nusing this:\n  \\<bar>lead_coeff g\\<bar> \\<le> \\<bar>lead_coeff f\\<bar>\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>lead_coeff g\\<bar>\n    \\<le> real_of_int \\<bar>lead_coeff f\\<bar>", "by simp"], ["proof (state)\nthis:\n  real_of_int \\<bar>lead_coeff g\\<bar>\n  \\<le> real_of_int \\<bar>lead_coeff f\\<bar>\n\ngoal (4 subgoals):\n 1. 0 \\<le> real (n - 1 choose k)\n 2. 0 \\<le> mahler_measure g\n 3. 0 \\<le> real (min k 1 * (n - 1 choose (k - 1)))\n 4. 0 \\<le> real_of_int \\<bar>lead_coeff g\\<bar>", "qed (auto simp: g0)"], ["proof (state)\nthis:\n  real (degree g - 1 choose k) * mahler_measure g +\n  real (min k 1 * (degree g - 1 choose (k - 1))) *\n  real_of_int \\<bar>lead_coeff g\\<bar>\n  \\<le> real (n - 1 choose k) * mahler_measure f +\n        real (min k 1 * (n - 1 choose (k - 1))) *\n        real_of_int \\<bar>lead_coeff f\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "finally"], ["proof (chain)\npicking this:\n  real_of_int \\<bar>poly.coeff g k\\<bar>\n  \\<le> real (n - 1 choose k) * mahler_measure f +\n        real (min k 1 * (n - 1 choose (k - 1))) *\n        real_of_int \\<bar>lead_coeff f\\<bar>", "have \"\\<bar>coeff g k\\<bar> \\<le> ?n * mahler_measure f + real_of_int (?n' * \\<bar>lead_coeff f\\<bar>)\""], ["proof (prove)\nusing this:\n  real_of_int \\<bar>poly.coeff g k\\<bar>\n  \\<le> real (n - 1 choose k) * mahler_measure f +\n        real (min k 1 * (n - 1 choose (k - 1))) *\n        real_of_int \\<bar>lead_coeff f\\<bar>\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (n - 1 choose k) * mahler_measure f +\n          real_of_int\n           (int (min k 1 * (n - 1 choose (k - 1))) *\n            \\<bar>lead_coeff f\\<bar>)", "by simp"], ["proof (state)\nthis:\n  real_of_int \\<bar>poly.coeff g k\\<bar>\n  \\<le> real (n - 1 choose k) * mahler_measure f +\n        real_of_int\n         (int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "from floor_mono[OF this, folded floor_add_int]"], ["proof (chain)\npicking this:\n  \\<lfloor>real_of_int \\<bar>poly.coeff g k\\<bar>\\<rfloor>\n  \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n        int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "have \"\\<bar>coeff g k\\<bar> \\<le> floor (?n * mahler_measure f) + ?n' * \\<bar>lead_coeff f\\<bar>\""], ["proof (prove)\nusing this:\n  \\<lfloor>real_of_int \\<bar>poly.coeff g k\\<bar>\\<rfloor>\n  \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n        int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "by linarith"], ["proof (state)\nthis:\n  \\<bar>poly.coeff g k\\<bar>\n  \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n        int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>poly.coeff g k\\<bar>\n  \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n        int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "unfolding mignotte_bound_def Let_def"], ["proof (prove)\nusing this:\n  \\<bar>poly.coeff g k\\<bar>\n  \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n        int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "using mahler_approximation[of ?n f ?bnd]"], ["proof (prove)\nusing this:\n  \\<bar>poly.coeff g k\\<bar>\n  \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n        int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>\n  \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor>\n  \\<le> mahler_approximation 2 (n - 1 choose k) f\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "by auto"], ["proof (state)\nthis:\n  \\<bar>poly.coeff g k\\<bar>\n  \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n        int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Mignotte_bound: \n  shows \"of_int \\<bar>coeff g k\\<bar> \\<le> (degree g choose k) * mahler_measure g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "proof (cases \"k \\<le> degree g \\<and> g \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<le> degree g \\<and> g \\<noteq> 0 \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g\n 2. \\<not> (k \\<le> degree g \\<and> g \\<noteq> 0) \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "case False"], ["proof (state)\nthis:\n  \\<not> (k \\<le> degree g \\<and> g \\<noteq> 0)\n\ngoal (2 subgoals):\n 1. k \\<le> degree g \\<and> g \\<noteq> 0 \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g\n 2. \\<not> (k \\<le> degree g \\<and> g \\<noteq> 0) \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "hence \"coeff g k = 0\""], ["proof (prove)\nusing this:\n  \\<not> (k \\<le> degree g \\<and> g \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. poly.coeff g k = 0", "using le_degree"], ["proof (prove)\nusing this:\n  \\<not> (k \\<le> degree g \\<and> g \\<noteq> 0)\n  poly.coeff ?p ?n \\<noteq> (0::?'a) \\<Longrightarrow> ?n \\<le> degree ?p\n\ngoal (1 subgoal):\n 1. poly.coeff g k = 0", "by (cases \"g = 0\", auto)"], ["proof (state)\nthis:\n  poly.coeff g k = 0\n\ngoal (2 subgoals):\n 1. k \\<le> degree g \\<and> g \\<noteq> 0 \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g\n 2. \\<not> (k \\<le> degree g \\<and> g \\<noteq> 0) \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "thus ?thesis"], ["proof (prove)\nusing this:\n  poly.coeff g k = 0\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "using mahler_measure_ge_0[of g]"], ["proof (prove)\nusing this:\n  poly.coeff g k = 0\n  0 \\<le> mahler_measure g\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "by auto"], ["proof (state)\nthis:\n  real_of_int \\<bar>poly.coeff g k\\<bar>\n  \\<le> real (degree g choose k) * mahler_measure g\n\ngoal (1 subgoal):\n 1. k \\<le> degree g \\<and> g \\<noteq> 0 \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<le> degree g \\<and> g \\<noteq> 0 \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "case kg: True"], ["proof (state)\nthis:\n  k \\<le> degree g \\<and> g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<le> degree g \\<and> g \\<noteq> 0 \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "hence g: \"g \\<noteq> 0\" \"g dvd g\""], ["proof (prove)\nusing this:\n  k \\<le> degree g \\<and> g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0 &&& g dvd g", "by auto"], ["proof (state)\nthis:\n  g \\<noteq> 0\n  g dvd g\n\ngoal (1 subgoal):\n 1. k \\<le> degree g \\<and> g \\<noteq> 0 \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "from mignotte_bound_main[OF g le_refl, of k]"], ["proof (chain)\npicking this:\n  \\<bar>poly.coeff g k\\<bar>\n  \\<le> \\<lfloor>real (degree g - 1 choose k) * mahler_measure g\\<rfloor> +\n        int (min k 1 * (degree g - 1 choose (k - 1))) *\n        \\<bar>lead_coeff g\\<bar>", "have \"real_of_int \\<bar>coeff g k\\<bar>\n    \\<le> of_int \\<lfloor>real (degree g - 1 choose k) * mahler_measure g\\<rfloor> +\n      of_int (int (min k 1 * (degree g - 1 choose (k - 1))) * \\<bar>lead_coeff g\\<bar>)\""], ["proof (prove)\nusing this:\n  \\<bar>poly.coeff g k\\<bar>\n  \\<le> \\<lfloor>real (degree g - 1 choose k) * mahler_measure g\\<rfloor> +\n        int (min k 1 * (degree g - 1 choose (k - 1))) *\n        \\<bar>lead_coeff g\\<bar>\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real_of_int\n           \\<lfloor>real (degree g - 1 choose k) *\n                    mahler_measure g\\<rfloor> +\n          real_of_int\n           (int (min k 1 * (degree g - 1 choose (k - 1))) *\n            \\<bar>lead_coeff g\\<bar>)", "by linarith"], ["proof (state)\nthis:\n  real_of_int \\<bar>poly.coeff g k\\<bar>\n  \\<le> real_of_int\n         \\<lfloor>real (degree g - 1 choose k) * mahler_measure g\\<rfloor> +\n        real_of_int\n         (int (min k 1 * (degree g - 1 choose (k - 1))) *\n          \\<bar>lead_coeff g\\<bar>)\n\ngoal (1 subgoal):\n 1. k \\<le> degree g \\<and> g \\<noteq> 0 \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "also"], ["proof (state)\nthis:\n  real_of_int \\<bar>poly.coeff g k\\<bar>\n  \\<le> real_of_int\n         \\<lfloor>real (degree g - 1 choose k) * mahler_measure g\\<rfloor> +\n        real_of_int\n         (int (min k 1 * (degree g - 1 choose (k - 1))) *\n          \\<bar>lead_coeff g\\<bar>)\n\ngoal (1 subgoal):\n 1. k \\<le> degree g \\<and> g \\<noteq> 0 \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "have \"\\<dots> \\<le> real (degree g - 1 choose k) * mahler_measure g \n     + real (min k 1 * (degree g - 1 choose (k - 1))) * (of_int \\<bar>lead_coeff g\\<bar> * 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int\n     \\<lfloor>real (degree g - 1 choose k) * mahler_measure g\\<rfloor> +\n    real_of_int\n     (int (min k 1 * (degree g - 1 choose (k - 1))) *\n      \\<bar>lead_coeff g\\<bar>)\n    \\<le> real (degree g - 1 choose k) * mahler_measure g +\n          real (min k 1 * (degree g - 1 choose (k - 1))) *\n          (real_of_int \\<bar>lead_coeff g\\<bar> * 1)", "by (rule add_mono, force, auto)"], ["proof (state)\nthis:\n  real_of_int\n   \\<lfloor>real (degree g - 1 choose k) * mahler_measure g\\<rfloor> +\n  real_of_int\n   (int (min k 1 * (degree g - 1 choose (k - 1))) *\n    \\<bar>lead_coeff g\\<bar>)\n  \\<le> real (degree g - 1 choose k) * mahler_measure g +\n        real (min k 1 * (degree g - 1 choose (k - 1))) *\n        (real_of_int \\<bar>lead_coeff g\\<bar> * 1)\n\ngoal (1 subgoal):\n 1. k \\<le> degree g \\<and> g \\<noteq> 0 \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "also"], ["proof (state)\nthis:\n  real_of_int\n   \\<lfloor>real (degree g - 1 choose k) * mahler_measure g\\<rfloor> +\n  real_of_int\n   (int (min k 1 * (degree g - 1 choose (k - 1))) *\n    \\<bar>lead_coeff g\\<bar>)\n  \\<le> real (degree g - 1 choose k) * mahler_measure g +\n        real (min k 1 * (degree g - 1 choose (k - 1))) *\n        (real_of_int \\<bar>lead_coeff g\\<bar> * 1)\n\ngoal (1 subgoal):\n 1. k \\<le> degree g \\<and> g \\<noteq> 0 \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "have \"\\<dots> \\<le> real (degree g - 1 choose k) * mahler_measure g \n     + real (min k 1 * (degree g - 1 choose (k - 1))) * mahler_measure g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (degree g - 1 choose k) * mahler_measure g +\n    real (min k 1 * (degree g - 1 choose (k - 1))) *\n    (real_of_int \\<bar>lead_coeff g\\<bar> * 1)\n    \\<le> real (degree g - 1 choose k) * mahler_measure g +\n          real (min k 1 * (degree g - 1 choose (k - 1))) * mahler_measure g", "by (rule add_left_mono[OF mult_left_mono], \n    unfold mahler_measure_def mahler_measure_poly_def,\n    rule mult_mono, auto intro!: prod_list_ge1)"], ["proof (state)\nthis:\n  real (degree g - 1 choose k) * mahler_measure g +\n  real (min k 1 * (degree g - 1 choose (k - 1))) *\n  (real_of_int \\<bar>lead_coeff g\\<bar> * 1)\n  \\<le> real (degree g - 1 choose k) * mahler_measure g +\n        real (min k 1 * (degree g - 1 choose (k - 1))) * mahler_measure g\n\ngoal (1 subgoal):\n 1. k \\<le> degree g \\<and> g \\<noteq> 0 \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "also"], ["proof (state)\nthis:\n  real (degree g - 1 choose k) * mahler_measure g +\n  real (min k 1 * (degree g - 1 choose (k - 1))) *\n  (real_of_int \\<bar>lead_coeff g\\<bar> * 1)\n  \\<le> real (degree g - 1 choose k) * mahler_measure g +\n        real (min k 1 * (degree g - 1 choose (k - 1))) * mahler_measure g\n\ngoal (1 subgoal):\n 1. k \\<le> degree g \\<and> g \\<noteq> 0 \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "have \"\\<dots> = \n    (real ((degree g - 1 choose k) + (min k 1 * (degree g - 1 choose (k - 1))))) * mahler_measure g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (degree g - 1 choose k) * mahler_measure g +\n    real (min k 1 * (degree g - 1 choose (k - 1))) * mahler_measure g =\n    real (degree g - 1 choose k + min k 1 * (degree g - 1 choose (k - 1))) *\n    mahler_measure g", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  real (degree g - 1 choose k) * mahler_measure g +\n  real (min k 1 * (degree g - 1 choose (k - 1))) * mahler_measure g =\n  real (degree g - 1 choose k + min k 1 * (degree g - 1 choose (k - 1))) *\n  mahler_measure g\n\ngoal (1 subgoal):\n 1. k \\<le> degree g \\<and> g \\<noteq> 0 \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "also"], ["proof (state)\nthis:\n  real (degree g - 1 choose k) * mahler_measure g +\n  real (min k 1 * (degree g - 1 choose (k - 1))) * mahler_measure g =\n  real (degree g - 1 choose k + min k 1 * (degree g - 1 choose (k - 1))) *\n  mahler_measure g\n\ngoal (1 subgoal):\n 1. k \\<le> degree g \\<and> g \\<noteq> 0 \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "have \"(degree g - 1 choose k) + (min k 1 * (degree g - 1 choose (k - 1))) = degree g choose k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree g - 1 choose k + min k 1 * (degree g - 1 choose (k - 1)) =\n    degree g choose k", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    degree g - 1 choose k + min k 1 * (degree g - 1 choose (k - 1)) =\n    degree g choose k\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    degree g - 1 choose k + min k 1 * (degree g - 1 choose (k - 1)) =\n    degree g choose k", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    degree g - 1 choose k + min k 1 * (degree g - 1 choose (k - 1)) =\n    degree g choose k\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    degree g - 1 choose k + min k 1 * (degree g - 1 choose (k - 1)) =\n    degree g choose k", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 0", "obtain kk where k: \"k = Suc kk\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>kk. k = Suc kk \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases k, auto)"], ["proof (state)\nthis:\n  k = Suc kk\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    degree g - 1 choose k + min k 1 * (degree g - 1 choose (k - 1)) =\n    degree g choose k\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    degree g - 1 choose k + min k 1 * (degree g - 1 choose (k - 1)) =\n    degree g choose k", "with kg"], ["proof (chain)\npicking this:\n  k \\<le> degree g \\<and> g \\<noteq> 0\n  k = Suc kk", "obtain gg where g: \"degree g = Suc gg\""], ["proof (prove)\nusing this:\n  k \\<le> degree g \\<and> g \\<noteq> 0\n  k = Suc kk\n\ngoal (1 subgoal):\n 1. (\\<And>gg. degree g = Suc gg \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"degree g\", auto)"], ["proof (state)\nthis:\n  degree g = Suc gg\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    degree g - 1 choose k + min k 1 * (degree g - 1 choose (k - 1)) =\n    degree g choose k\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    degree g - 1 choose k + min k 1 * (degree g - 1 choose (k - 1)) =\n    degree g choose k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree g - 1 choose k + min k 1 * (degree g - 1 choose (k - 1)) =\n    degree g choose k", "unfolding k g"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc gg - 1 choose Suc kk +\n    min (Suc kk) 1 * (Suc gg - 1 choose (Suc kk - 1)) =\n    Suc gg choose Suc kk", "by auto"], ["proof (state)\nthis:\n  degree g - 1 choose k + min k 1 * (degree g - 1 choose (k - 1)) =\n  degree g choose k\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow>\n    degree g - 1 choose k + min k 1 * (degree g - 1 choose (k - 1)) =\n    degree g choose k", "qed auto"], ["proof (state)\nthis:\n  degree g - 1 choose k + min k 1 * (degree g - 1 choose (k - 1)) =\n  degree g choose k\n\ngoal (1 subgoal):\n 1. k \\<le> degree g \\<and> g \\<noteq> 0 \\<Longrightarrow>\n    real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "finally"], ["proof (chain)\npicking this:\n  real_of_int \\<bar>poly.coeff g k\\<bar>\n  \\<le> real (degree g choose k) * mahler_measure g", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int \\<bar>poly.coeff g k\\<bar>\n  \\<le> real (degree g choose k) * mahler_measure g\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>poly.coeff g k\\<bar>\n    \\<le> real (degree g choose k) * mahler_measure g", "."], ["proof (state)\nthis:\n  real_of_int \\<bar>poly.coeff g k\\<bar>\n  \\<le> real (degree g choose k) * mahler_measure g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mignotte_bound:  \n  assumes \"f \\<noteq> 0\" \"g dvd f\" \"degree g \\<le> n\"\n  shows \"\\<bar>coeff g k\\<bar> \\<le> mignotte_bound f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> mignotte_bound f n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> mignotte_bound f n", "let ?bnd = 2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> mignotte_bound f n", "let ?n = \"(n - 1) choose ((n - 1) div 2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> mignotte_bound f n", "have to_n: \"(n - 1 choose k) \\<le> real ?n\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (n - 1 choose k) \\<le> real (n - 1 choose (n - 1) div 2)", "using choose_approx[OF le_refl]"], ["proof (prove)\nusing this:\n  ?N choose ?k \\<le> ?N choose ?N div 2\n\ngoal (1 subgoal):\n 1. real (n - 1 choose k) \\<le> real (n - 1 choose (n - 1) div 2)", "by auto"], ["proof (state)\nthis:\n  real (n - 1 choose ?k1) \\<le> real (n - 1 choose (n - 1) div 2)\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> mignotte_bound f n", "from mignotte_bound_main[OF assms, of k]"], ["proof (chain)\npicking this:\n  \\<bar>poly.coeff g k\\<bar>\n  \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n        int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "have \"\\<bar>coeff g k\\<bar> \\<le> \n    \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> + \n    int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>\""], ["proof (prove)\nusing this:\n  \\<bar>poly.coeff g k\\<bar>\n  \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n        int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>", "."], ["proof (state)\nthis:\n  \\<bar>poly.coeff g k\\<bar>\n  \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n        int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> mignotte_bound f n", "also"], ["proof (state)\nthis:\n  \\<bar>poly.coeff g k\\<bar>\n  \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n        int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> mignotte_bound f n", "have \"\\<dots> \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> + \n    int ((n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n    int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>\n    \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n          int (n - 1 choose (k - 1)) * \\<bar>lead_coeff f\\<bar>", "by (rule add_left_mono[OF mult_right_mono], cases k, auto)"], ["proof (state)\nthis:\n  \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n  int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>\n  \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n        int (n - 1 choose (k - 1)) * \\<bar>lead_coeff f\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> mignotte_bound f n", "also"], ["proof (state)\nthis:\n  \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n  int (min k 1 * (n - 1 choose (k - 1))) * \\<bar>lead_coeff f\\<bar>\n  \\<le> \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n        int (n - 1 choose (k - 1)) * \\<bar>lead_coeff f\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> mignotte_bound f n", "have \"\\<dots> \\<le> mignotte_bound f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n    int (n - 1 choose (k - 1)) * \\<bar>lead_coeff f\\<bar>\n    \\<le> mignotte_bound f n", "unfolding mignotte_bound_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n    int (n - 1 choose (k - 1)) * \\<bar>lead_coeff f\\<bar>\n    \\<le> mahler_approximation 2 (n - 1 choose (n - 1) div 2) f +\n          int (n - 1 choose (n - 1) div 2) * \\<bar>lead_coeff f\\<bar>", "by (rule add_mono[OF order.trans[OF floor_mono[OF mult_right_mono] \n    mahler_approximation[of ?n f ?bnd]] mult_right_mono], insert to_n mahler_measure_ge_0, auto)"], ["proof (state)\nthis:\n  \\<lfloor>real (n - 1 choose k) * mahler_measure f\\<rfloor> +\n  int (n - 1 choose (k - 1)) * \\<bar>lead_coeff f\\<bar>\n  \\<le> mignotte_bound f n\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> mignotte_bound f n", "finally"], ["proof (chain)\npicking this:\n  \\<bar>poly.coeff g k\\<bar> \\<le> mignotte_bound f n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>poly.coeff g k\\<bar> \\<le> mignotte_bound f n\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> mignotte_bound f n", "."], ["proof (state)\nthis:\n  \\<bar>poly.coeff g k\\<bar> \\<le> mignotte_bound f n\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>As indicated before, at the moment the only available factor bound is Mignotte's one.\n  As future work one might use a combined bound.\\<close>"], ["", "definition factor_bound :: \"int poly \\<Rightarrow> nat \\<Rightarrow> int\" where\n  \"factor_bound = mignotte_bound\""], ["", "lemma factor_bound: assumes \"f \\<noteq> 0\" \"g dvd f\" \"degree g \\<le> n\"\n  shows \"\\<bar>coeff g k\\<bar> \\<le> factor_bound f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> factor_bound f n", "unfolding factor_bound_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> mignotte_bound f n", "by (rule mignotte_bound[OF assms])"], ["", "text \\<open>We further prove a result for factor bounds and scalar multiplication.\\<close>"], ["", "lemma factor_bound_ge_0: \"f \\<noteq> 0 \\<Longrightarrow> factor_bound f n \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> 0 \\<le> factor_bound f n", "using factor_bound[of f 1 n 0]"], ["proof (prove)\nusing this:\n  \\<lbrakk>f \\<noteq> 0; 1 dvd f; degree 1 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> \\<bar>poly.coeff 1 0\\<bar> \\<le> factor_bound f n\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> 0 \\<le> factor_bound f n", "by auto"], ["", "lemma factor_bound_smult: assumes f: \"f \\<noteq> 0\" and d: \"d \\<noteq> 0\" \n  and dvd: \"g dvd smult d f\" and deg: \"degree g \\<le> n\" \n  shows \"\\<bar>coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "let ?nf = \"primitive_part f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "let ?cf = \"content f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "let ?ng = \"primitive_part g\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "let ?cg = \"content g\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "from content_dvd_contentI[OF dvd]"], ["proof (chain)\npicking this:\n  content g dvd content (Polynomial.smult d f)", "have \"?cg dvd abs d * ?cf\""], ["proof (prove)\nusing this:\n  content g dvd content (Polynomial.smult d f)\n\ngoal (1 subgoal):\n 1. content g dvd \\<bar>d\\<bar> * content f", "unfolding content_smult_int"], ["proof (prove)\nusing this:\n  content g dvd \\<bar>d\\<bar> * content f\n\ngoal (1 subgoal):\n 1. content g dvd \\<bar>d\\<bar> * content f", "."], ["proof (state)\nthis:\n  content g dvd \\<bar>d\\<bar> * content f\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "hence dvd_c: \"?cg dvd d * ?cf\""], ["proof (prove)\nusing this:\n  content g dvd \\<bar>d\\<bar> * content f\n\ngoal (1 subgoal):\n 1. content g dvd d * content f", "using d"], ["proof (prove)\nusing this:\n  content g dvd \\<bar>d\\<bar> * content f\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. content g dvd d * content f", "by (metis abs_content_int abs_mult dvd_abs_iff)"], ["proof (state)\nthis:\n  content g dvd d * content f\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "from primitive_part_dvd_primitive_partI[OF dvd]"], ["proof (chain)\npicking this:\n  primitive_part g dvd primitive_part (Polynomial.smult d f)", "have \"?ng dvd smult (sgn d) ?nf\""], ["proof (prove)\nusing this:\n  primitive_part g dvd primitive_part (Polynomial.smult d f)\n\ngoal (1 subgoal):\n 1. primitive_part g dvd Polynomial.smult (sgn d) (primitive_part f)", "unfolding primitive_part_smult_int"], ["proof (prove)\nusing this:\n  primitive_part g dvd Polynomial.smult (sgn d) (primitive_part f)\n\ngoal (1 subgoal):\n 1. primitive_part g dvd Polynomial.smult (sgn d) (primitive_part f)", "."], ["proof (state)\nthis:\n  primitive_part g dvd Polynomial.smult (sgn d) (primitive_part f)\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "hence dvd_n: \"?ng dvd ?nf\""], ["proof (prove)\nusing this:\n  primitive_part g dvd Polynomial.smult (sgn d) (primitive_part f)\n\ngoal (1 subgoal):\n 1. primitive_part g dvd primitive_part f", "using d"], ["proof (prove)\nusing this:\n  primitive_part g dvd Polynomial.smult (sgn d) (primitive_part f)\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. primitive_part g dvd primitive_part f", "by (metis content_eq_zero_iff dvd dvd_smult_int f mult_eq_0_iff content_times_primitive_part smult_smult)"], ["proof (state)\nthis:\n  primitive_part g dvd primitive_part f\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "define gc where \"gc = gcd ?cf ?cg\""], ["proof (state)\nthis:\n  gc = gcd (content f) (content g)\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "define cg where \"cg = ?cg div gc\""], ["proof (state)\nthis:\n  cg = content g div gc\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "from dvd d f"], ["proof (chain)\npicking this:\n  g dvd Polynomial.smult d f\n  d \\<noteq> 0\n  f \\<noteq> 0", "have g: \"g \\<noteq> 0\""], ["proof (prove)\nusing this:\n  g dvd Polynomial.smult d f\n  d \\<noteq> 0\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "from f"], ["proof (chain)\npicking this:\n  f \\<noteq> 0", "have cf: \"?cf \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. content f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  content f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "from g"], ["proof (chain)\npicking this:\n  g \\<noteq> 0", "have cg: \"?cg \\<noteq> 0\""], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. content g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  content g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "hence gc: \"gc \\<noteq> 0\""], ["proof (prove)\nusing this:\n  content g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gc \\<noteq> 0", "unfolding gc_def"], ["proof (prove)\nusing this:\n  content g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd (content f) (content g) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  gc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "have cg_dvd: \"cg dvd ?cg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cg dvd content g", "unfolding cg_def gc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. content g div gcd (content f) (content g) dvd content g", "using g"], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. content g div gcd (content f) (content g) dvd content g", "by (simp add: div_dvd_iff_mult)"], ["proof (state)\nthis:\n  cg dvd content g\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "have cg_id: \"?cg = cg * gc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content g = cg * gc", "unfolding gc_def cg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. content g =\n    content g div gcd (content f) (content g) * gcd (content f) (content g)", "using g cf"], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n  content f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. content g =\n    content g div gcd (content f) (content g) * gcd (content f) (content g)", "by simp"], ["proof (state)\nthis:\n  content g = cg * gc\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "from dvd_smult_int[OF d dvd]"], ["proof (chain)\npicking this:\n  primitive_part g dvd f", "have ngf: \"?ng dvd f\""], ["proof (prove)\nusing this:\n  primitive_part g dvd f\n\ngoal (1 subgoal):\n 1. primitive_part g dvd f", "."], ["proof (state)\nthis:\n  primitive_part g dvd f\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "have gcf: \"\\<bar>gc\\<bar> dvd content f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>gc\\<bar> dvd content f", "unfolding gc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>gcd (content f) (content g)\\<bar> dvd content f", "by auto"], ["proof (state)\nthis:\n  \\<bar>gc\\<bar> dvd content f\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "have dvd_f: \"smult gc ?ng dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult gc (primitive_part g) dvd f", "proof (rule dvd_content_dvd, \n      unfold content_smult_int content_primitive_part[OF g] \n      primitive_part_smult_int primitive_part_idemp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<bar>gc\\<bar> * 1 dvd content f\n 2. Polynomial.smult (sgn gc) (primitive_part g) dvd primitive_part f", "show \"\\<bar>gc\\<bar> * 1 dvd content f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>gc\\<bar> * 1 dvd content f", "using gcf"], ["proof (prove)\nusing this:\n  \\<bar>gc\\<bar> dvd content f\n\ngoal (1 subgoal):\n 1. \\<bar>gc\\<bar> * 1 dvd content f", "by auto"], ["proof (state)\nthis:\n  \\<bar>gc\\<bar> * 1 dvd content f\n\ngoal (1 subgoal):\n 1. Polynomial.smult (sgn gc) (primitive_part g) dvd primitive_part f", "show \"smult (sgn gc) (primitive_part g) dvd primitive_part f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (sgn gc) (primitive_part g) dvd primitive_part f", "using dvd_n cf gc"], ["proof (prove)\nusing this:\n  primitive_part g dvd primitive_part f\n  content f \\<noteq> 0\n  gc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Polynomial.smult (sgn gc) (primitive_part g) dvd primitive_part f", "using zsgn_def"], ["proof (prove)\nusing this:\n  primitive_part g dvd primitive_part f\n  content f \\<noteq> 0\n  gc \\<noteq> 0\n  sgn ?i = (if ?i = 0 then 0 else if 0 < ?i then 1 else - 1)\n\ngoal (1 subgoal):\n 1. Polynomial.smult (sgn gc) (primitive_part g) dvd primitive_part f", "by force"], ["proof (state)\nthis:\n  Polynomial.smult (sgn gc) (primitive_part g) dvd primitive_part f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Polynomial.smult gc (primitive_part g) dvd f\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "have \"cg dvd d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cg dvd d", "using dvd_c"], ["proof (prove)\nusing this:\n  content g dvd d * content f\n\ngoal (1 subgoal):\n 1. cg dvd d", "unfolding gc_def cg_def"], ["proof (prove)\nusing this:\n  content g dvd d * content f\n\ngoal (1 subgoal):\n 1. content g div gcd (content f) (content g) dvd d", "using cf cg d"], ["proof (prove)\nusing this:\n  content g dvd d * content f\n  content f \\<noteq> 0\n  content g \\<noteq> 0\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. content g div gcd (content f) (content g) dvd d", "by (simp add: div_dvd_iff_mult dvd_gcd_mult)"], ["proof (state)\nthis:\n  cg dvd d\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "then"], ["proof (chain)\npicking this:\n  cg dvd d", "obtain h where dcg: \"d = cg * h\""], ["proof (prove)\nusing this:\n  cg dvd d\n\ngoal (1 subgoal):\n 1. (\\<And>h. d = cg * h \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. d = cg * k\n\ngoal (1 subgoal):\n 1. (\\<And>h. d = cg * h \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  d = cg * h\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "with d"], ["proof (chain)\npicking this:\n  d \\<noteq> 0\n  d = cg * h", "have \"h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n  d = cg * h\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "hence h1: \"\\<bar>h\\<bar> \\<ge> 1\""], ["proof (prove)\nusing this:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<bar>h\\<bar>", "by simp"], ["proof (state)\nthis:\n  1 \\<le> \\<bar>h\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "have \"degree (smult gc (primitive_part g)) = degree g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Polynomial.smult gc (primitive_part g)) = degree g", "using gc"], ["proof (prove)\nusing this:\n  gc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (Polynomial.smult gc (primitive_part g)) = degree g", "by auto"], ["proof (state)\nthis:\n  degree (Polynomial.smult gc (primitive_part g)) = degree g\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "from factor_bound[OF f dvd_f, unfolded this, OF deg, of k, unfolded coeff_smult]"], ["proof (chain)\npicking this:\n  \\<bar>gc * poly.coeff (primitive_part g) k\\<bar> \\<le> factor_bound f n", "have le: \"\\<bar>gc * coeff ?ng k\\<bar> \\<le> factor_bound f n\""], ["proof (prove)\nusing this:\n  \\<bar>gc * poly.coeff (primitive_part g) k\\<bar> \\<le> factor_bound f n\n\ngoal (1 subgoal):\n 1. \\<bar>gc * poly.coeff (primitive_part g) k\\<bar> \\<le> factor_bound f n", "."], ["proof (state)\nthis:\n  \\<bar>gc * poly.coeff (primitive_part g) k\\<bar> \\<le> factor_bound f n\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "note f0 = factor_bound_ge_0[OF f, of n]"], ["proof (state)\nthis:\n  0 \\<le> factor_bound f n\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "from mult_left_mono[OF le, of \"abs cg\"]"], ["proof (chain)\npicking this:\n  0 \\<le> \\<bar>cg\\<bar> \\<Longrightarrow>\n  \\<bar>cg\\<bar> * \\<bar>gc * poly.coeff (primitive_part g) k\\<bar>\n  \\<le> \\<bar>cg\\<bar> * factor_bound f n", "have \"\\<bar>cg * gc * coeff ?ng k\\<bar> \\<le> \\<bar>cg\\<bar> * factor_bound f n\""], ["proof (prove)\nusing this:\n  0 \\<le> \\<bar>cg\\<bar> \\<Longrightarrow>\n  \\<bar>cg\\<bar> * \\<bar>gc * poly.coeff (primitive_part g) k\\<bar>\n  \\<le> \\<bar>cg\\<bar> * factor_bound f n\n\ngoal (1 subgoal):\n 1. \\<bar>cg * gc * poly.coeff (primitive_part g) k\\<bar>\n    \\<le> \\<bar>cg\\<bar> * factor_bound f n", "unfolding abs_mult[symmetric]"], ["proof (prove)\nusing this:\n  0 \\<le> \\<bar>cg\\<bar> \\<Longrightarrow>\n  \\<bar>cg * (gc * poly.coeff (primitive_part g) k)\\<bar>\n  \\<le> \\<bar>cg\\<bar> * factor_bound f n\n\ngoal (1 subgoal):\n 1. \\<bar>cg * gc * poly.coeff (primitive_part g) k\\<bar>\n    \\<le> \\<bar>cg\\<bar> * factor_bound f n", "by simp"], ["proof (state)\nthis:\n  \\<bar>cg * gc * poly.coeff (primitive_part g) k\\<bar>\n  \\<le> \\<bar>cg\\<bar> * factor_bound f n\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "also"], ["proof (state)\nthis:\n  \\<bar>cg * gc * poly.coeff (primitive_part g) k\\<bar>\n  \\<le> \\<bar>cg\\<bar> * factor_bound f n\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "have \"cg * gc * coeff ?ng k = coeff (smult ?cg ?ng) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cg * gc * poly.coeff (primitive_part g) k =\n    poly.coeff (Polynomial.smult (content g) (primitive_part g)) k", "unfolding cg_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. cg * gc * poly.coeff (primitive_part g) k =\n    poly.coeff (Polynomial.smult (cg * gc) (primitive_part g)) k", "by simp"], ["proof (state)\nthis:\n  cg * gc * poly.coeff (primitive_part g) k =\n  poly.coeff (Polynomial.smult (content g) (primitive_part g)) k\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "also"], ["proof (state)\nthis:\n  cg * gc * poly.coeff (primitive_part g) k =\n  poly.coeff (Polynomial.smult (content g) (primitive_part g)) k\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "have \"\\<dots> = coeff g k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (Polynomial.smult (content g) (primitive_part g)) k =\n    poly.coeff g k", "unfolding content_times_primitive_part"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff g k = poly.coeff g k", "by simp"], ["proof (state)\nthis:\n  poly.coeff (Polynomial.smult (content g) (primitive_part g)) k =\n  poly.coeff g k\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "finally"], ["proof (chain)\npicking this:\n  \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>cg\\<bar> * factor_bound f n", "have \"\\<bar>coeff g k\\<bar> \\<le> 1 * (\\<bar>cg\\<bar> * factor_bound f n)\""], ["proof (prove)\nusing this:\n  \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>cg\\<bar> * factor_bound f n\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> 1 * (\\<bar>cg\\<bar> * factor_bound f n)", "by simp"], ["proof (state)\nthis:\n  \\<bar>poly.coeff g k\\<bar> \\<le> 1 * (\\<bar>cg\\<bar> * factor_bound f n)\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "also"], ["proof (state)\nthis:\n  \\<bar>poly.coeff g k\\<bar> \\<le> 1 * (\\<bar>cg\\<bar> * factor_bound f n)\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "have \"\\<dots> \\<le> \\<bar>h\\<bar> * (\\<bar>cg\\<bar> * factor_bound f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * (\\<bar>cg\\<bar> * factor_bound f n)\n    \\<le> \\<bar>h\\<bar> * (\\<bar>cg\\<bar> * factor_bound f n)", "by (rule mult_right_mono[OF h1], insert f0, auto)"], ["proof (state)\nthis:\n  1 * (\\<bar>cg\\<bar> * factor_bound f n)\n  \\<le> \\<bar>h\\<bar> * (\\<bar>cg\\<bar> * factor_bound f n)\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "also"], ["proof (state)\nthis:\n  1 * (\\<bar>cg\\<bar> * factor_bound f n)\n  \\<le> \\<bar>h\\<bar> * (\\<bar>cg\\<bar> * factor_bound f n)\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "have \"\\<dots> = (\\<bar>cg * h\\<bar>) * factor_bound f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>h\\<bar> * (\\<bar>cg\\<bar> * factor_bound f n) =\n    \\<bar>cg * h\\<bar> * factor_bound f n", "by (simp add: abs_mult)"], ["proof (state)\nthis:\n  \\<bar>h\\<bar> * (\\<bar>cg\\<bar> * factor_bound f n) =\n  \\<bar>cg * h\\<bar> * factor_bound f n\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "finally"], ["proof (chain)\npicking this:\n  \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>cg * h\\<bar> * factor_bound f n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>cg * h\\<bar> * factor_bound f n\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n", "unfolding dcg"], ["proof (prove)\nusing this:\n  \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>cg * h\\<bar> * factor_bound f n\n\ngoal (1 subgoal):\n 1. \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>cg * h\\<bar> * factor_bound f n", "."], ["proof (state)\nthis:\n  \\<bar>poly.coeff g k\\<bar> \\<le> \\<bar>d\\<bar> * factor_bound f n\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}