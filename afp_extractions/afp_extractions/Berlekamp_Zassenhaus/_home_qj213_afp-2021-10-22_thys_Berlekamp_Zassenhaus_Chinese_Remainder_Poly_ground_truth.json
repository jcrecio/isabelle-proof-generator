{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Chinese_Remainder_Poly.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma cong_add_poly:\n  \"[(a::'b::{field_gcd} poly) = b] (mod m) \\<Longrightarrow> [c = d] (mod m) \\<Longrightarrow> [a + c = b + d] (mod m)\"", "lemma cong_mult_poly:\n  \"[(a::'b::{field_gcd} poly) = b] (mod m) \\<Longrightarrow> [c = d] (mod m) \\<Longrightarrow> [a * c = b * d] (mod m)\"", "lemma cong_mult_self_poly: \"[(a::'b::{field_gcd} poly) * m = 0] (mod m)\"", "lemma cong_scalar2_poly: \"[(a::'b::{field_gcd} poly)= b] (mod m) \\<Longrightarrow> [k * a = k * b] (mod m)\"", "lemma cong_sum_poly:\n    \"(\\<And>x. x \\<in> A \\<Longrightarrow> [((f x)::'b::{field_gcd} poly) = g x] (mod m)) \\<Longrightarrow>\n      [(\\<Sum>x\\<in>A. f x) = (\\<Sum>x\\<in>A. g x)] (mod m)\"", "lemma cong_iff_lin_poly: \"([(a::'b::{field_gcd} poly) = b] (mod m)) = (\\<exists>k. b = a + m * k)\"", "lemma cong_solve_poly: \"(a::'b::{field_gcd} poly) \\<noteq> 0 \\<Longrightarrow> \\<exists>x. [a * x = gcd a n] (mod n)\"", "lemma cong_solve_coprime_poly: \nassumes coprime_an:\"coprime (a::'b::{field_gcd} poly) n\"\nshows \"\\<exists>x. [a * x = 1] (mod n)\"", "lemma cong_dvd_modulus_poly:\n  \"[x = y] (mod m) \\<Longrightarrow> n dvd m \\<Longrightarrow> [x = y] (mod n)\" for x y :: \"'b::{field_gcd} poly\"", "lemma chinese_remainder_aux_poly:\n  fixes A :: \"'a set\"\n    and m :: \"'a \\<Rightarrow> 'b::{field_gcd} poly\"\n  assumes fin: \"finite A\"\n    and cop: \"\\<forall>i \\<in> A. (\\<forall>j \\<in> A. i \\<noteq> j \\<longrightarrow> coprime (m i) (m j))\"\n  shows \"\\<exists>b. (\\<forall>i \\<in> A. [b i = 1] (mod m i) \\<and> [b i = 0] (mod (\\<Prod>j \\<in> A - {i}. m j)))\"", "lemma chinese_remainder_poly:\n  fixes A :: \"'a set\"\n    and m :: \"'a \\<Rightarrow> 'b::{field_gcd} poly\"\n    and u :: \"'a \\<Rightarrow> 'b poly\"\n  assumes fin: \"finite A\"\n    and cop: \"\\<forall>i\\<in>A. (\\<forall>j\\<in>A. i \\<noteq> j \\<longrightarrow> coprime (m i) (m j))\"\n  shows \"\\<exists>x. (\\<forall>i\\<in>A. [x = u i] (mod m i))\"", "lemma cong_trans_poly:\n    \"[(a::'b::{field_gcd} poly) = b] (mod m) \\<Longrightarrow> [b = c] (mod m) \\<Longrightarrow> [a = c] (mod m)\"", "lemma cong_mod_poly: \"(n::'b::{field_gcd} poly) ~= 0 \\<Longrightarrow> [a mod n = a] (mod n)\"", "lemma cong_sym_poly: \"[(a::'b::{field_gcd} poly) = b] (mod m) \\<Longrightarrow> [b = a] (mod m)\"", "lemma cong_1_poly: \"[(a::'b::{field_gcd} poly) = b] (mod 1)\"", "lemma coprime_cong_mult_poly:\n  assumes \"[(a::'b::{field_gcd} poly) = b] (mod m)\" and \"[a = b] (mod n)\" and \"coprime m n\"\n  shows \"[a = b] (mod m * n)\"", "lemma coprime_cong_prod_poly:\n    \"(\\<forall>i\\<in>A. (\\<forall>j\\<in>A. i \\<noteq> j \\<longrightarrow> coprime (m i) (m j))) \\<Longrightarrow>\n      (\\<forall>i\\<in>A. [(x::'b::{field_gcd} poly) = y] (mod m i)) \\<Longrightarrow>\n         [x = y] (mod (\\<Prod>i\\<in>A. m i))\"", "lemma cong_less_modulus_unique_poly:\n    \"[(x::'b::{field_gcd} poly) = y] (mod m) \\<Longrightarrow> degree x < degree m \\<Longrightarrow> degree y < degree m \\<Longrightarrow> x = y\"", "lemma chinese_remainder_unique_poly:\n  fixes A :: \"'a set\"\n    and m :: \"'a \\<Rightarrow> 'b::{field_gcd} poly\"\n    and u :: \"'a \\<Rightarrow> 'b poly\"\n  assumes nz: \"\\<forall>i\\<in>A. (m i) \\<noteq> 0\"\n    and cop: \"\\<forall>i\\<in>A. (\\<forall>j\\<in>A. i \\<noteq> j \\<longrightarrow> coprime (m i) (m j))\"\n    (*The following assumption should not be necessary, but I need it since in Isabelle \n      degree 0 is 0 instead of -\\<infinity>*)\n    and not_constant: \"0 < degree (prod m A)\" \n  shows \"\\<exists>!x. degree x < (\\<Sum>i\\<in>A. degree (m i)) \\<and> (\\<forall>i\\<in>A. [x = u i] (mod m i))\""], "translations": [["", "lemma cong_add_poly:\n  \"[(a::'b::{field_gcd} poly) = b] (mod m) \\<Longrightarrow> [c = d] (mod m) \\<Longrightarrow> [a + c = b + d] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[a = b] (mod m); [c = d] (mod m)\\<rbrakk>\n    \\<Longrightarrow> [a + c = b + d] (mod m)", "by (fact cong_add)"], ["", "lemma cong_mult_poly:\n  \"[(a::'b::{field_gcd} poly) = b] (mod m) \\<Longrightarrow> [c = d] (mod m) \\<Longrightarrow> [a * c = b * d] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[a = b] (mod m); [c = d] (mod m)\\<rbrakk>\n    \\<Longrightarrow> [a * c = b * d] (mod m)", "by (fact cong_mult)"], ["", "lemma cong_mult_self_poly: \"[(a::'b::{field_gcd} poly) * m = 0] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a * m = 0] (mod m)", "by (fact cong_mult_self_right)"], ["", "lemma cong_scalar2_poly: \"[(a::'b::{field_gcd} poly)= b] (mod m) \\<Longrightarrow> [k * a = k * b] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a = b] (mod m) \\<Longrightarrow> [k * a = k * b] (mod m)", "by (fact cong_scalar_left)"], ["", "lemma cong_sum_poly:\n    \"(\\<And>x. x \\<in> A \\<Longrightarrow> [((f x)::'b::{field_gcd} poly) = g x] (mod m)) \\<Longrightarrow>\n      [(\\<Sum>x\\<in>A. f x) = (\\<Sum>x\\<in>A. g x)] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> A \\<Longrightarrow> [f x = g x] (mod m)) \\<Longrightarrow>\n    [sum f A = sum g A] (mod m)", "by (rule cong_sum)"], ["", "lemma cong_iff_lin_poly: \"([(a::'b::{field_gcd} poly) = b] (mod m)) = (\\<exists>k. b = a + m * k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a = b] (mod m) = (\\<exists>k. b = a + m * k)", "using cong_diff_iff_cong_0 [of b a m]"], ["proof (prove)\nusing this:\n  [b - a = 0] (mod m) = [b = a] (mod m)\n\ngoal (1 subgoal):\n 1. [a = b] (mod m) = (\\<exists>k. b = a + m * k)", "by (auto simp add: cong_0_iff dvd_def algebra_simps dest: cong_sym)"], ["", "lemma cong_solve_poly: \"(a::'b::{field_gcd} poly) \\<noteq> 0 \\<Longrightarrow> \\<exists>x. [a * x = gcd a n] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> \\<exists>x. [a * x = gcd a n] (mod n)", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> 0; n = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. [a * x = gcd a n] (mod n)\n 2. \\<lbrakk>a \\<noteq> 0; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. [a * x = gcd a n] (mod n)", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> 0; n = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. [a * x = gcd a n] (mod n)\n 2. \\<lbrakk>a \\<noteq> 0; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. [a * x = gcd a n] (mod n)", "note n0=True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> 0; n = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. [a * x = gcd a n] (mod n)\n 2. \\<lbrakk>a \\<noteq> 0; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. [a * x = gcd a n] (mod n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. [a * x = gcd a n] (mod n)", "proof (cases \"monic a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. monic a \\<Longrightarrow> \\<exists>x. [a * x = gcd a n] (mod n)\n 2. lead_coeff a \\<noteq> (1::'b) \\<Longrightarrow>\n    \\<exists>x. [a * x = gcd a n] (mod n)", "case True"], ["proof (state)\nthis:\n  monic a\n\ngoal (2 subgoals):\n 1. monic a \\<Longrightarrow> \\<exists>x. [a * x = gcd a n] (mod n)\n 2. lead_coeff a \\<noteq> (1::'b) \\<Longrightarrow>\n    \\<exists>x. [a * x = gcd a n] (mod n)", "have n: \"normalize a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize a = a", "by (rule normalize_monic[OF True])"], ["proof (state)\nthis:\n  normalize a = a\n\ngoal (2 subgoals):\n 1. monic a \\<Longrightarrow> \\<exists>x. [a * x = gcd a n] (mod n)\n 2. lead_coeff a \\<noteq> (1::'b) \\<Longrightarrow>\n    \\<exists>x. [a * x = gcd a n] (mod n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. [a * x = gcd a n] (mod n)", "by (rule exI[of _ 1], auto simp add: n0 n cong_def)"], ["proof (state)\nthis:\n  \\<exists>x. [a * x = gcd a n] (mod n)\n\ngoal (1 subgoal):\n 1. lead_coeff a \\<noteq> (1::'b) \\<Longrightarrow>\n    \\<exists>x. [a * x = gcd a n] (mod n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lead_coeff a \\<noteq> (1::'b) \\<Longrightarrow>\n    \\<exists>x. [a * x = gcd a n] (mod n)", "case False"], ["proof (state)\nthis:\n  lead_coeff a \\<noteq> (1::'b)\n\ngoal (1 subgoal):\n 1. lead_coeff a \\<noteq> (1::'b) \\<Longrightarrow>\n    \\<exists>x. [a * x = gcd a n] (mod n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. [a * x = gcd a n] (mod n)", "by (auto simp add: True cong_def normalize_poly_old_def map_div_is_smult_inverse)\n         (metis mult.right_neutral mult_smult_right)"], ["proof (state)\nthis:\n  \\<exists>x. [a * x = gcd a n] (mod n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. [a * x = gcd a n] (mod n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. [a * x = gcd a n] (mod n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. [a * x = gcd a n] (mod n)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. [a * x = gcd a n] (mod n)", "note n_not_0 = False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. [a * x = gcd a n] (mod n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. [a * x = gcd a n] (mod n)", "using bezout_coefficients_fst_snd [of a n, symmetric]"], ["proof (prove)\nusing this:\n  gcd a n =\n  fst (bezout_coefficients a n) * a + snd (bezout_coefficients a n) * n\n\ngoal (1 subgoal):\n 1. \\<exists>x. [a * x = gcd a n] (mod n)", "by (auto simp add: cong_iff_lin_poly mult.commute [of a] mult.commute [of n])"], ["proof (state)\nthis:\n  \\<exists>x. [a * x = gcd a n] (mod n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cong_solve_coprime_poly: \nassumes coprime_an:\"coprime (a::'b::{field_gcd} poly) n\"\nshows \"\\<exists>x. [a * x = 1] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. [a * x = 1] (mod n)", "proof (cases \"a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow> \\<exists>x. [a * x = 1] (mod n)\n 2. a \\<noteq> 0 \\<Longrightarrow> \\<exists>x. [a * x = 1] (mod n)", "case True"], ["proof (state)\nthis:\n  a = 0\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow> \\<exists>x. [a * x = 1] (mod n)\n 2. a \\<noteq> 0 \\<Longrightarrow> \\<exists>x. [a * x = 1] (mod n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. [a * x = 1] (mod n)", "unfolding cong_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. a * x mod n = 1 mod n", "using True coprime_an"], ["proof (prove)\nusing this:\n  a = 0\n  coprime a n\n\ngoal (1 subgoal):\n 1. \\<exists>x. a * x mod n = 1 mod n", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. [a * x = 1] (mod n)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> \\<exists>x. [a * x = 1] (mod n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> \\<exists>x. [a * x = 1] (mod n)", "case False"], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> \\<exists>x. [a * x = 1] (mod n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. [a * x = 1] (mod n)", "using coprime_an cong_solve_poly[OF False, of n]"], ["proof (prove)\nusing this:\n  coprime a n\n  \\<exists>x. [a * x = gcd a n] (mod n)\n\ngoal (1 subgoal):\n 1. \\<exists>x. [a * x = 1] (mod n)", "unfolding cong_def"], ["proof (prove)\nusing this:\n  coprime a n\n  \\<exists>x. a * x mod n = gcd a n mod n\n\ngoal (1 subgoal):\n 1. \\<exists>x. a * x mod n = 1 mod n", "by presburger"], ["proof (state)\nthis:\n  \\<exists>x. [a * x = 1] (mod n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cong_dvd_modulus_poly:\n  \"[x = y] (mod m) \\<Longrightarrow> n dvd m \\<Longrightarrow> [x = y] (mod n)\" for x y :: \"'b::{field_gcd} poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[x = y] (mod m); n dvd m\\<rbrakk>\n    \\<Longrightarrow> [x = y] (mod n)", "by (auto simp add: cong_iff_lin_poly elim!: dvdE)"], ["", "lemma chinese_remainder_aux_poly:\n  fixes A :: \"'a set\"\n    and m :: \"'a \\<Rightarrow> 'b::{field_gcd} poly\"\n  assumes fin: \"finite A\"\n    and cop: \"\\<forall>i \\<in> A. (\\<forall>j \\<in> A. i \\<noteq> j \\<longrightarrow> coprime (m i) (m j))\"\n  shows \"\\<exists>b. (\\<forall>i \\<in> A. [b i = 1] (mod m i) \\<and> [b i = 0] (mod (\\<Prod>j \\<in> A - {i}. m j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b.\n       \\<forall>i\\<in>A.\n          [b i = 1] (mod m i) \\<and> [b i = 0] (mod prod m (A - {i}))", "proof (rule finite_set_choice, rule fin, rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> A \\<Longrightarrow>\n       \\<exists>y. [y = 1] (mod m i) \\<and> [y = 0] (mod prod m (A - {i}))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> A \\<Longrightarrow>\n       \\<exists>y. [y = 1] (mod m i) \\<and> [y = 0] (mod prod m (A - {i}))", "assume \"i : A\""], ["proof (state)\nthis:\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> A \\<Longrightarrow>\n       \\<exists>y. [y = 1] (mod m i) \\<and> [y = 0] (mod prod m (A - {i}))", "with cop"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>A.\n     \\<forall>j\\<in>A. i \\<noteq> j \\<longrightarrow> coprime (m i) (m j)\n  i \\<in> A", "have \"coprime (\\<Prod>j \\<in> A - {i}. m j) (m i)\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>A.\n     \\<forall>j\\<in>A. i \\<noteq> j \\<longrightarrow> coprime (m i) (m j)\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. coprime (prod m (A - {i})) (m i)", "by (auto intro: prod_coprime_left)"], ["proof (state)\nthis:\n  coprime (prod m (A - {i})) (m i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> A \\<Longrightarrow>\n       \\<exists>y. [y = 1] (mod m i) \\<and> [y = 0] (mod prod m (A - {i}))", "then"], ["proof (chain)\npicking this:\n  coprime (prod m (A - {i})) (m i)", "have \"\\<exists>x. [(\\<Prod>j \\<in> A - {i}. m j) * x = 1] (mod m i)\""], ["proof (prove)\nusing this:\n  coprime (prod m (A - {i})) (m i)\n\ngoal (1 subgoal):\n 1. \\<exists>x. [prod m (A - {i}) * x = 1] (mod m i)", "by (elim cong_solve_coprime_poly)"], ["proof (state)\nthis:\n  \\<exists>x. [prod m (A - {i}) * x = 1] (mod m i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> A \\<Longrightarrow>\n       \\<exists>y. [y = 1] (mod m i) \\<and> [y = 0] (mod prod m (A - {i}))", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. [prod m (A - {i}) * x = 1] (mod m i)", "obtain x where \"[(\\<Prod>j \\<in> A - {i}. m j) * x = 1] (mod m i)\""], ["proof (prove)\nusing this:\n  \\<exists>x. [prod m (A - {i}) * x = 1] (mod m i)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        [prod m (A - {i}) * x = 1] (mod m i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  [prod m (A - {i}) * x = 1] (mod m i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> A \\<Longrightarrow>\n       \\<exists>y. [y = 1] (mod m i) \\<and> [y = 0] (mod prod m (A - {i}))", "moreover"], ["proof (state)\nthis:\n  [prod m (A - {i}) * x = 1] (mod m i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> A \\<Longrightarrow>\n       \\<exists>y. [y = 1] (mod m i) \\<and> [y = 0] (mod prod m (A - {i}))", "have \"[(\\<Prod>j \\<in> A - {i}. m j) * x = 0]\n    (mod (\\<Prod>j \\<in> A - {i}. m j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [prod m (A - {i}) * x = 0] (mod prod m (A - {i}))", "by (subst mult.commute, rule cong_mult_self_poly)"], ["proof (state)\nthis:\n  [prod m (A - {i}) * x = 0] (mod prod m (A - {i}))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> A \\<Longrightarrow>\n       \\<exists>y. [y = 1] (mod m i) \\<and> [y = 0] (mod prod m (A - {i}))", "ultimately"], ["proof (chain)\npicking this:\n  [prod m (A - {i}) * x = 1] (mod m i)\n  [prod m (A - {i}) * x = 0] (mod prod m (A - {i}))", "show \"\\<exists>a. [a = 1] (mod m i) \\<and> [a = 0]\n      (mod prod m (A - {i}))\""], ["proof (prove)\nusing this:\n  [prod m (A - {i}) * x = 1] (mod m i)\n  [prod m (A - {i}) * x = 0] (mod prod m (A - {i}))\n\ngoal (1 subgoal):\n 1. \\<exists>a. [a = 1] (mod m i) \\<and> [a = 0] (mod prod m (A - {i}))", "by blast"], ["proof (state)\nthis:\n  \\<exists>a. [a = 1] (mod m i) \\<and> [a = 0] (mod prod m (A - {i}))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*The Chinese Remainder Theorem for polynomials: *)"], ["", "lemma chinese_remainder_poly:\n  fixes A :: \"'a set\"\n    and m :: \"'a \\<Rightarrow> 'b::{field_gcd} poly\"\n    and u :: \"'a \\<Rightarrow> 'b poly\"\n  assumes fin: \"finite A\"\n    and cop: \"\\<forall>i\\<in>A. (\\<forall>j\\<in>A. i \\<noteq> j \\<longrightarrow> coprime (m i) (m j))\"\n  shows \"\\<exists>x. (\\<forall>i\\<in>A. [x = u i] (mod m i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>i\\<in>A. [x = u i] (mod m i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>i\\<in>A. [x = u i] (mod m i)", "from chinese_remainder_aux_poly [OF fin cop]"], ["proof (chain)\npicking this:\n  \\<exists>b.\n     \\<forall>i\\<in>A.\n        [b i = 1] (mod m i) \\<and> [b i = 0] (mod prod m (A - {i}))", "obtain b where\n    bprop: \"\\<forall>i\\<in>A. [b i = 1] (mod m i) \\<and>\n      [b i = 0] (mod (\\<Prod>j \\<in> A - {i}. m j))\""], ["proof (prove)\nusing this:\n  \\<exists>b.\n     \\<forall>i\\<in>A.\n        [b i = 1] (mod m i) \\<and> [b i = 0] (mod prod m (A - {i}))\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<forall>i\\<in>A.\n           [b i = 1] (mod m i) \\<and>\n           [b i = 0] (mod prod m (A - {i})) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>i\\<in>A.\n     [b i = 1] (mod m i) \\<and> [b i = 0] (mod prod m (A - {i}))\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>i\\<in>A. [x = u i] (mod m i)", "let ?x = \"\\<Sum>i\\<in>A. (u i) * (b i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>i\\<in>A. [x = u i] (mod m i)", "show \"?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>i\\<in>A. [x = u i] (mod m i)", "proof (rule exI, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> [?x = u i] (mod m i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> [?x = u i] (mod m i)", "assume a: \"i : A\""], ["proof (state)\nthis:\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> [?x = u i] (mod m i)", "show \"[?x = u i] (mod m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<Sum>i\\<in>A. u i * b i = u i] (mod m i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [\\<Sum>i\\<in>A. u i * b i = u i] (mod m i)", "from fin a"], ["proof (chain)\npicking this:\n  finite A\n  i \\<in> A", "have \"?x = (\\<Sum>j \\<in> {i}. u j * b j) +\n          (\\<Sum>j \\<in> A - {i}. u j * b j)\""], ["proof (prove)\nusing this:\n  finite A\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>A. u i * b i) =\n    (\\<Sum>j\\<in>{i}. u j * b j) + (\\<Sum>j\\<in>A - {i}. u j * b j)", "by (subst sum.union_disjoint [symmetric], auto intro: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>A. u i * b i) =\n  (\\<Sum>j\\<in>{i}. u j * b j) + (\\<Sum>j\\<in>A - {i}. u j * b j)\n\ngoal (1 subgoal):\n 1. [\\<Sum>i\\<in>A. u i * b i = u i] (mod m i)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<in>A. u i * b i) =\n  (\\<Sum>j\\<in>{i}. u j * b j) + (\\<Sum>j\\<in>A - {i}. u j * b j)", "have \"[?x = u i * b i + (\\<Sum>j \\<in> A - {i}. u j * b j)] (mod m i)\""], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>A. u i * b i) =\n  (\\<Sum>j\\<in>{i}. u j * b j) + (\\<Sum>j\\<in>A - {i}. u j * b j)\n\ngoal (1 subgoal):\n 1. [\\<Sum>i\\<in>A.\n       u i * b i = u i * b i + (\\<Sum>j\\<in>A - {i}. u j * b j)] (mod m i)", "unfolding cong_def"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>A. u i * b i) =\n  (\\<Sum>j\\<in>{i}. u j * b j) + (\\<Sum>j\\<in>A - {i}. u j * b j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>A. u i * b i) mod m i =\n    (u i * b i + (\\<Sum>j\\<in>A - {i}. u j * b j)) mod m i", "by auto"], ["proof (state)\nthis:\n  [\\<Sum>i\\<in>A.\n     u i * b i = u i * b i + (\\<Sum>j\\<in>A - {i}. u j * b j)] (mod m i)\n\ngoal (1 subgoal):\n 1. [\\<Sum>i\\<in>A. u i * b i = u i] (mod m i)", "also"], ["proof (state)\nthis:\n  [\\<Sum>i\\<in>A.\n     u i * b i = u i * b i + (\\<Sum>j\\<in>A - {i}. u j * b j)] (mod m i)\n\ngoal (1 subgoal):\n 1. [\\<Sum>i\\<in>A. u i * b i = u i] (mod m i)", "have \"[u i * b i + (\\<Sum>j \\<in> A - {i}. u j * b j) =\n                  u i * 1 + (\\<Sum>j \\<in> A - {i}. u j * 0)] (mod m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [u i * b i +\n     (\\<Sum>j\\<in>A - {i}.\n        u j * b j) = u i * 1 + (\\<Sum>j\\<in>A - {i}. u j * 0)] (mod m i)", "apply (rule cong_add_poly)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [u i * b i = u i * 1] (mod m i)\n 2. [\\<Sum>j\\<in>A - {i}.\n       u j * b j = \\<Sum>j\\<in>A - {i}. u j * 0] (mod m i)", "apply (rule cong_scalar2_poly)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [b i = 1] (mod m i)\n 2. [\\<Sum>j\\<in>A - {i}.\n       u j * b j = \\<Sum>j\\<in>A - {i}. u j * 0] (mod m i)", "using bprop a"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>A.\n     [b i = 1] (mod m i) \\<and> [b i = 0] (mod prod m (A - {i}))\n  i \\<in> A\n\ngoal (2 subgoals):\n 1. [b i = 1] (mod m i)\n 2. [\\<Sum>j\\<in>A - {i}.\n       u j * b j = \\<Sum>j\\<in>A - {i}. u j * 0] (mod m i)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<Sum>j\\<in>A - {i}.\n       u j * b j = \\<Sum>j\\<in>A - {i}. u j * 0] (mod m i)", "apply (rule cong_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A - {i} \\<Longrightarrow> [u x * b x = u x * 0] (mod m i)", "apply (rule cong_scalar2_poly)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A - {i} \\<Longrightarrow> [b x = 0] (mod m i)", "using bprop"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>A.\n     [b i = 1] (mod m i) \\<and> [b i = 0] (mod prod m (A - {i}))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A - {i} \\<Longrightarrow> [b x = 0] (mod m i)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<in>A.\n                   [b i = 1] (mod m i) \\<and>\n                   [b i = 0] (mod prod m (A - {i}));\n        x \\<in> A; x \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> [b x = 0] (mod m i)", "apply (rule cong_dvd_modulus_poly)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<in>A.\n                   [b i = 1] (mod m i) \\<and>\n                   [b i = 0] (mod prod m (A - {i}));\n        x \\<in> A; x \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> [b x = 0] (mod ?m19 x)\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<in>A.\n                   [b i = 1] (mod m i) \\<and>\n                   [b i = 0] (mod prod m (A - {i}));\n        x \\<in> A; x \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> m i dvd ?m19 x", "apply (drule (1) bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> A; x \\<noteq> i;\n        [b x = 1] (mod m x) \\<and> [b x = 0] (mod prod m (A - {x}))\\<rbrakk>\n       \\<Longrightarrow> [b x = 0] (mod ?m19 x)\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<in>A.\n                   [b i = 1] (mod m i) \\<and>\n                   [b i = 0] (mod prod m (A - {i}));\n        x \\<in> A; x \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> m i dvd ?m19 x", "apply (erule conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> A; x \\<noteq> i; [b x = 1] (mod m x);\n        [b x = 0] (mod prod m (A - {x}))\\<rbrakk>\n       \\<Longrightarrow> [b x = 0] (mod ?m19 x)\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<in>A.\n                   [b i = 1] (mod m i) \\<and>\n                   [b i = 0] (mod prod m (A - {i}));\n        x \\<in> A; x \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> m i dvd ?m19 x", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<in>A.\n                   [b i = 1] (mod m i) \\<and>\n                   [b i = 0] (mod prod m (A - {i}));\n        x \\<in> A; x \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> m i dvd prod m (A - {x})", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<in>A.\n                   [b i = 1] (mod m i) \\<and>\n                   [b i = 0] (mod prod m (A - {i}));\n        x \\<in> A; x \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> finite (A - {x})\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<in>A.\n                   [b i = 1] (mod m i) \\<and>\n                   [b i = 0] (mod prod m (A - {i}));\n        x \\<in> A; x \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> i \\<in> A - {x}", "using fin a"], ["proof (prove)\nusing this:\n  finite A\n  i \\<in> A\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<in>A.\n                   [b i = 1] (mod m i) \\<and>\n                   [b i = 0] (mod prod m (A - {i}));\n        x \\<in> A; x \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> finite (A - {x})\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<in>A.\n                   [b i = 1] (mod m i) \\<and>\n                   [b i = 0] (mod prod m (A - {i}));\n        x \\<in> A; x \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> i \\<in> A - {x}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  [u i * b i +\n   (\\<Sum>j\\<in>A - {i}.\n      u j * b j) = u i * 1 + (\\<Sum>j\\<in>A - {i}. u j * 0)] (mod m i)\n\ngoal (1 subgoal):\n 1. [\\<Sum>i\\<in>A. u i * b i = u i] (mod m i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [u i * b i +\n   (\\<Sum>j\\<in>A - {i}.\n      u j * b j) = u i * 1 + (\\<Sum>j\\<in>A - {i}. u j * 0)] (mod m i)\n\ngoal (1 subgoal):\n 1. [\\<Sum>i\\<in>A. u i * b i = u i] (mod m i)", "by (metis (no_types, lifting) a add.right_neutral fin mult_cancel_left1 mult_cancel_right1 \n         sum.not_neutral_contains_not_neutral sum.remove)"], ["proof (state)\nthis:\n  [\\<Sum>i\\<in>A. u i * b i = u i] (mod m i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [\\<Sum>i\\<in>A. u i * b i = u i] (mod m i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. \\<forall>i\\<in>A. [x = u i] (mod m i)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*********************** Now we try to prove the uniqueness **********************)"], ["", "lemma cong_trans_poly:\n    \"[(a::'b::{field_gcd} poly) = b] (mod m) \\<Longrightarrow> [b = c] (mod m) \\<Longrightarrow> [a = c] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[a = b] (mod m); [b = c] (mod m)\\<rbrakk>\n    \\<Longrightarrow> [a = c] (mod m)", "by (fact cong_trans)"], ["", "lemma cong_mod_poly: \"(n::'b::{field_gcd} poly) ~= 0 \\<Longrightarrow> [a mod n = a] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> [a mod n = a] (mod n)", "by auto"], ["", "lemma cong_sym_poly: \"[(a::'b::{field_gcd} poly) = b] (mod m) \\<Longrightarrow> [b = a] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a = b] (mod m) \\<Longrightarrow> [b = a] (mod m)", "by (fact cong_sym)"], ["", "lemma cong_1_poly: \"[(a::'b::{field_gcd} poly) = b] (mod 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a = b] (mod 1)", "by (fact cong_1)"], ["", "lemma coprime_cong_mult_poly:\n  assumes \"[(a::'b::{field_gcd} poly) = b] (mod m)\" and \"[a = b] (mod n)\" and \"coprime m n\"\n  shows \"[a = b] (mod m * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a = b] (mod m * n)", "using divides_mult assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a dvd ?c; ?b dvd ?c; coprime ?a ?b\\<rbrakk>\n  \\<Longrightarrow> ?a * ?b dvd ?c\n  [a = b] (mod m)\n  [a = b] (mod n)\n  coprime m n\n\ngoal (1 subgoal):\n 1. [a = b] (mod m * n)", "by (metis (no_types, hide_lams) cong_dvd_modulus_poly cong_iff_lin_poly dvd_mult2 dvd_refl minus_add_cancel mult.right_neutral)"], ["", "lemma coprime_cong_prod_poly:\n    \"(\\<forall>i\\<in>A. (\\<forall>j\\<in>A. i \\<noteq> j \\<longrightarrow> coprime (m i) (m j))) \\<Longrightarrow>\n      (\\<forall>i\\<in>A. [(x::'b::{field_gcd} poly) = y] (mod m i)) \\<Longrightarrow>\n         [x = y] (mod (\\<Prod>i\\<in>A. m i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>A.\n                \\<forall>j\\<in>A.\n                   i \\<noteq> j \\<longrightarrow> coprime (m i) (m j);\n     \\<forall>i\\<in>A. [x = y] (mod m i)\\<rbrakk>\n    \\<Longrightarrow> [x = y] (mod prod m A)", "apply (induct A rule: infinite_finite_induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<forall>i\\<in>A.\n           \\<forall>j\\<in>A.\n              i \\<noteq> j \\<longrightarrow> coprime (m i) (m j);\n        \\<forall>i\\<in>A. [x = y] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> [x = y] (mod prod m A)\n 2. \\<lbrakk>\\<forall>i\\<in>{}.\n                \\<forall>j\\<in>{}.\n                   i \\<noteq> j \\<longrightarrow> coprime (m i) (m j);\n     \\<forall>i\\<in>{}. [x = y] (mod m i)\\<rbrakk>\n    \\<Longrightarrow> [x = y] (mod prod m {})\n 3. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F.\n                    \\<forall>j\\<in>F.\n                       i \\<noteq> j \\<longrightarrow> coprime (m i) (m j);\n         \\<forall>i\\<in>F. [x = y] (mod m i)\\<rbrakk>\n        \\<Longrightarrow> [x = y] (mod prod m F);\n        \\<forall>i\\<in>insert xa F.\n           \\<forall>j\\<in>insert xa F.\n              i \\<noteq> j \\<longrightarrow> coprime (m i) (m j);\n        \\<forall>i\\<in>insert xa F. [x = y] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> [x = y] (mod prod m (insert xa F))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F; [x = y] (mod prod m F);\n        \\<forall>j\\<in>F.\n           xa \\<noteq> j \\<longrightarrow> coprime (m xa) (m j);\n        \\<forall>i\\<in>F.\n           (i \\<noteq> xa \\<longrightarrow> coprime (m i) (m xa)) \\<and>\n           (\\<forall>j\\<in>F.\n               i \\<noteq> j \\<longrightarrow> coprime (m i) (m j));\n        [x = y] (mod m xa); \\<forall>i\\<in>F. [x = y] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> [x = y] (mod m xa * prod m F)", "apply (metis coprime_cong_mult_poly prod_coprime_right)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cong_less_modulus_unique_poly:\n    \"[(x::'b::{field_gcd} poly) = y] (mod m) \\<Longrightarrow> degree x < degree m \\<Longrightarrow> degree y < degree m \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[x = y] (mod m); degree x < degree m;\n     degree y < degree m\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (simp add: cong_def mod_poly_less)"], ["", "lemma chinese_remainder_unique_poly:\n  fixes A :: \"'a set\"\n    and m :: \"'a \\<Rightarrow> 'b::{field_gcd} poly\"\n    and u :: \"'a \\<Rightarrow> 'b poly\"\n  assumes nz: \"\\<forall>i\\<in>A. (m i) \\<noteq> 0\"\n    and cop: \"\\<forall>i\\<in>A. (\\<forall>j\\<in>A. i \\<noteq> j \\<longrightarrow> coprime (m i) (m j))\"\n    (*The following assumption should not be necessary, but I need it since in Isabelle \n      degree 0 is 0 instead of -\\<infinity>*)\n    and not_constant: \"0 < degree (prod m A)\" \n  shows \"\\<exists>!x. degree x < (\\<Sum>i\\<in>A. degree (m i)) \\<and> (\\<forall>i\\<in>A. [x = u i] (mod m i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       degree x < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n       (\\<forall>i\\<in>A. [x = u i] (mod m i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       degree x < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n       (\\<forall>i\\<in>A. [x = u i] (mod m i))", "from not_constant"], ["proof (chain)\npicking this:\n  0 < degree (prod m A)", "have fin: \"finite A\""], ["proof (prove)\nusing this:\n  0 < degree (prod m A)\n\ngoal (1 subgoal):\n 1. finite A", "by (metis degree_1 gr_implies_not0 prod.infinite)"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       degree x < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n       (\\<forall>i\\<in>A. [x = u i] (mod m i))", "from chinese_remainder_poly [OF fin cop]"], ["proof (chain)\npicking this:\n  \\<exists>x. \\<forall>i\\<in>A. [x = ?u i] (mod m i)", "obtain y where one: \"(\\<forall>i\\<in>A. [y = u i] (mod m i))\""], ["proof (prove)\nusing this:\n  \\<exists>x. \\<forall>i\\<in>A. [x = ?u i] (mod m i)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<forall>i\\<in>A. [y = u i] (mod m i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>i\\<in>A. [y = u i] (mod m i)\n\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       degree x < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n       (\\<forall>i\\<in>A. [x = u i] (mod m i))", "let ?x = \"y mod (\\<Prod>i\\<in>A. m i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       degree x < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n       (\\<forall>i\\<in>A. [x = u i] (mod m i))", "have degree_prod_sum: \"degree (prod m A) = (\\<Sum>i\\<in>A. degree (m i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod m A) = (\\<Sum>i\\<in>A. degree (m i))", "by (rule degree_prod_eq_sum_degree[OF nz])"], ["proof (state)\nthis:\n  degree (prod m A) = (\\<Sum>i\\<in>A. degree (m i))\n\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       degree x < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n       (\\<forall>i\\<in>A. [x = u i] (mod m i))", "from fin nz"], ["proof (chain)\npicking this:\n  finite A\n  \\<forall>i\\<in>A. m i \\<noteq> 0", "have prodnz: \"(\\<Prod>i\\<in>A. (m i)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  finite A\n  \\<forall>i\\<in>A. m i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prod m A \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  prod m A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       degree x < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n       (\\<forall>i\\<in>A. [x = u i] (mod m i))", "(*This would hold without the premise not_constant if degree 0 = -\\<infinity>*)"], ["proof (state)\nthis:\n  prod m A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       degree x < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n       (\\<forall>i\\<in>A. [x = u i] (mod m i))", "have less: \"degree ?x < (\\<Sum>i\\<in>A. degree (m i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (y mod prod m A) < (\\<Sum>i\\<in>A. degree (m i))", "unfolding degree_prod_sum[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (y mod prod m A) < degree (prod m A)", "using degree_mod_less[OF prodnz, of y]"], ["proof (prove)\nusing this:\n  y mod prod m A = 0 \\<or> degree (y mod prod m A) < degree (prod m A)\n\ngoal (1 subgoal):\n 1. degree (y mod prod m A) < degree (prod m A)", "using not_constant"], ["proof (prove)\nusing this:\n  y mod prod m A = 0 \\<or> degree (y mod prod m A) < degree (prod m A)\n  0 < degree (prod m A)\n\ngoal (1 subgoal):\n 1. degree (y mod prod m A) < degree (prod m A)", "by auto"], ["proof (state)\nthis:\n  degree (y mod prod m A) < (\\<Sum>i\\<in>A. degree (m i))\n\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       degree x < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n       (\\<forall>i\\<in>A. [x = u i] (mod m i))", "have cong: \"\\<forall>i\\<in>A. [?x = u i] (mod m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>A. [y mod prod m A = u i] (mod m i)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> [y mod prod m A = u i] (mod m i)", "apply (rule cong_trans_poly)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> [y mod prod m A = ?b1 i] (mod m i)\n 2. \\<And>i. i \\<in> A \\<Longrightarrow> [?b1 i = u i] (mod m i)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> [?b1 i = u i] (mod m i)\n 2. \\<And>i. i \\<in> A \\<Longrightarrow> [y mod prod m A = ?b1 i] (mod m i)", "using one"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>A. [y = u i] (mod m i)\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> [?b1 i = u i] (mod m i)\n 2. \\<And>i. i \\<in> A \\<Longrightarrow> [y mod prod m A = ?b1 i] (mod m i)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> A; \\<forall>i\\<in>A. [y = u i] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> [y mod prod m A = y] (mod m i)", "apply (rule cong_dvd_modulus_poly)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> A; \\<forall>i\\<in>A. [y = u i] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> [y mod prod m A = y] (mod ?m11 i)\n 2. \\<And>i.\n       \\<lbrakk>i \\<in> A; \\<forall>i\\<in>A. [y = u i] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> m i dvd ?m11 i", "apply (rule cong_mod_poly)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> A; \\<forall>i\\<in>A. [y = u i] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> prod m A \\<noteq> 0\n 2. \\<And>i.\n       \\<lbrakk>i \\<in> A; \\<forall>i\\<in>A. [y = u i] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> m i dvd prod m A", "using prodnz"], ["proof (prove)\nusing this:\n  prod m A \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> A; \\<forall>i\\<in>A. [y = u i] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> prod m A \\<noteq> 0\n 2. \\<And>i.\n       \\<lbrakk>i \\<in> A; \\<forall>i\\<in>A. [y = u i] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> m i dvd prod m A", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> A; \\<forall>i\\<in>A. [y = u i] (mod m i);\n        prod m A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> m i dvd prod m A", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> A; \\<forall>i\\<in>A. [y = u i] (mod m i);\n        prod m A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> finite A\n 2. \\<And>i.\n       \\<lbrakk>i \\<in> A; \\<forall>i\\<in>A. [y = u i] (mod m i);\n        prod m A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i \\<in> A", "apply (rule fin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> A; \\<forall>i\\<in>A. [y = u i] (mod m i);\n        prod m A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i \\<in> A", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>i\\<in>A. [y mod prod m A = u i] (mod m i)\n\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       degree x < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n       (\\<forall>i\\<in>A. [x = u i] (mod m i))", "have unique: \"\\<forall>z. degree z < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n      (\\<forall>i\\<in>A. [z = u i] (mod m i)) \\<longrightarrow> z = ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       degree z < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n       (\\<forall>i\\<in>A. [z = u i] (mod m i)) \\<longrightarrow>\n       z = y mod prod m A", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>degree z < (\\<Sum>i\\<in>A. degree (m i));\n        \\<forall>i\\<in>A. [z = u i] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> z = y mod prod m A", "fix z::\"'b poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>degree z < (\\<Sum>i\\<in>A. degree (m i));\n        \\<forall>i\\<in>A. [z = u i] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> z = y mod prod m A", "assume zless: \"degree z < (\\<Sum>i\\<in>A. degree (m i))\""], ["proof (state)\nthis:\n  degree z < (\\<Sum>i\\<in>A. degree (m i))\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>degree z < (\\<Sum>i\\<in>A. degree (m i));\n        \\<forall>i\\<in>A. [z = u i] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> z = y mod prod m A", "assume zcong: \"(\\<forall>i\\<in>A. [z = u i] (mod m i))\""], ["proof (state)\nthis:\n  \\<forall>i\\<in>A. [z = u i] (mod m i)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>degree z < (\\<Sum>i\\<in>A. degree (m i));\n        \\<forall>i\\<in>A. [z = u i] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> z = y mod prod m A", "have deg1: \"degree z < degree (prod m A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree z < degree (prod m A)", "using degree_prod_sum zless"], ["proof (prove)\nusing this:\n  degree (prod m A) = (\\<Sum>i\\<in>A. degree (m i))\n  degree z < (\\<Sum>i\\<in>A. degree (m i))\n\ngoal (1 subgoal):\n 1. degree z < degree (prod m A)", "by simp"], ["proof (state)\nthis:\n  degree z < degree (prod m A)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>degree z < (\\<Sum>i\\<in>A. degree (m i));\n        \\<forall>i\\<in>A. [z = u i] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> z = y mod prod m A", "have deg2: \"degree ?x < degree (prod m A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (y mod prod m A) < degree (prod m A)", "by (metis deg1 degree_0 degree_mod_less gr0I gr_implies_not0)"], ["proof (state)\nthis:\n  degree (y mod prod m A) < degree (prod m A)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>degree z < (\\<Sum>i\\<in>A. degree (m i));\n        \\<forall>i\\<in>A. [z = u i] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> z = y mod prod m A", "have \"\\<forall>i\\<in>A. [?x = z] (mod m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>A. [y mod prod m A = z] (mod m i)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> [y mod prod m A = z] (mod m i)", "apply (rule cong_trans_poly)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> [y mod prod m A = ?b1 i] (mod m i)\n 2. \\<And>i. i \\<in> A \\<Longrightarrow> [?b1 i = z] (mod m i)", "using cong"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>A. [y mod prod m A = u i] (mod m i)\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> [y mod prod m A = ?b1 i] (mod m i)\n 2. \\<And>i. i \\<in> A \\<Longrightarrow> [?b1 i = z] (mod m i)", "apply (erule bspec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> [u i = z] (mod m i)", "apply (rule cong_sym_poly)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> [z = u i] (mod m i)", "using zcong"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>A. [z = u i] (mod m i)\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> [z = u i] (mod m i)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>A. [y mod prod m A = z] (mod m i)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>degree z < (\\<Sum>i\\<in>A. degree (m i));\n        \\<forall>i\\<in>A. [z = u i] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> z = y mod prod m A", "with fin cop"], ["proof (chain)\npicking this:\n  finite A\n  \\<forall>i\\<in>A.\n     \\<forall>j\\<in>A. i \\<noteq> j \\<longrightarrow> coprime (m i) (m j)\n  \\<forall>i\\<in>A. [y mod prod m A = z] (mod m i)", "have \"[?x = z] (mod (\\<Prod>i\\<in>A. m i))\""], ["proof (prove)\nusing this:\n  finite A\n  \\<forall>i\\<in>A.\n     \\<forall>j\\<in>A. i \\<noteq> j \\<longrightarrow> coprime (m i) (m j)\n  \\<forall>i\\<in>A. [y mod prod m A = z] (mod m i)\n\ngoal (1 subgoal):\n 1. [y mod prod m A = z] (mod prod m A)", "by (intro coprime_cong_prod_poly) auto"], ["proof (state)\nthis:\n  [y mod prod m A = z] (mod prod m A)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>degree z < (\\<Sum>i\\<in>A. degree (m i));\n        \\<forall>i\\<in>A. [z = u i] (mod m i)\\<rbrakk>\n       \\<Longrightarrow> z = y mod prod m A", "with zless"], ["proof (chain)\npicking this:\n  degree z < (\\<Sum>i\\<in>A. degree (m i))\n  [y mod prod m A = z] (mod prod m A)", "show \"z = ?x\""], ["proof (prove)\nusing this:\n  degree z < (\\<Sum>i\\<in>A. degree (m i))\n  [y mod prod m A = z] (mod prod m A)\n\ngoal (1 subgoal):\n 1. z = y mod prod m A", "apply (intro cong_less_modulus_unique_poly)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>degree z < (\\<Sum>i\\<in>A. degree (m i));\n     [y mod prod m A = z] (mod prod m A)\\<rbrakk>\n    \\<Longrightarrow> [z = y mod prod m A] (mod ?m2)\n 2. \\<lbrakk>degree z < (\\<Sum>i\\<in>A. degree (m i));\n     [y mod prod m A = z] (mod prod m A)\\<rbrakk>\n    \\<Longrightarrow> degree z < degree ?m2\n 3. \\<lbrakk>degree z < (\\<Sum>i\\<in>A. degree (m i));\n     [y mod prod m A = z] (mod prod m A)\\<rbrakk>\n    \\<Longrightarrow> degree (y mod prod m A) < degree ?m2", "apply (erule cong_sym_poly)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>degree z < (\\<Sum>i\\<in>A. degree (m i));\n     [y mod prod m A = z] (mod prod m A)\\<rbrakk>\n    \\<Longrightarrow> degree z < degree (prod m A)\n 2. \\<lbrakk>degree z < (\\<Sum>i\\<in>A. degree (m i));\n     [y mod prod m A = z] (mod prod m A)\\<rbrakk>\n    \\<Longrightarrow> degree (y mod prod m A) < degree (prod m A)", "apply (auto simp add:  deg1 deg2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  z = y mod prod m A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>z.\n     degree z < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n     (\\<forall>i\\<in>A. [z = u i] (mod m i)) \\<longrightarrow>\n     z = y mod prod m A\n\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       degree x < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n       (\\<forall>i\\<in>A. [x = u i] (mod m i))", "from less cong unique"], ["proof (chain)\npicking this:\n  degree (y mod prod m A) < (\\<Sum>i\\<in>A. degree (m i))\n  \\<forall>i\\<in>A. [y mod prod m A = u i] (mod m i)\n  \\<forall>z.\n     degree z < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n     (\\<forall>i\\<in>A. [z = u i] (mod m i)) \\<longrightarrow>\n     z = y mod prod m A", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (y mod prod m A) < (\\<Sum>i\\<in>A. degree (m i))\n  \\<forall>i\\<in>A. [y mod prod m A = u i] (mod m i)\n  \\<forall>z.\n     degree z < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n     (\\<forall>i\\<in>A. [z = u i] (mod m i)) \\<longrightarrow>\n     z = y mod prod m A\n\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       degree x < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n       (\\<forall>i\\<in>A. [x = u i] (mod m i))", "by blast"], ["proof (state)\nthis:\n  \\<exists>!x.\n     degree x < (\\<Sum>i\\<in>A. degree (m i)) \\<and>\n     (\\<forall>i\\<in>A. [x = u i] (mod m i))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}