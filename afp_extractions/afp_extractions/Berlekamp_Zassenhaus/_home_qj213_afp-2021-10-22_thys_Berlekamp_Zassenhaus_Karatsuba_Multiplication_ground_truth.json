{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Karatsuba_Multiplication.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma karatsuba_main_step: fixes f :: \"'a :: comm_ring_1 poly\"\n  assumes f: \"f = monom_mult n f1 + f0\" and g: \"g = monom_mult n g1 + g0\" \n  shows \n    \"monom_mult (n + n) (f1 * g1) + (monom_mult n (f1 * g1 - (f1 - f0) * (g1 - g0) + f0 * g0) + f0 * g0) = f * g\"", "lemma karatsuba_single_sided: fixes f :: \"'a :: comm_ring_1 poly\" \n  assumes \"f = monom_mult n f1 + f0\"\n  shows \"monom_mult n (f1 * g) + f0 * g = f * g\"", "lemma split_at_code[code]: \n  \"split_at n [] = ([],[])\"\n  \"split_at n (x # xs) = (if n = 0 then ([], x # xs) else case split_at (n-1) xs of (bef,aft)\n    \\<Rightarrow> (x # bef, aft))\"", "lemma poly_of_list_split_at: assumes \"split_at n f = (f0,f1)\" \n  shows \"poly_of_list f = monom_mult n (poly_of_list f1) + poly_of_list f0\"", "lemma coeffs_minus: \"poly_of_list (coeffs_minus f1 f0) = poly_of_list f1 - poly_of_list f0\"", "lemma karatsuba_main: \"karatsuba_main f n g m = poly_of_list f * poly_of_list g\"", "lemma karatsuba_mult_poly: \"karatsuba_mult_poly f g = f * g\"", "lemma karatsuba_mult_poly_code_unfold[code_unfold]: \"(*) = karatsuba_mult_poly\"", "lemmas karatsuba_monom_mult_code_unfold[code_unfold] = \n  monom_mult_unfold[where f = \"f :: 'a :: comm_ring_1 poly\" for f, unfolded karatsuba_mult_poly_code_unfold]"], "translations": [["", "lemma karatsuba_main_step: fixes f :: \"'a :: comm_ring_1 poly\"\n  assumes f: \"f = monom_mult n f1 + f0\" and g: \"g = monom_mult n g1 + g0\" \n  shows \n    \"monom_mult (n + n) (f1 * g1) + (monom_mult n (f1 * g1 - (f1 - f0) * (g1 - g0) + f0 * g0) + f0 * g0) = f * g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult (n + n) (f1 * g1) +\n    (monom_mult n (f1 * g1 - (f1 - f0) * (g1 - g0) + f0 * g0) + f0 * g0) =\n    f * g", "unfolding assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult (n + n) (f1 * g1) +\n    (monom_mult n (f1 * g1 - (f1 - f0) * (g1 - g0) + f0 * g0) + f0 * g0) =\n    (monom_mult n f1 + f0) * (monom_mult n g1 + g0)", "by (auto simp: field_simps mult_monom monom_mult_def)"], ["", "lemma karatsuba_single_sided: fixes f :: \"'a :: comm_ring_1 poly\" \n  assumes \"f = monom_mult n f1 + f0\"\n  shows \"monom_mult n (f1 * g) + f0 * g = f * g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult n (f1 * g) + f0 * g = f * g", "unfolding assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult n (f1 * g) + f0 * g = (monom_mult n f1 + f0) * g", "by (auto simp: field_simps mult_monom monom_mult_def)"], ["", "definition split_at :: \"nat \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<times> 'a list\" where \n  [code del]: \"split_at n xs = (take n xs, drop n xs)\""], ["", "lemma split_at_code[code]: \n  \"split_at n [] = ([],[])\"\n  \"split_at n (x # xs) = (if n = 0 then ([], x # xs) else case split_at (n-1) xs of (bef,aft)\n    \\<Rightarrow> (x # bef, aft))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split_at n [] = ([], []) &&&\n    split_at n (x # xs) =\n    (if n = 0 then ([], x # xs)\n     else case split_at (n - 1) xs of\n          (bef, aft) \\<Rightarrow> (x # bef, aft))", "unfolding split_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (take n [], drop n []) = ([], []) &&&\n    (take n (x # xs), drop n (x # xs)) =\n    (if n = 0 then ([], x # xs)\n     else case (take (n - 1) xs, drop (n - 1) xs) of\n          (bef, aft) \\<Rightarrow> (x # bef, aft))", "by (force, cases n, auto)"], ["", "fun coeffs_minus :: \"'a :: ab_group_add list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"coeffs_minus (x # xs) (y # ys) = ((x - y) # coeffs_minus xs ys)\" \n| \"coeffs_minus xs [] = xs\" \n| \"coeffs_minus [] ys = map uminus ys\""], ["", "text \\<open>The following constant determines at which size we will switch to the standard \n   multiplication algorithm.\\<close>"], ["", "definition karatsuba_lower_bound where [termination_simp]: \"karatsuba_lower_bound = (7 :: nat)\""], ["", "fun karatsuba_main :: \"'a :: comm_ring_1 list \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> 'a poly\" where\n  \"karatsuba_main f n g m = (if n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound then \n    let ff = poly_of_list f in foldr (\\<lambda>a p. smult a ff + pCons 0 p) g 0\n   else let n2 = n div 2 in \n   if m > n2 then (case split_at n2 f of \n   (f0,f1) \\<Rightarrow> case split_at n2 g of\n   (g0,g1) \\<Rightarrow> let \n      p1 = karatsuba_main f1 (n - n2) g1 (m - n2);\n      p2 = karatsuba_main (coeffs_minus f1 f0) n2 (coeffs_minus g1 g0) n2;\n      p3 = karatsuba_main f0 n2 g0 n2 \n      in monom_mult (n2 + n2) p1 + (monom_mult n2 (p1 - p2 + p3) + p3))\n    else case split_at n2 f of\n    (f0,f1) \\<Rightarrow> let \n       p1 = karatsuba_main f1 (n - n2) g m; \n       p2 = karatsuba_main f0 n2 g m\n     in monom_mult n2 p1 + p2)\""], ["", "declare karatsuba_main.simps[simp del]"], ["", "lemma poly_of_list_split_at: assumes \"split_at n f = (f0,f1)\" \n  shows \"poly_of_list f = monom_mult n (poly_of_list f1) + poly_of_list f0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_list f = monom_mult n (poly_of_list f1) + poly_of_list f0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_of_list f = monom_mult n (poly_of_list f1) + poly_of_list f0", "from assms"], ["proof (chain)\npicking this:\n  split_at n f = (f0, f1)", "have id: \"f1 = drop n f\" \"f0 = take n f\""], ["proof (prove)\nusing this:\n  split_at n f = (f0, f1)\n\ngoal (1 subgoal):\n 1. f1 = drop n f &&& f0 = take n f", "unfolding split_at_def"], ["proof (prove)\nusing this:\n  (take n f, drop n f) = (f0, f1)\n\ngoal (1 subgoal):\n 1. f1 = drop n f &&& f0 = take n f", "by auto"], ["proof (state)\nthis:\n  f1 = drop n f\n  f0 = take n f\n\ngoal (1 subgoal):\n 1. poly_of_list f = monom_mult n (poly_of_list f1) + poly_of_list f0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_list f = monom_mult n (poly_of_list f1) + poly_of_list f0", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_list f =\n    monom_mult n (poly_of_list (drop n f)) + poly_of_list (take n f)", "proof (rule poly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff (poly_of_list f) na =\n       coeff\n        (monom_mult n (poly_of_list (drop n f)) + poly_of_list (take n f))\n        na", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff (poly_of_list f) na =\n       coeff\n        (monom_mult n (poly_of_list (drop n f)) + poly_of_list (take n f))\n        na", "show \"coeff (poly_of_list f) i = \n      coeff (monom_mult n (poly_of_list (drop n f)) + poly_of_list (take n f)) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_of_list f) i =\n    coeff (monom_mult n (poly_of_list (drop n f)) + poly_of_list (take n f))\n     i", "unfolding monom_mult_def coeff_monom_mult coeff_add poly_of_list_def coeff_Poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default (0::'a) f i =\n    (if n \\<le> i then (1::'a) * nth_default (0::'a) (drop n f) (i - n)\n     else (0::'a)) +\n    nth_default (0::'a) (take n f) i", "by (cases \"n \\<le> i\"; cases \"i \\<ge> length f\", auto simp: nth_default_nth nth_default_beyond)"], ["proof (state)\nthis:\n  coeff (poly_of_list f) i =\n  coeff (monom_mult n (poly_of_list (drop n f)) + poly_of_list (take n f)) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_of_list f = monom_mult n (poly_of_list f1) + poly_of_list f0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeffs_minus: \"poly_of_list (coeffs_minus f1 f0) = poly_of_list f1 - poly_of_list f0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_list (coeffs_minus f1 f0) = poly_of_list f1 - poly_of_list f0", "proof (rule poly_eqI, unfold poly_of_list_def coeff_diff coeff_Poly)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       nth_default (0::'a) (coeffs_minus f1 f0) n =\n       nth_default (0::'a) f1 n - nth_default (0::'a) f0 n", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       nth_default (0::'a) (coeffs_minus f1 f0) n =\n       nth_default (0::'a) f1 n - nth_default (0::'a) f0 n", "show \"nth_default 0 (coeffs_minus f1 f0) i = nth_default 0 f1 i - nth_default 0 f0 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default (0::'a) (coeffs_minus f1 f0) i =\n    nth_default (0::'a) f1 i - nth_default (0::'a) f0 i", "proof (induct f1 f0 arbitrary: i rule: coeffs_minus.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs y ys i.\n       (\\<And>i.\n           nth_default (0::'a) (coeffs_minus xs ys) i =\n           nth_default (0::'a) xs i -\n           nth_default (0::'a) ys i) \\<Longrightarrow>\n       nth_default (0::'a) (coeffs_minus (x # xs) (y # ys)) i =\n       nth_default (0::'a) (x # xs) i - nth_default (0::'a) (y # ys) i\n 2. \\<And>xs i.\n       nth_default (0::'a) (coeffs_minus xs []) i =\n       nth_default (0::'a) xs i - nth_default (0::'a) [] i\n 3. \\<And>v va i.\n       nth_default (0::'a) (coeffs_minus [] (v # va)) i =\n       nth_default (0::'a) [] i - nth_default (0::'a) (v # va) i", "case (1 x xs y ys)"], ["proof (state)\nthis:\n  nth_default (0::'a) (coeffs_minus xs ys) ?i =\n  nth_default (0::'a) xs ?i - nth_default (0::'a) ys ?i\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys i.\n       (\\<And>i.\n           nth_default (0::'a) (coeffs_minus xs ys) i =\n           nth_default (0::'a) xs i -\n           nth_default (0::'a) ys i) \\<Longrightarrow>\n       nth_default (0::'a) (coeffs_minus (x # xs) (y # ys)) i =\n       nth_default (0::'a) (x # xs) i - nth_default (0::'a) (y # ys) i\n 2. \\<And>xs i.\n       nth_default (0::'a) (coeffs_minus xs []) i =\n       nth_default (0::'a) xs i - nth_default (0::'a) [] i\n 3. \\<And>v va i.\n       nth_default (0::'a) (coeffs_minus [] (v # va)) i =\n       nth_default (0::'a) [] i - nth_default (0::'a) (v # va) i", "thus ?case"], ["proof (prove)\nusing this:\n  nth_default (0::'a) (coeffs_minus xs ys) ?i =\n  nth_default (0::'a) xs ?i - nth_default (0::'a) ys ?i\n\ngoal (1 subgoal):\n 1. nth_default (0::'a) (coeffs_minus (x # xs) (y # ys)) i =\n    nth_default (0::'a) (x # xs) i - nth_default (0::'a) (y # ys) i", "by (cases i, auto)"], ["proof (state)\nthis:\n  nth_default (0::'a) (coeffs_minus (x # xs) (y # ys)) i =\n  nth_default (0::'a) (x # xs) i - nth_default (0::'a) (y # ys) i\n\ngoal (2 subgoals):\n 1. \\<And>xs i.\n       nth_default (0::'a) (coeffs_minus xs []) i =\n       nth_default (0::'a) xs i - nth_default (0::'a) [] i\n 2. \\<And>v va i.\n       nth_default (0::'a) (coeffs_minus [] (v # va)) i =\n       nth_default (0::'a) [] i - nth_default (0::'a) (v # va) i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs i.\n       nth_default (0::'a) (coeffs_minus xs []) i =\n       nth_default (0::'a) xs i - nth_default (0::'a) [] i\n 2. \\<And>v va i.\n       nth_default (0::'a) (coeffs_minus [] (v # va)) i =\n       nth_default (0::'a) [] i - nth_default (0::'a) (v # va) i", "case (3 x xs)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>xs i.\n       nth_default (0::'a) (coeffs_minus xs []) i =\n       nth_default (0::'a) xs i - nth_default (0::'a) [] i\n 2. \\<And>v va i.\n       nth_default (0::'a) (coeffs_minus [] (v # va)) i =\n       nth_default (0::'a) [] i - nth_default (0::'a) (v # va) i", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default (0::'a) (coeffs_minus [] (x # xs)) i =\n    nth_default (0::'a) [] i - nth_default (0::'a) (x # xs) i", "unfolding coeffs_minus.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default (0::'a) (map uminus (x # xs)) i =\n    nth_default (0::'a) [] i - nth_default (0::'a) (x # xs) i", "by (subst nth_default_map_eq[of uminus 0 0], auto)"], ["proof (state)\nthis:\n  nth_default (0::'a) (coeffs_minus [] (x # xs)) i =\n  nth_default (0::'a) [] i - nth_default (0::'a) (x # xs) i\n\ngoal (1 subgoal):\n 1. \\<And>xs i.\n       nth_default (0::'a) (coeffs_minus xs []) i =\n       nth_default (0::'a) xs i - nth_default (0::'a) [] i", "qed auto"], ["proof (state)\nthis:\n  nth_default (0::'a) (coeffs_minus f1 f0) i =\n  nth_default (0::'a) f1 i - nth_default (0::'a) f0 i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma karatsuba_main: \"karatsuba_main f n g m = poly_of_list f * poly_of_list g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. karatsuba_main f n g m = poly_of_list f * poly_of_list g", "proof (induct n arbitrary: f g m rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x f g m.\n       (\\<And>y f g m.\n           y < x \\<Longrightarrow>\n           karatsuba_main f y g m =\n           poly_of_list f * poly_of_list g) \\<Longrightarrow>\n       karatsuba_main f x g m = poly_of_list f * poly_of_list g", "case (less n f g m)"], ["proof (state)\nthis:\n  ?y < n \\<Longrightarrow>\n  karatsuba_main ?f ?y ?g ?m = poly_of_list ?f * poly_of_list ?g\n\ngoal (1 subgoal):\n 1. \\<And>x f g m.\n       (\\<And>y f g m.\n           y < x \\<Longrightarrow>\n           karatsuba_main f y g m =\n           poly_of_list f * poly_of_list g) \\<Longrightarrow>\n       karatsuba_main f x g m = poly_of_list f * poly_of_list g", "note simp[simp] = karatsuba_main.simps[of f n g m]"], ["proof (state)\nthis:\n  karatsuba_main f n g m =\n  (if n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound\n   then let ff = poly_of_list f\n        in foldr (\\<lambda>a p. smult a ff + pCons (0::'a) p) g 0\n   else let n2 = n div 2\n        in if n2 < m\n           then case split_at n2 f of\n                (f0, f1) \\<Rightarrow>\n                  case split_at n2 g of\n                  (g0, g1) \\<Rightarrow>\n                    let p1 = karatsuba_main f1 (n - n2) g1 (m - n2);\n                        p2 = karatsuba_main (coeffs_minus f1 f0) n2\n                              (coeffs_minus g1 g0) n2;\n                        p3 = karatsuba_main f0 n2 g0 n2\n                    in monom_mult (n2 + n2) p1 +\n                       (monom_mult n2 (p1 - p2 + p3) + p3)\n           else case split_at n2 f of\n                (f0, f1) \\<Rightarrow>\n                  let p1 = karatsuba_main f1 (n - n2) g m\n                  in Let (karatsuba_main f0 n2 g m)\n                      ((+) (monom_mult n2 p1)))\n\ngoal (1 subgoal):\n 1. \\<And>x f g m.\n       (\\<And>y f g m.\n           y < x \\<Longrightarrow>\n           karatsuba_main f y g m =\n           poly_of_list f * poly_of_list g) \\<Longrightarrow>\n       karatsuba_main f x g m = poly_of_list f * poly_of_list g", "show ?case (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. karatsuba_main f n g m = poly_of_list f * poly_of_list g", "proof (cases \"(n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) = False\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g\n 2. (n \\<le> karatsuba_lower_bound \\<or>\n     m \\<le> karatsuba_lower_bound) \\<noteq>\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "case False"], ["proof (state)\nthis:\n  (n \\<le> karatsuba_lower_bound \\<or>\n   m \\<le> karatsuba_lower_bound) \\<noteq>\n  False\n\ngoal (2 subgoals):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g\n 2. (n \\<le> karatsuba_lower_bound \\<or>\n     m \\<le> karatsuba_lower_bound) \\<noteq>\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "hence lhs: \"?lhs = foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons 0 p) g 0\""], ["proof (prove)\nusing this:\n  (n \\<le> karatsuba_lower_bound \\<or>\n   m \\<le> karatsuba_lower_bound) \\<noteq>\n  False\n\ngoal (1 subgoal):\n 1. karatsuba_main f n g m =\n    foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p) g 0", "by simp"], ["proof (state)\nthis:\n  karatsuba_main f n g m =\n  foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p) g 0\n\ngoal (2 subgoals):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g\n 2. (n \\<le> karatsuba_lower_bound \\<or>\n     m \\<le> karatsuba_lower_bound) \\<noteq>\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "have rhs: \"?rhs = poly_of_list g * poly_of_list f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_list f * poly_of_list g = poly_of_list g * poly_of_list f", "by simp"], ["proof (state)\nthis:\n  poly_of_list f * poly_of_list g = poly_of_list g * poly_of_list f\n\ngoal (2 subgoals):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g\n 2. (n \\<le> karatsuba_lower_bound \\<or>\n     m \\<le> karatsuba_lower_bound) \\<noteq>\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "also"], ["proof (state)\nthis:\n  poly_of_list f * poly_of_list g = poly_of_list g * poly_of_list f\n\ngoal (2 subgoals):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g\n 2. (n \\<le> karatsuba_lower_bound \\<or>\n     m \\<le> karatsuba_lower_bound) \\<noteq>\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "have \"\\<dots> = foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons 0 p) (strip_while ((=) 0) g) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_list g * poly_of_list f =\n    foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n     (strip_while ((=) (0::'a)) g) 0", "unfolding times_poly_def fold_coeffs_def poly_of_list_impl"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n     (strip_while ((=) (0::'a)) g) 0 =\n    foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n     (strip_while ((=) (0::'a)) g) 0", ".."], ["proof (state)\nthis:\n  poly_of_list g * poly_of_list f =\n  foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n   (strip_while ((=) (0::'a)) g) 0\n\ngoal (2 subgoals):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g\n 2. (n \\<le> karatsuba_lower_bound \\<or>\n     m \\<le> karatsuba_lower_bound) \\<noteq>\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "also"], ["proof (state)\nthis:\n  poly_of_list g * poly_of_list f =\n  foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n   (strip_while ((=) (0::'a)) g) 0\n\ngoal (2 subgoals):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g\n 2. (n \\<le> karatsuba_lower_bound \\<or>\n     m \\<le> karatsuba_lower_bound) \\<noteq>\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "have \"\\<dots> = ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n     (strip_while ((=) (0::'a)) g) 0 =\n    karatsuba_main f n g m", "unfolding lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n     (strip_while ((=) (0::'a)) g) 0 =\n    foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p) g 0", "proof (induct g)"], ["proof (state)\ngoal (2 subgoals):\n 1. foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n     (strip_while ((=) (0::'a)) []) 0 =\n    foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p) [] 0\n 2. \\<And>a g.\n       foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n        (strip_while ((=) (0::'a)) g) 0 =\n       foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p) g\n        0 \\<Longrightarrow>\n       foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n        (strip_while ((=) (0::'a)) (a # g)) 0 =\n       foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n        (a # g) 0", "case (Cons x xs)"], ["proof (state)\nthis:\n  foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n   (strip_while ((=) (0::'a)) xs) 0 =\n  foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p) xs 0\n\ngoal (2 subgoals):\n 1. foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n     (strip_while ((=) (0::'a)) []) 0 =\n    foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p) [] 0\n 2. \\<And>a g.\n       foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n        (strip_while ((=) (0::'a)) g) 0 =\n       foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p) g\n        0 \\<Longrightarrow>\n       foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n        (strip_while ((=) (0::'a)) (a # g)) 0 =\n       foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n        (a # g) 0", "have \"\\<forall>x\\<in>set xs. x = 0 \\<Longrightarrow> foldr (\\<lambda>a p. smult a (Poly f) + pCons 0 p) xs 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. x = (0::'a) \\<Longrightarrow>\n    foldr (\\<lambda>a p. smult a (Poly f) + pCons (0::'a) p) xs 0 = 0", "by (induct xs, auto)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. x = (0::'a) \\<Longrightarrow>\n  foldr (\\<lambda>a p. smult a (Poly f) + pCons (0::'a) p) xs 0 = 0\n\ngoal (2 subgoals):\n 1. foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n     (strip_while ((=) (0::'a)) []) 0 =\n    foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p) [] 0\n 2. \\<And>a g.\n       foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n        (strip_while ((=) (0::'a)) g) 0 =\n       foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p) g\n        0 \\<Longrightarrow>\n       foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n        (strip_while ((=) (0::'a)) (a # g)) 0 =\n       foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n        (a # g) 0", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. x = (0::'a) \\<Longrightarrow>\n  foldr (\\<lambda>a p. smult a (Poly f) + pCons (0::'a) p) xs 0 = 0\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n     (strip_while ((=) (0::'a)) (x # xs)) 0 =\n    foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n     (x # xs) 0", "using Cons"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. x = (0::'a) \\<Longrightarrow>\n  foldr (\\<lambda>a p. smult a (Poly f) + pCons (0::'a) p) xs 0 = 0\n  foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n   (strip_while ((=) (0::'a)) xs) 0 =\n  foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p) xs 0\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n     (strip_while ((=) (0::'a)) (x # xs)) 0 =\n    foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n     (x # xs) 0", "by (auto simp: cCons_def Cons)"], ["proof (state)\nthis:\n  foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n   (strip_while ((=) (0::'a)) (x # xs)) 0 =\n  foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p) (x # xs)\n   0\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n     (strip_while ((=) (0::'a)) []) 0 =\n    foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p) [] 0", "qed auto"], ["proof (state)\nthis:\n  foldr (\\<lambda>a p. smult a (poly_of_list f) + pCons (0::'a) p)\n   (strip_while ((=) (0::'a)) g) 0 =\n  karatsuba_main f n g m\n\ngoal (2 subgoals):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g\n 2. (n \\<le> karatsuba_lower_bound \\<or>\n     m \\<le> karatsuba_lower_bound) \\<noteq>\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "finally"], ["proof (chain)\npicking this:\n  poly_of_list f * poly_of_list g = karatsuba_main f n g m", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_of_list f * poly_of_list g = karatsuba_main f n g m\n\ngoal (1 subgoal):\n 1. karatsuba_main f n g m = poly_of_list f * poly_of_list g", "by simp"], ["proof (state)\nthis:\n  karatsuba_main f n g m = poly_of_list f * poly_of_list g\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "case True"], ["proof (state)\nthis:\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "let ?n2 = \"n div 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "have \"?n2 < n\" \"n - ?n2 < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n div 2 < n &&& n - n div 2 < n", "using True"], ["proof (prove)\nusing this:\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False\n\ngoal (1 subgoal):\n 1. n div 2 < n &&& n - n div 2 < n", "unfolding karatsuba_lower_bound_def"], ["proof (prove)\nusing this:\n  (n \\<le> 7 \\<or> m \\<le> 7) = False\n\ngoal (1 subgoal):\n 1. n div 2 < n &&& n - n div 2 < n", "by auto"], ["proof (state)\nthis:\n  n div 2 < n\n  n - n div 2 < n\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "note IH = less[OF this(1)] less[OF this(2)]"], ["proof (state)\nthis:\n  karatsuba_main ?f (n div 2) ?g ?m = poly_of_list ?f * poly_of_list ?g\n  karatsuba_main ?f (n - n div 2) ?g ?m = poly_of_list ?f * poly_of_list ?g\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "obtain f1 f0 where f: \"split_at ?n2 f = (f0,f1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f0 f1.\n        split_at (n div 2) f = (f0, f1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  split_at (n div 2) f = (f0, f1)\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "obtain g1 g0 where g: \"split_at ?n2 g = (g0,g1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g0 g1.\n        split_at (n div 2) g = (g0, g1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  split_at (n div 2) g = (g0, g1)\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "note fsplit = poly_of_list_split_at[OF f]"], ["proof (state)\nthis:\n  poly_of_list f = monom_mult (n div 2) (poly_of_list f1) + poly_of_list f0\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "note gsplit = poly_of_list_split_at[OF g]"], ["proof (state)\nthis:\n  poly_of_list g = monom_mult (n div 2) (poly_of_list g1) + poly_of_list g0\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    karatsuba_main f n g m = poly_of_list f * poly_of_list g", "show \"?lhs = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. karatsuba_main f n g m = poly_of_list f * poly_of_list g", "unfolding simp Let_def f g split IH True if_False coeffs_minus\n      karatsuba_single_sided[OF fsplit] karatsuba_main_step[OF fsplit gsplit]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n div 2 < m then poly_of_list f * poly_of_list g\n     else poly_of_list f * poly_of_list g) =\n    poly_of_list f * poly_of_list g", "by auto"], ["proof (state)\nthis:\n  karatsuba_main f n g m = poly_of_list f * poly_of_list g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  karatsuba_main f n g m = poly_of_list f * poly_of_list g\n\ngoal:\nNo subgoals!", "qed"], ["", "definition karatsuba_mult_poly :: \"'a :: comm_ring_1 poly \\<Rightarrow> 'a poly \\<Rightarrow> 'a poly\" where\n  \"karatsuba_mult_poly f g = (let ff = coeffs f; gg = coeffs g; n = length ff; m = length gg\n    in (if n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound then if n \\<le> m \n    then foldr (\\<lambda>a p. smult a g + pCons 0 p) ff 0 \n    else foldr (\\<lambda>a p. smult a f + pCons 0 p) gg 0 \n    else if n \\<le> m \n    then karatsuba_main gg m ff n \n    else karatsuba_main ff n gg m))\""], ["", "lemma karatsuba_mult_poly: \"karatsuba_mult_poly f g = f * g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. karatsuba_mult_poly f g = f * g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. karatsuba_mult_poly f g = f * g", "note d = karatsuba_mult_poly_def Let_def"], ["proof (state)\nthis:\n  karatsuba_mult_poly ?f ?g =\n  (let ff = coeffs ?f; gg = coeffs ?g; n = length ff; m = length gg\n   in if n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound\n      then if n \\<le> m\n           then foldr (\\<lambda>a p. smult a ?g + pCons (0::?'a) p) ff 0\n           else foldr (\\<lambda>a p. smult a ?f + pCons (0::?'a) p) gg 0\n      else if n \\<le> m then karatsuba_main gg m ff n\n           else karatsuba_main ff n gg m)\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (1 subgoal):\n 1. karatsuba_mult_poly f g = f * g", "let ?len = \"length (coeffs f) \\<le> length (coeffs g)\""], ["proof (state)\ngoal (1 subgoal):\n 1. karatsuba_mult_poly f g = f * g", "show ?thesis (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. karatsuba_mult_poly f g = f * g", "proof (cases \"length (coeffs f) \\<le> karatsuba_lower_bound \\<or> length (coeffs g) \\<le> karatsuba_lower_bound\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n    length (coeffs g) \\<le> karatsuba_lower_bound \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g\n 2. \\<not> (length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n            length (coeffs g) \\<le> karatsuba_lower_bound) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "case True"], ["proof (state)\nthis:\n  length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n  length (coeffs g) \\<le> karatsuba_lower_bound\n\ngoal (2 subgoals):\n 1. length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n    length (coeffs g) \\<le> karatsuba_lower_bound \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g\n 2. \\<not> (length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n            length (coeffs g) \\<le> karatsuba_lower_bound) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "note outer = this"], ["proof (state)\nthis:\n  length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n  length (coeffs g) \\<le> karatsuba_lower_bound\n\ngoal (2 subgoals):\n 1. length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n    length (coeffs g) \\<le> karatsuba_lower_bound \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g\n 2. \\<not> (length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n            length (coeffs g) \\<le> karatsuba_lower_bound) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. karatsuba_mult_poly f g = f * g", "proof (cases ?len)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g\n 2. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "case True"], ["proof (state)\nthis:\n  length (coeffs f) \\<le> length (coeffs g)\n\ngoal (2 subgoals):\n 1. length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g\n 2. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "with outer"], ["proof (chain)\npicking this:\n  length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n  length (coeffs g) \\<le> karatsuba_lower_bound\n  length (coeffs f) \\<le> length (coeffs g)", "have \"?lhs = foldr (\\<lambda>a p. smult a g + pCons 0 p) (coeffs f) 0\""], ["proof (prove)\nusing this:\n  length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n  length (coeffs g) \\<le> karatsuba_lower_bound\n  length (coeffs f) \\<le> length (coeffs g)\n\ngoal (1 subgoal):\n 1. karatsuba_mult_poly f g =\n    foldr (\\<lambda>a p. smult a g + pCons (0::'a) p) (coeffs f) 0", "unfolding d"], ["proof (prove)\nusing this:\n  length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n  length (coeffs g) \\<le> karatsuba_lower_bound\n  length (coeffs f) \\<le> length (coeffs g)\n\ngoal (1 subgoal):\n 1. (if length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n        length (coeffs g) \\<le> karatsuba_lower_bound\n     then if length (coeffs f) \\<le> length (coeffs g)\n          then foldr (\\<lambda>a p. smult a g + pCons (0::'a) p) (coeffs f)\n                0\n          else foldr (\\<lambda>a p. smult a f + pCons (0::'a) p) (coeffs g)\n                0\n     else if length (coeffs f) \\<le> length (coeffs g)\n          then karatsuba_main (coeffs g) (length (coeffs g)) (coeffs f)\n                (length (coeffs f))\n          else karatsuba_main (coeffs f) (length (coeffs f)) (coeffs g)\n                (length (coeffs g))) =\n    foldr (\\<lambda>a p. smult a g + pCons (0::'a) p) (coeffs f) 0", "by auto"], ["proof (state)\nthis:\n  karatsuba_mult_poly f g =\n  foldr (\\<lambda>a p. smult a g + pCons (0::'a) p) (coeffs f) 0\n\ngoal (2 subgoals):\n 1. length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g\n 2. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "also"], ["proof (state)\nthis:\n  karatsuba_mult_poly f g =\n  foldr (\\<lambda>a p. smult a g + pCons (0::'a) p) (coeffs f) 0\n\ngoal (2 subgoals):\n 1. length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g\n 2. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a p. smult a g + pCons (0::'a) p) (coeffs f) 0 = f * g", "unfolding times_poly_def fold_coeffs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a p. smult a g + pCons (0::'a) p) (coeffs f) 0 =\n    foldr (\\<lambda>a p. smult a g + pCons (0::'a) p) (coeffs f) 0", "by auto"], ["proof (state)\nthis:\n  foldr (\\<lambda>a p. smult a g + pCons (0::'a) p) (coeffs f) 0 = f * g\n\ngoal (2 subgoals):\n 1. length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g\n 2. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "finally"], ["proof (chain)\npicking this:\n  karatsuba_mult_poly f g = f * g", "show ?thesis"], ["proof (prove)\nusing this:\n  karatsuba_mult_poly f g = f * g\n\ngoal (1 subgoal):\n 1. karatsuba_mult_poly f g = f * g", "."], ["proof (state)\nthis:\n  karatsuba_mult_poly f g = f * g\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "case False"], ["proof (state)\nthis:\n  \\<not> length (coeffs f) \\<le> length (coeffs g)\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "with outer"], ["proof (chain)\npicking this:\n  length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n  length (coeffs g) \\<le> karatsuba_lower_bound\n  \\<not> length (coeffs f) \\<le> length (coeffs g)", "have \"?lhs = foldr (\\<lambda>a p. smult a f + pCons 0 p) (coeffs g) 0\""], ["proof (prove)\nusing this:\n  length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n  length (coeffs g) \\<le> karatsuba_lower_bound\n  \\<not> length (coeffs f) \\<le> length (coeffs g)\n\ngoal (1 subgoal):\n 1. karatsuba_mult_poly f g =\n    foldr (\\<lambda>a p. smult a f + pCons (0::'a) p) (coeffs g) 0", "unfolding d"], ["proof (prove)\nusing this:\n  length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n  length (coeffs g) \\<le> karatsuba_lower_bound\n  \\<not> length (coeffs f) \\<le> length (coeffs g)\n\ngoal (1 subgoal):\n 1. (if length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n        length (coeffs g) \\<le> karatsuba_lower_bound\n     then if length (coeffs f) \\<le> length (coeffs g)\n          then foldr (\\<lambda>a p. smult a g + pCons (0::'a) p) (coeffs f)\n                0\n          else foldr (\\<lambda>a p. smult a f + pCons (0::'a) p) (coeffs g)\n                0\n     else if length (coeffs f) \\<le> length (coeffs g)\n          then karatsuba_main (coeffs g) (length (coeffs g)) (coeffs f)\n                (length (coeffs f))\n          else karatsuba_main (coeffs f) (length (coeffs f)) (coeffs g)\n                (length (coeffs g))) =\n    foldr (\\<lambda>a p. smult a f + pCons (0::'a) p) (coeffs g) 0", "by auto"], ["proof (state)\nthis:\n  karatsuba_mult_poly f g =\n  foldr (\\<lambda>a p. smult a f + pCons (0::'a) p) (coeffs g) 0\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "also"], ["proof (state)\nthis:\n  karatsuba_mult_poly f g =\n  foldr (\\<lambda>a p. smult a f + pCons (0::'a) p) (coeffs g) 0\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "have \"\\<dots> = g * f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a p. smult a f + pCons (0::'a) p) (coeffs g) 0 = g * f", "unfolding times_poly_def fold_coeffs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a p. smult a f + pCons (0::'a) p) (coeffs g) 0 =\n    foldr (\\<lambda>a p. smult a f + pCons (0::'a) p) (coeffs g) 0", "by auto"], ["proof (state)\nthis:\n  foldr (\\<lambda>a p. smult a f + pCons (0::'a) p) (coeffs g) 0 = g * f\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "also"], ["proof (state)\nthis:\n  foldr (\\<lambda>a p. smult a f + pCons (0::'a) p) (coeffs g) 0 = g * f\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g * f = f * g", "by simp"], ["proof (state)\nthis:\n  g * f = f * g\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "finally"], ["proof (chain)\npicking this:\n  karatsuba_mult_poly f g = f * g", "show ?thesis"], ["proof (prove)\nusing this:\n  karatsuba_mult_poly f g = f * g\n\ngoal (1 subgoal):\n 1. karatsuba_mult_poly f g = f * g", "."], ["proof (state)\nthis:\n  karatsuba_mult_poly f g = f * g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  karatsuba_mult_poly f g = f * g\n\ngoal (1 subgoal):\n 1. \\<not> (length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n            length (coeffs g) \\<le> karatsuba_lower_bound) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n            length (coeffs g) \\<le> karatsuba_lower_bound) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "case False"], ["proof (state)\nthis:\n  \\<not> (length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n          length (coeffs g) \\<le> karatsuba_lower_bound)\n\ngoal (1 subgoal):\n 1. \\<not> (length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n            length (coeffs g) \\<le> karatsuba_lower_bound) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "note outer = this"], ["proof (state)\nthis:\n  \\<not> (length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n          length (coeffs g) \\<le> karatsuba_lower_bound)\n\ngoal (1 subgoal):\n 1. \\<not> (length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n            length (coeffs g) \\<le> karatsuba_lower_bound) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. karatsuba_mult_poly f g = f * g", "proof (cases ?len)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g\n 2. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "case True"], ["proof (state)\nthis:\n  length (coeffs f) \\<le> length (coeffs g)\n\ngoal (2 subgoals):\n 1. length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g\n 2. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "with outer"], ["proof (chain)\npicking this:\n  \\<not> (length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n          length (coeffs g) \\<le> karatsuba_lower_bound)\n  length (coeffs f) \\<le> length (coeffs g)", "have \"?lhs = karatsuba_main (coeffs g) (length (coeffs g)) (coeffs f) (length (coeffs f))\""], ["proof (prove)\nusing this:\n  \\<not> (length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n          length (coeffs g) \\<le> karatsuba_lower_bound)\n  length (coeffs f) \\<le> length (coeffs g)\n\ngoal (1 subgoal):\n 1. karatsuba_mult_poly f g =\n    karatsuba_main (coeffs g) (length (coeffs g)) (coeffs f)\n     (length (coeffs f))", "unfolding d"], ["proof (prove)\nusing this:\n  \\<not> (length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n          length (coeffs g) \\<le> karatsuba_lower_bound)\n  length (coeffs f) \\<le> length (coeffs g)\n\ngoal (1 subgoal):\n 1. (if length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n        length (coeffs g) \\<le> karatsuba_lower_bound\n     then if length (coeffs f) \\<le> length (coeffs g)\n          then foldr (\\<lambda>a p. smult a g + pCons (0::'a) p) (coeffs f)\n                0\n          else foldr (\\<lambda>a p. smult a f + pCons (0::'a) p) (coeffs g)\n                0\n     else if length (coeffs f) \\<le> length (coeffs g)\n          then karatsuba_main (coeffs g) (length (coeffs g)) (coeffs f)\n                (length (coeffs f))\n          else karatsuba_main (coeffs f) (length (coeffs f)) (coeffs g)\n                (length (coeffs g))) =\n    karatsuba_main (coeffs g) (length (coeffs g)) (coeffs f)\n     (length (coeffs f))", "by auto"], ["proof (state)\nthis:\n  karatsuba_mult_poly f g =\n  karatsuba_main (coeffs g) (length (coeffs g)) (coeffs f)\n   (length (coeffs f))\n\ngoal (2 subgoals):\n 1. length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g\n 2. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "also"], ["proof (state)\nthis:\n  karatsuba_mult_poly f g =\n  karatsuba_main (coeffs g) (length (coeffs g)) (coeffs f)\n   (length (coeffs f))\n\ngoal (2 subgoals):\n 1. length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g\n 2. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "have \"\\<dots> = g * f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. karatsuba_main (coeffs g) (length (coeffs g)) (coeffs f)\n     (length (coeffs f)) =\n    g * f", "unfolding karatsuba_main"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_list (coeffs g) * poly_of_list (coeffs f) = g * f", "by auto"], ["proof (state)\nthis:\n  karatsuba_main (coeffs g) (length (coeffs g)) (coeffs f)\n   (length (coeffs f)) =\n  g * f\n\ngoal (2 subgoals):\n 1. length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g\n 2. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "also"], ["proof (state)\nthis:\n  karatsuba_main (coeffs g) (length (coeffs g)) (coeffs f)\n   (length (coeffs f)) =\n  g * f\n\ngoal (2 subgoals):\n 1. length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g\n 2. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g * f = f * g", "by auto"], ["proof (state)\nthis:\n  g * f = f * g\n\ngoal (2 subgoals):\n 1. length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g\n 2. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "finally"], ["proof (chain)\npicking this:\n  karatsuba_mult_poly f g = f * g", "show ?thesis"], ["proof (prove)\nusing this:\n  karatsuba_mult_poly f g = f * g\n\ngoal (1 subgoal):\n 1. karatsuba_mult_poly f g = f * g", "."], ["proof (state)\nthis:\n  karatsuba_mult_poly f g = f * g\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "case False"], ["proof (state)\nthis:\n  \\<not> length (coeffs f) \\<le> length (coeffs g)\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "with outer"], ["proof (chain)\npicking this:\n  \\<not> (length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n          length (coeffs g) \\<le> karatsuba_lower_bound)\n  \\<not> length (coeffs f) \\<le> length (coeffs g)", "have \"?lhs = karatsuba_main (coeffs f) (length (coeffs f)) (coeffs g) (length (coeffs g))\""], ["proof (prove)\nusing this:\n  \\<not> (length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n          length (coeffs g) \\<le> karatsuba_lower_bound)\n  \\<not> length (coeffs f) \\<le> length (coeffs g)\n\ngoal (1 subgoal):\n 1. karatsuba_mult_poly f g =\n    karatsuba_main (coeffs f) (length (coeffs f)) (coeffs g)\n     (length (coeffs g))", "unfolding d"], ["proof (prove)\nusing this:\n  \\<not> (length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n          length (coeffs g) \\<le> karatsuba_lower_bound)\n  \\<not> length (coeffs f) \\<le> length (coeffs g)\n\ngoal (1 subgoal):\n 1. (if length (coeffs f) \\<le> karatsuba_lower_bound \\<or>\n        length (coeffs g) \\<le> karatsuba_lower_bound\n     then if length (coeffs f) \\<le> length (coeffs g)\n          then foldr (\\<lambda>a p. smult a g + pCons (0::'a) p) (coeffs f)\n                0\n          else foldr (\\<lambda>a p. smult a f + pCons (0::'a) p) (coeffs g)\n                0\n     else if length (coeffs f) \\<le> length (coeffs g)\n          then karatsuba_main (coeffs g) (length (coeffs g)) (coeffs f)\n                (length (coeffs f))\n          else karatsuba_main (coeffs f) (length (coeffs f)) (coeffs g)\n                (length (coeffs g))) =\n    karatsuba_main (coeffs f) (length (coeffs f)) (coeffs g)\n     (length (coeffs g))", "by auto"], ["proof (state)\nthis:\n  karatsuba_mult_poly f g =\n  karatsuba_main (coeffs f) (length (coeffs f)) (coeffs g)\n   (length (coeffs g))\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "also"], ["proof (state)\nthis:\n  karatsuba_mult_poly f g =\n  karatsuba_main (coeffs f) (length (coeffs f)) (coeffs g)\n   (length (coeffs g))\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. karatsuba_main (coeffs f) (length (coeffs f)) (coeffs g)\n     (length (coeffs g)) =\n    f * g", "unfolding karatsuba_main"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_list (coeffs f) * poly_of_list (coeffs g) = f * g", "by auto"], ["proof (state)\nthis:\n  karatsuba_main (coeffs f) (length (coeffs f)) (coeffs g)\n   (length (coeffs g)) =\n  f * g\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs f) \\<le> length (coeffs g) \\<Longrightarrow>\n    karatsuba_mult_poly f g = f * g", "finally"], ["proof (chain)\npicking this:\n  karatsuba_mult_poly f g = f * g", "show ?thesis"], ["proof (prove)\nusing this:\n  karatsuba_mult_poly f g = f * g\n\ngoal (1 subgoal):\n 1. karatsuba_mult_poly f g = f * g", "."], ["proof (state)\nthis:\n  karatsuba_mult_poly f g = f * g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  karatsuba_mult_poly f g = f * g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  karatsuba_mult_poly f g = f * g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma karatsuba_mult_poly_code_unfold[code_unfold]: \"(*) = karatsuba_mult_poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (*) = karatsuba_mult_poly", "by (intro ext, unfold karatsuba_mult_poly, auto)"], ["", "text \\<open>The following declaration will resolve a race-conflict between @{thm karatsuba_mult_poly_code_unfold}\n  and @{thm monom_mult_unfold}.\\<close>"], ["", "lemmas karatsuba_monom_mult_code_unfold[code_unfold] = \n  monom_mult_unfold[where f = \"f :: 'a :: comm_ring_1 poly\" for f, unfolded karatsuba_mult_poly_code_unfold]"], ["", "end"]]}