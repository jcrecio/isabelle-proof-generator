{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Hensel_Lifting_Type_Based.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma degree_smult_eq_iff:\n  \"degree (smult a p) = degree p \\<longleftrightarrow> degree p = 0 \\<or> a * lead_coeff p \\<noteq> 0\"", "lemma degree_smult_eqI[intro!]:\n  assumes \"degree p \\<noteq> 0 \\<Longrightarrow> a * lead_coeff p \\<noteq> 0\"\n  shows \"degree (smult a p) = degree p\"", "lemma degree_mult_eq2:\n  assumes lc: \"lead_coeff p * lead_coeff q \\<noteq> 0\"\n  shows \"degree (p * q) = degree p + degree q\" (is \"_ = ?r\")", "lemma degree_mult_eq_left_unit:\n  fixes p q :: \"'a :: comm_semiring_1 poly\"\n  assumes unit: \"lead_coeff p dvd 1\" and q0: \"q \\<noteq> 0\"\n  shows \"degree (p * q) = degree p + degree q\"", "lemma monic_degree_map_poly_hom: \"monic p \\<Longrightarrow> degree (map_poly hom p) = degree p\"", "lemma monic_map_poly_hom: \"monic p \\<Longrightarrow> monic (map_poly hom p)\"", "lemma of_nat_zero:\n  assumes \"CARD('a::nontriv) dvd n\"\n  shows \"(of_nat n :: 'a mod_ring) = 0\"", "lemma rebase_self [simp]:\n  \"@x = x\"", "lemma map_poly_rebase [simp]:\n  \"map_poly rebase p = #p\"", "lemma rebase_poly_0: \"#0 = 0\"", "lemma rebase_poly_1: \"#1 = 1\"", "lemma rebase_poly_pCons[simp]: \"#pCons a p = pCons (@a) (#p)\"", "lemma rebase_poly_self[simp]: \"#p = p\"", "lemma degree_rebase_poly_le: \"degree (#p) \\<le> degree p\"", "lemma(in comm_ring_hom) degree_map_poly_unit: assumes \"lead_coeff p dvd 1\"\n  shows \"degree (map_poly hom p) = degree p\"", "lemma rebase_poly_eq_0_iff:\n  \"(#p :: 'a :: nontriv mod_ring poly) = 0 \\<longleftrightarrow> (\\<forall>i. (@coeff p i :: 'a mod_ring) = 0)\" (is \"?l \\<longleftrightarrow> ?r\")", "lemma mod_mod_le:\n  assumes ab: \"(a::int) \\<le> b\" and a0: \"0 < a\" and c0: \"c \\<ge> 0\" shows \"(c mod a) mod b = c mod a\"", "lemma ab: \"int CARD('a) \\<le> CARD('b)\"", "lemma rebase_eq_0[simp]:\n  shows \"(@(x :: 'a mod_ring) :: 'b mod_ring) = 0 \\<longleftrightarrow> x = 0\"", "lemma degree_rebase_poly_eq[simp]:\n  shows \"degree (#(p :: 'a mod_ring poly) :: 'b mod_ring poly) = degree p\"", "lemma lead_coeff_rebase_poly[simp]:\n  \"lead_coeff (#(p::'a mod_ring poly) :: 'b mod_ring poly) = @lead_coeff p\"", "lemma to_int_mod_ring_rebase: \"to_int_mod_ring(@(x :: 'a mod_ring)::'b mod_ring) = to_int_mod_ring x\"", "lemma rebase_id[simp]: \"@(@(x::'a mod_ring) :: 'b mod_ring) = @x\"", "lemma rebase_poly_id[simp]: \"#(#(p::'a mod_ring poly) :: 'b mod_ring poly) = #p\"", "lemma ab: \"CARD('a) \\<ge> CARD('b)\"", "lemma rebase_id[simp]: \"@(@(x::'b mod_ring) :: 'a mod_ring) = x\"", "lemma rebase_poly_id[simp]: \"#(#(p::'b mod_ring poly) :: 'a mod_ring poly) = p\"", "lemma rebase_of_nat[simp]: \"(@(of_nat n :: 'a mod_ring) :: 'b mod_ring) = of_nat n\"", "lemma mod_1_lift_nat:\n  assumes \"(of_int (int x) :: 'a mod_ring) = 1\"\n  shows \"(of_int (int x) :: 'b mod_ring) = 1\"", "lemma of_nat_CARD_eq_0[simp]: \"(of_nat CARD('a) :: 'b mod_ring) = 0\"", "lemma poly_rebase[simp]: \"@poly p x = poly (#(p :: 'a mod_ring poly) :: 'b mod_ring poly) (@(x::'a mod_ring) :: 'b mod_ring)\"", "lemma rebase_poly_smult[simp]: \"(#(smult a p :: 'a mod_ring poly) :: 'b mod_ring poly) = smult (@a) (#p)\"", "lemma rebase_mult_eq[simp]: \"(of_nat CARD('d) * a :: 'a mod_ring) = of_nat CARD('d) * a' \\<longleftrightarrow> (@a :: 'b mod_ring) = @a'\"", "lemma rebase_poly_smult_eq[simp]:\n  fixes a a' :: \"'a mod_ring poly\"\n  defines \"d \\<equiv> of_nat CARD('d) :: 'a mod_ring\"\n  shows \"smult d a = smult d a' \\<longleftrightarrow> (#a :: 'b mod_ring poly) = #a'\" (is \"?l \\<longleftrightarrow> ?r\")", "lemma rebase_eq_0_imp_ex_mult:\n  \"(@(a :: 'a mod_ring) :: 'b mod_ring) = 0 \\<Longrightarrow> (\\<exists>c :: 'd mod_ring. a = of_nat CARD('b) * @c)\" (is \"?l \\<Longrightarrow> ?r\")", "lemma rebase_poly_eq_0_imp_ex_smult:\n  \"(#(p :: 'a mod_ring poly) :: 'b mod_ring poly) = 0 \\<Longrightarrow>\n   (\\<exists>p' :: 'd mod_ring poly. (p = 0 \\<longleftrightarrow> p' = 0) \\<and> degree p' \\<le> degree p \\<and> p = smult (of_nat CARD('b)) (#p'))\"\n  (is \"?l \\<Longrightarrow> ?r\")", "lemma mod_mod_nat[simp]: \"a mod b mod (b * c :: nat) = a mod b\"", "lemma p[simp]: \"p \\<equiv> CARD('p)\"", "lemma q[simp]: \"q = CARD('q)\"", "lemma p1: \"int p > 1\"", "lemma q1: \"int q > 1\"", "lemma q0: \"int q > 0\"", "lemma pq2[simp]: \"CARD('pq) = p * q\"", "lemma qq_eq_0[simp]: \"(of_nat CARD('q) * of_nat CARD('q) :: 'pq mod_ring) = 0\"", "lemma of_nat_q[simp]: \"of_nat q :: 'q mod_ring \\<equiv> 0\"", "lemma rebase_rebase[simp]: \"(@(@(x::'pq mod_ring) :: 'q mod_ring) :: 'p mod_ring) = @x\"", "lemma rebase_rebase_poly[simp]: \"(#(#(f::'pq mod_ring poly) :: 'q mod_ring poly) :: 'p mod_ring poly) = #f\"", "lemma dupe_monic:\n  fixes D :: \"'a :: prime_card mod_ring poly\"\n  assumes 1: \"D*S + H*T = 1\"\n  and mon: \"monic D\"\n  and dupe: \"dupe_monic D H S T U = (A,B)\" \n  shows \"A * D + B * H = U\" \"B = 0 \\<or> degree B < degree D\"\n    \"coprime D H \\<Longrightarrow> A' * D + B' * H = U \\<Longrightarrow> B' = 0 \\<or> degree B' < degree D \\<Longrightarrow> A' = A \\<and> B' = B\"", "lemma deg_v: \"degree (#v :: 'p mod_ring poly) = degree v\"", "lemma u0: \"u \\<noteq> 0\"", "lemma ex_f: \"\\<exists>f :: 'p mod_ring poly. u = #v * #w + smult (of_nat q) (#f)\"", "lemma u: \"u = #v * #w + smult (of_nat q) (#f)\"", "lemma t_ex: \"\\<exists>t :: 'p mod_ring poly. degree (b * f - t * #v) < degree v\"", "lemma f: \"w' * #v + v' * #w = f\" (is \"?l = _\")", "lemma degv': \"degree v' < degree v\"", "lemma degqf[simp]: \"degree (smult (of_nat CARD('q)) (#f :: 'pq mod_ring poly)) = degree (#f :: 'pq mod_ring poly)\"", "lemma degw': \"degree w' \\<le> degree w\"", "lemma vV: \"v = #V\"", "lemma wW: \"w = #W\"", "lemma uVW: \"u = V * W\"", "lemma degV: \"degree V = degree v\"\n  and lcV: \"lead_coeff V = @lead_coeff v\"\n  and degW: \"degree W = degree w\"", "lemma coprime_preserves: \"coprime (#V :: 'p mod_ring poly) (#W)\"", "lemma pre_unique:\n  assumes f2: \"w'' * #v + v'' * #w = f\"\n      and degv'': \"degree v'' < degree v\"\n  shows \"v'' = v' \\<and> w'' = w'\"", "lemma unique:\n  assumes vV2: \"v = #V2\" and wW2: \"w = #W2\" and uVW2: \"u = V2 * W2\"\n      and degV2: \"degree V2 = degree v\" and degW2: \"degree W2 = degree w\"\n      and lc: \"lead_coeff V2 = @lead_coeff v\"\n  shows \"V2 = V\" \"W2 = W\"", "lemma hensel_1:\n  fixes u :: \"'pq :: nontriv mod_ring poly\"\n    and v w :: \"'q :: nontriv mod_ring poly\"\n  assumes \"CARD('pq) = CARD('p :: prime_card) * CARD('q)\"\n      and \"CARD('p) dvd CARD('q)\"\n      and uvw: \"#u = v * w\"\n      and degu: \"degree u = degree v + degree w\"\n      and monic: \"monic v\"\n      and coprime: \"coprime (#v :: 'p mod_ring poly) (#w)\"\n      and out: \"hensel_1 TYPE('p) u v w = (V',W')\"\n  shows \"u = V' * W' \\<and> v = #V' \\<and> w = #W' \\<and> degree V' = degree v \\<and> degree W' = degree w \\<and>\n         monic V' \\<and> coprime (#V' :: 'p mod_ring poly) (#W')\" (is ?main)\n    and \"(\\<forall>V'' W''. u = V'' * W'' \\<longrightarrow> v = #V'' \\<longrightarrow> w = #W'' \\<longrightarrow>\n          degree V'' = degree v \\<longrightarrow> degree W'' = degree w \\<longrightarrow> lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n          V'' = V' \\<and> W'' = W')\" (is \"?unique\")"], "translations": [["", "lemma degree_smult_eq_iff:\n  \"degree (smult a p) = degree p \\<longleftrightarrow> degree p = 0 \\<or> a * lead_coeff p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (degree (Polynomial.smult a p) = degree p) =\n    (degree p = 0 \\<or> a * lead_coeff p \\<noteq> (0::'a))", "by (metis (no_types, lifting) coeff_smult degree_0 degree_smult_le le_antisym \n      le_degree le_zero_eq leading_coeff_0_iff)"], ["", "lemma degree_smult_eqI[intro!]:\n  assumes \"degree p \\<noteq> 0 \\<Longrightarrow> a * lead_coeff p \\<noteq> 0\"\n  shows \"degree (smult a p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Polynomial.smult a p) = degree p", "using assms degree_smult_eq_iff"], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0 \\<Longrightarrow> a * lead_coeff p \\<noteq> (0::'a)\n  (degree (Polynomial.smult ?a ?p) = degree ?p) =\n  (degree ?p = 0 \\<or> ?a * lead_coeff ?p \\<noteq> (0::?'a))\n\ngoal (1 subgoal):\n 1. degree (Polynomial.smult a p) = degree p", "by auto"], ["", "lemma degree_mult_eq2:\n  assumes lc: \"lead_coeff p * lead_coeff q \\<noteq> 0\"\n  shows \"degree (p * q) = degree p + degree q\" (is \"_ = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (p * q) = degree p + degree q", "proof(intro antisym[OF degree_mult_le] le_degree, unfold coeff_mult)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) \\<noteq>\n    (0::'a)", "let ?f = \"\\<lambda>i. coeff p i * coeff q (?r - i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) \\<noteq>\n    (0::'a)", "have \"(\\<Sum>i\\<le>?r. ?f i) = sum ?f {..degree p} + sum ?f {Suc (degree p)..?r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (\\<Sum>i\\<le>degree p.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) +\n    (\\<Sum>i = Suc (degree p)..degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i))", "by (rule sum_up_index_split)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree p + degree q.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n  (\\<Sum>i\\<le>degree p.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) +\n  (\\<Sum>i = Suc (degree p)..degree p + degree q.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) \\<noteq>\n    (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree p + degree q.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n  (\\<Sum>i\\<le>degree p.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) +\n  (\\<Sum>i = Suc (degree p)..degree p + degree q.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) \\<noteq>\n    (0::'a)", "have \"sum ?f {Suc (degree p)..?r} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc (degree p)..degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc (degree p)..degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc (degree p)..degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc (degree p)..degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "assume \"x > degree p\""], ["proof (state)\nthis:\n  degree p < x\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc (degree p)..degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "then"], ["proof (chain)\npicking this:\n  degree p < x", "have \"coeff p x = 0\""], ["proof (prove)\nusing this:\n  degree p < x\n\ngoal (1 subgoal):\n 1. poly.coeff p x = (0::'a)", "by (rule coeff_eq_0)"], ["proof (state)\nthis:\n  poly.coeff p x = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc (degree p)..degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "then"], ["proof (chain)\npicking this:\n  poly.coeff p x = (0::'a)", "have \"?f x = 0\""], ["proof (prove)\nusing this:\n  poly.coeff p x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly.coeff p x * poly.coeff q (degree p + degree q - x) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  poly.coeff p x * poly.coeff q (degree p + degree q - x) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc (degree p)..degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "}"], ["proof (state)\nthis:\n  degree p < ?x2 \\<Longrightarrow>\n  poly.coeff p ?x2 * poly.coeff q (degree p + degree q - ?x2) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc (degree p)..degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "then"], ["proof (chain)\npicking this:\n  degree p < ?x2 \\<Longrightarrow>\n  poly.coeff p ?x2 * poly.coeff q (degree p + degree q - ?x2) = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  degree p < ?x2 \\<Longrightarrow>\n  poly.coeff p ?x2 * poly.coeff q (degree p + degree q - ?x2) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc (degree p)..degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "by (intro sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i = Suc (degree p)..degree p + degree q.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = Suc (degree p)..degree p + degree q.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) \\<noteq>\n    (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = Suc (degree p)..degree p + degree q.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) \\<noteq>\n    (0::'a)", "have \"sum ?f {..degree p} = sum ?f {..<degree p} + ?f (degree p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (\\<Sum>i<degree p.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) +\n    lead_coeff p * poly.coeff q (degree p + degree q - degree p)", "by(fold lessThan_Suc_atMost, unfold sum.lessThan_Suc, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree p.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n  (\\<Sum>i<degree p.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) +\n  lead_coeff p * poly.coeff q (degree p + degree q - degree p)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) \\<noteq>\n    (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree p.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n  (\\<Sum>i<degree p.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) +\n  lead_coeff p * poly.coeff q (degree p + degree q - degree p)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) \\<noteq>\n    (0::'a)", "have \"sum ?f {..<degree p} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree p.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree p.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree p.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree p.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "assume \"x < degree p\""], ["proof (state)\nthis:\n  x < degree p\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree p.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "then"], ["proof (chain)\npicking this:\n  x < degree p", "have \"coeff q (?r - x) = 0\""], ["proof (prove)\nusing this:\n  x < degree p\n\ngoal (1 subgoal):\n 1. poly.coeff q (degree p + degree q - x) = (0::'a)", "by (intro coeff_eq_0, auto)"], ["proof (state)\nthis:\n  poly.coeff q (degree p + degree q - x) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree p.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "then"], ["proof (chain)\npicking this:\n  poly.coeff q (degree p + degree q - x) = (0::'a)", "have \"?f x = 0\""], ["proof (prove)\nusing this:\n  poly.coeff q (degree p + degree q - x) = (0::'a)\n\ngoal (1 subgoal):\n 1. poly.coeff p x * poly.coeff q (degree p + degree q - x) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  poly.coeff p x * poly.coeff q (degree p + degree q - x) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree p.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "}"], ["proof (state)\nthis:\n  ?x2 < degree p \\<Longrightarrow>\n  poly.coeff p ?x2 * poly.coeff q (degree p + degree q - ?x2) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree p.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "then"], ["proof (chain)\npicking this:\n  ?x2 < degree p \\<Longrightarrow>\n  poly.coeff p ?x2 * poly.coeff q (degree p + degree q - ?x2) = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x2 < degree p \\<Longrightarrow>\n  poly.coeff p ?x2 * poly.coeff q (degree p + degree q - ?x2) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree p.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n    (0::'a)", "by (intro sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree p.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i<degree p.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) \\<noteq>\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<le>degree p + degree q.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n  (0::'a) + lead_coeff p * poly.coeff q (degree p + degree q - degree p) +\n  (0::'a)", "show \"(\\<Sum>i\\<le>?r. ?f i) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>degree p + degree q.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n  (0::'a) + lead_coeff p * poly.coeff q (degree p + degree q - degree p) +\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) \\<noteq>\n    (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>degree p + degree q.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) =\n  (0::'a) + lead_coeff p * poly.coeff q (degree p + degree q - degree p) +\n  (0::'a)\n  lead_coeff p * lead_coeff q \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p + degree q.\n        poly.coeff p i * poly.coeff q (degree p + degree q - i)) \\<noteq>\n    (0::'a)", "by (auto simp:)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree p + degree q.\n      poly.coeff p i * poly.coeff q (degree p + degree q - i)) \\<noteq>\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_mult_eq_left_unit:\n  fixes p q :: \"'a :: comm_semiring_1 poly\"\n  assumes unit: \"lead_coeff p dvd 1\" and q0: \"q \\<noteq> 0\"\n  shows \"degree (p * q) = degree p + degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (p * q) = degree p + degree q", "proof(intro degree_mult_eq2 notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. lead_coeff p * lead_coeff q = (0::'a) \\<Longrightarrow> False", "from unit"], ["proof (chain)\npicking this:\n  lead_coeff p dvd (1::'a)", "obtain c where \"lead_coeff p * c = 1\""], ["proof (prove)\nusing this:\n  lead_coeff p dvd (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        lead_coeff p * c = (1::'a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (elim dvdE,auto)"], ["proof (state)\nthis:\n  lead_coeff p * c = (1::'a)\n\ngoal (1 subgoal):\n 1. lead_coeff p * lead_coeff q = (0::'a) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  lead_coeff p * c = (1::'a)", "have \"c * lead_coeff p = 1\""], ["proof (prove)\nusing this:\n  lead_coeff p * c = (1::'a)\n\ngoal (1 subgoal):\n 1. c * lead_coeff p = (1::'a)", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  c * lead_coeff p = (1::'a)\n\ngoal (1 subgoal):\n 1. lead_coeff p * lead_coeff q = (0::'a) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  c * lead_coeff p = (1::'a)\n\ngoal (1 subgoal):\n 1. lead_coeff p * lead_coeff q = (0::'a) \\<Longrightarrow> False", "assume \"lead_coeff p * lead_coeff q = 0\""], ["proof (state)\nthis:\n  lead_coeff p * lead_coeff q = (0::'a)\n\ngoal (1 subgoal):\n 1. lead_coeff p * lead_coeff q = (0::'a) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  lead_coeff p * lead_coeff q = (0::'a)", "have \"c * lead_coeff p * lead_coeff q = 0\""], ["proof (prove)\nusing this:\n  lead_coeff p * lead_coeff q = (0::'a)\n\ngoal (1 subgoal):\n 1. c * lead_coeff p * lead_coeff q = (0::'a)", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  c * lead_coeff p * lead_coeff q = (0::'a)\n\ngoal (1 subgoal):\n 1. lead_coeff p * lead_coeff q = (0::'a) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  c * lead_coeff p = (1::'a)\n  c * lead_coeff p * lead_coeff q = (0::'a)", "have \"lead_coeff q = 0\""], ["proof (prove)\nusing this:\n  c * lead_coeff p = (1::'a)\n  c * lead_coeff p * lead_coeff q = (0::'a)\n\ngoal (1 subgoal):\n 1. lead_coeff q = (0::'a)", "by auto"], ["proof (state)\nthis:\n  lead_coeff q = (0::'a)\n\ngoal (1 subgoal):\n 1. lead_coeff p * lead_coeff q = (0::'a) \\<Longrightarrow> False", "with q0"], ["proof (chain)\npicking this:\n  q \\<noteq> 0\n  lead_coeff q = (0::'a)", "show False"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  lead_coeff q = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "context ring_hom begin"], ["", "lemma monic_degree_map_poly_hom: \"monic p \\<Longrightarrow> degree (map_poly hom p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic p \\<Longrightarrow> degree (map_poly hom p) = degree p", "by (auto intro: degree_map_poly)"], ["", "lemma monic_map_poly_hom: \"monic p \\<Longrightarrow> monic (map_poly hom p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic p \\<Longrightarrow> monic (map_poly hom p)", "by (simp add: monic_degree_map_poly_hom)"], ["", "end"], ["", "lemma of_nat_zero:\n  assumes \"CARD('a::nontriv) dvd n\"\n  shows \"(of_nat n :: 'a mod_ring) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n = 0", "apply (transfer fixing: n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. int n mod int CARD('a) = 0", "using assms"], ["proof (prove)\nusing this:\n  CARD('a) dvd n\n\ngoal (1 subgoal):\n 1. int n mod int CARD('a) = 0", "by (presburger)"], ["", "abbreviation rebase :: \"'a :: nontriv mod_ring \\<Rightarrow> 'b :: nontriv mod_ring \"(\"@_\" [100]100)\n  where \"@x \\<equiv> of_int (to_int_mod_ring x)\""], ["", "abbreviation rebase_poly :: \"'a :: nontriv mod_ring poly \\<Rightarrow> 'b :: nontriv mod_ring poly\" (\"#_\" [100]100)\n  where \"#x \\<equiv> of_int_poly (to_int_poly x)\""], ["", "lemma rebase_self [simp]:\n  \"@x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. @x = x", "by (simp add: of_int_of_int_mod_ring)"], ["", "lemma map_poly_rebase [simp]:\n  \"map_poly rebase p = #p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly rebase p = #p", "by (induct p) simp_all"], ["", "lemma rebase_poly_0: \"#0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #0 = 0", "by simp"], ["", "lemma rebase_poly_1: \"#1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #1 = 1", "by simp"], ["", "lemma rebase_poly_pCons[simp]: \"#pCons a p = pCons (@a) (#p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #pCons a p = pCons (@a) (#p)", "by(cases \"a = 0 \\<and> p = 0\", simp, fold map_poly_rebase, subst map_poly_pCons, auto)"], ["", "lemma rebase_poly_self[simp]: \"#p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #p = p", "by (induct p, auto)"], ["", "lemma degree_rebase_poly_le: \"degree (#p) \\<le> degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (#p) \\<le> degree p", "by (fold map_poly_rebase, subst degree_map_poly_le, auto)"], ["", "lemma(in comm_ring_hom) degree_map_poly_unit: assumes \"lead_coeff p dvd 1\"\n  shows \"degree (map_poly hom p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly hom p) = degree p", "using hom_dvd_1[OF assms]"], ["proof (prove)\nusing this:\n  hom (lead_coeff p) dvd (1::'b)\n\ngoal (1 subgoal):\n 1. degree (map_poly hom p) = degree p", "by (auto intro: degree_map_poly)"], ["", "lemma rebase_poly_eq_0_iff:\n  \"(#p :: 'a :: nontriv mod_ring poly) = 0 \\<longleftrightarrow> (\\<forall>i. (@coeff p i :: 'a mod_ring) = 0)\" (is \"?l \\<longleftrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (#p = 0) = (\\<forall>i. @poly.coeff p i = 0)", "proof(intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. #p = 0 \\<Longrightarrow> \\<forall>i. @poly.coeff p i = 0\n 2. \\<forall>i. @poly.coeff p i = 0 \\<Longrightarrow> #p = 0", "assume ?l"], ["proof (state)\nthis:\n  #p = 0\n\ngoal (2 subgoals):\n 1. #p = 0 \\<Longrightarrow> \\<forall>i. @poly.coeff p i = 0\n 2. \\<forall>i. @poly.coeff p i = 0 \\<Longrightarrow> #p = 0", "then"], ["proof (chain)\npicking this:\n  #p = 0", "have \"coeff (#p :: 'a mod_ring poly) i = 0\" for i"], ["proof (prove)\nusing this:\n  #p = 0\n\ngoal (1 subgoal):\n 1. poly.coeff (#p) i = 0", "by auto"], ["proof (state)\nthis:\n  poly.coeff (#p) ?i = 0\n\ngoal (2 subgoals):\n 1. #p = 0 \\<Longrightarrow> \\<forall>i. @poly.coeff p i = 0\n 2. \\<forall>i. @poly.coeff p i = 0 \\<Longrightarrow> #p = 0", "then"], ["proof (chain)\npicking this:\n  poly.coeff (#p) ?i = 0", "show ?r"], ["proof (prove)\nusing this:\n  poly.coeff (#p) ?i = 0\n\ngoal (1 subgoal):\n 1. \\<forall>i. @poly.coeff p i = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>i. @poly.coeff p i = 0\n\ngoal (1 subgoal):\n 1. \\<forall>i. @poly.coeff p i = 0 \\<Longrightarrow> #p = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i. @poly.coeff p i = 0 \\<Longrightarrow> #p = 0", "assume ?r"], ["proof (state)\nthis:\n  \\<forall>i. @poly.coeff p i = 0\n\ngoal (1 subgoal):\n 1. \\<forall>i. @poly.coeff p i = 0 \\<Longrightarrow> #p = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>i. @poly.coeff p i = 0", "have \"coeff (#p :: 'a mod_ring poly) i = 0\" for i"], ["proof (prove)\nusing this:\n  \\<forall>i. @poly.coeff p i = 0\n\ngoal (1 subgoal):\n 1. poly.coeff (#p) i = 0", "by auto"], ["proof (state)\nthis:\n  poly.coeff (#p) ?i = 0\n\ngoal (1 subgoal):\n 1. \\<forall>i. @poly.coeff p i = 0 \\<Longrightarrow> #p = 0", "then"], ["proof (chain)\npicking this:\n  poly.coeff (#p) ?i = 0", "show ?l"], ["proof (prove)\nusing this:\n  poly.coeff (#p) ?i = 0\n\ngoal (1 subgoal):\n 1. #p = 0", "by (intro poly_eqI, auto)"], ["proof (state)\nthis:\n  #p = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_mod_le:\n  assumes ab: \"(a::int) \\<le> b\" and a0: \"0 < a\" and c0: \"c \\<ge> 0\" shows \"(c mod a) mod b = c mod a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c mod a mod b = c mod a", "by (meson Divides.pos_mod_bound Divides.pos_mod_sign a0 ab less_le_trans mod_pos_pos_trivial)"], ["", "locale rebase_ge =\n  fixes ty1 :: \"'a :: nontriv itself\" and ty2 :: \"'b :: nontriv itself\"\n  assumes card: \"CARD('a) \\<le> CARD('b)\"\nbegin"], ["", "lemma ab: \"int CARD('a) \\<le> CARD('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int CARD('a) \\<le> int CARD('b)", "using card"], ["proof (prove)\nusing this:\n  CARD('a) \\<le> CARD('b)\n\ngoal (1 subgoal):\n 1. int CARD('a) \\<le> int CARD('b)", "by auto"], ["", "lemma rebase_eq_0[simp]:\n  shows \"(@(x :: 'a mod_ring) :: 'b mod_ring) = 0 \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (@x = 0) = (x = 0)", "using card"], ["proof (prove)\nusing this:\n  CARD('a) \\<le> CARD('b)\n\ngoal (1 subgoal):\n 1. (@x = 0) = (x = 0)", "by (transfer, auto)"], ["", "lemma degree_rebase_poly_eq[simp]:\n  shows \"degree (#(p :: 'a mod_ring poly) :: 'b mod_ring poly) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (#p) = degree p", "by (subst degree_map_poly; simp)"], ["", "lemma lead_coeff_rebase_poly[simp]:\n  \"lead_coeff (#(p::'a mod_ring poly) :: 'b mod_ring poly) = @lead_coeff p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (#p) = @lead_coeff p", "by simp"], ["", "lemma to_int_mod_ring_rebase: \"to_int_mod_ring(@(x :: 'a mod_ring)::'b mod_ring) = to_int_mod_ring x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring (@x) = to_int_mod_ring x", "using card"], ["proof (prove)\nusing this:\n  CARD('a) \\<le> CARD('b)\n\ngoal (1 subgoal):\n 1. to_int_mod_ring (@x) = to_int_mod_ring x", "by (transfer, auto)"], ["", "lemma rebase_id[simp]: \"@(@(x::'a mod_ring) :: 'b mod_ring) = @x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. @@x = @x", "using card"], ["proof (prove)\nusing this:\n  CARD('a) \\<le> CARD('b)\n\ngoal (1 subgoal):\n 1. @@x = @x", "by (transfer, auto)"], ["", "lemma rebase_poly_id[simp]: \"#(#(p::'a mod_ring poly) :: 'b mod_ring poly) = #p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ##p = #p", "by (induct p, auto)"], ["", "end"], ["", "locale rebase_dvd =\n  fixes ty1 :: \"'a :: nontriv itself\" and ty2 :: \"'b :: nontriv itself\"\n  assumes dvd: \"CARD('b) dvd CARD('a)\"\nbegin"], ["", "lemma ab: \"CARD('a) \\<ge> CARD('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('b) \\<le> CARD('a)", "by (rule dvd_imp_le[OF dvd], auto)"], ["", "lemma rebase_id[simp]: \"@(@(x::'b mod_ring) :: 'a mod_ring) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. @@x = x", "using ab"], ["proof (prove)\nusing this:\n  CARD('b) \\<le> CARD('a)\n\ngoal (1 subgoal):\n 1. @@x = x", "by (transfer, auto)"], ["", "lemma rebase_poly_id[simp]: \"#(#(p::'b mod_ring poly) :: 'a mod_ring poly) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ##p = p", "by (induct p, auto)"], ["", "lemma rebase_of_nat[simp]: \"(@(of_nat n :: 'a mod_ring) :: 'b mod_ring) = of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. @of_nat n = of_nat n", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       int n mod int CARD('a) mod int CARD('b) = int n mod int CARD('b)", "apply (rule mod_mod_cancel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. int CARD('b) dvd int CARD('a)", "using dvd"], ["proof (prove)\nusing this:\n  CARD('b) dvd CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>n. int CARD('b) dvd int CARD('a)", "by presburger"], ["", "lemma mod_1_lift_nat:\n  assumes \"(of_int (int x) :: 'a mod_ring) = 1\"\n  shows \"(of_int (int x) :: 'b mod_ring) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (int x) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_int (int x) = 1", "from assms"], ["proof (chain)\npicking this:\n  of_int (int x) = 1", "have \"int x mod CARD('a) = 1\""], ["proof (prove)\nusing this:\n  of_int (int x) = 1\n\ngoal (1 subgoal):\n 1. int x mod int CARD('a) = 1", "by transfer"], ["proof (state)\nthis:\n  int x mod int CARD('a) = 1\n\ngoal (1 subgoal):\n 1. of_int (int x) = 1", "then"], ["proof (chain)\npicking this:\n  int x mod int CARD('a) = 1", "have \"x mod CARD('a) = 1\""], ["proof (prove)\nusing this:\n  int x mod int CARD('a) = 1\n\ngoal (1 subgoal):\n 1. x mod CARD('a) = 1", "by (simp add: of_nat_mod [symmetric])"], ["proof (state)\nthis:\n  x mod CARD('a) = 1\n\ngoal (1 subgoal):\n 1. of_int (int x) = 1", "then"], ["proof (chain)\npicking this:\n  x mod CARD('a) = 1", "have \"x mod CARD('b) = 1\""], ["proof (prove)\nusing this:\n  x mod CARD('a) = 1\n\ngoal (1 subgoal):\n 1. x mod CARD('b) = 1", "by (metis dvd mod_mod_cancel one_mod_card)"], ["proof (state)\nthis:\n  x mod CARD('b) = 1\n\ngoal (1 subgoal):\n 1. of_int (int x) = 1", "then"], ["proof (chain)\npicking this:\n  x mod CARD('b) = 1", "have \"int x mod CARD('b) = 1\""], ["proof (prove)\nusing this:\n  x mod CARD('b) = 1\n\ngoal (1 subgoal):\n 1. int x mod int CARD('b) = 1", "by (simp add: of_nat_mod [symmetric])"], ["proof (state)\nthis:\n  int x mod int CARD('b) = 1\n\ngoal (1 subgoal):\n 1. of_int (int x) = 1", "then"], ["proof (chain)\npicking this:\n  int x mod int CARD('b) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  int x mod int CARD('b) = 1\n\ngoal (1 subgoal):\n 1. of_int (int x) = 1", "by transfer"], ["proof (state)\nthis:\n  of_int (int x) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale comm_ring_hom \"rebase :: 'a mod_ring \\<Rightarrow> 'b mod_ring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_ring_hom rebase", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. @0 = 0\n 2. \\<And>x y. @(x + y) = @x + @y\n 3. @1 = 1\n 4. \\<And>x y. @(x * y) = @x * @y", "fix x y :: \"'a mod_ring\""], ["proof (state)\ngoal (4 subgoals):\n 1. @0 = 0\n 2. \\<And>x y. @(x + y) = @x + @y\n 3. @1 = 1\n 4. \\<And>x y. @(x * y) = @x * @y", "show hom_add: \"(@(x+y) :: 'b mod_ring) = @x + @y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. @(x + y) = @x + @y", "by transfer (simp add: mod_simps dvd mod_mod_cancel)"], ["proof (state)\nthis:\n  @(x + y) = @x + @y\n\ngoal (3 subgoals):\n 1. @0 = 0\n 2. @1 = 1\n 3. \\<And>x y. @(x * y) = @x * @y", "show \"(@(x*y) :: 'b mod_ring) = @x * @y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. @(x * y) = @x * @y", "by transfer (simp add: mod_simps dvd mod_mod_cancel)"], ["proof (state)\nthis:\n  @(x * y) = @x * @y\n\ngoal (2 subgoals):\n 1. @0 = 0\n 2. @1 = 1", "qed auto"], ["", "lemma of_nat_CARD_eq_0[simp]: \"(of_nat CARD('a) :: 'b mod_ring) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat CARD('a) = 0", "using dvd"], ["proof (prove)\nusing this:\n  CARD('b) dvd CARD('a)\n\ngoal (1 subgoal):\n 1. of_nat CARD('a) = 0", "by (transfer, presburger)"], ["", "interpretation map_poly_hom: map_poly_comm_ring_hom \"rebase :: 'a mod_ring \\<Rightarrow> 'b mod_ring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_ring_hom rebase", ".."], ["", "sublocale poly: comm_ring_hom \"rebase_poly :: 'a mod_ring poly \\<Rightarrow> 'b mod_ring poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_ring_hom rebase_poly", "by (fold map_poly_rebase, unfold_locales)"], ["", "lemma poly_rebase[simp]: \"@poly p x = poly (#(p :: 'a mod_ring poly) :: 'b mod_ring poly) (@(x::'a mod_ring) :: 'b mod_ring)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. @poly p x = poly (#p) (@x)", "by (fold map_poly_rebase poly_map_poly, rule)"], ["", "lemma rebase_poly_smult[simp]: \"(#(smult a p :: 'a mod_ring poly) :: 'b mod_ring poly) = smult (@a) (#p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #Polynomial.smult a p = Polynomial.smult (@a) (#p)", "by(induct p, auto simp: hom_distribs)"], ["", "end"], ["", "locale rebase_mult =\n  fixes ty1 :: \"'a :: nontriv itself\"\n    and ty2 :: \"'b :: nontriv itself\"\n    and ty3 :: \"'d :: nontriv itself\" (* due to some type reason, 'd has to be nontriv. *)\n  assumes d: \"CARD('a) = CARD('b) * CARD('d)\"\nbegin"], ["", "sublocale rebase_dvd ty1 ty2"], ["proof (prove)\ngoal (1 subgoal):\n 1. rebase_dvd TYPE('a) TYPE('b)", "using d"], ["proof (prove)\nusing this:\n  CARD('a) = CARD('b) * CARD('d)\n\ngoal (1 subgoal):\n 1. rebase_dvd TYPE('a) TYPE('b)", "by (unfold_locales, auto)"], ["", "lemma rebase_mult_eq[simp]: \"(of_nat CARD('d) * a :: 'a mod_ring) = of_nat CARD('d) * a' \\<longleftrightarrow> (@a :: 'b mod_ring) = @a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_nat CARD('d) * a = of_nat CARD('d) * a') = (@a = @a')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (of_nat CARD('d) * a = of_nat CARD('d) * a') = (@a = @a')", "from dvd"], ["proof (chain)\npicking this:\n  CARD('b) dvd CARD('a)", "obtain d' where \"CARD('a) = d' * CARD('b)\""], ["proof (prove)\nusing this:\n  CARD('b) dvd CARD('a)\n\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        CARD('a) = d' * CARD('b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim dvdE, auto)"], ["proof (state)\nthis:\n  CARD('a) = d' * CARD('b)\n\ngoal (1 subgoal):\n 1. (of_nat CARD('d) * a = of_nat CARD('d) * a') = (@a = @a')", "then"], ["proof (chain)\npicking this:\n  CARD('a) = d' * CARD('b)", "show ?thesis"], ["proof (prove)\nusing this:\n  CARD('a) = d' * CARD('b)\n\ngoal (1 subgoal):\n 1. (of_nat CARD('d) * a = of_nat CARD('d) * a') = (@a = @a')", "by (transfer, auto simp:d)"], ["proof (state)\nthis:\n  (of_nat CARD('d) * a = of_nat CARD('d) * a') = (@a = @a')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rebase_poly_smult_eq[simp]:\n  fixes a a' :: \"'a mod_ring poly\"\n  defines \"d \\<equiv> of_nat CARD('d) :: 'a mod_ring\"\n  shows \"smult d a = smult d a' \\<longleftrightarrow> (#a :: 'b mod_ring poly) = #a'\" (is \"?l \\<longleftrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Polynomial.smult d a = Polynomial.smult d a') = (#a = #a')", "proof (intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Polynomial.smult d a = Polynomial.smult d a' \\<Longrightarrow> #a = #a'\n 2. #a = #a' \\<Longrightarrow> Polynomial.smult d a = Polynomial.smult d a'", "assume l: ?l"], ["proof (state)\nthis:\n  Polynomial.smult d a = Polynomial.smult d a'\n\ngoal (2 subgoals):\n 1. Polynomial.smult d a = Polynomial.smult d a' \\<Longrightarrow> #a = #a'\n 2. #a = #a' \\<Longrightarrow> Polynomial.smult d a = Polynomial.smult d a'", "show \"?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #a = #a'", "proof (intro poly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff (#a) n = poly.coeff (#a') n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff (#a) n = poly.coeff (#a') n", "from l"], ["proof (chain)\npicking this:\n  Polynomial.smult d a = Polynomial.smult d a'", "have \"coeff (smult d a) n = coeff (smult d a') n\""], ["proof (prove)\nusing this:\n  Polynomial.smult d a = Polynomial.smult d a'\n\ngoal (1 subgoal):\n 1. poly.coeff (Polynomial.smult d a) n =\n    poly.coeff (Polynomial.smult d a') n", "by auto"], ["proof (state)\nthis:\n  poly.coeff (Polynomial.smult d a) n = poly.coeff (Polynomial.smult d a') n\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff (#a) n = poly.coeff (#a') n", "then"], ["proof (chain)\npicking this:\n  poly.coeff (Polynomial.smult d a) n = poly.coeff (Polynomial.smult d a') n", "have \"d * coeff a n = d * coeff a' n\""], ["proof (prove)\nusing this:\n  poly.coeff (Polynomial.smult d a) n = poly.coeff (Polynomial.smult d a') n\n\ngoal (1 subgoal):\n 1. d * poly.coeff a n = d * poly.coeff a' n", "by auto"], ["proof (state)\nthis:\n  d * poly.coeff a n = d * poly.coeff a' n\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff (#a) n = poly.coeff (#a') n", "from this[unfolded d_def rebase_mult_eq]"], ["proof (chain)\npicking this:\n  @poly.coeff a n = @poly.coeff a' n", "show \"coeff (#a :: 'b mod_ring poly) n = coeff (#a') n\""], ["proof (prove)\nusing this:\n  @poly.coeff a n = @poly.coeff a' n\n\ngoal (1 subgoal):\n 1. poly.coeff (#a) n = poly.coeff (#a') n", "by auto"], ["proof (state)\nthis:\n  poly.coeff (#a) n = poly.coeff (#a') n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  #a = #a'\n\ngoal (1 subgoal):\n 1. #a = #a' \\<Longrightarrow> Polynomial.smult d a = Polynomial.smult d a'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. #a = #a' \\<Longrightarrow> Polynomial.smult d a = Polynomial.smult d a'", "assume r: ?r"], ["proof (state)\nthis:\n  #a = #a'\n\ngoal (1 subgoal):\n 1. #a = #a' \\<Longrightarrow> Polynomial.smult d a = Polynomial.smult d a'", "show ?l"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult d a = Polynomial.smult d a'", "proof(intro poly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       poly.coeff (Polynomial.smult d a) n =\n       poly.coeff (Polynomial.smult d a') n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       poly.coeff (Polynomial.smult d a) n =\n       poly.coeff (Polynomial.smult d a') n", "from r"], ["proof (chain)\npicking this:\n  #a = #a'", "have \"coeff (#a :: 'b mod_ring poly) n = coeff (#a') n\""], ["proof (prove)\nusing this:\n  #a = #a'\n\ngoal (1 subgoal):\n 1. poly.coeff (#a) n = poly.coeff (#a') n", "by auto"], ["proof (state)\nthis:\n  poly.coeff (#a) n = poly.coeff (#a') n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       poly.coeff (Polynomial.smult d a) n =\n       poly.coeff (Polynomial.smult d a') n", "then"], ["proof (chain)\npicking this:\n  poly.coeff (#a) n = poly.coeff (#a') n", "have \"(@coeff a n :: 'b mod_ring) = @coeff a' n\""], ["proof (prove)\nusing this:\n  poly.coeff (#a) n = poly.coeff (#a') n\n\ngoal (1 subgoal):\n 1. @poly.coeff a n = @poly.coeff a' n", "by auto"], ["proof (state)\nthis:\n  @poly.coeff a n = @poly.coeff a' n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       poly.coeff (Polynomial.smult d a) n =\n       poly.coeff (Polynomial.smult d a') n", "from this[folded d_def rebase_mult_eq]"], ["proof (chain)\npicking this:\n  d * poly.coeff a n = d * poly.coeff a' n", "show \"coeff (smult d a) n = coeff (smult d a') n\""], ["proof (prove)\nusing this:\n  d * poly.coeff a n = d * poly.coeff a' n\n\ngoal (1 subgoal):\n 1. poly.coeff (Polynomial.smult d a) n =\n    poly.coeff (Polynomial.smult d a') n", "by auto"], ["proof (state)\nthis:\n  poly.coeff (Polynomial.smult d a) n = poly.coeff (Polynomial.smult d a') n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Polynomial.smult d a = Polynomial.smult d a'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rebase_eq_0_imp_ex_mult:\n  \"(@(a :: 'a mod_ring) :: 'b mod_ring) = 0 \\<Longrightarrow> (\\<exists>c :: 'd mod_ring. a = of_nat CARD('b) * @c)\" (is \"?l \\<Longrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. @a = 0 \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "proof(cases \"CARD('a) = CARD('b)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>@a = 0; CARD('a) = CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c\n 2. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "case True"], ["proof (state)\nthis:\n  CARD('a) = CARD('b)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>@a = 0; CARD('a) = CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c\n 2. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "then"], ["proof (chain)\npicking this:\n  CARD('a) = CARD('b)", "show \"?l \\<Longrightarrow> ?r\""], ["proof (prove)\nusing this:\n  CARD('a) = CARD('b)\n\ngoal (1 subgoal):\n 1. @a = 0 \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "by (transfer, auto)"], ["proof (state)\nthis:\n  @a = 0 \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "case False"], ["proof (state)\nthis:\n  CARD('a) \\<noteq> CARD('b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "have [simp]: \"int CARD('b) mod int CARD('a) = int CARD('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int CARD('b) mod int CARD('a) = int CARD('b)", "by(rule mod_pos_pos_trivial, insert ab False, auto)"], ["proof (state)\nthis:\n  int CARD('b) mod int CARD('a) = int CARD('b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "{"], ["proof (state)\nthis:\n  int CARD('b) mod int CARD('a) = int CARD('b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "assume a: \"0 \\<le> a\" \"a < int CARD('a)\" and mod: \"a mod int CARD('b) = 0\""], ["proof (state)\nthis:\n  0 \\<le> a\n  a < int CARD('a)\n  a mod int CARD('b) = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "from mod"], ["proof (chain)\npicking this:\n  a mod int CARD('b) = 0", "have \"int CARD('b) dvd a\""], ["proof (prove)\nusing this:\n  a mod int CARD('b) = 0\n\ngoal (1 subgoal):\n 1. int CARD('b) dvd a", "by auto"], ["proof (state)\nthis:\n  int CARD('b) dvd a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "then"], ["proof (chain)\npicking this:\n  int CARD('b) dvd a", "obtain i where *: \"a = int CARD('b) * i\""], ["proof (prove)\nusing this:\n  int CARD('b) dvd a\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        a = int CARD('b) * i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim dvdE, auto)"], ["proof (state)\nthis:\n  a = int CARD('b) * i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "from * a"], ["proof (chain)\npicking this:\n  a = int CARD('b) * i\n  0 \\<le> a\n  a < int CARD('a)", "have \"i < int CARD('d)\""], ["proof (prove)\nusing this:\n  a = int CARD('b) * i\n  0 \\<le> a\n  a < int CARD('a)\n\ngoal (1 subgoal):\n 1. i < int CARD('d)", "by (simp add:d)"], ["proof (state)\nthis:\n  i < int CARD('d)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "moreover"], ["proof (state)\nthis:\n  i < int CARD('d)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "hence \"(i mod int CARD('a)) = i\""], ["proof (prove)\nusing this:\n  i < int CARD('d)\n\ngoal (1 subgoal):\n 1. i mod int CARD('a) = i", "by (metis dual_order.order_iff_strict less_le_trans not_le of_nat_less_iff \"*\" a(1) a(2)\n             mod_pos_pos_trivial mult_less_cancel_right1 nat_neq_iff nontriv of_nat_1)"], ["proof (state)\nthis:\n  i mod int CARD('a) = i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "with * a"], ["proof (chain)\npicking this:\n  a = int CARD('b) * i\n  0 \\<le> a\n  a < int CARD('a)\n  i mod int CARD('a) = i", "have \"a = int CARD('b) * (i mod int CARD('a)) mod int CARD('a)\""], ["proof (prove)\nusing this:\n  a = int CARD('b) * i\n  0 \\<le> a\n  a < int CARD('a)\n  i mod int CARD('a) = i\n\ngoal (1 subgoal):\n 1. a = int CARD('b) * (i mod int CARD('a)) mod int CARD('a)", "by (auto simp:d)"], ["proof (state)\nthis:\n  a = int CARD('b) * (i mod int CARD('a)) mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "moreover"], ["proof (state)\nthis:\n  a = int CARD('b) * (i mod int CARD('a)) mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "from * a"], ["proof (chain)\npicking this:\n  a = int CARD('b) * i\n  0 \\<le> a\n  a < int CARD('a)", "have \"0 \\<le> i\""], ["proof (prove)\nusing this:\n  a = int CARD('b) * i\n  0 \\<le> a\n  a < int CARD('a)\n\ngoal (1 subgoal):\n 1. 0 \\<le> i", "using linordered_semiring_strict_class.mult_pos_neg of_nat_0_less_iff zero_less_card_finite"], ["proof (prove)\nusing this:\n  a = int CARD('b) * i\n  0 \\<le> a\n  a < int CARD('a)\n  \\<lbrakk>(0::?'a) < ?a; ?b < (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?a * ?b < (0::?'a)\n  ((0::?'a) < of_nat ?n) = (0 < ?n)\n  0 < CARD(?'a)\n\ngoal (1 subgoal):\n 1. 0 \\<le> i", "by (simp add: zero_le_mult_iff)"], ["proof (state)\nthis:\n  0 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "ultimately"], ["proof (chain)\npicking this:\n  i < int CARD('d)\n  a = int CARD('b) * (i mod int CARD('a)) mod int CARD('a)\n  0 \\<le> i", "have \"\\<exists>i\\<ge>0. i < int CARD('d) \\<and> a = int CARD('b) * (i mod int CARD('a)) mod int CARD('a)\""], ["proof (prove)\nusing this:\n  i < int CARD('d)\n  a = int CARD('b) * (i mod int CARD('a)) mod int CARD('a)\n  0 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<ge>0.\n       i < int CARD('d) \\<and>\n       a = int CARD('b) * (i mod int CARD('a)) mod int CARD('a)", "by (auto intro: exI[of _ i])"], ["proof (state)\nthis:\n  \\<exists>i\\<ge>0.\n     i < int CARD('d) \\<and>\n     a = int CARD('b) * (i mod int CARD('a)) mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?aa2; ?aa2 < int CARD('a);\n   ?aa2 mod int CARD('b) = 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i\\<ge>0.\n                       i < int CARD('d) \\<and>\n                       ?aa2 =\n                       int CARD('b) * (i mod int CARD('a)) mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>@a = 0; CARD('a) \\<noteq> CARD('b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> ?aa2; ?aa2 < int CARD('a);\n   ?aa2 mod int CARD('b) = 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i\\<ge>0.\n                       i < int CARD('d) \\<and>\n                       ?aa2 =\n                       int CARD('b) * (i mod int CARD('a)) mod int CARD('a)", "show \"?l \\<Longrightarrow> ?r\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?aa2; ?aa2 < int CARD('a);\n   ?aa2 mod int CARD('b) = 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i\\<ge>0.\n                       i < int CARD('d) \\<and>\n                       ?aa2 =\n                       int CARD('b) * (i mod int CARD('a)) mod int CARD('a)\n\ngoal (1 subgoal):\n 1. @a = 0 \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c", "by (transfer, auto simp:d)"], ["proof (state)\nthis:\n  @a = 0 \\<Longrightarrow> \\<exists>c. a = of_nat CARD('b) * @c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rebase_poly_eq_0_imp_ex_smult:\n  \"(#(p :: 'a mod_ring poly) :: 'b mod_ring poly) = 0 \\<Longrightarrow>\n   (\\<exists>p' :: 'd mod_ring poly. (p = 0 \\<longleftrightarrow> p' = 0) \\<and> degree p' \\<le> degree p \\<and> p = smult (of_nat CARD('b)) (#p'))\"\n  (is \"?l \\<Longrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. #p = 0 \\<Longrightarrow>\n    \\<exists>p'.\n       (p = 0) = (p' = 0) \\<and>\n       degree p' \\<le> degree p \\<and>\n       p = Polynomial.smult (of_nat CARD('b)) (#p')", "proof(induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. #0 = 0 \\<Longrightarrow>\n    \\<exists>p'.\n       (0 = 0) = (p' = 0) \\<and>\n       degree p' \\<le> degree 0 \\<and>\n       0 = Polynomial.smult (of_nat CARD('b)) (#p')\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        #p = 0 \\<Longrightarrow>\n        \\<exists>p'.\n           (p = 0) = (p' = 0) \\<and>\n           degree p' \\<le> degree p \\<and>\n           p = Polynomial.smult (of_nat CARD('b)) (#p');\n        #pCons a p = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            (pCons a p = 0) = (p' = 0) \\<and>\n                            degree p' \\<le> degree (pCons a p) \\<and>\n                            pCons a p =\n                            Polynomial.smult (of_nat CARD('b)) (#p')", "case 0"], ["proof (state)\nthis:\n  #0 = 0\n\ngoal (2 subgoals):\n 1. #0 = 0 \\<Longrightarrow>\n    \\<exists>p'.\n       (0 = 0) = (p' = 0) \\<and>\n       degree p' \\<le> degree 0 \\<and>\n       0 = Polynomial.smult (of_nat CARD('b)) (#p')\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        #p = 0 \\<Longrightarrow>\n        \\<exists>p'.\n           (p = 0) = (p' = 0) \\<and>\n           degree p' \\<le> degree p \\<and>\n           p = Polynomial.smult (of_nat CARD('b)) (#p');\n        #pCons a p = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            (pCons a p = 0) = (p' = 0) \\<and>\n                            degree p' \\<le> degree (pCons a p) \\<and>\n                            pCons a p =\n                            Polynomial.smult (of_nat CARD('b)) (#p')", "then"], ["proof (chain)\npicking this:\n  #0 = 0", "show ?case"], ["proof (prove)\nusing this:\n  #0 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       (0 = 0) = (p' = 0) \\<and>\n       degree p' \\<le> degree 0 \\<and>\n       0 = Polynomial.smult (of_nat CARD('b)) (#p')", "by (intro exI[of _ 0],auto)"], ["proof (state)\nthis:\n  \\<exists>p'.\n     (0 = 0) = (p' = 0) \\<and>\n     degree p' \\<le> degree 0 \\<and>\n     0 = Polynomial.smult (of_nat CARD('b)) (#p')\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        #p = 0 \\<Longrightarrow>\n        \\<exists>p'.\n           (p = 0) = (p' = 0) \\<and>\n           degree p' \\<le> degree p \\<and>\n           p = Polynomial.smult (of_nat CARD('b)) (#p');\n        #pCons a p = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            (pCons a p = 0) = (p' = 0) \\<and>\n                            degree p' \\<le> degree (pCons a p) \\<and>\n                            pCons a p =\n                            Polynomial.smult (of_nat CARD('b)) (#p')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        #p = 0 \\<Longrightarrow>\n        \\<exists>p'.\n           (p = 0) = (p' = 0) \\<and>\n           degree p' \\<le> degree p \\<and>\n           p = Polynomial.smult (of_nat CARD('b)) (#p');\n        #pCons a p = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            (pCons a p = 0) = (p' = 0) \\<and>\n                            degree p' \\<le> degree (pCons a p) \\<and>\n                            pCons a p =\n                            Polynomial.smult (of_nat CARD('b)) (#p')", "case IH: (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> 0 \\<or> p \\<noteq> 0\n  #p = 0 \\<Longrightarrow>\n  \\<exists>p'.\n     (p = 0) = (p' = 0) \\<and>\n     degree p' \\<le> degree p \\<and>\n     p = Polynomial.smult (of_nat CARD('b)) (#p')\n  #pCons a p = 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        #p = 0 \\<Longrightarrow>\n        \\<exists>p'.\n           (p = 0) = (p' = 0) \\<and>\n           degree p' \\<le> degree p \\<and>\n           p = Polynomial.smult (of_nat CARD('b)) (#p');\n        #pCons a p = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            (pCons a p = 0) = (p' = 0) \\<and>\n                            degree p' \\<le> degree (pCons a p) \\<and>\n                            pCons a p =\n                            Polynomial.smult (of_nat CARD('b)) (#p')", "from IH(3)"], ["proof (chain)\npicking this:\n  #pCons a p = 0", "have \"(#p :: 'b mod_ring poly) = 0\""], ["proof (prove)\nusing this:\n  #pCons a p = 0\n\ngoal (1 subgoal):\n 1. #p = 0", "by auto"], ["proof (state)\nthis:\n  #p = 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        #p = 0 \\<Longrightarrow>\n        \\<exists>p'.\n           (p = 0) = (p' = 0) \\<and>\n           degree p' \\<le> degree p \\<and>\n           p = Polynomial.smult (of_nat CARD('b)) (#p');\n        #pCons a p = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            (pCons a p = 0) = (p' = 0) \\<and>\n                            degree p' \\<le> degree (pCons a p) \\<and>\n                            pCons a p =\n                            Polynomial.smult (of_nat CARD('b)) (#p')", "from IH(2)[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>p'.\n     (p = 0) = (p' = 0) \\<and>\n     degree p' \\<le> degree p \\<and>\n     p = Polynomial.smult (of_nat CARD('b)) (#p')", "obtain p' :: \"'d mod_ring poly\"\n  where *: \"p = 0 \\<longleftrightarrow> p' = 0\" \"degree p' \\<le> degree p\" \"p = smult (of_nat CARD('b)) (#p')\""], ["proof (prove)\nusing this:\n  \\<exists>p'.\n     (p = 0) = (p' = 0) \\<and>\n     degree p' \\<le> degree p \\<and>\n     p = Polynomial.smult (of_nat CARD('b)) (#p')\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>(p = 0) = (p' = 0); degree p' \\<le> degree p;\n         p = Polynomial.smult (of_nat CARD('b)) (#p')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim exE conjE)"], ["proof (state)\nthis:\n  (p = 0) = (p' = 0)\n  degree p' \\<le> degree p\n  p = Polynomial.smult (of_nat CARD('b)) (#p')\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        #p = 0 \\<Longrightarrow>\n        \\<exists>p'.\n           (p = 0) = (p' = 0) \\<and>\n           degree p' \\<le> degree p \\<and>\n           p = Polynomial.smult (of_nat CARD('b)) (#p');\n        #pCons a p = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            (pCons a p = 0) = (p' = 0) \\<and>\n                            degree p' \\<le> degree (pCons a p) \\<and>\n                            pCons a p =\n                            Polynomial.smult (of_nat CARD('b)) (#p')", "from IH"], ["proof (chain)\npicking this:\n  a \\<noteq> 0 \\<or> p \\<noteq> 0\n  #p = 0 \\<Longrightarrow>\n  \\<exists>p'.\n     (p = 0) = (p' = 0) \\<and>\n     degree p' \\<le> degree p \\<and>\n     p = Polynomial.smult (of_nat CARD('b)) (#p')\n  #pCons a p = 0", "have \"(@a :: 'b mod_ring) = 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> 0 \\<or> p \\<noteq> 0\n  #p = 0 \\<Longrightarrow>\n  \\<exists>p'.\n     (p = 0) = (p' = 0) \\<and>\n     degree p' \\<le> degree p \\<and>\n     p = Polynomial.smult (of_nat CARD('b)) (#p')\n  #pCons a p = 0\n\ngoal (1 subgoal):\n 1. @a = 0", "by auto"], ["proof (state)\nthis:\n  @a = 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        #p = 0 \\<Longrightarrow>\n        \\<exists>p'.\n           (p = 0) = (p' = 0) \\<and>\n           degree p' \\<le> degree p \\<and>\n           p = Polynomial.smult (of_nat CARD('b)) (#p');\n        #pCons a p = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            (pCons a p = 0) = (p' = 0) \\<and>\n                            degree p' \\<le> degree (pCons a p) \\<and>\n                            pCons a p =\n                            Polynomial.smult (of_nat CARD('b)) (#p')", "from rebase_eq_0_imp_ex_mult[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>c. a = of_nat CARD('b) * @c", "obtain a' :: \"'d mod_ring\" where a': \"of_nat CARD('b) * (@a') = a\""], ["proof (prove)\nusing this:\n  \\<exists>c. a = of_nat CARD('b) * @c\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        of_nat CARD('b) * @a' = a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  of_nat CARD('b) * @a' = a\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        #p = 0 \\<Longrightarrow>\n        \\<exists>p'.\n           (p = 0) = (p' = 0) \\<and>\n           degree p' \\<le> degree p \\<and>\n           p = Polynomial.smult (of_nat CARD('b)) (#p');\n        #pCons a p = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            (pCons a p = 0) = (p' = 0) \\<and>\n                            degree p' \\<le> degree (pCons a p) \\<and>\n                            pCons a p =\n                            Polynomial.smult (of_nat CARD('b)) (#p')", "from IH(1)"], ["proof (chain)\npicking this:\n  a \\<noteq> 0 \\<or> p \\<noteq> 0", "have \"pCons a p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> 0 \\<or> p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pCons a p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  pCons a p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        #p = 0 \\<Longrightarrow>\n        \\<exists>p'.\n           (p = 0) = (p' = 0) \\<and>\n           degree p' \\<le> degree p \\<and>\n           p = Polynomial.smult (of_nat CARD('b)) (#p');\n        #pCons a p = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            (pCons a p = 0) = (p' = 0) \\<and>\n                            degree p' \\<le> degree (pCons a p) \\<and>\n                            pCons a p =\n                            Polynomial.smult (of_nat CARD('b)) (#p')", "moreover"], ["proof (state)\nthis:\n  pCons a p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        #p = 0 \\<Longrightarrow>\n        \\<exists>p'.\n           (p = 0) = (p' = 0) \\<and>\n           degree p' \\<le> degree p \\<and>\n           p = Polynomial.smult (of_nat CARD('b)) (#p');\n        #pCons a p = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            (pCons a p = 0) = (p' = 0) \\<and>\n                            degree p' \\<le> degree (pCons a p) \\<and>\n                            pCons a p =\n                            Polynomial.smult (of_nat CARD('b)) (#p')", "from *(1,2)"], ["proof (chain)\npicking this:\n  (p = 0) = (p' = 0)\n  degree p' \\<le> degree p", "have \"degree (pCons a' p') \\<le> degree (pCons a p)\""], ["proof (prove)\nusing this:\n  (p = 0) = (p' = 0)\n  degree p' \\<le> degree p\n\ngoal (1 subgoal):\n 1. degree (pCons a' p') \\<le> degree (pCons a p)", "by auto"], ["proof (state)\nthis:\n  degree (pCons a' p') \\<le> degree (pCons a p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        #p = 0 \\<Longrightarrow>\n        \\<exists>p'.\n           (p = 0) = (p' = 0) \\<and>\n           degree p' \\<le> degree p \\<and>\n           p = Polynomial.smult (of_nat CARD('b)) (#p');\n        #pCons a p = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            (pCons a p = 0) = (p' = 0) \\<and>\n                            degree p' \\<le> degree (pCons a p) \\<and>\n                            pCons a p =\n                            Polynomial.smult (of_nat CARD('b)) (#p')", "moreover"], ["proof (state)\nthis:\n  degree (pCons a' p') \\<le> degree (pCons a p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        #p = 0 \\<Longrightarrow>\n        \\<exists>p'.\n           (p = 0) = (p' = 0) \\<and>\n           degree p' \\<le> degree p \\<and>\n           p = Polynomial.smult (of_nat CARD('b)) (#p');\n        #pCons a p = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            (pCons a p = 0) = (p' = 0) \\<and>\n                            degree p' \\<le> degree (pCons a p) \\<and>\n                            pCons a p =\n                            Polynomial.smult (of_nat CARD('b)) (#p')", "from a' *(3)"], ["proof (chain)\npicking this:\n  of_nat CARD('b) * @a' = a\n  p = Polynomial.smult (of_nat CARD('b)) (#p')", "have \"pCons a p = smult (of_nat CARD('b)) (#pCons a' p')\""], ["proof (prove)\nusing this:\n  of_nat CARD('b) * @a' = a\n  p = Polynomial.smult (of_nat CARD('b)) (#p')\n\ngoal (1 subgoal):\n 1. pCons a p = Polynomial.smult (of_nat CARD('b)) (#pCons a' p')", "by auto"], ["proof (state)\nthis:\n  pCons a p = Polynomial.smult (of_nat CARD('b)) (#pCons a' p')\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        #p = 0 \\<Longrightarrow>\n        \\<exists>p'.\n           (p = 0) = (p' = 0) \\<and>\n           degree p' \\<le> degree p \\<and>\n           p = Polynomial.smult (of_nat CARD('b)) (#p');\n        #pCons a p = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            (pCons a p = 0) = (p' = 0) \\<and>\n                            degree p' \\<le> degree (pCons a p) \\<and>\n                            pCons a p =\n                            Polynomial.smult (of_nat CARD('b)) (#p')", "ultimately"], ["proof (chain)\npicking this:\n  pCons a p \\<noteq> 0\n  degree (pCons a' p') \\<le> degree (pCons a p)\n  pCons a p = Polynomial.smult (of_nat CARD('b)) (#pCons a' p')", "show ?case"], ["proof (prove)\nusing this:\n  pCons a p \\<noteq> 0\n  degree (pCons a' p') \\<le> degree (pCons a p)\n  pCons a p = Polynomial.smult (of_nat CARD('b)) (#pCons a' p')\n\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       (pCons a p = 0) = (p' = 0) \\<and>\n       degree p' \\<le> degree (pCons a p) \\<and>\n       pCons a p = Polynomial.smult (of_nat CARD('b)) (#p')", "by (intro exI[of _ \"pCons a' p'\"], auto)"], ["proof (state)\nthis:\n  \\<exists>p'.\n     (pCons a p = 0) = (p' = 0) \\<and>\n     degree p' \\<le> degree (pCons a p) \\<and>\n     pCons a p = Polynomial.smult (of_nat CARD('b)) (#p')\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma mod_mod_nat[simp]: \"a mod b mod (b * c :: nat) = a mod b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a mod b mod (b * c) = a mod b", "by (simp add: Divides.mod_mult2_eq)"], ["", "locale Knuth_ex_4_6_2_22_base =\n  fixes ty_p :: \"'p :: nontriv itself\"\n    and ty_q :: \"'q :: nontriv itself\"\n    and ty_pq :: \"'pq :: nontriv itself\"\n  assumes pq: \"CARD('pq) = CARD('p) * CARD('q)\"\n    and p_dvd_q: \"CARD('p) dvd CARD('q)\"\nbegin"], ["", "sublocale rebase_q_to_p: rebase_dvd \"TYPE('q)\" \"TYPE('p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rebase_dvd TYPE('q) TYPE('p)", "using p_dvd_q"], ["proof (prove)\nusing this:\n  CARD('p) dvd CARD('q)\n\ngoal (1 subgoal):\n 1. rebase_dvd TYPE('q) TYPE('p)", "by (unfold_locales, auto)"], ["", "sublocale rebase_pq_to_p: rebase_mult \"TYPE('pq)\" \"TYPE('p)\" \"TYPE('q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rebase_mult TYPE('pq) TYPE('p) TYPE('q)", "using pq"], ["proof (prove)\nusing this:\n  CARD('pq) = CARD('p) * CARD('q)\n\ngoal (1 subgoal):\n 1. rebase_mult TYPE('pq) TYPE('p) TYPE('q)", "by (unfold_locales, auto)"], ["", "sublocale rebase_pq_to_q: rebase_mult \"TYPE('pq)\" \"TYPE('q)\" \"TYPE('p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rebase_mult TYPE('pq) TYPE('q) TYPE('p)", "using pq"], ["proof (prove)\nusing this:\n  CARD('pq) = CARD('p) * CARD('q)\n\ngoal (1 subgoal):\n 1. rebase_mult TYPE('pq) TYPE('q) TYPE('p)", "by (unfold_locales, auto)"], ["", "sublocale rebase_p_to_q: rebase_ge \"TYPE('p)\" \"TYPE ('q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rebase_ge TYPE('p) TYPE('q)", "by (unfold_locales, insert p_dvd_q, simp add: dvd_imp_le)"], ["", "sublocale rebase_p_to_pq: rebase_ge \"TYPE('p)\" \"TYPE ('pq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rebase_ge TYPE('p) TYPE('pq)", "by (unfold_locales, simp add: pq)"], ["", "sublocale rebase_q_to_pq: rebase_ge \"TYPE('q)\" \"TYPE ('pq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rebase_ge TYPE('q) TYPE('pq)", "by (unfold_locales, simp add: pq)"], ["", "(* TODO: needs ugly workaround to fix 'p... *)"], ["", "definition \"p \\<equiv> if (ty_p :: 'p itself) = ty_p then CARD('p) else undefined\""], ["", "lemma p[simp]: \"p \\<equiv> CARD('p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<equiv> CARD('p)", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. if ty_p = ty_p then CARD('p) else undefined \\<equiv> CARD('p)", "by auto"], ["", "definition \"q \\<equiv> if (ty_q :: 'q itself) = ty_q then CARD('q) else undefined\""], ["", "lemma q[simp]: \"q = CARD('q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = CARD('q)", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ty_q = ty_q then CARD('q) else undefined) = CARD('q)", "by auto"], ["", "lemma p1: \"int p > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < int p", "using nontriv [where ?'a = 'p] p"], ["proof (prove)\nusing this:\n  1 < CARD('p)\n  p \\<equiv> CARD('p)\n\ngoal (1 subgoal):\n 1. 1 < int p", "by simp"], ["", "lemma q1: \"int q > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < int q", "using nontriv [where ?'a = 'q] q"], ["proof (prove)\nusing this:\n  1 < CARD('q)\n  q = CARD('q)\n\ngoal (1 subgoal):\n 1. 1 < int q", "by simp"], ["", "lemma q0: \"int q > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < int q", "using q1"], ["proof (prove)\nusing this:\n  1 < int q\n\ngoal (1 subgoal):\n 1. 0 < int q", "by auto"], ["", "lemma pq2[simp]: \"CARD('pq) = p * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('pq) = p * q", "using pq"], ["proof (prove)\nusing this:\n  CARD('pq) = CARD('p) * CARD('q)\n\ngoal (1 subgoal):\n 1. CARD('pq) = p * q", "by simp"], ["", "lemma qq_eq_0[simp]: \"(of_nat CARD('q) * of_nat CARD('q) :: 'pq mod_ring) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat CARD('q) * of_nat CARD('q) = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. of_nat CARD('q) * of_nat CARD('q) = 0", "have \"(of_nat (q * q) :: 'pq mod_ring) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (q * q) = 0", "by (rule of_nat_zero, auto simp: p_dvd_q)"], ["proof (state)\nthis:\n  of_nat (q * q) = 0\n\ngoal (1 subgoal):\n 1. of_nat CARD('q) * of_nat CARD('q) = 0", "then"], ["proof (chain)\npicking this:\n  of_nat (q * q) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  of_nat (q * q) = 0\n\ngoal (1 subgoal):\n 1. of_nat CARD('q) * of_nat CARD('q) = 0", "by auto"], ["proof (state)\nthis:\n  of_nat CARD('q) * of_nat CARD('q) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma of_nat_q[simp]: \"of_nat q :: 'q mod_ring \\<equiv> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat q \\<equiv> 0", "by (fold of_nat_card_eq_0, auto)"], ["", "lemma rebase_rebase[simp]: \"(@(@(x::'pq mod_ring) :: 'q mod_ring) :: 'p mod_ring) = @x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. @@x = @x", "using p_dvd_q"], ["proof (prove)\nusing this:\n  CARD('p) dvd CARD('q)\n\ngoal (1 subgoal):\n 1. @@x = @x", "by (transfer) (simp add: mod_mod_cancel)"], ["", "lemma rebase_rebase_poly[simp]: \"(#(#(f::'pq mod_ring poly) :: 'q mod_ring poly) :: 'p mod_ring poly) = #f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ##f = #f", "by (induct f, auto)"], ["", "end"], ["", "definition dupe_monic where\n  \"dupe_monic D H S T U = (case pdivmod_monic (T * U) D of (q,r) \\<Rightarrow> (S * U + H * q, r))\""], ["", "lemma dupe_monic:\n  fixes D :: \"'a :: prime_card mod_ring poly\"\n  assumes 1: \"D*S + H*T = 1\"\n  and mon: \"monic D\"\n  and dupe: \"dupe_monic D H S T U = (A,B)\" \n  shows \"A * D + B * H = U\" \"B = 0 \\<or> degree B < degree D\"\n    \"coprime D H \\<Longrightarrow> A' * D + B' * H = U \\<Longrightarrow> B' = 0 \\<or> degree B' < degree D \\<Longrightarrow> A' = A \\<and> B' = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * D + B * H = U &&&\n    B = 0 \\<or> degree B < degree D &&&\n    (\\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n      B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n     \\<Longrightarrow> A' = A \\<and> B' = B)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D\n 3. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "obtain q r where div: \"pdivmod_monic (T * U) D = (q,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        pdivmod_monic (T * U) D = (q, r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  pdivmod_monic (T * U) D = (q, r)\n\ngoal (3 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D\n 3. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "from dupe[unfolded dupe_monic_def div split]"], ["proof (chain)\npicking this:\n  (S * U + H * q, r) = (A, B)", "have A: \"A = (S * U + H * q)\" and B: \"B = r\""], ["proof (prove)\nusing this:\n  (S * U + H * q, r) = (A, B)\n\ngoal (1 subgoal):\n 1. A = S * U + H * q &&& B = r", "by auto"], ["proof (state)\nthis:\n  A = S * U + H * q\n  B = r\n\ngoal (3 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D\n 3. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "from pdivmod_monic[OF mon div]"], ["proof (chain)\npicking this:\n  T * U = D * q + r\n  r = 0 \\<or> degree r < degree D", "have TU: \"T * U = D * q + r\" and \n    deg: \"r = 0 \\<or> degree r < degree D\""], ["proof (prove)\nusing this:\n  T * U = D * q + r\n  r = 0 \\<or> degree r < degree D\n\ngoal (1 subgoal):\n 1. T * U = D * q + r &&& r = 0 \\<or> degree r < degree D", "by auto"], ["proof (state)\nthis:\n  T * U = D * q + r\n  r = 0 \\<or> degree r < degree D\n\ngoal (3 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D\n 3. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "hence r: \"r = T * U - D * q\""], ["proof (prove)\nusing this:\n  T * U = D * q + r\n  r = 0 \\<or> degree r < degree D\n\ngoal (1 subgoal):\n 1. r = T * U - D * q", "by simp"], ["proof (state)\nthis:\n  r = T * U - D * q\n\ngoal (3 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D\n 3. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "have \"A * D + B * H = (S * U + H * q) * D + (T * U - D * q) * H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * D + B * H = (S * U + H * q) * D + (T * U - D * q) * H", "unfolding A B r"], ["proof (prove)\ngoal (1 subgoal):\n 1. (S * U + H * q) * D + (T * U - D * q) * H =\n    (S * U + H * q) * D + (T * U - D * q) * H", "by simp"], ["proof (state)\nthis:\n  A * D + B * H = (S * U + H * q) * D + (T * U - D * q) * H\n\ngoal (3 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D\n 3. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "also"], ["proof (state)\nthis:\n  A * D + B * H = (S * U + H * q) * D + (T * U - D * q) * H\n\ngoal (3 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D\n 3. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "have \"... = (D * S + H * T) * U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S * U + H * q) * D + (T * U - D * q) * H = (D * S + H * T) * U", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (S * U + H * q) * D + (T * U - D * q) * H = (D * S + H * T) * U\n\ngoal (3 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D\n 3. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "also"], ["proof (state)\nthis:\n  (S * U + H * q) * D + (T * U - D * q) * H = (D * S + H * T) * U\n\ngoal (3 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D\n 3. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "have \"D * S + H * T = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D * S + H * T = 1", "using 1"], ["proof (prove)\nusing this:\n  D * S + H * T = 1\n\ngoal (1 subgoal):\n 1. D * S + H * T = 1", "by simp"], ["proof (state)\nthis:\n  D * S + H * T = 1\n\ngoal (3 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D\n 3. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "finally"], ["proof (chain)\npicking this:\n  A * D + B * H = 1 * U", "show eq: \"A * D + B * H = U\""], ["proof (prove)\nusing this:\n  A * D + B * H = 1 * U\n\ngoal (1 subgoal):\n 1. A * D + B * H = U", "by simp"], ["proof (state)\nthis:\n  A * D + B * H = U\n\ngoal (2 subgoals):\n 1. B = 0 \\<or> degree B < degree D\n 2. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "show degB: \"B = 0 \\<or> degree B < degree D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = 0 \\<or> degree B < degree D", "using deg"], ["proof (prove)\nusing this:\n  r = 0 \\<or> degree r < degree D\n\ngoal (1 subgoal):\n 1. B = 0 \\<or> degree B < degree D", "unfolding B"], ["proof (prove)\nusing this:\n  r = 0 \\<or> degree r < degree D\n\ngoal (1 subgoal):\n 1. r = 0 \\<or> degree r < degree D", "by (cases \"r = 0\", auto)"], ["proof (state)\nthis:\n  B = 0 \\<or> degree B < degree D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "assume another: \"A' * D + B' * H = U\" and degB': \"B' = 0 \\<or> degree B' < degree D\" \n    and cop: \"coprime D H\""], ["proof (state)\nthis:\n  A' * D + B' * H = U\n  B' = 0 \\<or> degree B' < degree D\n  comm_monoid_mult_class.coprime D H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "from degB"], ["proof (chain)\npicking this:\n  B = 0 \\<or> degree B < degree D", "have degB: \"B = 0 \\<or> degree B < degree D\""], ["proof (prove)\nusing this:\n  B = 0 \\<or> degree B < degree D\n\ngoal (1 subgoal):\n 1. B = 0 \\<or> degree B < degree D", "by auto"], ["proof (state)\nthis:\n  B = 0 \\<or> degree B < degree D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "from degB'"], ["proof (chain)\npicking this:\n  B' = 0 \\<or> degree B' < degree D", "have degB': \"B' = 0 \\<or> degree B' < degree D\""], ["proof (prove)\nusing this:\n  B' = 0 \\<or> degree B' < degree D\n\ngoal (1 subgoal):\n 1. B' = 0 \\<or> degree B' < degree D", "by auto"], ["proof (state)\nthis:\n  B' = 0 \\<or> degree B' < degree D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "from mon"], ["proof (chain)\npicking this:\n  monic D", "have D0: \"D \\<noteq> 0\""], ["proof (prove)\nusing this:\n  monic D\n\ngoal (1 subgoal):\n 1. D \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  D \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "from another eq"], ["proof (chain)\npicking this:\n  A' * D + B' * H = U\n  A * D + B * H = U", "have \"A' * D + B' * H = A * D + B * H\""], ["proof (prove)\nusing this:\n  A' * D + B' * H = U\n  A * D + B * H = U\n\ngoal (1 subgoal):\n 1. A' * D + B' * H = A * D + B * H", "by simp"], ["proof (state)\nthis:\n  A' * D + B' * H = A * D + B * H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>comm_monoid_mult_class.coprime D H; A' * D + B' * H = U;\n     B' = 0 \\<or> degree B' < degree D\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "from uniqueness_poly_equality[OF cop degB' degB D0 this]"], ["proof (chain)\npicking this:\n  A' = A\n  B' = B", "show \"A' = A \\<and> B' = B\""], ["proof (prove)\nusing this:\n  A' = A\n  B' = B\n\ngoal (1 subgoal):\n 1. A' = A \\<and> B' = B", "by auto"], ["proof (state)\nthis:\n  A' = A \\<and> B' = B\n\ngoal:\nNo subgoals!", "qed"], ["", "locale Knuth_ex_4_6_2_22_main = Knuth_ex_4_6_2_22_base p_ty q_ty pq_ty\n  for p_ty :: \"'p::nontriv itself\"\n  and q_ty :: \"'q::nontriv itself\"\n  and pq_ty :: \"'pq::nontriv itself\" +\n  fixes a b :: \"'p mod_ring poly\" and u :: \"'pq mod_ring poly\" and v w :: \"'q mod_ring poly\"\n  assumes uvw: \"(#u :: 'q mod_ring poly) = v * w\"\n      and degu: \"degree u = degree v + degree w\" (* not in Knuth's book *)\n      and avbw: \"(a * #v + b * #w :: 'p mod_ring poly) = 1\"\n      and monic_v: \"monic v\" (* stronger than Knuth's *)\n(* not needed!\n      and aw: \"degree a < degree w\" *)\n      and bv: \"degree b < degree v\"\nbegin"], ["", "lemma deg_v: \"degree (#v :: 'p mod_ring poly) = degree v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (#v) = degree v", "using monic_v"], ["proof (prove)\nusing this:\n  monic v\n\ngoal (1 subgoal):\n 1. degree (#v) = degree v", "by (simp add: of_int_hom.monic_degree_map_poly_hom)"], ["", "lemma u0: \"u \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "using degu bv"], ["proof (prove)\nusing this:\n  degree u = degree v + degree w\n  degree b < degree v\n\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "by auto"], ["", "lemma ex_f: \"\\<exists>f :: 'p mod_ring poly. u = #v * #w + smult (of_nat q) (#f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. u = #v * #w + Polynomial.smult (of_nat q) (#f)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. u = #v * #w + Polynomial.smult (of_nat q) (#f)", "from uvw"], ["proof (chain)\npicking this:\n  #u = v * w", "have \"(#(u - #v * #w) :: 'q mod_ring poly) = 0\""], ["proof (prove)\nusing this:\n  #u = v * w\n\ngoal (1 subgoal):\n 1. #(u - #v * #w) = 0", "by (auto simp:hom_distribs)"], ["proof (state)\nthis:\n  #(u - #v * #w) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>f. u = #v * #w + Polynomial.smult (of_nat q) (#f)", "from rebase_pq_to_q.rebase_poly_eq_0_imp_ex_smult[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>p'.\n     (u - #v * #w = 0) = (p' = 0) \\<and>\n     degree p' \\<le> degree (u - #v * #w) \\<and>\n     u - #v * #w = Polynomial.smult (of_nat CARD('q)) (#p')", "obtain f :: \"'p mod_ring poly\" where \"u - #v * #w = smult (of_nat q) (#f)\""], ["proof (prove)\nusing this:\n  \\<exists>p'.\n     (u - #v * #w = 0) = (p' = 0) \\<and>\n     degree p' \\<le> degree (u - #v * #w) \\<and>\n     u - #v * #w = Polynomial.smult (of_nat CARD('q)) (#p')\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        u - #v * #w = Polynomial.smult (of_nat q) (#f) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  u - #v * #w = Polynomial.smult (of_nat q) (#f)\n\ngoal (1 subgoal):\n 1. \\<exists>f. u = #v * #w + Polynomial.smult (of_nat q) (#f)", "then"], ["proof (chain)\npicking this:\n  u - #v * #w = Polynomial.smult (of_nat q) (#f)", "have \"u = #v * #w + smult (of_nat q) (#f)\""], ["proof (prove)\nusing this:\n  u - #v * #w = Polynomial.smult (of_nat q) (#f)\n\ngoal (1 subgoal):\n 1. u = #v * #w + Polynomial.smult (of_nat q) (#f)", "by (metis add_diff_cancel_left' add_diff_eq)"], ["proof (state)\nthis:\n  u = #v * #w + Polynomial.smult (of_nat q) (#f)\n\ngoal (1 subgoal):\n 1. \\<exists>f. u = #v * #w + Polynomial.smult (of_nat q) (#f)", "then"], ["proof (chain)\npicking this:\n  u = #v * #w + Polynomial.smult (of_nat q) (#f)", "show ?thesis"], ["proof (prove)\nusing this:\n  u = #v * #w + Polynomial.smult (of_nat q) (#f)\n\ngoal (1 subgoal):\n 1. \\<exists>f. u = #v * #w + Polynomial.smult (of_nat q) (#f)", "by (intro exI[of _ f], auto)"], ["proof (state)\nthis:\n  \\<exists>f. u = #v * #w + Polynomial.smult (of_nat q) (#f)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"f :: 'p mod_ring poly \\<equiv> SOME f. u = #v * #w + smult (of_nat q) (#f)\""], ["", "lemma u: \"u = #v * #w + smult (of_nat q) (#f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = #v * #w + Polynomial.smult (of_nat q) (#f)", "using ex_f[folded some_eq_ex] f_def"], ["proof (prove)\nusing this:\n  u =\n  #v * #w +\n  Polynomial.smult (of_nat q)\n   (#(SOME f. u = #v * #w + Polynomial.smult (of_nat q) (#f)))\n  f \\<equiv> SOME f. u = #v * #w + Polynomial.smult (of_nat q) (#f)\n\ngoal (1 subgoal):\n 1. u = #v * #w + Polynomial.smult (of_nat q) (#f)", "by auto"], ["", "lemma t_ex: \"\\<exists>t :: 'p mod_ring poly. degree (b * f - t * #v) < degree v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. degree (b * f - t * #v) < degree v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t. degree (b * f - t * #v) < degree v", "define v' where \"v' \\<equiv> #v :: 'p mod_ring poly\""], ["proof (state)\nthis:\n  v' \\<equiv> #v\n\ngoal (1 subgoal):\n 1. \\<exists>t. degree (b * f - t * #v) < degree v", "from monic_v"], ["proof (chain)\npicking this:\n  monic v", "have 1: \"lead_coeff v' = 1\""], ["proof (prove)\nusing this:\n  monic v\n\ngoal (1 subgoal):\n 1. monic v'", "by (simp add: v'_def deg_v)"], ["proof (state)\nthis:\n  monic v'\n\ngoal (1 subgoal):\n 1. \\<exists>t. degree (b * f - t * #v) < degree v", "then"], ["proof (chain)\npicking this:\n  monic v'", "have 4: \"v' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  monic v'\n\ngoal (1 subgoal):\n 1. v' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  v' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>t. degree (b * f - t * #v) < degree v", "obtain t rem :: \"'p mod_ring poly\"\n  where \"pseudo_divmod (b * f) v' = (t,rem)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t rem.\n        pseudo_divmod (b * f) v' = (t, rem) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  pseudo_divmod (b * f) v' = (t, rem)\n\ngoal (1 subgoal):\n 1. \\<exists>t. degree (b * f - t * #v) < degree v", "from pseudo_divmod[OF 4 this, folded, unfolded 1]"], ["proof (chain)\npicking this:\n  Polynomial.smult (1 ^ (Suc (degree (b * f)) - degree v')) (b * f) =\n  v' * t + rem\n  rem = 0 \\<or> degree rem < degree v'", "have \"b * f = v' * t + rem\" and deg: \"rem = 0 \\<or> degree rem < degree v'\""], ["proof (prove)\nusing this:\n  Polynomial.smult (1 ^ (Suc (degree (b * f)) - degree v')) (b * f) =\n  v' * t + rem\n  rem = 0 \\<or> degree rem < degree v'\n\ngoal (1 subgoal):\n 1. b * f = v' * t + rem &&& rem = 0 \\<or> degree rem < degree v'", "by auto"], ["proof (state)\nthis:\n  b * f = v' * t + rem\n  rem = 0 \\<or> degree rem < degree v'\n\ngoal (1 subgoal):\n 1. \\<exists>t. degree (b * f - t * #v) < degree v", "then"], ["proof (chain)\npicking this:\n  b * f = v' * t + rem\n  rem = 0 \\<or> degree rem < degree v'", "have \"rem = b * f - t * v'\""], ["proof (prove)\nusing this:\n  b * f = v' * t + rem\n  rem = 0 \\<or> degree rem < degree v'\n\ngoal (1 subgoal):\n 1. rem = b * f - t * v'", "by(auto simp: ac_simps)"], ["proof (state)\nthis:\n  rem = b * f - t * v'\n\ngoal (1 subgoal):\n 1. \\<exists>t. degree (b * f - t * #v) < degree v", "also"], ["proof (state)\nthis:\n  rem = b * f - t * v'\n\ngoal (1 subgoal):\n 1. \\<exists>t. degree (b * f - t * #v) < degree v", "have \"... = b * f - #(#t :: 'p mod_ring poly) * v'\" (is \"_ = _ - ?t * v'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. b * f - t * v' = b * f - ##t * v'", "by simp"], ["proof (state)\nthis:\n  b * f - t * v' = b * f - ##t * v'\n\ngoal (1 subgoal):\n 1. \\<exists>t. degree (b * f - t * #v) < degree v", "also"], ["proof (state)\nthis:\n  b * f - t * v' = b * f - ##t * v'\n\ngoal (1 subgoal):\n 1. \\<exists>t. degree (b * f - t * #v) < degree v", "have \"... = b * f - ?t * #v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * f - ##t * v' = b * f - ##t * #v", "by (unfold v'_def, rule)"], ["proof (state)\nthis:\n  b * f - ##t * v' = b * f - ##t * #v\n\ngoal (1 subgoal):\n 1. \\<exists>t. degree (b * f - t * #v) < degree v", "finally"], ["proof (chain)\npicking this:\n  rem = b * f - ##t * #v", "have \"degree rem = degree ...\""], ["proof (prove)\nusing this:\n  rem = b * f - ##t * #v\n\ngoal (1 subgoal):\n 1. degree rem = degree (b * f - ##t * #v)", "by auto"], ["proof (state)\nthis:\n  degree rem = degree (b * f - ##t * #v)\n\ngoal (1 subgoal):\n 1. \\<exists>t. degree (b * f - t * #v) < degree v", "with deg bv"], ["proof (chain)\npicking this:\n  rem = 0 \\<or> degree rem < degree v'\n  degree b < degree v\n  degree rem = degree (b * f - ##t * #v)", "have \"degree (b * f - ?t * #v :: 'p mod_ring poly) < degree v\""], ["proof (prove)\nusing this:\n  rem = 0 \\<or> degree rem < degree v'\n  degree b < degree v\n  degree rem = degree (b * f - ##t * #v)\n\ngoal (1 subgoal):\n 1. degree (b * f - ##t * #v) < degree v", "by (auto simp: v'_def deg_v)"], ["proof (state)\nthis:\n  degree (b * f - ##t * #v) < degree v\n\ngoal (1 subgoal):\n 1. \\<exists>t. degree (b * f - t * #v) < degree v", "then"], ["proof (chain)\npicking this:\n  degree (b * f - ##t * #v) < degree v", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (b * f - ##t * #v) < degree v\n\ngoal (1 subgoal):\n 1. \\<exists>t. degree (b * f - t * #v) < degree v", "by (rule exI)"], ["proof (state)\nthis:\n  \\<exists>t. degree (b * f - t * #v) < degree v\n\ngoal:\nNo subgoals!", "qed"], ["", "definition t where \"t \\<equiv> SOME t :: 'p mod_ring poly. degree (b * f - t * #v) < degree v\""], ["", "definition \"v' \\<equiv> b * f - t * #v\""], ["", "definition \"w' \\<equiv> a * f + t * #w\""], ["", "lemma f: \"w' * #v + v' * #w = f\" (is \"?l = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. w' * #v + v' * #w = f", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. w' * #v + v' * #w = f", "have \"?l = f * (a * #v + b * #w :: 'p mod_ring poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w' * #v + v' * #w = f * (a * #v + b * #w)", "by (simp add: v'_def w'_def ring_distribs ac_simps)"], ["proof (state)\nthis:\n  w' * #v + v' * #w = f * (a * #v + b * #w)\n\ngoal (1 subgoal):\n 1. w' * #v + v' * #w = f", "also"], ["proof (state)\nthis:\n  w' * #v + v' * #w = f * (a * #v + b * #w)\n\ngoal (1 subgoal):\n 1. w' * #v + v' * #w = f", "from avbw"], ["proof (chain)\npicking this:\n  a * #v + b * #w = 1", "have \"(#(a * #v + b * #w) :: 'p mod_ring poly) = 1\""], ["proof (prove)\nusing this:\n  a * #v + b * #w = 1\n\ngoal (1 subgoal):\n 1. #(a * #v + b * #w) = 1", "by auto"], ["proof (state)\nthis:\n  #(a * #v + b * #w) = 1\n\ngoal (1 subgoal):\n 1. w' * #v + v' * #w = f", "then"], ["proof (chain)\npicking this:\n  #(a * #v + b * #w) = 1", "have \"(a * #v + b * #w :: 'p mod_ring poly) = 1\""], ["proof (prove)\nusing this:\n  #(a * #v + b * #w) = 1\n\ngoal (1 subgoal):\n 1. a * #v + b * #w = 1", "by auto"], ["proof (state)\nthis:\n  a * #v + b * #w = 1\n\ngoal (1 subgoal):\n 1. w' * #v + v' * #w = f", "finally"], ["proof (chain)\npicking this:\n  w' * #v + v' * #w = f * 1", "show ?thesis"], ["proof (prove)\nusing this:\n  w' * #v + v' * #w = f * 1\n\ngoal (1 subgoal):\n 1. w' * #v + v' * #w = f", "by auto"], ["proof (state)\nthis:\n  w' * #v + v' * #w = f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degv': \"degree v' < degree v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree v' < degree v", "by (unfold v'_def t_def, rule someI_ex, rule t_ex)"], ["", "lemma degqf[simp]: \"degree (smult (of_nat CARD('q)) (#f :: 'pq mod_ring poly)) = degree (#f :: 'pq mod_ring poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Polynomial.smult (of_nat CARD('q)) (#f)) = degree (#f)", "proof (intro degree_smult_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (#f) \\<noteq> 0 \\<Longrightarrow>\n    of_nat CARD('q) * lead_coeff (#f) \\<noteq> 0", "assume \"degree (#f :: 'pq mod_ring poly) \\<noteq> 0\""], ["proof (state)\nthis:\n  degree (#f) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (#f) \\<noteq> 0 \\<Longrightarrow>\n    of_nat CARD('q) * lead_coeff (#f) \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  degree (#f) \\<noteq> 0", "have f0: \"degree f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree (#f) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (#f) \\<noteq> 0 \\<Longrightarrow>\n    of_nat CARD('q) * lead_coeff (#f) \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (#f) \\<noteq> 0 \\<Longrightarrow>\n    of_nat CARD('q) * lead_coeff (#f) \\<noteq> 0", "define l where \"l \\<equiv> lead_coeff f\""], ["proof (state)\nthis:\n  l \\<equiv> lead_coeff f\n\ngoal (1 subgoal):\n 1. degree (#f) \\<noteq> 0 \\<Longrightarrow>\n    of_nat CARD('q) * lead_coeff (#f) \\<noteq> 0", "ultimately"], ["proof (chain)\npicking this:\n  degree f \\<noteq> 0\n  l \\<equiv> lead_coeff f", "have l0: \"l \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree f \\<noteq> 0\n  l \\<equiv> lead_coeff f\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (#f) \\<noteq> 0 \\<Longrightarrow>\n    of_nat CARD('q) * lead_coeff (#f) \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> 0", "show \"of_nat CARD('q) * lead_coeff (#f::'pq mod_ring poly) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_nat CARD('q) * lead_coeff (#f) \\<noteq> 0", "apply (unfold rebase_p_to_pq.lead_coeff_rebase_poly, fold l_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<noteq> 0; l \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> of_nat CARD('q) * @l \\<noteq> 0", "apply (transfer)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>l \\<in> {0..<int CARD('p)}; l \\<noteq> 0;\n        l \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> int CARD('q) mod int CARD('pq) *\n                         (l mod int CARD('pq)) mod\n                         int CARD('pq) \\<noteq>\n                         0", "using q1"], ["proof (prove)\nusing this:\n  1 < int q\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>l \\<in> {0..<int CARD('p)}; l \\<noteq> 0;\n        l \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> int CARD('q) mod int CARD('pq) *\n                         (l mod int CARD('pq)) mod\n                         int CARD('pq) \\<noteq>\n                         0", "by (simp add: pq mod_mod_cancel)"], ["proof (state)\nthis:\n  of_nat CARD('q) * lead_coeff (#f) \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degw': \"degree w' \\<le> degree w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree w' \\<le> degree w", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "let ?f = \"#f :: 'pq mod_ring poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "let ?qf = \"smult (of_nat q) (#f) :: 'pq mod_ring poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "have \"degree (#w::'p mod_ring poly) \\<le> degree w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (#w) \\<le> degree w", "by (rule degree_rebase_poly_le)"], ["proof (state)\nthis:\n  degree (#w) \\<le> degree w\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree (#w) \\<le> degree w\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "assume \"\\<not> degree w' \\<le> degree w\""], ["proof (state)\nthis:\n  \\<not> degree w' \\<le> degree w\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> degree w' \\<le> degree w", "have 1: \"degree w < degree w'\""], ["proof (prove)\nusing this:\n  \\<not> degree w' \\<le> degree w\n\ngoal (1 subgoal):\n 1. degree w < degree w'", "by auto"], ["proof (state)\nthis:\n  degree w < degree w'\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  degree (#w) < degree w'", "have 2: \"degree (#w :: 'p mod_ring poly) < degree w'\""], ["proof (prove)\nusing this:\n  degree (#w) < degree w'\n\ngoal (1 subgoal):\n 1. degree (#w) < degree w'", "by auto"], ["proof (state)\nthis:\n  degree (#w) < degree w'\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  degree (#w) < degree w'", "have w'0: \"w' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree (#w) < degree w'\n\ngoal (1 subgoal):\n 1. w' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  w' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "have 3: \"degree (#v * w') = degree (#v :: 'p mod_ring poly) + degree w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (#v * w') = degree (#v) + degree w'", "using monic_v[unfolded]"], ["proof (prove)\nusing this:\n  monic v\n\ngoal (1 subgoal):\n 1. degree (#v * w') = degree (#v) + degree w'", "by (intro degree_monic_mult[OF _ w'0], auto simp: deg_v)"], ["proof (state)\nthis:\n  degree (#v * w') = degree (#v) + degree w'\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "have \"degree f \\<le> degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f \\<le> degree u", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> degree f \\<le> degree u \\<Longrightarrow> False", "assume \"\\<not>?thesis\""], ["proof (state)\nthis:\n  \\<not> degree f \\<le> degree u\n\ngoal (1 subgoal):\n 1. \\<not> degree f \\<le> degree u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> degree f \\<le> degree u", "have *: \"degree u < degree f\""], ["proof (prove)\nusing this:\n  \\<not> degree f \\<le> degree u\n\ngoal (1 subgoal):\n 1. degree u < degree f", "by auto"], ["proof (state)\nthis:\n  degree u < degree f\n\ngoal (1 subgoal):\n 1. \\<not> degree f \\<le> degree u \\<Longrightarrow> False", "with degu"], ["proof (chain)\npicking this:\n  degree u = degree v + degree w\n  degree u < degree f", "have 1: \"degree v + degree w < degree f\""], ["proof (prove)\nusing this:\n  degree u = degree v + degree w\n  degree u < degree f\n\ngoal (1 subgoal):\n 1. degree v + degree w < degree f", "by auto"], ["proof (state)\nthis:\n  degree v + degree w < degree f\n\ngoal (1 subgoal):\n 1. \\<not> degree f \\<le> degree u \\<Longrightarrow> False", "define lcf where \"lcf \\<equiv> lead_coeff f\""], ["proof (state)\nthis:\n  lcf \\<equiv> lead_coeff f\n\ngoal (1 subgoal):\n 1. \\<not> degree f \\<le> degree u \\<Longrightarrow> False", "with 1"], ["proof (chain)\npicking this:\n  degree v + degree w < degree f\n  lcf \\<equiv> lead_coeff f", "have lcf0: \"lcf \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree v + degree w < degree f\n  lcf \\<equiv> lead_coeff f\n\ngoal (1 subgoal):\n 1. lcf \\<noteq> 0", "by (unfold, auto)"], ["proof (state)\nthis:\n  lcf \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> degree f \\<le> degree u \\<Longrightarrow> False", "have \"degree f = degree ?qf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f = degree (Polynomial.smult (of_nat q) (#f))", "by simp"], ["proof (state)\nthis:\n  degree f = degree (Polynomial.smult (of_nat q) (#f))\n\ngoal (1 subgoal):\n 1. \\<not> degree f \\<le> degree u \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree f = degree (Polynomial.smult (of_nat q) (#f))\n\ngoal (1 subgoal):\n 1. \\<not> degree f \\<le> degree u \\<Longrightarrow> False", "have \"... = degree (#v * #w + ?qf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Polynomial.smult (of_nat q) (#f)) =\n    degree (#v * #w + Polynomial.smult (of_nat q) (#f))", "proof(rule sym, rule degree_add_eq_right)"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (#v * #w) < degree (Polynomial.smult (of_nat q) (#f))", "from 1 degree_mult_le[of \"#v::'pq mod_ring poly\" \"#w\"]"], ["proof (chain)\npicking this:\n  degree v + degree w < degree f\n  degree (#v * #w) \\<le> degree (#v) + degree (#w)", "show \"degree (#v * #w :: 'pq mod_ring poly) < degree ?qf\""], ["proof (prove)\nusing this:\n  degree v + degree w < degree f\n  degree (#v * #w) \\<le> degree (#v) + degree (#w)\n\ngoal (1 subgoal):\n 1. degree (#v * #w) < degree (Polynomial.smult (of_nat q) (#f))", "by simp"], ["proof (state)\nthis:\n  degree (#v * #w) < degree (Polynomial.smult (of_nat q) (#f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (Polynomial.smult (of_nat q) (#f)) =\n  degree (#v * #w + Polynomial.smult (of_nat q) (#f))\n\ngoal (1 subgoal):\n 1. \\<not> degree f \\<le> degree u \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree (Polynomial.smult (of_nat q) (#f)) =\n  degree (#v * #w + Polynomial.smult (of_nat q) (#f))\n\ngoal (1 subgoal):\n 1. \\<not> degree f \\<le> degree u \\<Longrightarrow> False", "have \"... < degree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (#v * #w + Polynomial.smult (of_nat q) (#f)) < degree f", "using * u"], ["proof (prove)\nusing this:\n  degree u < degree f\n  u = #v * #w + Polynomial.smult (of_nat q) (#f)\n\ngoal (1 subgoal):\n 1. degree (#v * #w + Polynomial.smult (of_nat q) (#f)) < degree f", "by auto"], ["proof (state)\nthis:\n  degree (#v * #w + Polynomial.smult (of_nat q) (#f)) < degree f\n\ngoal (1 subgoal):\n 1. \\<not> degree f \\<le> degree u \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  degree f < degree f", "show \"False\""], ["proof (prove)\nusing this:\n  degree f < degree f\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree f \\<le> degree u\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "with degu"], ["proof (chain)\npicking this:\n  degree u = degree v + degree w\n  degree f \\<le> degree u", "have \"degree f \\<le> degree v + degree w\""], ["proof (prove)\nusing this:\n  degree u = degree v + degree w\n  degree f \\<le> degree u\n\ngoal (1 subgoal):\n 1. degree f \\<le> degree v + degree w", "by auto"], ["proof (state)\nthis:\n  degree f \\<le> degree v + degree w\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree f \\<le> degree v + degree w\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "note f[symmetric]"], ["proof (state)\nthis:\n  f = w' * #v + v' * #w\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  degree (w' * #v + v' * #w) \\<le> degree v + degree w", "have \"degree (w' * #v + v' * #w) \\<le> degree v + degree w\""], ["proof (prove)\nusing this:\n  degree (w' * #v + v' * #w) \\<le> degree v + degree w\n\ngoal (1 subgoal):\n 1. degree (w' * #v + v' * #w) \\<le> degree v + degree w", "."], ["proof (state)\nthis:\n  degree (w' * #v + v' * #w) \\<le> degree v + degree w\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  degree (w' * #v + v' * #w) \\<le> degree v + degree w\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "have \"degree (w' * #v + v' * #w) = degree (w' * #v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (w' * #v + v' * #w) = degree (w' * #v)", "proof(rule degree_add_eq_left)"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (v' * #w) < degree (w' * #v)", "have \"degree (v' * #w) \\<le> degree v' + degree (#w :: 'p mod_ring poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (v' * #w) \\<le> degree v' + degree (#w)", "by(rule degree_mult_le)"], ["proof (state)\nthis:\n  degree (v' * #w) \\<le> degree v' + degree (#w)\n\ngoal (1 subgoal):\n 1. degree (v' * #w) < degree (w' * #v)", "also"], ["proof (state)\nthis:\n  degree (v' * #w) \\<le> degree v' + degree (#w)\n\ngoal (1 subgoal):\n 1. degree (v' * #w) < degree (w' * #v)", "have \"... < degree v + degree (#w :: 'p mod_ring poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree v' + degree (#w) < degree v + degree (#w)", "using degv'"], ["proof (prove)\nusing this:\n  degree v' < degree v\n\ngoal (1 subgoal):\n 1. degree v' + degree (#w) < degree v + degree (#w)", "by auto"], ["proof (state)\nthis:\n  degree v' + degree (#w) < degree v + degree (#w)\n\ngoal (1 subgoal):\n 1. degree (v' * #w) < degree (w' * #v)", "also"], ["proof (state)\nthis:\n  degree v' + degree (#w) < degree v + degree (#w)\n\ngoal (1 subgoal):\n 1. degree (v' * #w) < degree (w' * #v)", "have \"... < degree (#v :: 'p mod_ring poly) + degree w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree v + degree (#w) < degree (#v) + degree w'", "using 2"], ["proof (prove)\nusing this:\n  degree (#w) < degree w'\n\ngoal (1 subgoal):\n 1. degree v + degree (#w) < degree (#v) + degree w'", "by (auto simp: deg_v)"], ["proof (state)\nthis:\n  degree v + degree (#w) < degree (#v) + degree w'\n\ngoal (1 subgoal):\n 1. degree (v' * #w) < degree (w' * #v)", "also"], ["proof (state)\nthis:\n  degree v + degree (#w) < degree (#v) + degree w'\n\ngoal (1 subgoal):\n 1. degree (v' * #w) < degree (w' * #v)", "have \"... = degree (#v * w')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (#v) + degree w' = degree (#v * w')", "using 3"], ["proof (prove)\nusing this:\n  degree (#v * w') = degree (#v) + degree w'\n\ngoal (1 subgoal):\n 1. degree (#v) + degree w' = degree (#v * w')", "by auto"], ["proof (state)\nthis:\n  degree (#v) + degree w' = degree (#v * w')\n\ngoal (1 subgoal):\n 1. degree (v' * #w) < degree (w' * #v)", "finally"], ["proof (chain)\npicking this:\n  degree (v' * #w) < degree (#v * w')", "show \"degree (v' * #w) < degree (w' * #v)\""], ["proof (prove)\nusing this:\n  degree (v' * #w) < degree (#v * w')\n\ngoal (1 subgoal):\n 1. degree (v' * #w) < degree (w' * #v)", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  degree (v' * #w) < degree (w' * #v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (w' * #v + v' * #w) = degree (w' * #v)\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  degree (w' * #v + v' * #w) \\<le> degree v + degree w\n  degree (w' * #v + v' * #w) = degree (w' * #v)", "have \"degree (w' * #v) \\<le> degree v + degree w\""], ["proof (prove)\nusing this:\n  degree (w' * #v + v' * #w) \\<le> degree v + degree w\n  degree (w' * #v + v' * #w) = degree (w' * #v)\n\ngoal (1 subgoal):\n 1. degree (w' * #v) \\<le> degree v + degree w", "by auto"], ["proof (state)\nthis:\n  degree (w' * #v) \\<le> degree v + degree w\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  degree (w' * #v) \\<le> degree v + degree w\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "from 3"], ["proof (chain)\npicking this:\n  degree (#v * w') = degree (#v) + degree w'", "have \"degree (w' * #v) = degree w' + degree v\""], ["proof (prove)\nusing this:\n  degree (#v * w') = degree (#v) + degree w'\n\ngoal (1 subgoal):\n 1. degree (w' * #v) = degree w' + degree v", "by (auto simp: ac_simps deg_v)"], ["proof (state)\nthis:\n  degree (w' * #v) = degree w' + degree v\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "with 1"], ["proof (chain)\npicking this:\n  degree w < degree w'\n  degree (w' * #v) = degree w' + degree v", "have \"degree w + degree v < degree (w' * #v)\""], ["proof (prove)\nusing this:\n  degree w < degree w'\n  degree (w' * #v) = degree w' + degree v\n\ngoal (1 subgoal):\n 1. degree w + degree v < degree (w' * #v)", "by auto"], ["proof (state)\nthis:\n  degree w + degree v < degree (w' * #v)\n\ngoal (1 subgoal):\n 1. \\<not> degree w' \\<le> degree w \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  degree (w' * #v) \\<le> degree v + degree w\n  degree w + degree v < degree (w' * #v)", "show False"], ["proof (prove)\nusing this:\n  degree (w' * #v) \\<le> degree v + degree w\n  degree w + degree v < degree (w' * #v)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"qv' \\<equiv> smult (of_nat q) (#v') :: 'pq mod_ring poly\""], ["", "abbreviation \"qw' \\<equiv> smult (of_nat q) (#w') :: 'pq mod_ring poly\""], ["", "abbreviation \"V \\<equiv> #v + qv'\""], ["", "abbreviation \"W \\<equiv> #w + qw'\""], ["", "lemma vV: \"v = #V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = #(#v + Polynomial.smult (of_nat q) (#v'))", "by (auto simp: v'_def hom_distribs)"], ["", "lemma wW: \"w = #W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = #(#w + Polynomial.smult (of_nat q) (#w'))", "by (auto simp: w'_def hom_distribs)"], ["", "lemma uVW: \"u = V * W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u =\n    (#v + Polynomial.smult (of_nat q) (#v')) *\n    (#w + Polynomial.smult (of_nat q) (#w'))", "by (subst u, fold f, simp add: ring_distribs add.left_cancel smult_add_right[symmetric] hom_distribs)"], ["", "lemma degV: \"degree V = degree v\"\n  and lcV: \"lead_coeff V = @lead_coeff v\"\n  and degW: \"degree W = degree w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (#v + Polynomial.smult (of_nat q) (#v')) = degree v &&&\n    lead_coeff (#v + Polynomial.smult (of_nat q) (#v')) = @lead_coeff v &&&\n    degree (#w + Polynomial.smult (of_nat q) (#w')) = degree w", "proof-"], ["proof (state)\ngoal (3 subgoals):\n 1. degree (#v + Polynomial.smult (of_nat q) (#v')) = degree v\n 2. lead_coeff (#v + Polynomial.smult (of_nat q) (#v')) = @lead_coeff v\n 3. degree (#w + Polynomial.smult (of_nat q) (#w')) = degree w", "from p1 q1"], ["proof (chain)\npicking this:\n  1 < int p\n  1 < int q", "have \"int p < int p * int q\""], ["proof (prove)\nusing this:\n  1 < int p\n  1 < int q\n\ngoal (1 subgoal):\n 1. int p < int p * int q", "by auto"], ["proof (state)\nthis:\n  int p < int p * int q\n\ngoal (3 subgoals):\n 1. degree (#v + Polynomial.smult (of_nat q) (#v')) = degree v\n 2. lead_coeff (#v + Polynomial.smult (of_nat q) (#v')) = @lead_coeff v\n 3. degree (#w + Polynomial.smult (of_nat q) (#w')) = degree w", "from less_trans[OF _ this]"], ["proof (chain)\npicking this:\n  ?x < int p \\<Longrightarrow> ?x < int p * int q", "have 1: \"l < int p \\<Longrightarrow> l < int p * int q\" for l"], ["proof (prove)\nusing this:\n  ?x < int p \\<Longrightarrow> ?x < int p * int q\n\ngoal (1 subgoal):\n 1. l < int p \\<Longrightarrow> l < int p * int q", "by auto"], ["proof (state)\nthis:\n  ?l < int p \\<Longrightarrow> ?l < int p * int q\n\ngoal (3 subgoals):\n 1. degree (#v + Polynomial.smult (of_nat q) (#v')) = degree v\n 2. lead_coeff (#v + Polynomial.smult (of_nat q) (#v')) = @lead_coeff v\n 3. degree (#w + Polynomial.smult (of_nat q) (#w')) = degree w", "have \"degree qv' = degree (#v' :: 'pq mod_ring poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Polynomial.smult (of_nat q) (#v')) = degree (#v')", "proof (rule degree_smult_eqI, safe, unfold rebase_p_to_pq.degree_rebase_poly_eq)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < degree v';\n     of_nat q * poly.coeff (#v') (degree v') = 0\\<rbrakk>\n    \\<Longrightarrow> False", "define l where \"l \\<equiv> lead_coeff v'\""], ["proof (state)\nthis:\n  l \\<equiv> lead_coeff v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < degree v';\n     of_nat q * poly.coeff (#v') (degree v') = 0\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"degree v' > 0\""], ["proof (state)\nthis:\n  0 < degree v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < degree v';\n     of_nat q * poly.coeff (#v') (degree v') = 0\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < degree v'", "have \"lead_coeff v' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree v'\n\ngoal (1 subgoal):\n 1. lead_coeff v' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lead_coeff v' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < degree v';\n     of_nat q * poly.coeff (#v') (degree v') = 0\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  lead_coeff v' \\<noteq> 0", "have \"(@l :: 'pq mod_ring) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lead_coeff v' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. @l \\<noteq> 0", "by (simp add: l_def)"], ["proof (state)\nthis:\n  @l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < degree v';\n     of_nat q * poly.coeff (#v') (degree v') = 0\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  @l \\<noteq> 0", "have \"(of_nat q * @l :: 'pq mod_ring) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  @l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_nat q * @l \\<noteq> 0", "apply (transfer fixing:q_ty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>l \\<in> {0..<int CARD('p)};\n        l mod int CARD('pq) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> int q mod int CARD('pq) * (l mod int CARD('pq)) mod\n                         int CARD('pq) \\<noteq>\n                         0", "using p_dvd_q p1 q1 1"], ["proof (prove)\nusing this:\n  CARD('p) dvd CARD('q)\n  1 < int p\n  1 < int q\n  ?l < int p \\<Longrightarrow> ?l < int p * int q\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>l \\<in> {0..<int CARD('p)};\n        l mod int CARD('pq) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> int q mod int CARD('pq) * (l mod int CARD('pq)) mod\n                         int CARD('pq) \\<noteq>\n                         0", "by auto"], ["proof (state)\nthis:\n  of_nat q * @l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < degree v';\n     of_nat q * poly.coeff (#v') (degree v') = 0\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  of_nat q * @l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < degree v';\n     of_nat q * poly.coeff (#v') (degree v') = 0\\<rbrakk>\n    \\<Longrightarrow> False", "assume \" of_nat q * coeff (#v') (degree v') = (0 :: 'pq mod_ring)\""], ["proof (state)\nthis:\n  of_nat q * poly.coeff (#v') (degree v') = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < degree v';\n     of_nat q * poly.coeff (#v') (degree v') = 0\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  of_nat q * @l \\<noteq> 0\n  of_nat q * poly.coeff (#v') (degree v') = 0", "show False"], ["proof (prove)\nusing this:\n  of_nat q * @l \\<noteq> 0\n  of_nat q * poly.coeff (#v') (degree v') = 0\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: l_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (Polynomial.smult (of_nat q) (#v')) = degree (#v')\n\ngoal (3 subgoals):\n 1. degree (#v + Polynomial.smult (of_nat q) (#v')) = degree v\n 2. lead_coeff (#v + Polynomial.smult (of_nat q) (#v')) = @lead_coeff v\n 3. degree (#w + Polynomial.smult (of_nat q) (#w')) = degree w", "also"], ["proof (state)\nthis:\n  degree (Polynomial.smult (of_nat q) (#v')) = degree (#v')\n\ngoal (3 subgoals):\n 1. degree (#v + Polynomial.smult (of_nat q) (#v')) = degree v\n 2. lead_coeff (#v + Polynomial.smult (of_nat q) (#v')) = @lead_coeff v\n 3. degree (#w + Polynomial.smult (of_nat q) (#w')) = degree w", "from degv'"], ["proof (chain)\npicking this:\n  degree v' < degree v", "have \"... < degree (#v::'pq mod_ring poly)\""], ["proof (prove)\nusing this:\n  degree v' < degree v\n\ngoal (1 subgoal):\n 1. degree (#v') < degree (#v)", "by simp"], ["proof (state)\nthis:\n  degree (#v') < degree (#v)\n\ngoal (3 subgoals):\n 1. degree (#v + Polynomial.smult (of_nat q) (#v')) = degree v\n 2. lead_coeff (#v + Polynomial.smult (of_nat q) (#v')) = @lead_coeff v\n 3. degree (#w + Polynomial.smult (of_nat q) (#w')) = degree w", "finally"], ["proof (chain)\npicking this:\n  degree (Polynomial.smult (of_nat q) (#v')) < degree (#v)", "have *: \"degree qv' < degree (#v :: 'pq mod_ring poly)\""], ["proof (prove)\nusing this:\n  degree (Polynomial.smult (of_nat q) (#v')) < degree (#v)\n\ngoal (1 subgoal):\n 1. degree (Polynomial.smult (of_nat q) (#v')) < degree (#v)", "."], ["proof (state)\nthis:\n  degree (Polynomial.smult (of_nat q) (#v')) < degree (#v)\n\ngoal (3 subgoals):\n 1. degree (#v + Polynomial.smult (of_nat q) (#v')) = degree v\n 2. lead_coeff (#v + Polynomial.smult (of_nat q) (#v')) = @lead_coeff v\n 3. degree (#w + Polynomial.smult (of_nat q) (#w')) = degree w", "from degree_add_eq_left[OF *]"], ["proof (chain)\npicking this:\n  degree (#v + Polynomial.smult (of_nat q) (#v')) = degree (#v)", "show **: \"degree V = degree v\""], ["proof (prove)\nusing this:\n  degree (#v + Polynomial.smult (of_nat q) (#v')) = degree (#v)\n\ngoal (1 subgoal):\n 1. degree (#v + Polynomial.smult (of_nat q) (#v')) = degree v", "by (simp add: v'_def)"], ["proof (state)\nthis:\n  degree (#v + Polynomial.smult (of_nat q) (#v')) = degree v\n\ngoal (2 subgoals):\n 1. lead_coeff (#v + Polynomial.smult (of_nat q) (#v')) = @lead_coeff v\n 2. degree (#w + Polynomial.smult (of_nat q) (#w')) = degree w", "from *"], ["proof (chain)\npicking this:\n  degree (Polynomial.smult (of_nat q) (#v')) < degree (#v)", "have \"coeff qv' (degree v) = 0\""], ["proof (prove)\nusing this:\n  degree (Polynomial.smult (of_nat q) (#v')) < degree (#v)\n\ngoal (1 subgoal):\n 1. poly.coeff (Polynomial.smult (of_nat q) (#v')) (degree v) = 0", "by (intro coeff_eq_0, auto)"], ["proof (state)\nthis:\n  poly.coeff (Polynomial.smult (of_nat q) (#v')) (degree v) = 0\n\ngoal (2 subgoals):\n 1. lead_coeff (#v + Polynomial.smult (of_nat q) (#v')) = @lead_coeff v\n 2. degree (#w + Polynomial.smult (of_nat q) (#w')) = degree w", "then"], ["proof (chain)\npicking this:\n  poly.coeff (Polynomial.smult (of_nat q) (#v')) (degree v) = 0", "show \"lead_coeff V = @lead_coeff v\""], ["proof (prove)\nusing this:\n  poly.coeff (Polynomial.smult (of_nat q) (#v')) (degree v) = 0\n\ngoal (1 subgoal):\n 1. lead_coeff (#v + Polynomial.smult (of_nat q) (#v')) = @lead_coeff v", "by (unfold **, auto simp: v'_def)"], ["proof (state)\nthis:\n  lead_coeff (#v + Polynomial.smult (of_nat q) (#v')) = @lead_coeff v\n\ngoal (1 subgoal):\n 1. degree (#w + Polynomial.smult (of_nat q) (#w')) = degree w", "with u0 uVW"], ["proof (chain)\npicking this:\n  u \\<noteq> 0\n  u =\n  (#v + Polynomial.smult (of_nat q) (#v')) *\n  (#w + Polynomial.smult (of_nat q) (#w'))\n  lead_coeff (#v + Polynomial.smult (of_nat q) (#v')) = @lead_coeff v", "have \"degree (V * W) = degree V + degree W\""], ["proof (prove)\nusing this:\n  u \\<noteq> 0\n  u =\n  (#v + Polynomial.smult (of_nat q) (#v')) *\n  (#w + Polynomial.smult (of_nat q) (#w'))\n  lead_coeff (#v + Polynomial.smult (of_nat q) (#v')) = @lead_coeff v\n\ngoal (1 subgoal):\n 1. degree\n     ((#v + Polynomial.smult (of_nat q) (#v')) *\n      (#w + Polynomial.smult (of_nat q) (#w'))) =\n    degree (#v + Polynomial.smult (of_nat q) (#v')) +\n    degree (#w + Polynomial.smult (of_nat q) (#w'))", "by (intro degree_mult_eq_left_unit, auto simp: monic_v)"], ["proof (state)\nthis:\n  degree\n   ((#v + Polynomial.smult (of_nat q) (#v')) *\n    (#w + Polynomial.smult (of_nat q) (#w'))) =\n  degree (#v + Polynomial.smult (of_nat q) (#v')) +\n  degree (#w + Polynomial.smult (of_nat q) (#w'))\n\ngoal (1 subgoal):\n 1. degree (#w + Polynomial.smult (of_nat q) (#w')) = degree w", "from this[folded uVW, unfolded degu **]"], ["proof (chain)\npicking this:\n  degree v + degree w =\n  degree v + degree (#w + Polynomial.smult (of_nat q) (#w'))", "show \"degree W = degree w\""], ["proof (prove)\nusing this:\n  degree v + degree w =\n  degree v + degree (#w + Polynomial.smult (of_nat q) (#w'))\n\ngoal (1 subgoal):\n 1. degree (#w + Polynomial.smult (of_nat q) (#w')) = degree w", "by auto"], ["proof (state)\nthis:\n  degree (#w + Polynomial.smult (of_nat q) (#w')) = degree w\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale Knuth_ex_4_6_2_22_prime = Knuth_ex_4_6_2_22_main ty_p ty_q ty_pq a b u v w\n  for ty_p :: \"'p :: prime_card itself\"\n  and ty_q :: \"'q :: nontriv itself\"\n  and ty_pq :: \"'pq :: nontriv itself\"\n  and a b u v w +\n  assumes coprime: \"coprime (#v :: 'p mod_ring poly) (#w)\" (* not in Knuth *)\n\nbegin"], ["", "lemma coprime_preserves: \"coprime (#V :: 'p mod_ring poly) (#W)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime\n     (#(#v + Polynomial.smult (of_nat q) (#v')))\n     (#(#w + Polynomial.smult (of_nat q) (#w')))", "apply (intro coprimeI,simp add: rebase_q_to_p.of_nat_CARD_eq_0[simplified] hom_distribs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>r dvd #v; r dvd #w\\<rbrakk>\n       \\<Longrightarrow> r \\<noteq> 0 \\<and> degree r = 0", "using coprime"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (#v) (#w)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>r dvd #v; r dvd #w\\<rbrakk>\n       \\<Longrightarrow> r \\<noteq> 0 \\<and> degree r = 0", "by (elim coprimeE, auto)"], ["", "lemma pre_unique:\n  assumes f2: \"w'' * #v + v'' * #w = f\"\n      and degv'': \"degree v'' < degree v\"\n  shows \"v'' = v' \\<and> w'' = w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v'' = v' \\<and> w'' = w'", "proof(intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. v'' = v'\n 2. w'' = w'", "from f f2"], ["proof (chain)\npicking this:\n  w' * #v + v' * #w = f\n  w'' * #v + v'' * #w = f", "have \"w' * #v + v' * #w = w'' * #v + v'' * #w\""], ["proof (prove)\nusing this:\n  w' * #v + v' * #w = f\n  w'' * #v + v'' * #w = f\n\ngoal (1 subgoal):\n 1. w' * #v + v' * #w = w'' * #v + v'' * #w", "by auto"], ["proof (state)\nthis:\n  w' * #v + v' * #w = w'' * #v + v'' * #w\n\ngoal (2 subgoals):\n 1. v'' = v'\n 2. w'' = w'", "also"], ["proof (state)\nthis:\n  w' * #v + v' * #w = w'' * #v + v'' * #w\n\ngoal (2 subgoals):\n 1. v'' = v'\n 2. w'' = w'", "have \"... - w'' * #v = v'' * #w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w'' * #v + v'' * #w - w'' * #v = v'' * #w", "by auto"], ["proof (state)\nthis:\n  w'' * #v + v'' * #w - w'' * #v = v'' * #w\n\ngoal (2 subgoals):\n 1. v'' = v'\n 2. w'' = w'", "also"], ["proof (state)\nthis:\n  w'' * #v + v'' * #w - w'' * #v = v'' * #w\n\ngoal (2 subgoals):\n 1. v'' = v'\n 2. w'' = w'", "have \"... - v' * #w = (v''- v') * #w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v'' * #w - v' * #w = (v'' - v') * #w", "by (auto simp: left_diff_distrib)"], ["proof (state)\nthis:\n  v'' * #w - v' * #w = (v'' - v') * #w\n\ngoal (2 subgoals):\n 1. v'' = v'\n 2. w'' = w'", "finally"], ["proof (chain)\npicking this:\n  w' * #v + v' * #w - w'' * #v - v' * #w = (v'' - v') * #w", "have *: \"(w' - w'') * #v = (v''- v') * #w\""], ["proof (prove)\nusing this:\n  w' * #v + v' * #w - w'' * #v - v' * #w = (v'' - v') * #w\n\ngoal (1 subgoal):\n 1. (w' - w'') * #v = (v'' - v') * #w", "by (auto simp: left_diff_distrib)"], ["proof (state)\nthis:\n  (w' - w'') * #v = (v'' - v') * #w\n\ngoal (2 subgoals):\n 1. v'' = v'\n 2. w'' = w'", "then"], ["proof (chain)\npicking this:\n  (w' - w'') * #v = (v'' - v') * #w", "have \"#v dvd (v'' - v') * #w\""], ["proof (prove)\nusing this:\n  (w' - w'') * #v = (v'' - v') * #w\n\ngoal (1 subgoal):\n 1. #v dvd (v'' - v') * #w", "by (auto intro: dvdI[of _ _ \"w' - w''\"] simp: ac_simps)"], ["proof (state)\nthis:\n  #v dvd (v'' - v') * #w\n\ngoal (2 subgoals):\n 1. v'' = v'\n 2. w'' = w'", "with coprime"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime (#v) (#w)\n  #v dvd (v'' - v') * #w", "have \"#v dvd v'' - v'\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (#v) (#w)\n  #v dvd (v'' - v') * #w\n\ngoal (1 subgoal):\n 1. #v dvd v'' - v'", "by (simp add: coprime_dvd_mult_left_iff)"], ["proof (state)\nthis:\n  #v dvd v'' - v'\n\ngoal (2 subgoals):\n 1. v'' = v'\n 2. w'' = w'", "moreover"], ["proof (state)\nthis:\n  #v dvd v'' - v'\n\ngoal (2 subgoals):\n 1. v'' = v'\n 2. w'' = w'", "have \"degree (v'' - v') < degree v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (v'' - v') < degree v", "by (rule degree_diff_less[OF degv'' degv'])"], ["proof (state)\nthis:\n  degree (v'' - v') < degree v\n\ngoal (2 subgoals):\n 1. v'' = v'\n 2. w'' = w'", "ultimately"], ["proof (chain)\npicking this:\n  #v dvd v'' - v'\n  degree (v'' - v') < degree v", "have \"v'' - v' = 0\""], ["proof (prove)\nusing this:\n  #v dvd v'' - v'\n  degree (v'' - v') < degree v\n\ngoal (1 subgoal):\n 1. v'' - v' = 0", "by (metis deg_v degree_0 gr_implies_not_zero poly_divides_conv0)"], ["proof (state)\nthis:\n  v'' - v' = 0\n\ngoal (2 subgoals):\n 1. v'' = v'\n 2. w'' = w'", "then"], ["proof (chain)\npicking this:\n  v'' - v' = 0", "show \"v'' = v'\""], ["proof (prove)\nusing this:\n  v'' - v' = 0\n\ngoal (1 subgoal):\n 1. v'' = v'", "by auto"], ["proof (state)\nthis:\n  v'' = v'\n\ngoal (1 subgoal):\n 1. w'' = w'", "with *"], ["proof (chain)\npicking this:\n  (w' - w'') * #v = (v'' - v') * #w\n  v'' = v'", "have \"(w' - w'') * #v = 0\""], ["proof (prove)\nusing this:\n  (w' - w'') * #v = (v'' - v') * #w\n  v'' = v'\n\ngoal (1 subgoal):\n 1. (w' - w'') * #v = 0", "by auto"], ["proof (state)\nthis:\n  (w' - w'') * #v = 0\n\ngoal (1 subgoal):\n 1. w'' = w'", "with bv"], ["proof (chain)\npicking this:\n  degree b < degree v\n  (w' - w'') * #v = 0", "have \"w' - w'' = 0\""], ["proof (prove)\nusing this:\n  degree b < degree v\n  (w' - w'') * #v = 0\n\ngoal (1 subgoal):\n 1. w' - w'' = 0", "by (metis deg_v degree_0 gr_implies_not_zero mult_eq_0_iff)"], ["proof (state)\nthis:\n  w' - w'' = 0\n\ngoal (1 subgoal):\n 1. w'' = w'", "then"], ["proof (chain)\npicking this:\n  w' - w'' = 0", "show \"w'' = w'\""], ["proof (prove)\nusing this:\n  w' - w'' = 0\n\ngoal (1 subgoal):\n 1. w'' = w'", "by auto"], ["proof (state)\nthis:\n  w'' = w'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique:\n  assumes vV2: \"v = #V2\" and wW2: \"w = #W2\" and uVW2: \"u = V2 * W2\"\n      and degV2: \"degree V2 = degree v\" and degW2: \"degree W2 = degree w\"\n      and lc: \"lead_coeff V2 = @lead_coeff v\"\n  shows \"V2 = V\" \"W2 = W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v') &&&\n    W2 = #w + Polynomial.smult (of_nat q) (#w')", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "from vV2"], ["proof (chain)\npicking this:\n  v = #V2", "have \"(#(V2 - #v) :: 'q mod_ring poly) = 0\""], ["proof (prove)\nusing this:\n  v = #V2\n\ngoal (1 subgoal):\n 1. #(V2 - #v) = 0", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  #(V2 - #v) = 0\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "from rebase_pq_to_q.rebase_poly_eq_0_imp_ex_smult[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>p'.\n     (V2 - #v = 0) = (p' = 0) \\<and>\n     degree p' \\<le> degree (V2 - #v) \\<and>\n     V2 - #v = Polynomial.smult (of_nat CARD('q)) (#p')", "obtain v'' :: \"'p mod_ring poly\"\n  where deg: \"degree v'' \\<le> degree (V2 - #v)\"\n    and v'': \"V2 - #v = smult (of_nat CARD('q)) (#v'')\""], ["proof (prove)\nusing this:\n  \\<exists>p'.\n     (V2 - #v = 0) = (p' = 0) \\<and>\n     degree p' \\<le> degree (V2 - #v) \\<and>\n     V2 - #v = Polynomial.smult (of_nat CARD('q)) (#p')\n\ngoal (1 subgoal):\n 1. (\\<And>v''.\n        \\<lbrakk>degree v'' \\<le> degree (V2 - #v);\n         V2 - #v = Polynomial.smult (of_nat CARD('q)) (#v'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim exE conjE)"], ["proof (state)\nthis:\n  degree v'' \\<le> degree (V2 - #v)\n  V2 - #v = Polynomial.smult (of_nat CARD('q)) (#v'')\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "then"], ["proof (chain)\npicking this:\n  degree v'' \\<le> degree (V2 - #v)\n  V2 - #v = Polynomial.smult (of_nat CARD('q)) (#v'')", "have V2: \"V2 = #v + ...\""], ["proof (prove)\nusing this:\n  degree v'' \\<le> degree (V2 - #v)\n  V2 - #v = Polynomial.smult (of_nat CARD('q)) (#v'')\n\ngoal (1 subgoal):\n 1. V2 = #v + Polynomial.smult (of_nat CARD('q)) (#v'')", "by (metis add_diff_cancel_left' diff_add_cancel)"], ["proof (state)\nthis:\n  V2 = #v + Polynomial.smult (of_nat CARD('q)) (#v'')\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "from lc[unfolded degV2, unfolded V2]"], ["proof (chain)\npicking this:\n  poly.coeff (#v + Polynomial.smult (of_nat CARD('q)) (#v'')) (degree v) =\n  @lead_coeff v", "have \"of_nat q * (@coeff v'' (degree v) :: 'pq mod_ring) = of_nat q * 0\""], ["proof (prove)\nusing this:\n  poly.coeff (#v + Polynomial.smult (of_nat CARD('q)) (#v'')) (degree v) =\n  @lead_coeff v\n\ngoal (1 subgoal):\n 1. of_nat q * @poly.coeff v'' (degree v) = of_nat q * 0", "by auto"], ["proof (state)\nthis:\n  of_nat q * @poly.coeff v'' (degree v) = of_nat q * 0\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "from this[unfolded q rebase_pq_to_p.rebase_mult_eq]"], ["proof (chain)\npicking this:\n  @@poly.coeff v'' (degree v) = @0", "have \"coeff v'' (degree v) = 0\""], ["proof (prove)\nusing this:\n  @@poly.coeff v'' (degree v) = @0\n\ngoal (1 subgoal):\n 1. poly.coeff v'' (degree v) = 0", "by simp"], ["proof (state)\nthis:\n  poly.coeff v'' (degree v) = 0\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "moreover"], ["proof (state)\nthis:\n  poly.coeff v'' (degree v) = 0\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "have \"degree v'' \\<le>  degree v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree v'' \\<le> degree v", "using deg degV2"], ["proof (prove)\nusing this:\n  degree v'' \\<le> degree (V2 - #v)\n  degree V2 = degree v\n\ngoal (1 subgoal):\n 1. degree v'' \\<le> degree v", "by (metis degree_diff_le le_antisym nat_le_linear rebase_q_to_pq.degree_rebase_poly_eq)"], ["proof (state)\nthis:\n  degree v'' \\<le> degree v\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "ultimately"], ["proof (chain)\npicking this:\n  poly.coeff v'' (degree v) = 0\n  degree v'' \\<le> degree v", "have degv'': \"degree v'' < degree v\""], ["proof (prove)\nusing this:\n  poly.coeff v'' (degree v) = 0\n  degree v'' \\<le> degree v\n\ngoal (1 subgoal):\n 1. degree v'' < degree v", "using bv eq_zero_or_degree_less"], ["proof (prove)\nusing this:\n  poly.coeff v'' (degree v) = 0\n  degree v'' \\<le> degree v\n  degree b < degree v\n  \\<lbrakk>degree ?p \\<le> ?n; poly.coeff ?p ?n = (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?p = 0 \\<or> degree ?p < ?n\n\ngoal (1 subgoal):\n 1. degree v'' < degree v", "by fastforce"], ["proof (state)\nthis:\n  degree v'' < degree v\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "from wW2"], ["proof (chain)\npicking this:\n  w = #W2", "have \"(#(W2 - #w) :: 'q mod_ring poly) = 0\""], ["proof (prove)\nusing this:\n  w = #W2\n\ngoal (1 subgoal):\n 1. #(W2 - #w) = 0", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  #(W2 - #w) = 0\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "from rebase_pq_to_q.rebase_poly_eq_0_imp_ex_smult[OF this] pq"], ["proof (chain)\npicking this:\n  \\<exists>p'.\n     (W2 - #w = 0) = (p' = 0) \\<and>\n     degree p' \\<le> degree (W2 - #w) \\<and>\n     W2 - #w = Polynomial.smult (of_nat CARD('q)) (#p')\n  CARD('pq) = CARD('p) * CARD('q)", "obtain w'' :: \"'p mod_ring poly\" where w'': \"W2 - #w = smult (of_nat q) (#w'')\""], ["proof (prove)\nusing this:\n  \\<exists>p'.\n     (W2 - #w = 0) = (p' = 0) \\<and>\n     degree p' \\<le> degree (W2 - #w) \\<and>\n     W2 - #w = Polynomial.smult (of_nat CARD('q)) (#p')\n  CARD('pq) = CARD('p) * CARD('q)\n\ngoal (1 subgoal):\n 1. (\\<And>w''.\n        W2 - #w = Polynomial.smult (of_nat q) (#w'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  W2 - #w = Polynomial.smult (of_nat q) (#w'')\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "then"], ["proof (chain)\npicking this:\n  W2 - #w = Polynomial.smult (of_nat q) (#w'')", "have W2: \"W2 = #w + ...\""], ["proof (prove)\nusing this:\n  W2 - #w = Polynomial.smult (of_nat q) (#w'')\n\ngoal (1 subgoal):\n 1. W2 = #w + Polynomial.smult (of_nat q) (#w'')", "by (metis add_diff_cancel_left' diff_add_cancel)"], ["proof (state)\nthis:\n  W2 = #w + Polynomial.smult (of_nat q) (#w'')\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "have \"u = #v * #w + smult (of_nat q) (#w'' * #v + #v'' * #w) + smult (of_nat (q * q)) (#v'' * #w'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u =\n    #v * #w + Polynomial.smult (of_nat q) (#w'' * #v + #v'' * #w) +\n    Polynomial.smult (of_nat (q * q)) (#v'' * #w'')", "by(simp add: uVW2 V2 W2 ring_distribs smult_add_right ac_simps)"], ["proof (state)\nthis:\n  u =\n  #v * #w + Polynomial.smult (of_nat q) (#w'' * #v + #v'' * #w) +\n  Polynomial.smult (of_nat (q * q)) (#v'' * #w'')\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "also"], ["proof (state)\nthis:\n  u =\n  #v * #w + Polynomial.smult (of_nat q) (#w'' * #v + #v'' * #w) +\n  Polynomial.smult (of_nat (q * q)) (#v'' * #w'')\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "have \"smult (of_nat (q * q)) (#v'' * #w'' :: 'pq mod_ring poly) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (of_nat (q * q)) (#v'' * #w'') = 0", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult (of_nat (q * q)) (#v'' * #w'') = 0\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "finally"], ["proof (chain)\npicking this:\n  u = #v * #w + Polynomial.smult (of_nat q) (#w'' * #v + #v'' * #w) + 0", "have \"u - #v * #w = smult (of_nat q) (#w'' * #v + #v'' * #w)\""], ["proof (prove)\nusing this:\n  u = #v * #w + Polynomial.smult (of_nat q) (#w'' * #v + #v'' * #w) + 0\n\ngoal (1 subgoal):\n 1. u - #v * #w = Polynomial.smult (of_nat q) (#w'' * #v + #v'' * #w)", "by auto"], ["proof (state)\nthis:\n  u - #v * #w = Polynomial.smult (of_nat q) (#w'' * #v + #v'' * #w)\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "also"], ["proof (state)\nthis:\n  u - #v * #w = Polynomial.smult (of_nat q) (#w'' * #v + #v'' * #w)\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "have \"u - #v * #w = smult (of_nat q) (#f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u - #v * #w = Polynomial.smult (of_nat q) (#f)", "by (subst u, simp)"], ["proof (state)\nthis:\n  u - #v * #w = Polynomial.smult (of_nat q) (#f)\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "finally"], ["proof (chain)\npicking this:\n  Polynomial.smult (of_nat q) (#f) =\n  Polynomial.smult (of_nat q) (#w'' * #v + #v'' * #w)", "have \"w'' * #v + v'' * #w = f\""], ["proof (prove)\nusing this:\n  Polynomial.smult (of_nat q) (#f) =\n  Polynomial.smult (of_nat q) (#w'' * #v + #v'' * #w)\n\ngoal (1 subgoal):\n 1. w'' * #v + v'' * #w = f", "by (simp add: hom_distribs)"], ["proof (state)\nthis:\n  w'' * #v + v'' * #w = f\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "from pre_unique[OF this degv'']"], ["proof (chain)\npicking this:\n  v'' = v' \\<and> w'' = w'", "have pre: \"v'' = v'\" \"w'' = w'\""], ["proof (prove)\nusing this:\n  v'' = v' \\<and> w'' = w'\n\ngoal (1 subgoal):\n 1. v'' = v' &&& w'' = w'", "by auto"], ["proof (state)\nthis:\n  v'' = v'\n  w'' = w'\n\ngoal (2 subgoals):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v')\n 2. W2 = #w + Polynomial.smult (of_nat q) (#w')", "with V2 W2"], ["proof (chain)\npicking this:\n  V2 = #v + Polynomial.smult (of_nat CARD('q)) (#v'')\n  W2 = #w + Polynomial.smult (of_nat q) (#w'')\n  v'' = v'\n  w'' = w'", "show \"V2 = V\" \"W2 = W\""], ["proof (prove)\nusing this:\n  V2 = #v + Polynomial.smult (of_nat CARD('q)) (#v'')\n  W2 = #w + Polynomial.smult (of_nat q) (#w'')\n  v'' = v'\n  w'' = w'\n\ngoal (1 subgoal):\n 1. V2 = #v + Polynomial.smult (of_nat q) (#v') &&&\n    W2 = #w + Polynomial.smult (of_nat q) (#w')", "by auto"], ["proof (state)\nthis:\n  V2 = #v + Polynomial.smult (of_nat q) (#v')\n  W2 = #w + Polynomial.smult (of_nat q) (#w')\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition\n  \"hensel_1 (ty ::'p :: prime_card itself)\n    (u :: 'pq :: nontriv mod_ring poly) (v :: 'q :: nontriv mod_ring poly) (w :: 'q mod_ring poly) \\<equiv>\n   if v = 1 then (1,u) else\n   let (s, t) = bezout_coefficients (#v :: 'p mod_ring poly) (#w) in\n   let (a, b) = dupe_monic (#v::'p mod_ring poly) (#w) s t 1 in\n   (Knuth_ex_4_6_2_22_main.V TYPE('q) b u v w, Knuth_ex_4_6_2_22_main.W TYPE('q) a b u v w)\""], ["", "lemma hensel_1:\n  fixes u :: \"'pq :: nontriv mod_ring poly\"\n    and v w :: \"'q :: nontriv mod_ring poly\"\n  assumes \"CARD('pq) = CARD('p :: prime_card) * CARD('q)\"\n      and \"CARD('p) dvd CARD('q)\"\n      and uvw: \"#u = v * w\"\n      and degu: \"degree u = degree v + degree w\"\n      and monic: \"monic v\"\n      and coprime: \"coprime (#v :: 'p mod_ring poly) (#w)\"\n      and out: \"hensel_1 TYPE('p) u v w = (V',W')\"\n  shows \"u = V' * W' \\<and> v = #V' \\<and> w = #W' \\<and> degree V' = degree v \\<and> degree W' = degree w \\<and>\n         monic V' \\<and> coprime (#V' :: 'p mod_ring poly) (#W')\" (is ?main)\n    and \"(\\<forall>V'' W''. u = V'' * W'' \\<longrightarrow> v = #V'' \\<longrightarrow> w = #W'' \\<longrightarrow>\n          degree V'' = degree v \\<longrightarrow> degree W'' = degree w \\<longrightarrow> lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n          V'' = V' \\<and> W'' = W')\" (is \"?unique\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. u = V' * W' \\<and>\n    v = #V' \\<and>\n    w = #W' \\<and>\n    degree V' = degree v \\<and>\n    degree W' = degree w \\<and>\n    monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W') &&&\n    \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. u = V' * W' \\<and>\n    v = #V' \\<and>\n    w = #W' \\<and>\n    degree V' = degree v \\<and>\n    degree W' = degree w \\<and>\n    monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')\n 2. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "from monic"], ["proof (chain)\npicking this:\n  monic v", "have degv: \"degree (#v :: 'p mod_ring poly) = degree v\""], ["proof (prove)\nusing this:\n  monic v\n\ngoal (1 subgoal):\n 1. degree (#v) = degree v", "by (simp add: of_int_hom.monic_degree_map_poly_hom)"], ["proof (state)\nthis:\n  degree (#v) = degree v\n\ngoal (2 subgoals):\n 1. u = V' * W' \\<and>\n    v = #V' \\<and>\n    w = #W' \\<and>\n    degree V' = degree v \\<and>\n    degree W' = degree w \\<and>\n    monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')\n 2. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "from monic"], ["proof (chain)\npicking this:\n  monic v", "have monic2: \"monic (#v :: 'p mod_ring poly)\""], ["proof (prove)\nusing this:\n  monic v\n\ngoal (1 subgoal):\n 1. monic (#v)", "by (auto simp: degv)"], ["proof (state)\nthis:\n  monic (#v)\n\ngoal (2 subgoals):\n 1. u = V' * W' \\<and>\n    v = #V' \\<and>\n    w = #W' \\<and>\n    degree V' = degree v \\<and>\n    degree W' = degree w \\<and>\n    monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')\n 2. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "obtain s t where bezout: \"bezout_coefficients (#v :: 'p mod_ring poly) (#w) = (s, t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s t.\n        bezout_coefficients (#v) (#w) = (s, t) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: prod_eq_iff)"], ["proof (state)\nthis:\n  bezout_coefficients (#v) (#w) = (s, t)\n\ngoal (2 subgoals):\n 1. u = V' * W' \\<and>\n    v = #V' \\<and>\n    w = #W' \\<and>\n    degree V' = degree v \\<and>\n    degree W' = degree w \\<and>\n    monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')\n 2. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "then"], ["proof (chain)\npicking this:\n  bezout_coefficients (#v) (#w) = (s, t)", "have \"s * #v + t * #w = gcd (#v :: 'p mod_ring poly) (#w)\""], ["proof (prove)\nusing this:\n  bezout_coefficients (#v) (#w) = (s, t)\n\ngoal (1 subgoal):\n 1. s * #v + t * #w = gcd (#v) (#w)", "by (rule bezout_coefficients)"], ["proof (state)\nthis:\n  s * #v + t * #w = gcd (#v) (#w)\n\ngoal (2 subgoals):\n 1. u = V' * W' \\<and>\n    v = #V' \\<and>\n    w = #W' \\<and>\n    degree V' = degree v \\<and>\n    degree W' = degree w \\<and>\n    monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')\n 2. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "with coprime"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime (#v) (#w)\n  s * #v + t * #w = gcd (#v) (#w)", "have vswt: \"#v * s + #w * t = 1\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (#v) (#w)\n  s * #v + t * #w = gcd (#v) (#w)\n\ngoal (1 subgoal):\n 1. #v * s + #w * t = 1", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  #v * s + #w * t = 1\n\ngoal (2 subgoals):\n 1. u = V' * W' \\<and>\n    v = #V' \\<and>\n    w = #W' \\<and>\n    degree V' = degree v \\<and>\n    degree W' = degree w \\<and>\n    monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')\n 2. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "obtain a b where dupe: \"dupe_monic (#v) (#w) s t 1 = (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        Hensel_Lifting_Type_Based.dupe_monic (#v) (#w) s t 1 =\n        (a, b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  Hensel_Lifting_Type_Based.dupe_monic (#v) (#w) s t 1 = (a, b)\n\ngoal (2 subgoals):\n 1. u = V' * W' \\<and>\n    v = #V' \\<and>\n    w = #W' \\<and>\n    degree V' = degree v \\<and>\n    degree W' = degree w \\<and>\n    monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')\n 2. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "from dupe_monic(1,2)[OF vswt monic2, where U=1, unfolded this]"], ["proof (chain)\npicking this:\n  (a, b) = (?A, ?B) \\<Longrightarrow> ?A * #v + ?B * #w = 1\n  (a, b) = (?A, ?B) \\<Longrightarrow> ?B = 0 \\<or> degree ?B < degree (#v)", "have avbw: \"a * #v + b * #w = 1\" and degb: \"b = 0 \\<or> degree b < degree (#v::'p mod_ring poly)\""], ["proof (prove)\nusing this:\n  (a, b) = (?A, ?B) \\<Longrightarrow> ?A * #v + ?B * #w = 1\n  (a, b) = (?A, ?B) \\<Longrightarrow> ?B = 0 \\<or> degree ?B < degree (#v)\n\ngoal (1 subgoal):\n 1. a * #v + b * #w = 1 &&& b = 0 \\<or> degree b < degree (#v)", "by auto"], ["proof (state)\nthis:\n  a * #v + b * #w = 1\n  b = 0 \\<or> degree b < degree (#v)\n\ngoal (2 subgoals):\n 1. u = V' * W' \\<and>\n    v = #V' \\<and>\n    w = #W' \\<and>\n    degree V' = degree v \\<and>\n    degree W' = degree w \\<and>\n    monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')\n 2. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "have \"?main \\<and> ?unique\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')", "proof (cases \"b = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')", "case b0: True"], ["proof (state)\nthis:\n  b = 0\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')", "with avbw"], ["proof (chain)\npicking this:\n  a * #v + b * #w = 1\n  b = 0", "have \"a * #v = 1\""], ["proof (prove)\nusing this:\n  a * #v + b * #w = 1\n  b = 0\n\ngoal (1 subgoal):\n 1. a * #v = 1", "by auto"], ["proof (state)\nthis:\n  a * #v = 1\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')", "then"], ["proof (chain)\npicking this:\n  a * #v = 1", "have \"degree (#v :: 'p mod_ring poly) = 0\""], ["proof (prove)\nusing this:\n  a * #v = 1\n\ngoal (1 subgoal):\n 1. degree (#v) = 0", "by (metis degree_1 degree_mult_eq_0 mult_zero_left one_neq_zero)"], ["proof (state)\nthis:\n  degree (#v) = 0\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')", "from this[unfolded degv] monic_degree_0[OF monic[unfolded]]"], ["proof (chain)\npicking this:\n  degree v = 0\n  (degree v = 0) = (v = 1)", "have 1: \"v = 1\""], ["proof (prove)\nusing this:\n  degree v = 0\n  (degree v = 0) = (v = 1)\n\ngoal (1 subgoal):\n 1. v = 1", "by auto"], ["proof (state)\nthis:\n  v = 1\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')", "with b0 out uvw"], ["proof (chain)\npicking this:\n  b = 0\n  hensel_1 TYPE('p) u v w = (V', W')\n  #u = v * w\n  v = 1", "have 2: \"V' = 1\" \"W' = u\""], ["proof (prove)\nusing this:\n  b = 0\n  hensel_1 TYPE('p) u v w = (V', W')\n  #u = v * w\n  v = 1\n\ngoal (1 subgoal):\n 1. V' = 1 &&& W' = u", "by (unfold split hensel_1_def Let_def dupe) auto"], ["proof (state)\nthis:\n  V' = 1\n  W' = u\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')", "have 3: ?unique"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "apply (simp add: 1 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       #V'' = 1 \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = 0 \\<longrightarrow>\n       degree W'' = degree (#W'') \\<longrightarrow>\n       poly.coeff V'' 0 = 1 \\<longrightarrow> V'' = 1 \\<and> W'' = V'' * W''", "by (metis monic_degree_0 mult.left_neutral)"], ["proof (state)\nthis:\n  \\<forall>V'' W''.\n     u = V'' * W'' \\<longrightarrow>\n     v = #V'' \\<longrightarrow>\n     w = #W'' \\<longrightarrow>\n     degree V'' = degree v \\<longrightarrow>\n     degree W'' = degree w \\<longrightarrow>\n     lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n     V'' = V' \\<and> W'' = W'\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')", "with uvw degu"], ["proof (chain)\npicking this:\n  #u = v * w\n  degree u = degree v + degree w\n  \\<forall>V'' W''.\n     u = V'' * W'' \\<longrightarrow>\n     v = #V'' \\<longrightarrow>\n     w = #W'' \\<longrightarrow>\n     degree V'' = degree v \\<longrightarrow>\n     degree W'' = degree w \\<longrightarrow>\n     lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n     V'' = V' \\<and> W'' = W'", "show ?thesis"], ["proof (prove)\nusing this:\n  #u = v * w\n  degree u = degree v + degree w\n  \\<forall>V'' W''.\n     u = V'' * W'' \\<longrightarrow>\n     v = #V'' \\<longrightarrow>\n     w = #W'' \\<longrightarrow>\n     degree V'' = degree v \\<longrightarrow>\n     degree W'' = degree w \\<longrightarrow>\n     lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n     V'' = V' \\<and> W'' = W'\n\ngoal (1 subgoal):\n 1. (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')", "unfolding 1 2"], ["proof (prove)\nusing this:\n  #u = 1 * w\n  degree u = degree 1 + degree w\n  \\<forall>V'' W''.\n     u = V'' * W'' \\<longrightarrow>\n     1 = #V'' \\<longrightarrow>\n     w = #W'' \\<longrightarrow>\n     degree V'' = degree 1 \\<longrightarrow>\n     degree W'' = degree w \\<longrightarrow>\n     lead_coeff V'' = @lead_coeff 1 \\<longrightarrow> V'' = 1 \\<and> W'' = u\n\ngoal (1 subgoal):\n 1. (u = 1 * u \\<and>\n     1 = #1 \\<and>\n     w = #u \\<and>\n     degree 1 = degree 1 \\<and>\n     degree u = degree w \\<and>\n     monic 1 \\<and> comm_monoid_mult_class.coprime (#1) (#u)) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        1 = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree 1 \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff 1 \\<longrightarrow>\n        V'' = 1 \\<and> W'' = u)", "by auto"], ["proof (state)\nthis:\n  (u = V' * W' \\<and>\n   v = #V' \\<and>\n   w = #W' \\<and>\n   degree V' = degree v \\<and>\n   degree W' = degree w \\<and>\n   monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n  (\\<forall>V'' W''.\n      u = V'' * W'' \\<longrightarrow>\n      v = #V'' \\<longrightarrow>\n      w = #W'' \\<longrightarrow>\n      degree V'' = degree v \\<longrightarrow>\n      degree W'' = degree w \\<longrightarrow>\n      lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n      V'' = V' \\<and> W'' = W')\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')", "case b0: False"], ["proof (state)\nthis:\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')", "with degb degv"], ["proof (chain)\npicking this:\n  b = 0 \\<or> degree b < degree (#v)\n  degree (#v) = degree v\n  b \\<noteq> 0", "have degb: \"degree b < degree v\""], ["proof (prove)\nusing this:\n  b = 0 \\<or> degree b < degree (#v)\n  degree (#v) = degree v\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree b < degree v", "by auto"], ["proof (state)\nthis:\n  degree b < degree v\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')", "then"], ["proof (chain)\npicking this:\n  degree b < degree v", "have v1: \"v \\<noteq> 1\""], ["proof (prove)\nusing this:\n  degree b < degree v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> 1\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')", "interpret Knuth_ex_4_6_2_22_prime \"TYPE('p)\" \"TYPE('q)\" \"TYPE('pq)\" a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. Knuth_ex_4_6_2_22_prime a b u v w", "by (unfold_locales; fact assms degb avbw)"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u = V' * W' \\<and>\n     v = #V' \\<and>\n     w = #W' \\<and>\n     degree V' = degree v \\<and>\n     degree W' = degree w \\<and>\n     monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n    (\\<forall>V'' W''.\n        u = V'' * W'' \\<longrightarrow>\n        v = #V'' \\<longrightarrow>\n        w = #W'' \\<longrightarrow>\n        degree V'' = degree v \\<longrightarrow>\n        degree W'' = degree w \\<longrightarrow>\n        lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n        V'' = V' \\<and> W'' = W')", "proof (intro conjI)"], ["proof (state)\ngoal (8 subgoals):\n 1. u = V' * W'\n 2. v = #V'\n 3. w = #W'\n 4. degree V' = degree v\n 5. degree W' = degree w\n 6. monic V'\n 7. comm_monoid_mult_class.coprime (#V') (#W')\n 8. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "from out [unfolded hensel_1_def] v1"], ["proof (chain)\npicking this:\n  (if v = 1 then (1, u)\n   else let (s, t) = bezout_coefficients (#v) (#w);\n            (a, b) = Hensel_Lifting_Type_Based.dupe_monic (#v) (#w) s t 1\n        in (#v +\n            Polynomial.smult (of_nat q)\n             (#Knuth_ex_4_6_2_22_main.v' TYPE('q) b u v w),\n            #w +\n            Polynomial.smult (of_nat q)\n             (#Knuth_ex_4_6_2_22_main.w' TYPE('q) a b u v w))) =\n  (V', W')\n  v \\<noteq> 1", "have 1 [simp]: \"V' = V\" \"W' = W\""], ["proof (prove)\nusing this:\n  (if v = 1 then (1, u)\n   else let (s, t) = bezout_coefficients (#v) (#w);\n            (a, b) = Hensel_Lifting_Type_Based.dupe_monic (#v) (#w) s t 1\n        in (#v +\n            Polynomial.smult (of_nat q)\n             (#Knuth_ex_4_6_2_22_main.v' TYPE('q) b u v w),\n            #w +\n            Polynomial.smult (of_nat q)\n             (#Knuth_ex_4_6_2_22_main.w' TYPE('q) a b u v w))) =\n  (V', W')\n  v \\<noteq> 1\n\ngoal (1 subgoal):\n 1. V' = #v + Polynomial.smult (of_nat q) (#v') &&&\n    W' = #w + Polynomial.smult (of_nat q) (#w')", "by (auto simp: bezout dupe)"], ["proof (state)\nthis:\n  V' = #v + Polynomial.smult (of_nat q) (#v')\n  W' = #w + Polynomial.smult (of_nat q) (#w')\n\ngoal (8 subgoals):\n 1. u = V' * W'\n 2. v = #V'\n 3. w = #W'\n 4. degree V' = degree v\n 5. degree W' = degree w\n 6. monic V'\n 7. comm_monoid_mult_class.coprime (#V') (#W')\n 8. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "from uVW"], ["proof (chain)\npicking this:\n  u =\n  (#v + Polynomial.smult (of_nat q) (#v')) *\n  (#w + Polynomial.smult (of_nat q) (#w'))", "show \"u = V' * W'\""], ["proof (prove)\nusing this:\n  u =\n  (#v + Polynomial.smult (of_nat q) (#v')) *\n  (#w + Polynomial.smult (of_nat q) (#w'))\n\ngoal (1 subgoal):\n 1. u = V' * W'", "by auto"], ["proof (state)\nthis:\n  u = V' * W'\n\ngoal (7 subgoals):\n 1. v = #V'\n 2. w = #W'\n 3. degree V' = degree v\n 4. degree W' = degree w\n 5. monic V'\n 6. comm_monoid_mult_class.coprime (#V') (#W')\n 7. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "from degV"], ["proof (chain)\npicking this:\n  degree (#v + Polynomial.smult (of_nat q) (#v')) = degree v", "show [simp]: \"degree V' = degree v\""], ["proof (prove)\nusing this:\n  degree (#v + Polynomial.smult (of_nat q) (#v')) = degree v\n\ngoal (1 subgoal):\n 1. degree V' = degree v", "by simp"], ["proof (state)\nthis:\n  degree V' = degree v\n\ngoal (6 subgoals):\n 1. v = #V'\n 2. w = #W'\n 3. degree W' = degree w\n 4. monic V'\n 5. comm_monoid_mult_class.coprime (#V') (#W')\n 6. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "from degW"], ["proof (chain)\npicking this:\n  degree (#w + Polynomial.smult (of_nat q) (#w')) = degree w", "show [simp]: \"degree W' = degree w\""], ["proof (prove)\nusing this:\n  degree (#w + Polynomial.smult (of_nat q) (#w')) = degree w\n\ngoal (1 subgoal):\n 1. degree W' = degree w", "by simp"], ["proof (state)\nthis:\n  degree W' = degree w\n\ngoal (5 subgoals):\n 1. v = #V'\n 2. w = #W'\n 3. monic V'\n 4. comm_monoid_mult_class.coprime (#V') (#W')\n 5. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "from lcV"], ["proof (chain)\npicking this:\n  lead_coeff (#v + Polynomial.smult (of_nat q) (#v')) = @lead_coeff v", "have \"lead_coeff V' = @lead_coeff v\""], ["proof (prove)\nusing this:\n  lead_coeff (#v + Polynomial.smult (of_nat q) (#v')) = @lead_coeff v\n\ngoal (1 subgoal):\n 1. lead_coeff V' = @lead_coeff v", "by simp"], ["proof (state)\nthis:\n  lead_coeff V' = @lead_coeff v\n\ngoal (5 subgoals):\n 1. v = #V'\n 2. w = #W'\n 3. monic V'\n 4. comm_monoid_mult_class.coprime (#V') (#W')\n 5. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "with monic_v"], ["proof (chain)\npicking this:\n  monic v\n  lead_coeff V' = @lead_coeff v", "show \"monic V'\""], ["proof (prove)\nusing this:\n  monic v\n  lead_coeff V' = @lead_coeff v\n\ngoal (1 subgoal):\n 1. monic V'", "by (simp add:)"], ["proof (state)\nthis:\n  monic V'\n\ngoal (4 subgoals):\n 1. v = #V'\n 2. w = #W'\n 3. comm_monoid_mult_class.coprime (#V') (#W')\n 4. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "from vV"], ["proof (chain)\npicking this:\n  v = #(#v + Polynomial.smult (of_nat q) (#v'))", "show \"v = #V'\""], ["proof (prove)\nusing this:\n  v = #(#v + Polynomial.smult (of_nat q) (#v'))\n\ngoal (1 subgoal):\n 1. v = #V'", "by simp"], ["proof (state)\nthis:\n  v = #V'\n\ngoal (3 subgoals):\n 1. w = #W'\n 2. comm_monoid_mult_class.coprime (#V') (#W')\n 3. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "from wW"], ["proof (chain)\npicking this:\n  w = #(#w + Polynomial.smult (of_nat q) (#w'))", "show \"w = #W'\""], ["proof (prove)\nusing this:\n  w = #(#w + Polynomial.smult (of_nat q) (#w'))\n\ngoal (1 subgoal):\n 1. w = #W'", "by simp"], ["proof (state)\nthis:\n  w = #W'\n\ngoal (2 subgoals):\n 1. comm_monoid_mult_class.coprime (#V') (#W')\n 2. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "from coprime_preserves"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime (#(#v + Polynomial.smult (of_nat q) (#v')))\n   (#(#w + Polynomial.smult (of_nat q) (#w')))", "show \"coprime (#V' :: 'p mod_ring poly) (#W')\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (#(#v + Polynomial.smult (of_nat q) (#v')))\n   (#(#w + Polynomial.smult (of_nat q) (#w')))\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (#V') (#W')", "by simp"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (#V') (#W')\n\ngoal (1 subgoal):\n 1. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "show 9: ?unique"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "by (unfold 1, intro allI conjI impI; rule unique)"], ["proof (state)\nthis:\n  \\<forall>V'' W''.\n     u = V'' * W'' \\<longrightarrow>\n     v = #V'' \\<longrightarrow>\n     w = #W'' \\<longrightarrow>\n     degree V'' = degree v \\<longrightarrow>\n     degree W'' = degree w \\<longrightarrow>\n     lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n     V'' = V' \\<and> W'' = W'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u = V' * W' \\<and>\n   v = #V' \\<and>\n   w = #W' \\<and>\n   degree V' = degree v \\<and>\n   degree W' = degree w \\<and>\n   monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n  (\\<forall>V'' W''.\n      u = V'' * W'' \\<longrightarrow>\n      v = #V'' \\<longrightarrow>\n      w = #W'' \\<longrightarrow>\n      degree V'' = degree v \\<longrightarrow>\n      degree W'' = degree w \\<longrightarrow>\n      lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n      V'' = V' \\<and> W'' = W')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u = V' * W' \\<and>\n   v = #V' \\<and>\n   w = #W' \\<and>\n   degree V' = degree v \\<and>\n   degree W' = degree w \\<and>\n   monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n  (\\<forall>V'' W''.\n      u = V'' * W'' \\<longrightarrow>\n      v = #V'' \\<longrightarrow>\n      w = #W'' \\<longrightarrow>\n      degree V'' = degree v \\<longrightarrow>\n      degree W'' = degree w \\<longrightarrow>\n      lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n      V'' = V' \\<and> W'' = W')\n\ngoal (2 subgoals):\n 1. u = V' * W' \\<and>\n    v = #V' \\<and>\n    w = #W' \\<and>\n    degree V' = degree v \\<and>\n    degree W' = degree w \\<and>\n    monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')\n 2. \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "then"], ["proof (chain)\npicking this:\n  (u = V' * W' \\<and>\n   v = #V' \\<and>\n   w = #W' \\<and>\n   degree V' = degree v \\<and>\n   degree W' = degree w \\<and>\n   monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n  (\\<forall>V'' W''.\n      u = V'' * W'' \\<longrightarrow>\n      v = #V'' \\<longrightarrow>\n      w = #W'' \\<longrightarrow>\n      degree V'' = degree v \\<longrightarrow>\n      degree W'' = degree w \\<longrightarrow>\n      lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n      V'' = V' \\<and> W'' = W')", "show ?main ?unique"], ["proof (prove)\nusing this:\n  (u = V' * W' \\<and>\n   v = #V' \\<and>\n   w = #W' \\<and>\n   degree V' = degree v \\<and>\n   degree W' = degree w \\<and>\n   monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')) \\<and>\n  (\\<forall>V'' W''.\n      u = V'' * W'' \\<longrightarrow>\n      v = #V'' \\<longrightarrow>\n      w = #W'' \\<longrightarrow>\n      degree V'' = degree v \\<longrightarrow>\n      degree W'' = degree w \\<longrightarrow>\n      lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n      V'' = V' \\<and> W'' = W')\n\ngoal (1 subgoal):\n 1. u = V' * W' \\<and>\n    v = #V' \\<and>\n    w = #W' \\<and>\n    degree V' = degree v \\<and>\n    degree W' = degree w \\<and>\n    monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W') &&&\n    \\<forall>V'' W''.\n       u = V'' * W'' \\<longrightarrow>\n       v = #V'' \\<longrightarrow>\n       w = #W'' \\<longrightarrow>\n       degree V'' = degree v \\<longrightarrow>\n       degree W'' = degree w \\<longrightarrow>\n       lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n       V'' = V' \\<and> W'' = W'", "by (fact conjunct1, fact conjunct2)"], ["proof (state)\nthis:\n  u = V' * W' \\<and>\n  v = #V' \\<and>\n  w = #W' \\<and>\n  degree V' = degree v \\<and>\n  degree W' = degree w \\<and>\n  monic V' \\<and> comm_monoid_mult_class.coprime (#V') (#W')\n  \\<forall>V'' W''.\n     u = V'' * W'' \\<longrightarrow>\n     v = #V'' \\<longrightarrow>\n     w = #W'' \\<longrightarrow>\n     degree V'' = degree v \\<longrightarrow>\n     degree W'' = degree w \\<longrightarrow>\n     lead_coeff V'' = @lead_coeff v \\<longrightarrow>\n     V'' = V' \\<and> W'' = W'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}