{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Mahler_Measure.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma induct_gen_abs:\n    assumes \"\\<And> a r. a\\<in>set lst \\<Longrightarrow> P (f (h a) r) (f (g a) r)\"\n            \"\\<And> x y z. P x y \\<Longrightarrow> P y z \\<Longrightarrow> P x z\"\n            \"P (F (map g lst)) (F (map g lst))\"\n    shows \"P (F (map h lst)) (F (map g lst)) \"", "lemma prod_induct_gen:\n  assumes \"\\<And> a r. f (h a * r :: 'a :: {comm_monoid_mult}) = f (g a * r)\"\n  shows \"f (\\<Prod>v\\<leftarrow>lst. h v) = f (\\<Prod>v\\<leftarrow>lst. g v)\"", "lemma complex_roots:\n  \"smult (lead_coeff p) (\\<Prod>a\\<leftarrow>complex_roots_complex p. [:- a, 1:]) = p\"\n  \"length (complex_roots_complex p) = degree p\"", "lemma complex_roots_c [simp]:\n  \"complex_roots_complex [:c:] = []\"", "lemma complex_roots_1 [simp]:\n  \"complex_roots_complex 1 = []\"", "lemma linear_term_irreducible\\<^sub>d[simp]: \"irreducible\\<^sub>d [: a, 1:]\"", "lemma complex_roots_int:\n  \"smult (lead_coeff p) (\\<Prod>a\\<leftarrow>complex_roots_int p. [:- a, 1:]) = map_poly of_int p\"\n  \"length (complex_roots_int p) = degree p\"", "lemma mahler_measure_poly_via_monic :\n  \"mahler_measure_poly p = cmod (lead_coeff p) * mahler_measure_monic p\"", "lemma smult_inj[simp]: assumes \"(a::'a::idom) \\<noteq> 0\" shows \"inj (smult a)\"", "lemma reconstruct_is_original_poly:\n  \"reconstruct_poly (lead_coeff p) (complex_roots_complex p) = p\"", "lemma reconstruct_with_type_conversion:\n  \"smult (lead_coeff (map_poly of_int f)) (prod_list (map (\\<lambda> a. [:- a, 1:]) (complex_roots_int f)))\n   = map_poly of_int f\"", "lemma reconstruct_prod:\n  shows \"reconstruct_poly (a::complex) as * reconstruct_poly b bs\n        = reconstruct_poly (a * b) (as @ bs)\"", "lemma linear_term_inj[simplified,simp]: \"inj (\\<lambda> a. [:- a, 1::'a::idom:])\"", "lemma reconstruct_poly_monic_defines_mset:\n  assumes \"(\\<Prod>a\\<leftarrow>as. [:- a, 1:]) = (\\<Prod>a\\<leftarrow>bs. [:- a, 1::'a::field:])\"\n  shows \"mset as = mset bs\"", "lemma reconstruct_poly_defines_mset_of_argument:\n  assumes \"(a::'a::field) \\<noteq> 0\"\n          \"reconstruct_poly a as = reconstruct_poly a bs\"\n  shows \"mset as = mset bs\"", "lemma complex_roots_complex_prod [simp]:\n  assumes \"f \\<noteq> 0\" \"g \\<noteq> 0\"\n  shows  \"mset (complex_roots_complex (f * g))\n        = mset (complex_roots_complex f) + mset (complex_roots_complex g)\"", "lemma mset_mult_add:\n  assumes \"mset (a::'a::field list) = mset b + mset c\"\n  shows \"prod_list a = prod_list b * prod_list c\"", "lemma mset_mult_add_2:\n  assumes \"mset a = mset b + mset c\"\n  shows \"prod_list (map i a::'b::field list) = prod_list (map i b) * prod_list (map i c)\"", "lemma measure_mono_eq_prod:\n  assumes \"f \\<noteq> 0\" \"g \\<noteq> 0\"\n  shows \"mahler_measure_monic (f * g) = mahler_measure_monic f * mahler_measure_monic g\"", "lemma mahler_measure_poly_0[simp]: \"mahler_measure_poly 0 = 0\"", "lemma measure_eq_prod: (* Remark 10.2 *)\n  \"mahler_measure_poly (f * g) = mahler_measure_poly f * mahler_measure_poly g\"", "lemma prod_cmod[simp]:\n  \"cmod (\\<Prod>a\\<leftarrow>lst. f a) = (\\<Prod>a\\<leftarrow>lst. cmod (f a))\"", "lemma lead_coeff_of_prod[simp]:\n  \"lead_coeff (\\<Prod>a\\<leftarrow>lst. f a::'a::idom poly) = (\\<Prod>a\\<leftarrow>lst. lead_coeff (f a))\"", "lemma ineq_about_squares:assumes \"x \\<le> (y::real)\" shows \"x \\<le> c^2 + y\"", "lemma first_coeff_le_tail:\"(cmod (lead_coeff g))^2 \\<le> (\\<Sum>a\\<leftarrow>coeffs g. (cmod a)^2)\"", "lemma square_prod_cmod[simp]:\n  \"(cmod (a * b))^2 = cmod a ^ 2 * cmod b ^ 2\"", "lemma sum_coeffs_smult_cmod:\n  \"(\\<Sum>a\\<leftarrow>coeffs (smult v p). (cmod a)^2) = (cmod v)^2 * (\\<Sum>a\\<leftarrow>coeffs p. (cmod a)^2)\" \n  (is \"?l = ?r\")", "lemma coeffs_cong_1[simp]: \"cCons a v = cCons b v \\<longleftrightarrow> a = b\"", "lemma strip_while_singleton[simp]:\n  \"strip_while ((=) 0) [v * a] = cCons (v * a) []\"", "lemma coeffs_times_linterm:\n  shows \"coeffs (pCons 0 (smult a p) + smult b p) = strip_while (HOL.eq (0::'a::{comm_ring_1}))\n     (map (\\<lambda>(c,d).b*d+c*a) (zip (0 # coeffs p) (coeffs p @ [0])))\"", "lemma filter_distr_rev[simp]:\n  shows \"filter f (rev lst) = rev (filter f lst)\"", "lemma strip_while_filter:\n  shows \"filter ((\\<noteq>) 0) (strip_while ((=) 0) (lst::'a::zero list)) = filter ((\\<noteq>) 0) lst\"", "lemma sum_stripwhile[simp]:\n  assumes \"f 0 = 0\"\n  shows \"(\\<Sum>a\\<leftarrow>strip_while ((=) 0) lst. f a) = (\\<Sum>a\\<leftarrow>lst. f a)\"", "lemma complex_split : \"Complex a b = c \\<longleftrightarrow> (a = Re c \\<and> b = Im c)\"", "lemma norm_times_const:\"(\\<Sum>y\\<leftarrow>lst. (cmod (a * y))\\<^sup>2) = (cmod a)\\<^sup>2 * (\\<Sum>y\\<leftarrow>lst. (cmod y)\\<^sup>2)\"", "lemma bisumTail_is_map_zip:\n  \"(\\<Sum>x\\<leftarrow>zip (v # l1) (l1 @ [0]). f x) = bisumTail (\\<lambda>x y .f (x,y))  (v#l1)\"", "lemma bisum_is_map_zip:\n  \"(\\<Sum>x\\<leftarrow>zip (0 # l1) (l1 @ [0]). f x) = bisum (\\<lambda>x y. f (x,y)) l1\"", "lemma map_zip_is_bisum:\n  \"bisum f l1 = (\\<Sum>(x,y)\\<leftarrow>zip (0 # l1) (l1 @ [0]). f x y)\"", "lemma bisum_outside :\n  \"(bisum (\\<lambda> x y. f1 x - f2 x y + f3 y) lst :: 'a :: field)\n  = sum_list (map f1 lst) + f1 0 - bisum f2 lst + sum_list (map f3 lst) + f3 0\"", "lemma Landau_lemma:\n  \"(\\<Sum>a\\<leftarrow>coeffs (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]). (cmod a)\\<^sup>2) = (\\<Sum>a\\<leftarrow>coeffs (\\<Prod>a\\<leftarrow>lst. linH a). (cmod a)\\<^sup>2)\"\n  (is \"norm2 ?l = norm2 ?r\")", "lemma Landau_inequality:\n  \"mahler_measure_poly f \\<le> l2norm_complex f\"", "lemma prod_list_ge1:\n  assumes \"Ball (set x) (\\<lambda> (a::real). a \\<ge> 1)\"\n  shows \"prod_list x \\<ge> 1\"", "lemma mahler_measure_monic_ge_1: \"mahler_measure_monic p \\<ge> 1\"", "lemma mahler_measure_monic_ge_0: \"mahler_measure_monic p \\<ge> 0\"", "lemma mahler_measure_ge_0: \"0 \\<le> mahler_measure h\"", "lemma mahler_measure_constant[simp]: \"mahler_measure_poly [:c:] = cmod c\"", "lemma mahler_measure_factor[simplified,simp]: \"mahler_measure_poly [:- a, 1:] = max 1 (cmod a)\"", "lemma mahler_measure_poly_explicit: \"mahler_measure_poly (smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:]))\n  = cmod c * (\\<Prod>a\\<leftarrow>as. (max 1 (cmod a)))\"", "lemma mahler_measure_poly_ge_1:\n  assumes \"h \\<noteq> 0\"\n  shows \"(1::real) \\<le> mahler_measure h\"", "lemma mahler_measure_dvd: assumes \"f \\<noteq> 0\" and \"h dvd f\" \n  shows \"mahler_measure h \\<le> mahler_measure f\"", "lemma mahler_graeffe: \"mahler_measure_poly (graeffe_poly c as m) = (mahler_measure_poly f)^(2^m)\"", "lemma poly_square_subst_coeff: \"coeff (poly_square_subst f) i = coeff f (2 * i)\"", "lemma poly_even_odd_coeff: assumes \"poly_even_odd f = (ev,od)\"\n  shows \"coeff ev i = coeff f (2 * i)\" \"coeff od i = coeff f (2 * i + 1)\"", "lemma poly_square_subst: \"poly_square_subst (f \\<circ>\\<^sub>p (monom 1 2)) = f\"", "lemma poly_even_odd: assumes \"poly_even_odd f = (g,h)\" \n  shows \"f = g \\<circ>\\<^sub>p monom 1 2 + monom 1 1 * (h \\<circ>\\<^sub>p monom 1 2)\"", "lemma graeffe_0: \"f = smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<Longrightarrow> graeffe_poly c as 0 = f\"", "lemma graeffe_recursion: assumes \"graeffe_poly c as m = f\"\n  shows \"graeffe_poly c as (Suc m) = smult ((-1)^(degree f)) (poly_square_subst (f * f \\<circ>\\<^sub>p [:0,-1:]))\"", "lemma graeffe_one_step_code[code]: fixes c :: \"'a :: idom\" \n  shows \"graeffe_one_step c f = (case poly_even_odd f of (g,h)\n  \\<Rightarrow> smult c (g * g - monom 1 1 * h * h))\"", "lemma graeffe_poly_impl_main: assumes \"f = smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])\"\n  shows \"graeffe_poly_impl_main ((-1)^degree f) f m = graeffe_poly c as m\"", "lemma graeffe_poly_impl: assumes \"f = smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])\"\n  shows \"graeffe_poly_impl f m = graeffe_poly c as m\"", "lemma drop_half_map: \"drop_half (map f xs) = map f (drop_half xs)\"", "lemma (in inj_comm_ring_hom) map_poly_poly_square_subst: \n  \"map_poly hom (poly_square_subst f) = poly_square_subst (map_poly hom f)\"", "lemma graeffe_poly_impl_hom:\n  \"map_poly hom (graeffe_poly_impl f m) = graeffe_poly_impl (map_poly hom f) m\"", "lemma graeffe_poly_impl_mahler: \"mahler_measure (graeffe_poly_impl f m) = mahler_measure f ^ 2 ^ m\"", "lemma mahler_landau_graeffe_approximation_core: \n  assumes g: \"g = graeffe_poly_impl f k\" \n  shows \"mahler_measure f \\<le> root (2 ^ Suc k) (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))\"", "lemma Landau_inequality_mahler_measure: \"mahler_measure f \\<le> sqrt (real_of_int (\\<Sum>a\\<leftarrow>coeffs f. a * a))\"", "lemma mahler_landau_graeffe_approximation:\n  assumes g: \"g = graeffe_poly_impl f k\" \"dd = d^(2^(Suc k))\" \"kk = 2^(Suc k)\" \n  shows \"\\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mahler_landau_graeffe_approximation kk dd g\"", "lemma mahler_approximation_main: assumes \"k \\<noteq> 0 \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm\"\n    and \"c = (-1)^(degree f)\" \n    and \"g = graeffe_poly_impl_main c f k\" \"dd = d^(2^(Suc k))\" \"kk = 2^(Suc k)\"\n  shows \"\\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mahler_approximation_main dd c g mm k kk\"", "lemma mahler_approximation: \"\\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mahler_approximation d f\""], "translations": [["", "lemma induct_gen_abs:\n    assumes \"\\<And> a r. a\\<in>set lst \\<Longrightarrow> P (f (h a) r) (f (g a) r)\"\n            \"\\<And> x y z. P x y \\<Longrightarrow> P y z \\<Longrightarrow> P x z\"\n            \"P (F (map g lst)) (F (map g lst))\"\n    shows \"P (F (map h lst)) (F (map g lst)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (F (map h lst)) (F (map g lst))", "using assms"], ["proof (prove)\nusing this:\n  ?a \\<in> set lst \\<Longrightarrow>\n  P (h ?a \\<^bold>* ?r) (g ?a \\<^bold>* ?r)\n  \\<lbrakk>P ?x ?y; P ?y ?z\\<rbrakk> \\<Longrightarrow> P ?x ?z\n  P (F (map g lst)) (F (map g lst))\n\ngoal (1 subgoal):\n 1. P (F (map h lst)) (F (map g lst))", "proof(induct lst arbitrary:P)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>a r.\n                   a \\<in> set [] \\<Longrightarrow>\n                   P (h a \\<^bold>* r) (g a \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g [])) (F (map g []))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h [])) (F (map g []))\n 2. \\<And>a lst P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>\\<And>a r.\n                               a \\<in> set lst \\<Longrightarrow>\n                               P (h a \\<^bold>* r) (g a \\<^bold>* r);\n                    \\<And>x y z.\n                       \\<lbrakk>P x y; P y z\\<rbrakk>\n                       \\<Longrightarrow> P x z;\n                    P (F (map g lst)) (F (map g lst))\\<rbrakk>\n                   \\<Longrightarrow> P (F (map h lst)) (F (map g lst));\n        \\<And>aa r.\n           aa \\<in> set (a # lst) \\<Longrightarrow>\n           P (h aa \\<^bold>* r) (g aa \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g (a # lst))) (F (map g (a # lst)))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h (a # lst))) (F (map g (a # lst)))", "case (Cons a as P)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>a r.\n              a \\<in> set as \\<Longrightarrow>\n              ?P (h a \\<^bold>* r) (g a \\<^bold>* r);\n   \\<And>x y z. \\<lbrakk>?P x y; ?P y z\\<rbrakk> \\<Longrightarrow> ?P x z;\n   ?P (F (map g as)) (F (map g as))\\<rbrakk>\n  \\<Longrightarrow> ?P (F (map h as)) (F (map g as))\n  ?a \\<in> set (a # as) \\<Longrightarrow>\n  P (h ?a \\<^bold>* ?r) (g ?a \\<^bold>* ?r)\n  \\<lbrakk>P ?x ?y; P ?y ?z\\<rbrakk> \\<Longrightarrow> P ?x ?z\n  P (F (map g (a # as))) (F (map g (a # as)))\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>a r.\n                   a \\<in> set [] \\<Longrightarrow>\n                   P (h a \\<^bold>* r) (g a \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g [])) (F (map g []))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h [])) (F (map g []))\n 2. \\<And>a lst P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>\\<And>a r.\n                               a \\<in> set lst \\<Longrightarrow>\n                               P (h a \\<^bold>* r) (g a \\<^bold>* r);\n                    \\<And>x y z.\n                       \\<lbrakk>P x y; P y z\\<rbrakk>\n                       \\<Longrightarrow> P x z;\n                    P (F (map g lst)) (F (map g lst))\\<rbrakk>\n                   \\<Longrightarrow> P (F (map h lst)) (F (map g lst));\n        \\<And>aa r.\n           aa \\<in> set (a # lst) \\<Longrightarrow>\n           P (h aa \\<^bold>* r) (g aa \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g (a # lst))) (F (map g (a # lst)))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h (a # lst))) (F (map g (a # lst)))", "have inl:\"a\\<in>set (a#as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (a # as)", "by auto"], ["proof (state)\nthis:\n  a \\<in> set (a # as)\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>a r.\n                   a \\<in> set [] \\<Longrightarrow>\n                   P (h a \\<^bold>* r) (g a \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g [])) (F (map g []))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h [])) (F (map g []))\n 2. \\<And>a lst P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>\\<And>a r.\n                               a \\<in> set lst \\<Longrightarrow>\n                               P (h a \\<^bold>* r) (g a \\<^bold>* r);\n                    \\<And>x y z.\n                       \\<lbrakk>P x y; P y z\\<rbrakk>\n                       \\<Longrightarrow> P x z;\n                    P (F (map g lst)) (F (map g lst))\\<rbrakk>\n                   \\<Longrightarrow> P (F (map h lst)) (F (map g lst));\n        \\<And>aa r.\n           aa \\<in> set (a # lst) \\<Longrightarrow>\n           P (h aa \\<^bold>* r) (g aa \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g (a # lst))) (F (map g (a # lst)))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h (a # lst))) (F (map g (a # lst)))", "let ?uf = \"\\<lambda> v w. P (f (g a) v) (f (g a) w)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>a r.\n                   a \\<in> set [] \\<Longrightarrow>\n                   P (h a \\<^bold>* r) (g a \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g [])) (F (map g []))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h [])) (F (map g []))\n 2. \\<And>a lst P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>\\<And>a r.\n                               a \\<in> set lst \\<Longrightarrow>\n                               P (h a \\<^bold>* r) (g a \\<^bold>* r);\n                    \\<And>x y z.\n                       \\<lbrakk>P x y; P y z\\<rbrakk>\n                       \\<Longrightarrow> P x z;\n                    P (F (map g lst)) (F (map g lst))\\<rbrakk>\n                   \\<Longrightarrow> P (F (map h lst)) (F (map g lst));\n        \\<And>aa r.\n           aa \\<in> set (a # lst) \\<Longrightarrow>\n           P (h aa \\<^bold>* r) (g aa \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g (a # lst))) (F (map g (a # lst)))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h (a # lst))) (F (map g (a # lst)))", "have p_suc:\"?uf (F (map g as)) (F (map g as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (g a \\<^bold>* F (map g as)) (g a \\<^bold>* F (map g as))", "using Cons.prems(3)"], ["proof (prove)\nusing this:\n  P (F (map g (a # as))) (F (map g (a # as)))\n\ngoal (1 subgoal):\n 1. P (g a \\<^bold>* F (map g as)) (g a \\<^bold>* F (map g as))", "by auto"], ["proof (state)\nthis:\n  P (g a \\<^bold>* F (map g as)) (g a \\<^bold>* F (map g as))\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>a r.\n                   a \\<in> set [] \\<Longrightarrow>\n                   P (h a \\<^bold>* r) (g a \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g [])) (F (map g []))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h [])) (F (map g []))\n 2. \\<And>a lst P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>\\<And>a r.\n                               a \\<in> set lst \\<Longrightarrow>\n                               P (h a \\<^bold>* r) (g a \\<^bold>* r);\n                    \\<And>x y z.\n                       \\<lbrakk>P x y; P y z\\<rbrakk>\n                       \\<Longrightarrow> P x z;\n                    P (F (map g lst)) (F (map g lst))\\<rbrakk>\n                   \\<Longrightarrow> P (F (map h lst)) (F (map g lst));\n        \\<And>aa r.\n           aa \\<in> set (a # lst) \\<Longrightarrow>\n           P (h aa \\<^bold>* r) (g aa \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g (a # lst))) (F (map g (a # lst)))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h (a # lst))) (F (map g (a # lst)))", "{"], ["proof (state)\nthis:\n  P (g a \\<^bold>* F (map g as)) (g a \\<^bold>* F (map g as))\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>a r.\n                   a \\<in> set [] \\<Longrightarrow>\n                   P (h a \\<^bold>* r) (g a \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g [])) (F (map g []))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h [])) (F (map g []))\n 2. \\<And>a lst P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>\\<And>a r.\n                               a \\<in> set lst \\<Longrightarrow>\n                               P (h a \\<^bold>* r) (g a \\<^bold>* r);\n                    \\<And>x y z.\n                       \\<lbrakk>P x y; P y z\\<rbrakk>\n                       \\<Longrightarrow> P x z;\n                    P (F (map g lst)) (F (map g lst))\\<rbrakk>\n                   \\<Longrightarrow> P (F (map h lst)) (F (map g lst));\n        \\<And>aa r.\n           aa \\<in> set (a # lst) \\<Longrightarrow>\n           P (h aa \\<^bold>* r) (g aa \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g (a # lst))) (F (map g (a # lst)))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h (a # lst))) (F (map g (a # lst)))", "fix r aa"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>a r.\n                   a \\<in> set [] \\<Longrightarrow>\n                   P (h a \\<^bold>* r) (g a \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g [])) (F (map g []))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h [])) (F (map g []))\n 2. \\<And>a lst P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>\\<And>a r.\n                               a \\<in> set lst \\<Longrightarrow>\n                               P (h a \\<^bold>* r) (g a \\<^bold>* r);\n                    \\<And>x y z.\n                       \\<lbrakk>P x y; P y z\\<rbrakk>\n                       \\<Longrightarrow> P x z;\n                    P (F (map g lst)) (F (map g lst))\\<rbrakk>\n                   \\<Longrightarrow> P (F (map h lst)) (F (map g lst));\n        \\<And>aa r.\n           aa \\<in> set (a # lst) \\<Longrightarrow>\n           P (h aa \\<^bold>* r) (g aa \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g (a # lst))) (F (map g (a # lst)))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h (a # lst))) (F (map g (a # lst)))", "assume \"aa \\<in> set as\""], ["proof (state)\nthis:\n  aa \\<in> set as\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>a r.\n                   a \\<in> set [] \\<Longrightarrow>\n                   P (h a \\<^bold>* r) (g a \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g [])) (F (map g []))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h [])) (F (map g []))\n 2. \\<And>a lst P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>\\<And>a r.\n                               a \\<in> set lst \\<Longrightarrow>\n                               P (h a \\<^bold>* r) (g a \\<^bold>* r);\n                    \\<And>x y z.\n                       \\<lbrakk>P x y; P y z\\<rbrakk>\n                       \\<Longrightarrow> P x z;\n                    P (F (map g lst)) (F (map g lst))\\<rbrakk>\n                   \\<Longrightarrow> P (F (map h lst)) (F (map g lst));\n        \\<And>aa r.\n           aa \\<in> set (a # lst) \\<Longrightarrow>\n           P (h aa \\<^bold>* r) (g aa \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g (a # lst))) (F (map g (a # lst)))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h (a # lst))) (F (map g (a # lst)))", "hence ins:\"aa \\<in> set (a#as)\""], ["proof (prove)\nusing this:\n  aa \\<in> set as\n\ngoal (1 subgoal):\n 1. aa \\<in> set (a # as)", "by auto"], ["proof (state)\nthis:\n  aa \\<in> set (a # as)\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>a r.\n                   a \\<in> set [] \\<Longrightarrow>\n                   P (h a \\<^bold>* r) (g a \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g [])) (F (map g []))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h [])) (F (map g []))\n 2. \\<And>a lst P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>\\<And>a r.\n                               a \\<in> set lst \\<Longrightarrow>\n                               P (h a \\<^bold>* r) (g a \\<^bold>* r);\n                    \\<And>x y z.\n                       \\<lbrakk>P x y; P y z\\<rbrakk>\n                       \\<Longrightarrow> P x z;\n                    P (F (map g lst)) (F (map g lst))\\<rbrakk>\n                   \\<Longrightarrow> P (F (map h lst)) (F (map g lst));\n        \\<And>aa r.\n           aa \\<in> set (a # lst) \\<Longrightarrow>\n           P (h aa \\<^bold>* r) (g aa \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g (a # lst))) (F (map g (a # lst)))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h (a # lst))) (F (map g (a # lst)))", "have \"P (f (g a) (f (h aa) r)) (f (g a) (f (g aa) r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (g a \\<^bold>* (h aa \\<^bold>* r)) (g a \\<^bold>* (g aa \\<^bold>* r))", "using Cons.prems(1)[of aa \"f r (g a)\",OF ins]"], ["proof (prove)\nusing this:\n  P (h aa \\<^bold>* (r \\<^bold>* g a)) (g aa \\<^bold>* (r \\<^bold>* g a))\n\ngoal (1 subgoal):\n 1. P (g a \\<^bold>* (h aa \\<^bold>* r)) (g a \\<^bold>* (g aa \\<^bold>* r))", "by (auto simp: assoc commute left_commute)"], ["proof (state)\nthis:\n  P (g a \\<^bold>* (h aa \\<^bold>* r)) (g a \\<^bold>* (g aa \\<^bold>* r))\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>a r.\n                   a \\<in> set [] \\<Longrightarrow>\n                   P (h a \\<^bold>* r) (g a \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g [])) (F (map g []))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h [])) (F (map g []))\n 2. \\<And>a lst P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>\\<And>a r.\n                               a \\<in> set lst \\<Longrightarrow>\n                               P (h a \\<^bold>* r) (g a \\<^bold>* r);\n                    \\<And>x y z.\n                       \\<lbrakk>P x y; P y z\\<rbrakk>\n                       \\<Longrightarrow> P x z;\n                    P (F (map g lst)) (F (map g lst))\\<rbrakk>\n                   \\<Longrightarrow> P (F (map h lst)) (F (map g lst));\n        \\<And>aa r.\n           aa \\<in> set (a # lst) \\<Longrightarrow>\n           P (h aa \\<^bold>* r) (g aa \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g (a # lst))) (F (map g (a # lst)))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h (a # lst))) (F (map g (a # lst)))", "}"], ["proof (state)\nthis:\n  ?aa2 \\<in> set as \\<Longrightarrow>\n  P (g a \\<^bold>* (h ?aa2 \\<^bold>* ?r2))\n   (g a \\<^bold>* (g ?aa2 \\<^bold>* ?r2))\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>a r.\n                   a \\<in> set [] \\<Longrightarrow>\n                   P (h a \\<^bold>* r) (g a \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g [])) (F (map g []))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h [])) (F (map g []))\n 2. \\<And>a lst P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>\\<And>a r.\n                               a \\<in> set lst \\<Longrightarrow>\n                               P (h a \\<^bold>* r) (g a \\<^bold>* r);\n                    \\<And>x y z.\n                       \\<lbrakk>P x y; P y z\\<rbrakk>\n                       \\<Longrightarrow> P x z;\n                    P (F (map g lst)) (F (map g lst))\\<rbrakk>\n                   \\<Longrightarrow> P (F (map h lst)) (F (map g lst));\n        \\<And>aa r.\n           aa \\<in> set (a # lst) \\<Longrightarrow>\n           P (h aa \\<^bold>* r) (g aa \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g (a # lst))) (F (map g (a # lst)))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h (a # lst))) (F (map g (a # lst)))", "note h = this"], ["proof (state)\nthis:\n  ?aa2 \\<in> set as \\<Longrightarrow>\n  P (g a \\<^bold>* (h ?aa2 \\<^bold>* ?r2))\n   (g a \\<^bold>* (g ?aa2 \\<^bold>* ?r2))\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>a r.\n                   a \\<in> set [] \\<Longrightarrow>\n                   P (h a \\<^bold>* r) (g a \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g [])) (F (map g []))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h [])) (F (map g []))\n 2. \\<And>a lst P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>\\<And>a r.\n                               a \\<in> set lst \\<Longrightarrow>\n                               P (h a \\<^bold>* r) (g a \\<^bold>* r);\n                    \\<And>x y z.\n                       \\<lbrakk>P x y; P y z\\<rbrakk>\n                       \\<Longrightarrow> P x z;\n                    P (F (map g lst)) (F (map g lst))\\<rbrakk>\n                   \\<Longrightarrow> P (F (map h lst)) (F (map g lst));\n        \\<And>aa r.\n           aa \\<in> set (a # lst) \\<Longrightarrow>\n           P (h aa \\<^bold>* r) (g aa \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g (a # lst))) (F (map g (a # lst)))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h (a # lst))) (F (map g (a # lst)))", "from Cons.hyps(1)[of ?uf, OF h Cons.prems(2)[simplified] p_suc]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>a r. a \\<in> set as \\<Longrightarrow> a \\<in> set as;\n   \\<And>x y z.\n      \\<lbrakk>P (g a \\<^bold>* x) (g a \\<^bold>* y);\n       P (g a \\<^bold>* y) (g a \\<^bold>* z)\\<rbrakk>\n      \\<Longrightarrow> P (g a \\<^bold>* x) (?y x y z);\n   \\<And>x y z.\n      \\<lbrakk>P (g a \\<^bold>* x) (g a \\<^bold>* y);\n       P (g a \\<^bold>* y) (g a \\<^bold>* z)\\<rbrakk>\n      \\<Longrightarrow> P (?y x y z) (g a \\<^bold>* z)\\<rbrakk>\n  \\<Longrightarrow> P (g a \\<^bold>* F (map h as))\n                     (g a \\<^bold>* F (map g as))", "have e1:\"P (f (g a) (F (map h as))) (f (g a) (F (map g as)))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>a r. a \\<in> set as \\<Longrightarrow> a \\<in> set as;\n   \\<And>x y z.\n      \\<lbrakk>P (g a \\<^bold>* x) (g a \\<^bold>* y);\n       P (g a \\<^bold>* y) (g a \\<^bold>* z)\\<rbrakk>\n      \\<Longrightarrow> P (g a \\<^bold>* x) (?y x y z);\n   \\<And>x y z.\n      \\<lbrakk>P (g a \\<^bold>* x) (g a \\<^bold>* y);\n       P (g a \\<^bold>* y) (g a \\<^bold>* z)\\<rbrakk>\n      \\<Longrightarrow> P (?y x y z) (g a \\<^bold>* z)\\<rbrakk>\n  \\<Longrightarrow> P (g a \\<^bold>* F (map h as))\n                     (g a \\<^bold>* F (map g as))\n\ngoal (1 subgoal):\n 1. P (g a \\<^bold>* F (map h as)) (g a \\<^bold>* F (map g as))", "by simp"], ["proof (state)\nthis:\n  P (g a \\<^bold>* F (map h as)) (g a \\<^bold>* F (map g as))\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>a r.\n                   a \\<in> set [] \\<Longrightarrow>\n                   P (h a \\<^bold>* r) (g a \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g [])) (F (map g []))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h [])) (F (map g []))\n 2. \\<And>a lst P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>\\<And>a r.\n                               a \\<in> set lst \\<Longrightarrow>\n                               P (h a \\<^bold>* r) (g a \\<^bold>* r);\n                    \\<And>x y z.\n                       \\<lbrakk>P x y; P y z\\<rbrakk>\n                       \\<Longrightarrow> P x z;\n                    P (F (map g lst)) (F (map g lst))\\<rbrakk>\n                   \\<Longrightarrow> P (F (map h lst)) (F (map g lst));\n        \\<And>aa r.\n           aa \\<in> set (a # lst) \\<Longrightarrow>\n           P (h aa \\<^bold>* r) (g aa \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g (a # lst))) (F (map g (a # lst)))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h (a # lst))) (F (map g (a # lst)))", "have e2:\"P (f (h a) (F (map h as))) (f (g a) (F (map h as)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (h a \\<^bold>* F (map h as)) (g a \\<^bold>* F (map h as))", "using Cons.prems(1)[OF inl]"], ["proof (prove)\nusing this:\n  P (h a \\<^bold>* ?r) (g a \\<^bold>* ?r)\n\ngoal (1 subgoal):\n 1. P (h a \\<^bold>* F (map h as)) (g a \\<^bold>* F (map h as))", "by blast"], ["proof (state)\nthis:\n  P (h a \\<^bold>* F (map h as)) (g a \\<^bold>* F (map h as))\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>a r.\n                   a \\<in> set [] \\<Longrightarrow>\n                   P (h a \\<^bold>* r) (g a \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g [])) (F (map g []))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h [])) (F (map g []))\n 2. \\<And>a lst P.\n       \\<lbrakk>\\<And>P.\n                   \\<lbrakk>\\<And>a r.\n                               a \\<in> set lst \\<Longrightarrow>\n                               P (h a \\<^bold>* r) (g a \\<^bold>* r);\n                    \\<And>x y z.\n                       \\<lbrakk>P x y; P y z\\<rbrakk>\n                       \\<Longrightarrow> P x z;\n                    P (F (map g lst)) (F (map g lst))\\<rbrakk>\n                   \\<Longrightarrow> P (F (map h lst)) (F (map g lst));\n        \\<And>aa r.\n           aa \\<in> set (a # lst) \\<Longrightarrow>\n           P (h aa \\<^bold>* r) (g aa \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g (a # lst))) (F (map g (a # lst)))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h (a # lst))) (F (map g (a # lst)))", "from Cons(3)[OF e2 e1]"], ["proof (chain)\npicking this:\n  P (h a \\<^bold>* F (map h as)) (g a \\<^bold>* F (map g as))", "show ?case"], ["proof (prove)\nusing this:\n  P (h a \\<^bold>* F (map h as)) (g a \\<^bold>* F (map g as))\n\ngoal (1 subgoal):\n 1. P (F (map h (a # as))) (F (map g (a # as)))", "by auto"], ["proof (state)\nthis:\n  P (F (map h (a # as))) (F (map g (a # as)))\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>a r.\n                   a \\<in> set [] \\<Longrightarrow>\n                   P (h a \\<^bold>* r) (g a \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g [])) (F (map g []))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h [])) (F (map g []))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>a r.\n                   a \\<in> set [] \\<Longrightarrow>\n                   P (h a \\<^bold>* r) (g a \\<^bold>* r);\n        \\<And>x y z. \\<lbrakk>P x y; P y z\\<rbrakk> \\<Longrightarrow> P x z;\n        P (F (map g [])) (F (map g []))\\<rbrakk>\n       \\<Longrightarrow> P (F (map h [])) (F (map g []))", "qed auto"], ["", "end"], ["", "lemma prod_induct_gen:\n  assumes \"\\<And> a r. f (h a * r :: 'a :: {comm_monoid_mult}) = f (g a * r)\"\n  shows \"f (\\<Prod>v\\<leftarrow>lst. h v) = f (\\<Prod>v\\<leftarrow>lst. g v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (prod_list (map h lst)) = f (prod_list (map g lst))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f (prod_list (map h lst)) = f (prod_list (map g lst))", "let \"?P x y\" = \"f x = f y\""], ["proof (state)\ngoal (1 subgoal):\n 1. f (prod_list (map h lst)) = f (prod_list (map g lst))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (prod_list (map h lst)) = f (prod_list (map g lst))", "using comm_monoid_mult_class.prod_list.induct_gen_abs[of _ ?P,OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y z.\n              \\<lbrakk>f x = f y; f y = f z\\<rbrakk>\n              \\<Longrightarrow> f x = f z;\n   f (\\<Prod>a\\<leftarrow>?lst. g (?a3 a)) =\n   f (\\<Prod>a\\<leftarrow>?lst. g (?a3 a))\\<rbrakk>\n  \\<Longrightarrow> f (\\<Prod>a\\<leftarrow>?lst. h (?a3 a)) =\n                    f (\\<Prod>a\\<leftarrow>?lst. g (?a3 a))\n\ngoal (1 subgoal):\n 1. f (prod_list (map h lst)) = f (prod_list (map g lst))", "by auto"], ["proof (state)\nthis:\n  f (prod_list (map h lst)) = f (prod_list (map g lst))\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation complex_of_int::\"int \\<Rightarrow> complex\" where\n  \"complex_of_int \\<equiv> of_int\""], ["", "definition l2norm_list :: \"int list \\<Rightarrow> int\" where\n  \"l2norm_list lst = \\<lfloor>sqrt (sum_list (map (\\<lambda> a. a * a) lst))\\<rfloor>\""], ["", "abbreviation l2norm :: \"int poly \\<Rightarrow> int\" where\n  \"l2norm p \\<equiv> l2norm_list (coeffs p)\""], ["", "abbreviation \"norm2 p \\<equiv> \\<Sum>a\\<leftarrow>coeffs p. (cmod a)\\<^sup>2\""], ["", "(* the square of the Euclidean/l2-norm *)"], ["", "abbreviation l2norm_complex where\n  \"l2norm_complex p \\<equiv> sqrt (norm2 p)\""], ["", "abbreviation height :: \"int poly \\<Rightarrow> int\" where\n  \"height p \\<equiv> max_list (map (nat \\<circ> abs) (coeffs p))\""], ["", "definition complex_roots_complex where\n  \"complex_roots_complex (p::complex poly) = (SOME as. smult (coeff p (degree p)) (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) = p \\<and> length as = degree p)\""], ["", "lemma complex_roots:\n  \"smult (lead_coeff p) (\\<Prod>a\\<leftarrow>complex_roots_complex p. [:- a, 1:]) = p\"\n  \"length (complex_roots_complex p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (lead_coeff p)\n     (\\<Prod>a\\<leftarrow>complex_roots_complex p. [:- a, 1:]) =\n    p &&&\n    length (complex_roots_complex p) = degree p", "using someI_ex[OF fundamental_theorem_algebra_factorized]"], ["proof (prove)\nusing this:\n  Polynomial.smult (lead_coeff ?p1)\n   (\\<Prod>a\\<leftarrow>(SOME x.\n                            Polynomial.smult (lead_coeff ?p1)\n                             (\\<Prod>a\\<leftarrow>x. [:- a, 1:]) =\n                            ?p1 \\<and>\n                            length x = degree ?p1). [:- a, 1:]) =\n  ?p1 \\<and>\n  length\n   (SOME x.\n       Polynomial.smult (lead_coeff ?p1)\n        (\\<Prod>a\\<leftarrow>x. [:- a, 1:]) =\n       ?p1 \\<and>\n       length x = degree ?p1) =\n  degree ?p1\n\ngoal (1 subgoal):\n 1. Polynomial.smult (lead_coeff p)\n     (\\<Prod>a\\<leftarrow>complex_roots_complex p. [:- a, 1:]) =\n    p &&&\n    length (complex_roots_complex p) = degree p", "unfolding complex_roots_complex_def"], ["proof (prove)\nusing this:\n  Polynomial.smult (lead_coeff ?p1)\n   (\\<Prod>a\\<leftarrow>(SOME x.\n                            Polynomial.smult (lead_coeff ?p1)\n                             (\\<Prod>a\\<leftarrow>x. [:- a, 1:]) =\n                            ?p1 \\<and>\n                            length x = degree ?p1). [:- a, 1:]) =\n  ?p1 \\<and>\n  length\n   (SOME x.\n       Polynomial.smult (lead_coeff ?p1)\n        (\\<Prod>a\\<leftarrow>x. [:- a, 1:]) =\n       ?p1 \\<and>\n       length x = degree ?p1) =\n  degree ?p1\n\ngoal (1 subgoal):\n 1. Polynomial.smult (lead_coeff p)\n     (\\<Prod>a\\<leftarrow>(SOME as.\n                              Polynomial.smult (lead_coeff p)\n                               (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) =\n                              p \\<and>\n                              length as = degree p). [:- a, 1:]) =\n    p &&&\n    length\n     (SOME as.\n         Polynomial.smult (lead_coeff p)\n          (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) =\n         p \\<and>\n         length as = degree p) =\n    degree p", "by simp_all"], ["", "lemma complex_roots_c [simp]:\n  \"complex_roots_complex [:c:] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_roots_complex [:c:] = []", "using complex_roots(2) [of \"[:c:]\"]"], ["proof (prove)\nusing this:\n  length (complex_roots_complex [:c:]) = degree [:c:]\n\ngoal (1 subgoal):\n 1. complex_roots_complex [:c:] = []", "by simp"], ["", "declare complex_roots(2)[simp]"], ["", "lemma complex_roots_1 [simp]:\n  \"complex_roots_complex 1 = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_roots_complex 1 = []", "using complex_roots_c [of 1]"], ["proof (prove)\nusing this:\n  complex_roots_complex [:1:] = []\n\ngoal (1 subgoal):\n 1. complex_roots_complex 1 = []", "by (simp add: pCons_one)"], ["", "lemma linear_term_irreducible\\<^sub>d[simp]: \"irreducible\\<^sub>d [: a, 1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d [:a, 1::'a:]", "by (rule linear_irreducible\\<^sub>d, simp)"], ["", "definition complex_roots_int where\n  \"complex_roots_int (p::int poly) = complex_roots_complex (map_poly of_int p)\""], ["", "lemma complex_roots_int:\n  \"smult (lead_coeff p) (\\<Prod>a\\<leftarrow>complex_roots_int p. [:- a, 1:]) = map_poly of_int p\"\n  \"length (complex_roots_int p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (complex_of_int (lead_coeff p))\n     (\\<Prod>a\\<leftarrow>complex_roots_int p. [:- a, 1:]) =\n    of_int_poly p &&&\n    length (complex_roots_int p) = degree p", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. Polynomial.smult (complex_of_int (lead_coeff p))\n     (\\<Prod>a\\<leftarrow>complex_roots_int p. [:- a, 1:]) =\n    of_int_poly p\n 2. length (complex_roots_int p) = degree p", "show \"smult (lead_coeff p) (\\<Prod>a\\<leftarrow>complex_roots_int p. [:- a, 1:]) = map_poly of_int p\"\n  \"length (complex_roots_int p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (complex_of_int (lead_coeff p))\n     (\\<Prod>a\\<leftarrow>complex_roots_int p. [:- a, 1:]) =\n    of_int_poly p &&&\n    length (complex_roots_int p) = degree p", "using complex_roots[of \"map_poly of_int p\"]"], ["proof (prove)\nusing this:\n  Polynomial.smult (lead_coeff (of_int_poly p))\n   (\\<Prod>a\\<leftarrow>complex_roots_complex (of_int_poly p). [:- a, 1:]) =\n  of_int_poly p\n  length (complex_roots_complex (of_int_poly p)) = degree (of_int_poly p)\n\ngoal (1 subgoal):\n 1. Polynomial.smult (complex_of_int (lead_coeff p))\n     (\\<Prod>a\\<leftarrow>complex_roots_int p. [:- a, 1:]) =\n    of_int_poly p &&&\n    length (complex_roots_int p) = degree p", "unfolding complex_roots_int_def"], ["proof (prove)\nusing this:\n  Polynomial.smult (lead_coeff (of_int_poly p))\n   (\\<Prod>a\\<leftarrow>complex_roots_complex (of_int_poly p). [:- a, 1:]) =\n  of_int_poly p\n  length (complex_roots_complex (of_int_poly p)) = degree (of_int_poly p)\n\ngoal (1 subgoal):\n 1. Polynomial.smult (complex_of_int (lead_coeff p))\n     (\\<Prod>a\\<leftarrow>complex_roots_complex\n                           (of_int_poly p). [:- a, 1:]) =\n    of_int_poly p &&&\n    length (complex_roots_complex (of_int_poly p)) = degree p", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult (complex_of_int (lead_coeff p))\n   (\\<Prod>a\\<leftarrow>complex_roots_int p. [:- a, 1:]) =\n  of_int_poly p\n  length (complex_roots_int p) = degree p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The measure for polynomials, after K. Mahler\\<close>"], ["", "definition mahler_measure_poly where\n  \"mahler_measure_poly p = cmod (lead_coeff p) * (\\<Prod>a\\<leftarrow>complex_roots_complex p. (max 1 (cmod a)))\""], ["", "definition mahler_measure where\n  \"mahler_measure p = mahler_measure_poly (map_poly complex_of_int p)\""], ["", "definition mahler_measure_monic where\n  \"mahler_measure_monic p = (\\<Prod>a\\<leftarrow>complex_roots_complex p. (max 1 (cmod a)))\""], ["", "lemma mahler_measure_poly_via_monic :\n  \"mahler_measure_poly p = cmod (lead_coeff p) * mahler_measure_monic p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly p = cmod (lead_coeff p) * mahler_measure_monic p", "unfolding mahler_measure_poly_def mahler_measure_monic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (lead_coeff p) *\n    (\\<Prod>a\\<leftarrow>complex_roots_complex p. max 1 (cmod a)) =\n    cmod (lead_coeff p) *\n    (\\<Prod>a\\<leftarrow>complex_roots_complex p. max 1 (cmod a))", "by simp"], ["", "lemma smult_inj[simp]: assumes \"(a::'a::idom) \\<noteq> 0\" shows \"inj (smult a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (Polynomial.smult a)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. inj (Polynomial.smult a)", "interpret map_poly_inj_zero_hom \"(*) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_zero_hom ((*) a)", "using assms"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. map_poly_inj_zero_hom ((*) a)", "by (unfold_locales, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. inj (Polynomial.smult a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (Polynomial.smult a)", "unfolding smult_as_map_poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (map_poly ((*) a))", "by (rule inj_f)"], ["proof (state)\nthis:\n  inj (Polynomial.smult a)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition reconstruct_poly::\"'a::idom \\<Rightarrow> 'a list \\<Rightarrow> 'a poly\" where\n  \"reconstruct_poly c roots = smult c (\\<Prod>a\\<leftarrow>roots. [:- a, 1:])\""], ["", "lemma reconstruct_is_original_poly:\n  \"reconstruct_poly (lead_coeff p) (complex_roots_complex p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reconstruct_poly (lead_coeff p) (complex_roots_complex p) = p", "using complex_roots(1)"], ["proof (prove)\nusing this:\n  Polynomial.smult (lead_coeff ?p)\n   (\\<Prod>a\\<leftarrow>complex_roots_complex ?p. [:- a, 1:]) =\n  ?p\n\ngoal (1 subgoal):\n 1. reconstruct_poly (lead_coeff p) (complex_roots_complex p) = p", "by (simp add: reconstruct_poly_def)"], ["", "lemma reconstruct_with_type_conversion:\n  \"smult (lead_coeff (map_poly of_int f)) (prod_list (map (\\<lambda> a. [:- a, 1:]) (complex_roots_int f)))\n   = map_poly of_int f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (lead_coeff (of_int_poly f))\n     (\\<Prod>a\\<leftarrow>complex_roots_int f. [:- a, 1:]) =\n    of_int_poly f", "unfolding complex_roots_int_def complex_roots(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly f = of_int_poly f", "by simp"], ["", "lemma reconstruct_prod:\n  shows \"reconstruct_poly (a::complex) as * reconstruct_poly b bs\n        = reconstruct_poly (a * b) (as @ bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reconstruct_poly a as * reconstruct_poly b bs =\n    reconstruct_poly (a * b) (as @ bs)", "unfolding reconstruct_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult a (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) *\n    Polynomial.smult b (\\<Prod>a\\<leftarrow>bs. [:- a, 1:]) =\n    Polynomial.smult (a * b) (\\<Prod>a\\<leftarrow>as @ bs. [:- a, 1:])", "by auto"], ["", "lemma linear_term_inj[simplified,simp]: \"inj (\\<lambda> a. [:- a, 1::'a::idom:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>a. [:- a, 1::'a:])", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          [:- x, 1::'a:] = [:- y, 1::'a:] \\<longrightarrow> x = y", "by simp"], ["", "lemma reconstruct_poly_monic_defines_mset:\n  assumes \"(\\<Prod>a\\<leftarrow>as. [:- a, 1:]) = (\\<Prod>a\\<leftarrow>bs. [:- a, 1::'a::field:])\"\n  shows \"mset as = mset bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset as = mset bs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mset as = mset bs", "let ?as = \"mset (map (\\<lambda> a. [:- a, 1:]) as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. mset as = mset bs", "let ?bs = \"mset (map (\\<lambda> a. [:- a, 1:]) bs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. mset as = mset bs", "have eq_smult:\"prod_mset ?as = prod_mset ?bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (mset (map (\\<lambda>a. [:- a, 1::'a:]) as)) =\n    \\<Prod>\\<^sub># (mset (map (\\<lambda>a. [:- a, 1::'a:]) bs))", "using assms"], ["proof (prove)\nusing this:\n  (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) =\n  (\\<Prod>a\\<leftarrow>bs. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (mset (map (\\<lambda>a. [:- a, 1::'a:]) as)) =\n    \\<Prod>\\<^sub># (mset (map (\\<lambda>a. [:- a, 1::'a:]) bs))", "by (metis prod_mset_prod_list)"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># (mset (map (\\<lambda>a. [:- a, 1::'a:]) as)) =\n  \\<Prod>\\<^sub># (mset (map (\\<lambda>a. [:- a, 1::'a:]) bs))\n\ngoal (1 subgoal):\n 1. mset as = mset bs", "have irr:\"\\<And> as::'a list. set_mset (mset (map (\\<lambda> a. [:- a, 1:]) as)) \\<subseteq> {q. irreducible q \\<and> monic q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as.\n       set_mset (mset (map (\\<lambda>a. [:- a, 1::'a:]) as))\n       \\<subseteq> {q. irreducible q \\<and> monic q}", "by (auto intro!: linear_term_irreducible\\<^sub>d[of \"-_::'a\", simplified])"], ["proof (state)\nthis:\n  set_mset (mset (map (\\<lambda>a. [:- a, 1::'a:]) ?as))\n  \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. mset as = mset bs", "from monic_factorization_unique_mset[OF eq_smult irr irr]"], ["proof (chain)\npicking this:\n  mset (map (\\<lambda>a. [:- a, 1::'a:]) as) =\n  mset (map (\\<lambda>a. [:- a, 1::'a:]) bs)", "show ?thesis"], ["proof (prove)\nusing this:\n  mset (map (\\<lambda>a. [:- a, 1::'a:]) as) =\n  mset (map (\\<lambda>a. [:- a, 1::'a:]) bs)\n\ngoal (1 subgoal):\n 1. mset as = mset bs", "apply (subst inj_eq[OF multiset.inj_map,symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. mset (map (\\<lambda>a. [:- a, 1::'a:]) as) =\n    mset (map (\\<lambda>a. [:- a, 1::'a:]) bs) \\<Longrightarrow>\n    inj ?f4\n 2. mset (map (\\<lambda>a. [:- a, 1::'a:]) as) =\n    mset (map (\\<lambda>a. [:- a, 1::'a:]) bs) \\<Longrightarrow>\n    image_mset ?f4 (mset as) = image_mset ?f4 (mset bs)", "by auto"], ["proof (state)\nthis:\n  mset as = mset bs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reconstruct_poly_defines_mset_of_argument:\n  assumes \"(a::'a::field) \\<noteq> 0\"\n          \"reconstruct_poly a as = reconstruct_poly a bs\"\n  shows \"mset as = mset bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset as = mset bs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mset as = mset bs", "have eq_smult:\"smult a (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) = smult a (\\<Prod>a\\<leftarrow>bs. [:- a, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult a (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) =\n    Polynomial.smult a (\\<Prod>a\\<leftarrow>bs. [:- a, 1::'a:])", "using assms(2)"], ["proof (prove)\nusing this:\n  reconstruct_poly a as = reconstruct_poly a bs\n\ngoal (1 subgoal):\n 1. Polynomial.smult a (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) =\n    Polynomial.smult a (\\<Prod>a\\<leftarrow>bs. [:- a, 1::'a:])", "by (auto simp:reconstruct_poly_def)"], ["proof (state)\nthis:\n  Polynomial.smult a (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) =\n  Polynomial.smult a (\\<Prod>a\\<leftarrow>bs. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. mset as = mset bs", "from reconstruct_poly_monic_defines_mset[OF Fun.injD[OF smult_inj[OF assms(1)] eq_smult]]"], ["proof (chain)\npicking this:\n  mset as = mset bs", "show ?thesis"], ["proof (prove)\nusing this:\n  mset as = mset bs\n\ngoal (1 subgoal):\n 1. mset as = mset bs", "by simp"], ["proof (state)\nthis:\n  mset as = mset bs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complex_roots_complex_prod [simp]:\n  assumes \"f \\<noteq> 0\" \"g \\<noteq> 0\"\n  shows  \"mset (complex_roots_complex (f * g))\n        = mset (complex_roots_complex f) + mset (complex_roots_complex g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (complex_roots_complex (f * g)) =\n    mset (complex_roots_complex f) + mset (complex_roots_complex g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mset (complex_roots_complex (f * g)) =\n    mset (complex_roots_complex f) + mset (complex_roots_complex g)", "let ?p = \"f * g\""], ["proof (state)\ngoal (1 subgoal):\n 1. mset (complex_roots_complex (f * g)) =\n    mset (complex_roots_complex f) + mset (complex_roots_complex g)", "let \"?lc v\" = \"(lead_coeff (v:: complex poly))\""], ["proof (state)\ngoal (1 subgoal):\n 1. mset (complex_roots_complex (f * g)) =\n    mset (complex_roots_complex f) + mset (complex_roots_complex g)", "have nonzero_prod:\"?lc ?p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (f * g) \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff (f * g) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lead_coeff (f * g) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. mset (complex_roots_complex (f * g)) =\n    mset (complex_roots_complex f) + mset (complex_roots_complex g)", "from reconstruct_prod[of \"?lc f\" \"complex_roots_complex f\" \"?lc g\" \"complex_roots_complex g\"]"], ["proof (chain)\npicking this:\n  reconstruct_poly (lead_coeff f) (complex_roots_complex f) *\n  reconstruct_poly (lead_coeff g) (complex_roots_complex g) =\n  reconstruct_poly (lead_coeff f * lead_coeff g)\n   (complex_roots_complex f @ complex_roots_complex g)", "have \"reconstruct_poly (?lc ?p) (complex_roots_complex ?p)\n       = reconstruct_poly (?lc ?p) (complex_roots_complex f @ complex_roots_complex g)\""], ["proof (prove)\nusing this:\n  reconstruct_poly (lead_coeff f) (complex_roots_complex f) *\n  reconstruct_poly (lead_coeff g) (complex_roots_complex g) =\n  reconstruct_poly (lead_coeff f * lead_coeff g)\n   (complex_roots_complex f @ complex_roots_complex g)\n\ngoal (1 subgoal):\n 1. reconstruct_poly (lead_coeff (f * g)) (complex_roots_complex (f * g)) =\n    reconstruct_poly (lead_coeff (f * g))\n     (complex_roots_complex f @ complex_roots_complex g)", "unfolding lead_coeff_mult[symmetric] reconstruct_is_original_poly"], ["proof (prove)\nusing this:\n  f * g =\n  reconstruct_poly (lead_coeff (f * g))\n   (complex_roots_complex f @ complex_roots_complex g)\n\ngoal (1 subgoal):\n 1. f * g =\n    reconstruct_poly (lead_coeff (f * g))\n     (complex_roots_complex f @ complex_roots_complex g)", "by auto"], ["proof (state)\nthis:\n  reconstruct_poly (lead_coeff (f * g)) (complex_roots_complex (f * g)) =\n  reconstruct_poly (lead_coeff (f * g))\n   (complex_roots_complex f @ complex_roots_complex g)\n\ngoal (1 subgoal):\n 1. mset (complex_roots_complex (f * g)) =\n    mset (complex_roots_complex f) + mset (complex_roots_complex g)", "from reconstruct_poly_defines_mset_of_argument[OF nonzero_prod this]"], ["proof (chain)\npicking this:\n  mset (complex_roots_complex (f * g)) =\n  mset (complex_roots_complex f @ complex_roots_complex g)", "show ?thesis"], ["proof (prove)\nusing this:\n  mset (complex_roots_complex (f * g)) =\n  mset (complex_roots_complex f @ complex_roots_complex g)\n\ngoal (1 subgoal):\n 1. mset (complex_roots_complex (f * g)) =\n    mset (complex_roots_complex f) + mset (complex_roots_complex g)", "by simp"], ["proof (state)\nthis:\n  mset (complex_roots_complex (f * g)) =\n  mset (complex_roots_complex f) + mset (complex_roots_complex g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_mult_add:\n  assumes \"mset (a::'a::field list) = mset b + mset c\"\n  shows \"prod_list a = prod_list b * prod_list c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list a = prod_list b * prod_list c", "unfolding prod_mset_prod_list[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (mset a) =\n    \\<Prod>\\<^sub># (mset b) * \\<Prod>\\<^sub># (mset c)", "using prod_mset_Un[of \"mset b\" \"mset c\",unfolded assms[symmetric]]"], ["proof (prove)\nusing this:\n  \\<Prod>\\<^sub># (mset a) =\n  \\<Prod>\\<^sub># (mset b) * \\<Prod>\\<^sub># (mset c)\n\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (mset a) =\n    \\<Prod>\\<^sub># (mset b) * \\<Prod>\\<^sub># (mset c)", "."], ["", "lemma mset_mult_add_2:\n  assumes \"mset a = mset b + mset c\"\n  shows \"prod_list (map i a::'b::field list) = prod_list (map i b) * prod_list (map i c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map i a) = prod_list (map i b) * prod_list (map i c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod_list (map i a) = prod_list (map i b) * prod_list (map i c)", "have r:\"mset (map i a) = mset (map i b) + mset (map i c) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (map i a) = mset (map i b) + mset (map i c)", "using assms"], ["proof (prove)\nusing this:\n  mset a = mset b + mset c\n\ngoal (1 subgoal):\n 1. mset (map i a) = mset (map i b) + mset (map i c)", "by (metis map_append mset_append mset_map)"], ["proof (state)\nthis:\n  mset (map i a) = mset (map i b) + mset (map i c)\n\ngoal (1 subgoal):\n 1. prod_list (map i a) = prod_list (map i b) * prod_list (map i c)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map i a) = prod_list (map i b) * prod_list (map i c)", "using mset_mult_add[OF r]"], ["proof (prove)\nusing this:\n  prod_list (map i a) = prod_list (map i b) * prod_list (map i c)\n\ngoal (1 subgoal):\n 1. prod_list (map i a) = prod_list (map i b) * prod_list (map i c)", "by auto"], ["proof (state)\nthis:\n  prod_list (map i a) = prod_list (map i b) * prod_list (map i c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma measure_mono_eq_prod:\n  assumes \"f \\<noteq> 0\" \"g \\<noteq> 0\"\n  shows \"mahler_measure_monic (f * g) = mahler_measure_monic f * mahler_measure_monic g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_monic (f * g) =\n    mahler_measure_monic f * mahler_measure_monic g", "unfolding mahler_measure_monic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>complex_roots_complex (f * g). max 1 (cmod a)) =\n    (\\<Prod>a\\<leftarrow>complex_roots_complex f. max 1 (cmod a)) *\n    (\\<Prod>a\\<leftarrow>complex_roots_complex g. max 1 (cmod a))", "using mset_mult_add_2[OF complex_roots_complex_prod[OF assms],of \"\\<lambda> a. max 1 (cmod a)\"]"], ["proof (prove)\nusing this:\n  (\\<Prod>a\\<leftarrow>complex_roots_complex (f * g). max 1 (cmod a)) =\n  (\\<Prod>a\\<leftarrow>complex_roots_complex f. max 1 (cmod a)) *\n  (\\<Prod>a\\<leftarrow>complex_roots_complex g. max 1 (cmod a))\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>complex_roots_complex (f * g). max 1 (cmod a)) =\n    (\\<Prod>a\\<leftarrow>complex_roots_complex f. max 1 (cmod a)) *\n    (\\<Prod>a\\<leftarrow>complex_roots_complex g. max 1 (cmod a))", "by simp"], ["", "lemma mahler_measure_poly_0[simp]: \"mahler_measure_poly 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly 0 = 0", "unfolding mahler_measure_poly_via_monic"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (lead_coeff 0) * mahler_measure_monic 0 = 0", "by auto"], ["", "lemma measure_eq_prod: (* Remark 10.2 *)\n  \"mahler_measure_poly (f * g) = mahler_measure_poly f * mahler_measure_poly g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly (f * g) =\n    mahler_measure_poly f * mahler_measure_poly g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure_poly (f * g) =\n    mahler_measure_poly f * mahler_measure_poly g", "consider \"f = 0\" | \"g = 0\" | (both) \"f \\<noteq> 0\" \"g \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f = 0 \\<Longrightarrow> thesis; g = 0 \\<Longrightarrow> thesis;\n     \\<lbrakk>f \\<noteq> 0; g \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>f = 0 \\<Longrightarrow> ?thesis; g = 0 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>f \\<noteq> 0; g \\<noteq> 0\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. mahler_measure_poly (f * g) =\n    mahler_measure_poly f * mahler_measure_poly g", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>f = 0 \\<Longrightarrow> ?thesis; g = 0 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>f \\<noteq> 0; g \\<noteq> 0\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. mahler_measure_poly (f * g) =\n    mahler_measure_poly f * mahler_measure_poly g", "proof(cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. f = 0 \\<Longrightarrow>\n    mahler_measure_poly (f * g) =\n    mahler_measure_poly f * mahler_measure_poly g\n 2. g = 0 \\<Longrightarrow>\n    mahler_measure_poly (f * g) =\n    mahler_measure_poly f * mahler_measure_poly g\n 3. \\<lbrakk>f \\<noteq> 0; g \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> mahler_measure_poly (f * g) =\n                      mahler_measure_poly f * mahler_measure_poly g", "case both"], ["proof (state)\nthis:\n  f \\<noteq> 0\n  g \\<noteq> 0\n\ngoal (3 subgoals):\n 1. f = 0 \\<Longrightarrow>\n    mahler_measure_poly (f * g) =\n    mahler_measure_poly f * mahler_measure_poly g\n 2. g = 0 \\<Longrightarrow>\n    mahler_measure_poly (f * g) =\n    mahler_measure_poly f * mahler_measure_poly g\n 3. \\<lbrakk>f \\<noteq> 0; g \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> mahler_measure_poly (f * g) =\n                      mahler_measure_poly f * mahler_measure_poly g", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly (f * g) =\n    mahler_measure_poly f * mahler_measure_poly g", "unfolding mahler_measure_poly_via_monic norm_mult lead_coeff_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (lead_coeff f) * cmod (lead_coeff g) *\n    mahler_measure_monic (f * g) =\n    cmod (lead_coeff f) * mahler_measure_monic f *\n    (cmod (lead_coeff g) * mahler_measure_monic g)", "by (auto simp: measure_mono_eq_prod[OF both])"], ["proof (state)\nthis:\n  mahler_measure_poly (f * g) =\n  mahler_measure_poly f * mahler_measure_poly g\n\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow>\n    mahler_measure_poly (f * g) =\n    mahler_measure_poly f * mahler_measure_poly g\n 2. g = 0 \\<Longrightarrow>\n    mahler_measure_poly (f * g) =\n    mahler_measure_poly f * mahler_measure_poly g", "qed (simp_all)"], ["proof (state)\nthis:\n  mahler_measure_poly (f * g) =\n  mahler_measure_poly f * mahler_measure_poly g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_cmod[simp]:\n  \"cmod (\\<Prod>a\\<leftarrow>lst. f a) = (\\<Prod>a\\<leftarrow>lst. cmod (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (prod_list (map f lst)) = (\\<Prod>a\\<leftarrow>lst. cmod (f a))", "by(induct lst,auto simp:real_normed_div_algebra_class.norm_mult)"], ["", "lemma lead_coeff_of_prod[simp]:\n  \"lead_coeff (\\<Prod>a\\<leftarrow>lst. f a::'a::idom poly) = (\\<Prod>a\\<leftarrow>lst. lead_coeff (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (prod_list (map f lst)) =\n    (\\<Prod>a\\<leftarrow>lst. lead_coeff (f a))", "by(induct lst,auto simp:lead_coeff_mult)"], ["", "lemma ineq_about_squares:assumes \"x \\<le> (y::real)\" shows \"x \\<le> c^2 + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> c\\<^sup>2 + y", "using assms"], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> c\\<^sup>2 + y", "by (simp add: add.commute add_increasing2)"], ["", "lemma first_coeff_le_tail:\"(cmod (lead_coeff g))^2 \\<le> (\\<Sum>a\\<leftarrow>coeffs g. (cmod a)^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod (lead_coeff g))\\<^sup>2 \\<le> norm2 g", "proof(induct g)"], ["proof (state)\ngoal (2 subgoals):\n 1. (cmod (lead_coeff 0))\\<^sup>2 \\<le> norm2 0\n 2. \\<And>a g.\n       \\<lbrakk>a \\<noteq> 0 \\<or> g \\<noteq> 0;\n        (cmod (lead_coeff g))\\<^sup>2 \\<le> norm2 g\\<rbrakk>\n       \\<Longrightarrow> (cmod (lead_coeff (pCons a g)))\\<^sup>2\n                         \\<le> norm2 (pCons a g)", "case (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> 0 \\<or> p \\<noteq> 0\n  (cmod (lead_coeff p))\\<^sup>2 \\<le> norm2 p\n\ngoal (2 subgoals):\n 1. (cmod (lead_coeff 0))\\<^sup>2 \\<le> norm2 0\n 2. \\<And>a g.\n       \\<lbrakk>a \\<noteq> 0 \\<or> g \\<noteq> 0;\n        (cmod (lead_coeff g))\\<^sup>2 \\<le> norm2 g\\<rbrakk>\n       \\<Longrightarrow> (cmod (lead_coeff (pCons a g)))\\<^sup>2\n                         \\<le> norm2 (pCons a g)", "thus ?case"], ["proof (prove)\nusing this:\n  a \\<noteq> 0 \\<or> p \\<noteq> 0\n  (cmod (lead_coeff p))\\<^sup>2 \\<le> norm2 p\n\ngoal (1 subgoal):\n 1. (cmod (lead_coeff (pCons a p)))\\<^sup>2 \\<le> norm2 (pCons a p)", "proof(cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n     (cmod (lead_coeff p))\\<^sup>2 \\<le> norm2 p; p = 0\\<rbrakk>\n    \\<Longrightarrow> (cmod (lead_coeff (pCons a p)))\\<^sup>2\n                      \\<le> norm2 (pCons a p)\n 2. \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n     (cmod (lead_coeff p))\\<^sup>2 \\<le> norm2 p; p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (cmod (lead_coeff (pCons a p)))\\<^sup>2\n                      \\<le> norm2 (pCons a p)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n     (cmod (lead_coeff p))\\<^sup>2 \\<le> norm2 p; p = 0\\<rbrakk>\n    \\<Longrightarrow> (cmod (lead_coeff (pCons a p)))\\<^sup>2\n                      \\<le> norm2 (pCons a p)\n 2. \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n     (cmod (lead_coeff p))\\<^sup>2 \\<le> norm2 p; p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (cmod (lead_coeff (pCons a p)))\\<^sup>2\n                      \\<le> norm2 (pCons a p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod (lead_coeff (pCons a p)))\\<^sup>2 \\<le> norm2 (pCons a p)", "using pCons"], ["proof (prove)\nusing this:\n  a \\<noteq> 0 \\<or> p \\<noteq> 0\n  (cmod (lead_coeff p))\\<^sup>2 \\<le> norm2 p\n\ngoal (1 subgoal):\n 1. (cmod (lead_coeff (pCons a p)))\\<^sup>2 \\<le> norm2 (pCons a p)", "unfolding lead_coeff_pCons(1)[OF False]"], ["proof (prove)\nusing this:\n  a \\<noteq> 0 \\<or> p \\<noteq> 0\n  (cmod (lead_coeff p))\\<^sup>2 \\<le> norm2 p\n\ngoal (1 subgoal):\n 1. (cmod (lead_coeff p))\\<^sup>2 \\<le> norm2 (pCons a p)", "by(cases \"a = 0\",simp_all add:ineq_about_squares)"], ["proof (state)\nthis:\n  (cmod (lead_coeff (pCons a p)))\\<^sup>2 \\<le> norm2 (pCons a p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n     (cmod (lead_coeff p))\\<^sup>2 \\<le> norm2 p; p = 0\\<rbrakk>\n    \\<Longrightarrow> (cmod (lead_coeff (pCons a p)))\\<^sup>2\n                      \\<le> norm2 (pCons a p)", "qed simp"], ["proof (state)\nthis:\n  (cmod (lead_coeff (pCons a p)))\\<^sup>2 \\<le> norm2 (pCons a p)\n\ngoal (1 subgoal):\n 1. (cmod (lead_coeff 0))\\<^sup>2 \\<le> norm2 0", "qed simp"], ["", "lemma square_prod_cmod[simp]:\n  \"(cmod (a * b))^2 = cmod a ^ 2 * cmod b ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod (a * b))\\<^sup>2 = (cmod a)\\<^sup>2 * (cmod b)\\<^sup>2", "by (simp add: norm_mult power_mult_distrib)"], ["", "lemma sum_coeffs_smult_cmod:\n  \"(\\<Sum>a\\<leftarrow>coeffs (smult v p). (cmod a)^2) = (cmod v)^2 * (\\<Sum>a\\<leftarrow>coeffs p. (cmod a)^2)\" \n  (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm2 (Polynomial.smult v p) = (cmod v)\\<^sup>2 * norm2 p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm2 (Polynomial.smult v p) = (cmod v)\\<^sup>2 * norm2 p", "have \"?l = (\\<Sum>a\\<leftarrow>coeffs p. (cmod v)^2 * (cmod a)^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm2 (Polynomial.smult v p) =\n    (\\<Sum>a\\<leftarrow>coeffs p. (cmod v)\\<^sup>2 * (cmod a)\\<^sup>2)", "by(cases \"v=0\";induct p,auto)"], ["proof (state)\nthis:\n  norm2 (Polynomial.smult v p) =\n  (\\<Sum>a\\<leftarrow>coeffs p. (cmod v)\\<^sup>2 * (cmod a)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. norm2 (Polynomial.smult v p) = (cmod v)\\<^sup>2 * norm2 p", "thus ?thesis"], ["proof (prove)\nusing this:\n  norm2 (Polynomial.smult v p) =\n  (\\<Sum>a\\<leftarrow>coeffs p. (cmod v)\\<^sup>2 * (cmod a)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. norm2 (Polynomial.smult v p) = (cmod v)\\<^sup>2 * norm2 p", "by (auto simp:sum_list_const_mult)"], ["proof (state)\nthis:\n  norm2 (Polynomial.smult v p) = (cmod v)\\<^sup>2 * norm2 p\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"linH a \\<equiv> if (cmod a > 1) then [:- 1,cnj a:] else [:- a,1:]\""], ["", "lemma coeffs_cong_1[simp]: \"cCons a v = cCons b v \\<longleftrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cCons a v = cCons b v) = (a = b)", "unfolding cCons_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if v = [] \\<and> a = (0::'a) then [] else a # v) =\n     (if v = [] \\<and> b = (0::'a) then [] else b # v)) =\n    (a = b)", "by auto"], ["", "lemma strip_while_singleton[simp]:\n  \"strip_while ((=) 0) [v * a] = cCons (v * a) []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_while ((=) (0::'a)) [v * a] = cCons (v * a) []", "unfolding cCons_def strip_while_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rev \\<circ> dropWhile ((=) (0::'a)) \\<circ> rev) [v * a] =\n    (if [] = [] \\<and> v * a = (0::'a) then [] else [v * a])", "by auto"], ["", "lemma coeffs_times_linterm:\n  shows \"coeffs (pCons 0 (smult a p) + smult b p) = strip_while (HOL.eq (0::'a::{comm_ring_1}))\n     (map (\\<lambda>(c,d).b*d+c*a) (zip (0 # coeffs p) (coeffs p @ [0])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeffs (pCons (0::'a) (Polynomial.smult a p) + Polynomial.smult b p) =\n    strip_while ((=) (0::'a))\n     (map2 (\\<lambda>c d. b * d + c * a) ((0::'a) # coeffs p)\n       (coeffs p @ [0::'a]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coeffs (pCons (0::'a) (Polynomial.smult a p) + Polynomial.smult b p) =\n    strip_while ((=) (0::'a))\n     (map2 (\\<lambda>c d. b * d + c * a) ((0::'a) # coeffs p)\n       (coeffs p @ [0::'a]))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. coeffs (pCons (0::'a) (Polynomial.smult a p) + Polynomial.smult b p) =\n    strip_while ((=) (0::'a))\n     (map2 (\\<lambda>c d. b * d + c * a) ((0::'a) # coeffs p)\n       (coeffs p @ [0::'a]))", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. coeffs (pCons (0::'a) (Polynomial.smult a p) + Polynomial.smult b p) =\n    strip_while ((=) (0::'a))\n     (map2 (\\<lambda>c d. b * d + c * a) ((0::'a) # coeffs p)\n       (coeffs p @ [0::'a]))", "have \"coeffs (smult b p + pCons (a* v) (smult a p)) = strip_while (HOL.eq 0) (map (\\<lambda>(c,d).b*d+c*a) (zip ([v] @ coeffs p) (coeffs p @ [0])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeffs (Polynomial.smult b p + pCons (a * v) (Polynomial.smult a p)) =\n    strip_while ((=) (0::'a))\n     (map2 (\\<lambda>c d. b * d + c * a) ([v] @ coeffs p)\n       (coeffs p @ [0::'a]))", "proof(induct p arbitrary:v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       coeffs\n        (Polynomial.smult b 0 + pCons (a * v) (Polynomial.smult a 0)) =\n       strip_while ((=) (0::'a))\n        (map2 (\\<lambda>c d. b * d + c * a) ([v] @ coeffs 0)\n          (coeffs 0 @ [0::'a]))\n 2. \\<And>aa p v.\n       \\<lbrakk>aa \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        \\<And>v.\n           coeffs\n            (Polynomial.smult b p + pCons (a * v) (Polynomial.smult a p)) =\n           strip_while ((=) (0::'a))\n            (map2 (\\<lambda>c d. b * d + c * a) ([v] @ coeffs p)\n              (coeffs p @ [0::'a]))\\<rbrakk>\n       \\<Longrightarrow> coeffs\n                          (Polynomial.smult b (pCons aa p) +\n                           pCons (a * v)\n                            (Polynomial.smult a (pCons aa p))) =\n                         strip_while ((=) (0::'a))\n                          (map2 (\\<lambda>c d. b * d + c * a)\n                            ([v] @ coeffs (pCons aa p))\n                            (coeffs (pCons aa p) @ [0::'a]))", "case (pCons pa ps)"], ["proof (state)\nthis:\n  pa \\<noteq> (0::'a) \\<or> ps \\<noteq> 0\n  coeffs (Polynomial.smult b ps + pCons (a * ?v) (Polynomial.smult a ps)) =\n  strip_while ((=) (0::'a))\n   (map2 (\\<lambda>c d. b * d + c * a) ([?v] @ coeffs ps)\n     (coeffs ps @ [0::'a]))\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       coeffs\n        (Polynomial.smult b 0 + pCons (a * v) (Polynomial.smult a 0)) =\n       strip_while ((=) (0::'a))\n        (map2 (\\<lambda>c d. b * d + c * a) ([v] @ coeffs 0)\n          (coeffs 0 @ [0::'a]))\n 2. \\<And>aa p v.\n       \\<lbrakk>aa \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        \\<And>v.\n           coeffs\n            (Polynomial.smult b p + pCons (a * v) (Polynomial.smult a p)) =\n           strip_while ((=) (0::'a))\n            (map2 (\\<lambda>c d. b * d + c * a) ([v] @ coeffs p)\n              (coeffs p @ [0::'a]))\\<rbrakk>\n       \\<Longrightarrow> coeffs\n                          (Polynomial.smult b (pCons aa p) +\n                           pCons (a * v)\n                            (Polynomial.smult a (pCons aa p))) =\n                         strip_while ((=) (0::'a))\n                          (map2 (\\<lambda>c d. b * d + c * a)\n                            ([v] @ coeffs (pCons aa p))\n                            (coeffs (pCons aa p) @ [0::'a]))", "thus ?case"], ["proof (prove)\nusing this:\n  pa \\<noteq> (0::'a) \\<or> ps \\<noteq> 0\n  coeffs (Polynomial.smult b ps + pCons (a * ?v) (Polynomial.smult a ps)) =\n  strip_while ((=) (0::'a))\n   (map2 (\\<lambda>c d. b * d + c * a) ([?v] @ coeffs ps)\n     (coeffs ps @ [0::'a]))\n\ngoal (1 subgoal):\n 1. coeffs\n     (Polynomial.smult b (pCons pa ps) +\n      pCons (a * v) (Polynomial.smult a (pCons pa ps))) =\n    strip_while ((=) (0::'a))\n     (map2 (\\<lambda>c d. b * d + c * a) ([v] @ coeffs (pCons pa ps))\n       (coeffs (pCons pa ps) @ [0::'a]))", "by auto"], ["proof (state)\nthis:\n  coeffs\n   (Polynomial.smult b (pCons pa ps) +\n    pCons (a * v) (Polynomial.smult a (pCons pa ps))) =\n  strip_while ((=) (0::'a))\n   (map2 (\\<lambda>c d. b * d + c * a) ([v] @ coeffs (pCons pa ps))\n     (coeffs (pCons pa ps) @ [0::'a]))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       coeffs\n        (Polynomial.smult b 0 + pCons (a * v) (Polynomial.smult a 0)) =\n       strip_while ((=) (0::'a))\n        (map2 (\\<lambda>c d. b * d + c * a) ([v] @ coeffs 0)\n          (coeffs 0 @ [0::'a]))", "qed auto"], ["proof (state)\nthis:\n  coeffs (Polynomial.smult b p + pCons (a * v) (Polynomial.smult a p)) =\n  strip_while ((=) (0::'a))\n   (map2 (\\<lambda>c d. b * d + c * a) ([v] @ coeffs p)\n     (coeffs p @ [0::'a]))\n\ngoal (1 subgoal):\n 1. coeffs (pCons (0::'a) (Polynomial.smult a p) + Polynomial.smult b p) =\n    strip_while ((=) (0::'a))\n     (map2 (\\<lambda>c d. b * d + c * a) ((0::'a) # coeffs p)\n       (coeffs p @ [0::'a]))", "(* just putting ;auto does not work *)"], ["proof (state)\nthis:\n  coeffs (Polynomial.smult b p + pCons (a * v) (Polynomial.smult a p)) =\n  strip_while ((=) (0::'a))\n   (map2 (\\<lambda>c d. b * d + c * a) ([v] @ coeffs p)\n     (coeffs p @ [0::'a]))\n\ngoal (1 subgoal):\n 1. coeffs (pCons (0::'a) (Polynomial.smult a p) + Polynomial.smult b p) =\n    strip_while ((=) (0::'a))\n     (map2 (\\<lambda>c d. b * d + c * a) ((0::'a) # coeffs p)\n       (coeffs p @ [0::'a]))", "}"], ["proof (state)\nthis:\n  coeffs (Polynomial.smult b p + pCons (a * ?v2) (Polynomial.smult a p)) =\n  strip_while ((=) (0::'a))\n   (map2 (\\<lambda>c d. b * d + c * a) ([?v2] @ coeffs p)\n     (coeffs p @ [0::'a]))\n\ngoal (1 subgoal):\n 1. coeffs (pCons (0::'a) (Polynomial.smult a p) + Polynomial.smult b p) =\n    strip_while ((=) (0::'a))\n     (map2 (\\<lambda>c d. b * d + c * a) ((0::'a) # coeffs p)\n       (coeffs p @ [0::'a]))", "from this[of 0]"], ["proof (chain)\npicking this:\n  coeffs\n   (Polynomial.smult b p + pCons (a * (0::'a)) (Polynomial.smult a p)) =\n  strip_while ((=) (0::'a))\n   (map2 (\\<lambda>c d. b * d + c * a) ([0::'a] @ coeffs p)\n     (coeffs p @ [0::'a]))", "show ?thesis"], ["proof (prove)\nusing this:\n  coeffs\n   (Polynomial.smult b p + pCons (a * (0::'a)) (Polynomial.smult a p)) =\n  strip_while ((=) (0::'a))\n   (map2 (\\<lambda>c d. b * d + c * a) ([0::'a] @ coeffs p)\n     (coeffs p @ [0::'a]))\n\ngoal (1 subgoal):\n 1. coeffs (pCons (0::'a) (Polynomial.smult a p) + Polynomial.smult b p) =\n    strip_while ((=) (0::'a))\n     (map2 (\\<lambda>c d. b * d + c * a) ((0::'a) # coeffs p)\n       (coeffs p @ [0::'a]))", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  coeffs (pCons (0::'a) (Polynomial.smult a p) + Polynomial.smult b p) =\n  strip_while ((=) (0::'a))\n   (map2 (\\<lambda>c d. b * d + c * a) ((0::'a) # coeffs p)\n     (coeffs p @ [0::'a]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_distr_rev[simp]:\n  shows \"filter f (rev lst) = rev (filter f lst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter f (rev lst) = rev (filter f lst)", "by(induct lst;auto)"], ["", "lemma strip_while_filter:\n  shows \"filter ((\\<noteq>) 0) (strip_while ((=) 0) (lst::'a::zero list)) = filter ((\\<noteq>) 0) lst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) lst) =\n    filter ((\\<noteq>) (0::'a)) lst", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) lst) =\n    filter ((\\<noteq>) (0::'a)) lst", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) lst) =\n    filter ((\\<noteq>) (0::'a)) lst", "fix lst::\"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) lst) =\n    filter ((\\<noteq>) (0::'a)) lst", "have \"filter ((\\<noteq>) 0) (dropWhile ((=) 0) lst) = filter ((\\<noteq>) 0) lst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) (0::'a)) (dropWhile ((=) (0::'a)) lst) =\n    filter ((\\<noteq>) (0::'a)) lst", "by (induct lst;auto)"], ["proof (state)\nthis:\n  filter ((\\<noteq>) (0::'a)) (dropWhile ((=) (0::'a)) lst) =\n  filter ((\\<noteq>) (0::'a)) lst\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) lst) =\n    filter ((\\<noteq>) (0::'a)) lst", "hence \"(filter ((\\<noteq>) 0) (strip_while ((=) 0) (rev lst))) = filter ((\\<noteq>) 0) (rev lst)\""], ["proof (prove)\nusing this:\n  filter ((\\<noteq>) (0::'a)) (dropWhile ((=) (0::'a)) lst) =\n  filter ((\\<noteq>) (0::'a)) lst\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) (rev lst)) =\n    filter ((\\<noteq>) (0::'a)) (rev lst)", "unfolding strip_while_def"], ["proof (prove)\nusing this:\n  filter ((\\<noteq>) (0::'a)) (dropWhile ((=) (0::'a)) lst) =\n  filter ((\\<noteq>) (0::'a)) lst\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) (0::'a))\n     ((rev \\<circ> dropWhile ((=) (0::'a)) \\<circ> rev) (rev lst)) =\n    filter ((\\<noteq>) (0::'a)) (rev lst)", "by(simp)"], ["proof (state)\nthis:\n  filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) (rev lst)) =\n  filter ((\\<noteq>) (0::'a)) (rev lst)\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) lst) =\n    filter ((\\<noteq>) (0::'a)) lst", "}"], ["proof (state)\nthis:\n  filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) (rev ?lsta2)) =\n  filter ((\\<noteq>) (0::'a)) (rev ?lsta2)\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) lst) =\n    filter ((\\<noteq>) (0::'a)) lst", "from this[of \"rev lst\"]"], ["proof (chain)\npicking this:\n  filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) (rev (rev lst))) =\n  filter ((\\<noteq>) (0::'a)) (rev (rev lst))", "show ?thesis"], ["proof (prove)\nusing this:\n  filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) (rev (rev lst))) =\n  filter ((\\<noteq>) (0::'a)) (rev (rev lst))\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) lst) =\n    filter ((\\<noteq>) (0::'a)) lst", "by simp"], ["proof (state)\nthis:\n  filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) lst) =\n  filter ((\\<noteq>) (0::'a)) lst\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_stripwhile[simp]:\n  assumes \"f 0 = 0\"\n  shows \"(\\<Sum>a\\<leftarrow>strip_while ((=) 0) lst. f a) = (\\<Sum>a\\<leftarrow>lst. f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f (strip_while ((=) (0::'b)) lst)) = sum_list (map f lst)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list (map f (strip_while ((=) (0::'b)) lst)) = sum_list (map f lst)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list (map f (strip_while ((=) (0::'b)) lst)) = sum_list (map f lst)", "fix lst"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list (map f (strip_while ((=) (0::'b)) lst)) = sum_list (map f lst)", "have \"(\\<Sum>a\\<leftarrow>filter ((\\<noteq>) 0) lst. f a) = (\\<Sum>a\\<leftarrow>lst. f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f (filter ((\\<noteq>) (0::'b)) lst)) =\n    sum_list (map f lst)", "by(induct lst,auto simp:assms)"], ["proof (state)\nthis:\n  sum_list (map f (filter ((\\<noteq>) (0::'b)) lst)) = sum_list (map f lst)\n\ngoal (1 subgoal):\n 1. sum_list (map f (strip_while ((=) (0::'b)) lst)) = sum_list (map f lst)", "}"], ["proof (state)\nthis:\n  sum_list (map f (filter ((\\<noteq>) (0::'b)) ?lsta2)) =\n  sum_list (map f ?lsta2)\n\ngoal (1 subgoal):\n 1. sum_list (map f (strip_while ((=) (0::'b)) lst)) = sum_list (map f lst)", "note f=this"], ["proof (state)\nthis:\n  sum_list (map f (filter ((\\<noteq>) (0::'b)) ?lsta2)) =\n  sum_list (map f ?lsta2)\n\ngoal (1 subgoal):\n 1. sum_list (map f (strip_while ((=) (0::'b)) lst)) = sum_list (map f lst)", "have \"sum_list (map f (filter ((\\<noteq>) 0) (strip_while ((=) 0) lst)))\n       = sum_list (map f (filter ((\\<noteq>) 0) lst))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map f (filter ((\\<noteq>) (0::'b)) (strip_while ((=) (0::'b)) lst))) =\n    sum_list (map f (filter ((\\<noteq>) (0::'b)) lst))", "using strip_while_filter[of lst]"], ["proof (prove)\nusing this:\n  filter ((\\<noteq>) (0::'b)) (strip_while ((=) (0::'b)) lst) =\n  filter ((\\<noteq>) (0::'b)) lst\n\ngoal (1 subgoal):\n 1. sum_list\n     (map f (filter ((\\<noteq>) (0::'b)) (strip_while ((=) (0::'b)) lst))) =\n    sum_list (map f (filter ((\\<noteq>) (0::'b)) lst))", "by(simp)"], ["proof (state)\nthis:\n  sum_list\n   (map f (filter ((\\<noteq>) (0::'b)) (strip_while ((=) (0::'b)) lst))) =\n  sum_list (map f (filter ((\\<noteq>) (0::'b)) lst))\n\ngoal (1 subgoal):\n 1. sum_list (map f (strip_while ((=) (0::'b)) lst)) = sum_list (map f lst)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sum_list\n   (map f (filter ((\\<noteq>) (0::'b)) (strip_while ((=) (0::'b)) lst))) =\n  sum_list (map f (filter ((\\<noteq>) (0::'b)) lst))\n\ngoal (1 subgoal):\n 1. sum_list (map f (strip_while ((=) (0::'b)) lst)) = sum_list (map f lst)", "unfolding f"], ["proof (prove)\nusing this:\n  sum_list (map f (strip_while ((=) (0::'b)) lst)) = sum_list (map f lst)\n\ngoal (1 subgoal):\n 1. sum_list (map f (strip_while ((=) (0::'b)) lst)) = sum_list (map f lst)", "."], ["proof (state)\nthis:\n  sum_list (map f (strip_while ((=) (0::'b)) lst)) = sum_list (map f lst)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complex_split : \"Complex a b = c \\<longleftrightarrow> (a = Re c \\<and> b = Im c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Complex a b = c) = (a = Re c \\<and> b = Im c)", "using complex_surj"], ["proof (prove)\nusing this:\n  Complex (Re ?z) (Im ?z) = ?z\n\ngoal (1 subgoal):\n 1. (Complex a b = c) = (a = Re c \\<and> b = Im c)", "by auto"], ["", "lemma norm_times_const:\"(\\<Sum>y\\<leftarrow>lst. (cmod (a * y))\\<^sup>2) = (cmod a)\\<^sup>2 * (\\<Sum>y\\<leftarrow>lst. (cmod y)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<leftarrow>lst. (cmod (a * y))\\<^sup>2) =\n    (cmod a)\\<^sup>2 * (\\<Sum>y\\<leftarrow>lst. (cmod y)\\<^sup>2)", "by(induct lst,auto simp:ring_distribs)"], ["", "fun bisumTail where (* Used for Landau's lemma *)\n  \"bisumTail f (Cons a (Cons b bs)) = f a b + bisumTail f (Cons b bs)\" |\n  \"bisumTail f (Cons a Nil) = f a 0\" |\n  \"bisumTail f Nil = f 1 0\""], ["", "(* never called, not used in proofs *)"], ["", "fun bisum where\n  \"bisum f (Cons a as) = f 0 a + bisumTail f (Cons a as)\" |\n  \"bisum f Nil = f 0 0\""], ["", "lemma bisumTail_is_map_zip:\n  \"(\\<Sum>x\\<leftarrow>zip (v # l1) (l1 @ [0]). f x) = bisumTail (\\<lambda>x y .f (x,y))  (v#l1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f (zip (v # l1) (l1 @ [0::'b]))) =\n    bisumTail (\\<lambda>x y. f (x, y)) (v # l1)", "by(induct l1 arbitrary:v,auto)"], ["", "(* converting to and from bisum *)"], ["", "lemma bisum_is_map_zip:\n  \"(\\<Sum>x\\<leftarrow>zip (0 # l1) (l1 @ [0]). f x) = bisum (\\<lambda>x y. f (x,y)) l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f (zip ((0::'b) # l1) (l1 @ [0::'b]))) =\n    bisum (\\<lambda>x y. f (x, y)) l1", "using bisumTail_is_map_zip[of f \"hd l1\" \"tl l1\"]"], ["proof (prove)\nusing this:\n  sum_list (map f (zip (hd l1 # tl l1) (tl l1 @ [0::'b]))) =\n  bisumTail (\\<lambda>x y. f (x, y)) (hd l1 # tl l1)\n\ngoal (1 subgoal):\n 1. sum_list (map f (zip ((0::'b) # l1) (l1 @ [0::'b]))) =\n    bisum (\\<lambda>x y. f (x, y)) l1", "by(cases l1,auto)"], ["", "lemma map_zip_is_bisum:\n  \"bisum f l1 = (\\<Sum>(x,y)\\<leftarrow>zip (0 # l1) (l1 @ [0]). f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisum f l1 = sum_list (map2 f ((0::'b) # l1) (l1 @ [0::'b]))", "using bisum_is_map_zip[of \"\\<lambda>(x,y). f x y\"]"], ["proof (prove)\nusing this:\n  sum_list (map2 f ((0::'b) # ?l1.0) (?l1.0 @ [0::'b])) =\n  bisum (\\<lambda>x y. case (x, y) of (x, y) \\<Rightarrow> f x y) ?l1.0\n\ngoal (1 subgoal):\n 1. bisum f l1 = sum_list (map2 f ((0::'b) # l1) (l1 @ [0::'b]))", "by auto"], ["", "lemma bisum_outside :\n  \"(bisum (\\<lambda> x y. f1 x - f2 x y + f3 y) lst :: 'a :: field)\n  = sum_list (map f1 lst) + f1 0 - bisum f2 lst + sum_list (map f3 lst) + f3 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisum (\\<lambda>x y. f1 x - f2 x y + f3 y) lst =\n    sum_list (map f1 lst) + f1 (0::'b) - bisum f2 lst +\n    sum_list (map f3 lst) +\n    f3 (0::'b)", "proof(cases lst)"], ["proof (state)\ngoal (2 subgoals):\n 1. lst = [] \\<Longrightarrow>\n    bisum (\\<lambda>x y. f1 x - f2 x y + f3 y) lst =\n    sum_list (map f1 lst) + f1 (0::'b) - bisum f2 lst +\n    sum_list (map f3 lst) +\n    f3 (0::'b)\n 2. \\<And>a list.\n       lst = a # list \\<Longrightarrow>\n       bisum (\\<lambda>x y. f1 x - f2 x y + f3 y) lst =\n       sum_list (map f1 lst) + f1 (0::'b) - bisum f2 lst +\n       sum_list (map f3 lst) +\n       f3 (0::'b)", "case (Cons a lst)"], ["proof (state)\nthis:\n  lst = a # lst\n\ngoal (2 subgoals):\n 1. lst = [] \\<Longrightarrow>\n    bisum (\\<lambda>x y. f1 x - f2 x y + f3 y) lst =\n    sum_list (map f1 lst) + f1 (0::'b) - bisum f2 lst +\n    sum_list (map f3 lst) +\n    f3 (0::'b)\n 2. \\<And>a list.\n       lst = a # list \\<Longrightarrow>\n       bisum (\\<lambda>x y. f1 x - f2 x y + f3 y) lst =\n       sum_list (map f1 lst) + f1 (0::'b) - bisum f2 lst +\n       sum_list (map f3 lst) +\n       f3 (0::'b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bisum (\\<lambda>x y. f1 x - f2 x y + f3 y) lst =\n    sum_list (map f1 lst) + f1 (0::'b) - bisum f2 lst +\n    sum_list (map f3 lst) +\n    f3 (0::'b)", "unfolding map_zip_is_bisum Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map2 (\\<lambda>x y. f1 x - f2 x y + f3 y) ((0::'b) # a # lst)\n       ((a # lst) @ [0::'b])) =\n    sum_list (map f1 (a # lst)) + f1 (0::'b) -\n    sum_list (map2 f2 ((0::'b) # a # lst) ((a # lst) @ [0::'b])) +\n    sum_list (map f3 (a # lst)) +\n    f3 (0::'b)", "by(induct lst arbitrary:a,auto)"], ["proof (state)\nthis:\n  bisum (\\<lambda>x y. f1 x - f2 x y + f3 y) lst =\n  sum_list (map f1 lst) + f1 (0::'b) - bisum f2 lst +\n  sum_list (map f3 lst) +\n  f3 (0::'b)\n\ngoal (1 subgoal):\n 1. lst = [] \\<Longrightarrow>\n    bisum (\\<lambda>x y. f1 x - f2 x y + f3 y) lst =\n    sum_list (map f1 lst) + f1 (0::'b) - bisum f2 lst +\n    sum_list (map f3 lst) +\n    f3 (0::'b)", "qed auto"], ["", "lemma Landau_lemma:\n  \"(\\<Sum>a\\<leftarrow>coeffs (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]). (cmod a)\\<^sup>2) = (\\<Sum>a\\<leftarrow>coeffs (\\<Prod>a\\<leftarrow>lst. linH a). (cmod a)\\<^sup>2)\"\n  (is \"norm2 ?l = norm2 ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "have a:\"\\<And> a. (cmod a)\\<^sup>2 = Re (a * cnj a) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. (cmod a)\\<^sup>2 = Re (a * cnj a)", "using complex_norm_square"], ["proof (prove)\nusing this:\n  complex_of_real ((cmod ?z)\\<^sup>2) = ?z * cnj ?z\n\ngoal (1 subgoal):\n 1. \\<And>a. (cmod a)\\<^sup>2 = Re (a * cnj a)", "unfolding complex_split complex_of_real_def"], ["proof (prove)\nusing this:\n  (cmod ?z)\\<^sup>2 = Re (?z * cnj ?z) \\<and> 0 = Im (?z * cnj ?z)\n\ngoal (1 subgoal):\n 1. \\<And>a. (cmod a)\\<^sup>2 = Re (a * cnj a)", "by simp"], ["proof (state)\nthis:\n  (cmod ?a)\\<^sup>2 = Re (?a * cnj ?a)\n\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "have b:\"\\<And> x a y. (cmod (x - a * y))^2\n               = (cmod x)\\<^sup>2 - Re (a * y * cnj x + x * cnj (a * y)) + (cmod (a * y))^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a y.\n       (cmod (x - a * y))\\<^sup>2 =\n       (cmod x)\\<^sup>2 - Re (a * y * cnj x + x * cnj (a * y)) +\n       (cmod (a * y))\\<^sup>2", "unfolding left_diff_distrib right_diff_distrib a complex_cnj_diff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a y.\n       Re (x * cnj x - a * y * cnj x -\n           (x * cnj (a * y) - a * y * cnj (a * y))) =\n       Re (x * cnj x) - Re (a * y * cnj x + x * cnj (a * y)) +\n       Re (a * y * cnj (a * y))", "by simp"], ["proof (state)\nthis:\n  (cmod (?x - ?a * ?y))\\<^sup>2 =\n  (cmod ?x)\\<^sup>2 - Re (?a * ?y * cnj ?x + ?x * cnj (?a * ?y)) +\n  (cmod (?a * ?y))\\<^sup>2\n\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "have c:\"\\<And> y a x. (cmod (cnj a * x - y))\\<^sup>2\n               = (cmod (a * x))\\<^sup>2 - Re (a * y * cnj x + x * cnj (a * y)) + (cmod y)^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y a x.\n       (cmod (cnj a * x - y))\\<^sup>2 =\n       (cmod (a * x))\\<^sup>2 - Re (a * y * cnj x + x * cnj (a * y)) +\n       (cmod y)\\<^sup>2", "unfolding left_diff_distrib right_diff_distrib a complex_cnj_diff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y a x.\n       Re (cnj a * x * cnj (cnj a * x) - y * cnj (cnj a * x) -\n           (cnj a * x * cnj y - y * cnj y)) =\n       Re (a * x * cnj (a * x)) - Re (a * y * cnj x + x * cnj (a * y)) +\n       Re (y * cnj y)", "by (simp add: mult.assoc mult.left_commute)"], ["proof (state)\nthis:\n  (cmod (cnj ?a * ?x - ?y))\\<^sup>2 =\n  (cmod (?a * ?x))\\<^sup>2 - Re (?a * ?y * cnj ?x + ?x * cnj (?a * ?y)) +\n  (cmod ?y)\\<^sup>2\n\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "{"], ["proof (state)\nthis:\n  (cmod (cnj ?a * ?x - ?y))\\<^sup>2 =\n  (cmod (?a * ?x))\\<^sup>2 - Re (?a * ?y * cnj ?x + ?x * cnj (?a * ?y)) +\n  (cmod ?y)\\<^sup>2\n\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "fix f1 a"], ["proof (state)\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "have \"norm2 ([:- a, 1 :] * f1) = bisum (\\<lambda>x y. cmod (x - a * y)^2) (coeffs f1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm2 ([:- a, 1:] * f1) =\n    bisum (\\<lambda>x y. (cmod (x - a * y))\\<^sup>2) (coeffs f1)", "by(simp add: bisum_is_map_zip[of _ \"coeffs f1\"] coeffs_times_linterm[of 1 _ \"-a\",simplified])"], ["proof (state)\nthis:\n  norm2 ([:- a, 1:] * f1) =\n  bisum (\\<lambda>x y. (cmod (x - a * y))\\<^sup>2) (coeffs f1)\n\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "also"], ["proof (state)\nthis:\n  norm2 ([:- a, 1:] * f1) =\n  bisum (\\<lambda>x y. (cmod (x - a * y))\\<^sup>2) (coeffs f1)\n\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "have \"\\<dots> = norm2 f1 + cmod a^2*norm2 f1\n                  - bisum (\\<lambda>x y. Re (a * y * cnj x + x * cnj (a * y))) (coeffs f1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisum (\\<lambda>x y. (cmod (x - a * y))\\<^sup>2) (coeffs f1) =\n    norm2 f1 + (cmod a)\\<^sup>2 * norm2 f1 -\n    bisum (\\<lambda>x y. Re (a * y * cnj x + x * cnj (a * y))) (coeffs f1)", "unfolding b bisum_outside norm_times_const"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm2 f1 + (cmod 0)\\<^sup>2 -\n    bisum (\\<lambda>x y. Re (a * y * cnj x + x * cnj (a * y))) (coeffs f1) +\n    (cmod a)\\<^sup>2 * norm2 f1 +\n    (cmod (a * 0))\\<^sup>2 =\n    norm2 f1 + (cmod a)\\<^sup>2 * norm2 f1 -\n    bisum (\\<lambda>x y. Re (a * y * cnj x + x * cnj (a * y))) (coeffs f1)", "by simp"], ["proof (state)\nthis:\n  bisum (\\<lambda>x y. (cmod (x - a * y))\\<^sup>2) (coeffs f1) =\n  norm2 f1 + (cmod a)\\<^sup>2 * norm2 f1 -\n  bisum (\\<lambda>x y. Re (a * y * cnj x + x * cnj (a * y))) (coeffs f1)\n\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "also"], ["proof (state)\nthis:\n  bisum (\\<lambda>x y. (cmod (x - a * y))\\<^sup>2) (coeffs f1) =\n  norm2 f1 + (cmod a)\\<^sup>2 * norm2 f1 -\n  bisum (\\<lambda>x y. Re (a * y * cnj x + x * cnj (a * y))) (coeffs f1)\n\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "have \"\\<dots> = bisum (\\<lambda>x y. cmod (cnj a * x - y)^2) (coeffs f1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm2 f1 + (cmod a)\\<^sup>2 * norm2 f1 -\n    bisum (\\<lambda>x y. Re (a * y * cnj x + x * cnj (a * y))) (coeffs f1) =\n    bisum (\\<lambda>x y. (cmod (cnj a * x - y))\\<^sup>2) (coeffs f1)", "unfolding c bisum_outside norm_times_const"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm2 f1 + (cmod a)\\<^sup>2 * norm2 f1 -\n    bisum (\\<lambda>x y. Re (a * y * cnj x + x * cnj (a * y))) (coeffs f1) =\n    (cmod a)\\<^sup>2 * norm2 f1 + (cmod (a * 0))\\<^sup>2 -\n    bisum (\\<lambda>x y. Re (a * y * cnj x + x * cnj (a * y))) (coeffs f1) +\n    norm2 f1 +\n    (cmod 0)\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  norm2 f1 + (cmod a)\\<^sup>2 * norm2 f1 -\n  bisum (\\<lambda>x y. Re (a * y * cnj x + x * cnj (a * y))) (coeffs f1) =\n  bisum (\\<lambda>x y. (cmod (cnj a * x - y))\\<^sup>2) (coeffs f1)\n\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "also"], ["proof (state)\nthis:\n  norm2 f1 + (cmod a)\\<^sup>2 * norm2 f1 -\n  bisum (\\<lambda>x y. Re (a * y * cnj x + x * cnj (a * y))) (coeffs f1) =\n  bisum (\\<lambda>x y. (cmod (cnj a * x - y))\\<^sup>2) (coeffs f1)\n\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "have \"\\<dots> = norm2 ([:- 1, cnj a :] * f1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisum (\\<lambda>x y. (cmod (cnj a * x - y))\\<^sup>2) (coeffs f1) =\n    norm2 ([:- 1, cnj a:] * f1)", "using coeffs_times_linterm[of \"cnj a\" _ \"-1\"]"], ["proof (prove)\nusing this:\n  coeffs\n   (pCons 0 (Polynomial.smult (cnj a) ?p) + Polynomial.smult (- 1) ?p) =\n  strip_while ((=) 0)\n   (map2 (\\<lambda>c d. - 1 * d + c * cnj a) (0 # coeffs ?p)\n     (coeffs ?p @ [0]))\n\ngoal (1 subgoal):\n 1. bisum (\\<lambda>x y. (cmod (cnj a * x - y))\\<^sup>2) (coeffs f1) =\n    norm2 ([:- 1, cnj a:] * f1)", "by(simp add: bisum_is_map_zip[of _ \"coeffs f1\"] mult.commute)"], ["proof (state)\nthis:\n  bisum (\\<lambda>x y. (cmod (cnj a * x - y))\\<^sup>2) (coeffs f1) =\n  norm2 ([:- 1, cnj a:] * f1)\n\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "finally"], ["proof (chain)\npicking this:\n  norm2 ([:- a, 1:] * f1) = norm2 ([:- 1, cnj a:] * f1)", "have \"norm2 ([:- a, 1 :] * f1) = \\<dots>\""], ["proof (prove)\nusing this:\n  norm2 ([:- a, 1:] * f1) = norm2 ([:- 1, cnj a:] * f1)\n\ngoal (1 subgoal):\n 1. norm2 ([:- a, 1:] * f1) = norm2 ([:- 1, cnj a:] * f1)", "."], ["proof (state)\nthis:\n  norm2 ([:- a, 1:] * f1) = norm2 ([:- 1, cnj a:] * f1)\n\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "}"], ["proof (state)\nthis:\n  norm2 ([:- ?a2, 1:] * ?f1.2) = norm2 ([:- 1, cnj ?a2:] * ?f1.2)\n\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "hence h:\"\\<And> a f1. norm2 ([:- a, 1 :] * f1) = norm2 (linH a * f1)\""], ["proof (prove)\nusing this:\n  norm2 ([:- ?a2, 1:] * ?f1.2) = norm2 ([:- 1, cnj ?a2:] * ?f1.2)\n\ngoal (1 subgoal):\n 1. \\<And>a f1.\n       norm2 ([:- a, 1:] * f1) =\n       norm2 ((if 1 < cmod a then [:- 1, cnj a:] else [:- a, 1:]) * f1)", "by auto"], ["proof (state)\nthis:\n  norm2 ([:- ?a, 1:] * ?f1.0) =\n  norm2 ((if 1 < cmod ?a then [:- 1, cnj ?a:] else [:- ?a, 1:]) * ?f1.0)\n\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n    norm2\n     (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])", "by(rule prod_induct_gen[OF h])"], ["proof (state)\nthis:\n  norm2 (\\<Prod>a\\<leftarrow>lst. [:- a, 1:]) =\n  norm2\n   (\\<Prod>a\\<leftarrow>lst. if 1 < cmod a then [:- 1, cnj a:]\n                             else [:- a, 1:])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Landau_inequality:\n  \"mahler_measure_poly f \\<le> l2norm_complex f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "let ?f = \"reconstruct_poly (lead_coeff f) (complex_roots_complex f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "let ?roots = \"(complex_roots_complex f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "let ?g = \"\\<Prod>a\\<leftarrow>?roots. linH a\""], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "(* g is chosen such that lead_coeff_g holds, and its l2 norm is equal to f's l2 norm *)"], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "have max:\"\\<And>a. cmod (if 1 < cmod a then cnj a else 1) = max 1 (cmod a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. cmod (if 1 < cmod a then cnj a else 1) = max 1 (cmod a)", "by(simp add:if_split,auto)"], ["proof (state)\nthis:\n  cmod (if 1 < cmod ?a then cnj ?a else 1) = max 1 (cmod ?a)\n\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "have \"\\<And>a. 1 < cmod a \\<Longrightarrow> a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. 1 < cmod a \\<Longrightarrow> a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  1 < cmod ?a \\<Longrightarrow> ?a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "hence \"\\<And>a. lead_coeff (linH a) = (if (cmod a > 1) then cnj a else 1)\""], ["proof (prove)\nusing this:\n  1 < cmod ?a \\<Longrightarrow> ?a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lead_coeff (if 1 < cmod a then [:- 1, cnj a:] else [:- a, 1:]) =\n       (if 1 < cmod a then cnj a else 1)", "by(auto simp:if_split)"], ["proof (state)\nthis:\n  lead_coeff (if 1 < cmod ?a then [:- 1, cnj ?a:] else [:- ?a, 1:]) =\n  (if 1 < cmod ?a then cnj ?a else 1)\n\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "hence lead_coeff_g:\"cmod (lead_coeff ?g) = (\\<Prod>a\\<leftarrow>?roots. max 1 (cmod a))\""], ["proof (prove)\nusing this:\n  lead_coeff (if 1 < cmod ?a then [:- 1, cnj ?a:] else [:- ?a, 1:]) =\n  (if 1 < cmod ?a then cnj ?a else 1)\n\ngoal (1 subgoal):\n 1. cmod\n     (lead_coeff\n       (\\<Prod>a\\<leftarrow>complex_roots_complex\n                             f. if 1 < cmod a then [:- 1, cnj a:]\n                                else [:- a, 1:])) =\n    (\\<Prod>a\\<leftarrow>complex_roots_complex f. max 1 (cmod a))", "by(auto simp:max)"], ["proof (state)\nthis:\n  cmod\n   (lead_coeff\n     (\\<Prod>a\\<leftarrow>complex_roots_complex\n                           f. if 1 < cmod a then [:- 1, cnj a:]\n                              else [:- a, 1:])) =\n  (\\<Prod>a\\<leftarrow>complex_roots_complex f. max 1 (cmod a))\n\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "have \"norm2 f = (\\<Sum>a\\<leftarrow>coeffs ?f. (cmod a)^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm2 f =\n    norm2 (reconstruct_poly (lead_coeff f) (complex_roots_complex f))", "unfolding reconstruct_is_original_poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm2 f = norm2 f", ".."], ["proof (state)\nthis:\n  norm2 f =\n  norm2 (reconstruct_poly (lead_coeff f) (complex_roots_complex f))\n\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "also"], ["proof (state)\nthis:\n  norm2 f =\n  norm2 (reconstruct_poly (lead_coeff f) (complex_roots_complex f))\n\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "have \"\\<dots> = cmod (lead_coeff f)^2 * (\\<Sum>a\\<leftarrow>coeffs (\\<Prod>a\\<leftarrow>?roots. [:- a, 1:]). (cmod a)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm2 (reconstruct_poly (lead_coeff f) (complex_roots_complex f)) =\n    (cmod (lead_coeff f))\\<^sup>2 *\n    norm2 (\\<Prod>a\\<leftarrow>complex_roots_complex f. [:- a, 1:])", "unfolding reconstruct_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm2\n     (Polynomial.smult (lead_coeff f)\n       (\\<Prod>a\\<leftarrow>complex_roots_complex f. [:- a, 1:])) =\n    (cmod (lead_coeff f))\\<^sup>2 *\n    norm2 (\\<Prod>a\\<leftarrow>complex_roots_complex f. [:- a, 1:])", "using sum_coeffs_smult_cmod"], ["proof (prove)\nusing this:\n  norm2 (Polynomial.smult ?v ?p) = (cmod ?v)\\<^sup>2 * norm2 ?p\n\ngoal (1 subgoal):\n 1. norm2\n     (Polynomial.smult (lead_coeff f)\n       (\\<Prod>a\\<leftarrow>complex_roots_complex f. [:- a, 1:])) =\n    (cmod (lead_coeff f))\\<^sup>2 *\n    norm2 (\\<Prod>a\\<leftarrow>complex_roots_complex f. [:- a, 1:])", "."], ["proof (state)\nthis:\n  norm2 (reconstruct_poly (lead_coeff f) (complex_roots_complex f)) =\n  (cmod (lead_coeff f))\\<^sup>2 *\n  norm2 (\\<Prod>a\\<leftarrow>complex_roots_complex f. [:- a, 1:])\n\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "finally"], ["proof (chain)\npicking this:\n  norm2 f =\n  (cmod (lead_coeff f))\\<^sup>2 *\n  norm2 (\\<Prod>a\\<leftarrow>complex_roots_complex f. [:- a, 1:])", "have fg_norm:\"norm2 f = cmod (lead_coeff f)^2 * (\\<Sum>a\\<leftarrow>coeffs ?g. (cmod a)^2)\""], ["proof (prove)\nusing this:\n  norm2 f =\n  (cmod (lead_coeff f))\\<^sup>2 *\n  norm2 (\\<Prod>a\\<leftarrow>complex_roots_complex f. [:- a, 1:])\n\ngoal (1 subgoal):\n 1. norm2 f =\n    (cmod (lead_coeff f))\\<^sup>2 *\n    norm2\n     (\\<Prod>a\\<leftarrow>complex_roots_complex\n                           f. if 1 < cmod a then [:- 1, cnj a:]\n                              else [:- a, 1:])", "unfolding Landau_lemma"], ["proof (prove)\nusing this:\n  norm2 f =\n  (cmod (lead_coeff f))\\<^sup>2 *\n  norm2\n   (\\<Prod>a\\<leftarrow>complex_roots_complex\n                         f. if 1 < cmod a then [:- 1, cnj a:]\n                            else [:- a, 1:])\n\ngoal (1 subgoal):\n 1. norm2 f =\n    (cmod (lead_coeff f))\\<^sup>2 *\n    norm2\n     (\\<Prod>a\\<leftarrow>complex_roots_complex\n                           f. if 1 < cmod a then [:- 1, cnj a:]\n                              else [:- a, 1:])", "by auto"], ["proof (state)\nthis:\n  norm2 f =\n  (cmod (lead_coeff f))\\<^sup>2 *\n  norm2\n   (\\<Prod>a\\<leftarrow>complex_roots_complex\n                         f. if 1 < cmod a then [:- 1, cnj a:]\n                            else [:- a, 1:])\n\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "have \"(cmod (lead_coeff ?g))^2 \\<le> (\\<Sum>a\\<leftarrow>coeffs ?g. (cmod a)^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod\n      (lead_coeff\n        (\\<Prod>a\\<leftarrow>complex_roots_complex\n                              f. if 1 < cmod a then [:- 1, cnj a:]\n                                 else [:- a, 1:])))\\<^sup>2\n    \\<le> norm2\n           (\\<Prod>a\\<leftarrow>complex_roots_complex\n                                 f. if 1 < cmod a then [:- 1, cnj a:]\n                                    else [:- a, 1:])", "using first_coeff_le_tail"], ["proof (prove)\nusing this:\n  (cmod (lead_coeff ?g))\\<^sup>2 \\<le> norm2 ?g\n\ngoal (1 subgoal):\n 1. (cmod\n      (lead_coeff\n        (\\<Prod>a\\<leftarrow>complex_roots_complex\n                              f. if 1 < cmod a then [:- 1, cnj a:]\n                                 else [:- a, 1:])))\\<^sup>2\n    \\<le> norm2\n           (\\<Prod>a\\<leftarrow>complex_roots_complex\n                                 f. if 1 < cmod a then [:- 1, cnj a:]\n                                    else [:- a, 1:])", "by blast"], ["proof (state)\nthis:\n  (cmod\n    (lead_coeff\n      (\\<Prod>a\\<leftarrow>complex_roots_complex\n                            f. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])))\\<^sup>2\n  \\<le> norm2\n         (\\<Prod>a\\<leftarrow>complex_roots_complex\n                               f. if 1 < cmod a then [:- 1, cnj a:]\n                                  else [:- a, 1:])\n\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "from ordered_comm_semiring_class.comm_mult_left_mono[OF this]"], ["proof (chain)\npicking this:\n  0 \\<le> ?c \\<Longrightarrow>\n  ?c *\n  (cmod\n    (lead_coeff\n      (\\<Prod>a\\<leftarrow>complex_roots_complex\n                            f. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])))\\<^sup>2\n  \\<le> ?c *\n        norm2\n         (\\<Prod>a\\<leftarrow>complex_roots_complex\n                               f. if 1 < cmod a then [:- 1, cnj a:]\n                                  else [:- a, 1:])", "have \"(cmod (lead_coeff f) * cmod (lead_coeff ?g))^2 \\<le> (\\<Sum>a\\<leftarrow>coeffs f. (cmod a)^2)\""], ["proof (prove)\nusing this:\n  0 \\<le> ?c \\<Longrightarrow>\n  ?c *\n  (cmod\n    (lead_coeff\n      (\\<Prod>a\\<leftarrow>complex_roots_complex\n                            f. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])))\\<^sup>2\n  \\<le> ?c *\n        norm2\n         (\\<Prod>a\\<leftarrow>complex_roots_complex\n                               f. if 1 < cmod a then [:- 1, cnj a:]\n                                  else [:- a, 1:])\n\ngoal (1 subgoal):\n 1. (cmod (lead_coeff f) *\n     cmod\n      (lead_coeff\n        (\\<Prod>a\\<leftarrow>complex_roots_complex\n                              f. if 1 < cmod a then [:- 1, cnj a:]\n                                 else [:- a, 1:])))\\<^sup>2\n    \\<le> norm2 f", "unfolding fg_norm"], ["proof (prove)\nusing this:\n  0 \\<le> ?c \\<Longrightarrow>\n  ?c *\n  (cmod\n    (lead_coeff\n      (\\<Prod>a\\<leftarrow>complex_roots_complex\n                            f. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])))\\<^sup>2\n  \\<le> ?c *\n        norm2\n         (\\<Prod>a\\<leftarrow>complex_roots_complex\n                               f. if 1 < cmod a then [:- 1, cnj a:]\n                                  else [:- a, 1:])\n\ngoal (1 subgoal):\n 1. (cmod (lead_coeff f) *\n     cmod\n      (lead_coeff\n        (\\<Prod>a\\<leftarrow>complex_roots_complex\n                              f. if 1 < cmod a then [:- 1, cnj a:]\n                                 else [:- a, 1:])))\\<^sup>2\n    \\<le> (cmod (lead_coeff f))\\<^sup>2 *\n          norm2\n           (\\<Prod>a\\<leftarrow>complex_roots_complex\n                                 f. if 1 < cmod a then [:- 1, cnj a:]\n                                    else [:- a, 1:])", "by (simp add:power_mult_distrib)"], ["proof (state)\nthis:\n  (cmod (lead_coeff f) *\n   cmod\n    (lead_coeff\n      (\\<Prod>a\\<leftarrow>complex_roots_complex\n                            f. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])))\\<^sup>2\n  \\<le> norm2 f\n\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "hence \"cmod (lead_coeff f) * (\\<Prod>a\\<leftarrow>?roots. max 1 (cmod a)) \\<le> sqrt (norm2 f)\""], ["proof (prove)\nusing this:\n  (cmod (lead_coeff f) *\n   cmod\n    (lead_coeff\n      (\\<Prod>a\\<leftarrow>complex_roots_complex\n                            f. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])))\\<^sup>2\n  \\<le> norm2 f\n\ngoal (1 subgoal):\n 1. cmod (lead_coeff f) *\n    (\\<Prod>a\\<leftarrow>complex_roots_complex f. max 1 (cmod a))\n    \\<le> l2norm_complex f", "using NthRoot.real_le_rsqrt lead_coeff_g"], ["proof (prove)\nusing this:\n  (cmod (lead_coeff f) *\n   cmod\n    (lead_coeff\n      (\\<Prod>a\\<leftarrow>complex_roots_complex\n                            f. if 1 < cmod a then [:- 1, cnj a:]\n                               else [:- a, 1:])))\\<^sup>2\n  \\<le> norm2 f\n  ?x\\<^sup>2 \\<le> ?y \\<Longrightarrow> ?x \\<le> sqrt ?y\n  cmod\n   (lead_coeff\n     (\\<Prod>a\\<leftarrow>complex_roots_complex\n                           f. if 1 < cmod a then [:- 1, cnj a:]\n                              else [:- a, 1:])) =\n  (\\<Prod>a\\<leftarrow>complex_roots_complex f. max 1 (cmod a))\n\ngoal (1 subgoal):\n 1. cmod (lead_coeff f) *\n    (\\<Prod>a\\<leftarrow>complex_roots_complex f. max 1 (cmod a))\n    \\<le> l2norm_complex f", "by auto"], ["proof (state)\nthis:\n  cmod (lead_coeff f) *\n  (\\<Prod>a\\<leftarrow>complex_roots_complex f. max 1 (cmod a))\n  \\<le> l2norm_complex f\n\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "thus \"mahler_measure_poly f \\<le> sqrt (norm2 f)\""], ["proof (prove)\nusing this:\n  cmod (lead_coeff f) *\n  (\\<Prod>a\\<leftarrow>complex_roots_complex f. max 1 (cmod a))\n  \\<le> l2norm_complex f\n\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "using reconstruct_with_type_conversion[unfolded complex_roots_int_def]"], ["proof (prove)\nusing this:\n  cmod (lead_coeff f) *\n  (\\<Prod>a\\<leftarrow>complex_roots_complex f. max 1 (cmod a))\n  \\<le> l2norm_complex f\n  Polynomial.smult (lead_coeff (of_int_poly ?f))\n   (\\<Prod>a\\<leftarrow>complex_roots_complex\n                         (of_int_poly ?f). [:- a, 1:]) =\n  of_int_poly ?f\n\ngoal (1 subgoal):\n 1. mahler_measure_poly f \\<le> l2norm_complex f", "by (simp add: mahler_measure_poly_via_monic mahler_measure_monic_def complex_roots_int_def)"], ["proof (state)\nthis:\n  mahler_measure_poly f \\<le> l2norm_complex f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_list_ge1:\n  assumes \"Ball (set x) (\\<lambda> (a::real). a \\<ge> 1)\"\n  shows \"prod_list x \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> prod_list x", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set x. 1 \\<le> a\n\ngoal (1 subgoal):\n 1. 1 \\<le> prod_list x", "proof(induct x)"], ["proof (state)\ngoal (2 subgoals):\n 1. Ball (set []) ((\\<le>) 1) \\<Longrightarrow> 1 \\<le> prod_list []\n 2. \\<And>a x.\n       \\<lbrakk>Ball (set x) ((\\<le>) 1) \\<Longrightarrow>\n                1 \\<le> prod_list x;\n        Ball (set (a # x)) ((\\<le>) 1)\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> prod_list (a # x)", "case (Cons a as)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set as. 1 \\<le> a \\<Longrightarrow> 1 \\<le> prod_list as\n  \\<forall>a\\<in>set (a # as). 1 \\<le> a\n\ngoal (2 subgoals):\n 1. Ball (set []) ((\\<le>) 1) \\<Longrightarrow> 1 \\<le> prod_list []\n 2. \\<And>a x.\n       \\<lbrakk>Ball (set x) ((\\<le>) 1) \\<Longrightarrow>\n                1 \\<le> prod_list x;\n        Ball (set (a # x)) ((\\<le>) 1)\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> prod_list (a # x)", "have \"\\<forall>a\\<in>set as. 1 \\<le> a\" \"1 \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set as. 1 \\<le> a &&& 1 \\<le> a", "using Cons(2)"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # as). 1 \\<le> a\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set as. 1 \\<le> a &&& 1 \\<le> a", "by auto"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set as. 1 \\<le> a\n  1 \\<le> a\n\ngoal (2 subgoals):\n 1. Ball (set []) ((\\<le>) 1) \\<Longrightarrow> 1 \\<le> prod_list []\n 2. \\<And>a x.\n       \\<lbrakk>Ball (set x) ((\\<le>) 1) \\<Longrightarrow>\n                1 \\<le> prod_list x;\n        Ball (set (a # x)) ((\\<le>) 1)\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> prod_list (a # x)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set as. 1 \\<le> a\n  1 \\<le> a\n\ngoal (1 subgoal):\n 1. 1 \\<le> prod_list (a # as)", "using Cons.hyps mult_mono'"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set as. 1 \\<le> a\n  1 \\<le> a\n  \\<forall>a\\<in>set as. 1 \\<le> a \\<Longrightarrow> 1 \\<le> prod_list as\n  \\<lbrakk>?a \\<le> ?b; ?c \\<le> ?d; (0::?'a) \\<le> ?a;\n   (0::?'a) \\<le> ?c\\<rbrakk>\n  \\<Longrightarrow> ?a * ?c \\<le> ?b * ?d\n\ngoal (1 subgoal):\n 1. 1 \\<le> prod_list (a # as)", "by fastforce"], ["proof (state)\nthis:\n  1 \\<le> prod_list (a # as)\n\ngoal (1 subgoal):\n 1. Ball (set []) ((\\<le>) 1) \\<Longrightarrow> 1 \\<le> prod_list []", "qed auto"], ["", "lemma mahler_measure_monic_ge_1: \"mahler_measure_monic p \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> mahler_measure_monic p", "unfolding mahler_measure_monic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> (\\<Prod>a\\<leftarrow>complex_roots_complex p. max 1 (cmod a))", "by(rule prod_list_ge1,simp)"], ["", "lemma mahler_measure_monic_ge_0: \"mahler_measure_monic p \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> mahler_measure_monic p", "using mahler_measure_monic_ge_1 le_numeral_extra(1) order_trans"], ["proof (prove)\nusing this:\n  1 \\<le> mahler_measure_monic ?p\n  (0::?'a) \\<le> (1::?'a)\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. 0 \\<le> mahler_measure_monic p", "by blast"], ["", "lemma mahler_measure_ge_0: \"0 \\<le> mahler_measure h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> mahler_measure h", "unfolding mahler_measure_def mahler_measure_poly_via_monic"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cmod (lead_coeff (of_int_poly h)) *\n            mahler_measure_monic (of_int_poly h)", "by (simp add: mahler_measure_monic_ge_0)"], ["", "lemma mahler_measure_constant[simp]: \"mahler_measure_poly [:c:] = cmod c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly [:c:] = cmod c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure_poly [:c:] = cmod c", "have main: \"complex_roots_complex [:c:] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_roots_complex [:c:] = []", "unfolding complex_roots_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME as.\n        Polynomial.smult (lead_coeff [:c:])\n         (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) =\n        [:c:] \\<and>\n        length as = degree [:c:]) =\n    []", "by (rule some_equality, auto)"], ["proof (state)\nthis:\n  complex_roots_complex [:c:] = []\n\ngoal (1 subgoal):\n 1. mahler_measure_poly [:c:] = cmod c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly [:c:] = cmod c", "unfolding mahler_measure_poly_def main"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (lead_coeff [:c:]) * (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a)) =\n    cmod c", "by auto"], ["proof (state)\nthis:\n  mahler_measure_poly [:c:] = cmod c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mahler_measure_factor[simplified,simp]: \"mahler_measure_poly [:- a, 1:] = max 1 (cmod a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly [:- a, 1:] = max 1 (cmod a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure_poly [:- a, 1:] = max 1 (cmod a)", "have main: \"complex_roots_complex [:- a, 1:] = [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_roots_complex [:- a, 1:] = [a]", "unfolding complex_roots_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME as.\n        Polynomial.smult (lead_coeff [:- a, 1:])\n         (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) =\n        [:- a, 1:] \\<and>\n        length as = degree [:- a, 1:]) =\n    [a]", "proof (rule some_equality, auto, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>(\\<Prod>a\\<leftarrow>as. pCons (- a) 1) = pCons (- a) 1;\n        length as = Suc 0\\<rbrakk>\n       \\<Longrightarrow> as = [a]", "case (1 as)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as. pCons (- a) 1) = pCons (- a) 1\n  length as = Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>(\\<Prod>a\\<leftarrow>as. pCons (- a) 1) = pCons (- a) 1;\n        length as = Suc 0\\<rbrakk>\n       \\<Longrightarrow> as = [a]", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<Prod>a\\<leftarrow>as. pCons (- a) 1) = pCons (- a) 1\n  length as = Suc 0\n\ngoal (1 subgoal):\n 1. as = [a]", "by (cases as, auto)"], ["proof (state)\nthis:\n  as = [a]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  complex_roots_complex [:- a, 1:] = [a]\n\ngoal (1 subgoal):\n 1. mahler_measure_poly [:- a, 1:] = max 1 (cmod a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly [:- a, 1:] = max 1 (cmod a)", "unfolding mahler_measure_poly_def main"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (lead_coeff [:- a, 1:]) *\n    (\\<Prod>a\\<leftarrow>[a]. max 1 (cmod a)) =\n    max 1 (cmod a)", "by auto"], ["proof (state)\nthis:\n  mahler_measure_poly [:- a, 1:] = max 1 (cmod a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mahler_measure_poly_explicit: \"mahler_measure_poly (smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:]))\n  = cmod c * (\\<Prod>a\\<leftarrow>as. (max 1 (cmod a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))", "proof (cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))", "case True"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))", "by auto"], ["proof (state)\nthis:\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n  cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))", "note c = this"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))", "proof (induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>[]. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a))\n 2. \\<And>a as.\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) \\<Longrightarrow>\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>a # as. max 1 (cmod a))", "case (Cons a as)"], ["proof (state)\nthis:\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n  cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))\n\ngoal (2 subgoals):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>[]. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a))\n 2. \\<And>a as.\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) \\<Longrightarrow>\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>a # as. max 1 (cmod a))", "have \"mahler_measure_poly (smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:]))\n      = mahler_measure_poly (smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) * [: -a, 1 :])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:])) =\n    mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) * [:- a, 1:])", "by (rule arg_cong[of _ _ mahler_measure_poly], unfold list.simps prod_list.Cons mult_smult_left, simp)"], ["proof (state)\nthis:\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:])) =\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) * [:- a, 1:])\n\ngoal (2 subgoals):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>[]. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a))\n 2. \\<And>a as.\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) \\<Longrightarrow>\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>a # as. max 1 (cmod a))", "also"], ["proof (state)\nthis:\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:])) =\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) * [:- a, 1:])\n\ngoal (2 subgoals):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>[]. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a))\n 2. \\<And>a as.\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) \\<Longrightarrow>\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>a # as. max 1 (cmod a))", "have \"\\<dots> = mahler_measure_poly (smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) * mahler_measure_poly ([:- a, 1:])\" \n      (is \"_ = ?l * ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) *\n      [:- a, 1:]) =\n    mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) *\n    mahler_measure_poly [:- a, 1:]", "by (rule measure_eq_prod)"], ["proof (state)\nthis:\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) * [:- a, 1:]) =\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) *\n  mahler_measure_poly [:- a, 1:]\n\ngoal (2 subgoals):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>[]. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a))\n 2. \\<And>a as.\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) \\<Longrightarrow>\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>a # as. max 1 (cmod a))", "also"], ["proof (state)\nthis:\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) * [:- a, 1:]) =\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) *\n  mahler_measure_poly [:- a, 1:]\n\ngoal (2 subgoals):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>[]. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a))\n 2. \\<And>a as.\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) \\<Longrightarrow>\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>a # as. max 1 (cmod a))", "have \"?l = cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))", "unfolding Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) =\n    cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))", "by simp"], ["proof (state)\nthis:\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n  cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))\n\ngoal (2 subgoals):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>[]. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a))\n 2. \\<And>a as.\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) \\<Longrightarrow>\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>a # as. max 1 (cmod a))", "also"], ["proof (state)\nthis:\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n  cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))\n\ngoal (2 subgoals):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>[]. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a))\n 2. \\<And>a as.\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) \\<Longrightarrow>\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>a # as. max 1 (cmod a))", "have \"?r = max 1 (cmod a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly [:- a, 1:] = max 1 (cmod a)", "by simp"], ["proof (state)\nthis:\n  mahler_measure_poly [:- a, 1:] = max 1 (cmod a)\n\ngoal (2 subgoals):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>[]. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a))\n 2. \\<And>a as.\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) \\<Longrightarrow>\n       mahler_measure_poly\n        (Polynomial.smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:])) =\n       cmod c * (\\<Prod>a\\<leftarrow>a # as. max 1 (cmod a))", "finally"], ["proof (chain)\npicking this:\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:])) =\n  cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) * max 1 (cmod a)", "show ?case"], ["proof (prove)\nusing this:\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:])) =\n  cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) * max 1 (cmod a)\n\ngoal (1 subgoal):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>a # as. max 1 (cmod a))", "by simp"], ["proof (state)\nthis:\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>a # as. [:- a, 1:])) =\n  cmod c * (\\<Prod>a\\<leftarrow>a # as. max 1 (cmod a))\n\ngoal (1 subgoal):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>[]. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>[]. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>[]. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly\n     (Polynomial.smult c (\\<Prod>a\\<leftarrow>[]. [:- a, 1:])) =\n    cmod c * (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a))", "by simp"], ["proof (state)\nthis:\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>[]. [:- a, 1:])) =\n  cmod c * (\\<Prod>a\\<leftarrow>[]. max 1 (cmod a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mahler_measure_poly\n   (Polynomial.smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])) =\n  cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mahler_measure_poly_ge_1:\n  assumes \"h \\<noteq> 0\"\n  shows \"(1::real) \\<le> mahler_measure h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> mahler_measure h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> mahler_measure h", "have rc: \"\\<bar>real_of_int i\\<bar> = of_int \\<bar>i\\<bar>\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real_of_int i\\<bar> = real_of_int \\<bar>i\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>real_of_int ?i\\<bar> = real_of_int \\<bar>?i\\<bar>\n\ngoal (1 subgoal):\n 1. 1 \\<le> mahler_measure h", "from assms"], ["proof (chain)\npicking this:\n  h \\<noteq> 0", "have \"cmod (lead_coeff (map_poly complex_of_int h)) > 0\""], ["proof (prove)\nusing this:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < cmod (lead_coeff (of_int_poly h))", "by simp"], ["proof (state)\nthis:\n  0 < cmod (lead_coeff (of_int_poly h))\n\ngoal (1 subgoal):\n 1. 1 \\<le> mahler_measure h", "hence \"cmod (lead_coeff (map_poly complex_of_int h)) \\<ge> 1\""], ["proof (prove)\nusing this:\n  0 < cmod (lead_coeff (of_int_poly h))\n\ngoal (1 subgoal):\n 1. 1 \\<le> cmod (lead_coeff (of_int_poly h))", "by(cases \"lead_coeff h = 0\", auto simp del: leading_coeff_0_iff)"], ["proof (state)\nthis:\n  1 \\<le> cmod (lead_coeff (of_int_poly h))\n\ngoal (1 subgoal):\n 1. 1 \\<le> mahler_measure h", "from mult_mono[OF this mahler_measure_monic_ge_1 norm_ge_zero]"], ["proof (chain)\npicking this:\n  0 \\<le> 1 \\<Longrightarrow>\n  1 * 1 \\<le> cmod (lead_coeff (of_int_poly h)) * mahler_measure_monic ?p2", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> 1 \\<Longrightarrow>\n  1 * 1 \\<le> cmod (lead_coeff (of_int_poly h)) * mahler_measure_monic ?p2\n\ngoal (1 subgoal):\n 1. 1 \\<le> mahler_measure h", "unfolding mahler_measure_def mahler_measure_poly_via_monic"], ["proof (prove)\nusing this:\n  0 \\<le> 1 \\<Longrightarrow>\n  1 * 1 \\<le> cmod (lead_coeff (of_int_poly h)) * mahler_measure_monic ?p2\n\ngoal (1 subgoal):\n 1. 1 \\<le> cmod (lead_coeff (of_int_poly h)) *\n            mahler_measure_monic (of_int_poly h)", "by auto"], ["proof (state)\nthis:\n  1 \\<le> mahler_measure h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mahler_measure_dvd: assumes \"f \\<noteq> 0\" and \"h dvd f\" \n  shows \"mahler_measure h \\<le> mahler_measure f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure h \\<le> mahler_measure f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure h \\<le> mahler_measure f", "from assms"], ["proof (chain)\npicking this:\n  f \\<noteq> 0\n  h dvd f", "obtain g where f: \"f = g * h\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  h dvd f\n\ngoal (1 subgoal):\n 1. (\\<And>g. f = g * h \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  \\<exists>k. f = h * k\n\ngoal (1 subgoal):\n 1. (\\<And>g. f = g * h \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  f = g * h\n\ngoal (1 subgoal):\n 1. mahler_measure h \\<le> mahler_measure f", "from f assms"], ["proof (chain)\npicking this:\n  f = g * h\n  f \\<noteq> 0\n  h dvd f", "have g0: \"g \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f = g * h\n  f \\<noteq> 0\n  h dvd f\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. mahler_measure h \\<le> mahler_measure f", "hence mg: \"mahler_measure g \\<ge> 1\""], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> mahler_measure g", "by (rule mahler_measure_poly_ge_1)"], ["proof (state)\nthis:\n  1 \\<le> mahler_measure g\n\ngoal (1 subgoal):\n 1. mahler_measure h \\<le> mahler_measure f", "have \"1 * mahler_measure h \\<le> mahler_measure f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * mahler_measure h \\<le> mahler_measure f", "unfolding mahler_measure_def f measure_eq_prod\n      of_int_poly_hom.hom_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * mahler_measure_poly (of_int_poly h)\n    \\<le> mahler_measure_poly (of_int_poly g) *\n          mahler_measure_poly (of_int_poly h)", "unfolding mahler_measure_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * mahler_measure h \\<le> mahler_measure g * mahler_measure h", "by (rule mult_right_mono[OF mg mahler_measure_ge_0])"], ["proof (state)\nthis:\n  1 * mahler_measure h \\<le> mahler_measure f\n\ngoal (1 subgoal):\n 1. mahler_measure h \\<le> mahler_measure f", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 * mahler_measure h \\<le> mahler_measure f\n\ngoal (1 subgoal):\n 1. mahler_measure h \\<le> mahler_measure f", "by simp"], ["proof (state)\nthis:\n  mahler_measure h \\<le> mahler_measure f\n\ngoal:\nNo subgoals!", "qed"], ["", "definition graeffe_poly :: \"'a \\<Rightarrow> 'a :: comm_ring_1 list \\<Rightarrow> nat \\<Rightarrow> 'a poly\" where\n  \"graeffe_poly c as m = smult (c ^ (2^m)) (\\<Prod>a\\<leftarrow>as. [:- (a ^ (2^m)), 1:])\""], ["", "context\n  fixes f :: \"complex poly\" and c as\n  assumes f: \"f = smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])\"\nbegin"], ["", "lemma mahler_graeffe: \"mahler_measure_poly (graeffe_poly c as m) = (mahler_measure_poly f)^(2^m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly (graeffe_poly c as m) =\n    mahler_measure_poly f ^ 2 ^ m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure_poly (graeffe_poly c as m) =\n    mahler_measure_poly f ^ 2 ^ m", "have graeffe: \"graeffe_poly c as m = smult (c ^ 2 ^ m) (\\<Prod>a\\<leftarrow>(map (\\<lambda> a. a ^ 2 ^ m) as). [:- a, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graeffe_poly c as m =\n    Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>map (\\<lambda>a. a ^ 2 ^ m) as. [:- a, 1:])", "unfolding graeffe_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1:]) =\n    Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>map (\\<lambda>a. a ^ 2 ^ m) as. [:- a, 1:])", "by (rule arg_cong[of _ _ \"smult (c ^ 2 ^ m)\"], induct as, auto)"], ["proof (state)\nthis:\n  graeffe_poly c as m =\n  Polynomial.smult (c ^ 2 ^ m)\n   (\\<Prod>a\\<leftarrow>map (\\<lambda>a. a ^ 2 ^ m) as. [:- a, 1:])\n\ngoal (1 subgoal):\n 1. mahler_measure_poly (graeffe_poly c as m) =\n    mahler_measure_poly f ^ 2 ^ m", "{"], ["proof (state)\nthis:\n  graeffe_poly c as m =\n  Polynomial.smult (c ^ 2 ^ m)\n   (\\<Prod>a\\<leftarrow>map (\\<lambda>a. a ^ 2 ^ m) as. [:- a, 1:])\n\ngoal (1 subgoal):\n 1. mahler_measure_poly (graeffe_poly c as m) =\n    mahler_measure_poly f ^ 2 ^ m", "fix n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure_poly (graeffe_poly c as m) =\n    mahler_measure_poly f ^ 2 ^ m", "assume n: \"n > 0\""], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. mahler_measure_poly (graeffe_poly c as m) =\n    mahler_measure_poly f ^ 2 ^ m", "have id: \"max 1 (cmod a ^ n) = max 1 (cmod a) ^ n\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. max 1 (cmod a ^ n) = max 1 (cmod a) ^ n", "proof (cases \"cmod a \\<le> 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. cmod a \\<le> 1 \\<Longrightarrow> max 1 (cmod a ^ n) = max 1 (cmod a) ^ n\n 2. \\<not> cmod a \\<le> 1 \\<Longrightarrow>\n    max 1 (cmod a ^ n) = max 1 (cmod a) ^ n", "case True"], ["proof (state)\nthis:\n  cmod a \\<le> 1\n\ngoal (2 subgoals):\n 1. cmod a \\<le> 1 \\<Longrightarrow> max 1 (cmod a ^ n) = max 1 (cmod a) ^ n\n 2. \\<not> cmod a \\<le> 1 \\<Longrightarrow>\n    max 1 (cmod a ^ n) = max 1 (cmod a) ^ n", "hence \"cmod a ^ n \\<le> 1\""], ["proof (prove)\nusing this:\n  cmod a \\<le> 1\n\ngoal (1 subgoal):\n 1. cmod a ^ n \\<le> 1", "by (simp add: power_le_one)"], ["proof (state)\nthis:\n  cmod a ^ n \\<le> 1\n\ngoal (2 subgoals):\n 1. cmod a \\<le> 1 \\<Longrightarrow> max 1 (cmod a ^ n) = max 1 (cmod a) ^ n\n 2. \\<not> cmod a \\<le> 1 \\<Longrightarrow>\n    max 1 (cmod a ^ n) = max 1 (cmod a) ^ n", "with True"], ["proof (chain)\npicking this:\n  cmod a \\<le> 1\n  cmod a ^ n \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod a \\<le> 1\n  cmod a ^ n \\<le> 1\n\ngoal (1 subgoal):\n 1. max 1 (cmod a ^ n) = max 1 (cmod a) ^ n", "by (simp add: max_def)"], ["proof (state)\nthis:\n  max 1 (cmod a ^ n) = max 1 (cmod a) ^ n\n\ngoal (1 subgoal):\n 1. \\<not> cmod a \\<le> 1 \\<Longrightarrow>\n    max 1 (cmod a ^ n) = max 1 (cmod a) ^ n", "qed (auto simp: max_def)"], ["proof (state)\nthis:\n  max 1 (cmod ?a ^ n) = max 1 (cmod ?a) ^ n\n\ngoal (1 subgoal):\n 1. mahler_measure_poly (graeffe_poly c as m) =\n    mahler_measure_poly f ^ 2 ^ m", "have \"(\\<Prod>x\\<leftarrow>as. max 1 (cmod x ^ n)) = (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>as. max 1 (cmod x ^ n)) =\n    (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) ^ n", "by (induct as, auto simp: field_simps n id)"], ["proof (state)\nthis:\n  (\\<Prod>x\\<leftarrow>as. max 1 (cmod x ^ n)) =\n  (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) ^ n\n\ngoal (1 subgoal):\n 1. mahler_measure_poly (graeffe_poly c as m) =\n    mahler_measure_poly f ^ 2 ^ m", "}"], ["proof (state)\nthis:\n  0 < ?n2 \\<Longrightarrow>\n  (\\<Prod>x\\<leftarrow>as. max 1 (cmod x ^ ?n2)) =\n  (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) ^ ?n2\n\ngoal (1 subgoal):\n 1. mahler_measure_poly (graeffe_poly c as m) =\n    mahler_measure_poly f ^ 2 ^ m", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < ?n2 \\<Longrightarrow>\n  (\\<Prod>x\\<leftarrow>as. max 1 (cmod x ^ ?n2)) =\n  (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) ^ ?n2\n\ngoal (1 subgoal):\n 1. mahler_measure_poly (graeffe_poly c as m) =\n    mahler_measure_poly f ^ 2 ^ m", "unfolding f mahler_measure_poly_explicit graeffe"], ["proof (prove)\nusing this:\n  0 < ?n2 \\<Longrightarrow>\n  (\\<Prod>x\\<leftarrow>as. max 1 (cmod x ^ ?n2)) =\n  (\\<Prod>a\\<leftarrow>as. max 1 (cmod a)) ^ ?n2\n\ngoal (1 subgoal):\n 1. cmod (c ^ 2 ^ m) *\n    (\\<Prod>a\\<leftarrow>map (\\<lambda>a. a ^ 2 ^ m) as. max 1 (cmod a)) =\n    (cmod c * (\\<Prod>a\\<leftarrow>as. max 1 (cmod a))) ^ 2 ^ m", "by (auto simp: o_def field_simps norm_power)"], ["proof (state)\nthis:\n  mahler_measure_poly (graeffe_poly c as m) = mahler_measure_poly f ^ 2 ^ m\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "fun drop_half :: \"'a list \\<Rightarrow> 'a list\" where\n  \"drop_half (x # y # ys) = x # drop_half ys\" \n| \"drop_half xs = xs\""], ["", "fun alternate :: \"'a list \\<Rightarrow> 'a list \\<times> 'a list\" where\n  \"alternate (x # y # ys) = (case alternate ys of (evn, od) \\<Rightarrow> (x # evn, y # od))\" \n| \"alternate xs = (xs,[])\""], ["", "definition poly_square_subst :: \"'a :: comm_ring_1 poly \\<Rightarrow> 'a poly\" where\n  \"poly_square_subst f = poly_of_list (drop_half (coeffs f))\""], ["", "definition poly_even_odd :: \"'a :: comm_ring_1 poly \\<Rightarrow> 'a poly \\<times> 'a poly\" where\n  \"poly_even_odd f = (case alternate (coeffs f) of (evn,od) \\<Rightarrow> (poly_of_list evn, poly_of_list od))\""], ["", "lemma poly_square_subst_coeff: \"coeff (poly_square_subst f) i = coeff f (2 * i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (poly_square_subst f) i = poly.coeff f (2 * i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly.coeff (poly_square_subst f) i = poly.coeff f (2 * i)", "have id: \"coeff f (2 * i) = coeff (Poly (coeffs f)) (2 * i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff f (2 * i) = poly.coeff (Poly (coeffs f)) (2 * i)", "by simp"], ["proof (state)\nthis:\n  poly.coeff f (2 * i) = poly.coeff (Poly (coeffs f)) (2 * i)\n\ngoal (1 subgoal):\n 1. poly.coeff (poly_square_subst f) i = poly.coeff f (2 * i)", "obtain xs where xs: \"coeffs f = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs. coeffs f = xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  coeffs f = xs\n\ngoal (1 subgoal):\n 1. poly.coeff (poly_square_subst f) i = poly.coeff f (2 * i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (poly_square_subst f) i = poly.coeff f (2 * i)", "unfolding poly_square_subst_def poly_of_list_def coeff_Poly_eq id xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default (0::'a) (drop_half xs) i = nth_default (0::'a) xs (2 * i)", "proof (induct xs arbitrary: i rule: drop_half.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y ys i.\n       (\\<And>i.\n           nth_default (0::'a) (drop_half ys) i =\n           nth_default (0::'a) ys (2 * i)) \\<Longrightarrow>\n       nth_default (0::'a) (drop_half (x # y # ys)) i =\n       nth_default (0::'a) (x # y # ys) (2 * i)\n 2. \\<And>i.\n       nth_default (0::'a) (drop_half []) i = nth_default (0::'a) [] (2 * i)\n 3. \\<And>v i.\n       nth_default (0::'a) (drop_half [v]) i =\n       nth_default (0::'a) [v] (2 * i)", "case (1 x y ys i)"], ["proof (state)\nthis:\n  nth_default (0::'a) (drop_half ys) ?i = nth_default (0::'a) ys (2 * ?i)\n\ngoal (3 subgoals):\n 1. \\<And>x y ys i.\n       (\\<And>i.\n           nth_default (0::'a) (drop_half ys) i =\n           nth_default (0::'a) ys (2 * i)) \\<Longrightarrow>\n       nth_default (0::'a) (drop_half (x # y # ys)) i =\n       nth_default (0::'a) (x # y # ys) (2 * i)\n 2. \\<And>i.\n       nth_default (0::'a) (drop_half []) i = nth_default (0::'a) [] (2 * i)\n 3. \\<And>v i.\n       nth_default (0::'a) (drop_half [v]) i =\n       nth_default (0::'a) [v] (2 * i)", "thus ?case"], ["proof (prove)\nusing this:\n  nth_default (0::'a) (drop_half ys) ?i = nth_default (0::'a) ys (2 * ?i)\n\ngoal (1 subgoal):\n 1. nth_default (0::'a) (drop_half (x # y # ys)) i =\n    nth_default (0::'a) (x # y # ys) (2 * i)", "by (cases i, auto)"], ["proof (state)\nthis:\n  nth_default (0::'a) (drop_half (x # y # ys)) i =\n  nth_default (0::'a) (x # y # ys) (2 * i)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       nth_default (0::'a) (drop_half []) i = nth_default (0::'a) [] (2 * i)\n 2. \\<And>v i.\n       nth_default (0::'a) (drop_half [v]) i =\n       nth_default (0::'a) [v] (2 * i)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       nth_default (0::'a) (drop_half []) i = nth_default (0::'a) [] (2 * i)\n 2. \\<And>v i.\n       nth_default (0::'a) (drop_half [v]) i =\n       nth_default (0::'a) [v] (2 * i)", "case (\"2_2\" x i)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>i.\n       nth_default (0::'a) (drop_half []) i = nth_default (0::'a) [] (2 * i)\n 2. \\<And>v i.\n       nth_default (0::'a) (drop_half [v]) i =\n       nth_default (0::'a) [v] (2 * i)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default (0::'a) (drop_half [x]) i = nth_default (0::'a) [x] (2 * i)", "by (cases i, auto)"], ["proof (state)\nthis:\n  nth_default (0::'a) (drop_half [x]) i = nth_default (0::'a) [x] (2 * i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       nth_default (0::'a) (drop_half []) i = nth_default (0::'a) [] (2 * i)", "qed auto"], ["proof (state)\nthis:\n  poly.coeff (poly_square_subst f) i = poly.coeff f (2 * i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_even_odd_coeff: assumes \"poly_even_odd f = (ev,od)\"\n  shows \"coeff ev i = coeff f (2 * i)\" \"coeff od i = coeff f (2 * i + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff ev i = poly.coeff f (2 * i) &&&\n    poly.coeff od i = poly.coeff f (2 * i + 1)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. poly.coeff ev i = poly.coeff f (2 * i)\n 2. poly.coeff od i = poly.coeff f (2 * i + 1)", "have id: \"\\<And> i. coeff f i = coeff (Poly (coeffs f)) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. poly.coeff f i = poly.coeff (Poly (coeffs f)) i", "by simp"], ["proof (state)\nthis:\n  poly.coeff f ?i = poly.coeff (Poly (coeffs f)) ?i\n\ngoal (2 subgoals):\n 1. poly.coeff ev i = poly.coeff f (2 * i)\n 2. poly.coeff od i = poly.coeff f (2 * i + 1)", "obtain xs where xs: \"coeffs f = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs. coeffs f = xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  coeffs f = xs\n\ngoal (2 subgoals):\n 1. poly.coeff ev i = poly.coeff f (2 * i)\n 2. poly.coeff od i = poly.coeff f (2 * i + 1)", "from assms[unfolded poly_even_odd_def]"], ["proof (chain)\npicking this:\n  (case alternate (coeffs f) of\n   (evn, od) \\<Rightarrow> (poly_of_list evn, poly_of_list od)) =\n  (ev, od)", "have ev_od: \"ev = Poly (fst (alternate xs))\" \"od = Poly (snd (alternate xs))\""], ["proof (prove)\nusing this:\n  (case alternate (coeffs f) of\n   (evn, od) \\<Rightarrow> (poly_of_list evn, poly_of_list od)) =\n  (ev, od)\n\ngoal (1 subgoal):\n 1. ev = Poly (fst (alternate xs)) &&& od = Poly (snd (alternate xs))", "by (auto simp: xs split: prod.splits)"], ["proof (state)\nthis:\n  ev = Poly (fst (alternate xs))\n  od = Poly (snd (alternate xs))\n\ngoal (2 subgoals):\n 1. poly.coeff ev i = poly.coeff f (2 * i)\n 2. poly.coeff od i = poly.coeff f (2 * i + 1)", "have \"coeff ev i = coeff f (2 * i) \\<and> coeff od i = coeff f (2 * i + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff ev i = poly.coeff f (2 * i) \\<and>\n    poly.coeff od i = poly.coeff f (2 * i + 1)", "unfolding poly_of_list_def coeff_Poly_eq id xs ev_od"], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default (0::'a) (fst (alternate xs)) i =\n    nth_default (0::'a) xs (2 * i) \\<and>\n    nth_default (0::'a) (snd (alternate xs)) i =\n    nth_default (0::'a) xs (2 * i + 1)", "proof (induct xs arbitrary: i rule: alternate.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y ys i.\n       (\\<And>i.\n           nth_default (0::'a) (fst (alternate ys)) i =\n           nth_default (0::'a) ys (2 * i) \\<and>\n           nth_default (0::'a) (snd (alternate ys)) i =\n           nth_default (0::'a) ys (2 * i + 1)) \\<Longrightarrow>\n       nth_default (0::'a) (fst (alternate (x # y # ys))) i =\n       nth_default (0::'a) (x # y # ys) (2 * i) \\<and>\n       nth_default (0::'a) (snd (alternate (x # y # ys))) i =\n       nth_default (0::'a) (x # y # ys) (2 * i + 1)\n 2. \\<And>i.\n       nth_default (0::'a) (fst (alternate [])) i =\n       nth_default (0::'a) [] (2 * i) \\<and>\n       nth_default (0::'a) (snd (alternate [])) i =\n       nth_default (0::'a) [] (2 * i + 1)\n 3. \\<And>v i.\n       nth_default (0::'a) (fst (alternate [v])) i =\n       nth_default (0::'a) [v] (2 * i) \\<and>\n       nth_default (0::'a) (snd (alternate [v])) i =\n       nth_default (0::'a) [v] (2 * i + 1)", "case (1 x y ys i)"], ["proof (state)\nthis:\n  nth_default (0::'a) (fst (alternate ys)) ?i =\n  nth_default (0::'a) ys (2 * ?i) \\<and>\n  nth_default (0::'a) (snd (alternate ys)) ?i =\n  nth_default (0::'a) ys (2 * ?i + 1)\n\ngoal (3 subgoals):\n 1. \\<And>x y ys i.\n       (\\<And>i.\n           nth_default (0::'a) (fst (alternate ys)) i =\n           nth_default (0::'a) ys (2 * i) \\<and>\n           nth_default (0::'a) (snd (alternate ys)) i =\n           nth_default (0::'a) ys (2 * i + 1)) \\<Longrightarrow>\n       nth_default (0::'a) (fst (alternate (x # y # ys))) i =\n       nth_default (0::'a) (x # y # ys) (2 * i) \\<and>\n       nth_default (0::'a) (snd (alternate (x # y # ys))) i =\n       nth_default (0::'a) (x # y # ys) (2 * i + 1)\n 2. \\<And>i.\n       nth_default (0::'a) (fst (alternate [])) i =\n       nth_default (0::'a) [] (2 * i) \\<and>\n       nth_default (0::'a) (snd (alternate [])) i =\n       nth_default (0::'a) [] (2 * i + 1)\n 3. \\<And>v i.\n       nth_default (0::'a) (fst (alternate [v])) i =\n       nth_default (0::'a) [v] (2 * i) \\<and>\n       nth_default (0::'a) (snd (alternate [v])) i =\n       nth_default (0::'a) [v] (2 * i + 1)", "thus ?case"], ["proof (prove)\nusing this:\n  nth_default (0::'a) (fst (alternate ys)) ?i =\n  nth_default (0::'a) ys (2 * ?i) \\<and>\n  nth_default (0::'a) (snd (alternate ys)) ?i =\n  nth_default (0::'a) ys (2 * ?i + 1)\n\ngoal (1 subgoal):\n 1. nth_default (0::'a) (fst (alternate (x # y # ys))) i =\n    nth_default (0::'a) (x # y # ys) (2 * i) \\<and>\n    nth_default (0::'a) (snd (alternate (x # y # ys))) i =\n    nth_default (0::'a) (x # y # ys) (2 * i + 1)", "by (cases \"alternate ys\"; cases i, auto)"], ["proof (state)\nthis:\n  nth_default (0::'a) (fst (alternate (x # y # ys))) i =\n  nth_default (0::'a) (x # y # ys) (2 * i) \\<and>\n  nth_default (0::'a) (snd (alternate (x # y # ys))) i =\n  nth_default (0::'a) (x # y # ys) (2 * i + 1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       nth_default (0::'a) (fst (alternate [])) i =\n       nth_default (0::'a) [] (2 * i) \\<and>\n       nth_default (0::'a) (snd (alternate [])) i =\n       nth_default (0::'a) [] (2 * i + 1)\n 2. \\<And>v i.\n       nth_default (0::'a) (fst (alternate [v])) i =\n       nth_default (0::'a) [v] (2 * i) \\<and>\n       nth_default (0::'a) (snd (alternate [v])) i =\n       nth_default (0::'a) [v] (2 * i + 1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       nth_default (0::'a) (fst (alternate [])) i =\n       nth_default (0::'a) [] (2 * i) \\<and>\n       nth_default (0::'a) (snd (alternate [])) i =\n       nth_default (0::'a) [] (2 * i + 1)\n 2. \\<And>v i.\n       nth_default (0::'a) (fst (alternate [v])) i =\n       nth_default (0::'a) [v] (2 * i) \\<and>\n       nth_default (0::'a) (snd (alternate [v])) i =\n       nth_default (0::'a) [v] (2 * i + 1)", "case (\"2_2\" x i)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>i.\n       nth_default (0::'a) (fst (alternate [])) i =\n       nth_default (0::'a) [] (2 * i) \\<and>\n       nth_default (0::'a) (snd (alternate [])) i =\n       nth_default (0::'a) [] (2 * i + 1)\n 2. \\<And>v i.\n       nth_default (0::'a) (fst (alternate [v])) i =\n       nth_default (0::'a) [v] (2 * i) \\<and>\n       nth_default (0::'a) (snd (alternate [v])) i =\n       nth_default (0::'a) [v] (2 * i + 1)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default (0::'a) (fst (alternate [x])) i =\n    nth_default (0::'a) [x] (2 * i) \\<and>\n    nth_default (0::'a) (snd (alternate [x])) i =\n    nth_default (0::'a) [x] (2 * i + 1)", "by (cases i, auto)"], ["proof (state)\nthis:\n  nth_default (0::'a) (fst (alternate [x])) i =\n  nth_default (0::'a) [x] (2 * i) \\<and>\n  nth_default (0::'a) (snd (alternate [x])) i =\n  nth_default (0::'a) [x] (2 * i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       nth_default (0::'a) (fst (alternate [])) i =\n       nth_default (0::'a) [] (2 * i) \\<and>\n       nth_default (0::'a) (snd (alternate [])) i =\n       nth_default (0::'a) [] (2 * i + 1)", "qed auto"], ["proof (state)\nthis:\n  poly.coeff ev i = poly.coeff f (2 * i) \\<and>\n  poly.coeff od i = poly.coeff f (2 * i + 1)\n\ngoal (2 subgoals):\n 1. poly.coeff ev i = poly.coeff f (2 * i)\n 2. poly.coeff od i = poly.coeff f (2 * i + 1)", "thus \"coeff ev i = coeff f (2 * i)\" \"coeff od i = coeff f (2 * i + 1)\""], ["proof (prove)\nusing this:\n  poly.coeff ev i = poly.coeff f (2 * i) \\<and>\n  poly.coeff od i = poly.coeff f (2 * i + 1)\n\ngoal (1 subgoal):\n 1. poly.coeff ev i = poly.coeff f (2 * i) &&&\n    poly.coeff od i = poly.coeff f (2 * i + 1)", "by auto"], ["proof (state)\nthis:\n  poly.coeff ev i = poly.coeff f (2 * i)\n  poly.coeff od i = poly.coeff f (2 * i + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_square_subst: \"poly_square_subst (f \\<circ>\\<^sub>p (monom 1 2)) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_square_subst (f \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) = f", "by (rule poly_eqI, unfold poly_square_subst_coeff, subst coeff_pcompose_x_pow_n, auto)"], ["", "lemma poly_even_odd: assumes \"poly_even_odd f = (g,h)\" \n  shows \"f = g \\<circ>\\<^sub>p monom 1 2 + monom 1 1 * (h \\<circ>\\<^sub>p monom 1 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f =\n    g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n    Polynomial.monom (1::'a) 1 *\n    h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f =\n    g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n    Polynomial.monom (1::'a) 1 *\n    h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2", "note id = poly_even_odd_coeff[OF assms]"], ["proof (state)\nthis:\n  poly.coeff g ?i = poly.coeff f (2 * ?i)\n  poly.coeff h ?i = poly.coeff f (2 * ?i + 1)\n\ngoal (1 subgoal):\n 1. f =\n    g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n    Polynomial.monom (1::'a) 1 *\n    h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f =\n    g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n    Polynomial.monom (1::'a) 1 *\n    h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2", "proof (rule poly_eqI, unfold coeff_add coeff_monom_mult)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       poly.coeff f n =\n       poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n       (if 1 \\<le> n\n        then (1::'a) *\n             poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2)\n              (n - 1)\n        else (0::'a))", "fix n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       poly.coeff f n =\n       poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n       (if 1 \\<le> n\n        then (1::'a) *\n             poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2)\n              (n - 1)\n        else (0::'a))", "obtain m i where mi: \"m = n div 2\" \"i = n mod 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m i.\n        \\<lbrakk>m = n div 2; i = n mod 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  m = n div 2\n  i = n mod 2\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       poly.coeff f n =\n       poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n       (if 1 \\<le> n\n        then (1::'a) *\n             poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2)\n              (n - 1)\n        else (0::'a))", "have nmi: \"n = 2 * m + i\" \"i < 2\" \"0 < (2 :: nat)\" \"1 < (2 :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n = 2 * m + i &&& i < 2) &&& 0 < 2 &&& 1 < 2", "unfolding mi"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n = 2 * (n div 2) + n mod 2 &&& n mod 2 < 2) &&& 0 < 2 &&& 1 < 2", "by auto"], ["proof (state)\nthis:\n  n = 2 * m + i\n  i < 2\n  0 < 2\n  1 < 2\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       poly.coeff f n =\n       poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n       (if 1 \\<le> n\n        then (1::'a) *\n             poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2)\n              (n - 1)\n        else (0::'a))", "have \"(2 :: nat) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       poly.coeff f n =\n       poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n       (if 1 \\<le> n\n        then (1::'a) *\n             poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2)\n              (n - 1)\n        else (0::'a))", "show \"coeff f n = coeff (g \\<circ>\\<^sub>p monom 1 2) n + (if 1 \\<le> n then 1 * coeff (h \\<circ>\\<^sub>p monom 1 2) (n - 1) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))", "proof (cases \"i = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))\n 2. i \\<noteq> 1 \\<Longrightarrow>\n    poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))", "case True"], ["proof (state)\nthis:\n  i = 1\n\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))\n 2. i \\<noteq> 1 \\<Longrightarrow>\n    poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))", "hence id1: \"2 * m + i - 1 = 2 * m + 0\""], ["proof (prove)\nusing this:\n  i = 1\n\ngoal (1 subgoal):\n 1. 2 * m + i - 1 = 2 * m + 0", "by auto"], ["proof (state)\nthis:\n  2 * m + i - 1 = 2 * m + 0\n\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))\n 2. i \\<noteq> 1 \\<Longrightarrow>\n    poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))", "unfolding nmi id id1 coeff_pcompose_monom[OF nmi(2)] coeff_pcompose_monom[OF nmi(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff f (2 * m + i) =\n    (if i = 0 then poly.coeff f (2 * m) else (0::'a)) +\n    (if 1 \\<le> 2 * m + i\n     then (1::'a) * (if 0 = 0 then poly.coeff f (2 * m + 1) else (0::'a))\n     else (0::'a))", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff f (2 * m + 1) =\n    (if 1 = 0 then poly.coeff f (2 * m) else (0::'a)) +\n    (if 1 \\<le> 2 * m + 1\n     then (1::'a) * (if 0 = 0 then poly.coeff f (2 * m + 1) else (0::'a))\n     else (0::'a))", "by auto"], ["proof (state)\nthis:\n  poly.coeff f n =\n  poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n  (if 1 \\<le> n\n   then (1::'a) *\n        poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n   else (0::'a))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))", "with nmi"], ["proof (chain)\npicking this:\n  n = 2 * m + i\n  i < 2\n  0 < 2\n  1 < 2\n  i \\<noteq> 1", "have i0: \"i = 0\""], ["proof (prove)\nusing this:\n  n = 2 * m + i\n  i < 2\n  0 < 2\n  1 < 2\n  i \\<noteq> 1\n\ngoal (1 subgoal):\n 1. i = 0", "by auto"], ["proof (state)\nthis:\n  i = 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))", "proof (cases m)"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       poly.coeff f n =\n       poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n       (if 1 \\<le> n\n        then (1::'a) *\n             poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2)\n              (n - 1)\n        else (0::'a))", "case (Suc k)"], ["proof (state)\nthis:\n  m = Suc k\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       poly.coeff f n =\n       poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n       (if 1 \\<le> n\n        then (1::'a) *\n             poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2)\n              (n - 1)\n        else (0::'a))", "hence id1: \"2 * m + i - 1 = 2 * k + 1\""], ["proof (prove)\nusing this:\n  m = Suc k\n\ngoal (1 subgoal):\n 1. 2 * m + i - 1 = 2 * k + 1", "using i0"], ["proof (prove)\nusing this:\n  m = Suc k\n  i = 0\n\ngoal (1 subgoal):\n 1. 2 * m + i - 1 = 2 * k + 1", "by auto"], ["proof (state)\nthis:\n  2 * m + i - 1 = 2 * k + 1\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       poly.coeff f n =\n       poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n       (if 1 \\<le> n\n        then (1::'a) *\n             poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2)\n              (n - 1)\n        else (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))", "unfolding nmi id coeff_pcompose_monom[OF nmi(2)] \n          coeff_pcompose_monom[OF nmi(4)] id1"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff f (2 * m + i) =\n    (if i = 0 then poly.coeff f (2 * m) else (0::'a)) +\n    (if 1 \\<le> 2 * m + i\n     then (1::'a) * (if 1 = 0 then poly.coeff f (2 * k + 1) else (0::'a))\n     else (0::'a))", "unfolding Suc i0"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff f (2 * Suc k + 0) =\n    (if 0 = 0 then poly.coeff f (2 * Suc k) else (0::'a)) +\n    (if 1 \\<le> 2 * Suc k + 0\n     then (1::'a) * (if 1 = 0 then poly.coeff f (2 * k + 1) else (0::'a))\n     else (0::'a))", "by auto"], ["proof (state)\nthis:\n  poly.coeff f n =\n  poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n  (if 1 \\<le> n\n   then (1::'a) *\n        poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n   else (0::'a))\n\ngoal (1 subgoal):\n 1. m = 0 \\<Longrightarrow>\n    poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m = 0 \\<Longrightarrow>\n    poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))", "case 0"], ["proof (state)\nthis:\n  m = 0\n\ngoal (1 subgoal):\n 1. m = 0 \\<Longrightarrow>\n    poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff f n =\n    poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n    (if 1 \\<le> n\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n     else (0::'a))", "unfolding nmi id coeff_pcompose_monom[OF nmi(2)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff f (2 * m + i) =\n    (if i = 0 then poly.coeff f (2 * m) else (0::'a)) +\n    (if 1 \\<le> 2 * m + i\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2)\n           (2 * m + i - 1)\n     else (0::'a))", "unfolding i0 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff f (2 * 0 + 0) =\n    (if 0 = 0 then poly.coeff f (2 * 0) else (0::'a)) +\n    (if 1 \\<le> 2 * 0 + 0\n     then (1::'a) *\n          poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2)\n           (2 * 0 + 0 - 1)\n     else (0::'a))", "by auto"], ["proof (state)\nthis:\n  poly.coeff f n =\n  poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n  (if 1 \\<le> n\n   then (1::'a) *\n        poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n   else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly.coeff f n =\n  poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n  (if 1 \\<le> n\n   then (1::'a) *\n        poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n   else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly.coeff f n =\n  poly.coeff (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) n +\n  (if 1 \\<le> n\n   then (1::'a) *\n        poly.coeff (h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) (n - 1)\n   else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f =\n  g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n  Polynomial.monom (1::'a) 1 * h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes f :: \"'a :: idom poly\" \nbegin"], ["", "lemma graeffe_0: \"f = smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<Longrightarrow> graeffe_poly c as 0 = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f =\n    Polynomial.smult c\n     (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) \\<Longrightarrow>\n    graeffe_poly c as 0 = f", "unfolding graeffe_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f =\n    Polynomial.smult c\n     (\\<Prod>a\\<leftarrow>as. [:- a, 1::'a:]) \\<Longrightarrow>\n    Polynomial.smult (c ^ 2 ^ 0)\n     (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ 0), 1::'a:]) =\n    f", "by auto"], ["", "lemma graeffe_recursion: assumes \"graeffe_poly c as m = f\"\n  shows \"graeffe_poly c as (Suc m) = smult ((-1)^(degree f)) (poly_square_subst (f * f \\<circ>\\<^sub>p [:0,-1:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "let ?g = \"graeffe_poly c as m\""], ["proof (state)\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "have \"f * f \\<circ>\\<^sub>p [:0,-1:] = ?g * ?g \\<circ>\\<^sub>p [:0,-1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n    graeffe_poly c as m *\n    graeffe_poly c as m \\<circ>\\<^sub>p [:0::'a, - (1::'a):]", "unfolding assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n    f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]", "by simp"], ["proof (state)\nthis:\n  f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  graeffe_poly c as m *\n  graeffe_poly c as m \\<circ>\\<^sub>p [:0::'a, - (1::'a):]\n\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "also"], ["proof (state)\nthis:\n  f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  graeffe_poly c as m *\n  graeffe_poly c as m \\<circ>\\<^sub>p [:0::'a, - (1::'a):]\n\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "have \"?g \\<circ>\\<^sub>p [:0,-1:] = smult ((- 1) ^ length as) (smult (c ^ 2 ^ m) (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graeffe_poly c as m \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))", "unfolding graeffe_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))", "proof (induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length [])\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]))\n 2. \\<And>a as.\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length as)\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) \\<Longrightarrow>\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>a #\n                             as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length (a # as))\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))", "case (Cons a as)"], ["proof (state)\nthis:\n  Polynomial.smult (c ^ 2 ^ m)\n   (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n  [:0::'a, - (1::'a):] =\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))\n\ngoal (2 subgoals):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length [])\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]))\n 2. \\<And>a as.\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length as)\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) \\<Longrightarrow>\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>a #\n                             as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length (a # as))\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))", "have \"?case = ((smult (c ^ 2 ^ m) ([:- (a ^ 2 ^ m), 1:] \\<circ>\\<^sub>p [:0, - 1:] * (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1:]) \\<circ>\\<^sub>p [:0, - 1:]) =\n     smult (-1 * (- 1) ^ length as)\n      (smult (c ^ 2 ^ m) ([: a ^ 2 ^ m, 1:] * (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1:])))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Polynomial.smult (c ^ 2 ^ m)\n      (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n     [:0::'a, - (1::'a):] =\n     Polynomial.smult ((- (1::'a)) ^ length (a # as))\n      (Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))) =\n    (Polynomial.smult (c ^ 2 ^ m)\n      ([:- (a ^ 2 ^ m), 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):] *\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):]) =\n     Polynomial.smult (- (1::'a) * (- (1::'a)) ^ length as)\n      (Polynomial.smult (c ^ 2 ^ m)\n        ([:a ^ 2 ^ m, 1::'a:] *\n         (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))))", "unfolding list.simps prod_list.Cons pcompose_smult pcompose_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Polynomial.smult (c ^ 2 ^ m)\n      ([:- (a ^ 2 ^ m), 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):] *\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):]) =\n     Polynomial.smult ((- (1::'a)) ^ length (a # as))\n      (Polynomial.smult (c ^ 2 ^ m)\n        ([:a ^ 2 ^ m, 1::'a:] *\n         (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])))) =\n    (Polynomial.smult (c ^ 2 ^ m)\n      ([:- (a ^ 2 ^ m), 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):] *\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):]) =\n     Polynomial.smult (- (1::'a) * (- (1::'a)) ^ length as)\n      (Polynomial.smult (c ^ 2 ^ m)\n        ([:a ^ 2 ^ m, 1::'a:] *\n         (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))))", "by simp"], ["proof (state)\nthis:\n  (Polynomial.smult (c ^ 2 ^ m)\n    (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n   [:0::'a, - (1::'a):] =\n   Polynomial.smult ((- (1::'a)) ^ length (a # as))\n    (Polynomial.smult (c ^ 2 ^ m)\n      (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))) =\n  (Polynomial.smult (c ^ 2 ^ m)\n    ([:- (a ^ 2 ^ m), 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):] *\n     (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n     [:0::'a, - (1::'a):]) =\n   Polynomial.smult (- (1::'a) * (- (1::'a)) ^ length as)\n    (Polynomial.smult (c ^ 2 ^ m)\n      ([:a ^ 2 ^ m, 1::'a:] *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))))\n\ngoal (2 subgoals):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length [])\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]))\n 2. \\<And>a as.\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length as)\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) \\<Longrightarrow>\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>a #\n                             as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length (a # as))\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))", "also"], ["proof (state)\nthis:\n  (Polynomial.smult (c ^ 2 ^ m)\n    (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n   [:0::'a, - (1::'a):] =\n   Polynomial.smult ((- (1::'a)) ^ length (a # as))\n    (Polynomial.smult (c ^ 2 ^ m)\n      (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))) =\n  (Polynomial.smult (c ^ 2 ^ m)\n    ([:- (a ^ 2 ^ m), 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):] *\n     (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n     [:0::'a, - (1::'a):]) =\n   Polynomial.smult (- (1::'a) * (- (1::'a)) ^ length as)\n    (Polynomial.smult (c ^ 2 ^ m)\n      ([:a ^ 2 ^ m, 1::'a:] *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))))\n\ngoal (2 subgoals):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length [])\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]))\n 2. \\<And>a as.\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length as)\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) \\<Longrightarrow>\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>a #\n                             as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length (a # as))\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))", "have \"smult (c ^ 2 ^ m) ([:- (a ^ 2 ^ m), 1:] \\<circ>\\<^sub>p [:0, - 1:] * (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1:]) \\<circ>\\<^sub>p [:0, - 1:])\n      = smult (c ^ 2 ^ m) ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1:]) \\<circ>\\<^sub>p [:0, - 1:]) * [:- (a ^ 2 ^ m), 1:] \\<circ>\\<^sub>p [:0, - 1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     ([:- (a ^ 2 ^ m), 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):] *\n      (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n      [:0::'a, - (1::'a):]) =\n    Polynomial.smult (c ^ 2 ^ m)\n     ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n      [:0::'a, - (1::'a):]) *\n    [:- (a ^ 2 ^ m), 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):]", "unfolding mult_smult_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     ([:- (a ^ 2 ^ m), 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):] *\n      (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n      [:0::'a, - (1::'a):]) =\n    Polynomial.smult (c ^ 2 ^ m)\n     ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n      [:0::'a, - (1::'a):] *\n      [:- (a ^ 2 ^ m), 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):])", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult (c ^ 2 ^ m)\n   ([:- (a ^ 2 ^ m), 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):] *\n    (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):]) =\n  Polynomial.smult (c ^ 2 ^ m)\n   ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):]) *\n  [:- (a ^ 2 ^ m), 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):]\n\ngoal (2 subgoals):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length [])\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]))\n 2. \\<And>a as.\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length as)\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) \\<Longrightarrow>\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>a #\n                             as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length (a # as))\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))", "also"], ["proof (state)\nthis:\n  Polynomial.smult (c ^ 2 ^ m)\n   ([:- (a ^ 2 ^ m), 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):] *\n    (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):]) =\n  Polynomial.smult (c ^ 2 ^ m)\n   ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):]) *\n  [:- (a ^ 2 ^ m), 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):]\n\ngoal (2 subgoals):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length [])\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]))\n 2. \\<And>a as.\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length as)\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) \\<Longrightarrow>\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>a #\n                             as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length (a # as))\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))", "have \"smult (c ^ 2 ^ m) ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1:]) \\<circ>\\<^sub>p [:0, - 1:]) = \n      smult ((- 1) ^ length as) (smult (c ^ 2 ^ m) (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n      [:0::'a, - (1::'a):]) =\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))", "unfolding pcompose_smult[symmetric] Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult ((- (1::'a)) ^ length as)\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) =\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))", ".."], ["proof (state)\nthis:\n  Polynomial.smult (c ^ 2 ^ m)\n   ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):]) =\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))\n\ngoal (2 subgoals):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length [])\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]))\n 2. \\<And>a as.\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length as)\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) \\<Longrightarrow>\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>a #\n                             as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length (a # as))\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))", "also"], ["proof (state)\nthis:\n  Polynomial.smult (c ^ 2 ^ m)\n   ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):]) =\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))\n\ngoal (2 subgoals):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length [])\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]))\n 2. \\<And>a as.\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length as)\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) \\<Longrightarrow>\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>a #\n                             as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length (a # as))\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))", "have \"[:- (a ^ 2 ^ m), 1:] \\<circ>\\<^sub>p [:0, - 1:] = smult (-1) [: a^2^m, 1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- (a ^ 2 ^ m), 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n    Polynomial.smult (- (1::'a)) [:a ^ 2 ^ m, 1::'a:]", "by simp"], ["proof (state)\nthis:\n  [:- (a ^ 2 ^ m), 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  Polynomial.smult (- (1::'a)) [:a ^ 2 ^ m, 1::'a:]\n\ngoal (2 subgoals):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length [])\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]))\n 2. \\<And>a as.\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length as)\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) \\<Longrightarrow>\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>a #\n                             as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length (a # as))\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))", "finally"], ["proof (chain)\npicking this:\n  (Polynomial.smult (c ^ 2 ^ m)\n    (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n   [:0::'a, - (1::'a):] =\n   Polynomial.smult ((- (1::'a)) ^ length (a # as))\n    (Polynomial.smult (c ^ 2 ^ m)\n      (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))) =\n  (Polynomial.smult ((- (1::'a)) ^ length as)\n    (Polynomial.smult (c ^ 2 ^ m)\n      (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) *\n   Polynomial.smult (- (1::'a)) [:a ^ 2 ^ m, 1::'a:] =\n   Polynomial.smult (- (1::'a) * (- (1::'a)) ^ length as)\n    (Polynomial.smult (c ^ 2 ^ m)\n      ([:a ^ 2 ^ m, 1::'a:] *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))))", "have id: \"?case = (smult ((- 1) ^ length as) (smult (c ^ 2 ^ m) (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1:])) * smult (- 1) [:a ^ 2 ^ m, 1:] =\n      smult (- 1 * (- 1) ^ length as) (smult (c ^ 2 ^ m) ([:a ^ 2 ^ m, 1:] * (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1:]))))\""], ["proof (prove)\nusing this:\n  (Polynomial.smult (c ^ 2 ^ m)\n    (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n   [:0::'a, - (1::'a):] =\n   Polynomial.smult ((- (1::'a)) ^ length (a # as))\n    (Polynomial.smult (c ^ 2 ^ m)\n      (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))) =\n  (Polynomial.smult ((- (1::'a)) ^ length as)\n    (Polynomial.smult (c ^ 2 ^ m)\n      (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) *\n   Polynomial.smult (- (1::'a)) [:a ^ 2 ^ m, 1::'a:] =\n   Polynomial.smult (- (1::'a) * (- (1::'a)) ^ length as)\n    (Polynomial.smult (c ^ 2 ^ m)\n      ([:a ^ 2 ^ m, 1::'a:] *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))))\n\ngoal (1 subgoal):\n 1. (Polynomial.smult (c ^ 2 ^ m)\n      (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n     [:0::'a, - (1::'a):] =\n     Polynomial.smult ((- (1::'a)) ^ length (a # as))\n      (Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))) =\n    (Polynomial.smult ((- (1::'a)) ^ length as)\n      (Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) *\n     Polynomial.smult (- (1::'a)) [:a ^ 2 ^ m, 1::'a:] =\n     Polynomial.smult (- (1::'a) * (- (1::'a)) ^ length as)\n      (Polynomial.smult (c ^ 2 ^ m)\n        ([:a ^ 2 ^ m, 1::'a:] *\n         (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))))", "by simp"], ["proof (state)\nthis:\n  (Polynomial.smult (c ^ 2 ^ m)\n    (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n   [:0::'a, - (1::'a):] =\n   Polynomial.smult ((- (1::'a)) ^ length (a # as))\n    (Polynomial.smult (c ^ 2 ^ m)\n      (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))) =\n  (Polynomial.smult ((- (1::'a)) ^ length as)\n    (Polynomial.smult (c ^ 2 ^ m)\n      (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) *\n   Polynomial.smult (- (1::'a)) [:a ^ 2 ^ m, 1::'a:] =\n   Polynomial.smult (- (1::'a) * (- (1::'a)) ^ length as)\n    (Polynomial.smult (c ^ 2 ^ m)\n      ([:a ^ 2 ^ m, 1::'a:] *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))))\n\ngoal (2 subgoals):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length [])\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]))\n 2. \\<And>a as.\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length as)\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) \\<Longrightarrow>\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>a #\n                             as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length (a # as))\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))", "obtain c d where id': \"(\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1:]) = c\" \"[:a ^ 2 ^ m, 1:] = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c d.\n        \\<lbrakk>(\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) = c;\n         [:a ^ 2 ^ m, 1::'a:] = d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) = c\n  [:a ^ 2 ^ m, 1::'a:] = d\n\ngoal (2 subgoals):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length [])\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]))\n 2. \\<And>a as.\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length as)\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) \\<Longrightarrow>\n       Polynomial.smult (c ^ 2 ^ m)\n        (\\<Prod>a\\<leftarrow>a #\n                             as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n       [:0::'a, - (1::'a):] =\n       Polynomial.smult ((- (1::'a)) ^ length (a # as))\n        (Polynomial.smult (c ^ 2 ^ m)\n          (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length (a # as))\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult ((- (1::'a)) ^ length as)\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) *\n    Polynomial.smult (- (1::'a)) [:a ^ 2 ^ m, 1::'a:] =\n    Polynomial.smult (- (1::'a) * (- (1::'a)) ^ length as)\n     (Polynomial.smult (c ^ 2 ^ m)\n       ([:a ^ 2 ^ m, 1::'a:] *\n        (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])))", "unfolding id'"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult ((- (1::'a)) ^ length as)\n     (Polynomial.smult (c ^ 2 ^ m) c) *\n    Polynomial.smult (- (1::'a)) d =\n    Polynomial.smult (- (1::'a) * (- (1::'a)) ^ length as)\n     (Polynomial.smult (c ^ 2 ^ m) (d * c))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  Polynomial.smult (c ^ 2 ^ m)\n   (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n  [:0::'a, - (1::'a):] =\n  Polynomial.smult ((- (1::'a)) ^ length (a # as))\n   (Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length [])\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]))", "qed simp"], ["proof (state)\nthis:\n  graeffe_poly c as m \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))\n\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "finally"], ["proof (chain)\npicking this:\n  f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  graeffe_poly c as m *\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))", "have \"f * f \\<circ>\\<^sub>p [:0, - 1:] =\n    smult ((- 1) ^ length as * (c ^ 2 ^ m * c ^ 2 ^ m)) \n    ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1:]) * (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1:]))\""], ["proof (prove)\nusing this:\n  f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  graeffe_poly c as m *\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))\n\ngoal (1 subgoal):\n 1. f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length as * (c ^ 2 ^ m * c ^ 2 ^ m))\n     ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n      (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))", "unfolding graeffe_poly_def"], ["proof (prove)\nusing this:\n  f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  Polynomial.smult (c ^ 2 ^ m)\n   (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))\n\ngoal (1 subgoal):\n 1. f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length as * (c ^ 2 ^ m * c ^ 2 ^ m))\n     ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n      (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  Polynomial.smult ((- (1::'a)) ^ length as * (c ^ 2 ^ m * c ^ 2 ^ m))\n   ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))\n\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "also"], ["proof (state)\nthis:\n  f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  Polynomial.smult ((- (1::'a)) ^ length as * (c ^ 2 ^ m * c ^ 2 ^ m))\n   ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))\n\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "have \"c ^ 2 ^ m * c ^ 2 ^ m = c ^ 2 ^ (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ^ 2 ^ m * c ^ 2 ^ m = c ^ 2 ^ Suc m", "by (simp add: semiring_normalization_rules(36))"], ["proof (state)\nthis:\n  c ^ 2 ^ m * c ^ 2 ^ m = c ^ 2 ^ Suc m\n\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "also"], ["proof (state)\nthis:\n  c ^ 2 ^ m * c ^ 2 ^ m = c ^ 2 ^ Suc m\n\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "have \"(\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1:]) * (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1:]) = \n    (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ (Suc m)), 1:]) \\<circ>\\<^sub>p monom 1 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2", "proof (induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2\n 2. \\<And>a as.\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2 \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>a #\n                            as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2", "case (Cons a as)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n  (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n  (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n  Polynomial.monom (1::'a) 2\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2\n 2. \\<And>a as.\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2 \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>a #\n                            as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2", "have id: \"(monom 1 2 :: 'a poly) = [:0,0,1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.monom (1::'a) 2 = [:0::'a, 0::'a, 1::'a:]", "by (metis monom_altdef pCons_0_as_mult power2_eq_square smult_1_left)"], ["proof (state)\nthis:\n  Polynomial.monom (1::'a) 2 = [:0::'a, 0::'a, 1::'a:]\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2\n 2. \\<And>a as.\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2 \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>a #\n                            as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2", "have \"(\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1:]) * (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1:])\n      = ([:- (a ^ 2 ^ m), 1:] * [: a ^ 2 ^ m, 1:]) * ((\\<Prod>a\\<leftarrow> as. [:- (a ^ 2 ^ m), 1:]) * (\\<Prod>a\\<leftarrow> as. [:a ^ 2 ^ m, 1:]))\" \n        (is \"_ = ?a * ?b\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n    [:- (a ^ 2 ^ m), 1::'a:] * [:a ^ 2 ^ m, 1::'a:] *\n    ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n     (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))", "unfolding list.simps prod_list.Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- (a ^ 2 ^ m), 1::'a:] *\n    (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n    ([:a ^ 2 ^ m, 1::'a:] *\n     (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:])) =\n    [:- (a ^ 2 ^ m), 1::'a:] * [:a ^ 2 ^ m, 1::'a:] *\n    ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n     (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))", "by (simp only: ac_simps)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n  (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n  [:- (a ^ 2 ^ m), 1::'a:] * [:a ^ 2 ^ m, 1::'a:] *\n  ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n   (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2\n 2. \\<And>a as.\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2 \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>a #\n                            as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n  (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n  [:- (a ^ 2 ^ m), 1::'a:] * [:a ^ 2 ^ m, 1::'a:] *\n  ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n   (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]))\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2\n 2. \\<And>a as.\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2 \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>a #\n                            as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2", "have \"?b = (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m), 1:]) \\<circ>\\<^sub>p monom 1 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2", "unfolding Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2 =\n    (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n  (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n  (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n  Polynomial.monom (1::'a) 2\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2\n 2. \\<And>a as.\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2 \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>a #\n                            as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n  (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n  (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n  Polynomial.monom (1::'a) 2\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2\n 2. \\<And>a as.\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2 \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>a #\n                            as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2", "have \"?a = [: - (a ^ 2 ^ (Suc m)), 0 , 1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- (a ^ 2 ^ m), 1::'a:] * [:a ^ 2 ^ m, 1::'a:] =\n    [:- (a ^ 2 ^ Suc m), 0::'a, 1::'a:]", "by (simp add: semiring_normalization_rules(36))"], ["proof (state)\nthis:\n  [:- (a ^ 2 ^ m), 1::'a:] * [:a ^ 2 ^ m, 1::'a:] =\n  [:- (a ^ 2 ^ Suc m), 0::'a, 1::'a:]\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2\n 2. \\<And>a as.\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2 \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>a #\n                            as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2", "also"], ["proof (state)\nthis:\n  [:- (a ^ 2 ^ m), 1::'a:] * [:a ^ 2 ^ m, 1::'a:] =\n  [:- (a ^ 2 ^ Suc m), 0::'a, 1::'a:]\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2\n 2. \\<And>a as.\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2 \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>a #\n                            as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2", "have \"\\<dots> = [: - (a ^ 2 ^ (Suc m)), 1:] \\<circ>\\<^sub>p monom 1 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- (a ^ 2 ^ Suc m), 0::'a, 1::'a:] =\n    [:- (a ^ 2 ^ Suc m), 1::'a:] \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2", "by (simp add: id)"], ["proof (state)\nthis:\n  [:- (a ^ 2 ^ Suc m), 0::'a, 1::'a:] =\n  [:- (a ^ 2 ^ Suc m), 1::'a:] \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2\n 2. \\<And>a as.\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2 \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>a #\n                            as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2", "also"], ["proof (state)\nthis:\n  [:- (a ^ 2 ^ Suc m), 0::'a, 1::'a:] =\n  [:- (a ^ 2 ^ Suc m), 1::'a:] \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2\n 2. \\<And>a as.\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2 \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>a #\n                            as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2", "have \"[: - (a ^ 2 ^ (Suc m)), 1:] \\<circ>\\<^sub>p monom 1 2 * (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m), 1:]) \\<circ>\\<^sub>p monom 1 2 =\n      (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ Suc m), 1:]) \\<circ>\\<^sub>p monom 1 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- (a ^ 2 ^ Suc m), 1::'a:] \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2 *\n    (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2 =\n    (\\<Prod>a\\<leftarrow>a #\n                         as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2", "unfolding pcompose_mult[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([:- (a ^ 2 ^ Suc m), 1::'a:] *\n     (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m), 1::'a:])) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2 =\n    (\\<Prod>a\\<leftarrow>a #\n                         as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2", "by simp"], ["proof (state)\nthis:\n  [:- (a ^ 2 ^ Suc m), 1::'a:] \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n  (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n  Polynomial.monom (1::'a) 2 =\n  (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n  Polynomial.monom (1::'a) 2\n\ngoal (2 subgoals):\n 1. (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2\n 2. \\<And>a as.\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2 \\<Longrightarrow>\n       (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n       (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n       (\\<Prod>a\\<leftarrow>a #\n                            as. [:- (a ^ 2 ^ Suc m),\n                                  1::'a:]) \\<circ>\\<^sub>p\n       Polynomial.monom (1::'a) 2", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n  (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n  (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n  Polynomial.monom (1::'a) 2", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n  (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n  (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n  Polynomial.monom (1::'a) 2\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>a #\n                         as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2", "."], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ m), 1::'a:]) *\n  (\\<Prod>a\\<leftarrow>a # as. [:a ^ 2 ^ m, 1::'a:]) =\n  (\\<Prod>a\\<leftarrow>a # as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n  Polynomial.monom (1::'a) 2\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ m), 1::'a:]) *\n    (\\<Prod>a\\<leftarrow>[]. [:a ^ 2 ^ m, 1::'a:]) =\n    (\\<Prod>a\\<leftarrow>[]. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2", "qed simp"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) *\n  (\\<Prod>a\\<leftarrow>as. [:a ^ 2 ^ m, 1::'a:]) =\n  (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n  Polynomial.monom (1::'a) 2\n\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "finally"], ["proof (chain)\npicking this:\n  f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  Polynomial.smult ((- (1::'a)) ^ length as * c ^ 2 ^ Suc m)\n   ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2)", "have \"f * f \\<circ>\\<^sub>p [:0, - 1:] = (smult ((- 1) ^ length as) (graeffe_poly c as (Suc m)) \\<circ>\\<^sub>p monom 1 2)\""], ["proof (prove)\nusing this:\n  f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  Polynomial.smult ((- (1::'a)) ^ length as * c ^ 2 ^ Suc m)\n   ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2)\n\ngoal (1 subgoal):\n 1. f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (graeffe_poly c as (Suc m)) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2", "unfolding graeffe_poly_def pcompose_smult"], ["proof (prove)\nusing this:\n  f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  Polynomial.smult ((- (1::'a)) ^ length as * c ^ 2 ^ Suc m)\n   ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m), 1::'a:]) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2)\n\ngoal (1 subgoal):\n 1. f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (Polynomial.smult (c ^ 2 ^ Suc m)\n       ((\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ Suc m),\n                                   1::'a:]) \\<circ>\\<^sub>p\n        Polynomial.monom (1::'a) 2))", "by simp"], ["proof (state)\nthis:\n  f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (graeffe_poly c as (Suc m)) \\<circ>\\<^sub>p\n  Polynomial.monom (1::'a) 2\n\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "from arg_cong[OF this, of \"\\<lambda> f. smult ((- 1) ^ length as) (poly_square_subst f)\", unfolded poly_square_subst]"], ["proof (chain)\npicking this:\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (Polynomial.smult ((- (1::'a)) ^ length as) (graeffe_poly c as (Suc m)))", "have \"graeffe_poly c as (Suc m) = smult ((- 1) ^ length as) (poly_square_subst (f * f \\<circ>\\<^sub>p [:0, - 1:]))\""], ["proof (prove)\nusing this:\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (Polynomial.smult ((- (1::'a)) ^ length as) (graeffe_poly c as (Suc m)))\n\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "by simp"], ["proof (state)\nthis:\n  graeffe_poly c as (Suc m) =\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))\n\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "also"], ["proof (state)\nthis:\n  graeffe_poly c as (Suc m) =\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))\n\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "have \"\\<dots> = smult ((- 1) ^ degree f) (poly_square_subst (f * f \\<circ>\\<^sub>p [:0, - 1:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "proof (cases \"f = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow>\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "case True"], ["proof (state)\nthis:\n  f = 0\n\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow>\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = 0\n\ngoal (1 subgoal):\n 1. Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "by (auto simp: poly_square_subst_def)"], ["proof (state)\nthis:\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n  Polynomial.smult ((- (1::'a)) ^ degree f)\n   (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "case False"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "with assms"], ["proof (chain)\npicking this:\n  graeffe_poly c as m = f\n  f \\<noteq> 0", "have c0: \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  graeffe_poly c as m = f\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a)", "unfolding graeffe_poly_def"], ["proof (prove)\nusing this:\n  Polynomial.smult (c ^ 2 ^ m)\n   (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) =\n  f\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "from arg_cong[OF assms, of degree]"], ["proof (chain)\npicking this:\n  degree (graeffe_poly c as m) = degree f", "have \"degree f = degree (smult (c ^ 2 ^ m) (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1:]))\""], ["proof (prove)\nusing this:\n  degree (graeffe_poly c as m) = degree f\n\ngoal (1 subgoal):\n 1. degree f =\n    degree\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]))", "unfolding graeffe_poly_def"], ["proof (prove)\nusing this:\n  degree\n   (Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:])) =\n  degree f\n\ngoal (1 subgoal):\n 1. degree f =\n    degree\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]))", "by auto"], ["proof (state)\nthis:\n  degree f =\n  degree\n   (Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]))\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "also"], ["proof (state)\nthis:\n  degree f =\n  degree\n   (Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]))\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "have \"\\<dots> = degree (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (Polynomial.smult (c ^ 2 ^ m)\n       (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:])) =\n    degree (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:])", "unfolding degree_smult_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if c ^ 2 ^ m = (0::'a) then 0\n     else degree (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:])) =\n    degree (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:])", "using c0"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (if c ^ 2 ^ m = (0::'a) then 0\n     else degree (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:])) =\n    degree (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:])", "by auto"], ["proof (state)\nthis:\n  degree\n   (Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:])) =\n  degree (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:])\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "also"], ["proof (state)\nthis:\n  degree\n   (Polynomial.smult (c ^ 2 ^ m)\n     (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:])) =\n  degree (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:])\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "have \"\\<dots> = length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) = length as", "unfolding degree_linear_factors"], ["proof (prove)\ngoal (1 subgoal):\n 1. length as = length as", "by simp"], ["proof (state)\nthis:\n  degree (\\<Prod>a\\<leftarrow>as. [:- (a ^ 2 ^ m), 1::'a:]) = length as\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "finally"], ["proof (chain)\npicking this:\n  degree f = length as", "show ?thesis"], ["proof (prove)\nusing this:\n  degree f = length as\n\ngoal (1 subgoal):\n 1. Polynomial.smult ((- (1::'a)) ^ length as)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n  Polynomial.smult ((- (1::'a)) ^ degree f)\n   (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Polynomial.smult ((- (1::'a)) ^ length as)\n   (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n  Polynomial.smult ((- (1::'a)) ^ degree f)\n   (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))\n\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "finally"], ["proof (chain)\npicking this:\n  graeffe_poly c as (Suc m) =\n  Polynomial.smult ((- (1::'a)) ^ degree f)\n   (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "show ?thesis"], ["proof (prove)\nusing this:\n  graeffe_poly c as (Suc m) =\n  Polynomial.smult ((- (1::'a)) ^ degree f)\n   (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))\n\ngoal (1 subgoal):\n 1. graeffe_poly c as (Suc m) =\n    Polynomial.smult ((- (1::'a)) ^ degree f)\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))", "."], ["proof (state)\nthis:\n  graeffe_poly c as (Suc m) =\n  Polynomial.smult ((- (1::'a)) ^ degree f)\n   (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition graeffe_one_step :: \"'a \\<Rightarrow> 'a :: idom poly \\<Rightarrow> 'a poly\" where \n  \"graeffe_one_step c f = smult c (poly_square_subst (f * f \\<circ>\\<^sub>p [:0,-1:]))\""], ["", "lemma graeffe_one_step_code[code]: fixes c :: \"'a :: idom\" \n  shows \"graeffe_one_step c f = (case poly_even_odd f of (g,h)\n  \\<Rightarrow> smult c (g * g - monom 1 1 * h * h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graeffe_one_step c f =\n    (case poly_even_odd f of\n     (g, h) \\<Rightarrow>\n       Polynomial.smult c (g * g - Polynomial.monom (1::'a) 1 * h * h))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. graeffe_one_step c f =\n    (case poly_even_odd f of\n     (g, h) \\<Rightarrow>\n       Polynomial.smult c (g * g - Polynomial.monom (1::'a) 1 * h * h))", "obtain g h where eo: \"poly_even_odd f = (g,h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g h.\n        poly_even_odd f = (g, h) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  poly_even_odd f = (g, h)\n\ngoal (1 subgoal):\n 1. graeffe_one_step c f =\n    (case poly_even_odd f of\n     (g, h) \\<Rightarrow>\n       Polynomial.smult c (g * g - Polynomial.monom (1::'a) 1 * h * h))", "from poly_even_odd[OF eo]"], ["proof (chain)\npicking this:\n  f =\n  g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n  Polynomial.monom (1::'a) 1 * h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2", "have fgh: \"f = g \\<circ>\\<^sub>p monom 1 2 + monom 1 1 * h \\<circ>\\<^sub>p monom 1 2 \""], ["proof (prove)\nusing this:\n  f =\n  g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n  Polynomial.monom (1::'a) 1 * h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2\n\ngoal (1 subgoal):\n 1. f =\n    g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n    Polynomial.monom (1::'a) 1 *\n    h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2", "by auto"], ["proof (state)\nthis:\n  f =\n  g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n  Polynomial.monom (1::'a) 1 * h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2\n\ngoal (1 subgoal):\n 1. graeffe_one_step c f =\n    (case poly_even_odd f of\n     (g, h) \\<Rightarrow>\n       Polynomial.smult c (g * g - Polynomial.monom (1::'a) 1 * h * h))", "have m2: \"monom (1 :: 'a) 2 = [:0,0,1:]\" \"monom (1 :: 'a) 1 = [:0,1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.monom (1::'a) 2 = [:0::'a, 0::'a, 1::'a:] &&&\n    Polynomial.monom (1::'a) 1 = [:0::'a, 1::'a:]", "unfolding coeffs_eq_iff coeffs_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (1::'a) = (0::'a) then [] else replicate 2 (0::'a) @ [1::'a]) =\n    coeffs [:0::'a, 0::'a, 1::'a:] &&&\n    (if (1::'a) = (0::'a) then [] else replicate 1 (0::'a) @ [1::'a]) =\n    coeffs [:0::'a, 1::'a:]", "by (auto simp add: numeral_2_eq_2)"], ["proof (state)\nthis:\n  Polynomial.monom (1::'a) 2 = [:0::'a, 0::'a, 1::'a:]\n  Polynomial.monom (1::'a) 1 = [:0::'a, 1::'a:]\n\ngoal (1 subgoal):\n 1. graeffe_one_step c f =\n    (case poly_even_odd f of\n     (g, h) \\<Rightarrow>\n       Polynomial.smult c (g * g - Polynomial.monom (1::'a) 1 * h * h))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. graeffe_one_step c f =\n    (case poly_even_odd f of\n     (g, h) \\<Rightarrow>\n       Polynomial.smult c (g * g - Polynomial.monom (1::'a) 1 * h * h))", "unfolding eo split graeffe_one_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult c\n     (poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):])) =\n    Polynomial.smult c (g * g - Polynomial.monom (1::'a) 1 * h * h)", "proof (rule arg_cong[of _ _ \"smult c\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "let ?g = \"g \\<circ>\\<^sub>p monom 1 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "let ?h = \"h \\<circ>\\<^sub>p monom 1 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "let ?x = \"monom (1 :: 'a) 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "have 2: \"2 = Suc (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 = Suc (Suc 0)", "by simp"], ["proof (state)\nthis:\n  2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "have \"f * f \\<circ>\\<^sub>p [:0, - 1:] = (g \\<circ>\\<^sub>p monom 1 2 + monom 1 1 * h \\<circ>\\<^sub>p monom 1 2) * \n      (g \\<circ>\\<^sub>p monom 1 2 + monom 1 1 * h \\<circ>\\<^sub>p monom 1 2) \\<circ>\\<^sub>p [:0, - 1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n    (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n     Polynomial.monom (1::'a) 1 *\n     h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) *\n    (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n     Polynomial.monom (1::'a) 1 *\n     h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):]", "unfolding fgh"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n     Polynomial.monom (1::'a) 1 *\n     h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) *\n    (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n     Polynomial.monom (1::'a) 1 *\n     h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n     Polynomial.monom (1::'a) 1 *\n     h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) *\n    (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n     Polynomial.monom (1::'a) 1 *\n     h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):]", "by simp"], ["proof (state)\nthis:\n  f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n   Polynomial.monom (1::'a) 1 *\n   h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) *\n  (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n   Polynomial.monom (1::'a) 1 *\n   h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) \\<circ>\\<^sub>p\n  [:0::'a, - (1::'a):]\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "also"], ["proof (state)\nthis:\n  f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n   Polynomial.monom (1::'a) 1 *\n   h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) *\n  (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n   Polynomial.monom (1::'a) 1 *\n   h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) \\<circ>\\<^sub>p\n  [:0::'a, - (1::'a):]\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "have \"(g \\<circ>\\<^sub>p monom 1 2 + monom 1 1 * h \\<circ>\\<^sub>p monom 1 2) \\<circ>\\<^sub>p [:0, - 1:]\n      = g \\<circ>\\<^sub>p (monom 1 2 \\<circ>\\<^sub>p [:0, - 1:]) + monom 1 1 \\<circ>\\<^sub>p [:0, - 1:] * h \\<circ>\\<^sub>p (monom 1 2 \\<circ>\\<^sub>p [:0, - 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n     Polynomial.monom (1::'a) 1 *\n     h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    g \\<circ>\\<^sub>p\n    (Polynomial.monom (1::'a) 2 \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) +\n    Polynomial.monom (1::'a) 1 \\<circ>\\<^sub>p [:0::'a, - (1::'a):] *\n    h \\<circ>\\<^sub>p\n    (Polynomial.monom (1::'a) 2 \\<circ>\\<^sub>p [:0::'a, - (1::'a):])", "unfolding pcompose_add pcompose_mult pcompose_assoc"], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] +\n    Polynomial.monom (1::'a) 1 \\<circ>\\<^sub>p [:0::'a, - (1::'a):] *\n    h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] =\n    g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):] +\n    Polynomial.monom (1::'a) 1 \\<circ>\\<^sub>p [:0::'a, - (1::'a):] *\n    h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 \\<circ>\\<^sub>p\n    [:0::'a, - (1::'a):]", "by simp"], ["proof (state)\nthis:\n  (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n   Polynomial.monom (1::'a) 1 *\n   h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) \\<circ>\\<^sub>p\n  [:0::'a, - (1::'a):] =\n  g \\<circ>\\<^sub>p\n  (Polynomial.monom (1::'a) 2 \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) +\n  Polynomial.monom (1::'a) 1 \\<circ>\\<^sub>p [:0::'a, - (1::'a):] *\n  h \\<circ>\\<^sub>p\n  (Polynomial.monom (1::'a) 2 \\<circ>\\<^sub>p [:0::'a, - (1::'a):])\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "also"], ["proof (state)\nthis:\n  (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n   Polynomial.monom (1::'a) 1 *\n   h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) \\<circ>\\<^sub>p\n  [:0::'a, - (1::'a):] =\n  g \\<circ>\\<^sub>p\n  (Polynomial.monom (1::'a) 2 \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) +\n  Polynomial.monom (1::'a) 1 \\<circ>\\<^sub>p [:0::'a, - (1::'a):] *\n  h \\<circ>\\<^sub>p\n  (Polynomial.monom (1::'a) 2 \\<circ>\\<^sub>p [:0::'a, - (1::'a):])\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "have \"monom (1 :: 'a) 2 \\<circ>\\<^sub>p [:0, - 1:] = monom 1 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.monom (1::'a) 2 \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n    Polynomial.monom (1::'a) 2", "unfolding m2"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0::'a, 0::'a, 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n    [:0::'a, 0::'a, 1::'a:]", "by auto"], ["proof (state)\nthis:\n  Polynomial.monom (1::'a) 2 \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  Polynomial.monom (1::'a) 2\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "also"], ["proof (state)\nthis:\n  Polynomial.monom (1::'a) 2 \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  Polynomial.monom (1::'a) 2\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "have \"?x \\<circ>\\<^sub>p [:0, - 1:] = [:0, -1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.monom (1::'a) 1 \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n    [:0::'a, - (1::'a):]", "unfolding m2"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n    [:0::'a, - (1::'a):]", "by auto"], ["proof (state)\nthis:\n  Polynomial.monom (1::'a) 1 \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  [:0::'a, - (1::'a):]\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "also"], ["proof (state)\nthis:\n  Polynomial.monom (1::'a) 1 \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  [:0::'a, - (1::'a):]\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "have \"[:0, - 1:] * h \\<circ>\\<^sub>p monom 1 2 = (-?x) * ?h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0::'a, - (1::'a):] * h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 =\n    - Polynomial.monom (1::'a) 1 *\n    h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2", "unfolding m2"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0::'a, - (1::'a):] * h \\<circ>\\<^sub>p [:0::'a, 0::'a, 1::'a:] =\n    - [:0::'a, 1::'a:] * h \\<circ>\\<^sub>p [:0::'a, 0::'a, 1::'a:]", "by simp"], ["proof (state)\nthis:\n  [:0::'a, - (1::'a):] * h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 =\n  - Polynomial.monom (1::'a) 1 *\n  h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "also"], ["proof (state)\nthis:\n  [:0::'a, - (1::'a):] * h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 =\n  - Polynomial.monom (1::'a) 1 *\n  h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "have \"(?g + ?x * ?h) * (?g + (- ?x) * ?h) = (?g * ?g - (?x * ?x) * ?h * ?h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n     Polynomial.monom (1::'a) 1 *\n     h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) *\n    (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n     - Polynomial.monom (1::'a) 1 *\n     h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) =\n    g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n    g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 -\n    Polynomial.monom (1::'a) 1 * Polynomial.monom (1::'a) 1 *\n    h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n    h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n   Polynomial.monom (1::'a) 1 *\n   h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) *\n  (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n   - Polynomial.monom (1::'a) 1 *\n   h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) =\n  g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n  g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 -\n  Polynomial.monom (1::'a) 1 * Polynomial.monom (1::'a) 1 *\n  h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n  h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "also"], ["proof (state)\nthis:\n  (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n   Polynomial.monom (1::'a) 1 *\n   h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) *\n  (g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 +\n   - Polynomial.monom (1::'a) 1 *\n   h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2) =\n  g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n  g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 -\n  Polynomial.monom (1::'a) 1 * Polynomial.monom (1::'a) 1 *\n  h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n  h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "have \"?x * ?x = ?x \\<circ>\\<^sub>p monom 1 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.monom (1::'a) 1 * Polynomial.monom (1::'a) 1 =\n    Polynomial.monom (1::'a) 1 \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2", "unfolding mult_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.monom ((1::'a) * (1::'a)) (1 + 1) =\n    Polynomial.monom (1::'a) 1 \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2", "by (insert m2, simp add: 2)"], ["proof (state)\nthis:\n  Polynomial.monom (1::'a) 1 * Polynomial.monom (1::'a) 1 =\n  Polynomial.monom (1::'a) 1 \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "also"], ["proof (state)\nthis:\n  Polynomial.monom (1::'a) 1 * Polynomial.monom (1::'a) 1 =\n  Polynomial.monom (1::'a) 1 \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "have \"(?g * ?g - \\<dots> * ?h * ?h) = (g * g - ?x * h * h) \\<circ>\\<^sub>p monom 1 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n    g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 -\n    Polynomial.monom (1::'a) 1 \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n    h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n    h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 =\n    (g * g - Polynomial.monom (1::'a) 1 * h * h) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2", "unfolding pcompose_diff pcompose_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n    g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 -\n    Polynomial.monom (1::'a) 1 \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n    h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n    h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 =\n    g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n    g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 -\n    Polynomial.monom (1::'a) 1 \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n    h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n    h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2", "by auto"], ["proof (state)\nthis:\n  g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n  g \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 -\n  Polynomial.monom (1::'a) 1 \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n  h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 *\n  h \\<circ>\\<^sub>p Polynomial.monom (1::'a) 2 =\n  (g * g - Polynomial.monom (1::'a) 1 * h * h) \\<circ>\\<^sub>p\n  Polynomial.monom (1::'a) 2\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "finally"], ["proof (chain)\npicking this:\n  f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  (g * g - Polynomial.monom (1::'a) 1 * h * h) \\<circ>\\<^sub>p\n  Polynomial.monom (1::'a) 2", "have \"poly_square_subst (f * f \\<circ>\\<^sub>p [:0, - 1:]) \n      = poly_square_subst ((g * g - ?x * h * h) \\<circ>\\<^sub>p monom 1 2)\""], ["proof (prove)\nusing this:\n  f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):] =\n  (g * g - Polynomial.monom (1::'a) 1 * h * h) \\<circ>\\<^sub>p\n  Polynomial.monom (1::'a) 2\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    poly_square_subst\n     ((g * g - Polynomial.monom (1::'a) 1 * h * h) \\<circ>\\<^sub>p\n      Polynomial.monom (1::'a) 2)", "by simp"], ["proof (state)\nthis:\n  poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n  poly_square_subst\n   ((g * g - Polynomial.monom (1::'a) 1 * h * h) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2)\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "also"], ["proof (state)\nthis:\n  poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n  poly_square_subst\n   ((g * g - Polynomial.monom (1::'a) 1 * h * h) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2)\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "have \"\\<dots> = g * g - ?x * h * h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_square_subst\n     ((g * g - Polynomial.monom (1::'a) 1 * h * h) \\<circ>\\<^sub>p\n      Polynomial.monom (1::'a) 2) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "unfolding poly_square_subst"], ["proof (prove)\ngoal (1 subgoal):\n 1. g * g - Polynomial.monom (1::'a) 1 * h * h =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "by simp"], ["proof (state)\nthis:\n  poly_square_subst\n   ((g * g - Polynomial.monom (1::'a) 1 * h * h) \\<circ>\\<^sub>p\n    Polynomial.monom (1::'a) 2) =\n  g * g - Polynomial.monom (1::'a) 1 * h * h\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "finally"], ["proof (chain)\npicking this:\n  poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n  g * g - Polynomial.monom (1::'a) 1 * h * h", "show \"poly_square_subst (f * f \\<circ>\\<^sub>p [:0, - 1:]) = g * g - ?x * h * h\""], ["proof (prove)\nusing this:\n  poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n  g * g - Polynomial.monom (1::'a) 1 * h * h\n\ngoal (1 subgoal):\n 1. poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n    g * g - Polynomial.monom (1::'a) 1 * h * h", "."], ["proof (state)\nthis:\n  poly_square_subst (f * f \\<circ>\\<^sub>p [:0::'a, - (1::'a):]) =\n  g * g - Polynomial.monom (1::'a) 1 * h * h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  graeffe_one_step c f =\n  (case poly_even_odd f of\n   (g, h) \\<Rightarrow>\n     Polynomial.smult c (g * g - Polynomial.monom (1::'a) 1 * h * h))\n\ngoal:\nNo subgoals!", "qed"], ["", "fun graeffe_poly_impl_main :: \"'a \\<Rightarrow> 'a :: idom poly \\<Rightarrow> nat \\<Rightarrow> 'a poly\" where\n  \"graeffe_poly_impl_main c f 0 = f\" \n| \"graeffe_poly_impl_main c f (Suc m) = graeffe_one_step c (graeffe_poly_impl_main c f m)\""], ["", "lemma graeffe_poly_impl_main: assumes \"f = smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])\"\n  shows \"graeffe_poly_impl_main ((-1)^degree f) f m = graeffe_poly c as m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f m =\n    graeffe_poly c as m", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f 0 =\n    graeffe_poly c as 0\n 2. \\<And>m.\n       graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f m =\n       graeffe_poly c as m \\<Longrightarrow>\n       graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f (Suc m) =\n       graeffe_poly c as (Suc m)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f 0 =\n    graeffe_poly c as 0\n 2. \\<And>m.\n       graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f m =\n       graeffe_poly c as m \\<Longrightarrow>\n       graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f (Suc m) =\n       graeffe_poly c as (Suc m)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f 0 =\n    graeffe_poly c as 0", "using graeffe_0[OF assms]"], ["proof (prove)\nusing this:\n  graeffe_poly c as 0 = f\n\ngoal (1 subgoal):\n 1. graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f 0 =\n    graeffe_poly c as 0", "by simp"], ["proof (state)\nthis:\n  graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f 0 = graeffe_poly c as 0\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f m =\n       graeffe_poly c as m \\<Longrightarrow>\n       graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f (Suc m) =\n       graeffe_poly c as (Suc m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f m =\n       graeffe_poly c as m \\<Longrightarrow>\n       graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f (Suc m) =\n       graeffe_poly c as (Suc m)", "case (Suc m)"], ["proof (state)\nthis:\n  graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f m = graeffe_poly c as m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f m =\n       graeffe_poly c as m \\<Longrightarrow>\n       graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f (Suc m) =\n       graeffe_poly c as (Suc m)", "have [simp]: \"degree (graeffe_poly c as m) = degree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (graeffe_poly c as m) = degree f", "unfolding graeffe_poly_def degree_smult_eq assms\n    degree_linear_factors"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if c ^ 2 ^ m = (0::'a) then 0 else length as) =\n    (if c = (0::'a) then 0 else length as)", "by auto"], ["proof (state)\nthis:\n  degree (graeffe_poly c as m) = degree f\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f m =\n       graeffe_poly c as m \\<Longrightarrow>\n       graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f (Suc m) =\n       graeffe_poly c as (Suc m)", "from arg_cong[OF Suc, of degree]"], ["proof (chain)\npicking this:\n  degree (graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f m) =\n  degree (graeffe_poly c as m)", "show ?case"], ["proof (prove)\nusing this:\n  degree (graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f m) =\n  degree (graeffe_poly c as m)\n\ngoal (1 subgoal):\n 1. graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f (Suc m) =\n    graeffe_poly c as (Suc m)", "unfolding graeffe_recursion[OF Suc[symmetric]]"], ["proof (prove)\nusing this:\n  degree (graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f m) =\n  degree (graeffe_poly c as m)\n\ngoal (1 subgoal):\n 1. graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f (Suc m) =\n    Polynomial.smult\n     ((- (1::'a)) ^\n      degree (graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f m))\n     (poly_square_subst\n       (graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f m *\n        graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f m \\<circ>\\<^sub>p\n        [:0::'a, - (1::'a):]))", "by (simp add: graeffe_one_step_def)"], ["proof (state)\nthis:\n  graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f (Suc m) =\n  graeffe_poly c as (Suc m)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition graeffe_poly_impl :: \"'a :: idom poly \\<Rightarrow> nat \\<Rightarrow> 'a poly\" where\n  \"graeffe_poly_impl f = graeffe_poly_impl_main ((-1)^(degree f)) f\""], ["", "lemma graeffe_poly_impl: assumes \"f = smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:])\"\n  shows \"graeffe_poly_impl f m = graeffe_poly c as m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graeffe_poly_impl f m = graeffe_poly c as m", "using graeffe_poly_impl_main[OF assms]"], ["proof (prove)\nusing this:\n  graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f ?m =\n  graeffe_poly c as ?m\n\ngoal (1 subgoal):\n 1. graeffe_poly_impl f m = graeffe_poly c as m", "unfolding graeffe_poly_impl_def"], ["proof (prove)\nusing this:\n  graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f ?m =\n  graeffe_poly c as ?m\n\ngoal (1 subgoal):\n 1. graeffe_poly_impl_main ((- (1::'a)) ^ degree f) f m =\n    graeffe_poly c as m", "."], ["", "lemma drop_half_map: \"drop_half (map f xs) = map f (drop_half xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_half (map f xs) = map f (drop_half xs)", "by (induct xs rule: drop_half.induct, auto)"], ["", "lemma (in inj_comm_ring_hom) map_poly_poly_square_subst: \n  \"map_poly hom (poly_square_subst f) = poly_square_subst (map_poly hom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (poly_square_subst f) = poly_square_subst (map_poly hom f)", "unfolding poly_square_subst_def coeffs_map_poly_hom drop_half_map poly_of_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (Poly (drop_half (coeffs f))) =\n    Poly (map hom (drop_half (coeffs f)))", "by (rule poly_eqI, auto simp: nth_default_map_eq)"], ["", "context inj_idom_hom\nbegin"], ["", "lemma graeffe_poly_impl_hom:\n  \"map_poly hom (graeffe_poly_impl f m) = graeffe_poly_impl (map_poly hom f) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (graeffe_poly_impl f m) =\n    graeffe_poly_impl (map_poly hom f) m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly hom (graeffe_poly_impl f m) =\n    graeffe_poly_impl (map_poly hom f) m", "interpret mh: map_poly_inj_idom_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_idom_hom hom", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly hom (graeffe_poly_impl f m) =\n    graeffe_poly_impl (map_poly hom f) m", "obtain c where c: \"(((- 1) ^ degree f) :: 'a) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (- (1::'a)) ^ degree f = c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (- (1::'a)) ^ degree f = c\n\ngoal (1 subgoal):\n 1. map_poly hom (graeffe_poly_impl f m) =\n    graeffe_poly_impl (map_poly hom f) m", "have c': \"(((- 1) ^ degree f) :: 'b) = hom c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'b)) ^ degree f = hom c", "unfolding c[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'b)) ^ degree f = hom ((- (1::'a)) ^ degree f)", "by (simp add:hom_distribs)"], ["proof (state)\nthis:\n  (- (1::'b)) ^ degree f = hom c\n\ngoal (1 subgoal):\n 1. map_poly hom (graeffe_poly_impl f m) =\n    graeffe_poly_impl (map_poly hom f) m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (graeffe_poly_impl f m) =\n    graeffe_poly_impl (map_poly hom f) m", "unfolding graeffe_poly_impl_def degree_map_poly_hom c c'"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (graeffe_poly_impl_main c f m) =\n    graeffe_poly_impl_main (hom c) (map_poly hom f) m", "apply (induct m arbitrary: f; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m f.\n       (\\<And>f.\n           map_poly hom (graeffe_poly_impl_main c f m) =\n           graeffe_poly_impl_main (hom c) (map_poly hom f)\n            m) \\<Longrightarrow>\n       map_poly hom (graeffe_one_step c (graeffe_poly_impl_main c f m)) =\n       graeffe_one_step (hom c)\n        (graeffe_poly_impl_main (hom c) (map_poly hom f) m)", "by (unfold graeffe_one_step_def hom_distribs map_poly_poly_square_subst map_poly_pcompose,simp)"], ["proof (state)\nthis:\n  map_poly hom (graeffe_poly_impl f m) =\n  graeffe_poly_impl (map_poly hom f) m\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma graeffe_poly_impl_mahler: \"mahler_measure (graeffe_poly_impl f m) = mahler_measure f ^ 2 ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure (graeffe_poly_impl f m) = mahler_measure f ^ 2 ^ m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure (graeffe_poly_impl f m) = mahler_measure f ^ 2 ^ m", "let ?c = \"complex_of_int\""], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure (graeffe_poly_impl f m) = mahler_measure f ^ 2 ^ m", "let ?cc = \"map_poly ?c\""], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure (graeffe_poly_impl f m) = mahler_measure f ^ 2 ^ m", "let ?f = \"?cc f\""], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure (graeffe_poly_impl f m) = mahler_measure f ^ 2 ^ m", "note eq = complex_roots(1)[of ?f]"], ["proof (state)\nthis:\n  Polynomial.smult (lead_coeff (of_int_poly f))\n   (\\<Prod>a\\<leftarrow>complex_roots_complex (of_int_poly f). [:- a, 1:]) =\n  of_int_poly f\n\ngoal (1 subgoal):\n 1. mahler_measure (graeffe_poly_impl f m) = mahler_measure f ^ 2 ^ m", "interpret inj_idom_hom complex_of_int"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_idom_hom complex_of_int", "by (standard, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure (graeffe_poly_impl f m) = mahler_measure f ^ 2 ^ m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure (graeffe_poly_impl f m) = mahler_measure f ^ 2 ^ m", "unfolding mahler_measure_def mahler_graeffe[OF eq[symmetric], symmetric]\n     graeffe_poly_impl[OF eq[symmetric], symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure_poly (of_int_poly (graeffe_poly_impl f m)) =\n    mahler_measure_poly (graeffe_poly_impl (of_int_poly f) m)", "by (simp add: of_int_hom.graeffe_poly_impl_hom)"], ["proof (state)\nthis:\n  mahler_measure (graeffe_poly_impl f m) = mahler_measure f ^ 2 ^ m\n\ngoal:\nNo subgoals!", "qed"], ["", "definition mahler_landau_graeffe_approximation :: \"nat \\<Rightarrow> nat \\<Rightarrow> int poly \\<Rightarrow> int\" where\n  \"mahler_landau_graeffe_approximation kk dd f = (let \n     no = sum_list (map (\\<lambda> a. a * a) (coeffs f))\n    in root_int_floor kk (dd * no))\""], ["", "lemma mahler_landau_graeffe_approximation_core: \n  assumes g: \"g = graeffe_poly_impl f k\" \n  shows \"mahler_measure f \\<le> root (2 ^ Suc k) (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure f\n    \\<le> root (2 ^ Suc k)\n           (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mahler_measure f\n    \\<le> root (2 ^ Suc k)\n           (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))", "have \"mahler_measure f = root (2^k) (mahler_measure f ^ (2^k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure f = root (2 ^ k) (mahler_measure f ^ 2 ^ k)", "by (simp add: real_root_power_cancel mahler_measure_ge_0)"], ["proof (state)\nthis:\n  mahler_measure f = root (2 ^ k) (mahler_measure f ^ 2 ^ k)\n\ngoal (1 subgoal):\n 1. mahler_measure f\n    \\<le> root (2 ^ Suc k)\n           (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))", "also"], ["proof (state)\nthis:\n  mahler_measure f = root (2 ^ k) (mahler_measure f ^ 2 ^ k)\n\ngoal (1 subgoal):\n 1. mahler_measure f\n    \\<le> root (2 ^ Suc k)\n           (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))", "have \"\\<dots> = root (2^k) (mahler_measure g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (2 ^ k) (mahler_measure f ^ 2 ^ k) =\n    root (2 ^ k) (mahler_measure g)", "unfolding graeffe_poly_impl_mahler g"], ["proof (prove)\ngoal (1 subgoal):\n 1. root (2 ^ k) (mahler_measure f ^ 2 ^ k) =\n    root (2 ^ k) (mahler_measure f ^ 2 ^ k)", "by simp"], ["proof (state)\nthis:\n  root (2 ^ k) (mahler_measure f ^ 2 ^ k) = root (2 ^ k) (mahler_measure g)\n\ngoal (1 subgoal):\n 1. mahler_measure f\n    \\<le> root (2 ^ Suc k)\n           (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))", "also"], ["proof (state)\nthis:\n  root (2 ^ k) (mahler_measure f ^ 2 ^ k) = root (2 ^ k) (mahler_measure g)\n\ngoal (1 subgoal):\n 1. mahler_measure f\n    \\<le> root (2 ^ Suc k)\n           (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))", "have \"\\<dots> = root (2^k) (root 2 (((mahler_measure g)^2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (2 ^ k) (mahler_measure g) =\n    root (2 ^ k) (root 2 ((mahler_measure g)\\<^sup>2))", "by (simp add: real_root_power_cancel mahler_measure_ge_0)"], ["proof (state)\nthis:\n  root (2 ^ k) (mahler_measure g) =\n  root (2 ^ k) (root 2 ((mahler_measure g)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. mahler_measure f\n    \\<le> root (2 ^ Suc k)\n           (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))", "also"], ["proof (state)\nthis:\n  root (2 ^ k) (mahler_measure g) =\n  root (2 ^ k) (root 2 ((mahler_measure g)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. mahler_measure f\n    \\<le> root (2 ^ Suc k)\n           (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))", "have \"\\<dots> = root (2^Suc k) (((mahler_measure g)^2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (2 ^ k) (root 2 ((mahler_measure g)\\<^sup>2)) =\n    root (2 ^ Suc k) ((mahler_measure g)\\<^sup>2)", "by (metis power_Suc2 real_root_mult_exp)"], ["proof (state)\nthis:\n  root (2 ^ k) (root 2 ((mahler_measure g)\\<^sup>2)) =\n  root (2 ^ Suc k) ((mahler_measure g)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. mahler_measure f\n    \\<le> root (2 ^ Suc k)\n           (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))", "also"], ["proof (state)\nthis:\n  root (2 ^ k) (root 2 ((mahler_measure g)\\<^sup>2)) =\n  root (2 ^ Suc k) ((mahler_measure g)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. mahler_measure f\n    \\<le> root (2 ^ Suc k)\n           (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))", "have \"\\<dots> \\<le> root (2 ^ Suc k) (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (2 ^ Suc k) ((mahler_measure g)\\<^sup>2)\n    \\<le> root (2 ^ Suc k)\n           (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))", "proof (rule real_root_le_mono, force)"], ["proof (state)\ngoal (1 subgoal):\n 1. (mahler_measure g)\\<^sup>2\n    \\<le> real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a)", "have square_mono: \"0 \\<le> (x :: real) \\<Longrightarrow> x \\<le> y \\<Longrightarrow> x * x \\<le> y * y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> x * x \\<le> y * y", "by (simp add: mult_mono')"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x * ?x \\<le> ?y * ?y\n\ngoal (1 subgoal):\n 1. (mahler_measure g)\\<^sup>2\n    \\<le> real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a)", "obtain gs where gs: \"coeffs g = gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>gs. coeffs g = gs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  coeffs g = gs\n\ngoal (1 subgoal):\n 1. (mahler_measure g)\\<^sup>2\n    \\<le> real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a)", "have \"(mahler_measure g)\\<^sup>2 \\<le> real_of_int \\<bar>\\<Sum>a\\<leftarrow>coeffs g. a * a\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mahler_measure g)\\<^sup>2\n    \\<le> real_of_int \\<bar>\\<Sum>a\\<leftarrow>coeffs g. a * a\\<bar>", "using square_mono[OF mahler_measure_ge_0 Landau_inequality[of \"of_int_poly g\", folded mahler_measure_def]]"], ["proof (prove)\nusing this:\n  mahler_measure g * mahler_measure g\n  \\<le> l2norm_complex (of_int_poly g) * l2norm_complex (of_int_poly g)\n\ngoal (1 subgoal):\n 1. (mahler_measure g)\\<^sup>2\n    \\<le> real_of_int \\<bar>\\<Sum>a\\<leftarrow>coeffs g. a * a\\<bar>", "by (auto simp: power2_eq_square coeffs_map_poly o_def of_int_hom.hom_sum_list)"], ["proof (state)\nthis:\n  (mahler_measure g)\\<^sup>2\n  \\<le> real_of_int \\<bar>\\<Sum>a\\<leftarrow>coeffs g. a * a\\<bar>\n\ngoal (1 subgoal):\n 1. (mahler_measure g)\\<^sup>2\n    \\<le> real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a)", "also"], ["proof (state)\nthis:\n  (mahler_measure g)\\<^sup>2\n  \\<le> real_of_int \\<bar>\\<Sum>a\\<leftarrow>coeffs g. a * a\\<bar>\n\ngoal (1 subgoal):\n 1. (mahler_measure g)\\<^sup>2\n    \\<le> real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a)", "have \"\\<bar>\\<Sum>a\\<leftarrow>coeffs g. a * a\\<bar> = (\\<Sum>a\\<leftarrow>coeffs g. a * a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<leftarrow>coeffs g. a * a\\<bar> =\n    (\\<Sum>a\\<leftarrow>coeffs g. a * a)", "unfolding gs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<leftarrow>gs. a * a\\<bar> =\n    (\\<Sum>a\\<leftarrow>gs. a * a)", "by (induct gs, auto)"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>a\\<leftarrow>coeffs g. a * a\\<bar> =\n  (\\<Sum>a\\<leftarrow>coeffs g. a * a)\n\ngoal (1 subgoal):\n 1. (mahler_measure g)\\<^sup>2\n    \\<le> real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a)", "finally"], ["proof (chain)\npicking this:\n  (mahler_measure g)\\<^sup>2\n  \\<le> real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a)", "show \"(mahler_measure g)\\<^sup>2 \\<le> real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a)\""], ["proof (prove)\nusing this:\n  (mahler_measure g)\\<^sup>2\n  \\<le> real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a)\n\ngoal (1 subgoal):\n 1. (mahler_measure g)\\<^sup>2\n    \\<le> real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a)", "."], ["proof (state)\nthis:\n  (mahler_measure g)\\<^sup>2\n  \\<le> real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  root (2 ^ Suc k) ((mahler_measure g)\\<^sup>2)\n  \\<le> root (2 ^ Suc k) (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))\n\ngoal (1 subgoal):\n 1. mahler_measure f\n    \\<le> root (2 ^ Suc k)\n           (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))", "finally"], ["proof (chain)\npicking this:\n  mahler_measure f\n  \\<le> root (2 ^ Suc k) (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))", "show \"mahler_measure f \\<le> root (2 ^ Suc k) (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))\""], ["proof (prove)\nusing this:\n  mahler_measure f\n  \\<le> root (2 ^ Suc k) (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))\n\ngoal (1 subgoal):\n 1. mahler_measure f\n    \\<le> root (2 ^ Suc k)\n           (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))", "."], ["proof (state)\nthis:\n  mahler_measure f\n  \\<le> root (2 ^ Suc k) (real_of_int (\\<Sum>a\\<leftarrow>coeffs g. a * a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Landau_inequality_mahler_measure: \"mahler_measure f \\<le> sqrt (real_of_int (\\<Sum>a\\<leftarrow>coeffs f. a * a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mahler_measure f\n    \\<le> sqrt (real_of_int (\\<Sum>a\\<leftarrow>coeffs f. a * a))", "by (rule order.trans[OF mahler_landau_graeffe_approximation_core[OF refl, of _ 0]],\n  auto simp: graeffe_poly_impl_def sqrt_def)"], ["", "lemma mahler_landau_graeffe_approximation:\n  assumes g: \"g = graeffe_poly_impl f k\" \"dd = d^(2^(Suc k))\" \"kk = 2^(Suc k)\" \n  shows \"\\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mahler_landau_graeffe_approximation kk dd g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> mahler_landau_graeffe_approximation kk dd g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> mahler_landau_graeffe_approximation kk dd g", "have id1: \"real_of_int (int (d ^ 2 ^ Suc k)) = (real d) ^ 2 ^ Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (int (d ^ 2 ^ Suc k)) = real d ^ 2 ^ Suc k", "by simp"], ["proof (state)\nthis:\n  real_of_int (int (d ^ 2 ^ Suc k)) = real d ^ 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> mahler_landau_graeffe_approximation kk dd g", "have id2: \"root (2 ^ Suc k) (real d ^ 2 ^ Suc k) = real d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (2 ^ Suc k) (real d ^ 2 ^ Suc k) = real d", "by (simp add: real_root_power_cancel)"], ["proof (state)\nthis:\n  root (2 ^ Suc k) (real d ^ 2 ^ Suc k) = real d\n\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> mahler_landau_graeffe_approximation kk dd g", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> mahler_landau_graeffe_approximation kk dd g", "unfolding mahler_landau_graeffe_approximation_def Let_def root_int_floor of_int_mult g(2-3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> \\<lfloor>root (2 ^ Suc k)\n                    (real_of_int (int (d ^ 2 ^ Suc k)) *\n                     real_of_int\n                      (\\<Sum>a\\<leftarrow>coeffs g. a * a))\\<rfloor>", "by (rule floor_mono, unfold real_root_mult id1 id2, rule mult_left_mono, \n    rule mahler_landau_graeffe_approximation_core[OF g(1)], auto)"], ["proof (state)\nthis:\n  \\<lfloor>real d * mahler_measure f\\<rfloor>\n  \\<le> mahler_landau_graeffe_approximation kk dd g\n\ngoal:\nNo subgoals!", "qed"], ["", "context \n  fixes bnd :: nat\nbegin"], ["", "(* \"dd = d^(2^(Suc k))\" \"kk = 2^(Suc k)\" *)"], ["", "function mahler_approximation_main :: \"nat \\<Rightarrow> int \\<Rightarrow> int poly \\<Rightarrow> int \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> int\" where\n  \"mahler_approximation_main dd c g mm k kk = (let mmm = mahler_landau_graeffe_approximation kk dd g;\n     new_mm = (if k = 0 then mmm else min mm mmm)\n     in (if k \\<ge> bnd then new_mm else \n     \\<comment> \\<open>abort after \\<open>bnd\\<close> iterations of Graeffe transformation\\<close>\n      mahler_approximation_main (dd * dd) c (graeffe_one_step c g) new_mm (Suc k) (2 * kk)))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>dd c g mm k kk.\n           x = (dd, c, g, mm, k, kk) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>dd c g mm k kk dda ca ga mma ka kka.\n       (dd, c, g, mm, k, kk) = (dda, ca, ga, mma, ka, kka) \\<Longrightarrow>\n       (let mmm = mahler_landau_graeffe_approximation kk dd g;\n            new_mm = if k = 0 then mmm else min mm mmm\n        in if bnd \\<le> k then new_mm\n           else mahler_approximation_main_sumC\n                 (dd * dd, c, graeffe_one_step c g, new_mm, Suc k,\n                  2 * kk)) =\n       (let mmm = mahler_landau_graeffe_approximation kka dda ga;\n            new_mm = if ka = 0 then mmm else min mma mmm\n        in if bnd \\<le> ka then new_mm\n           else mahler_approximation_main_sumC\n                 (dda * dda, ca, graeffe_one_step ca ga, new_mm, Suc ka,\n                  2 * kka))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All local.mahler_approximation_main_dom", "by (relation \"measure (\\<lambda> (dd,c,f,mm,k,kk). Suc bnd - k)\", auto)"], ["", "declare mahler_approximation_main.simps[simp del]"], ["", "lemma mahler_approximation_main: assumes \"k \\<noteq> 0 \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm\"\n    and \"c = (-1)^(degree f)\" \n    and \"g = graeffe_poly_impl_main c f k\" \"dd = d^(2^(Suc k))\" \"kk = 2^(Suc k)\"\n  shows \"\\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mahler_approximation_main dd c g mm k kk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main dd c g mm k kk", "using assms"], ["proof (prove)\nusing this:\n  k \\<noteq> 0 \\<Longrightarrow>\n  \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm\n  c = (- 1) ^ degree f\n  g = graeffe_poly_impl_main c f k\n  dd = d ^ 2 ^ Suc k\n  kk = 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main dd c g mm k kk", "proof (induct c g mm k kk rule: mahler_approximation_main.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "case (1 dd c g mm k kk)"], ["proof (state)\nthis:\n  \\<lbrakk>?x = mahler_landau_graeffe_approximation kk dd g;\n   ?xa = (if k = 0 then ?x else min mm ?x); \\<not> bnd \\<le> k;\n   Suc k \\<noteq> 0 \\<Longrightarrow>\n   \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> ?xa;\n   c = (- 1) ^ degree f;\n   graeffe_one_step c g = graeffe_poly_impl_main c f (Suc k);\n   dd * dd = d ^ 2 ^ Suc (Suc k); 2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n  \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                    \\<le> local.mahler_approximation_main (dd * dd) c\n                           (graeffe_one_step c g) ?xa (Suc k) (2 * kk)\n  k \\<noteq> 0 \\<Longrightarrow>\n  \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm\n  c = (- 1) ^ degree f\n  g = graeffe_poly_impl_main c f k\n  dd = d ^ 2 ^ Suc k\n  kk = 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "let ?df = \"\\<lfloor>real d * mahler_measure f\\<rfloor>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "note dd = 1(5)"], ["proof (state)\nthis:\n  dd = d ^ 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "note kk = 1(6)"], ["proof (state)\nthis:\n  kk = 2 ^ Suc k\n\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "note g = 1(4)"], ["proof (state)\nthis:\n  g = graeffe_poly_impl_main c f k\n\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "note c = 1(3)"], ["proof (state)\nthis:\n  c = (- 1) ^ degree f\n\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "note mm = 1(2)"], ["proof (state)\nthis:\n  k \\<noteq> 0 \\<Longrightarrow>\n  \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm\n\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "note IH = 1(1)"], ["proof (state)\nthis:\n  \\<lbrakk>?x = mahler_landau_graeffe_approximation kk dd g;\n   ?xa = (if k = 0 then ?x else min mm ?x); \\<not> bnd \\<le> k;\n   Suc k \\<noteq> 0 \\<Longrightarrow>\n   \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> ?xa;\n   c = (- 1) ^ degree f;\n   graeffe_one_step c g = graeffe_poly_impl_main c f (Suc k);\n   dd * dd = d ^ 2 ^ Suc (Suc k); 2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n  \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                    \\<le> local.mahler_approximation_main (dd * dd) c\n                           (graeffe_one_step c g) ?xa (Suc k) (2 * kk)\n\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "note mahl = mahler_approximation_main.simps[of dd c g mm k kk]"], ["proof (state)\nthis:\n  local.mahler_approximation_main dd c g mm k kk =\n  (let mmm = mahler_landau_graeffe_approximation kk dd g;\n       new_mm = if k = 0 then mmm else min mm mmm\n   in if bnd \\<le> k then new_mm\n      else local.mahler_approximation_main (dd * dd) c\n            (graeffe_one_step c g) new_mm (Suc k) (2 * kk))\n\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "define mmm where \"mmm = mahler_landau_graeffe_approximation kk dd g\""], ["proof (state)\nthis:\n  mmm = mahler_landau_graeffe_approximation kk dd g\n\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "define new_mm where \"new_mm = (if k = 0 then mmm else min mm mmm)\""], ["proof (state)\nthis:\n  new_mm = (if k = 0 then mmm else min mm mmm)\n\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "let ?cond = \"bnd \\<le> k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "have id: \"mahler_approximation_main dd c g mm k kk = (if ?cond then new_mm\n        else mahler_approximation_main (dd * dd) c (graeffe_one_step c g) new_mm (Suc k) (2 * kk))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.mahler_approximation_main dd c g mm k kk =\n    (if bnd \\<le> k then new_mm\n     else local.mahler_approximation_main (dd * dd) c (graeffe_one_step c g)\n           new_mm (Suc k) (2 * kk))", "unfolding mahl mmm_def[symmetric] Let_def new_mm_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if bnd \\<le> k then new_mm\n     else local.mahler_approximation_main (dd * dd) c (graeffe_one_step c g)\n           new_mm (Suc k) (2 * kk)) =\n    (if bnd \\<le> k then new_mm\n     else local.mahler_approximation_main (dd * dd) c (graeffe_one_step c g)\n           new_mm (Suc k) (2 * kk))", "by simp"], ["proof (state)\nthis:\n  local.mahler_approximation_main dd c g mm k kk =\n  (if bnd \\<le> k then new_mm\n   else local.mahler_approximation_main (dd * dd) c (graeffe_one_step c g)\n         new_mm (Suc k) (2 * kk))\n\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "have gg: \"g = (graeffe_poly_impl f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = graeffe_poly_impl f k", "unfolding g graeffe_poly_impl_def c"], ["proof (prove)\ngoal (1 subgoal):\n 1. graeffe_poly_impl_main ((- 1) ^ degree f) f k =\n    graeffe_poly_impl_main ((- 1) ^ degree f) f k", ".."], ["proof (state)\nthis:\n  g = graeffe_poly_impl f k\n\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "from mahler_landau_graeffe_approximation[OF gg dd kk, folded mmm_def]"], ["proof (chain)\npicking this:\n  \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mmm", "have mmm: \"?df \\<le> mmm\""], ["proof (prove)\nusing this:\n  \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mmm\n\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mmm", "."], ["proof (state)\nthis:\n  \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mmm\n\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "with mm"], ["proof (chain)\npicking this:\n  k \\<noteq> 0 \\<Longrightarrow>\n  \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm\n  \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mmm", "have new_mm: \"?df \\<le> new_mm\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0 \\<Longrightarrow>\n  \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm\n  \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mmm\n\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> new_mm", "unfolding new_mm_def"], ["proof (prove)\nusing this:\n  k \\<noteq> 0 \\<Longrightarrow>\n  \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm\n  \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mmm\n\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> (if k = 0 then mmm else min mm mmm)", "by auto"], ["proof (state)\nthis:\n  \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> new_mm\n\ngoal (1 subgoal):\n 1. \\<And>dd c g mm k kk.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>x = mahler_landau_graeffe_approximation kk dd g;\n                    xa = (if k = 0 then x else min mm x);\n                    \\<not> bnd \\<le> k;\n                    Suc k \\<noteq> 0 \\<Longrightarrow>\n                    \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> xa;\n                    c = (- 1) ^ degree f;\n                    graeffe_one_step c g =\n                    graeffe_poly_impl_main c f (Suc k);\n                    dd * dd = d ^ 2 ^ Suc (Suc k);\n                    2 * kk = 2 ^ Suc (Suc k)\\<rbrakk>\n                   \\<Longrightarrow> \\<lfloor>real d *\n        mahler_measure f\\<rfloor>\n                                     \\<le> local.mahler_approximation_main\n      (dd * dd) c (graeffe_one_step c g) xa (Suc k) (2 * kk);\n        k \\<noteq> 0 \\<Longrightarrow>\n        \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mm;\n        c = (- 1) ^ degree f; g = graeffe_poly_impl_main c f k;\n        dd = d ^ 2 ^ Suc k; kk = 2 ^ Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>real d * mahler_measure f\\<rfloor>\n                         \\<le> local.mahler_approximation_main dd c g mm k\n                                kk", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main dd c g mm k kk", "proof (cases ?cond)"], ["proof (state)\ngoal (2 subgoals):\n 1. bnd \\<le> k \\<Longrightarrow>\n    \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main dd c g mm k kk\n 2. \\<not> bnd \\<le> k \\<Longrightarrow>\n    \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main dd c g mm k kk", "case True"], ["proof (state)\nthis:\n  bnd \\<le> k\n\ngoal (2 subgoals):\n 1. bnd \\<le> k \\<Longrightarrow>\n    \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main dd c g mm k kk\n 2. \\<not> bnd \\<le> k \\<Longrightarrow>\n    \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main dd c g mm k kk", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main dd c g mm k kk", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> (if bnd \\<le> k then new_mm\n           else local.mahler_approximation_main (dd * dd) c\n                 (graeffe_one_step c g) new_mm (Suc k) (2 * kk))", "using True new_mm"], ["proof (prove)\nusing this:\n  bnd \\<le> k\n  \\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> new_mm\n\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> (if bnd \\<le> k then new_mm\n           else local.mahler_approximation_main (dd * dd) c\n                 (graeffe_one_step c g) new_mm (Suc k) (2 * kk))", "by auto"], ["proof (state)\nthis:\n  \\<lfloor>real d * mahler_measure f\\<rfloor>\n  \\<le> local.mahler_approximation_main dd c g mm k kk\n\ngoal (1 subgoal):\n 1. \\<not> bnd \\<le> k \\<Longrightarrow>\n    \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main dd c g mm k kk", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> bnd \\<le> k \\<Longrightarrow>\n    \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main dd c g mm k kk", "case False"], ["proof (state)\nthis:\n  \\<not> bnd \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> bnd \\<le> k \\<Longrightarrow>\n    \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main dd c g mm k kk", "hence id: \"mahler_approximation_main dd c g mm k kk = \n      mahler_approximation_main (dd * dd) c (graeffe_one_step c g) new_mm (Suc k) (2 * kk)\""], ["proof (prove)\nusing this:\n  \\<not> bnd \\<le> k\n\ngoal (1 subgoal):\n 1. local.mahler_approximation_main dd c g mm k kk =\n    local.mahler_approximation_main (dd * dd) c (graeffe_one_step c g)\n     new_mm (Suc k) (2 * kk)", "unfolding id"], ["proof (prove)\nusing this:\n  \\<not> bnd \\<le> k\n\ngoal (1 subgoal):\n 1. (if bnd \\<le> k then new_mm\n     else local.mahler_approximation_main (dd * dd) c (graeffe_one_step c g)\n           new_mm (Suc k) (2 * kk)) =\n    local.mahler_approximation_main (dd * dd) c (graeffe_one_step c g)\n     new_mm (Suc k) (2 * kk)", "by auto"], ["proof (state)\nthis:\n  local.mahler_approximation_main dd c g mm k kk =\n  local.mahler_approximation_main (dd * dd) c (graeffe_one_step c g) new_mm\n   (Suc k) (2 * kk)\n\ngoal (1 subgoal):\n 1. \\<not> bnd \\<le> k \\<Longrightarrow>\n    \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main dd c g mm k kk", "have id': \"graeffe_one_step c g = graeffe_poly_impl_main c f (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graeffe_one_step c g = graeffe_poly_impl_main c f (Suc k)", "unfolding g"], ["proof (prove)\ngoal (1 subgoal):\n 1. graeffe_one_step c (graeffe_poly_impl_main c f k) =\n    graeffe_poly_impl_main c f (Suc k)", "by simp"], ["proof (state)\nthis:\n  graeffe_one_step c g = graeffe_poly_impl_main c f (Suc k)\n\ngoal (1 subgoal):\n 1. \\<not> bnd \\<le> k \\<Longrightarrow>\n    \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main dd c g mm k kk", "have \"dd * dd = d ^ 2 ^ Suc (Suc k)\" \"2 * kk = 2 ^ Suc (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dd * dd = d ^ 2 ^ Suc (Suc k) &&& 2 * kk = 2 ^ Suc (Suc k)", "unfolding dd kk\n      semiring_normalization_rules(26)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d ^ (2 ^ Suc k + 2 ^ Suc k) = d ^ 2 ^ Suc (Suc k) &&&\n    2 * 2 ^ Suc k = 2 ^ Suc (Suc k)", "by auto"], ["proof (state)\nthis:\n  dd * dd = d ^ 2 ^ Suc (Suc k)\n  2 * kk = 2 ^ Suc (Suc k)\n\ngoal (1 subgoal):\n 1. \\<not> bnd \\<le> k \\<Longrightarrow>\n    \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main dd c g mm k kk", "from IH[OF mmm_def new_mm_def False new_mm c id' this]"], ["proof (chain)\npicking this:\n  \\<lfloor>real d * mahler_measure f\\<rfloor>\n  \\<le> local.mahler_approximation_main (dd * dd) c (graeffe_one_step c g)\n         new_mm (Suc k) (2 * kk)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lfloor>real d * mahler_measure f\\<rfloor>\n  \\<le> local.mahler_approximation_main (dd * dd) c (graeffe_one_step c g)\n         new_mm (Suc k) (2 * kk)\n\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main dd c g mm k kk", "unfolding id"], ["proof (prove)\nusing this:\n  \\<lfloor>real d * mahler_measure f\\<rfloor>\n  \\<le> local.mahler_approximation_main (dd * dd) c (graeffe_one_step c g)\n         new_mm (Suc k) (2 * kk)\n\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main (dd * dd) c (graeffe_one_step c g)\n           new_mm (Suc k) (2 * kk)", "."], ["proof (state)\nthis:\n  \\<lfloor>real d * mahler_measure f\\<rfloor>\n  \\<le> local.mahler_approximation_main dd c g mm k kk\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lfloor>real d * mahler_measure f\\<rfloor>\n  \\<le> local.mahler_approximation_main dd c g mm k kk\n\ngoal:\nNo subgoals!", "qed"], ["", "definition mahler_approximation :: \"nat \\<Rightarrow> int poly \\<Rightarrow> int\" where\n  \"mahler_approximation d f = mahler_approximation_main (d * d) ((-1)^(degree f)) f (-1) 0 2\""], ["", "lemma mahler_approximation: \"\\<lfloor>real d * mahler_measure f\\<rfloor> \\<le> mahler_approximation d f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation d f", "unfolding mahler_approximation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real d * mahler_measure f\\<rfloor>\n    \\<le> local.mahler_approximation_main (d * d) ((- 1) ^ degree f) f (- 1)\n           0 2", "by (rule mahler_approximation_main, auto simp: semiring_normalization_rules(29))"], ["", "end"], ["", "end"]]}