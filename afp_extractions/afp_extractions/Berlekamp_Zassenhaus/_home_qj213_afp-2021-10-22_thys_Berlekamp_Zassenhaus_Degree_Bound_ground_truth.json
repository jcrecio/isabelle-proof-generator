{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Degree_Bound.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma insort_middle: \"sort (xs @ x # ys) = insort x (sort (xs @ ys))\"", "lemma sum_list_insort[simp]: \n  \"sum_list (insort (d :: 'a :: {comm_monoid_add,linorder}) xs) = d + sum_list xs\"", "lemma half_largest_elements_mono: \"sum_list (drop (length ds div 2) (sort ds))\n    \\<le> sum_list (drop (Suc (length ds) div 2) (insort (d :: nat) (sort ds)))\"", "lemma max_factor_degree_mono: \n  \"max_factor_degree (map degree (fold remove1 ws vs)) \\<le> max_factor_degree (map degree vs)\"", "lemma mset_sub_decompose: \"mset ds \\<subseteq># mset bs + as \\<Longrightarrow> length ds < length bs \\<Longrightarrow> \\<exists> b1 b b2. \n   bs = b1 @ b # b2 \\<and> mset ds \\<subseteq># mset (b1 @ b2) + as\"", "lemma max_factor_degree_aux: fixes es :: \"nat list\" \n  assumes sub: \"mset ds \\<subseteq># mset es\" \n    and len: \"length ds + length ds \\<le> length es\" and sort: \"sorted es\" \n  shows \"sum_list ds \\<le> sum_list (drop (length es div 2) es)\"", "lemma max_factor_degree: assumes sub: \"mset ws \\<subseteq># mset vs\"\n  and len: \"length ws + length ws \\<le> length vs\"\n  shows \"degree (prod_list ws) \\<le> max_factor_degree (map degree vs)\"", "lemma degree_bound: assumes sub: \"mset ws \\<subseteq># mset vs\"\n  and len: \"length ws + length ws \\<le> length vs\"\nshows \"degree (prod_list ws) \\<le> degree_bound vs\""], "translations": [["", "lemma insort_middle: \"sort (xs @ x # ys) = insort x (sort (xs @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort (xs @ x # ys) = insort x (sort (xs @ ys))", "by (metis append.assoc sort_append_Cons_swap sort_snoc)"], ["", "lemma sum_list_insort[simp]: \n  \"sum_list (insort (d :: 'a :: {comm_monoid_add,linorder}) xs) = d + sum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (insort d xs) = d + sum_list xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. sum_list (insort d []) = d + sum_list []\n 2. \\<And>a xs.\n       sum_list (insort d xs) = d + sum_list xs \\<Longrightarrow>\n       sum_list (insort d (a # xs)) = d + sum_list (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  sum_list (insort d xs) = d + sum_list xs\n\ngoal (2 subgoals):\n 1. sum_list (insort d []) = d + sum_list []\n 2. \\<And>a xs.\n       sum_list (insort d xs) = d + sum_list xs \\<Longrightarrow>\n       sum_list (insort d (a # xs)) = d + sum_list (a # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  sum_list (insort d xs) = d + sum_list xs\n\ngoal (1 subgoal):\n 1. sum_list (insort d (x # xs)) = d + sum_list (x # xs)", "by (cases \"d \\<le> x\", auto simp: ac_simps)"], ["proof (state)\nthis:\n  sum_list (insort d (x # xs)) = d + sum_list (x # xs)\n\ngoal (1 subgoal):\n 1. sum_list (insort d []) = d + sum_list []", "qed simp"], ["", "lemma half_largest_elements_mono: \"sum_list (drop (length ds div 2) (sort ds))\n    \\<le> sum_list (drop (Suc (length ds) div 2) (insort (d :: nat) (sort ds)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop (length ds div 2) (sort ds))\n    \\<le> sum_list (drop (Suc (length ds) div 2) (insort d (sort ds)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list (drop (length ds div 2) (sort ds))\n    \\<le> sum_list (drop (Suc (length ds) div 2) (insort d (sort ds)))", "define n  where \"n  = length ds div 2\""], ["proof (state)\nthis:\n  n = length ds div 2\n\ngoal (1 subgoal):\n 1. sum_list (drop (length ds div 2) (sort ds))\n    \\<le> sum_list (drop (Suc (length ds) div 2) (insort d (sort ds)))", "define m  where \"m  = Suc (length ds) div 2\""], ["proof (state)\nthis:\n  m = Suc (length ds) div 2\n\ngoal (1 subgoal):\n 1. sum_list (drop (length ds div 2) (sort ds))\n    \\<le> sum_list (drop (Suc (length ds) div 2) (insort d (sort ds)))", "define xs where \"xs = sort ds\""], ["proof (state)\nthis:\n  xs = sort ds\n\ngoal (1 subgoal):\n 1. sum_list (drop (length ds div 2) (sort ds))\n    \\<le> sum_list (drop (Suc (length ds) div 2) (insort d (sort ds)))", "have xs: \"sorted xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted xs", "unfolding xs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (sort ds)", "by auto"], ["proof (state)\nthis:\n  sorted xs\n\ngoal (1 subgoal):\n 1. sum_list (drop (length ds div 2) (sort ds))\n    \\<le> sum_list (drop (Suc (length ds) div 2) (insort d (sort ds)))", "have nm: \"m \\<in> {n, Suc n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> {n, Suc n}", "unfolding n_def m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (length ds) div 2 \\<in> {length ds div 2, Suc (length ds div 2)}", "by auto"], ["proof (state)\nthis:\n  m \\<in> {n, Suc n}\n\ngoal (1 subgoal):\n 1. sum_list (drop (length ds div 2) (sort ds))\n    \\<le> sum_list (drop (Suc (length ds) div 2) (insort d (sort ds)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop (length ds div 2) (sort ds))\n    \\<le> sum_list (drop (Suc (length ds) div 2) (insort d (sort ds)))", "unfolding n_def[symmetric] m_def[symmetric] xs_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop n xs) \\<le> sum_list (drop m (insort d xs))", "using nm xs"], ["proof (prove)\nusing this:\n  m \\<in> {n, Suc n}\n  sorted xs\n\ngoal (1 subgoal):\n 1. sum_list (drop n xs) \\<le> sum_list (drop m (insort d xs))", "proof (induct xs arbitrary: n m d)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n m d.\n       \\<lbrakk>m \\<in> {n, Suc n}; sorted []\\<rbrakk>\n       \\<Longrightarrow> sum_list (drop n [])\n                         \\<le> sum_list (drop m (insort d []))\n 2. \\<And>a xs n m d.\n       \\<lbrakk>\\<And>n m d.\n                   \\<lbrakk>m \\<in> {n, Suc n}; sorted xs\\<rbrakk>\n                   \\<Longrightarrow> sum_list (drop n xs)\n                                     \\<le> sum_list (drop m (insort d xs));\n        m \\<in> {n, Suc n}; sorted (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sum_list (drop n (a # xs))\n                         \\<le> sum_list (drop m (insort d (a # xs)))", "case (Cons x xs n m d)"], ["proof (state)\nthis:\n  \\<lbrakk>?m \\<in> {?n, Suc ?n}; sorted xs\\<rbrakk>\n  \\<Longrightarrow> sum_list (drop ?n xs)\n                    \\<le> sum_list (drop ?m (insort ?d xs))\n  m \\<in> {n, Suc n}\n  sorted (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>n m d.\n       \\<lbrakk>m \\<in> {n, Suc n}; sorted []\\<rbrakk>\n       \\<Longrightarrow> sum_list (drop n [])\n                         \\<le> sum_list (drop m (insort d []))\n 2. \\<And>a xs n m d.\n       \\<lbrakk>\\<And>n m d.\n                   \\<lbrakk>m \\<in> {n, Suc n}; sorted xs\\<rbrakk>\n                   \\<Longrightarrow> sum_list (drop n xs)\n                                     \\<le> sum_list (drop m (insort d xs));\n        m \\<in> {n, Suc n}; sorted (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sum_list (drop n (a # xs))\n                         \\<le> sum_list (drop m (insort d (a # xs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       sum_list (drop n (x # xs))\n       \\<le> sum_list (drop m (insort d (x # xs)))", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       sum_list (drop n (x # xs))\n       \\<le> sum_list (drop m (insort d (x # xs)))", "with Cons(2)"], ["proof (chain)\npicking this:\n  m \\<in> {n, Suc n}\n  n = 0", "have m: \"m = 0 \\<or> m = 1\""], ["proof (prove)\nusing this:\n  m \\<in> {n, Suc n}\n  n = 0\n\ngoal (1 subgoal):\n 1. m = 0 \\<or> m = 1", "by auto"], ["proof (state)\nthis:\n  m = 0 \\<or> m = 1\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       sum_list (drop n (x # xs))\n       \\<le> sum_list (drop m (insort d (x # xs)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "proof (cases \"d \\<le> x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))\n 2. \\<not> d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "case True"], ["proof (state)\nthis:\n  d \\<le> x\n\ngoal (2 subgoals):\n 1. d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))\n 2. \\<not> d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "hence ins: \"insort d (x # xs) = d # x # xs\""], ["proof (prove)\nusing this:\n  d \\<le> x\n\ngoal (1 subgoal):\n 1. insort d (x # xs) = d # x # xs", "by auto"], ["proof (state)\nthis:\n  insort d (x # xs) = d # x # xs\n\ngoal (2 subgoals):\n 1. d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))\n 2. \\<not> d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "unfolding ins 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop 0 (x # xs)) \\<le> sum_list (drop m (d # x # xs))", "using True m"], ["proof (prove)\nusing this:\n  d \\<le> x\n  m = 0 \\<or> m = 1\n\ngoal (1 subgoal):\n 1. sum_list (drop 0 (x # xs)) \\<le> sum_list (drop m (d # x # xs))", "by auto"], ["proof (state)\nthis:\n  sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "case False"], ["proof (state)\nthis:\n  \\<not> d \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "hence ins: \"insort d (x # xs) = x # insort d xs\""], ["proof (prove)\nusing this:\n  \\<not> d \\<le> x\n\ngoal (1 subgoal):\n 1. insort d (x # xs) = x # insort d xs", "by auto"], ["proof (state)\nthis:\n  insort d (x # xs) = x # insort d xs\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "unfolding ins 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop 0 (x # xs)) \\<le> sum_list (drop m (x # insort d xs))", "using False m"], ["proof (prove)\nusing this:\n  \\<not> d \\<le> x\n  m = 0 \\<or> m = 1\n\ngoal (1 subgoal):\n 1. sum_list (drop 0 (x # xs)) \\<le> sum_list (drop m (x # insort d xs))", "by auto"], ["proof (state)\nthis:\n  sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       sum_list (drop n (x # xs))\n       \\<le> sum_list (drop m (insort d (x # xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       sum_list (drop n (x # xs))\n       \\<le> sum_list (drop m (insort d (x # xs)))", "case (Suc nn)"], ["proof (state)\nthis:\n  n = Suc nn\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       sum_list (drop n (x # xs))\n       \\<le> sum_list (drop m (insort d (x # xs)))", "with Cons(2)"], ["proof (chain)\npicking this:\n  m \\<in> {n, Suc n}\n  n = Suc nn", "obtain mm where m: \"m = Suc mm\" and mm: \"mm \\<in> {nn, Suc nn}\""], ["proof (prove)\nusing this:\n  m \\<in> {n, Suc n}\n  n = Suc nn\n\ngoal (1 subgoal):\n 1. (\\<And>mm.\n        \\<lbrakk>m = Suc mm; mm \\<in> {nn, Suc nn}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  m = Suc mm\n  mm \\<in> {nn, Suc nn}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       sum_list (drop n (x # xs))\n       \\<le> sum_list (drop m (insort d (x # xs)))", "from Cons(3)"], ["proof (chain)\npicking this:\n  sorted (x # xs)", "have sort: \"sorted xs\""], ["proof (prove)\nusing this:\n  sorted (x # xs)\n\ngoal (1 subgoal):\n 1. sorted xs", "by (simp)"], ["proof (state)\nthis:\n  sorted xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       sum_list (drop n (x # xs))\n       \\<le> sum_list (drop m (insort d (x # xs)))", "note IH = Cons(1)[OF mm]"], ["proof (state)\nthis:\n  sorted xs \\<Longrightarrow>\n  sum_list (drop nn xs) \\<le> sum_list (drop mm (insort ?d xs))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       sum_list (drop n (x # xs))\n       \\<le> sum_list (drop m (insort d (x # xs)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "proof (cases \"d \\<le> x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))\n 2. \\<not> d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "case True"], ["proof (state)\nthis:\n  d \\<le> x\n\ngoal (2 subgoals):\n 1. d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))\n 2. \\<not> d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "with Cons(3)"], ["proof (chain)\npicking this:\n  sorted (x # xs)\n  d \\<le> x", "have ins: \"insort d (x # xs) = d # insort x xs\""], ["proof (prove)\nusing this:\n  sorted (x # xs)\n  d \\<le> x\n\ngoal (1 subgoal):\n 1. insort d (x # xs) = d # insort x xs", "by (cases xs, auto)"], ["proof (state)\nthis:\n  insort d (x # xs) = d # insort x xs\n\ngoal (2 subgoals):\n 1. d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))\n 2. \\<not> d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "unfolding ins Suc m"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop (Suc nn) (x # xs))\n    \\<le> sum_list (drop (Suc mm) (d # insort x xs))", "using IH[OF sort]"], ["proof (prove)\nusing this:\n  sum_list (drop nn xs) \\<le> sum_list (drop mm (insort ?d xs))\n\ngoal (1 subgoal):\n 1. sum_list (drop (Suc nn) (x # xs))\n    \\<le> sum_list (drop (Suc mm) (d # insort x xs))", "by auto"], ["proof (state)\nthis:\n  sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "case False"], ["proof (state)\nthis:\n  \\<not> d \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "hence ins: \"insort d (x # xs) = x # insort d xs\""], ["proof (prove)\nusing this:\n  \\<not> d \\<le> x\n\ngoal (1 subgoal):\n 1. insort d (x # xs) = x # insort d xs", "by auto"], ["proof (state)\nthis:\n  insort d (x # xs) = x # insort d xs\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> x \\<Longrightarrow>\n    sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))", "unfolding ins Suc m"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop (Suc nn) (x # xs))\n    \\<le> sum_list (drop (Suc mm) (x # insort d xs))", "using IH[OF sort] Cons(3)"], ["proof (prove)\nusing this:\n  sum_list (drop nn xs) \\<le> sum_list (drop mm (insort ?d xs))\n  sorted (x # xs)\n\ngoal (1 subgoal):\n 1. sum_list (drop (Suc nn) (x # xs))\n    \\<le> sum_list (drop (Suc mm) (x # insort d xs))", "by auto"], ["proof (state)\nthis:\n  sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (drop n (x # xs)) \\<le> sum_list (drop m (insort d (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>n m d.\n       \\<lbrakk>m \\<in> {n, Suc n}; sorted []\\<rbrakk>\n       \\<Longrightarrow> sum_list (drop n [])\n                         \\<le> sum_list (drop m (insort d []))", "qed auto"], ["proof (state)\nthis:\n  sum_list (drop (length ds div 2) (sort ds))\n  \\<le> sum_list (drop (Suc (length ds) div 2) (insort d (sort ds)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_factor_degree_mono: \n  \"max_factor_degree (map degree (fold remove1 ws vs)) \\<le> max_factor_degree (map degree vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_factor_degree (map degree (fold remove1 ws vs))\n    \\<le> max_factor_degree (map degree vs)", "unfolding max_factor_degree_def Let_def length_sort length_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (drop (length (fold remove1 ws vs) div 2)\n       (sort (map degree (fold remove1 ws vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "proof (induct ws arbitrary: vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       sum_list\n        (drop (length (fold remove1 [] vs) div 2)\n          (sort (map degree (fold remove1 [] vs))))\n       \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))\n 2. \\<And>a ws vs.\n       (\\<And>vs.\n           sum_list\n            (drop (length (fold remove1 ws vs) div 2)\n              (sort (map degree (fold remove1 ws vs))))\n           \\<le> sum_list\n                  (drop (length vs div 2)\n                    (sort (map degree vs)))) \\<Longrightarrow>\n       sum_list\n        (drop (length (fold remove1 (a # ws) vs) div 2)\n          (sort (map degree (fold remove1 (a # ws) vs))))\n       \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "case (Cons w ws vs)"], ["proof (state)\nthis:\n  sum_list\n   (drop (length (fold remove1 ws ?vs) div 2)\n     (sort (map degree (fold remove1 ws ?vs))))\n  \\<le> sum_list (drop (length ?vs div 2) (sort (map degree ?vs)))\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       sum_list\n        (drop (length (fold remove1 [] vs) div 2)\n          (sort (map degree (fold remove1 [] vs))))\n       \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))\n 2. \\<And>a ws vs.\n       (\\<And>vs.\n           sum_list\n            (drop (length (fold remove1 ws vs) div 2)\n              (sort (map degree (fold remove1 ws vs))))\n           \\<le> sum_list\n                  (drop (length vs div 2)\n                    (sort (map degree vs)))) \\<Longrightarrow>\n       sum_list\n        (drop (length (fold remove1 (a # ws) vs) div 2)\n          (sort (map degree (fold remove1 (a # ws) vs))))\n       \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "proof (cases \"w \\<in> set vs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))\n 2. w \\<notin> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "case False"], ["proof (state)\nthis:\n  w \\<notin> set vs\n\ngoal (2 subgoals):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))\n 2. w \\<notin> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "hence \"remove1 w vs = vs\""], ["proof (prove)\nusing this:\n  w \\<notin> set vs\n\ngoal (1 subgoal):\n 1. remove1 w vs = vs", "by (rule remove1_idem)"], ["proof (state)\nthis:\n  remove1 w vs = vs\n\ngoal (2 subgoals):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))\n 2. w \\<notin> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  remove1 w vs = vs\n\ngoal (1 subgoal):\n 1. sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "using Cons[of vs]"], ["proof (prove)\nusing this:\n  remove1 w vs = vs\n  sum_list\n   (drop (length (fold remove1 ws vs) div 2)\n     (sort (map degree (fold remove1 ws vs))))\n  \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))\n\ngoal (1 subgoal):\n 1. sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "by auto"], ["proof (state)\nthis:\n  sum_list\n   (drop (length (fold remove1 (w # ws) vs) div 2)\n     (sort (map degree (fold remove1 (w # ws) vs))))\n  \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))\n\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "case True"], ["proof (state)\nthis:\n  w \\<in> set vs\n\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "then"], ["proof (chain)\npicking this:\n  w \\<in> set vs", "obtain bef aft where vs: \"vs = bef @ w # aft\" and rem1: \"remove1 w vs = bef @ aft\""], ["proof (prove)\nusing this:\n  w \\<in> set vs\n\ngoal (1 subgoal):\n 1. (\\<And>bef aft.\n        \\<lbrakk>vs = bef @ w # aft; remove1 w vs = bef @ aft\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis remove1.simps(2) remove1_append split_list_first)"], ["proof (state)\nthis:\n  vs = bef @ w # aft\n  remove1 w vs = bef @ aft\n\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "let ?exp = \"\\<lambda> ws vs. sum_list (drop (length (fold remove1 ws vs) div 2) \n      (sort (map degree (fold remove1 ws vs))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "let ?bnd = \"\\<lambda> vs. sum_list (drop (length vs div 2) (sort (map degree vs)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "let ?bd = \"\\<lambda> vs. sum_list (drop (length vs div 2) (sort vs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "define ba where \"ba = bef @ aft\""], ["proof (state)\nthis:\n  ba = bef @ aft\n\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "define ds where \"ds = map degree ba\""], ["proof (state)\nthis:\n  ds = map degree ba\n\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "define d  where \"d  = degree w\""], ["proof (state)\nthis:\n  d = degree w\n\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "have \"?exp (w # ws) vs = ?exp ws (bef @ aft)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs)))) =\n    sum_list\n     (drop (length (fold remove1 ws (bef @ aft)) div 2)\n       (sort (map degree (fold remove1 ws (bef @ aft)))))", "by (auto simp: rem1)"], ["proof (state)\nthis:\n  sum_list\n   (drop (length (fold remove1 (w # ws) vs) div 2)\n     (sort (map degree (fold remove1 (w # ws) vs)))) =\n  sum_list\n   (drop (length (fold remove1 ws (bef @ aft)) div 2)\n     (sort (map degree (fold remove1 ws (bef @ aft)))))\n\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "also"], ["proof (state)\nthis:\n  sum_list\n   (drop (length (fold remove1 (w # ws) vs) div 2)\n     (sort (map degree (fold remove1 (w # ws) vs)))) =\n  sum_list\n   (drop (length (fold remove1 ws (bef @ aft)) div 2)\n     (sort (map degree (fold remove1 ws (bef @ aft)))))\n\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "have \"\\<dots> \\<le> ?bnd ba\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (drop (length (fold remove1 ws (bef @ aft)) div 2)\n       (sort (map degree (fold remove1 ws (bef @ aft)))))\n    \\<le> sum_list (drop (length ba div 2) (sort (map degree ba)))", "unfolding ba_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (drop (length (fold remove1 ws (bef @ aft)) div 2)\n       (sort (map degree (fold remove1 ws (bef @ aft)))))\n    \\<le> sum_list\n           (drop (length (bef @ aft) div 2) (sort (map degree (bef @ aft))))", "by (rule Cons)"], ["proof (state)\nthis:\n  sum_list\n   (drop (length (fold remove1 ws (bef @ aft)) div 2)\n     (sort (map degree (fold remove1 ws (bef @ aft)))))\n  \\<le> sum_list (drop (length ba div 2) (sort (map degree ba)))\n\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "also"], ["proof (state)\nthis:\n  sum_list\n   (drop (length (fold remove1 ws (bef @ aft)) div 2)\n     (sort (map degree (fold remove1 ws (bef @ aft)))))\n  \\<le> sum_list (drop (length ba div 2) (sort (map degree ba)))\n\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "have \"\\<dots> = ?bd ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop (length ba div 2) (sort (map degree ba))) =\n    sum_list (drop (length ds div 2) (sort ds))", "unfolding ds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop (length ba div 2) (sort (map degree ba))) =\n    sum_list (drop (length (map degree ba) div 2) (sort (map degree ba)))", "by simp"], ["proof (state)\nthis:\n  sum_list (drop (length ba div 2) (sort (map degree ba))) =\n  sum_list (drop (length ds div 2) (sort ds))\n\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "also"], ["proof (state)\nthis:\n  sum_list (drop (length ba div 2) (sort (map degree ba))) =\n  sum_list (drop (length ds div 2) (sort ds))\n\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "have \"\\<dots> \\<le> sum_list (drop (Suc (length ds) div 2) (insort d (sort ds)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop (length ds div 2) (sort ds))\n    \\<le> sum_list (drop (Suc (length ds) div 2) (insort d (sort ds)))", "by (rule half_largest_elements_mono)"], ["proof (state)\nthis:\n  sum_list (drop (length ds div 2) (sort ds))\n  \\<le> sum_list (drop (Suc (length ds) div 2) (insort d (sort ds)))\n\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "also"], ["proof (state)\nthis:\n  sum_list (drop (length ds div 2) (sort ds))\n  \\<le> sum_list (drop (Suc (length ds) div 2) (insort d (sort ds)))\n\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "have \"\\<dots> = ?bnd vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (drop (Suc (length ds) div 2) (insort d (sort ds))) =\n    sum_list (drop (length vs div 2) (sort (map degree vs)))", "unfolding vs ds_def d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (drop (Suc (length (map degree ba)) div 2)\n       (insort (degree w) (sort (map degree ba)))) =\n    sum_list\n     (drop (length (bef @ w # aft) div 2)\n       (sort (map degree (bef @ w # aft))))", "by (simp add: ba_def insort_middle)"], ["proof (state)\nthis:\n  sum_list (drop (Suc (length ds) div 2) (insort d (sort ds))) =\n  sum_list (drop (length vs div 2) (sort (map degree vs)))\n\ngoal (1 subgoal):\n 1. w \\<in> set vs \\<Longrightarrow>\n    sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "finally"], ["proof (chain)\npicking this:\n  sum_list\n   (drop (length (fold remove1 (w # ws) vs) div 2)\n     (sort (map degree (fold remove1 (w # ws) vs))))\n  \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "show \"?exp (w # ws) vs \\<le> ?bnd vs\""], ["proof (prove)\nusing this:\n  sum_list\n   (drop (length (fold remove1 (w # ws) vs) div 2)\n     (sort (map degree (fold remove1 (w # ws) vs))))\n  \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))\n\ngoal (1 subgoal):\n 1. sum_list\n     (drop (length (fold remove1 (w # ws) vs) div 2)\n       (sort (map degree (fold remove1 (w # ws) vs))))\n    \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "by simp"], ["proof (state)\nthis:\n  sum_list\n   (drop (length (fold remove1 (w # ws) vs) div 2)\n     (sort (map degree (fold remove1 (w # ws) vs))))\n  \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list\n   (drop (length (fold remove1 (w # ws) vs) div 2)\n     (sort (map degree (fold remove1 (w # ws) vs))))\n  \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))\n\ngoal (1 subgoal):\n 1. \\<And>vs.\n       sum_list\n        (drop (length (fold remove1 [] vs) div 2)\n          (sort (map degree (fold remove1 [] vs))))\n       \\<le> sum_list (drop (length vs div 2) (sort (map degree vs)))", "qed auto"], ["", "lemma mset_sub_decompose: \"mset ds \\<subseteq># mset bs + as \\<Longrightarrow> length ds < length bs \\<Longrightarrow> \\<exists> b1 b b2. \n   bs = b1 @ b # b2 \\<and> mset ds \\<subseteq># mset (b1 @ b2) + as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mset ds \\<subseteq># mset bs + as;\n     length ds < length bs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>b1 b b2.\n                         bs = b1 @ b # b2 \\<and>\n                         mset ds \\<subseteq># mset (b1 @ b2) + as", "proof (induct ds arbitrary: bs as)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs as.\n       \\<lbrakk>mset [] \\<subseteq># mset bs + as;\n        length [] < length bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b1 b b2.\n                            bs = b1 @ b # b2 \\<and>\n                            mset [] \\<subseteq># mset (b1 @ b2) + as\n 2. \\<And>a ds bs as.\n       \\<lbrakk>\\<And>bs as.\n                   \\<lbrakk>mset ds \\<subseteq># mset bs + as;\n                    length ds < length bs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>b1 b b2.\n  bs = b1 @ b # b2 \\<and> mset ds \\<subseteq># mset (b1 @ b2) + as;\n        mset (a # ds) \\<subseteq># mset bs + as;\n        length (a # ds) < length bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b1 b b2.\n                            bs = b1 @ b # b2 \\<and>\n                            mset (a # ds) \\<subseteq># mset (b1 @ b2) + as", "case Nil"], ["proof (state)\nthis:\n  mset [] \\<subseteq># mset bs + as\n  length [] < length bs\n\ngoal (2 subgoals):\n 1. \\<And>bs as.\n       \\<lbrakk>mset [] \\<subseteq># mset bs + as;\n        length [] < length bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b1 b b2.\n                            bs = b1 @ b # b2 \\<and>\n                            mset [] \\<subseteq># mset (b1 @ b2) + as\n 2. \\<And>a ds bs as.\n       \\<lbrakk>\\<And>bs as.\n                   \\<lbrakk>mset ds \\<subseteq># mset bs + as;\n                    length ds < length bs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>b1 b b2.\n  bs = b1 @ b # b2 \\<and> mset ds \\<subseteq># mset (b1 @ b2) + as;\n        mset (a # ds) \\<subseteq># mset bs + as;\n        length (a # ds) < length bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b1 b b2.\n                            bs = b1 @ b # b2 \\<and>\n                            mset (a # ds) \\<subseteq># mset (b1 @ b2) + as", "hence \"bs = [] @ hd bs # tl bs\""], ["proof (prove)\nusing this:\n  mset [] \\<subseteq># mset bs + as\n  length [] < length bs\n\ngoal (1 subgoal):\n 1. bs = [] @ hd bs # tl bs", "by auto"], ["proof (state)\nthis:\n  bs = [] @ hd bs # tl bs\n\ngoal (2 subgoals):\n 1. \\<And>bs as.\n       \\<lbrakk>mset [] \\<subseteq># mset bs + as;\n        length [] < length bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b1 b b2.\n                            bs = b1 @ b # b2 \\<and>\n                            mset [] \\<subseteq># mset (b1 @ b2) + as\n 2. \\<And>a ds bs as.\n       \\<lbrakk>\\<And>bs as.\n                   \\<lbrakk>mset ds \\<subseteq># mset bs + as;\n                    length ds < length bs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>b1 b b2.\n  bs = b1 @ b # b2 \\<and> mset ds \\<subseteq># mset (b1 @ b2) + as;\n        mset (a # ds) \\<subseteq># mset bs + as;\n        length (a # ds) < length bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b1 b b2.\n                            bs = b1 @ b # b2 \\<and>\n                            mset (a # ds) \\<subseteq># mset (b1 @ b2) + as", "thus ?case"], ["proof (prove)\nusing this:\n  bs = [] @ hd bs # tl bs\n\ngoal (1 subgoal):\n 1. \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and> mset [] \\<subseteq># mset (b1 @ b2) + as", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>b1 b b2.\n     bs = b1 @ b # b2 \\<and> mset [] \\<subseteq># mset (b1 @ b2) + as\n\ngoal (1 subgoal):\n 1. \\<And>a ds bs as.\n       \\<lbrakk>\\<And>bs as.\n                   \\<lbrakk>mset ds \\<subseteq># mset bs + as;\n                    length ds < length bs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>b1 b b2.\n  bs = b1 @ b # b2 \\<and> mset ds \\<subseteq># mset (b1 @ b2) + as;\n        mset (a # ds) \\<subseteq># mset bs + as;\n        length (a # ds) < length bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b1 b b2.\n                            bs = b1 @ b # b2 \\<and>\n                            mset (a # ds) \\<subseteq># mset (b1 @ b2) + as", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ds bs as.\n       \\<lbrakk>\\<And>bs as.\n                   \\<lbrakk>mset ds \\<subseteq># mset bs + as;\n                    length ds < length bs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>b1 b b2.\n  bs = b1 @ b # b2 \\<and> mset ds \\<subseteq># mset (b1 @ b2) + as;\n        mset (a # ds) \\<subseteq># mset bs + as;\n        length (a # ds) < length bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b1 b b2.\n                            bs = b1 @ b # b2 \\<and>\n                            mset (a # ds) \\<subseteq># mset (b1 @ b2) + as", "case (Cons d ds bs as)"], ["proof (state)\nthis:\n  \\<lbrakk>mset ds \\<subseteq># mset ?bs + ?as;\n   length ds < length ?bs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b1 b b2.\n                       ?bs = b1 @ b # b2 \\<and>\n                       mset ds \\<subseteq># mset (b1 @ b2) + ?as\n  mset (d # ds) \\<subseteq># mset bs + as\n  length (d # ds) < length bs\n\ngoal (1 subgoal):\n 1. \\<And>a ds bs as.\n       \\<lbrakk>\\<And>bs as.\n                   \\<lbrakk>mset ds \\<subseteq># mset bs + as;\n                    length ds < length bs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>b1 b b2.\n  bs = b1 @ b # b2 \\<and> mset ds \\<subseteq># mset (b1 @ b2) + as;\n        mset (a # ds) \\<subseteq># mset bs + as;\n        length (a # ds) < length bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b1 b b2.\n                            bs = b1 @ b # b2 \\<and>\n                            mset (a # ds) \\<subseteq># mset (b1 @ b2) + as", "have \"d \\<in># mset (d # ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<in># mset (d # ds)", "by auto"], ["proof (state)\nthis:\n  d \\<in># mset (d # ds)\n\ngoal (1 subgoal):\n 1. \\<And>a ds bs as.\n       \\<lbrakk>\\<And>bs as.\n                   \\<lbrakk>mset ds \\<subseteq># mset bs + as;\n                    length ds < length bs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>b1 b b2.\n  bs = b1 @ b # b2 \\<and> mset ds \\<subseteq># mset (b1 @ b2) + as;\n        mset (a # ds) \\<subseteq># mset bs + as;\n        length (a # ds) < length bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b1 b b2.\n                            bs = b1 @ b # b2 \\<and>\n                            mset (a # ds) \\<subseteq># mset (b1 @ b2) + as", "with Cons(2)"], ["proof (chain)\npicking this:\n  mset (d # ds) \\<subseteq># mset bs + as\n  d \\<in># mset (d # ds)", "have d: \"d \\<in># mset bs + as\""], ["proof (prove)\nusing this:\n  mset (d # ds) \\<subseteq># mset bs + as\n  d \\<in># mset (d # ds)\n\ngoal (1 subgoal):\n 1. d \\<in># mset bs + as", "by (rule mset_subset_eqD)"], ["proof (state)\nthis:\n  d \\<in># mset bs + as\n\ngoal (1 subgoal):\n 1. \\<And>a ds bs as.\n       \\<lbrakk>\\<And>bs as.\n                   \\<lbrakk>mset ds \\<subseteq># mset bs + as;\n                    length ds < length bs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>b1 b b2.\n  bs = b1 @ b # b2 \\<and> mset ds \\<subseteq># mset (b1 @ b2) + as;\n        mset (a # ds) \\<subseteq># mset bs + as;\n        length (a # ds) < length bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b1 b b2.\n                            bs = b1 @ b # b2 \\<and>\n                            mset (a # ds) \\<subseteq># mset (b1 @ b2) + as", "hence \"d \\<in> set bs \\<or> d \\<in># as\""], ["proof (prove)\nusing this:\n  d \\<in># mset bs + as\n\ngoal (1 subgoal):\n 1. d \\<in> set bs \\<or> d \\<in># as", "by auto"], ["proof (state)\nthis:\n  d \\<in> set bs \\<or> d \\<in># as\n\ngoal (1 subgoal):\n 1. \\<And>a ds bs as.\n       \\<lbrakk>\\<And>bs as.\n                   \\<lbrakk>mset ds \\<subseteq># mset bs + as;\n                    length ds < length bs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>b1 b b2.\n  bs = b1 @ b # b2 \\<and> mset ds \\<subseteq># mset (b1 @ b2) + as;\n        mset (a # ds) \\<subseteq># mset bs + as;\n        length (a # ds) < length bs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b1 b b2.\n                            bs = b1 @ b # b2 \\<and>\n                            mset (a # ds) \\<subseteq># mset (b1 @ b2) + as", "thus ?case"], ["proof (prove)\nusing this:\n  d \\<in> set bs \\<or> d \\<in># as\n\ngoal (1 subgoal):\n 1. \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<in> set bs \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n 2. d \\<in># as \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "assume \"d \\<in> set bs\""], ["proof (state)\nthis:\n  d \\<in> set bs\n\ngoal (2 subgoals):\n 1. d \\<in> set bs \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n 2. d \\<in># as \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "from this[unfolded in_set_conv_decomp]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. bs = ys @ d # zs", "obtain b1 b2 where bs: \"bs = b1 @ d # b2\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. bs = ys @ d # zs\n\ngoal (1 subgoal):\n 1. (\\<And>b1 b2.\n        bs = b1 @ d # b2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  bs = b1 @ d # b2\n\ngoal (2 subgoals):\n 1. d \\<in> set bs \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n 2. d \\<in># as \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "from Cons(2) Cons(3)"], ["proof (chain)\npicking this:\n  mset (d # ds) \\<subseteq># mset bs + as\n  length (d # ds) < length bs", "have \"mset ds \\<subseteq># mset (b1 @ b2) + as\" \"length ds < length (b1 @ b2)\""], ["proof (prove)\nusing this:\n  mset (d # ds) \\<subseteq># mset bs + as\n  length (d # ds) < length bs\n\ngoal (1 subgoal):\n 1. mset ds \\<subseteq># mset (b1 @ b2) + as &&&\n    length ds < length (b1 @ b2)", "by (auto simp: ac_simps bs)"], ["proof (state)\nthis:\n  mset ds \\<subseteq># mset (b1 @ b2) + as\n  length ds < length (b1 @ b2)\n\ngoal (2 subgoals):\n 1. d \\<in> set bs \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n 2. d \\<in># as \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "from Cons(1)[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>b1a b b2a.\n     b1 @ b2 = b1a @ b # b2a \\<and>\n     mset ds \\<subseteq># mset (b1a @ b2a) + as", "obtain b1' b b2' where split: \"b1 @ b2 = b1' @ b # b2'\" \n      and sub: \"mset ds \\<subseteq># mset (b1' @ b2') + as\""], ["proof (prove)\nusing this:\n  \\<exists>b1a b b2a.\n     b1 @ b2 = b1a @ b # b2a \\<and>\n     mset ds \\<subseteq># mset (b1a @ b2a) + as\n\ngoal (1 subgoal):\n 1. (\\<And>b1' b b2'.\n        \\<lbrakk>b1 @ b2 = b1' @ b # b2';\n         mset ds \\<subseteq># mset (b1' @ b2') + as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b1 @ b2 = b1' @ b # b2'\n  mset ds \\<subseteq># mset (b1' @ b2') + as\n\ngoal (2 subgoals):\n 1. d \\<in> set bs \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n 2. d \\<in># as \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "from split[unfolded append_eq_append_conv2]"], ["proof (chain)\npicking this:\n  \\<exists>us.\n     b1 = b1' @ us \\<and> us @ b2 = b # b2' \\<or>\n     b1 @ us = b1' \\<and> b2 = us @ b # b2'", "obtain us where \"b1 = b1' @ us \\<and> us @ b2 = b # b2' \\<or> b1 @ us = b1' \\<and> b2 = us @ b # b2'\""], ["proof (prove)\nusing this:\n  \\<exists>us.\n     b1 = b1' @ us \\<and> us @ b2 = b # b2' \\<or>\n     b1 @ us = b1' \\<and> b2 = us @ b # b2'\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        b1 = b1' @ us \\<and> us @ b2 = b # b2' \\<or>\n        b1 @ us = b1' \\<and> b2 = us @ b # b2' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  b1 = b1' @ us \\<and> us @ b2 = b # b2' \\<or>\n  b1 @ us = b1' \\<and> b2 = us @ b # b2'\n\ngoal (2 subgoals):\n 1. d \\<in> set bs \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n 2. d \\<in># as \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "thus ?thesis"], ["proof (prove)\nusing this:\n  b1 = b1' @ us \\<and> us @ b2 = b # b2' \\<or>\n  b1 @ us = b1' \\<and> b2 = us @ b # b2'\n\ngoal (1 subgoal):\n 1. \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. b1 = b1' @ us \\<and> us @ b2 = b # b2' \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n 2. b1 @ us = b1' \\<and> b2 = us @ b # b2' \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "assume \"b1 @ us = b1' \\<and> b2 = us @ b # b2'\""], ["proof (state)\nthis:\n  b1 @ us = b1' \\<and> b2 = us @ b # b2'\n\ngoal (2 subgoals):\n 1. b1 = b1' @ us \\<and> us @ b2 = b # b2' \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n 2. b1 @ us = b1' \\<and> b2 = us @ b # b2' \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "hence *: \"b1 @ us = b1'\" \"b2 = us @ b # b2'\""], ["proof (prove)\nusing this:\n  b1 @ us = b1' \\<and> b2 = us @ b # b2'\n\ngoal (1 subgoal):\n 1. b1 @ us = b1' &&& b2 = us @ b # b2'", "by auto"], ["proof (state)\nthis:\n  b1 @ us = b1'\n  b2 = us @ b # b2'\n\ngoal (2 subgoals):\n 1. b1 = b1' @ us \\<and> us @ b2 = b # b2' \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n 2. b1 @ us = b1' \\<and> b2 = us @ b # b2' \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "hence bs: \"bs = (b1 @ d # us) @ b # b2'\""], ["proof (prove)\nusing this:\n  b1 @ us = b1'\n  b2 = us @ b # b2'\n\ngoal (1 subgoal):\n 1. bs = (b1 @ d # us) @ b # b2'", "unfolding bs"], ["proof (prove)\nusing this:\n  b1 @ us = b1'\n  b2 = us @ b # b2'\n\ngoal (1 subgoal):\n 1. b1 @ d # b2 = (b1 @ d # us) @ b # b2'", "by auto"], ["proof (state)\nthis:\n  bs = (b1 @ d # us) @ b # b2'\n\ngoal (2 subgoals):\n 1. b1 = b1' @ us \\<and> us @ b2 = b # b2' \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n 2. b1 @ us = b1' \\<and> b2 = us @ b # b2' \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "by (intro exI conjI, rule bs, insert * sub, auto simp: ac_simps)"], ["proof (state)\nthis:\n  \\<exists>b1 b b2.\n     bs = b1 @ b # b2 \\<and> mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n\ngoal (1 subgoal):\n 1. b1 = b1' @ us \\<and> us @ b2 = b # b2' \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b1 = b1' @ us \\<and> us @ b2 = b # b2' \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "assume \"b1 = b1' @ us \\<and> us @ b2 = b # b2'\""], ["proof (state)\nthis:\n  b1 = b1' @ us \\<and> us @ b2 = b # b2'\n\ngoal (1 subgoal):\n 1. b1 = b1' @ us \\<and> us @ b2 = b # b2' \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "hence *: \"b1 = b1' @ us\" \"us @ b2 = b # b2'\""], ["proof (prove)\nusing this:\n  b1 = b1' @ us \\<and> us @ b2 = b # b2'\n\ngoal (1 subgoal):\n 1. b1 = b1' @ us &&& us @ b2 = b # b2'", "by auto"], ["proof (state)\nthis:\n  b1 = b1' @ us\n  us @ b2 = b # b2'\n\ngoal (1 subgoal):\n 1. b1 = b1' @ us \\<and> us @ b2 = b # b2' \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "proof (cases us)"], ["proof (state)\ngoal (2 subgoals):\n 1. us = [] \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n 2. \\<And>a list.\n       us = a # list \\<Longrightarrow>\n       \\<exists>b1 b b2.\n          bs = b1 @ b # b2 \\<and>\n          mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "case Nil"], ["proof (state)\nthis:\n  us = []\n\ngoal (2 subgoals):\n 1. us = [] \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n 2. \\<And>a list.\n       us = a # list \\<Longrightarrow>\n       \\<exists>b1 b b2.\n          bs = b1 @ b # b2 \\<and>\n          mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "with *"], ["proof (chain)\npicking this:\n  b1 = b1' @ us\n  us @ b2 = b # b2'\n  us = []", "have *: \"b1 = b1'\" \"b2 = b # b2'\""], ["proof (prove)\nusing this:\n  b1 = b1' @ us\n  us @ b2 = b # b2'\n  us = []\n\ngoal (1 subgoal):\n 1. b1 = b1' &&& b2 = b # b2'", "by auto"], ["proof (state)\nthis:\n  b1 = b1'\n  b2 = b # b2'\n\ngoal (2 subgoals):\n 1. us = [] \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n 2. \\<And>a list.\n       us = a # list \\<Longrightarrow>\n       \\<exists>b1 b b2.\n          bs = b1 @ b # b2 \\<and>\n          mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "hence bs: \"bs = (b1' @ [d]) @ b # b2'\""], ["proof (prove)\nusing this:\n  b1 = b1'\n  b2 = b # b2'\n\ngoal (1 subgoal):\n 1. bs = (b1' @ [d]) @ b # b2'", "unfolding bs"], ["proof (prove)\nusing this:\n  b1 = b1'\n  b2 = b # b2'\n\ngoal (1 subgoal):\n 1. b1 @ d # b2 = (b1' @ [d]) @ b # b2'", "by simp"], ["proof (state)\nthis:\n  bs = (b1' @ [d]) @ b # b2'\n\ngoal (2 subgoals):\n 1. us = [] \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n 2. \\<And>a list.\n       us = a # list \\<Longrightarrow>\n       \\<exists>b1 b b2.\n          bs = b1 @ b # b2 \\<and>\n          mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "by (intro exI conjI, rule bs, insert * sub, auto simp: ac_simps)"], ["proof (state)\nthis:\n  \\<exists>b1 b b2.\n     bs = b1 @ b # b2 \\<and> mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       us = a # list \\<Longrightarrow>\n       \\<exists>b1 b b2.\n          bs = b1 @ b # b2 \\<and>\n          mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       us = a # list \\<Longrightarrow>\n       \\<exists>b1 b b2.\n          bs = b1 @ b # b2 \\<and>\n          mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "case (Cons u vs)"], ["proof (state)\nthis:\n  us = u # vs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       us = a # list \\<Longrightarrow>\n       \\<exists>b1 b b2.\n          bs = b1 @ b # b2 \\<and>\n          mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "with *"], ["proof (chain)\npicking this:\n  b1 = b1' @ us\n  us @ b2 = b # b2'\n  us = u # vs", "have *: \"b1 = b1' @ b # vs\" \"vs @ b2 = b2'\""], ["proof (prove)\nusing this:\n  b1 = b1' @ us\n  us @ b2 = b # b2'\n  us = u # vs\n\ngoal (1 subgoal):\n 1. b1 = b1' @ b # vs &&& vs @ b2 = b2'", "by auto"], ["proof (state)\nthis:\n  b1 = b1' @ b # vs\n  vs @ b2 = b2'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       us = a # list \\<Longrightarrow>\n       \\<exists>b1 b b2.\n          bs = b1 @ b # b2 \\<and>\n          mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "hence bs: \"bs = b1' @ b # (vs @ d # b2)\""], ["proof (prove)\nusing this:\n  b1 = b1' @ b # vs\n  vs @ b2 = b2'\n\ngoal (1 subgoal):\n 1. bs = b1' @ b # vs @ d # b2", "unfolding bs"], ["proof (prove)\nusing this:\n  b1 = b1' @ b # vs\n  vs @ b2 = b2'\n\ngoal (1 subgoal):\n 1. b1 @ d # b2 = b1' @ b # vs @ d # b2", "by auto"], ["proof (state)\nthis:\n  bs = b1' @ b # vs @ d # b2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       us = a # list \\<Longrightarrow>\n       \\<exists>b1 b b2.\n          bs = b1 @ b # b2 \\<and>\n          mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "by (intro exI conjI, rule bs, insert * sub, auto simp: ac_simps)"], ["proof (state)\nthis:\n  \\<exists>b1 b b2.\n     bs = b1 @ b # b2 \\<and> mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>b1 b b2.\n     bs = b1 @ b # b2 \\<and> mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>b1 b b2.\n     bs = b1 @ b # b2 \\<and> mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n\ngoal (1 subgoal):\n 1. d \\<in># as \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<in># as \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "define as' where \"as' = as - {#d#}\""], ["proof (state)\nthis:\n  as' = as - {#d#}\n\ngoal (1 subgoal):\n 1. d \\<in># as \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "assume \"d \\<in># as\""], ["proof (state)\nthis:\n  d \\<in># as\n\ngoal (1 subgoal):\n 1. d \\<in># as \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "hence as': \"as = {#d#} + as'\""], ["proof (prove)\nusing this:\n  d \\<in># as\n\ngoal (1 subgoal):\n 1. as = {#d#} + as'", "unfolding as'_def"], ["proof (prove)\nusing this:\n  d \\<in># as\n\ngoal (1 subgoal):\n 1. as = {#d#} + (as - {#d#})", "by auto"], ["proof (state)\nthis:\n  as = {#d#} + as'\n\ngoal (1 subgoal):\n 1. d \\<in># as \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "from Cons(2)[unfolded as'] Cons(3)"], ["proof (chain)\npicking this:\n  mset (d # ds) \\<subseteq># mset bs + ({#d#} + as')\n  length (d # ds) < length bs", "have \"mset ds \\<subseteq># mset bs + as'\" \"length ds < length bs\""], ["proof (prove)\nusing this:\n  mset (d # ds) \\<subseteq># mset bs + ({#d#} + as')\n  length (d # ds) < length bs\n\ngoal (1 subgoal):\n 1. mset ds \\<subseteq># mset bs + as' &&& length ds < length bs", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  mset ds \\<subseteq># mset bs + as'\n  length ds < length bs\n\ngoal (1 subgoal):\n 1. d \\<in># as \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "from Cons(1)[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>b1 b b2.\n     bs = b1 @ b # b2 \\<and> mset ds \\<subseteq># mset (b1 @ b2) + as'", "obtain b1 b b2 where bs: \"bs = b1 @ b # b2\" and \n      sub: \"mset ds \\<subseteq># mset (b1 @ b2) + as'\""], ["proof (prove)\nusing this:\n  \\<exists>b1 b b2.\n     bs = b1 @ b # b2 \\<and> mset ds \\<subseteq># mset (b1 @ b2) + as'\n\ngoal (1 subgoal):\n 1. (\\<And>b1 b b2.\n        \\<lbrakk>bs = b1 @ b # b2;\n         mset ds \\<subseteq># mset (b1 @ b2) + as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  bs = b1 @ b # b2\n  mset ds \\<subseteq># mset (b1 @ b2) + as'\n\ngoal (1 subgoal):\n 1. d \\<in># as \\<Longrightarrow>\n    \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b1 b b2.\n       bs = b1 @ b # b2 \\<and>\n       mset (d # ds) \\<subseteq># mset (b1 @ b2) + as", "by (intro exI conjI, rule bs, insert sub, auto simp: as' ac_simps)"], ["proof (state)\nthis:\n  \\<exists>b1 b b2.\n     bs = b1 @ b # b2 \\<and> mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>b1 b b2.\n     bs = b1 @ b # b2 \\<and> mset (d # ds) \\<subseteq># mset (b1 @ b2) + as\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_factor_degree_aux: fixes es :: \"nat list\" \n  assumes sub: \"mset ds \\<subseteq># mset es\" \n    and len: \"length ds + length ds \\<le> length es\" and sort: \"sorted es\" \n  shows \"sum_list ds \\<le> sum_list (drop (length es div 2) es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list ds \\<le> sum_list (drop (length es div 2) es)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list ds \\<le> sum_list (drop (length es div 2) es)", "define bef where \"bef = take (length es div 2) es\""], ["proof (state)\nthis:\n  bef = take (length es div 2) es\n\ngoal (1 subgoal):\n 1. sum_list ds \\<le> sum_list (drop (length es div 2) es)", "define aft where \"aft = drop (length es div 2) es\""], ["proof (state)\nthis:\n  aft = drop (length es div 2) es\n\ngoal (1 subgoal):\n 1. sum_list ds \\<le> sum_list (drop (length es div 2) es)", "have es: \"es = bef @ aft\""], ["proof (prove)\ngoal (1 subgoal):\n 1. es = bef @ aft", "unfolding bef_def aft_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. es = take (length es div 2) es @ drop (length es div 2) es", "by auto"], ["proof (state)\nthis:\n  es = bef @ aft\n\ngoal (1 subgoal):\n 1. sum_list ds \\<le> sum_list (drop (length es div 2) es)", "from len"], ["proof (chain)\npicking this:\n  length ds + length ds \\<le> length es", "have len: \"length ds \\<le> length bef\" \"length ds \\<le> length aft\""], ["proof (prove)\nusing this:\n  length ds + length ds \\<le> length es\n\ngoal (1 subgoal):\n 1. length ds \\<le> length bef &&& length ds \\<le> length aft", "unfolding bef_def aft_def"], ["proof (prove)\nusing this:\n  length ds + length ds \\<le> length es\n\ngoal (1 subgoal):\n 1. length ds \\<le> length (take (length es div 2) es) &&&\n    length ds \\<le> length (drop (length es div 2) es)", "by auto"], ["proof (state)\nthis:\n  length ds \\<le> length bef\n  length ds \\<le> length aft\n\ngoal (1 subgoal):\n 1. sum_list ds \\<le> sum_list (drop (length es div 2) es)", "from sub"], ["proof (chain)\npicking this:\n  mset ds \\<subseteq># mset es", "have sub: \"mset ds \\<subseteq># mset bef + mset aft\""], ["proof (prove)\nusing this:\n  mset ds \\<subseteq># mset es\n\ngoal (1 subgoal):\n 1. mset ds \\<subseteq># mset bef + mset aft", "unfolding es"], ["proof (prove)\nusing this:\n  mset ds \\<subseteq># mset (bef @ aft)\n\ngoal (1 subgoal):\n 1. mset ds \\<subseteq># mset bef + mset aft", "by auto"], ["proof (state)\nthis:\n  mset ds \\<subseteq># mset bef + mset aft\n\ngoal (1 subgoal):\n 1. sum_list ds \\<le> sum_list (drop (length es div 2) es)", "from sort"], ["proof (chain)\npicking this:\n  sorted es", "have sort: \"sorted (bef @ aft)\""], ["proof (prove)\nusing this:\n  sorted es\n\ngoal (1 subgoal):\n 1. sorted (bef @ aft)", "unfolding es"], ["proof (prove)\nusing this:\n  sorted (bef @ aft)\n\ngoal (1 subgoal):\n 1. sorted (bef @ aft)", "."], ["proof (state)\nthis:\n  sorted (bef @ aft)\n\ngoal (1 subgoal):\n 1. sum_list ds \\<le> sum_list (drop (length es div 2) es)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list ds \\<le> sum_list (drop (length es div 2) es)", "unfolding aft_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list ds \\<le> sum_list aft", "using sub len sort"], ["proof (prove)\nusing this:\n  mset ds \\<subseteq># mset bef + mset aft\n  length ds \\<le> length bef\n  length ds \\<le> length aft\n  sorted (bef @ aft)\n\ngoal (1 subgoal):\n 1. sum_list ds \\<le> sum_list aft", "proof (induct ds arbitrary: bef aft)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bef aft.\n       \\<lbrakk>mset [] \\<subseteq># mset bef + mset aft;\n        length [] \\<le> length bef; length [] \\<le> length aft;\n        sorted (bef @ aft)\\<rbrakk>\n       \\<Longrightarrow> sum_list [] \\<le> sum_list aft\n 2. \\<And>a ds bef aft.\n       \\<lbrakk>\\<And>bef aft.\n                   \\<lbrakk>mset ds \\<subseteq># mset bef + mset aft;\n                    length ds \\<le> length bef; length ds \\<le> length aft;\n                    sorted (bef @ aft)\\<rbrakk>\n                   \\<Longrightarrow> sum_list ds \\<le> sum_list aft;\n        mset (a # ds) \\<subseteq># mset bef + mset aft;\n        length (a # ds) \\<le> length bef; length (a # ds) \\<le> length aft;\n        sorted (bef @ aft)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ds) \\<le> sum_list aft", "case (Cons d ds bef aft)"], ["proof (state)\nthis:\n  \\<lbrakk>mset ds \\<subseteq># mset ?bef + mset ?aft;\n   length ds \\<le> length ?bef; length ds \\<le> length ?aft;\n   sorted (?bef @ ?aft)\\<rbrakk>\n  \\<Longrightarrow> sum_list ds \\<le> sum_list ?aft\n  mset (d # ds) \\<subseteq># mset bef + mset aft\n  length (d # ds) \\<le> length bef\n  length (d # ds) \\<le> length aft\n  sorted (bef @ aft)\n\ngoal (2 subgoals):\n 1. \\<And>bef aft.\n       \\<lbrakk>mset [] \\<subseteq># mset bef + mset aft;\n        length [] \\<le> length bef; length [] \\<le> length aft;\n        sorted (bef @ aft)\\<rbrakk>\n       \\<Longrightarrow> sum_list [] \\<le> sum_list aft\n 2. \\<And>a ds bef aft.\n       \\<lbrakk>\\<And>bef aft.\n                   \\<lbrakk>mset ds \\<subseteq># mset bef + mset aft;\n                    length ds \\<le> length bef; length ds \\<le> length aft;\n                    sorted (bef @ aft)\\<rbrakk>\n                   \\<Longrightarrow> sum_list ds \\<le> sum_list aft;\n        mset (a # ds) \\<subseteq># mset bef + mset aft;\n        length (a # ds) \\<le> length bef; length (a # ds) \\<le> length aft;\n        sorted (bef @ aft)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ds) \\<le> sum_list aft", "have \"d \\<in># mset (d # ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<in># mset (d # ds)", "by auto"], ["proof (state)\nthis:\n  d \\<in># mset (d # ds)\n\ngoal (2 subgoals):\n 1. \\<And>bef aft.\n       \\<lbrakk>mset [] \\<subseteq># mset bef + mset aft;\n        length [] \\<le> length bef; length [] \\<le> length aft;\n        sorted (bef @ aft)\\<rbrakk>\n       \\<Longrightarrow> sum_list [] \\<le> sum_list aft\n 2. \\<And>a ds bef aft.\n       \\<lbrakk>\\<And>bef aft.\n                   \\<lbrakk>mset ds \\<subseteq># mset bef + mset aft;\n                    length ds \\<le> length bef; length ds \\<le> length aft;\n                    sorted (bef @ aft)\\<rbrakk>\n                   \\<Longrightarrow> sum_list ds \\<le> sum_list aft;\n        mset (a # ds) \\<subseteq># mset bef + mset aft;\n        length (a # ds) \\<le> length bef; length (a # ds) \\<le> length aft;\n        sorted (bef @ aft)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ds) \\<le> sum_list aft", "with Cons(2)"], ["proof (chain)\npicking this:\n  mset (d # ds) \\<subseteq># mset bef + mset aft\n  d \\<in># mset (d # ds)", "have \"d \\<in># mset bef + mset aft\""], ["proof (prove)\nusing this:\n  mset (d # ds) \\<subseteq># mset bef + mset aft\n  d \\<in># mset (d # ds)\n\ngoal (1 subgoal):\n 1. d \\<in># mset bef + mset aft", "by (rule mset_subset_eqD)"], ["proof (state)\nthis:\n  d \\<in># mset bef + mset aft\n\ngoal (2 subgoals):\n 1. \\<And>bef aft.\n       \\<lbrakk>mset [] \\<subseteq># mset bef + mset aft;\n        length [] \\<le> length bef; length [] \\<le> length aft;\n        sorted (bef @ aft)\\<rbrakk>\n       \\<Longrightarrow> sum_list [] \\<le> sum_list aft\n 2. \\<And>a ds bef aft.\n       \\<lbrakk>\\<And>bef aft.\n                   \\<lbrakk>mset ds \\<subseteq># mset bef + mset aft;\n                    length ds \\<le> length bef; length ds \\<le> length aft;\n                    sorted (bef @ aft)\\<rbrakk>\n                   \\<Longrightarrow> sum_list ds \\<le> sum_list aft;\n        mset (a # ds) \\<subseteq># mset bef + mset aft;\n        length (a # ds) \\<le> length bef; length (a # ds) \\<le> length aft;\n        sorted (bef @ aft)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ds) \\<le> sum_list aft", "hence \"d \\<in> set bef \\<or> d \\<in> set aft\""], ["proof (prove)\nusing this:\n  d \\<in># mset bef + mset aft\n\ngoal (1 subgoal):\n 1. d \\<in> set bef \\<or> d \\<in> set aft", "by auto"], ["proof (state)\nthis:\n  d \\<in> set bef \\<or> d \\<in> set aft\n\ngoal (2 subgoals):\n 1. \\<And>bef aft.\n       \\<lbrakk>mset [] \\<subseteq># mset bef + mset aft;\n        length [] \\<le> length bef; length [] \\<le> length aft;\n        sorted (bef @ aft)\\<rbrakk>\n       \\<Longrightarrow> sum_list [] \\<le> sum_list aft\n 2. \\<And>a ds bef aft.\n       \\<lbrakk>\\<And>bef aft.\n                   \\<lbrakk>mset ds \\<subseteq># mset bef + mset aft;\n                    length ds \\<le> length bef; length ds \\<le> length aft;\n                    sorted (bef @ aft)\\<rbrakk>\n                   \\<Longrightarrow> sum_list ds \\<le> sum_list aft;\n        mset (a # ds) \\<subseteq># mset bef + mset aft;\n        length (a # ds) \\<le> length bef; length (a # ds) \\<le> length aft;\n        sorted (bef @ aft)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ds) \\<le> sum_list aft", "thus ?case"], ["proof (prove)\nusing this:\n  d \\<in> set bef \\<or> d \\<in> set aft\n\ngoal (1 subgoal):\n 1. sum_list (d # ds) \\<le> sum_list aft", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft\n 2. d \\<in> set aft \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "assume \"d \\<in> set aft\""], ["proof (state)\nthis:\n  d \\<in> set aft\n\ngoal (2 subgoals):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft\n 2. d \\<in> set aft \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "from this[unfolded in_set_conv_decomp]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. aft = ys @ d # zs", "obtain a1 a2 where aft: \"aft = a1 @ d # a2\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. aft = ys @ d # zs\n\ngoal (1 subgoal):\n 1. (\\<And>a1 a2.\n        aft = a1 @ d # a2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  aft = a1 @ d # a2\n\ngoal (2 subgoals):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft\n 2. d \\<in> set aft \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "from Cons(4)"], ["proof (chain)\npicking this:\n  length (d # ds) \\<le> length aft", "have len_a: \"length ds \\<le> length (a1 @ a2)\""], ["proof (prove)\nusing this:\n  length (d # ds) \\<le> length aft\n\ngoal (1 subgoal):\n 1. length ds \\<le> length (a1 @ a2)", "unfolding aft"], ["proof (prove)\nusing this:\n  length (d # ds) \\<le> length (a1 @ d # a2)\n\ngoal (1 subgoal):\n 1. length ds \\<le> length (a1 @ a2)", "by auto"], ["proof (state)\nthis:\n  length ds \\<le> length (a1 @ a2)\n\ngoal (2 subgoals):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft\n 2. d \\<in> set aft \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "from Cons(2)[unfolded aft] Cons(3)"], ["proof (chain)\npicking this:\n  mset (d # ds) \\<subseteq># mset bef + mset (a1 @ d # a2)\n  length (d # ds) \\<le> length bef", "have \"mset ds \\<subseteq># mset bef + (mset (a1 @ a2))\" \"length ds < length bef\""], ["proof (prove)\nusing this:\n  mset (d # ds) \\<subseteq># mset bef + mset (a1 @ d # a2)\n  length (d # ds) \\<le> length bef\n\ngoal (1 subgoal):\n 1. mset ds \\<subseteq># mset bef + mset (a1 @ a2) &&&\n    length ds < length bef", "by auto"], ["proof (state)\nthis:\n  mset ds \\<subseteq># mset bef + mset (a1 @ a2)\n  length ds < length bef\n\ngoal (2 subgoals):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft\n 2. d \\<in> set aft \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "from mset_sub_decompose[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>b1 b b2.\n     bef = b1 @ b # b2 \\<and>\n     mset ds \\<subseteq># mset (b1 @ b2) + mset (a1 @ a2)", "obtain b b1 b2 \n        where bef: \"bef = b1 @ b # b2\" and sub: \"mset ds \\<subseteq># (mset (b1 @ b2) + mset (a1 @ a2))\""], ["proof (prove)\nusing this:\n  \\<exists>b1 b b2.\n     bef = b1 @ b # b2 \\<and>\n     mset ds \\<subseteq># mset (b1 @ b2) + mset (a1 @ a2)\n\ngoal (1 subgoal):\n 1. (\\<And>b1 b b2.\n        \\<lbrakk>bef = b1 @ b # b2;\n         mset ds \\<subseteq># mset (b1 @ b2) + mset (a1 @ a2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  bef = b1 @ b # b2\n  mset ds \\<subseteq># mset (b1 @ b2) + mset (a1 @ a2)\n\ngoal (2 subgoals):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft\n 2. d \\<in> set aft \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "from Cons(3)"], ["proof (chain)\npicking this:\n  length (d # ds) \\<le> length bef", "have len_b: \"length ds \\<le> length (b1 @ b2)\""], ["proof (prove)\nusing this:\n  length (d # ds) \\<le> length bef\n\ngoal (1 subgoal):\n 1. length ds \\<le> length (b1 @ b2)", "unfolding bef"], ["proof (prove)\nusing this:\n  length (d # ds) \\<le> length (b1 @ b # b2)\n\ngoal (1 subgoal):\n 1. length ds \\<le> length (b1 @ b2)", "by auto"], ["proof (state)\nthis:\n  length ds \\<le> length (b1 @ b2)\n\ngoal (2 subgoals):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft\n 2. d \\<in> set aft \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "from Cons(5)[unfolded bef aft]"], ["proof (chain)\npicking this:\n  sorted ((b1 @ b # b2) @ a1 @ d # a2)", "have sort: \"sorted ( (b1 @ b2) @ (a1 @ a2))\""], ["proof (prove)\nusing this:\n  sorted ((b1 @ b # b2) @ a1 @ d # a2)\n\ngoal (1 subgoal):\n 1. sorted ((b1 @ b2) @ a1 @ a2)", "unfolding sorted_append"], ["proof (prove)\nusing this:\n  (sorted b1 \\<and>\n   sorted (b # b2) \\<and>\n   (\\<forall>x\\<in>set b1. Ball (set (b # b2)) ((\\<le>) x))) \\<and>\n  (sorted a1 \\<and>\n   sorted (d # a2) \\<and>\n   (\\<forall>x\\<in>set a1. Ball (set (d # a2)) ((\\<le>) x))) \\<and>\n  (\\<forall>x\\<in>set (b1 @ b # b2). Ball (set (a1 @ d # a2)) ((\\<le>) x))\n\ngoal (1 subgoal):\n 1. (sorted b1 \\<and>\n     sorted b2 \\<and>\n     (\\<forall>x\\<in>set b1. Ball (set b2) ((\\<le>) x))) \\<and>\n    (sorted a1 \\<and>\n     sorted a2 \\<and>\n     (\\<forall>x\\<in>set a1. Ball (set a2) ((\\<le>) x))) \\<and>\n    (\\<forall>x\\<in>set (b1 @ b2). Ball (set (a1 @ a2)) ((\\<le>) x))", "by auto"], ["proof (state)\nthis:\n  sorted ((b1 @ b2) @ a1 @ a2)\n\ngoal (2 subgoals):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft\n 2. d \\<in> set aft \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "note IH = Cons(1)[OF sub len_b len_a sort]"], ["proof (state)\nthis:\n  sum_list ds \\<le> sum_list (a1 @ a2)\n\ngoal (2 subgoals):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft\n 2. d \\<in> set aft \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (d # ds) \\<le> sum_list aft", "using IH"], ["proof (prove)\nusing this:\n  sum_list ds \\<le> sum_list (a1 @ a2)\n\ngoal (1 subgoal):\n 1. sum_list (d # ds) \\<le> sum_list aft", "unfolding aft"], ["proof (prove)\nusing this:\n  sum_list ds \\<le> sum_list (a1 @ a2)\n\ngoal (1 subgoal):\n 1. sum_list (d # ds) \\<le> sum_list (a1 @ d # a2)", "by simp"], ["proof (state)\nthis:\n  sum_list (d # ds) \\<le> sum_list aft\n\ngoal (1 subgoal):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "assume \"d \\<in> set bef\""], ["proof (state)\nthis:\n  d \\<in> set bef\n\ngoal (1 subgoal):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "from this[unfolded in_set_conv_decomp]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. bef = ys @ d # zs", "obtain b1 b2 where bef: \"bef = b1 @ d # b2\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. bef = ys @ d # zs\n\ngoal (1 subgoal):\n 1. (\\<And>b1 b2.\n        bef = b1 @ d # b2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  bef = b1 @ d # b2\n\ngoal (1 subgoal):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "from Cons(3)"], ["proof (chain)\npicking this:\n  length (d # ds) \\<le> length bef", "have len_b: \"length ds \\<le> length (b1 @ b2)\""], ["proof (prove)\nusing this:\n  length (d # ds) \\<le> length bef\n\ngoal (1 subgoal):\n 1. length ds \\<le> length (b1 @ b2)", "unfolding bef"], ["proof (prove)\nusing this:\n  length (d # ds) \\<le> length (b1 @ d # b2)\n\ngoal (1 subgoal):\n 1. length ds \\<le> length (b1 @ b2)", "by auto"], ["proof (state)\nthis:\n  length ds \\<le> length (b1 @ b2)\n\ngoal (1 subgoal):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "from Cons(2)[unfolded bef] Cons(4)"], ["proof (chain)\npicking this:\n  mset (d # ds) \\<subseteq># mset (b1 @ d # b2) + mset aft\n  length (d # ds) \\<le> length aft", "have \"mset ds \\<subseteq># mset aft + (mset (b1 @ b2))\" \"length ds < length aft\""], ["proof (prove)\nusing this:\n  mset (d # ds) \\<subseteq># mset (b1 @ d # b2) + mset aft\n  length (d # ds) \\<le> length aft\n\ngoal (1 subgoal):\n 1. mset ds \\<subseteq># mset aft + mset (b1 @ b2) &&&\n    length ds < length aft", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  mset ds \\<subseteq># mset aft + mset (b1 @ b2)\n  length ds < length aft\n\ngoal (1 subgoal):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "from mset_sub_decompose[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>b1a b b2a.\n     aft = b1a @ b # b2a \\<and>\n     mset ds \\<subseteq># mset (b1a @ b2a) + mset (b1 @ b2)", "obtain a a1 a2 \n        where aft: \"aft = a1 @ a # a2\" and sub: \"mset ds \\<subseteq># (mset (b1 @ b2) + mset (a1 @ a2))\""], ["proof (prove)\nusing this:\n  \\<exists>b1a b b2a.\n     aft = b1a @ b # b2a \\<and>\n     mset ds \\<subseteq># mset (b1a @ b2a) + mset (b1 @ b2)\n\ngoal (1 subgoal):\n 1. (\\<And>a1 a a2.\n        \\<lbrakk>aft = a1 @ a # a2;\n         mset ds \\<subseteq># mset (b1 @ b2) + mset (a1 @ a2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  aft = a1 @ a # a2\n  mset ds \\<subseteq># mset (b1 @ b2) + mset (a1 @ a2)\n\ngoal (1 subgoal):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "from Cons(4)"], ["proof (chain)\npicking this:\n  length (d # ds) \\<le> length aft", "have len_a: \"length ds \\<le> length (a1 @ a2)\""], ["proof (prove)\nusing this:\n  length (d # ds) \\<le> length aft\n\ngoal (1 subgoal):\n 1. length ds \\<le> length (a1 @ a2)", "unfolding aft"], ["proof (prove)\nusing this:\n  length (d # ds) \\<le> length (a1 @ a # a2)\n\ngoal (1 subgoal):\n 1. length ds \\<le> length (a1 @ a2)", "by auto"], ["proof (state)\nthis:\n  length ds \\<le> length (a1 @ a2)\n\ngoal (1 subgoal):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "from Cons(5)[unfolded bef aft]"], ["proof (chain)\npicking this:\n  sorted ((b1 @ d # b2) @ a1 @ a # a2)", "have sort: \"sorted ( (b1 @ b2) @ (a1 @ a2))\" and ad: \"d \\<le> a\""], ["proof (prove)\nusing this:\n  sorted ((b1 @ d # b2) @ a1 @ a # a2)\n\ngoal (1 subgoal):\n 1. sorted ((b1 @ b2) @ a1 @ a2) &&& d \\<le> a", "unfolding sorted_append"], ["proof (prove)\nusing this:\n  (sorted b1 \\<and>\n   sorted (d # b2) \\<and>\n   (\\<forall>x\\<in>set b1. Ball (set (d # b2)) ((\\<le>) x))) \\<and>\n  (sorted a1 \\<and>\n   sorted (a # a2) \\<and>\n   (\\<forall>x\\<in>set a1. Ball (set (a # a2)) ((\\<le>) x))) \\<and>\n  (\\<forall>x\\<in>set (b1 @ d # b2). Ball (set (a1 @ a # a2)) ((\\<le>) x))\n\ngoal (1 subgoal):\n 1. (sorted b1 \\<and>\n     sorted b2 \\<and>\n     (\\<forall>x\\<in>set b1. Ball (set b2) ((\\<le>) x))) \\<and>\n    (sorted a1 \\<and>\n     sorted a2 \\<and>\n     (\\<forall>x\\<in>set a1. Ball (set a2) ((\\<le>) x))) \\<and>\n    (\\<forall>x\\<in>set (b1 @ b2). Ball (set (a1 @ a2)) ((\\<le>) x)) &&&\n    d \\<le> a", "by auto"], ["proof (state)\nthis:\n  sorted ((b1 @ b2) @ a1 @ a2)\n  d \\<le> a\n\ngoal (1 subgoal):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "note IH = Cons(1)[OF sub len_b len_a sort]"], ["proof (state)\nthis:\n  sum_list ds \\<le> sum_list (a1 @ a2)\n\ngoal (1 subgoal):\n 1. d \\<in> set bef \\<Longrightarrow> sum_list (d # ds) \\<le> sum_list aft", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (d # ds) \\<le> sum_list aft", "using IH ad"], ["proof (prove)\nusing this:\n  sum_list ds \\<le> sum_list (a1 @ a2)\n  d \\<le> a\n\ngoal (1 subgoal):\n 1. sum_list (d # ds) \\<le> sum_list aft", "unfolding aft"], ["proof (prove)\nusing this:\n  sum_list ds \\<le> sum_list (a1 @ a2)\n  d \\<le> a\n\ngoal (1 subgoal):\n 1. sum_list (d # ds) \\<le> sum_list (a1 @ a # a2)", "by simp"], ["proof (state)\nthis:\n  sum_list (d # ds) \\<le> sum_list aft\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (d # ds) \\<le> sum_list aft\n\ngoal (1 subgoal):\n 1. \\<And>bef aft.\n       \\<lbrakk>mset [] \\<subseteq># mset bef + mset aft;\n        length [] \\<le> length bef; length [] \\<le> length aft;\n        sorted (bef @ aft)\\<rbrakk>\n       \\<Longrightarrow> sum_list [] \\<le> sum_list aft", "qed auto"], ["proof (state)\nthis:\n  sum_list ds \\<le> sum_list (drop (length es div 2) es)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_factor_degree: assumes sub: \"mset ws \\<subseteq># mset vs\"\n  and len: \"length ws + length ws \\<le> length vs\"\n  shows \"degree (prod_list ws) \\<le> max_factor_degree (map degree vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod_list ws) \\<le> max_factor_degree (map degree vs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (prod_list ws) \\<le> max_factor_degree (map degree vs)", "define ds where \"ds \\<equiv> map degree ws\""], ["proof (state)\nthis:\n  ds \\<equiv> map degree ws\n\ngoal (1 subgoal):\n 1. degree (prod_list ws) \\<le> max_factor_degree (map degree vs)", "define es where \"es \\<equiv> sort (map degree vs)\""], ["proof (state)\nthis:\n  es \\<equiv> sort (map degree vs)\n\ngoal (1 subgoal):\n 1. degree (prod_list ws) \\<le> max_factor_degree (map degree vs)", "from sub len"], ["proof (chain)\npicking this:\n  mset ws \\<subseteq># mset vs\n  length ws + length ws \\<le> length vs", "have sub: \"mset ds \\<subseteq># mset es\" and len: \"length ds + length ds \\<le> length es\"\n    and es: \"sorted es\""], ["proof (prove)\nusing this:\n  mset ws \\<subseteq># mset vs\n  length ws + length ws \\<le> length vs\n\ngoal (1 subgoal):\n 1. mset ds \\<subseteq># mset es &&&\n    length ds + length ds \\<le> length es &&& sorted es", "unfolding ds_def es_def"], ["proof (prove)\nusing this:\n  mset ws \\<subseteq># mset vs\n  length ws + length ws \\<le> length vs\n\ngoal (1 subgoal):\n 1. mset (map degree ws) \\<subseteq># mset (sort (map degree vs)) &&&\n    length (map degree ws) + length (map degree ws)\n    \\<le> length (sort (map degree vs)) &&&\n    sorted (sort (map degree vs))", "by (auto simp: image_mset_subseteq_mono)"], ["proof (state)\nthis:\n  mset ds \\<subseteq># mset es\n  length ds + length ds \\<le> length es\n  sorted es\n\ngoal (1 subgoal):\n 1. degree (prod_list ws) \\<le> max_factor_degree (map degree vs)", "have \"degree (prod_list ws) \\<le> sum_list (map degree ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod_list ws) \\<le> sum_list (map degree ws)", "by (rule degree_prod_list_le)"], ["proof (state)\nthis:\n  degree (prod_list ws) \\<le> sum_list (map degree ws)\n\ngoal (1 subgoal):\n 1. degree (prod_list ws) \\<le> max_factor_degree (map degree vs)", "also"], ["proof (state)\nthis:\n  degree (prod_list ws) \\<le> sum_list (map degree ws)\n\ngoal (1 subgoal):\n 1. degree (prod_list ws) \\<le> max_factor_degree (map degree vs)", "have \"\\<dots> \\<le> max_factor_degree (map degree vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map degree ws) \\<le> max_factor_degree (map degree vs)", "unfolding max_factor_degree_def Let_def ds_def[symmetric] es_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list ds \\<le> sum_list (drop (length es div 2) es)", "using sub len es"], ["proof (prove)\nusing this:\n  mset ds \\<subseteq># mset es\n  length ds + length ds \\<le> length es\n  sorted es\n\ngoal (1 subgoal):\n 1. sum_list ds \\<le> sum_list (drop (length es div 2) es)", "by (rule max_factor_degree_aux)"], ["proof (state)\nthis:\n  sum_list (map degree ws) \\<le> max_factor_degree (map degree vs)\n\ngoal (1 subgoal):\n 1. degree (prod_list ws) \\<le> max_factor_degree (map degree vs)", "finally"], ["proof (chain)\npicking this:\n  degree (prod_list ws) \\<le> max_factor_degree (map degree vs)", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (prod_list ws) \\<le> max_factor_degree (map degree vs)\n\ngoal (1 subgoal):\n 1. degree (prod_list ws) \\<le> max_factor_degree (map degree vs)", "."], ["proof (state)\nthis:\n  degree (prod_list ws) \\<le> max_factor_degree (map degree vs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_bound: assumes sub: \"mset ws \\<subseteq># mset vs\"\n  and len: \"length ws + length ws \\<le> length vs\"\nshows \"degree (prod_list ws) \\<le> degree_bound vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod_list ws) \\<le> degree_bound vs", "using max_factor_degree[OF sub len]"], ["proof (prove)\nusing this:\n  degree (prod_list ws) \\<le> max_factor_degree (map degree vs)\n\ngoal (1 subgoal):\n 1. degree (prod_list ws) \\<le> degree_bound vs", "unfolding degree_bound_def"], ["proof (prove)\nusing this:\n  degree (prod_list ws) \\<le> max_factor_degree (map degree vs)\n\ngoal (1 subgoal):\n 1. degree (prod_list ws) \\<le> max_factor_degree (map degree vs)", "by auto"], ["", "end"]]}