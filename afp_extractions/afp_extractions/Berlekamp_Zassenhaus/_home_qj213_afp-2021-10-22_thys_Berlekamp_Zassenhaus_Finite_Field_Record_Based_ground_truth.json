{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Finite_Field_Record_Based.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma mod_nonneg_pos_int[simp]: \"x \\<ge> 0 \\<Longrightarrow> y > 0 \\<Longrightarrow> mod_nonneg_pos_int x y = (x mod y)\"", "lemma int_of_uint32_shift: \"int_of_uint32 (shiftr n k) = (int_of_uint32 n) div (2 ^ k)\"", "lemma int_of_uint32_0_iff: \"int_of_uint32 n = 0 \\<longleftrightarrow> n = 0\"", "lemma int_of_uint32_0: \"int_of_uint32 0 = 0\"", "lemma int_of_uint32_ge_0: \"int_of_uint32 n \\<ge> 0\"", "lemma two_32: \"2 ^ LENGTH(32) = (4294967296 :: int)\"", "lemma int_of_uint32_plus: \"int_of_uint32 (x + y) = (int_of_uint32 x + int_of_uint32 y) mod 4294967296\"", "lemma int_of_uint32_minus: \"int_of_uint32 (x - y) = (int_of_uint32 x - int_of_uint32 y) mod 4294967296\"", "lemma int_of_uint32_mult: \"int_of_uint32 (x * y) = (int_of_uint32 x * int_of_uint32 y) mod 4294967296\"", "lemma int_of_uint32_mod: \"int_of_uint32 (x mod y) = (int_of_uint32 x mod int_of_uint32 y)\"", "lemma int_of_uint32_inv: \"0 \\<le> x \\<Longrightarrow> x < 4294967296 \\<Longrightarrow> int_of_uint32 (uint32_of_int x) = x\"", "lemma shiftr_uint32_code [code_unfold]: \"drop_bit 1 x = (uint32_shiftr x 1)\"", "lemma nat_p: \"nat p = CARD('a)\"", "lemma p2: \"p \\<ge> 2\"", "lemma p2_ident: \"int (CARD('a) - 2) = p - 2\"", "lemma Domainp_mod_ring_rel [transfer_domain_rule]:\n  \"Domainp (mod_ring_rel) = (\\<lambda> v. v \\<in> {0 ..< p})\"", "lemma bi_unique_mod_ring_rel [transfer_rule]:\n  \"bi_unique mod_ring_rel\" \"left_unique mod_ring_rel\" \"right_unique mod_ring_rel\"", "lemma right_total_mod_ring_rel [transfer_rule]: \"right_total mod_ring_rel\"", "lemma mod_ring_0[transfer_rule]: \"mod_ring_rel 0 0\"", "lemma mod_ring_1[transfer_rule]: \"mod_ring_rel 1 1\"", "lemma plus_p_mod_def: assumes x: \"x \\<in> {0 ..< p}\" and y: \"y \\<in> {0 ..< p}\"\n  shows \"plus_p p x y = ((x + y) mod p)\"", "lemma mod_ring_plus[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (plus_p p) (+)\"", "lemma minus_p_mod_def: assumes x: \"x \\<in> {0 ..< p}\" and y: \"y \\<in> {0 ..< p}\"\n  shows \"minus_p p x y = ((x - y) mod p)\"", "lemma mod_ring_minus[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (minus_p p) (-)\"", "lemma mod_ring_uminus[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel) (uminus_p p) uminus\"", "lemma mod_ring_mult[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (mult_p p) ((*))\"", "lemma mod_ring_eq[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel ===> (=)) (=) (=)\"", "lemma mod_ring_power[transfer_rule]: \"(mod_ring_rel ===> (=) ===> mod_ring_rel) (power_p p) (^)\"", "lemma ring_finite_field_ops_int: \"ring_ops (finite_field_ops_int p) mod_ring_rel\"", "lemma prime: \"prime p\"", "lemma mod_ring_mod[transfer_rule]:\n \"(mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) ((\\<lambda> x y. if y = 0 then x else 0)) (mod)\"", "lemma mod_ring_normalize[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel) ((\\<lambda> x. if x = 0 then 0 else 1)) normalize\"", "lemma mod_ring_unit_factor[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel) (\\<lambda> x. x) unit_factor\"", "lemma mod_ring_inverse[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel) (inverse_p p) inverse\"", "lemma mod_ring_divide[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel)\n  (divide_p p) (/)\"", "lemma mod_ring_rel_unsafe: assumes \"x < CARD('a)\"\n  shows \"mod_ring_rel (int x) (of_nat x)\" \"0 < x \\<Longrightarrow> of_nat x \\<noteq> (0 :: 'a mod_ring)\"", "lemma finite_field_ops_int: \"field_ops (finite_field_ops_int p) mod_ring_rel\"", "lemmas uint32_simps = \n  int_of_uint32_0\n  int_of_uint32_plus \n  int_of_uint32_minus\n  int_of_uint32_mult", "lemma urel32_0: \"urel32 0 0\"", "lemma urel32_1: \"urel32 1 1\"", "lemma le_int_of_uint32: \"(x \\<le> y) = (int_of_uint32 x \\<le> int_of_uint32 y)\"", "lemma urel32_plus: assumes \"urel32 x y\" \"urel32 x' y'\"\n  shows \"urel32 (plus_p32 pp x x') (plus_p p y y')\"", "lemma urel32_minus: assumes \"urel32 x y\" \"urel32 x' y'\"\n  shows \"urel32 (minus_p32 pp x x') (minus_p p y y')\"", "lemma urel32_uminus: assumes \"urel32 x y\"\n  shows \"urel32 (uminus_p32 pp x) (uminus_p p y)\"", "lemma urel32_mult: assumes \"urel32 x y\" \"urel32 x' y'\"\n  shows \"urel32 (mult_p32 pp x x') (mult_p p y y')\"", "lemma urel32_eq: assumes \"urel32 x y\" \"urel32 x' y'\" \n  shows \"(x = x') = (y = y')\"", "lemma urel32_normalize: \nassumes x: \"urel32 x y\"\nshows \"urel32 (if x = 0 then 0 else 1) (if y = 0 then 0 else 1)\"", "lemma urel32_mod: \nassumes x: \"urel32 x x'\" and y: \"urel32 y y'\" \nshows \"urel32 (if y = 0 then x else 0) (if y' = 0 then x' else 0)\"", "lemma urel32_power: \"urel32 x x' \\<Longrightarrow> urel32 y (int y') \\<Longrightarrow> urel32 (power_p32 pp x y) (power_p p x' y')\"", "lemma urel32_inverse: assumes x: \"urel32 x x'\" \n  shows \"urel32 (inverse_p32 pp x) (inverse_p p x')\"", "lemma mod_ring_0_32: \"mod_ring_rel32 0 0\"", "lemma mod_ring_1_32: \"mod_ring_rel32 1 1\"", "lemma mod_ring_uminus32: \"(mod_ring_rel32 ===> mod_ring_rel32) (uminus_p32 pp) uminus\"", "lemma mod_ring_plus32: \"(mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (plus_p32 pp) (+)\"", "lemma mod_ring_minus32: \"(mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (minus_p32 pp) (-)\"", "lemma mod_ring_mult32: \"(mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (mult_p32 pp) ((*))\"", "lemma mod_ring_eq32: \"(mod_ring_rel32 ===> mod_ring_rel32 ===> (=)) (=) (=)\"", "lemma urel32_inj: \"urel32 x y \\<Longrightarrow> urel32 x z \\<Longrightarrow> y = z\"", "lemma urel32_inj': \"urel32 x z \\<Longrightarrow> urel32 y z \\<Longrightarrow> x = y\"", "lemma bi_unique_mod_ring_rel32:\n  \"bi_unique mod_ring_rel32\" \"left_unique mod_ring_rel32\" \"right_unique mod_ring_rel32\"", "lemma right_total_mod_ring_rel32: \"right_total mod_ring_rel32\"", "lemma Domainp_mod_ring_rel32: \"Domainp mod_ring_rel32 = (\\<lambda>x. 0 \\<le> x \\<and> x < pp)\"", "lemma ring_finite_field_ops32: \"ring_ops (finite_field_ops32 pp) mod_ring_rel32\"", "lemma mod_ring_normalize32: \"(mod_ring_rel32 ===> mod_ring_rel32) (\\<lambda>x. if x = 0 then 0 else 1) normalize\"", "lemma mod_ring_mod32: \"(mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (\\<lambda>x y. if y = 0 then x else 0) (mod)\"", "lemma mod_ring_unit_factor32: \"(mod_ring_rel32 ===> mod_ring_rel32) (\\<lambda>x. x) unit_factor\"", "lemma mod_ring_inverse32: \"(mod_ring_rel32 ===> mod_ring_rel32) (inverse_p32 pp) inverse\"", "lemma mod_ring_divide32: \"(mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (divide_p32 pp) (/)\"", "lemma finite_field_ops32: \"field_ops (finite_field_ops32 pp) mod_ring_rel32\"", "lemma int_of_uint64_shift: \"int_of_uint64 (shiftr n k) = (int_of_uint64 n) div (2 ^ k)\"", "lemma int_of_uint64_0_iff: \"int_of_uint64 n = 0 \\<longleftrightarrow> n = 0\"", "lemma int_of_uint64_0: \"int_of_uint64 0 = 0\"", "lemma int_of_uint64_ge_0: \"int_of_uint64 n \\<ge> 0\"", "lemma two_64: \"2 ^ LENGTH(64) = (18446744073709551616 :: int)\"", "lemma int_of_uint64_plus: \"int_of_uint64 (x + y) = (int_of_uint64 x + int_of_uint64 y) mod 18446744073709551616\"", "lemma int_of_uint64_minus: \"int_of_uint64 (x - y) = (int_of_uint64 x - int_of_uint64 y) mod 18446744073709551616\"", "lemma int_of_uint64_mult: \"int_of_uint64 (x * y) = (int_of_uint64 x * int_of_uint64 y) mod 18446744073709551616\"", "lemma int_of_uint64_mod: \"int_of_uint64 (x mod y) = (int_of_uint64 x mod int_of_uint64 y)\"", "lemma int_of_uint64_inv: \"0 \\<le> x \\<Longrightarrow> x < 18446744073709551616 \\<Longrightarrow> int_of_uint64 (uint64_of_int x) = x\"", "lemma shiftr_uint64_code [code_unfold]: \"drop_bit 1 x = (uint64_shiftr x 1)\"", "lemmas uint64_simps = \n  int_of_uint64_0\n  int_of_uint64_plus \n  int_of_uint64_minus\n  int_of_uint64_mult", "lemma urel64_0: \"urel64 0 0\"", "lemma urel64_1: \"urel64 1 1\"", "lemma le_int_of_uint64: \"(x \\<le> y) = (int_of_uint64 x \\<le> int_of_uint64 y)\"", "lemma urel64_plus: assumes \"urel64 x y\" \"urel64 x' y'\"\n  shows \"urel64 (plus_p64 pp x x') (plus_p p y y')\"", "lemma urel64_minus: assumes \"urel64 x y\" \"urel64 x' y'\"\n  shows \"urel64 (minus_p64 pp x x') (minus_p p y y')\"", "lemma urel64_uminus: assumes \"urel64 x y\"\n  shows \"urel64 (uminus_p64 pp x) (uminus_p p y)\"", "lemma urel64_mult: assumes \"urel64 x y\" \"urel64 x' y'\"\n  shows \"urel64 (mult_p64 pp x x') (mult_p p y y')\"", "lemma urel64_eq: assumes \"urel64 x y\" \"urel64 x' y'\" \n  shows \"(x = x') = (y = y')\"", "lemma urel64_normalize: \nassumes x: \"urel64 x y\"\nshows \"urel64 (if x = 0 then 0 else 1) (if y = 0 then 0 else 1)\"", "lemma urel64_mod: \nassumes x: \"urel64 x x'\" and y: \"urel64 y y'\" \nshows \"urel64 (if y = 0 then x else 0) (if y' = 0 then x' else 0)\"", "lemma urel64_power: \"urel64 x x' \\<Longrightarrow> urel64 y (int y') \\<Longrightarrow> urel64 (power_p64 pp x y) (power_p p x' y')\"", "lemma urel64_inverse: assumes x: \"urel64 x x'\" \n  shows \"urel64 (inverse_p64 pp x) (inverse_p p x')\"", "lemma mod_ring_0_64: \"mod_ring_rel64 0 0\"", "lemma mod_ring_1_64: \"mod_ring_rel64 1 1\"", "lemma mod_ring_uminus64: \"(mod_ring_rel64 ===> mod_ring_rel64) (uminus_p64 pp) uminus\"", "lemma mod_ring_plus64: \"(mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (plus_p64 pp) (+)\"", "lemma mod_ring_minus64: \"(mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (minus_p64 pp) (-)\"", "lemma mod_ring_mult64: \"(mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (mult_p64 pp) ((*))\"", "lemma mod_ring_eq64: \"(mod_ring_rel64 ===> mod_ring_rel64 ===> (=)) (=) (=)\"", "lemma urel64_inj: \"urel64 x y \\<Longrightarrow> urel64 x z \\<Longrightarrow> y = z\"", "lemma urel64_inj': \"urel64 x z \\<Longrightarrow> urel64 y z \\<Longrightarrow> x = y\"", "lemma bi_unique_mod_ring_rel64:\n  \"bi_unique mod_ring_rel64\" \"left_unique mod_ring_rel64\" \"right_unique mod_ring_rel64\"", "lemma right_total_mod_ring_rel64: \"right_total mod_ring_rel64\"", "lemma Domainp_mod_ring_rel64: \"Domainp mod_ring_rel64 = (\\<lambda>x. 0 \\<le> x \\<and> x < pp)\"", "lemma ring_finite_field_ops64: \"ring_ops (finite_field_ops64 pp) mod_ring_rel64\"", "lemma mod_ring_normalize64: \"(mod_ring_rel64 ===> mod_ring_rel64) (\\<lambda>x. if x = 0 then 0 else 1) normalize\"", "lemma mod_ring_mod64: \"(mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (\\<lambda>x y. if y = 0 then x else 0) (mod)\"", "lemma mod_ring_unit_factor64: \"(mod_ring_rel64 ===> mod_ring_rel64) (\\<lambda>x. x) unit_factor\"", "lemma mod_ring_inverse64: \"(mod_ring_rel64 ===> mod_ring_rel64) (inverse_p64 pp) inverse\"", "lemma mod_ring_divide64: \"(mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (divide_p64 pp) (/)\"", "lemma finite_field_ops64: \"field_ops (finite_field_ops64 pp) mod_ring_rel64\"", "lemma int_of_integer_0_iff: \"int_of_integer n = 0 \\<longleftrightarrow> n = 0\"", "lemma int_of_integer_0: \"int_of_integer 0 = 0\"", "lemma int_of_integer_plus: \"int_of_integer (x + y) = (int_of_integer x + int_of_integer y)\"", "lemma int_of_integer_minus: \"int_of_integer (x - y) = (int_of_integer x - int_of_integer y)\"", "lemma int_of_integer_mult: \"int_of_integer (x * y) = (int_of_integer x * int_of_integer y)\"", "lemma int_of_integer_mod: \"int_of_integer (x mod y) = (int_of_integer x mod int_of_integer y)\"", "lemma int_of_integer_inv: \"int_of_integer (integer_of_int x) = x\"", "lemma int_of_integer_shift: \"int_of_integer (shiftr n k) = (int_of_integer n) div (2 ^ k)\"", "lemma shiftr_integer_code [code_unfold]: \"drop_bit 1 x = (integer_shiftr x 1)\"", "lemmas integer_simps = \n  int_of_integer_0\n  int_of_integer_plus \n  int_of_integer_minus\n  int_of_integer_mult", "lemma urel_integer_0: \"urel_integer 0 0\"", "lemma urel_integer_1: \"urel_integer 1 1\"", "lemma le_int_of_integer: \"(x \\<le> y) = (int_of_integer x \\<le> int_of_integer y)\"", "lemma urel_integer_plus: assumes \"urel_integer x y\" \"urel_integer x' y'\"\n  shows \"urel_integer (plus_p_integer pp x x') (plus_p p y y')\"", "lemma urel_integer_minus: assumes \"urel_integer x y\" \"urel_integer x' y'\"\n  shows \"urel_integer (minus_p_integer pp x x') (minus_p p y y')\"", "lemma urel_integer_uminus: assumes \"urel_integer x y\"\n  shows \"urel_integer (uminus_p_integer pp x) (uminus_p p y)\"", "lemma pp_pos: \"int_of_integer pp > 0\"", "lemma urel_integer_mult: assumes \"urel_integer x y\" \"urel_integer x' y'\"\n  shows \"urel_integer (mult_p_integer pp x x') (mult_p p y y')\"", "lemma urel_integer_eq: assumes \"urel_integer x y\" \"urel_integer x' y'\" \n  shows \"(x = x') = (y = y')\"", "lemma urel_integer_normalize: \nassumes x: \"urel_integer x y\"\nshows \"urel_integer (if x = 0 then 0 else 1) (if y = 0 then 0 else 1)\"", "lemma urel_integer_mod: \nassumes x: \"urel_integer x x'\" and y: \"urel_integer y y'\" \nshows \"urel_integer (if y = 0 then x else 0) (if y' = 0 then x' else 0)\"", "lemma urel_integer_power: \"urel_integer x x' \\<Longrightarrow> urel_integer y (int y') \\<Longrightarrow> urel_integer (power_p_integer pp x y) (power_p p x' y')\"", "lemma urel_integer_inverse: assumes x: \"urel_integer x x'\" \n  shows \"urel_integer (inverse_p_integer pp x) (inverse_p p x')\"", "lemma mod_ring_0__integer: \"mod_ring_rel_integer 0 0\"", "lemma mod_ring_1__integer: \"mod_ring_rel_integer 1 1\"", "lemma mod_ring_uminus_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer) (uminus_p_integer pp) uminus\"", "lemma mod_ring_plus_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer ===> mod_ring_rel_integer) (plus_p_integer pp) (+)\"", "lemma mod_ring_minus_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer ===> mod_ring_rel_integer) (minus_p_integer pp) (-)\"", "lemma mod_ring_mult_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer ===> mod_ring_rel_integer) (mult_p_integer pp) ((*))\"", "lemma mod_ring_eq_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer ===> (=)) (=) (=)\"", "lemma urel_integer_inj: \"urel_integer x y \\<Longrightarrow> urel_integer x z \\<Longrightarrow> y = z\"", "lemma urel_integer_inj': \"urel_integer x z \\<Longrightarrow> urel_integer y z \\<Longrightarrow> x = y\"", "lemma bi_unique_mod_ring_rel_integer:\n  \"bi_unique mod_ring_rel_integer\" \"left_unique mod_ring_rel_integer\" \"right_unique mod_ring_rel_integer\"", "lemma right_total_mod_ring_rel_integer: \"right_total mod_ring_rel_integer\"", "lemma Domainp_mod_ring_rel_integer: \"Domainp mod_ring_rel_integer = (\\<lambda>x. 0 \\<le> x \\<and> x < pp)\"", "lemma ring_finite_field_ops_integer: \"ring_ops (finite_field_ops_integer pp) mod_ring_rel_integer\"", "lemma mod_ring_normalize_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer) (\\<lambda>x. if x = 0 then 0 else 1) normalize\"", "lemma mod_ring_mod_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer ===> mod_ring_rel_integer) (\\<lambda>x y. if y = 0 then x else 0) (mod)\"", "lemma mod_ring_unit_factor_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer) (\\<lambda>x. x) unit_factor\"", "lemma mod_ring_inverse_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer) (inverse_p_integer pp) inverse\"", "lemma mod_ring_divide_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer ===> mod_ring_rel_integer) (divide_p_integer pp) (/)\"", "lemma finite_field_ops_integer: \"field_ops (finite_field_ops_integer pp) mod_ring_rel_integer\""], "translations": [["", "lemma mod_nonneg_pos_int[simp]: \"x \\<ge> 0 \\<Longrightarrow> y > 0 \\<Longrightarrow> mod_nonneg_pos_int x y = (x mod y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; 0 < y\\<rbrakk>\n    \\<Longrightarrow> mod_nonneg_pos_int x y = x mod y", "unfolding mod_nonneg_pos_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; 0 < y\\<rbrakk>\n    \\<Longrightarrow> int_of_integer\n                       (mod_nonneg_pos (integer_of_int x)\n                         (integer_of_int y)) =\n                      x mod y", "using mod_nonneg_pos_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; 0 < ?y\\<rbrakk>\n  \\<Longrightarrow> mod_nonneg_pos ?x ?y = ?x mod ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; 0 < y\\<rbrakk>\n    \\<Longrightarrow> int_of_integer\n                       (mod_nonneg_pos (integer_of_int x)\n                         (integer_of_int y)) =\n                      x mod y", "by simp"], ["", "context\n  fixes p :: int\nbegin"], ["", "definition plus_p :: \"int \\<Rightarrow> int \\<Rightarrow> int\" where\n  \"plus_p x y \\<equiv> let z = x + y in if z \\<ge> p then z - p else z\""], ["", "definition minus_p :: \"int \\<Rightarrow> int \\<Rightarrow> int\" where\n  \"minus_p x y \\<equiv> if y \\<le> x then x - y else x + p - y\""], ["", "definition uminus_p :: \"int \\<Rightarrow> int\" where\n  \"uminus_p x = (if x = 0 then 0 else p - x)\""], ["", "definition mult_p :: \"int \\<Rightarrow> int \\<Rightarrow> int\" where\n  \"mult_p x y = (mod_nonneg_pos_int (x * y) p)\""], ["", "fun power_p :: \"int \\<Rightarrow> nat \\<Rightarrow> int\" where\n  \"power_p x n = (if n = 0 then 1 else\n    let (d,r) = Divides.divmod_nat n 2;\n       rec = power_p (mult_p x x) d in\n    if r = 0 then rec else mult_p rec x)\""], ["", "text \\<open>In experiments with Berlekamp-factorization (where the prime $p$ is usually small),\n  it turned out that taking the below implementation of inverse via exponentiation\n  is faster than the one based on the extended Euclidean algorithm.\\<close>"], ["", "definition inverse_p :: \"int \\<Rightarrow> int\" where\n  \"inverse_p x = (if x = 0 then 0 else power_p x (nat (p - 2)))\""], ["", "definition divide_p :: \"int \\<Rightarrow> int \\<Rightarrow> int\"  where\n  \"divide_p x y = mult_p x (inverse_p y)\""], ["", "definition finite_field_ops_int :: \"int arith_ops_record\" where\n  \"finite_field_ops_int \\<equiv> Arith_Ops_Record\n      0\n      1\n      plus_p\n      mult_p\n      minus_p\n      uminus_p\n      divide_p\n      inverse_p\n      (\\<lambda> x y . if y = 0 then x else 0)\n      (\\<lambda> x . if x = 0 then 0 else 1)\n      (\\<lambda> x . x)\n      (\\<lambda> x . x)\n      (\\<lambda> x . x)\n      (\\<lambda> x. 0 \\<le> x \\<and> x < p)\""], ["", "end"], ["", "context\n  fixes p :: uint32\nbegin"], ["", "definition plus_p32 :: \"uint32 \\<Rightarrow> uint32 \\<Rightarrow> uint32\" where\n  \"plus_p32 x y \\<equiv> let z = x + y in if z \\<ge> p then z - p else z\""], ["", "definition minus_p32 :: \"uint32 \\<Rightarrow> uint32 \\<Rightarrow> uint32\" where\n  \"minus_p32 x y \\<equiv> if y \\<le> x then x - y else (x + p) - y\""], ["", "definition uminus_p32 :: \"uint32 \\<Rightarrow> uint32\" where\n  \"uminus_p32 x = (if x = 0 then 0 else p - x)\""], ["", "definition mult_p32 :: \"uint32 \\<Rightarrow> uint32 \\<Rightarrow> uint32\" where\n  \"mult_p32 x y = (x * y mod p)\""], ["", "lemma int_of_uint32_shift: \"int_of_uint32 (shiftr n k) = (int_of_uint32 n) div (2 ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint32 (n >> k) = int_of_uint32 n div 2 ^ k", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n k. uint (drop_bit k n) = uint n div 2 ^ k", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n k.\n       take_bit LENGTH(32) ((drop_bit k \\<circ> take_bit LENGTH(32)) n) =\n       take_bit LENGTH(32) n div 2 ^ k", "apply (simp add: take_bit_drop_bit min_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n k.\n       0 < k \\<longrightarrow>\n       drop_bit k (take_bit 32 n) = take_bit 32 n div 2 ^ k", "apply (simp add: drop_bit_eq_div)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma int_of_uint32_0_iff: \"int_of_uint32 n = 0 \\<longleftrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int_of_uint32 n = 0) = (n = 0)", "by (transfer, rule uint_0_iff)"], ["", "lemma int_of_uint32_0: \"int_of_uint32 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint32 0 = 0", "unfolding int_of_uint32_0_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = 0", "by simp"], ["", "lemma int_of_uint32_ge_0: \"int_of_uint32 n \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> int_of_uint32 n", "by (transfer, auto)"], ["", "lemma two_32: \"2 ^ LENGTH(32) = (4294967296 :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ LENGTH(32) = 4294967296", "by simp"], ["", "lemma int_of_uint32_plus: \"int_of_uint32 (x + y) = (int_of_uint32 x + int_of_uint32 y) mod 4294967296\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint32 (x + y) =\n    (int_of_uint32 x + int_of_uint32 y) mod 4294967296", "by (transfer, unfold uint_word_ariths two_32, rule refl)"], ["", "lemma int_of_uint32_minus: \"int_of_uint32 (x - y) = (int_of_uint32 x - int_of_uint32 y) mod 4294967296\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint32 (x - y) =\n    (int_of_uint32 x - int_of_uint32 y) mod 4294967296", "by (transfer, unfold uint_word_ariths two_32, rule refl)"], ["", "lemma int_of_uint32_mult: \"int_of_uint32 (x * y) = (int_of_uint32 x * int_of_uint32 y) mod 4294967296\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint32 (x * y) = int_of_uint32 x * int_of_uint32 y mod 4294967296", "by (transfer, unfold uint_word_ariths two_32, rule refl)"], ["", "lemma int_of_uint32_mod: \"int_of_uint32 (x mod y) = (int_of_uint32 x mod int_of_uint32 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint32 (x mod y) = int_of_uint32 x mod int_of_uint32 y", "by (transfer, unfold uint_mod two_32, rule refl)"], ["", "lemma int_of_uint32_inv: \"0 \\<le> x \\<Longrightarrow> x < 4294967296 \\<Longrightarrow> int_of_uint32 (uint32_of_int x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; x < 4294967296\\<rbrakk>\n    \\<Longrightarrow> int_of_uint32 (uint32_of_int x) = x", "by transfer (simp add: take_bit_int_eq_self)"], ["", "function power_p32 :: \"uint32 \\<Rightarrow> uint32 \\<Rightarrow> uint32\" where\n  \"power_p32 x n = (if n = 0 then 1 else\n    let rec = power_p32 (mult_p32 x x) (shiftr n 1) in\n    if n AND 1 = 0 then rec else mult_p32 rec x)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>xa n. x = (xa, n) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>x n xa na.\n       (x, n) = (xa, na) \\<Longrightarrow>\n       (if n = 0 then 1\n        else let rec = power_p32_sumC (local.mult_p32 x x, n >> 1)\n             in if n AND 1 = 0 then rec else local.mult_p32 rec x) =\n       (if na = 0 then 1\n        else let rec = power_p32_sumC (local.mult_p32 xa xa, na >> 1)\n             in if na AND 1 = 0 then rec else local.mult_p32 rec xa)", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All local.power_p32_dom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. All local.power_p32_dom", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. All local.power_p32_dom", "fix n :: uint32"], ["proof (state)\ngoal (1 subgoal):\n 1. All local.power_p32_dom", "assume \"n \\<noteq> 0\""], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. All local.power_p32_dom", "with int_of_uint32_ge_0[of n] int_of_uint32_0_iff[of n]"], ["proof (chain)\npicking this:\n  0 \\<le> int_of_uint32 n\n  (int_of_uint32 n = 0) = (n = 0)\n  n \\<noteq> 0", "have \"int_of_uint32 n > 0\""], ["proof (prove)\nusing this:\n  0 \\<le> int_of_uint32 n\n  (int_of_uint32 n = 0) = (n = 0)\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < int_of_uint32 n", "by auto"], ["proof (state)\nthis:\n  0 < int_of_uint32 n\n\ngoal (1 subgoal):\n 1. All local.power_p32_dom", "hence \"0 < int_of_uint32 n\" \"int_of_uint32 n div 2 < int_of_uint32 n\""], ["proof (prove)\nusing this:\n  0 < int_of_uint32 n\n\ngoal (1 subgoal):\n 1. 0 < int_of_uint32 n &&& int_of_uint32 n div 2 < int_of_uint32 n", "by auto"], ["proof (state)\nthis:\n  0 < int_of_uint32 n\n  int_of_uint32 n div 2 < int_of_uint32 n\n\ngoal (1 subgoal):\n 1. All local.power_p32_dom", "}"], ["proof (state)\nthis:\n  ?n2 \\<noteq> 0 \\<Longrightarrow> 0 < int_of_uint32 ?n2\n  ?n2 \\<noteq> 0 \\<Longrightarrow>\n  int_of_uint32 ?n2 div 2 < int_of_uint32 ?n2\n\ngoal (1 subgoal):\n 1. All local.power_p32_dom", "note * = this"], ["proof (state)\nthis:\n  ?n2 \\<noteq> 0 \\<Longrightarrow> 0 < int_of_uint32 ?n2\n  ?n2 \\<noteq> 0 \\<Longrightarrow>\n  int_of_uint32 ?n2 div 2 < int_of_uint32 ?n2\n\ngoal (1 subgoal):\n 1. All local.power_p32_dom", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. All local.power_p32_dom", "by (relation \"measure (\\<lambda> (x,n). nat (int_of_uint32 n))\", auto simp: int_of_uint32_shift *)"], ["proof (state)\nthis:\n  All local.power_p32_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In experiments with Berlekamp-factorization (where the prime $p$ is usually small),\n  it turned out that taking the below implementation of inverse via exponentiation\n  is faster than the one based on the extended Euclidean algorithm.\\<close>"], ["", "definition inverse_p32 :: \"uint32 \\<Rightarrow> uint32\" where\n  \"inverse_p32 x = (if x = 0 then 0 else power_p32 x (p - 2))\""], ["", "definition divide_p32 :: \"uint32 \\<Rightarrow> uint32 \\<Rightarrow> uint32\"  where\n  \"divide_p32 x y = mult_p32 x (inverse_p32 y)\""], ["", "definition finite_field_ops32 :: \"uint32 arith_ops_record\" where\n  \"finite_field_ops32 \\<equiv> Arith_Ops_Record\n      0\n      1\n      plus_p32\n      mult_p32\n      minus_p32\n      uminus_p32\n      divide_p32\n      inverse_p32\n      (\\<lambda> x y . if y = 0 then x else 0)\n      (\\<lambda> x . if x = 0 then 0 else 1)\n      (\\<lambda> x . x)\n      uint32_of_int\n      int_of_uint32\n      (\\<lambda> x. 0 \\<le> x \\<and> x < p)\""], ["", "end"], ["", "lemma shiftr_uint32_code [code_unfold]: \"drop_bit 1 x = (uint32_shiftr x 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit 1 x = uint32_shiftr x 1", "by (simp add: uint32_shiftr_def shiftr_eq_drop_bit)"], ["", "(* ******************************************************************************** *)"], ["", "subsubsection \\<open>Transfer Relation\\<close>"], ["", "locale mod_ring_locale =\n  fixes p :: int and ty :: \"'a :: nontriv itself\"\n  assumes p: \"p = int CARD('a)\"\nbegin"], ["", "lemma nat_p: \"nat p = CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat p = CARD('a)", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (int CARD('a)) = CARD('a)", "by simp"], ["", "lemma p2: \"p \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> p", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> int CARD('a)", "using nontriv[where 'a = 'a]"], ["proof (prove)\nusing this:\n  1 < CARD('a)\n\ngoal (1 subgoal):\n 1. 2 \\<le> int CARD('a)", "by auto"], ["", "lemma p2_ident: \"int (CARD('a) - 2) = p - 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (CARD('a) - 2) = p - 2", "using p2"], ["proof (prove)\nusing this:\n  2 \\<le> p\n\ngoal (1 subgoal):\n 1. int (CARD('a) - 2) = p - 2", "unfolding p"], ["proof (prove)\nusing this:\n  2 \\<le> int CARD('a)\n\ngoal (1 subgoal):\n 1. int (CARD('a) - 2) = int CARD('a) - 2", "by simp"], ["", "definition mod_ring_rel :: \"int \\<Rightarrow> 'a mod_ring \\<Rightarrow> bool\" where\n  \"mod_ring_rel x x' = (x = to_int_mod_ring x')\""], ["", "(* domain transfer rules *)"], ["", "lemma Domainp_mod_ring_rel [transfer_domain_rule]:\n  \"Domainp (mod_ring_rel) = (\\<lambda> v. v \\<in> {0 ..< p})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})", "fix v :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})", "assume *: \"0 \\<le> v\" \"v < p\""], ["proof (state)\nthis:\n  0 \\<le> v\n  v < p\n\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})", "have \"Domainp mod_ring_rel v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_ring_rel v ?b", "show \"mod_ring_rel v (of_int_mod_ring v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel v (of_int_mod_ring v)", "unfolding mod_ring_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v = to_int_mod_ring (of_int_mod_ring v)", "using * p"], ["proof (prove)\nusing this:\n  0 \\<le> v\n  v < p\n  p = int CARD('a)\n\ngoal (1 subgoal):\n 1. v = to_int_mod_ring (of_int_mod_ring v)", "by auto"], ["proof (state)\nthis:\n  mod_ring_rel v (of_int_mod_ring v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Domainp mod_ring_rel v\n\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?v2; ?v2 < p\\<rbrakk>\n  \\<Longrightarrow> Domainp mod_ring_rel ?v2\n\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?v2; ?v2 < p\\<rbrakk>\n  \\<Longrightarrow> Domainp mod_ring_rel ?v2\n\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})", "by (intro ext iffI, insert range_to_int_mod_ring[where 'a = 'a] *, auto simp: mod_ring_rel_def p)"], ["proof (state)\nthis:\n  Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})\n\ngoal:\nNo subgoals!", "qed"], ["", "(* left/right/bi-unique *)"], ["", "lemma bi_unique_mod_ring_rel [transfer_rule]:\n  \"bi_unique mod_ring_rel\" \"left_unique mod_ring_rel\" \"right_unique mod_ring_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique mod_ring_rel &&&\n    left_unique mod_ring_rel &&& right_unique mod_ring_rel", "unfolding mod_ring_rel_def bi_unique_def left_unique_def right_unique_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        x = to_int_mod_ring y \\<longrightarrow>\n        x = to_int_mod_ring z \\<longrightarrow> y = z) \\<and>\n    (\\<forall>x y z.\n        x = to_int_mod_ring z \\<longrightarrow>\n        y = to_int_mod_ring z \\<longrightarrow> x = y) &&&\n    \\<forall>x y z.\n       x = to_int_mod_ring z \\<longrightarrow>\n       y = to_int_mod_ring z \\<longrightarrow> x = y &&&\n    \\<forall>x y z.\n       x = to_int_mod_ring y \\<longrightarrow>\n       x = to_int_mod_ring z \\<longrightarrow> y = z", "by auto"], ["", "(* left/right-total *)"], ["", "lemma right_total_mod_ring_rel [transfer_rule]: \"right_total mod_ring_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total mod_ring_rel", "unfolding mod_ring_rel_def right_total_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. x = to_int_mod_ring y", "by simp"], ["", "(* ************************************************************************************ *)"], ["", "subsubsection \\<open>Transfer Rules\\<close>"], ["", "(* 0 / 1 *)"], ["", "lemma mod_ring_0[transfer_rule]: \"mod_ring_rel 0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel 0 0", "unfolding mod_ring_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = to_int_mod_ring 0", "by simp"], ["", "lemma mod_ring_1[transfer_rule]: \"mod_ring_rel 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel 1 1", "unfolding mod_ring_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = to_int_mod_ring 1", "by simp"], ["", "(* addition *)"], ["", "lemma plus_p_mod_def: assumes x: \"x \\<in> {0 ..< p}\" and y: \"y \\<in> {0 ..< p}\"\n  shows \"plus_p p x y = ((x + y) mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plus_p p x y = (x + y) mod p", "proof (cases \"p \\<le> x + y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<le> x + y \\<Longrightarrow> plus_p p x y = (x + y) mod p\n 2. \\<not> p \\<le> x + y \\<Longrightarrow> plus_p p x y = (x + y) mod p", "case False"], ["proof (state)\nthis:\n  \\<not> p \\<le> x + y\n\ngoal (2 subgoals):\n 1. p \\<le> x + y \\<Longrightarrow> plus_p p x y = (x + y) mod p\n 2. \\<not> p \\<le> x + y \\<Longrightarrow> plus_p p x y = (x + y) mod p", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> p \\<le> x + y\n\ngoal (1 subgoal):\n 1. plus_p p x y = (x + y) mod p", "using x y"], ["proof (prove)\nusing this:\n  \\<not> p \\<le> x + y\n  x \\<in> {0..<p}\n  y \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. plus_p p x y = (x + y) mod p", "unfolding plus_p_def Let_def"], ["proof (prove)\nusing this:\n  \\<not> p \\<le> x + y\n  x \\<in> {0..<p}\n  y \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. (if p \\<le> x + y then x + y - p else x + y) = (x + y) mod p", "by auto"], ["proof (state)\nthis:\n  plus_p p x y = (x + y) mod p\n\ngoal (1 subgoal):\n 1. p \\<le> x + y \\<Longrightarrow> plus_p p x y = (x + y) mod p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<le> x + y \\<Longrightarrow> plus_p p x y = (x + y) mod p", "case True"], ["proof (state)\nthis:\n  p \\<le> x + y\n\ngoal (1 subgoal):\n 1. p \\<le> x + y \\<Longrightarrow> plus_p p x y = (x + y) mod p", "from True x y"], ["proof (chain)\npicking this:\n  p \\<le> x + y\n  x \\<in> {0..<p}\n  y \\<in> {0..<p}", "have *: \"p > 0\" \"0 \\<le> x + y - p\" \"x + y - p < p\""], ["proof (prove)\nusing this:\n  p \\<le> x + y\n  x \\<in> {0..<p}\n  y \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. 0 < p &&& 0 \\<le> x + y - p &&& x + y - p < p", "by auto"], ["proof (state)\nthis:\n  0 < p\n  0 \\<le> x + y - p\n  x + y - p < p\n\ngoal (1 subgoal):\n 1. p \\<le> x + y \\<Longrightarrow> plus_p p x y = (x + y) mod p", "from True"], ["proof (chain)\npicking this:\n  p \\<le> x + y", "have id: \"plus_p p x y = x + y - p\""], ["proof (prove)\nusing this:\n  p \\<le> x + y\n\ngoal (1 subgoal):\n 1. plus_p p x y = x + y - p", "unfolding plus_p_def"], ["proof (prove)\nusing this:\n  p \\<le> x + y\n\ngoal (1 subgoal):\n 1. (let z = x + y in if p \\<le> z then z - p else z) = x + y - p", "by auto"], ["proof (state)\nthis:\n  plus_p p x y = x + y - p\n\ngoal (1 subgoal):\n 1. p \\<le> x + y \\<Longrightarrow> plus_p p x y = (x + y) mod p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. plus_p p x y = (x + y) mod p", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y - p = (x + y) mod p", "using *"], ["proof (prove)\nusing this:\n  0 < p\n  0 \\<le> x + y - p\n  x + y - p < p\n\ngoal (1 subgoal):\n 1. x + y - p = (x + y) mod p", "using mod_pos_pos_trivial"], ["proof (prove)\nusing this:\n  0 < p\n  0 \\<le> x + y - p\n  x + y - p < p\n  \\<lbrakk>0 \\<le> ?k; ?k < ?l\\<rbrakk> \\<Longrightarrow> ?k mod ?l = ?k\n\ngoal (1 subgoal):\n 1. x + y - p = (x + y) mod p", "by fastforce"], ["proof (state)\nthis:\n  plus_p p x y = (x + y) mod p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_ring_plus[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (plus_p p) (+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (plus_p p) (+)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (plus_p p) (+)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (plus_p p) (+)", "fix x y :: \"'a mod_ring\""], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (plus_p p) (+)", "have \"plus_p p (to_int_mod_ring x) (to_int_mod_ring y) = to_int_mod_ring (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plus_p p (to_int_mod_ring x) (to_int_mod_ring y) =\n    to_int_mod_ring (x + y)", "by (transfer, subst plus_p_mod_def, auto, auto simp: p)"], ["proof (state)\nthis:\n  plus_p p (to_int_mod_ring x) (to_int_mod_ring y) = to_int_mod_ring (x + y)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (plus_p p) (+)", "}"], ["proof (state)\nthis:\n  plus_p p (to_int_mod_ring ?x2) (to_int_mod_ring ?y2) =\n  to_int_mod_ring (?x2 + ?y2)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (plus_p p) (+)", "note * = this"], ["proof (state)\nthis:\n  plus_p p (to_int_mod_ring ?x2) (to_int_mod_ring ?y2) =\n  to_int_mod_ring (?x2 + ?y2)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (plus_p p) (+)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (plus_p p) (+)", "by (intro rel_funI, auto simp: mod_ring_rel_def *)"], ["proof (state)\nthis:\n  (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (plus_p p) (+)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* subtraction *)"], ["", "lemma minus_p_mod_def: assumes x: \"x \\<in> {0 ..< p}\" and y: \"y \\<in> {0 ..< p}\"\n  shows \"minus_p p x y = ((x - y) mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minus_p p x y = (x - y) mod p", "proof (cases \"x - y < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x - y < 0 \\<Longrightarrow> minus_p p x y = (x - y) mod p\n 2. \\<not> x - y < 0 \\<Longrightarrow> minus_p p x y = (x - y) mod p", "case False"], ["proof (state)\nthis:\n  \\<not> x - y < 0\n\ngoal (2 subgoals):\n 1. x - y < 0 \\<Longrightarrow> minus_p p x y = (x - y) mod p\n 2. \\<not> x - y < 0 \\<Longrightarrow> minus_p p x y = (x - y) mod p", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> x - y < 0\n\ngoal (1 subgoal):\n 1. minus_p p x y = (x - y) mod p", "using x y"], ["proof (prove)\nusing this:\n  \\<not> x - y < 0\n  x \\<in> {0..<p}\n  y \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. minus_p p x y = (x - y) mod p", "unfolding minus_p_def Let_def"], ["proof (prove)\nusing this:\n  \\<not> x - y < 0\n  x \\<in> {0..<p}\n  y \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. (if y \\<le> x then x - y else x + p - y) = (x - y) mod p", "by auto"], ["proof (state)\nthis:\n  minus_p p x y = (x - y) mod p\n\ngoal (1 subgoal):\n 1. x - y < 0 \\<Longrightarrow> minus_p p x y = (x - y) mod p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x - y < 0 \\<Longrightarrow> minus_p p x y = (x - y) mod p", "case True"], ["proof (state)\nthis:\n  x - y < 0\n\ngoal (1 subgoal):\n 1. x - y < 0 \\<Longrightarrow> minus_p p x y = (x - y) mod p", "from True x y"], ["proof (chain)\npicking this:\n  x - y < 0\n  x \\<in> {0..<p}\n  y \\<in> {0..<p}", "have *: \"p > 0\" \"0 \\<le> x - y + p\" \"x - y + p < p\""], ["proof (prove)\nusing this:\n  x - y < 0\n  x \\<in> {0..<p}\n  y \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. 0 < p &&& 0 \\<le> x - y + p &&& x - y + p < p", "by auto"], ["proof (state)\nthis:\n  0 < p\n  0 \\<le> x - y + p\n  x - y + p < p\n\ngoal (1 subgoal):\n 1. x - y < 0 \\<Longrightarrow> minus_p p x y = (x - y) mod p", "from True"], ["proof (chain)\npicking this:\n  x - y < 0", "have id: \"minus_p p x y = x - y + p\""], ["proof (prove)\nusing this:\n  x - y < 0\n\ngoal (1 subgoal):\n 1. minus_p p x y = x - y + p", "unfolding minus_p_def"], ["proof (prove)\nusing this:\n  x - y < 0\n\ngoal (1 subgoal):\n 1. (if y \\<le> x then x - y else x + p - y) = x - y + p", "by auto"], ["proof (state)\nthis:\n  minus_p p x y = x - y + p\n\ngoal (1 subgoal):\n 1. x - y < 0 \\<Longrightarrow> minus_p p x y = (x - y) mod p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. minus_p p x y = (x - y) mod p", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. x - y + p = (x - y) mod p", "using *"], ["proof (prove)\nusing this:\n  0 < p\n  0 \\<le> x - y + p\n  x - y + p < p\n\ngoal (1 subgoal):\n 1. x - y + p = (x - y) mod p", "using mod_pos_pos_trivial"], ["proof (prove)\nusing this:\n  0 < p\n  0 \\<le> x - y + p\n  x - y + p < p\n  \\<lbrakk>0 \\<le> ?k; ?k < ?l\\<rbrakk> \\<Longrightarrow> ?k mod ?l = ?k\n\ngoal (1 subgoal):\n 1. x - y + p = (x - y) mod p", "by fastforce"], ["proof (state)\nthis:\n  minus_p p x y = (x - y) mod p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_ring_minus[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (minus_p p) (-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (minus_p p) (-)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (minus_p p) (-)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (minus_p p) (-)", "fix x y :: \"'a mod_ring\""], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (minus_p p) (-)", "have \"minus_p p (to_int_mod_ring x) (to_int_mod_ring y) = to_int_mod_ring (x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minus_p p (to_int_mod_ring x) (to_int_mod_ring y) =\n    to_int_mod_ring (x - y)", "by (transfer, subst minus_p_mod_def, auto simp: p)"], ["proof (state)\nthis:\n  minus_p p (to_int_mod_ring x) (to_int_mod_ring y) =\n  to_int_mod_ring (x - y)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (minus_p p) (-)", "}"], ["proof (state)\nthis:\n  minus_p p (to_int_mod_ring ?x2) (to_int_mod_ring ?y2) =\n  to_int_mod_ring (?x2 - ?y2)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (minus_p p) (-)", "note * = this"], ["proof (state)\nthis:\n  minus_p p (to_int_mod_ring ?x2) (to_int_mod_ring ?y2) =\n  to_int_mod_ring (?x2 - ?y2)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (minus_p p) (-)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (minus_p p) (-)", "by (intro rel_funI, auto simp: mod_ring_rel_def *)"], ["proof (state)\nthis:\n  (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (minus_p p) (-)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* unary minus *)"], ["", "lemma mod_ring_uminus[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel) (uminus_p p) uminus\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (uminus_p p) uminus", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (uminus_p p) uminus", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (uminus_p p) uminus", "fix x :: \"'a mod_ring\""], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (uminus_p p) uminus", "have \"uminus_p p (to_int_mod_ring x) = to_int_mod_ring (uminus x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uminus_p p (to_int_mod_ring x) = to_int_mod_ring (- x)", "by (transfer, auto simp: uminus_p_def p)"], ["proof (state)\nthis:\n  uminus_p p (to_int_mod_ring x) = to_int_mod_ring (- x)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (uminus_p p) uminus", "}"], ["proof (state)\nthis:\n  uminus_p p (to_int_mod_ring ?x2) = to_int_mod_ring (- ?x2)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (uminus_p p) uminus", "note * = this"], ["proof (state)\nthis:\n  uminus_p p (to_int_mod_ring ?x2) = to_int_mod_ring (- ?x2)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (uminus_p p) uminus", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (uminus_p p) uminus", "by (intro rel_funI, auto simp: mod_ring_rel_def *)"], ["proof (state)\nthis:\n  (mod_ring_rel ===> mod_ring_rel) (uminus_p p) uminus\n\ngoal:\nNo subgoals!", "qed"], ["", "(* multiplication *)"], ["", "lemma mod_ring_mult[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (mult_p p) ((*))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (mult_p p) (*)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (mult_p p) (*)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (mult_p p) (*)", "fix x y :: \"'a mod_ring\""], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (mult_p p) (*)", "have \"mult_p p (to_int_mod_ring x) (to_int_mod_ring y) = to_int_mod_ring (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mult_p p (to_int_mod_ring x) (to_int_mod_ring y) =\n    to_int_mod_ring (x * y)", "by (transfer, auto simp: mult_p_def p)"], ["proof (state)\nthis:\n  mult_p p (to_int_mod_ring x) (to_int_mod_ring y) = to_int_mod_ring (x * y)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (mult_p p) (*)", "}"], ["proof (state)\nthis:\n  mult_p p (to_int_mod_ring ?x2) (to_int_mod_ring ?y2) =\n  to_int_mod_ring (?x2 * ?y2)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (mult_p p) (*)", "note * = this"], ["proof (state)\nthis:\n  mult_p p (to_int_mod_ring ?x2) (to_int_mod_ring ?y2) =\n  to_int_mod_ring (?x2 * ?y2)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (mult_p p) (*)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (mult_p p) (*)", "by (intro rel_funI, auto simp: mod_ring_rel_def *)"], ["proof (state)\nthis:\n  (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (mult_p p) (*)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* equality *)"], ["", "lemma mod_ring_eq[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel ===> (=)) (=) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> (=)) (=) (=)", "by (intro rel_funI, auto simp: mod_ring_rel_def)"], ["", "(* power *)"], ["", "lemma mod_ring_power[transfer_rule]: \"(mod_ring_rel ===> (=) ===> mod_ring_rel) (power_p p) (^)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> (=) ===> mod_ring_rel) (power_p p) (^)", "proof (intro rel_funI, clarify, unfold binary_power[symmetric], goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       mod_ring_rel x y \\<Longrightarrow>\n       mod_ring_rel (power_p p x ya) (binary_power y ya)", "fix x y n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       mod_ring_rel x y \\<Longrightarrow>\n       mod_ring_rel (power_p p x ya) (binary_power y ya)", "assume xy: \"mod_ring_rel x y\""], ["proof (state)\nthis:\n  mod_ring_rel x y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       mod_ring_rel x y \\<Longrightarrow>\n       mod_ring_rel (power_p p x ya) (binary_power y ya)", "from xy"], ["proof (chain)\npicking this:\n  mod_ring_rel x y", "show \"mod_ring_rel (power_p p x n) (binary_power y n)\""], ["proof (prove)\nusing this:\n  mod_ring_rel x y\n\ngoal (1 subgoal):\n 1. mod_ring_rel (power_p p x n) (binary_power y n)", "proof (induct y n arbitrary: x rule: binary_power.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x n xa.\n       \\<lbrakk>\\<And>xa xb y xc.\n                   \\<lbrakk>n \\<noteq> 0; xa = divmod_nat n 2; (xb, y) = xa;\n                    mod_ring_rel xc (x * x)\\<rbrakk>\n                   \\<Longrightarrow> mod_ring_rel (power_p p xc xb)\n(binary_power (x * x) xb);\n        mod_ring_rel xa x\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel (power_p p xa n) (binary_power x n)", "case (1 x n y)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<noteq> 0; ?xa = divmod_nat n 2; (?xb, ?y) = ?xa;\n   mod_ring_rel ?x (x * x)\\<rbrakk>\n  \\<Longrightarrow> mod_ring_rel (power_p p ?x ?xb)\n                     (binary_power (x * x) ?xb)\n  mod_ring_rel y x\n\ngoal (1 subgoal):\n 1. \\<And>x n xa.\n       \\<lbrakk>\\<And>xa xb y xc.\n                   \\<lbrakk>n \\<noteq> 0; xa = divmod_nat n 2; (xb, y) = xa;\n                    mod_ring_rel xc (x * x)\\<rbrakk>\n                   \\<Longrightarrow> mod_ring_rel (power_p p xc xb)\n(binary_power (x * x) xb);\n        mod_ring_rel xa x\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel (power_p p xa n) (binary_power x n)", "note 1(2)[transfer_rule]"], ["proof (state)\nthis:\n  mod_ring_rel y x\n\ngoal (1 subgoal):\n 1. \\<And>x n xa.\n       \\<lbrakk>\\<And>xa xb y xc.\n                   \\<lbrakk>n \\<noteq> 0; xa = divmod_nat n 2; (xb, y) = xa;\n                    mod_ring_rel xc (x * x)\\<rbrakk>\n                   \\<Longrightarrow> mod_ring_rel (power_p p xc xb)\n(binary_power (x * x) xb);\n        mod_ring_rel xa x\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel (power_p p xa n) (binary_power x n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel (power_p p y n) (binary_power x n)", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> mod_ring_rel (power_p p y n) (binary_power x n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    mod_ring_rel (power_p p y n) (binary_power x n)", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> mod_ring_rel (power_p p y n) (binary_power x n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    mod_ring_rel (power_p p y n) (binary_power x n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. mod_ring_rel (power_p p y n) (binary_power x n)", "by (simp add: mod_ring_1)"], ["proof (state)\nthis:\n  mod_ring_rel (power_p p y n) (binary_power x n)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    mod_ring_rel (power_p p y n) (binary_power x n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    mod_ring_rel (power_p p y n) (binary_power x n)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    mod_ring_rel (power_p p y n) (binary_power x n)", "obtain d r where id: \"Divides.divmod_nat n 2 = (d,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d r.\n        divmod_nat n 2 = (d, r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  divmod_nat n 2 = (d, r)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    mod_ring_rel (power_p p y n) (binary_power x n)", "let ?int = \"power_p p (mult_p p y y) d\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    mod_ring_rel (power_p p y n) (binary_power x n)", "let ?gfp = \"binary_power (x * x) d\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    mod_ring_rel (power_p p y n) (binary_power x n)", "from False"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "have id': \"?thesis = (mod_ring_rel\n         (if r = 0 then ?int else mult_p p ?int y)\n         (if r = 0 then ?gfp else ?gfp * x))\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. mod_ring_rel (power_p p y n) (binary_power x n) =\n    mod_ring_rel\n     (if r = 0 then power_p p (mult_p p y y) d\n      else mult_p p (power_p p (mult_p p y y) d) y)\n     (if r = 0 then binary_power (x * x) d else binary_power (x * x) d * x)", "unfolding power_p.simps[of _ _ n] binary_power.simps[of _ n] Let_def id split"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. mod_ring_rel\n     (if n = 0 then 1\n      else if r = 0 then power_p p (mult_p p y y) d\n           else mult_p p (power_p p (mult_p p y y) d) y)\n     (if n = 0 then 1\n      else if r = 0 then binary_power (x * x) d\n           else binary_power (x * x) d * x) =\n    mod_ring_rel\n     (if r = 0 then power_p p (mult_p p y y) d\n      else mult_p p (power_p p (mult_p p y y) d) y)\n     (if r = 0 then binary_power (x * x) d else binary_power (x * x) d * x)", "by simp"], ["proof (state)\nthis:\n  mod_ring_rel (power_p p y n) (binary_power x n) =\n  mod_ring_rel\n   (if r = 0 then power_p p (mult_p p y y) d\n    else mult_p p (power_p p (mult_p p y y) d) y)\n   (if r = 0 then binary_power (x * x) d else binary_power (x * x) d * x)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    mod_ring_rel (power_p p y n) (binary_power x n)", "have [transfer_rule]: \"mod_ring_rel ?int ?gfp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel (power_p p (mult_p p y y) d) (binary_power (x * x) d)", "by (rule 1(1)[OF False refl id[symmetric]], transfer_prover)"], ["proof (state)\nthis:\n  mod_ring_rel (power_p p (mult_p p y y) d) (binary_power (x * x) d)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    mod_ring_rel (power_p p y n) (binary_power x n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel (power_p p y n) (binary_power x n)", "unfolding id'"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel\n     (if r = 0 then power_p p (mult_p p y y) d\n      else mult_p p (power_p p (mult_p p y y) d) y)\n     (if r = 0 then binary_power (x * x) d else binary_power (x * x) d * x)", "by transfer_prover"], ["proof (state)\nthis:\n  mod_ring_rel (power_p p y n) (binary_power x n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_ring_rel (power_p p y n) (binary_power x n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_ring_rel (power_p p x n) (binary_power y n)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare power_p.simps[simp del]"], ["", "lemma ring_finite_field_ops_int: \"ring_ops (finite_field_ops_int p) mod_ring_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_ops (finite_field_ops_int p) mod_ring_rel", "by (unfold_locales, auto simp:\n  finite_field_ops_int_def\n  bi_unique_mod_ring_rel\n  right_total_mod_ring_rel\n  mod_ring_plus\n  mod_ring_minus\n  mod_ring_uminus\n  mod_ring_mult\n  mod_ring_eq\n  mod_ring_0\n  mod_ring_1\n  Domainp_mod_ring_rel)"], ["", "end"], ["", "locale prime_field = mod_ring_locale p ty for p and ty :: \"'a :: prime_card itself\"\nbegin"], ["", "lemma prime: \"prime p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime (int CARD('a))", "using prime_card[where 'a = 'a]"], ["proof (prove)\nusing this:\n  prime CARD('a)\n\ngoal (1 subgoal):\n 1. prime (int CARD('a))", "by simp"], ["", "(* mod *)"], ["", "lemma mod_ring_mod[transfer_rule]:\n \"(mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) ((\\<lambda> x y. if y = 0 then x else 0)) (mod)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel)\n     (\\<lambda>x y. if y = 0 then x else 0) (mod)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel)\n     (\\<lambda>x y. if y = 0 then x else 0) (mod)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel)\n     (\\<lambda>x y. if y = 0 then x else 0) (mod)", "fix x y :: \"'a mod_ring\""], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel)\n     (\\<lambda>x y. if y = 0 then x else 0) (mod)", "have \"(if to_int_mod_ring y = 0 then to_int_mod_ring x else 0) = to_int_mod_ring (x mod y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if to_int_mod_ring y = 0 then to_int_mod_ring x else 0) =\n    to_int_mod_ring (x mod y)", "unfolding modulo_mod_ring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if to_int_mod_ring y = 0 then to_int_mod_ring x else 0) =\n    to_int_mod_ring (if y = 0 then x else 0)", "by auto"], ["proof (state)\nthis:\n  (if to_int_mod_ring y = 0 then to_int_mod_ring x else 0) =\n  to_int_mod_ring (x mod y)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel)\n     (\\<lambda>x y. if y = 0 then x else 0) (mod)", "}"], ["proof (state)\nthis:\n  (if to_int_mod_ring ?y2 = 0 then to_int_mod_ring ?x2 else 0) =\n  to_int_mod_ring (?x2 mod ?y2)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel)\n     (\\<lambda>x y. if y = 0 then x else 0) (mod)", "note * = this"], ["proof (state)\nthis:\n  (if to_int_mod_ring ?y2 = 0 then to_int_mod_ring ?x2 else 0) =\n  to_int_mod_ring (?x2 mod ?y2)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel)\n     (\\<lambda>x y. if y = 0 then x else 0) (mod)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel)\n     (\\<lambda>x y. if y = 0 then x else 0) (mod)", "by (intro rel_funI, auto simp: mod_ring_rel_def *[symmetric])"], ["proof (state)\nthis:\n  (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel)\n   (\\<lambda>x y. if y = 0 then x else 0) (mod)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* normalize *)"], ["", "lemma mod_ring_normalize[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel) ((\\<lambda> x. if x = 0 then 0 else 1)) normalize\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. if x = 0 then 0 else 1)\n     normalize", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. if x = 0 then 0 else 1)\n     normalize", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. if x = 0 then 0 else 1)\n     normalize", "fix x :: \"'a mod_ring\""], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. if x = 0 then 0 else 1)\n     normalize", "have \"(if to_int_mod_ring x = 0 then 0 else 1) = to_int_mod_ring (normalize x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if to_int_mod_ring x = 0 then 0 else 1) = to_int_mod_ring (normalize x)", "unfolding normalize_mod_ring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if to_int_mod_ring x = 0 then 0 else 1) =\n    to_int_mod_ring (if x = 0 then 0 else 1)", "by auto"], ["proof (state)\nthis:\n  (if to_int_mod_ring x = 0 then 0 else 1) = to_int_mod_ring (normalize x)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. if x = 0 then 0 else 1)\n     normalize", "}"], ["proof (state)\nthis:\n  (if to_int_mod_ring ?x2 = 0 then 0 else 1) =\n  to_int_mod_ring (normalize ?x2)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. if x = 0 then 0 else 1)\n     normalize", "note * = this"], ["proof (state)\nthis:\n  (if to_int_mod_ring ?x2 = 0 then 0 else 1) =\n  to_int_mod_ring (normalize ?x2)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. if x = 0 then 0 else 1)\n     normalize", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. if x = 0 then 0 else 1)\n     normalize", "by (intro rel_funI, auto simp: mod_ring_rel_def *[symmetric])"], ["proof (state)\nthis:\n  (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. if x = 0 then 0 else 1)\n   normalize\n\ngoal:\nNo subgoals!", "qed"], ["", "(* unit_factor *)"], ["", "lemma mod_ring_unit_factor[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel) (\\<lambda> x. x) unit_factor\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. x) unit_factor", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. x) unit_factor", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. x) unit_factor", "fix x :: \"'a mod_ring\""], ["proof (state)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. x) unit_factor", "have \"to_int_mod_ring x = to_int_mod_ring (unit_factor x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring x = to_int_mod_ring (unit_factor x)", "unfolding unit_factor_mod_ring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring x = to_int_mod_ring x", "by auto"], ["proof (state)\nthis:\n  to_int_mod_ring x = to_int_mod_ring (unit_factor x)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. x) unit_factor", "}"], ["proof (state)\nthis:\n  to_int_mod_ring ?x2 = to_int_mod_ring (unit_factor ?x2)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. x) unit_factor", "note * = this"], ["proof (state)\nthis:\n  to_int_mod_ring ?x2 = to_int_mod_ring (unit_factor ?x2)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. x) unit_factor", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. x) unit_factor", "by (intro rel_funI, auto simp: mod_ring_rel_def *[symmetric])"], ["proof (state)\nthis:\n  (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. x) unit_factor\n\ngoal:\nNo subgoals!", "qed"], ["", "(* inverse *)"], ["", "lemma mod_ring_inverse[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel) (inverse_p p) inverse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel) (inverse_p p) inverse", "proof (intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       mod_ring_rel x y \\<Longrightarrow>\n       mod_ring_rel (inverse_p p x) (inverse y)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       mod_ring_rel x y \\<Longrightarrow>\n       mod_ring_rel (inverse_p p x) (inverse y)", "assume [transfer_rule]: \"mod_ring_rel x y\""], ["proof (state)\nthis:\n  mod_ring_rel x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       mod_ring_rel x y \\<Longrightarrow>\n       mod_ring_rel (inverse_p p x) (inverse y)", "show \"mod_ring_rel (inverse_p p x) (inverse y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel (inverse_p p x) (inverse y)", "unfolding inverse_p_def inverse_mod_ring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel (if x = 0 then 0 else power_p p x (nat (p - 2)))\n     (if y = 0 then 0 else y ^ nat (int (CARD('a) - 2)))", "apply (transfer_prover_start)"], ["proof (prove)\ngoal (16 subgoals):\n 1. Transfer.Rel ?Rp17 ?an17 num.One\n 2. Transfer.Rel (?Rp17 ===> ?Ro17) ?am17 num.Bit0\n 3. Transfer.Rel (?Ro17 ===> ?Rm17) ?al17 numeral\n 4. Transfer.Rel ?Rn17 ?ak17 UNIV\n 5. Transfer.Rel (?Rn17 ===> ?Rl17) ?aj17 card\n 6. Transfer.Rel (?Rl17 ===> ?Rm17 ===> ?Rk17) ?ai17 (-)\n 7. Transfer.Rel (?Rk17 ===> ?Rj17) ?ah17 int\n 8. Transfer.Rel (?Rj17 ===> ?Ri17) ?ag17 nat\n 9. Transfer.Rel ?Rh17 ?af17 y\n 10. Transfer.Rel (?Rh17 ===> ?Ri17 ===> ?Rd17) ?ae17 (^)\nA total of 16 subgoals...", "apply (transfer_step)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x = 0 then 0 else power_p p x (nat (p - 2))) =\n    (if x = 0 then 0 else power_p p x (nat (int (CARD('a) - 2))))", "apply (unfold p2_ident)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x = 0 then 0 else power_p p x (nat (p - 2))) =\n    (if x = 0 then 0 else power_p p x (nat (p - 2)))", "apply (rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mod_ring_rel (inverse_p p x) (inverse y)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* division *)"], ["", "lemma mod_ring_divide[transfer_rule]: \"(mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel)\n  (divide_p p) (/)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (divide_p p) (/)", "unfolding divide_p_def[abs_def] divide_mod_ring_def[abs_def] inverse_mod_ring_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel)\n     (\\<lambda>x y. mult_p p x (inverse_p p y))\n     (\\<lambda>x y. x * inverse y)", "by transfer_prover"], ["", "lemma mod_ring_rel_unsafe: assumes \"x < CARD('a)\"\n  shows \"mod_ring_rel (int x) (of_nat x)\" \"0 < x \\<Longrightarrow> of_nat x \\<noteq> (0 :: 'a mod_ring)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel (int x) (of_nat x) &&&\n    (0 < x \\<Longrightarrow> of_nat x \\<noteq> 0)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_ring_rel (int x) (of_nat x)\n 2. 0 < x \\<Longrightarrow> of_nat x \\<noteq> 0", "have id: \"of_nat x = (of_int (int x) :: 'a mod_ring)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat x = of_int (int x)", "by simp"], ["proof (state)\nthis:\n  of_nat x = of_int (int x)\n\ngoal (2 subgoals):\n 1. mod_ring_rel (int x) (of_nat x)\n 2. 0 < x \\<Longrightarrow> of_nat x \\<noteq> 0", "show \"mod_ring_rel (int x) (of_nat x)\" \"0 < x \\<Longrightarrow> of_nat x \\<noteq> (0 :: 'a mod_ring)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel (int x) (of_nat x) &&&\n    (0 < x \\<Longrightarrow> of_nat x \\<noteq> 0)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel (int x) (of_int (int x)) &&&\n    (0 < x \\<Longrightarrow> of_int (int x) \\<noteq> 0)", "unfolding mod_ring_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. int x = to_int_mod_ring (of_int (int x)) &&&\n    (0 < x \\<Longrightarrow> of_int (int x) \\<noteq> 0)", "proof (auto simp add: assms of_int_of_int_mod_ring)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; of_int_mod_ring (int x) = 0\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"0 < x\""], ["proof (state)\nthis:\n  0 < x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; of_int_mod_ring (int x) = 0\\<rbrakk>\n    \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  x < CARD('a)\n  0 < x", "have \"of_int_mod_ring (int x) \\<noteq> (0 :: 'a mod_ring)\""], ["proof (prove)\nusing this:\n  x < CARD('a)\n  0 < x\n\ngoal (1 subgoal):\n 1. of_int_mod_ring (int x) \\<noteq> 0", "by (metis (no_types) less_imp_of_nat_less less_irrefl of_nat_0_le_iff of_nat_0_less_iff to_int_mod_ring_hom.hom_zero to_int_mod_ring_of_int_mod_ring)"], ["proof (state)\nthis:\n  of_int_mod_ring (int x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; of_int_mod_ring (int x) = 0\\<rbrakk>\n    \\<Longrightarrow> False", "thus \"of_int_mod_ring (int x) = (0 :: 'a mod_ring) \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  of_int_mod_ring (int x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_int_mod_ring (int x) = 0 \\<Longrightarrow> False", "by blast"], ["proof (state)\nthis:\n  of_int_mod_ring (int x) = 0 \\<Longrightarrow> False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_ring_rel (int x) (of_nat x)\n  0 < x \\<Longrightarrow> of_nat x \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_field_ops_int: \"field_ops (finite_field_ops_int p) mod_ring_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. field_ops (finite_field_ops_int p) mod_ring_rel", "by (unfold_locales, auto simp:\n  finite_field_ops_int_def\n  bi_unique_mod_ring_rel\n  right_total_mod_ring_rel\n  mod_ring_divide\n  mod_ring_plus\n  mod_ring_minus\n  mod_ring_uminus\n  mod_ring_inverse\n  mod_ring_mod\n  mod_ring_unit_factor\n  mod_ring_normalize\n  mod_ring_mult\n  mod_ring_eq\n  mod_ring_0\n  mod_ring_1\n  Domainp_mod_ring_rel)"], ["", "end"], ["", "text \\<open>Once we have proven the soundness of the implementation, we do not care any longer\n  that @{typ \"'a mod_ring\"} has been defined internally via lifting. Disabling the transfer-rules\n  will hide the internal definition in further applications of transfer.\\<close>"], ["", "lifting_forget mod_ring.lifting"], ["", "text \\<open>For soundness of the 32-bit implementation, we mainly prove that this implementation\n  implements the int-based implementation of the mod-ring.\\<close>"], ["", "context mod_ring_locale\nbegin"], ["", "context fixes pp :: \"uint32\" \n  assumes ppp: \"p = int_of_uint32 pp\" \n  and small: \"p \\<le> 65535\" \nbegin"], ["", "lemmas uint32_simps = \n  int_of_uint32_0\n  int_of_uint32_plus \n  int_of_uint32_minus\n  int_of_uint32_mult"], ["", "definition urel32 :: \"uint32 \\<Rightarrow> int \\<Rightarrow> bool\" where \"urel32 x y = (y = int_of_uint32 x \\<and> y < p)\""], ["", "definition mod_ring_rel32 :: \"uint32 \\<Rightarrow> 'a mod_ring \\<Rightarrow> bool\" where\n  \"mod_ring_rel32 x y = (\\<exists> z. urel32 x z \\<and> mod_ring_rel z y)\""], ["", "lemma urel32_0: \"urel32 0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 0 0", "unfolding urel32_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = int_of_uint32 0 \\<and> 0 < p", "using p2"], ["proof (prove)\nusing this:\n  2 \\<le> p\n\ngoal (1 subgoal):\n 1. 0 = int_of_uint32 0 \\<and> 0 < p", "by (simp, transfer, simp)"], ["", "lemma urel32_1: \"urel32 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 1 1", "unfolding urel32_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = int_of_uint32 1 \\<and> 1 < p", "using p2"], ["proof (prove)\nusing this:\n  2 \\<le> p\n\ngoal (1 subgoal):\n 1. 1 = int_of_uint32 1 \\<and> 1 < p", "by (simp, transfer, simp)"], ["", "lemma le_int_of_uint32: \"(x \\<le> y) = (int_of_uint32 x \\<le> int_of_uint32 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (int_of_uint32 x \\<le> int_of_uint32 y)", "by (transfer, simp add: word_le_def)"], ["", "lemma urel32_plus: assumes \"urel32 x y\" \"urel32 x' y'\"\n  shows \"urel32 (plus_p32 pp x x') (plus_p p y y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (plus_p32 pp x x') (plus_p p y y')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. urel32 (plus_p32 pp x x') (plus_p p y y')", "let ?x = \"int_of_uint32 x\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel32 (plus_p32 pp x x') (plus_p p y y')", "let ?x' = \"int_of_uint32 x'\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel32 (plus_p32 pp x x') (plus_p p y y')", "let ?p = \"int_of_uint32 pp\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel32 (plus_p32 pp x x') (plus_p p y y')", "from assms int_of_uint32_ge_0"], ["proof (chain)\npicking this:\n  urel32 x y\n  urel32 x' y'\n  0 \\<le> int_of_uint32 ?n", "have id: \"y = ?x\" \"y' = ?x'\" \n    and rel: \"0 \\<le> ?x\" \"?x < p\" \n      \"0 \\<le> ?x'\" \"?x' \\<le> p\""], ["proof (prove)\nusing this:\n  urel32 x y\n  urel32 x' y'\n  0 \\<le> int_of_uint32 ?n\n\ngoal (1 subgoal):\n 1. (y = int_of_uint32 x &&& y' = int_of_uint32 x') &&&\n    (0 \\<le> int_of_uint32 x &&& int_of_uint32 x < p) &&&\n    0 \\<le> int_of_uint32 x' &&& int_of_uint32 x' \\<le> p", "unfolding urel32_def"], ["proof (prove)\nusing this:\n  y = int_of_uint32 x \\<and> y < p\n  y' = int_of_uint32 x' \\<and> y' < p\n  0 \\<le> int_of_uint32 ?n\n\ngoal (1 subgoal):\n 1. (y = int_of_uint32 x &&& y' = int_of_uint32 x') &&&\n    (0 \\<le> int_of_uint32 x &&& int_of_uint32 x < p) &&&\n    0 \\<le> int_of_uint32 x' &&& int_of_uint32 x' \\<le> p", "by auto"], ["proof (state)\nthis:\n  y = int_of_uint32 x\n  y' = int_of_uint32 x'\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel32 (plus_p32 pp x x') (plus_p p y y')", "have le: \"(pp \\<le> x + x') = (?p \\<le> ?x + ?x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pp \\<le> x + x') =\n    (int_of_uint32 pp \\<le> int_of_uint32 x + int_of_uint32 x')", "unfolding le_int_of_uint32"], ["proof (prove)\ngoal (1 subgoal):\n 1. (int_of_uint32 pp \\<le> int_of_uint32 (x + x')) =\n    (int_of_uint32 pp \\<le> int_of_uint32 x + int_of_uint32 x')", "using rel small"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> p\n  p \\<le> 65535\n\ngoal (1 subgoal):\n 1. (int_of_uint32 pp \\<le> int_of_uint32 (x + x')) =\n    (int_of_uint32 pp \\<le> int_of_uint32 x + int_of_uint32 x')", "by (auto simp: uint32_simps)"], ["proof (state)\nthis:\n  (pp \\<le> x + x') =\n  (int_of_uint32 pp \\<le> int_of_uint32 x + int_of_uint32 x')\n\ngoal (1 subgoal):\n 1. urel32 (plus_p32 pp x x') (plus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (plus_p32 pp x x') (plus_p p y y')", "proof (cases \"?p \\<le> ?x + ?x'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. int_of_uint32 pp\n    \\<le> int_of_uint32 x + int_of_uint32 x' \\<Longrightarrow>\n    urel32 (plus_p32 pp x x') (plus_p p y y')\n 2. \\<not> int_of_uint32 pp\n           \\<le> int_of_uint32 x + int_of_uint32 x' \\<Longrightarrow>\n    urel32 (plus_p32 pp x x') (plus_p p y y')", "case True"], ["proof (state)\nthis:\n  int_of_uint32 pp \\<le> int_of_uint32 x + int_of_uint32 x'\n\ngoal (2 subgoals):\n 1. int_of_uint32 pp\n    \\<le> int_of_uint32 x + int_of_uint32 x' \\<Longrightarrow>\n    urel32 (plus_p32 pp x x') (plus_p p y y')\n 2. \\<not> int_of_uint32 pp\n           \\<le> int_of_uint32 x + int_of_uint32 x' \\<Longrightarrow>\n    urel32 (plus_p32 pp x x') (plus_p p y y')", "hence True: \"(?p \\<le> ?x + ?x') = True\""], ["proof (prove)\nusing this:\n  int_of_uint32 pp \\<le> int_of_uint32 x + int_of_uint32 x'\n\ngoal (1 subgoal):\n 1. (int_of_uint32 pp \\<le> int_of_uint32 x + int_of_uint32 x') = True", "by simp"], ["proof (state)\nthis:\n  (int_of_uint32 pp \\<le> int_of_uint32 x + int_of_uint32 x') = True\n\ngoal (2 subgoals):\n 1. int_of_uint32 pp\n    \\<le> int_of_uint32 x + int_of_uint32 x' \\<Longrightarrow>\n    urel32 (plus_p32 pp x x') (plus_p p y y')\n 2. \\<not> int_of_uint32 pp\n           \\<le> int_of_uint32 x + int_of_uint32 x' \\<Longrightarrow>\n    urel32 (plus_p32 pp x x') (plus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (plus_p32 pp x x') (plus_p p y y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (plus_p32 pp x x')\n     (plus_p p (int_of_uint32 x) (int_of_uint32 x'))", "using small rel"], ["proof (prove)\nusing this:\n  p \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel32 (plus_p32 pp x x')\n     (plus_p p (int_of_uint32 x) (int_of_uint32 x'))", "unfolding plus_p32_def plus_p_def Let_def urel32_def"], ["proof (prove)\nusing this:\n  p \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> p\n\ngoal (1 subgoal):\n 1. (if p \\<le> int_of_uint32 x + int_of_uint32 x'\n     then int_of_uint32 x + int_of_uint32 x' - p\n     else int_of_uint32 x + int_of_uint32 x') =\n    int_of_uint32 (if pp \\<le> x + x' then x + x' - pp else x + x') \\<and>\n    (if p \\<le> int_of_uint32 x + int_of_uint32 x'\n     then int_of_uint32 x + int_of_uint32 x' - p\n     else int_of_uint32 x + int_of_uint32 x')\n    < p", "unfolding ppp le True if_True"], ["proof (prove)\nusing this:\n  int_of_uint32 pp \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < int_of_uint32 pp\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> int_of_uint32 pp\n\ngoal (1 subgoal):\n 1. int_of_uint32 x + int_of_uint32 x' - int_of_uint32 pp =\n    int_of_uint32 (x + x' - pp) \\<and>\n    int_of_uint32 x + int_of_uint32 x' - int_of_uint32 pp < int_of_uint32 pp", "using True"], ["proof (prove)\nusing this:\n  int_of_uint32 pp \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < int_of_uint32 pp\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> int_of_uint32 pp\n  (int_of_uint32 pp \\<le> int_of_uint32 x + int_of_uint32 x') = True\n\ngoal (1 subgoal):\n 1. int_of_uint32 x + int_of_uint32 x' - int_of_uint32 pp =\n    int_of_uint32 (x + x' - pp) \\<and>\n    int_of_uint32 x + int_of_uint32 x' - int_of_uint32 pp < int_of_uint32 pp", "by (auto simp: uint32_simps)"], ["proof (state)\nthis:\n  urel32 (plus_p32 pp x x') (plus_p p y y')\n\ngoal (1 subgoal):\n 1. \\<not> int_of_uint32 pp\n           \\<le> int_of_uint32 x + int_of_uint32 x' \\<Longrightarrow>\n    urel32 (plus_p32 pp x x') (plus_p p y y')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> int_of_uint32 pp\n           \\<le> int_of_uint32 x + int_of_uint32 x' \\<Longrightarrow>\n    urel32 (plus_p32 pp x x') (plus_p p y y')", "case False"], ["proof (state)\nthis:\n  \\<not> int_of_uint32 pp \\<le> int_of_uint32 x + int_of_uint32 x'\n\ngoal (1 subgoal):\n 1. \\<not> int_of_uint32 pp\n           \\<le> int_of_uint32 x + int_of_uint32 x' \\<Longrightarrow>\n    urel32 (plus_p32 pp x x') (plus_p p y y')", "hence False: \"(?p \\<le> ?x + ?x') = False\""], ["proof (prove)\nusing this:\n  \\<not> int_of_uint32 pp \\<le> int_of_uint32 x + int_of_uint32 x'\n\ngoal (1 subgoal):\n 1. (int_of_uint32 pp \\<le> int_of_uint32 x + int_of_uint32 x') = False", "by simp"], ["proof (state)\nthis:\n  (int_of_uint32 pp \\<le> int_of_uint32 x + int_of_uint32 x') = False\n\ngoal (1 subgoal):\n 1. \\<not> int_of_uint32 pp\n           \\<le> int_of_uint32 x + int_of_uint32 x' \\<Longrightarrow>\n    urel32 (plus_p32 pp x x') (plus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (plus_p32 pp x x') (plus_p p y y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (plus_p32 pp x x')\n     (plus_p p (int_of_uint32 x) (int_of_uint32 x'))", "using small rel"], ["proof (prove)\nusing this:\n  p \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel32 (plus_p32 pp x x')\n     (plus_p p (int_of_uint32 x) (int_of_uint32 x'))", "unfolding plus_p32_def plus_p_def Let_def urel32_def"], ["proof (prove)\nusing this:\n  p \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> p\n\ngoal (1 subgoal):\n 1. (if p \\<le> int_of_uint32 x + int_of_uint32 x'\n     then int_of_uint32 x + int_of_uint32 x' - p\n     else int_of_uint32 x + int_of_uint32 x') =\n    int_of_uint32 (if pp \\<le> x + x' then x + x' - pp else x + x') \\<and>\n    (if p \\<le> int_of_uint32 x + int_of_uint32 x'\n     then int_of_uint32 x + int_of_uint32 x' - p\n     else int_of_uint32 x + int_of_uint32 x')\n    < p", "unfolding ppp le False if_False"], ["proof (prove)\nusing this:\n  int_of_uint32 pp \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < int_of_uint32 pp\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> int_of_uint32 pp\n\ngoal (1 subgoal):\n 1. int_of_uint32 x + int_of_uint32 x' = int_of_uint32 (x + x') \\<and>\n    int_of_uint32 x + int_of_uint32 x' < int_of_uint32 pp", "using False"], ["proof (prove)\nusing this:\n  int_of_uint32 pp \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < int_of_uint32 pp\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> int_of_uint32 pp\n  (int_of_uint32 pp \\<le> int_of_uint32 x + int_of_uint32 x') = False\n\ngoal (1 subgoal):\n 1. int_of_uint32 x + int_of_uint32 x' = int_of_uint32 (x + x') \\<and>\n    int_of_uint32 x + int_of_uint32 x' < int_of_uint32 pp", "by (auto simp: uint32_simps)"], ["proof (state)\nthis:\n  urel32 (plus_p32 pp x x') (plus_p p y y')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  urel32 (plus_p32 pp x x') (plus_p p y y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel32_minus: assumes \"urel32 x y\" \"urel32 x' y'\"\n  shows \"urel32 (minus_p32 pp x x') (minus_p p y y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (minus_p32 pp x x') (minus_p p y y')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. urel32 (minus_p32 pp x x') (minus_p p y y')", "let ?x = \"int_of_uint32 x\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel32 (minus_p32 pp x x') (minus_p p y y')", "let ?x' = \"int_of_uint32 x'\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel32 (minus_p32 pp x x') (minus_p p y y')", "from assms int_of_uint32_ge_0"], ["proof (chain)\npicking this:\n  urel32 x y\n  urel32 x' y'\n  0 \\<le> int_of_uint32 ?n", "have id: \"y = ?x\" \"y' = ?x'\" \n    and rel: \"0 \\<le> ?x\" \"?x < p\" \n      \"0 \\<le> ?x'\" \"?x' \\<le> p\""], ["proof (prove)\nusing this:\n  urel32 x y\n  urel32 x' y'\n  0 \\<le> int_of_uint32 ?n\n\ngoal (1 subgoal):\n 1. (y = int_of_uint32 x &&& y' = int_of_uint32 x') &&&\n    (0 \\<le> int_of_uint32 x &&& int_of_uint32 x < p) &&&\n    0 \\<le> int_of_uint32 x' &&& int_of_uint32 x' \\<le> p", "unfolding urel32_def"], ["proof (prove)\nusing this:\n  y = int_of_uint32 x \\<and> y < p\n  y' = int_of_uint32 x' \\<and> y' < p\n  0 \\<le> int_of_uint32 ?n\n\ngoal (1 subgoal):\n 1. (y = int_of_uint32 x &&& y' = int_of_uint32 x') &&&\n    (0 \\<le> int_of_uint32 x &&& int_of_uint32 x < p) &&&\n    0 \\<le> int_of_uint32 x' &&& int_of_uint32 x' \\<le> p", "by auto"], ["proof (state)\nthis:\n  y = int_of_uint32 x\n  y' = int_of_uint32 x'\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel32 (minus_p32 pp x x') (minus_p p y y')", "have le: \"(x' \\<le> x) = (?x' \\<le> ?x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x' \\<le> x) = (int_of_uint32 x' \\<le> int_of_uint32 x)", "unfolding le_int_of_uint32"], ["proof (prove)\ngoal (1 subgoal):\n 1. (int_of_uint32 x' \\<le> int_of_uint32 x) =\n    (int_of_uint32 x' \\<le> int_of_uint32 x)", "using rel small"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> p\n  p \\<le> 65535\n\ngoal (1 subgoal):\n 1. (int_of_uint32 x' \\<le> int_of_uint32 x) =\n    (int_of_uint32 x' \\<le> int_of_uint32 x)", "by (auto simp: uint32_simps)"], ["proof (state)\nthis:\n  (x' \\<le> x) = (int_of_uint32 x' \\<le> int_of_uint32 x)\n\ngoal (1 subgoal):\n 1. urel32 (minus_p32 pp x x') (minus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (minus_p32 pp x x') (minus_p p y y')", "proof (cases \"?x' \\<le> ?x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. int_of_uint32 x' \\<le> int_of_uint32 x \\<Longrightarrow>\n    urel32 (minus_p32 pp x x') (minus_p p y y')\n 2. \\<not> int_of_uint32 x' \\<le> int_of_uint32 x \\<Longrightarrow>\n    urel32 (minus_p32 pp x x') (minus_p p y y')", "case True"], ["proof (state)\nthis:\n  int_of_uint32 x' \\<le> int_of_uint32 x\n\ngoal (2 subgoals):\n 1. int_of_uint32 x' \\<le> int_of_uint32 x \\<Longrightarrow>\n    urel32 (minus_p32 pp x x') (minus_p p y y')\n 2. \\<not> int_of_uint32 x' \\<le> int_of_uint32 x \\<Longrightarrow>\n    urel32 (minus_p32 pp x x') (minus_p p y y')", "hence True: \"(?x' \\<le> ?x) = True\""], ["proof (prove)\nusing this:\n  int_of_uint32 x' \\<le> int_of_uint32 x\n\ngoal (1 subgoal):\n 1. (int_of_uint32 x' \\<le> int_of_uint32 x) = True", "by simp"], ["proof (state)\nthis:\n  (int_of_uint32 x' \\<le> int_of_uint32 x) = True\n\ngoal (2 subgoals):\n 1. int_of_uint32 x' \\<le> int_of_uint32 x \\<Longrightarrow>\n    urel32 (minus_p32 pp x x') (minus_p p y y')\n 2. \\<not> int_of_uint32 x' \\<le> int_of_uint32 x \\<Longrightarrow>\n    urel32 (minus_p32 pp x x') (minus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (minus_p32 pp x x') (minus_p p y y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (minus_p32 pp x x')\n     (minus_p p (int_of_uint32 x) (int_of_uint32 x'))", "using small rel"], ["proof (prove)\nusing this:\n  p \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel32 (minus_p32 pp x x')\n     (minus_p p (int_of_uint32 x) (int_of_uint32 x'))", "unfolding minus_p32_def minus_p_def Let_def urel32_def"], ["proof (prove)\nusing this:\n  p \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> p\n\ngoal (1 subgoal):\n 1. (if int_of_uint32 x' \\<le> int_of_uint32 x\n     then int_of_uint32 x - int_of_uint32 x'\n     else int_of_uint32 x + p - int_of_uint32 x') =\n    int_of_uint32 (if x' \\<le> x then x - x' else x + pp - x') \\<and>\n    (if int_of_uint32 x' \\<le> int_of_uint32 x\n     then int_of_uint32 x - int_of_uint32 x'\n     else int_of_uint32 x + p - int_of_uint32 x')\n    < p", "unfolding ppp le True if_True"], ["proof (prove)\nusing this:\n  int_of_uint32 pp \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < int_of_uint32 pp\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> int_of_uint32 pp\n\ngoal (1 subgoal):\n 1. int_of_uint32 x - int_of_uint32 x' = int_of_uint32 (x - x') \\<and>\n    int_of_uint32 x - int_of_uint32 x' < int_of_uint32 pp", "using True"], ["proof (prove)\nusing this:\n  int_of_uint32 pp \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < int_of_uint32 pp\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> int_of_uint32 pp\n  (int_of_uint32 x' \\<le> int_of_uint32 x) = True\n\ngoal (1 subgoal):\n 1. int_of_uint32 x - int_of_uint32 x' = int_of_uint32 (x - x') \\<and>\n    int_of_uint32 x - int_of_uint32 x' < int_of_uint32 pp", "by (auto simp: uint32_simps)"], ["proof (state)\nthis:\n  urel32 (minus_p32 pp x x') (minus_p p y y')\n\ngoal (1 subgoal):\n 1. \\<not> int_of_uint32 x' \\<le> int_of_uint32 x \\<Longrightarrow>\n    urel32 (minus_p32 pp x x') (minus_p p y y')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> int_of_uint32 x' \\<le> int_of_uint32 x \\<Longrightarrow>\n    urel32 (minus_p32 pp x x') (minus_p p y y')", "case False"], ["proof (state)\nthis:\n  \\<not> int_of_uint32 x' \\<le> int_of_uint32 x\n\ngoal (1 subgoal):\n 1. \\<not> int_of_uint32 x' \\<le> int_of_uint32 x \\<Longrightarrow>\n    urel32 (minus_p32 pp x x') (minus_p p y y')", "hence False: \"(?x' \\<le> ?x) = False\""], ["proof (prove)\nusing this:\n  \\<not> int_of_uint32 x' \\<le> int_of_uint32 x\n\ngoal (1 subgoal):\n 1. (int_of_uint32 x' \\<le> int_of_uint32 x) = False", "by simp"], ["proof (state)\nthis:\n  (int_of_uint32 x' \\<le> int_of_uint32 x) = False\n\ngoal (1 subgoal):\n 1. \\<not> int_of_uint32 x' \\<le> int_of_uint32 x \\<Longrightarrow>\n    urel32 (minus_p32 pp x x') (minus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (minus_p32 pp x x') (minus_p p y y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (minus_p32 pp x x')\n     (minus_p p (int_of_uint32 x) (int_of_uint32 x'))", "using small rel"], ["proof (prove)\nusing this:\n  p \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel32 (minus_p32 pp x x')\n     (minus_p p (int_of_uint32 x) (int_of_uint32 x'))", "unfolding minus_p32_def minus_p_def Let_def urel32_def"], ["proof (prove)\nusing this:\n  p \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> p\n\ngoal (1 subgoal):\n 1. (if int_of_uint32 x' \\<le> int_of_uint32 x\n     then int_of_uint32 x - int_of_uint32 x'\n     else int_of_uint32 x + p - int_of_uint32 x') =\n    int_of_uint32 (if x' \\<le> x then x - x' else x + pp - x') \\<and>\n    (if int_of_uint32 x' \\<le> int_of_uint32 x\n     then int_of_uint32 x - int_of_uint32 x'\n     else int_of_uint32 x + p - int_of_uint32 x')\n    < p", "unfolding ppp le False if_False"], ["proof (prove)\nusing this:\n  int_of_uint32 pp \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < int_of_uint32 pp\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> int_of_uint32 pp\n\ngoal (1 subgoal):\n 1. int_of_uint32 x + int_of_uint32 pp - int_of_uint32 x' =\n    int_of_uint32 (x + pp - x') \\<and>\n    int_of_uint32 x + int_of_uint32 pp - int_of_uint32 x' < int_of_uint32 pp", "using False"], ["proof (prove)\nusing this:\n  int_of_uint32 pp \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < int_of_uint32 pp\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' \\<le> int_of_uint32 pp\n  (int_of_uint32 x' \\<le> int_of_uint32 x) = False\n\ngoal (1 subgoal):\n 1. int_of_uint32 x + int_of_uint32 pp - int_of_uint32 x' =\n    int_of_uint32 (x + pp - x') \\<and>\n    int_of_uint32 x + int_of_uint32 pp - int_of_uint32 x' < int_of_uint32 pp", "by (auto simp: uint32_simps)"], ["proof (state)\nthis:\n  urel32 (minus_p32 pp x x') (minus_p p y y')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  urel32 (minus_p32 pp x x') (minus_p p y y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel32_uminus: assumes \"urel32 x y\"\n  shows \"urel32 (uminus_p32 pp x) (uminus_p p y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (uminus_p32 pp x) (uminus_p p y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. urel32 (uminus_p32 pp x) (uminus_p p y)", "let ?x = \"int_of_uint32 x\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel32 (uminus_p32 pp x) (uminus_p p y)", "from assms int_of_uint32_ge_0"], ["proof (chain)\npicking this:\n  urel32 x y\n  0 \\<le> int_of_uint32 ?n", "have id: \"y = ?x\" \n    and rel: \"0 \\<le> ?x\" \"?x < p\""], ["proof (prove)\nusing this:\n  urel32 x y\n  0 \\<le> int_of_uint32 ?n\n\ngoal (1 subgoal):\n 1. y = int_of_uint32 x &&& 0 \\<le> int_of_uint32 x &&& int_of_uint32 x < p", "unfolding urel32_def"], ["proof (prove)\nusing this:\n  y = int_of_uint32 x \\<and> y < p\n  0 \\<le> int_of_uint32 ?n\n\ngoal (1 subgoal):\n 1. y = int_of_uint32 x &&& 0 \\<le> int_of_uint32 x &&& int_of_uint32 x < p", "by auto"], ["proof (state)\nthis:\n  y = int_of_uint32 x\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n\ngoal (1 subgoal):\n 1. urel32 (uminus_p32 pp x) (uminus_p p y)", "have le: \"(x = 0) = (?x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = 0) = (int_of_uint32 x = 0)", "unfolding int_of_uint32_0_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = 0) = (x = 0)", "using rel small"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  p \\<le> 65535\n\ngoal (1 subgoal):\n 1. (x = 0) = (x = 0)", "by (auto simp: uint32_simps)"], ["proof (state)\nthis:\n  (x = 0) = (int_of_uint32 x = 0)\n\ngoal (1 subgoal):\n 1. urel32 (uminus_p32 pp x) (uminus_p p y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (uminus_p32 pp x) (uminus_p p y)", "proof (cases \"?x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. int_of_uint32 x = 0 \\<Longrightarrow>\n    urel32 (uminus_p32 pp x) (uminus_p p y)\n 2. int_of_uint32 x \\<noteq> 0 \\<Longrightarrow>\n    urel32 (uminus_p32 pp x) (uminus_p p y)", "case True"], ["proof (state)\nthis:\n  int_of_uint32 x = 0\n\ngoal (2 subgoals):\n 1. int_of_uint32 x = 0 \\<Longrightarrow>\n    urel32 (uminus_p32 pp x) (uminus_p p y)\n 2. int_of_uint32 x \\<noteq> 0 \\<Longrightarrow>\n    urel32 (uminus_p32 pp x) (uminus_p p y)", "hence True: \"(?x = 0) = True\""], ["proof (prove)\nusing this:\n  int_of_uint32 x = 0\n\ngoal (1 subgoal):\n 1. (int_of_uint32 x = 0) = True", "by simp"], ["proof (state)\nthis:\n  (int_of_uint32 x = 0) = True\n\ngoal (2 subgoals):\n 1. int_of_uint32 x = 0 \\<Longrightarrow>\n    urel32 (uminus_p32 pp x) (uminus_p p y)\n 2. int_of_uint32 x \\<noteq> 0 \\<Longrightarrow>\n    urel32 (uminus_p32 pp x) (uminus_p p y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (uminus_p32 pp x) (uminus_p p y)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (uminus_p32 pp x) (uminus_p p (int_of_uint32 x))", "using small rel"], ["proof (prove)\nusing this:\n  p \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n\ngoal (1 subgoal):\n 1. urel32 (uminus_p32 pp x) (uminus_p p (int_of_uint32 x))", "unfolding uminus_p32_def uminus_p_def Let_def urel32_def"], ["proof (prove)\nusing this:\n  p \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n\ngoal (1 subgoal):\n 1. (if int_of_uint32 x = 0 then 0 else p - int_of_uint32 x) =\n    int_of_uint32 (if x = 0 then 0 else pp - x) \\<and>\n    (if int_of_uint32 x = 0 then 0 else p - int_of_uint32 x) < p", "unfolding ppp le True if_True"], ["proof (prove)\nusing this:\n  int_of_uint32 pp \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < int_of_uint32 pp\n\ngoal (1 subgoal):\n 1. 0 = int_of_uint32 0 \\<and> 0 < int_of_uint32 pp", "using True"], ["proof (prove)\nusing this:\n  int_of_uint32 pp \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < int_of_uint32 pp\n  (int_of_uint32 x = 0) = True\n\ngoal (1 subgoal):\n 1. 0 = int_of_uint32 0 \\<and> 0 < int_of_uint32 pp", "by (auto simp: uint32_simps)"], ["proof (state)\nthis:\n  urel32 (uminus_p32 pp x) (uminus_p p y)\n\ngoal (1 subgoal):\n 1. int_of_uint32 x \\<noteq> 0 \\<Longrightarrow>\n    urel32 (uminus_p32 pp x) (uminus_p p y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. int_of_uint32 x \\<noteq> 0 \\<Longrightarrow>\n    urel32 (uminus_p32 pp x) (uminus_p p y)", "case False"], ["proof (state)\nthis:\n  int_of_uint32 x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int_of_uint32 x \\<noteq> 0 \\<Longrightarrow>\n    urel32 (uminus_p32 pp x) (uminus_p p y)", "hence False: \"(?x = 0) = False\""], ["proof (prove)\nusing this:\n  int_of_uint32 x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (int_of_uint32 x = 0) = False", "by simp"], ["proof (state)\nthis:\n  (int_of_uint32 x = 0) = False\n\ngoal (1 subgoal):\n 1. int_of_uint32 x \\<noteq> 0 \\<Longrightarrow>\n    urel32 (uminus_p32 pp x) (uminus_p p y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (uminus_p32 pp x) (uminus_p p y)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (uminus_p32 pp x) (uminus_p p (int_of_uint32 x))", "using small rel"], ["proof (prove)\nusing this:\n  p \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n\ngoal (1 subgoal):\n 1. urel32 (uminus_p32 pp x) (uminus_p p (int_of_uint32 x))", "unfolding uminus_p32_def uminus_p_def Let_def urel32_def"], ["proof (prove)\nusing this:\n  p \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n\ngoal (1 subgoal):\n 1. (if int_of_uint32 x = 0 then 0 else p - int_of_uint32 x) =\n    int_of_uint32 (if x = 0 then 0 else pp - x) \\<and>\n    (if int_of_uint32 x = 0 then 0 else p - int_of_uint32 x) < p", "unfolding ppp le False if_False"], ["proof (prove)\nusing this:\n  int_of_uint32 pp \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < int_of_uint32 pp\n\ngoal (1 subgoal):\n 1. int_of_uint32 pp - int_of_uint32 x = int_of_uint32 (pp - x) \\<and>\n    int_of_uint32 pp - int_of_uint32 x < int_of_uint32 pp", "using False"], ["proof (prove)\nusing this:\n  int_of_uint32 pp \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < int_of_uint32 pp\n  (int_of_uint32 x = 0) = False\n\ngoal (1 subgoal):\n 1. int_of_uint32 pp - int_of_uint32 x = int_of_uint32 (pp - x) \\<and>\n    int_of_uint32 pp - int_of_uint32 x < int_of_uint32 pp", "by (auto simp: uint32_simps)"], ["proof (state)\nthis:\n  urel32 (uminus_p32 pp x) (uminus_p p y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  urel32 (uminus_p32 pp x) (uminus_p p y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel32_mult: assumes \"urel32 x y\" \"urel32 x' y'\"\n  shows \"urel32 (mult_p32 pp x x') (mult_p p y y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (mult_p32 pp x x') (mult_p p y y')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. urel32 (mult_p32 pp x x') (mult_p p y y')", "let ?x = \"int_of_uint32 x\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel32 (mult_p32 pp x x') (mult_p p y y')", "let ?x' = \"int_of_uint32 x'\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel32 (mult_p32 pp x x') (mult_p p y y')", "from assms int_of_uint32_ge_0"], ["proof (chain)\npicking this:\n  urel32 x y\n  urel32 x' y'\n  0 \\<le> int_of_uint32 ?n", "have id: \"y = ?x\" \"y' = ?x'\" \n    and rel: \"0 \\<le> ?x\" \"?x < p\" \n      \"0 \\<le> ?x'\" \"?x' < p\""], ["proof (prove)\nusing this:\n  urel32 x y\n  urel32 x' y'\n  0 \\<le> int_of_uint32 ?n\n\ngoal (1 subgoal):\n 1. (y = int_of_uint32 x &&& y' = int_of_uint32 x') &&&\n    (0 \\<le> int_of_uint32 x &&& int_of_uint32 x < p) &&&\n    0 \\<le> int_of_uint32 x' &&& int_of_uint32 x' < p", "unfolding urel32_def"], ["proof (prove)\nusing this:\n  y = int_of_uint32 x \\<and> y < p\n  y' = int_of_uint32 x' \\<and> y' < p\n  0 \\<le> int_of_uint32 ?n\n\ngoal (1 subgoal):\n 1. (y = int_of_uint32 x &&& y' = int_of_uint32 x') &&&\n    (0 \\<le> int_of_uint32 x &&& int_of_uint32 x < p) &&&\n    0 \\<le> int_of_uint32 x' &&& int_of_uint32 x' < p", "by auto"], ["proof (state)\nthis:\n  y = int_of_uint32 x\n  y' = int_of_uint32 x'\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' < p\n\ngoal (1 subgoal):\n 1. urel32 (mult_p32 pp x x') (mult_p p y y')", "from rel"], ["proof (chain)\npicking this:\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' < p", "have \"?x * ?x' < p * p\""], ["proof (prove)\nusing this:\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' < p\n\ngoal (1 subgoal):\n 1. int_of_uint32 x * int_of_uint32 x' < p * p", "by (metis mult_strict_mono')"], ["proof (state)\nthis:\n  int_of_uint32 x * int_of_uint32 x' < p * p\n\ngoal (1 subgoal):\n 1. urel32 (mult_p32 pp x x') (mult_p p y y')", "also"], ["proof (state)\nthis:\n  int_of_uint32 x * int_of_uint32 x' < p * p\n\ngoal (1 subgoal):\n 1. urel32 (mult_p32 pp x x') (mult_p p y y')", "have \"\\<dots> \\<le> 65536 * 65536\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * p \\<le> 65536 * 65536", "by (rule mult_mono, insert p2 small, auto)"], ["proof (state)\nthis:\n  p * p \\<le> 65536 * 65536\n\ngoal (1 subgoal):\n 1. urel32 (mult_p32 pp x x') (mult_p p y y')", "finally"], ["proof (chain)\npicking this:\n  int_of_uint32 x * int_of_uint32 x' < 65536 * 65536", "have le: \"?x * ?x' < 4294967296\""], ["proof (prove)\nusing this:\n  int_of_uint32 x * int_of_uint32 x' < 65536 * 65536\n\ngoal (1 subgoal):\n 1. int_of_uint32 x * int_of_uint32 x' < 4294967296", "by simp"], ["proof (state)\nthis:\n  int_of_uint32 x * int_of_uint32 x' < 4294967296\n\ngoal (1 subgoal):\n 1. urel32 (mult_p32 pp x x') (mult_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (mult_p32 pp x x') (mult_p p y y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (mult_p32 pp x x')\n     (mult_p p (int_of_uint32 x) (int_of_uint32 x'))", "using small rel"], ["proof (prove)\nusing this:\n  p \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' < p\n\ngoal (1 subgoal):\n 1. urel32 (mult_p32 pp x x')\n     (mult_p p (int_of_uint32 x) (int_of_uint32 x'))", "unfolding mult_p32_def mult_p_def Let_def urel32_def"], ["proof (prove)\nusing this:\n  p \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < p\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' < p\n\ngoal (1 subgoal):\n 1. mod_nonneg_pos_int (int_of_uint32 x * int_of_uint32 x') p =\n    int_of_uint32 (x * x' mod pp) \\<and>\n    mod_nonneg_pos_int (int_of_uint32 x * int_of_uint32 x') p < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  int_of_uint32 pp \\<le> 65535\n  0 \\<le> int_of_uint32 x\n  int_of_uint32 x < int_of_uint32 pp\n  0 \\<le> int_of_uint32 x'\n  int_of_uint32 x' < int_of_uint32 pp\n\ngoal (1 subgoal):\n 1. mod_nonneg_pos_int (int_of_uint32 x * int_of_uint32 x')\n     (int_of_uint32 pp) =\n    int_of_uint32 (x * x' mod pp) \\<and>\n    mod_nonneg_pos_int (int_of_uint32 x * int_of_uint32 x')\n     (int_of_uint32 pp)\n    < int_of_uint32 pp", "by (auto simp: uint32_simps, unfold int_of_uint32_mod int_of_uint32_mult, \n        subst mod_pos_pos_trivial[of _ 4294967296], insert le, auto)"], ["proof (state)\nthis:\n  urel32 (mult_p32 pp x x') (mult_p p y y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel32_eq: assumes \"urel32 x y\" \"urel32 x' y'\" \n  shows \"(x = x') = (y = y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "let ?x = \"int_of_uint32 x\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "let ?x' = \"int_of_uint32 x'\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "from assms int_of_uint32_ge_0"], ["proof (chain)\npicking this:\n  urel32 x y\n  urel32 x' y'\n  0 \\<le> int_of_uint32 ?n", "have id: \"y = ?x\" \"y' = ?x'\""], ["proof (prove)\nusing this:\n  urel32 x y\n  urel32 x' y'\n  0 \\<le> int_of_uint32 ?n\n\ngoal (1 subgoal):\n 1. y = int_of_uint32 x &&& y' = int_of_uint32 x'", "unfolding urel32_def"], ["proof (prove)\nusing this:\n  y = int_of_uint32 x \\<and> y < p\n  y' = int_of_uint32 x' \\<and> y' < p\n  0 \\<le> int_of_uint32 ?n\n\ngoal (1 subgoal):\n 1. y = int_of_uint32 x &&& y' = int_of_uint32 x'", "by auto"], ["proof (state)\nthis:\n  y = int_of_uint32 x\n  y' = int_of_uint32 x'\n\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = x') = (int_of_uint32 x = int_of_uint32 x')", "by (transfer, transfer) rule"], ["proof (state)\nthis:\n  (x = x') = (y = y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel32_normalize: \nassumes x: \"urel32 x y\"\nshows \"urel32 (if x = 0 then 0 else 1) (if y = 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (if x = 0 then 0 else 1) (if y = 0 then 0 else 1)", "unfolding urel32_eq[OF x urel32_0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (if y = 0 then 0 else 1) (if y = 0 then 0 else 1)", "using urel32_0 urel32_1"], ["proof (prove)\nusing this:\n  urel32 0 0\n  urel32 1 1\n\ngoal (1 subgoal):\n 1. urel32 (if y = 0 then 0 else 1) (if y = 0 then 0 else 1)", "by auto"], ["", "lemma urel32_mod: \nassumes x: \"urel32 x x'\" and y: \"urel32 y y'\" \nshows \"urel32 (if y = 0 then x else 0) (if y' = 0 then x' else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (if y = 0 then x else 0) (if y' = 0 then x' else 0)", "unfolding urel32_eq[OF y urel32_0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (if y' = 0 then x else 0) (if y' = 0 then x' else 0)", "using urel32_0 x"], ["proof (prove)\nusing this:\n  urel32 0 0\n  urel32 x x'\n\ngoal (1 subgoal):\n 1. urel32 (if y' = 0 then x else 0) (if y' = 0 then x' else 0)", "by auto"], ["", "lemma urel32_power: \"urel32 x x' \\<Longrightarrow> urel32 y (int y') \\<Longrightarrow> urel32 (power_p32 pp x y) (power_p p x' y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>urel32 x x'; urel32 y (int y')\\<rbrakk>\n    \\<Longrightarrow> urel32 (power_p32 pp x y) (power_p p x' y')", "proof (induct x' y' arbitrary: x y rule: power_p.induct[of _ p])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x n xa y.\n       \\<lbrakk>\\<And>xa xb y xc ya.\n                   \\<lbrakk>n \\<noteq> 0; xa = divmod_nat n 2; (xb, y) = xa;\n                    urel32 xc (mult_p p x x); urel32 ya (int xb)\\<rbrakk>\n                   \\<Longrightarrow> urel32 (power_p32 pp xc ya)\n(power_p p (mult_p p x x) xb);\n        urel32 xa x; urel32 y (int n)\\<rbrakk>\n       \\<Longrightarrow> urel32 (power_p32 pp xa y) (power_p p x n)", "case (1 x' y' x y)"], ["proof (state)\nthis:\n  \\<lbrakk>y' \\<noteq> 0; ?xa = divmod_nat y' 2; (?xb, ?y) = ?xa;\n   urel32 ?x (mult_p p x' x'); urel32 ?ya (int ?xb)\\<rbrakk>\n  \\<Longrightarrow> urel32 (power_p32 pp ?x ?ya)\n                     (power_p p (mult_p p x' x') ?xb)\n  urel32 x x'\n  urel32 y (int y')\n\ngoal (1 subgoal):\n 1. \\<And>x n xa y.\n       \\<lbrakk>\\<And>xa xb y xc ya.\n                   \\<lbrakk>n \\<noteq> 0; xa = divmod_nat n 2; (xb, y) = xa;\n                    urel32 xc (mult_p p x x); urel32 ya (int xb)\\<rbrakk>\n                   \\<Longrightarrow> urel32 (power_p32 pp xc ya)\n(power_p p (mult_p p x x) xb);\n        urel32 xa x; urel32 y (int n)\\<rbrakk>\n       \\<Longrightarrow> urel32 (power_p32 pp xa y) (power_p p x n)", "note x = 1(2)"], ["proof (state)\nthis:\n  urel32 x x'\n\ngoal (1 subgoal):\n 1. \\<And>x n xa y.\n       \\<lbrakk>\\<And>xa xb y xc ya.\n                   \\<lbrakk>n \\<noteq> 0; xa = divmod_nat n 2; (xb, y) = xa;\n                    urel32 xc (mult_p p x x); urel32 ya (int xb)\\<rbrakk>\n                   \\<Longrightarrow> urel32 (power_p32 pp xc ya)\n(power_p p (mult_p p x x) xb);\n        urel32 xa x; urel32 y (int n)\\<rbrakk>\n       \\<Longrightarrow> urel32 (power_p32 pp xa y) (power_p p x n)", "note y = 1(3)"], ["proof (state)\nthis:\n  urel32 y (int y')\n\ngoal (1 subgoal):\n 1. \\<And>x n xa y.\n       \\<lbrakk>\\<And>xa xb y xc ya.\n                   \\<lbrakk>n \\<noteq> 0; xa = divmod_nat n 2; (xb, y) = xa;\n                    urel32 xc (mult_p p x x); urel32 ya (int xb)\\<rbrakk>\n                   \\<Longrightarrow> urel32 (power_p32 pp xc ya)\n(power_p p (mult_p p x x) xb);\n        urel32 xa x; urel32 y (int n)\\<rbrakk>\n       \\<Longrightarrow> urel32 (power_p32 pp xa y) (power_p p x n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (power_p32 pp x y) (power_p p x' y')", "proof (cases \"y' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y' = 0 \\<Longrightarrow> urel32 (power_p32 pp x y) (power_p p x' y')\n 2. y' \\<noteq> 0 \\<Longrightarrow>\n    urel32 (power_p32 pp x y) (power_p p x' y')", "case True"], ["proof (state)\nthis:\n  y' = 0\n\ngoal (2 subgoals):\n 1. y' = 0 \\<Longrightarrow> urel32 (power_p32 pp x y) (power_p p x' y')\n 2. y' \\<noteq> 0 \\<Longrightarrow>\n    urel32 (power_p32 pp x y) (power_p p x' y')", "hence y: \"y = 0\""], ["proof (prove)\nusing this:\n  y' = 0\n\ngoal (1 subgoal):\n 1. y = 0", "using urel32_eq[OF y urel32_0]"], ["proof (prove)\nusing this:\n  y' = 0\n  (y = 0) = (int y' = 0)\n\ngoal (1 subgoal):\n 1. y = 0", "by auto"], ["proof (state)\nthis:\n  y = 0\n\ngoal (2 subgoals):\n 1. y' = 0 \\<Longrightarrow> urel32 (power_p32 pp x y) (power_p p x' y')\n 2. y' \\<noteq> 0 \\<Longrightarrow>\n    urel32 (power_p32 pp x y) (power_p p x' y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (power_p32 pp x y) (power_p p x' y')", "unfolding y True"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (power_p32 pp x 0) (power_p p x' 0)", "by (simp add: power_p.simps urel32_1)"], ["proof (state)\nthis:\n  urel32 (power_p32 pp x y) (power_p p x' y')\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel32 (power_p32 pp x y) (power_p p x' y')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel32 (power_p32 pp x y) (power_p p x' y')", "case False"], ["proof (state)\nthis:\n  y' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel32 (power_p32 pp x y) (power_p p x' y')", "hence id: \"(y = 0) = False\" \"(y' = 0) = False\""], ["proof (prove)\nusing this:\n  y' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (y = 0) = False &&& (y' = 0) = False", "using urel32_eq[OF y urel32_0]"], ["proof (prove)\nusing this:\n  y' \\<noteq> 0\n  (y = 0) = (int y' = 0)\n\ngoal (1 subgoal):\n 1. (y = 0) = False &&& (y' = 0) = False", "by auto"], ["proof (state)\nthis:\n  (y = 0) = False\n  (y' = 0) = False\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel32 (power_p32 pp x y) (power_p p x' y')", "obtain d' r' where dr': \"Divides.divmod_nat y' 2 = (d',r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d' r'.\n        divmod_nat y' 2 = (d', r') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  divmod_nat y' 2 = (d', r')\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel32 (power_p32 pp x y) (power_p p x' y')", "from divmod_nat_def[of y' 2, unfolded dr']"], ["proof (chain)\npicking this:\n  (d', r') = (y' div 2, y' mod 2)", "have r': \"r' = y' mod 2\" and d': \"d' = y' div 2\""], ["proof (prove)\nusing this:\n  (d', r') = (y' div 2, y' mod 2)\n\ngoal (1 subgoal):\n 1. r' = y' mod 2 &&& d' = y' div 2", "by auto"], ["proof (state)\nthis:\n  r' = y' mod 2\n  d' = y' div 2\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel32 (power_p32 pp x y) (power_p p x' y')", "have \"urel32 (y AND 1) r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (y AND 1) (int r')", "unfolding r'"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (y AND 1) (int (y' mod 2))", "using y"], ["proof (prove)\nusing this:\n  urel32 y (int y')\n\ngoal (1 subgoal):\n 1. urel32 (y AND 1) (int (y' mod 2))", "unfolding urel32_def"], ["proof (prove)\nusing this:\n  int y' = int_of_uint32 y \\<and> int y' < p\n\ngoal (1 subgoal):\n 1. int (y' mod 2) = int_of_uint32 (y AND 1) \\<and> int (y' mod 2) < p", "using small"], ["proof (prove)\nusing this:\n  int y' = int_of_uint32 y \\<and> int y' < p\n  p \\<le> 65535\n\ngoal (1 subgoal):\n 1. int (y' mod 2) = int_of_uint32 (y AND 1) \\<and> int (y' mod 2) < p", "apply (simp add: ppp and_one_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>int y' = int_of_uint32 y \\<and> int y' < int_of_uint32 pp;\n     int_of_uint32 pp \\<le> 65535\\<rbrakk>\n    \\<Longrightarrow> int (y' mod 2) = int_of_uint32 (y mod 2) \\<and>\n                      int (y' mod 2) < int_of_uint32 pp", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y' y pp.\n       \\<lbrakk>int y' = uint y \\<and> int y' < uint pp;\n        uint pp \\<le> 65535\\<rbrakk>\n       \\<Longrightarrow> int (y' mod 2) = uint (y mod 2) \\<and>\n                         int (y' mod 2) < uint pp", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y' y pp.\n       \\<lbrakk>int y' = take_bit LENGTH(32) y \\<and>\n                int y' < take_bit LENGTH(32) pp;\n        take_bit LENGTH(32) pp \\<le> 65535\\<rbrakk>\n       \\<Longrightarrow> int (y' mod 2) =\n                         take_bit LENGTH(32)\n                          (take_bit LENGTH(32) y mod\n                           take_bit LENGTH(32) 2) \\<and>\n                         int (y' mod 2) < take_bit LENGTH(32) pp", "apply (auto simp add: zmod_int take_bit_int_eq_self)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y' y pp.\n       \\<lbrakk>take_bit 32 pp \\<le> 65535; int y' = take_bit 32 y;\n        take_bit 32 y < take_bit 32 pp\\<rbrakk>\n       \\<Longrightarrow> take_bit 32 y mod 2 < take_bit 32 pp", "apply (rule le_less_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y' y pp.\n       \\<lbrakk>take_bit 32 pp \\<le> 65535; int y' = take_bit 32 y;\n        take_bit 32 y < take_bit 32 pp\\<rbrakk>\n       \\<Longrightarrow> take_bit 32 y mod 2 \\<le> ?y822 y' y pp\n 2. \\<And>y' y pp.\n       \\<lbrakk>take_bit 32 pp \\<le> 65535; int y' = take_bit 32 y;\n        take_bit 32 y < take_bit 32 pp\\<rbrakk>\n       \\<Longrightarrow> ?y822 y' y pp < take_bit 32 pp", "apply (rule zmod_le_nonneg_dividend)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y' y pp.\n       \\<lbrakk>take_bit 32 pp \\<le> 65535; int y' = take_bit 32 y;\n        take_bit 32 y < take_bit 32 pp\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> take_bit 32 y\n 2. \\<And>y' y pp.\n       \\<lbrakk>take_bit 32 pp \\<le> 65535; int y' = take_bit 32 y;\n        take_bit 32 y < take_bit 32 pp\\<rbrakk>\n       \\<Longrightarrow> take_bit 32 y < take_bit 32 pp", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  urel32 (y AND 1) (int r')\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel32 (power_p32 pp x y) (power_p p x' y')", "from urel32_eq[OF this urel32_0]"], ["proof (chain)\npicking this:\n  (y AND 1 = 0) = (int r' = 0)", "have rem: \"(y AND 1 = 0) = (r' = 0)\""], ["proof (prove)\nusing this:\n  (y AND 1 = 0) = (int r' = 0)\n\ngoal (1 subgoal):\n 1. (y AND 1 = 0) = (r' = 0)", "by simp"], ["proof (state)\nthis:\n  (y AND 1 = 0) = (r' = 0)\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel32 (power_p32 pp x y) (power_p p x' y')", "have div: \"urel32 (shiftr y 1) (int d')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (y >> 1) (int d')", "unfolding d'"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (y >> 1) (int (y' div 2))", "using y"], ["proof (prove)\nusing this:\n  urel32 y (int y')\n\ngoal (1 subgoal):\n 1. urel32 (y >> 1) (int (y' div 2))", "unfolding urel32_def"], ["proof (prove)\nusing this:\n  int y' = int_of_uint32 y \\<and> int y' < p\n\ngoal (1 subgoal):\n 1. int (y' div 2) = int_of_uint32 (y >> 1) \\<and> int (y' div 2) < p", "using small"], ["proof (prove)\nusing this:\n  int y' = int_of_uint32 y \\<and> int y' < p\n  p \\<le> 65535\n\ngoal (1 subgoal):\n 1. int (y' div 2) = int_of_uint32 (y >> 1) \\<and> int (y' div 2) < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  int y' = int_of_uint32 y \\<and> int y' < int_of_uint32 pp\n  int_of_uint32 pp \\<le> 65535\n\ngoal (1 subgoal):\n 1. int (y' div 2) = int_of_uint32 (y >> 1) \\<and>\n    int (y' div 2) < int_of_uint32 pp", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y' y pp.\n       \\<lbrakk>int y' = uint y \\<and> int y' < uint pp;\n        uint pp \\<le> 65535\\<rbrakk>\n       \\<Longrightarrow> int (y' div 2) = uint (drop_bit 1 y) \\<and>\n                         int (y' div 2) < uint pp", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y' y pp.\n       \\<lbrakk>int y' = take_bit LENGTH(32) y \\<and>\n                int y' < take_bit LENGTH(32) pp;\n        take_bit LENGTH(32) pp \\<le> 65535\\<rbrakk>\n       \\<Longrightarrow> int (y' div 2) =\n                         take_bit LENGTH(32)\n                          ((drop_bit 1 \\<circ> take_bit LENGTH(32))\n                            y) \\<and>\n                         int (y' div 2) < take_bit LENGTH(32) pp", "apply (auto simp add: drop_bit_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  urel32 (y >> 1) (int d')\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel32 (power_p32 pp x y) (power_p p x' y')", "note IH = 1(1)[OF False refl dr'[symmetric] urel32_mult[OF x x] div]"], ["proof (state)\nthis:\n  urel32 (power_p32 pp (mult_p32 pp x x) (y >> 1))\n   (power_p p (mult_p p x' x') d')\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel32 (power_p32 pp x y) (power_p p x' y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (power_p32 pp x y) (power_p p x' y')", "unfolding power_p.simps[of _ _ \"y'\"] power_p32.simps[of _ _ y] dr' id if_False rem"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32\n     (let rec = power_p32 pp (mult_p32 pp x x) (y >> 1)\n      in if r' = 0 then rec else mult_p32 pp rec x)\n     (let (d, r) = (d', r'); rec = power_p p (mult_p p x' x') d\n      in if r = 0 then rec else mult_p p rec x')", "using IH urel32_mult[OF IH x]"], ["proof (prove)\nusing this:\n  urel32 (power_p32 pp (mult_p32 pp x x) (y >> 1))\n   (power_p p (mult_p p x' x') d')\n  urel32 (mult_p32 pp (power_p32 pp (mult_p32 pp x x) (y >> 1)) x)\n   (mult_p p (power_p p (mult_p p x' x') d') x')\n\ngoal (1 subgoal):\n 1. urel32\n     (let rec = power_p32 pp (mult_p32 pp x x) (y >> 1)\n      in if r' = 0 then rec else mult_p32 pp rec x)\n     (let (d, r) = (d', r'); rec = power_p p (mult_p p x' x') d\n      in if r = 0 then rec else mult_p p rec x')", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  urel32 (power_p32 pp x y) (power_p p x' y')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  urel32 (power_p32 pp x y) (power_p p x' y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel32_inverse: assumes x: \"urel32 x x'\" \n  shows \"urel32 (inverse_p32 pp x) (inverse_p p x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (inverse_p32 pp x) (inverse_p p x')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. urel32 (inverse_p32 pp x) (inverse_p p x')", "have p: \"urel32 (pp - 2) (int (nat (p - 2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (pp - 2) (int (nat (p - 2)))", "using p2 small"], ["proof (prove)\nusing this:\n  2 \\<le> p\n  p \\<le> 65535\n\ngoal (1 subgoal):\n 1. urel32 (pp - 2) (int (nat (p - 2)))", "unfolding urel32_def"], ["proof (prove)\nusing this:\n  2 \\<le> p\n  p \\<le> 65535\n\ngoal (1 subgoal):\n 1. int (nat (p - 2)) = int_of_uint32 (pp - 2) \\<and> int (nat (p - 2)) < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  2 \\<le> int_of_uint32 pp\n  int_of_uint32 pp \\<le> 65535\n\ngoal (1 subgoal):\n 1. int (nat (int_of_uint32 pp - 2)) = int_of_uint32 (pp - 2) \\<and>\n    int (nat (int_of_uint32 pp - 2)) < int_of_uint32 pp", "by (transfer, auto simp: uint_word_ariths)"], ["proof (state)\nthis:\n  urel32 (pp - 2) (int (nat (p - 2)))\n\ngoal (1 subgoal):\n 1. urel32 (inverse_p32 pp x) (inverse_p p x')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (inverse_p32 pp x) (inverse_p p x')", "unfolding inverse_p32_def inverse_p_def urel32_eq[OF x urel32_0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 (if x' = 0 then 0 else power_p32 pp x (pp - 2))\n     (if x' = 0 then 0 else power_p p x' (nat (p - 2)))", "using urel32_0 urel32_power[OF x p]"], ["proof (prove)\nusing this:\n  urel32 0 0\n  urel32 (power_p32 pp x (pp - 2)) (power_p p x' (nat (p - 2)))\n\ngoal (1 subgoal):\n 1. urel32 (if x' = 0 then 0 else power_p32 pp x (pp - 2))\n     (if x' = 0 then 0 else power_p p x' (nat (p - 2)))", "by auto"], ["proof (state)\nthis:\n  urel32 (inverse_p32 pp x) (inverse_p p x')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_ring_0_32: \"mod_ring_rel32 0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel32 0 0", "using urel32_0 mod_ring_0"], ["proof (prove)\nusing this:\n  urel32 0 0\n  mod_ring_rel 0 0\n\ngoal (1 subgoal):\n 1. mod_ring_rel32 0 0", "unfolding mod_ring_rel32_def"], ["proof (prove)\nusing this:\n  urel32 0 0\n  mod_ring_rel 0 0\n\ngoal (1 subgoal):\n 1. \\<exists>z. urel32 0 z \\<and> mod_ring_rel z 0", "by blast"], ["", "lemma mod_ring_1_32: \"mod_ring_rel32 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel32 1 1", "using urel32_1 mod_ring_1"], ["proof (prove)\nusing this:\n  urel32 1 1\n  mod_ring_rel 1 1\n\ngoal (1 subgoal):\n 1. mod_ring_rel32 1 1", "unfolding mod_ring_rel32_def"], ["proof (prove)\nusing this:\n  urel32 1 1\n  mod_ring_rel 1 1\n\ngoal (1 subgoal):\n 1. \\<exists>z. urel32 1 z \\<and> mod_ring_rel z 1", "by blast"], ["", "lemma mod_ring_uminus32: \"(mod_ring_rel32 ===> mod_ring_rel32) (uminus_p32 pp) uminus\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32) (uminus_p32 pp) uminus", "using urel32_uminus mod_ring_uminus"], ["proof (prove)\nusing this:\n  urel32 ?x ?y \\<Longrightarrow> urel32 (uminus_p32 pp ?x) (uminus_p p ?y)\n  (mod_ring_rel ===> mod_ring_rel) (uminus_p p) uminus\n\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32) (uminus_p32 pp) uminus", "unfolding mod_ring_rel32_def rel_fun_def"], ["proof (prove)\nusing this:\n  urel32 ?x ?y \\<Longrightarrow> urel32 (uminus_p32 pp ?x) (uminus_p p ?y)\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow> mod_ring_rel (uminus_p p x) (- y)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel32 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<exists>z. urel32 (uminus_p32 pp x) z \\<and> mod_ring_rel z (- y))", "by blast"], ["", "lemma mod_ring_plus32: \"(mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (plus_p32 pp) (+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (plus_p32 pp)\n     (+)", "using urel32_plus mod_ring_plus"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel32 ?x ?y; urel32 ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel32 (plus_p32 pp ?x ?x') (plus_p p ?y ?y')\n  (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (plus_p p) (+)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (plus_p32 pp)\n     (+)", "unfolding mod_ring_rel32_def rel_fun_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel32 ?x ?y; urel32 ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel32 (plus_p32 pp ?x ?x') (plus_p p ?y ?y')\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel xa ya \\<longrightarrow>\n         mod_ring_rel (plus_p p x xa) (y + ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel32 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<exists>z.\n               urel32 xa z \\<and> mod_ring_rel z ya) \\<longrightarrow>\n           (\\<exists>z.\n               urel32 (plus_p32 pp x xa) z \\<and> mod_ring_rel z (y + ya)))", "by blast"], ["", "lemma mod_ring_minus32: \"(mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (minus_p32 pp) (-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (minus_p32 pp)\n     (-)", "using urel32_minus mod_ring_minus"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel32 ?x ?y; urel32 ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel32 (minus_p32 pp ?x ?x') (minus_p p ?y ?y')\n  (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (minus_p p) (-)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (minus_p32 pp)\n     (-)", "unfolding mod_ring_rel32_def rel_fun_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel32 ?x ?y; urel32 ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel32 (minus_p32 pp ?x ?x') (minus_p p ?y ?y')\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel xa ya \\<longrightarrow>\n         mod_ring_rel (minus_p p x xa) (y - ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel32 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<exists>z.\n               urel32 xa z \\<and> mod_ring_rel z ya) \\<longrightarrow>\n           (\\<exists>z.\n               urel32 (minus_p32 pp x xa) z \\<and> mod_ring_rel z (y - ya)))", "by blast"], ["", "lemma mod_ring_mult32: \"(mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (mult_p32 pp) ((*))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (mult_p32 pp)\n     (*)", "using urel32_mult mod_ring_mult"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel32 ?x ?y; urel32 ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel32 (mult_p32 pp ?x ?x') (mult_p p ?y ?y')\n  (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (mult_p p) (*)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (mult_p32 pp)\n     (*)", "unfolding mod_ring_rel32_def rel_fun_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel32 ?x ?y; urel32 ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel32 (mult_p32 pp ?x ?x') (mult_p p ?y ?y')\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel xa ya \\<longrightarrow>\n         mod_ring_rel (mult_p p x xa) (y * ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel32 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<exists>z.\n               urel32 xa z \\<and> mod_ring_rel z ya) \\<longrightarrow>\n           (\\<exists>z.\n               urel32 (mult_p32 pp x xa) z \\<and> mod_ring_rel z (y * ya)))", "by blast"], ["", "lemma mod_ring_eq32: \"(mod_ring_rel32 ===> mod_ring_rel32 ===> (=)) (=) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32 ===> (=)) (=) (=)", "using urel32_eq mod_ring_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel32 ?x ?y; urel32 ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> (?x = ?x') = (?y = ?y')\n  (mod_ring_rel ===> mod_ring_rel ===> (=)) (=) (=)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32 ===> (=)) (=) (=)", "unfolding mod_ring_rel32_def rel_fun_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel32 ?x ?y; urel32 ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> (?x = ?x') = (?y = ?y')\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel xa ya \\<longrightarrow> (x = xa) = (y = ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel32 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<exists>z.\n               urel32 xa z \\<and> mod_ring_rel z ya) \\<longrightarrow>\n           (x = xa) = (y = ya))", "by blast"], ["", "lemma urel32_inj: \"urel32 x y \\<Longrightarrow> urel32 x z \\<Longrightarrow> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>urel32 x y; urel32 x z\\<rbrakk> \\<Longrightarrow> y = z", "using urel32_eq[of x y x z]"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel32 x y; urel32 x z\\<rbrakk>\n  \\<Longrightarrow> (x = x) = (y = z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>urel32 x y; urel32 x z\\<rbrakk> \\<Longrightarrow> y = z", "by auto"], ["", "lemma urel32_inj': \"urel32 x z \\<Longrightarrow> urel32 y z \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>urel32 x z; urel32 y z\\<rbrakk> \\<Longrightarrow> x = y", "using urel32_eq[of x z y z]"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel32 x z; urel32 y z\\<rbrakk>\n  \\<Longrightarrow> (x = y) = (z = z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>urel32 x z; urel32 y z\\<rbrakk> \\<Longrightarrow> x = y", "by auto"], ["", "lemma bi_unique_mod_ring_rel32:\n  \"bi_unique mod_ring_rel32\" \"left_unique mod_ring_rel32\" \"right_unique mod_ring_rel32\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique mod_ring_rel32 &&&\n    left_unique mod_ring_rel32 &&& right_unique mod_ring_rel32", "using bi_unique_mod_ring_rel urel32_inj'"], ["proof (prove)\nusing this:\n  bi_unique mod_ring_rel\n  left_unique mod_ring_rel\n  right_unique mod_ring_rel\n  \\<lbrakk>urel32 ?x ?z; urel32 ?y ?z\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. bi_unique mod_ring_rel32 &&&\n    left_unique mod_ring_rel32 &&& right_unique mod_ring_rel32", "unfolding mod_ring_rel32_def bi_unique_def left_unique_def right_unique_def"], ["proof (prove)\nusing this:\n  (\\<forall>x y z.\n      mod_ring_rel x y \\<longrightarrow>\n      mod_ring_rel x z \\<longrightarrow> y = z) \\<and>\n  (\\<forall>x y z.\n      mod_ring_rel x z \\<longrightarrow>\n      mod_ring_rel y z \\<longrightarrow> x = y)\n  \\<forall>x y z.\n     mod_ring_rel x z \\<longrightarrow>\n     mod_ring_rel y z \\<longrightarrow> x = y\n  \\<forall>x y z.\n     mod_ring_rel x y \\<longrightarrow>\n     mod_ring_rel x z \\<longrightarrow> y = z\n  \\<lbrakk>urel32 ?x ?z; urel32 ?y ?z\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        (\\<exists>z. urel32 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n        (\\<exists>za.\n            urel32 x za \\<and> mod_ring_rel za z) \\<longrightarrow>\n        y = z) \\<and>\n    (\\<forall>x y z.\n        (\\<exists>za.\n            urel32 x za \\<and> mod_ring_rel za z) \\<longrightarrow>\n        (\\<exists>za.\n            urel32 y za \\<and> mod_ring_rel za z) \\<longrightarrow>\n        x = y) &&&\n    \\<forall>x y z.\n       (\\<exists>za. urel32 x za \\<and> mod_ring_rel za z) \\<longrightarrow>\n       (\\<exists>za. urel32 y za \\<and> mod_ring_rel za z) \\<longrightarrow>\n       x = y &&&\n    \\<forall>x y z.\n       (\\<exists>z. urel32 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<exists>za. urel32 x za \\<and> mod_ring_rel za z) \\<longrightarrow>\n       y = z", "by (auto simp: urel32_def)"], ["", "lemma right_total_mod_ring_rel32: \"right_total mod_ring_rel32\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total mod_ring_rel32", "unfolding mod_ring_rel32_def right_total_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x z. urel32 x z \\<and> mod_ring_rel z y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x z. urel32 x z \\<and> mod_ring_rel z y", "fix y :: \"'a mod_ring\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x z. urel32 x z \\<and> mod_ring_rel z y", "from right_total_mod_ring_rel[unfolded right_total_def, rule_format, of y]"], ["proof (chain)\npicking this:\n  \\<exists>x. mod_ring_rel x y", "obtain z where zy: \"mod_ring_rel z y\""], ["proof (prove)\nusing this:\n  \\<exists>x. mod_ring_rel x y\n\ngoal (1 subgoal):\n 1. (\\<And>z. mod_ring_rel z y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mod_ring_rel z y\n\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x z. urel32 x z \\<and> mod_ring_rel z y", "hence zp: \"0 \\<le> z\" \"z < p\""], ["proof (prove)\nusing this:\n  mod_ring_rel z y\n\ngoal (1 subgoal):\n 1. 0 \\<le> z &&& z < p", "unfolding mod_ring_rel_def p"], ["proof (prove)\nusing this:\n  z = to_int_mod_ring y\n\ngoal (1 subgoal):\n 1. 0 \\<le> z &&& z < int CARD('a)", "using range_to_int_mod_ring[where 'a = 'a]"], ["proof (prove)\nusing this:\n  z = to_int_mod_ring y\n  range to_int_mod_ring = {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. 0 \\<le> z &&& z < int CARD('a)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x z. urel32 x z \\<and> mod_ring_rel z y", "hence \"urel32 (uint32_of_int z) z\""], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. urel32 (uint32_of_int z) z", "unfolding urel32_def"], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. z = int_of_uint32 (uint32_of_int z) \\<and> z < p", "using small"], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z < p\n  p \\<le> 65535\n\ngoal (1 subgoal):\n 1. z = int_of_uint32 (uint32_of_int z) \\<and> z < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z < int_of_uint32 pp\n  int_of_uint32 pp \\<le> 65535\n\ngoal (1 subgoal):\n 1. z = int_of_uint32 (uint32_of_int z) \\<and> z < int_of_uint32 pp", "by (auto simp: int_of_uint32_inv)"], ["proof (state)\nthis:\n  urel32 (uint32_of_int z) z\n\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x z. urel32 x z \\<and> mod_ring_rel z y", "with zy"], ["proof (chain)\npicking this:\n  mod_ring_rel z y\n  urel32 (uint32_of_int z) z", "show \"\\<exists> x z. urel32 x z \\<and> mod_ring_rel z y\""], ["proof (prove)\nusing this:\n  mod_ring_rel z y\n  urel32 (uint32_of_int z) z\n\ngoal (1 subgoal):\n 1. \\<exists>x z. urel32 x z \\<and> mod_ring_rel z y", "by blast"], ["proof (state)\nthis:\n  \\<exists>x z. urel32 x z \\<and> mod_ring_rel z y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Domainp_mod_ring_rel32: \"Domainp mod_ring_rel32 = (\\<lambda>x. 0 \\<le> x \\<and> x < pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel32 = (\\<lambda>x. 0 \\<le> x \\<and> x < pp)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Domainp mod_ring_rel32 x = (0 \\<le> x \\<and> x < pp)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Domainp mod_ring_rel32 x = (0 \\<le> x \\<and> x < pp)", "show \"Domainp mod_ring_rel32 x = (0 \\<le> x \\<and> x < pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel32 x = (0 \\<le> x \\<and> x < pp)", "unfolding Domainp.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a b. x = a \\<and> mod_ring_rel32 a b) =\n    (0 \\<le> x \\<and> x < pp)", "unfolding mod_ring_rel32_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a b.\n        x = a \\<and> (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b)) =\n    (0 \\<le> x \\<and> x < pp)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b)", "let ?i = \"int_of_uint32\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b)", "assume *: \"0 \\<le> x \\<and> x < pp\""], ["proof (state)\nthis:\n  0 \\<le> x \\<and> x < pp\n\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b)", "hence \"0 \\<le> ?i x \\<and> ?i x < p\""], ["proof (prove)\nusing this:\n  0 \\<le> x \\<and> x < pp\n\ngoal (1 subgoal):\n 1. 0 \\<le> int_of_uint32 x \\<and> int_of_uint32 x < p", "using small"], ["proof (prove)\nusing this:\n  0 \\<le> x \\<and> x < pp\n  p \\<le> 65535\n\ngoal (1 subgoal):\n 1. 0 \\<le> int_of_uint32 x \\<and> int_of_uint32 x < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  0 \\<le> x \\<and> x < pp\n  int_of_uint32 pp \\<le> 65535\n\ngoal (1 subgoal):\n 1. 0 \\<le> int_of_uint32 x \\<and> int_of_uint32 x < int_of_uint32 pp", "by (transfer, auto simp: word_less_def)"], ["proof (state)\nthis:\n  0 \\<le> int_of_uint32 x \\<and> int_of_uint32 x < p\n\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b)", "hence \"?i x \\<in> {0 ..< p}\""], ["proof (prove)\nusing this:\n  0 \\<le> int_of_uint32 x \\<and> int_of_uint32 x < p\n\ngoal (1 subgoal):\n 1. int_of_uint32 x \\<in> {0..<p}", "by auto"], ["proof (state)\nthis:\n  int_of_uint32 x \\<in> {0..<p}\n\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b)", "with Domainp_mod_ring_rel"], ["proof (chain)\npicking this:\n  Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})\n  int_of_uint32 x \\<in> {0..<p}", "have \"Domainp mod_ring_rel (?i x)\""], ["proof (prove)\nusing this:\n  Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})\n  int_of_uint32 x \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel (int_of_uint32 x)", "by auto"], ["proof (state)\nthis:\n  Domainp mod_ring_rel (int_of_uint32 x)\n\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b)", "from this[unfolded Domainp.simps]"], ["proof (chain)\npicking this:\n  \\<exists>a b. int_of_uint32 x = a \\<and> mod_ring_rel a b", "obtain b where b: \"mod_ring_rel (?i x) b\""], ["proof (prove)\nusing this:\n  \\<exists>a b. int_of_uint32 x = a \\<and> mod_ring_rel a b\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        mod_ring_rel (int_of_uint32 x) b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mod_ring_rel (int_of_uint32 x) b\n\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b)", "show \"\\<exists>a b. x = a \\<and> (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b)", "proof (intro exI, rule conjI[OF refl], rule exI, rule conjI[OF _ b])"], ["proof (state)\ngoal (1 subgoal):\n 1. urel32 x (int_of_uint32 x)", "show \"urel32 x (?i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel32 x (int_of_uint32 x)", "unfolding urel32_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint32 x = int_of_uint32 x \\<and> int_of_uint32 x < p", "using small *"], ["proof (prove)\nusing this:\n  p \\<le> 65535\n  0 \\<le> x \\<and> x < pp\n\ngoal (1 subgoal):\n 1. int_of_uint32 x = int_of_uint32 x \\<and> int_of_uint32 x < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  int_of_uint32 pp \\<le> 65535\n  0 \\<le> x \\<and> x < pp\n\ngoal (1 subgoal):\n 1. int_of_uint32 x = int_of_uint32 x \\<and>\n    int_of_uint32 x < int_of_uint32 pp", "by (transfer, auto simp: word_less_def)"], ["proof (state)\nthis:\n  urel32 x (int_of_uint32 x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a b.\n     x = a \\<and> (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b)\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "assume \"\\<exists>a b. x = a \\<and> (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b)\""], ["proof (state)\nthis:\n  \\<exists>a b.\n     x = a \\<and> (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b)\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "then"], ["proof (chain)\npicking this:\n  \\<exists>a b.\n     x = a \\<and> (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b)", "obtain b z where xz: \"urel32 x z\" and zb: \"mod_ring_rel z b\""], ["proof (prove)\nusing this:\n  \\<exists>a b.\n     x = a \\<and> (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b)\n\ngoal (1 subgoal):\n 1. (\\<And>z b.\n        \\<lbrakk>urel32 x z; mod_ring_rel z b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  urel32 x z\n  mod_ring_rel z b\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "hence \"Domainp mod_ring_rel z\""], ["proof (prove)\nusing this:\n  urel32 x z\n  mod_ring_rel z b\n\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel z", "by auto"], ["proof (state)\nthis:\n  Domainp mod_ring_rel z\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "with Domainp_mod_ring_rel"], ["proof (chain)\npicking this:\n  Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})\n  Domainp mod_ring_rel z", "have \"0 \\<le> z\" \"z < p\""], ["proof (prove)\nusing this:\n  Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})\n  Domainp mod_ring_rel z\n\ngoal (1 subgoal):\n 1. 0 \\<le> z &&& z < p", "by auto"], ["proof (state)\nthis:\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel32 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "with xz"], ["proof (chain)\npicking this:\n  urel32 x z\n  0 \\<le> z\n  z < p", "show \"0 \\<le> x \\<and> x < pp\""], ["proof (prove)\nusing this:\n  urel32 x z\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x < pp", "unfolding urel32_def"], ["proof (prove)\nusing this:\n  z = int_of_uint32 x \\<and> z < p\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x < pp", "using small"], ["proof (prove)\nusing this:\n  z = int_of_uint32 x \\<and> z < p\n  0 \\<le> z\n  z < p\n  p \\<le> 65535\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x < pp", "unfolding ppp"], ["proof (prove)\nusing this:\n  z = int_of_uint32 x \\<and> z < int_of_uint32 pp\n  0 \\<le> z\n  z < int_of_uint32 pp\n  int_of_uint32 pp \\<le> 65535\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x < pp", "by (transfer, auto simp: word_less_def)"], ["proof (state)\nthis:\n  0 \\<le> x \\<and> x < pp\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Domainp mod_ring_rel32 x = (0 \\<le> x \\<and> x < pp)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ring_finite_field_ops32: \"ring_ops (finite_field_ops32 pp) mod_ring_rel32\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_ops (finite_field_ops32 pp) mod_ring_rel32", "by (unfold_locales, auto simp:\n  finite_field_ops32_def\n  bi_unique_mod_ring_rel32\n  right_total_mod_ring_rel32\n  mod_ring_plus32\n  mod_ring_minus32\n  mod_ring_uminus32\n  mod_ring_mult32\n  mod_ring_eq32\n  mod_ring_0_32\n  mod_ring_1_32\n  Domainp_mod_ring_rel32)"], ["", "end"], ["", "end"], ["", "context prime_field\nbegin"], ["", "context fixes pp :: \"uint32\" \n  assumes *: \"p = int_of_uint32 pp\" \"p \\<le> 65535\" \nbegin"], ["", "lemma mod_ring_normalize32: \"(mod_ring_rel32 ===> mod_ring_rel32) (\\<lambda>x. if x = 0 then 0 else 1) normalize\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32)\n     (\\<lambda>x. if x = 0 then 0 else 1) normalize", "using urel32_normalize[OF *] mod_ring_normalize"], ["proof (prove)\nusing this:\n  urel32 ?x ?y \\<Longrightarrow>\n  urel32 (if ?x = 0 then 0 else 1) (if ?y = 0 then 0 else 1)\n  (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. if x = 0 then 0 else 1)\n   normalize\n\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32)\n     (\\<lambda>x. if x = 0 then 0 else 1) normalize", "unfolding mod_ring_rel32_def[OF *] rel_fun_def"], ["proof (prove)\nusing this:\n  urel32 ?x ?y \\<Longrightarrow>\n  urel32 (if ?x = 0 then 0 else 1) (if ?y = 0 then 0 else 1)\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     mod_ring_rel (if x = 0 then 0 else 1) (normalize y)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel32 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<exists>z.\n           urel32 (if x = 0 then 0 else 1) z \\<and>\n           mod_ring_rel z (normalize y))", "by blast"], ["", "lemma mod_ring_mod32: \"(mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (\\<lambda>x y. if y = 0 then x else 0) (mod)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32)\n     (\\<lambda>x y. if y = 0 then x else 0) (mod)", "using urel32_mod[OF *] mod_ring_mod"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel32 ?x ?x'; urel32 ?y ?y'\\<rbrakk>\n  \\<Longrightarrow> urel32 (if ?y = 0 then ?x else 0)\n                     (if ?y' = 0 then ?x' else 0)\n  (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel)\n   (\\<lambda>x y. if y = 0 then x else 0) (mod)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32)\n     (\\<lambda>x y. if y = 0 then x else 0) (mod)", "unfolding mod_ring_rel32_def[OF *] rel_fun_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel32 ?x ?x'; urel32 ?y ?y'\\<rbrakk>\n  \\<Longrightarrow> urel32 (if ?y = 0 then ?x else 0)\n                     (if ?y' = 0 then ?x' else 0)\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel xa ya \\<longrightarrow>\n         mod_ring_rel (if xa = 0 then x else 0) (y mod ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel32 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<exists>z.\n               urel32 xa z \\<and> mod_ring_rel z ya) \\<longrightarrow>\n           (\\<exists>z.\n               urel32 (if xa = 0 then x else 0) z \\<and>\n               mod_ring_rel z (y mod ya)))", "by blast"], ["", "lemma mod_ring_unit_factor32: \"(mod_ring_rel32 ===> mod_ring_rel32) (\\<lambda>x. x) unit_factor\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32) (\\<lambda>x. x) unit_factor", "using mod_ring_unit_factor"], ["proof (prove)\nusing this:\n  (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. x) unit_factor\n\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32) (\\<lambda>x. x) unit_factor", "unfolding mod_ring_rel32_def[OF *] rel_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow> mod_ring_rel x (unit_factor y)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel32 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<exists>z. urel32 x z \\<and> mod_ring_rel z (unit_factor y))", "by blast"], ["", "lemma mod_ring_inverse32: \"(mod_ring_rel32 ===> mod_ring_rel32) (inverse_p32 pp) inverse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32) (inverse_p32 pp) inverse", "using urel32_inverse[OF *] mod_ring_inverse"], ["proof (prove)\nusing this:\n  urel32 ?x ?x' \\<Longrightarrow>\n  urel32 (inverse_p32 pp ?x) (inverse_p p ?x')\n  (mod_ring_rel ===> mod_ring_rel) (inverse_p p) inverse\n\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32) (inverse_p32 pp) inverse", "unfolding mod_ring_rel32_def[OF *] rel_fun_def"], ["proof (prove)\nusing this:\n  urel32 ?x ?x' \\<Longrightarrow>\n  urel32 (inverse_p32 pp ?x) (inverse_p p ?x')\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     mod_ring_rel (inverse_p p x) (inverse y)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel32 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<exists>z.\n           urel32 (inverse_p32 pp x) z \\<and> mod_ring_rel z (inverse y))", "by blast"], ["", "lemma mod_ring_divide32: \"(mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (divide_p32 pp) (/)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (divide_p32 pp)\n     (/)", "using mod_ring_inverse32 mod_ring_mult32[OF *]"], ["proof (prove)\nusing this:\n  (mod_ring_rel32 ===> mod_ring_rel32) (inverse_p32 pp) inverse\n  (mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (mult_p32 pp) (*)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel32 ===> mod_ring_rel32 ===> mod_ring_rel32) (divide_p32 pp)\n     (/)", "unfolding divide_p32_def divide_mod_ring_def inverse_mod_ring_def[symmetric]\n    rel_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     mod_ring_rel32 x y \\<longrightarrow>\n     mod_ring_rel32 (inverse_p32 pp x) (inverse y)\n  \\<forall>x y.\n     mod_ring_rel32 x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel32 xa ya \\<longrightarrow>\n         mod_ring_rel32 (mult_p32 pp x xa) (y * ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       mod_ring_rel32 x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           mod_ring_rel32 xa ya \\<longrightarrow>\n           mod_ring_rel32 (mult_p32 pp x (inverse_p32 pp xa))\n            (y * inverse ya))", "by blast"], ["", "lemma finite_field_ops32: \"field_ops (finite_field_ops32 pp) mod_ring_rel32\""], ["proof (prove)\ngoal (1 subgoal):\n 1. field_ops (finite_field_ops32 pp) mod_ring_rel32", "by (unfold_locales, insert ring_finite_field_ops32[OF *], auto simp:\n  ring_ops_def\n  finite_field_ops32_def\n  mod_ring_divide32\n  mod_ring_inverse32\n  mod_ring_mod32\n  mod_ring_normalize32)"], ["", "end"], ["", "end"], ["", "(* now there is 64-bit time *)"], ["", "context\n  fixes p :: uint64\nbegin"], ["", "definition plus_p64 :: \"uint64 \\<Rightarrow> uint64 \\<Rightarrow> uint64\" where\n  \"plus_p64 x y \\<equiv> let z = x + y in if z \\<ge> p then z - p else z\""], ["", "definition minus_p64 :: \"uint64 \\<Rightarrow> uint64 \\<Rightarrow> uint64\" where\n  \"minus_p64 x y \\<equiv> if y \\<le> x then x - y else (x + p) - y\""], ["", "definition uminus_p64 :: \"uint64 \\<Rightarrow> uint64\" where\n  \"uminus_p64 x = (if x = 0 then 0 else p - x)\""], ["", "definition mult_p64 :: \"uint64 \\<Rightarrow> uint64 \\<Rightarrow> uint64\" where\n  \"mult_p64 x y = (x * y mod p)\""], ["", "lemma int_of_uint64_shift: \"int_of_uint64 (shiftr n k) = (int_of_uint64 n) div (2 ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint64 (n >> k) = int_of_uint64 n div 2 ^ k", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n k. uint (drop_bit k n) = uint n div 2 ^ k", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n k.\n       take_bit LENGTH(64) ((drop_bit k \\<circ> take_bit LENGTH(64)) n) =\n       take_bit LENGTH(64) n div 2 ^ k", "apply (simp add: take_bit_drop_bit min_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n k.\n       0 < k \\<longrightarrow>\n       drop_bit k (take_bit 64 n) = take_bit 64 n div 2 ^ k", "apply (simp add: drop_bit_eq_div)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma int_of_uint64_0_iff: \"int_of_uint64 n = 0 \\<longleftrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int_of_uint64 n = 0) = (n = 0)", "by (transfer, rule uint_0_iff)"], ["", "lemma int_of_uint64_0: \"int_of_uint64 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint64 0 = 0", "unfolding int_of_uint64_0_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = 0", "by simp"], ["", "lemma int_of_uint64_ge_0: \"int_of_uint64 n \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> int_of_uint64 n", "by (transfer, auto)"], ["", "lemma two_64: \"2 ^ LENGTH(64) = (18446744073709551616 :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ LENGTH(64) = 18446744073709551616", "by simp"], ["", "lemma int_of_uint64_plus: \"int_of_uint64 (x + y) = (int_of_uint64 x + int_of_uint64 y) mod 18446744073709551616\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint64 (x + y) =\n    (int_of_uint64 x + int_of_uint64 y) mod 18446744073709551616", "by (transfer, unfold uint_word_ariths two_64, rule refl)"], ["", "lemma int_of_uint64_minus: \"int_of_uint64 (x - y) = (int_of_uint64 x - int_of_uint64 y) mod 18446744073709551616\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint64 (x - y) =\n    (int_of_uint64 x - int_of_uint64 y) mod 18446744073709551616", "by (transfer, unfold uint_word_ariths two_64, rule refl)"], ["", "lemma int_of_uint64_mult: \"int_of_uint64 (x * y) = (int_of_uint64 x * int_of_uint64 y) mod 18446744073709551616\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint64 (x * y) =\n    int_of_uint64 x * int_of_uint64 y mod 18446744073709551616", "by (transfer, unfold uint_word_ariths two_64, rule refl)"], ["", "lemma int_of_uint64_mod: \"int_of_uint64 (x mod y) = (int_of_uint64 x mod int_of_uint64 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint64 (x mod y) = int_of_uint64 x mod int_of_uint64 y", "by (transfer, unfold uint_mod two_64, rule refl)"], ["", "lemma int_of_uint64_inv: \"0 \\<le> x \\<Longrightarrow> x < 18446744073709551616 \\<Longrightarrow> int_of_uint64 (uint64_of_int x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; x < 18446744073709551616\\<rbrakk>\n    \\<Longrightarrow> int_of_uint64 (uint64_of_int x) = x", "by transfer (simp add: take_bit_int_eq_self)"], ["", "function power_p64 :: \"uint64 \\<Rightarrow> uint64 \\<Rightarrow> uint64\" where\n  \"power_p64 x n = (if n = 0 then 1 else\n    let rec = power_p64 (mult_p64 x x) (shiftr n 1) in\n    if n AND 1 = 0 then rec else mult_p64 rec x)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>xa n. x = (xa, n) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>x n xa na.\n       (x, n) = (xa, na) \\<Longrightarrow>\n       (if n = 0 then 1\n        else let rec = power_p64_sumC (local.mult_p64 x x, n >> 1)\n             in if n AND 1 = 0 then rec else local.mult_p64 rec x) =\n       (if na = 0 then 1\n        else let rec = power_p64_sumC (local.mult_p64 xa xa, na >> 1)\n             in if na AND 1 = 0 then rec else local.mult_p64 rec xa)", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All local.power_p64_dom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. All local.power_p64_dom", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. All local.power_p64_dom", "fix n :: uint64"], ["proof (state)\ngoal (1 subgoal):\n 1. All local.power_p64_dom", "assume \"n \\<noteq> 0\""], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. All local.power_p64_dom", "with int_of_uint64_ge_0[of n] int_of_uint64_0_iff[of n]"], ["proof (chain)\npicking this:\n  0 \\<le> int_of_uint64 n\n  (int_of_uint64 n = 0) = (n = 0)\n  n \\<noteq> 0", "have \"int_of_uint64 n > 0\""], ["proof (prove)\nusing this:\n  0 \\<le> int_of_uint64 n\n  (int_of_uint64 n = 0) = (n = 0)\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < int_of_uint64 n", "by auto"], ["proof (state)\nthis:\n  0 < int_of_uint64 n\n\ngoal (1 subgoal):\n 1. All local.power_p64_dom", "hence \"0 < int_of_uint64 n\" \"int_of_uint64 n div 2 < int_of_uint64 n\""], ["proof (prove)\nusing this:\n  0 < int_of_uint64 n\n\ngoal (1 subgoal):\n 1. 0 < int_of_uint64 n &&& int_of_uint64 n div 2 < int_of_uint64 n", "by auto"], ["proof (state)\nthis:\n  0 < int_of_uint64 n\n  int_of_uint64 n div 2 < int_of_uint64 n\n\ngoal (1 subgoal):\n 1. All local.power_p64_dom", "}"], ["proof (state)\nthis:\n  ?n2 \\<noteq> 0 \\<Longrightarrow> 0 < int_of_uint64 ?n2\n  ?n2 \\<noteq> 0 \\<Longrightarrow>\n  int_of_uint64 ?n2 div 2 < int_of_uint64 ?n2\n\ngoal (1 subgoal):\n 1. All local.power_p64_dom", "note * = this"], ["proof (state)\nthis:\n  ?n2 \\<noteq> 0 \\<Longrightarrow> 0 < int_of_uint64 ?n2\n  ?n2 \\<noteq> 0 \\<Longrightarrow>\n  int_of_uint64 ?n2 div 2 < int_of_uint64 ?n2\n\ngoal (1 subgoal):\n 1. All local.power_p64_dom", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. All local.power_p64_dom", "by (relation \"measure (\\<lambda> (x,n). nat (int_of_uint64 n))\", auto simp: int_of_uint64_shift *)"], ["proof (state)\nthis:\n  All local.power_p64_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In experiments with Berlekamp-factorization (where the prime $p$ is usually small),\n  it turned out that taking the below implementation of inverse via exponentiation\n  is faster than the one based on the extended Euclidean algorithm.\\<close>"], ["", "definition inverse_p64 :: \"uint64 \\<Rightarrow> uint64\" where\n  \"inverse_p64 x = (if x = 0 then 0 else power_p64 x (p - 2))\""], ["", "definition divide_p64 :: \"uint64 \\<Rightarrow> uint64 \\<Rightarrow> uint64\"  where\n  \"divide_p64 x y = mult_p64 x (inverse_p64 y)\""], ["", "definition finite_field_ops64 :: \"uint64 arith_ops_record\" where\n  \"finite_field_ops64 \\<equiv> Arith_Ops_Record\n      0\n      1\n      plus_p64\n      mult_p64\n      minus_p64\n      uminus_p64\n      divide_p64\n      inverse_p64\n      (\\<lambda> x y . if y = 0 then x else 0)\n      (\\<lambda> x . if x = 0 then 0 else 1)\n      (\\<lambda> x . x)\n      uint64_of_int\n      int_of_uint64\n      (\\<lambda> x. 0 \\<le> x \\<and> x < p)\""], ["", "end"], ["", "lemma shiftr_uint64_code [code_unfold]: \"drop_bit 1 x = (uint64_shiftr x 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit 1 x = uint64_shiftr x 1", "by (simp add: uint64_shiftr_def)"], ["", "text \\<open>For soundness of the 64-bit implementation, we mainly prove that this implementation\n  implements the int-based implementation of GF(p).\\<close>"], ["", "context mod_ring_locale\nbegin"], ["", "context fixes pp :: \"uint64\" \n  assumes ppp: \"p = int_of_uint64 pp\" \n  and small: \"p \\<le> 4294967295\" \nbegin"], ["", "lemmas uint64_simps = \n  int_of_uint64_0\n  int_of_uint64_plus \n  int_of_uint64_minus\n  int_of_uint64_mult"], ["", "definition urel64 :: \"uint64 \\<Rightarrow> int \\<Rightarrow> bool\" where \"urel64 x y = (y = int_of_uint64 x \\<and> y < p)\""], ["", "definition mod_ring_rel64 :: \"uint64 \\<Rightarrow> 'a mod_ring \\<Rightarrow> bool\" where\n  \"mod_ring_rel64 x y = (\\<exists> z. urel64 x z \\<and> mod_ring_rel z y)\""], ["", "lemma urel64_0: \"urel64 0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 0 0", "unfolding urel64_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = int_of_uint64 0 \\<and> 0 < p", "using p2"], ["proof (prove)\nusing this:\n  2 \\<le> p\n\ngoal (1 subgoal):\n 1. 0 = int_of_uint64 0 \\<and> 0 < p", "by (simp, transfer, simp)"], ["", "lemma urel64_1: \"urel64 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 1 1", "unfolding urel64_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = int_of_uint64 1 \\<and> 1 < p", "using p2"], ["proof (prove)\nusing this:\n  2 \\<le> p\n\ngoal (1 subgoal):\n 1. 1 = int_of_uint64 1 \\<and> 1 < p", "by (simp, transfer, simp)"], ["", "lemma le_int_of_uint64: \"(x \\<le> y) = (int_of_uint64 x \\<le> int_of_uint64 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (int_of_uint64 x \\<le> int_of_uint64 y)", "by (transfer, simp add: word_le_def)"], ["", "lemma urel64_plus: assumes \"urel64 x y\" \"urel64 x' y'\"\n  shows \"urel64 (plus_p64 pp x x') (plus_p p y y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (plus_p64 pp x x') (plus_p p y y')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. urel64 (plus_p64 pp x x') (plus_p p y y')", "let ?x = \"int_of_uint64 x\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel64 (plus_p64 pp x x') (plus_p p y y')", "let ?x' = \"int_of_uint64 x'\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel64 (plus_p64 pp x x') (plus_p p y y')", "let ?p = \"int_of_uint64 pp\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel64 (plus_p64 pp x x') (plus_p p y y')", "from assms int_of_uint64_ge_0"], ["proof (chain)\npicking this:\n  urel64 x y\n  urel64 x' y'\n  0 \\<le> int_of_uint64 ?n", "have id: \"y = ?x\" \"y' = ?x'\" \n    and rel: \"0 \\<le> ?x\" \"?x < p\" \n      \"0 \\<le> ?x'\" \"?x' \\<le> p\""], ["proof (prove)\nusing this:\n  urel64 x y\n  urel64 x' y'\n  0 \\<le> int_of_uint64 ?n\n\ngoal (1 subgoal):\n 1. (y = int_of_uint64 x &&& y' = int_of_uint64 x') &&&\n    (0 \\<le> int_of_uint64 x &&& int_of_uint64 x < p) &&&\n    0 \\<le> int_of_uint64 x' &&& int_of_uint64 x' \\<le> p", "unfolding urel64_def"], ["proof (prove)\nusing this:\n  y = int_of_uint64 x \\<and> y < p\n  y' = int_of_uint64 x' \\<and> y' < p\n  0 \\<le> int_of_uint64 ?n\n\ngoal (1 subgoal):\n 1. (y = int_of_uint64 x &&& y' = int_of_uint64 x') &&&\n    (0 \\<le> int_of_uint64 x &&& int_of_uint64 x < p) &&&\n    0 \\<le> int_of_uint64 x' &&& int_of_uint64 x' \\<le> p", "by auto"], ["proof (state)\nthis:\n  y = int_of_uint64 x\n  y' = int_of_uint64 x'\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel64 (plus_p64 pp x x') (plus_p p y y')", "have le: \"(pp \\<le> x + x') = (?p \\<le> ?x + ?x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pp \\<le> x + x') =\n    (int_of_uint64 pp \\<le> int_of_uint64 x + int_of_uint64 x')", "unfolding le_int_of_uint64"], ["proof (prove)\ngoal (1 subgoal):\n 1. (int_of_uint64 pp \\<le> int_of_uint64 (x + x')) =\n    (int_of_uint64 pp \\<le> int_of_uint64 x + int_of_uint64 x')", "using rel small"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> p\n  p \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. (int_of_uint64 pp \\<le> int_of_uint64 (x + x')) =\n    (int_of_uint64 pp \\<le> int_of_uint64 x + int_of_uint64 x')", "by (auto simp: uint64_simps)"], ["proof (state)\nthis:\n  (pp \\<le> x + x') =\n  (int_of_uint64 pp \\<le> int_of_uint64 x + int_of_uint64 x')\n\ngoal (1 subgoal):\n 1. urel64 (plus_p64 pp x x') (plus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (plus_p64 pp x x') (plus_p p y y')", "proof (cases \"?p \\<le> ?x + ?x'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. int_of_uint64 pp\n    \\<le> int_of_uint64 x + int_of_uint64 x' \\<Longrightarrow>\n    urel64 (plus_p64 pp x x') (plus_p p y y')\n 2. \\<not> int_of_uint64 pp\n           \\<le> int_of_uint64 x + int_of_uint64 x' \\<Longrightarrow>\n    urel64 (plus_p64 pp x x') (plus_p p y y')", "case True"], ["proof (state)\nthis:\n  int_of_uint64 pp \\<le> int_of_uint64 x + int_of_uint64 x'\n\ngoal (2 subgoals):\n 1. int_of_uint64 pp\n    \\<le> int_of_uint64 x + int_of_uint64 x' \\<Longrightarrow>\n    urel64 (plus_p64 pp x x') (plus_p p y y')\n 2. \\<not> int_of_uint64 pp\n           \\<le> int_of_uint64 x + int_of_uint64 x' \\<Longrightarrow>\n    urel64 (plus_p64 pp x x') (plus_p p y y')", "hence True: \"(?p \\<le> ?x + ?x') = True\""], ["proof (prove)\nusing this:\n  int_of_uint64 pp \\<le> int_of_uint64 x + int_of_uint64 x'\n\ngoal (1 subgoal):\n 1. (int_of_uint64 pp \\<le> int_of_uint64 x + int_of_uint64 x') = True", "by simp"], ["proof (state)\nthis:\n  (int_of_uint64 pp \\<le> int_of_uint64 x + int_of_uint64 x') = True\n\ngoal (2 subgoals):\n 1. int_of_uint64 pp\n    \\<le> int_of_uint64 x + int_of_uint64 x' \\<Longrightarrow>\n    urel64 (plus_p64 pp x x') (plus_p p y y')\n 2. \\<not> int_of_uint64 pp\n           \\<le> int_of_uint64 x + int_of_uint64 x' \\<Longrightarrow>\n    urel64 (plus_p64 pp x x') (plus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (plus_p64 pp x x') (plus_p p y y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (plus_p64 pp x x')\n     (plus_p p (int_of_uint64 x) (int_of_uint64 x'))", "using small rel"], ["proof (prove)\nusing this:\n  p \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel64 (plus_p64 pp x x')\n     (plus_p p (int_of_uint64 x) (int_of_uint64 x'))", "unfolding plus_p64_def plus_p_def Let_def urel64_def"], ["proof (prove)\nusing this:\n  p \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> p\n\ngoal (1 subgoal):\n 1. (if p \\<le> int_of_uint64 x + int_of_uint64 x'\n     then int_of_uint64 x + int_of_uint64 x' - p\n     else int_of_uint64 x + int_of_uint64 x') =\n    int_of_uint64 (if pp \\<le> x + x' then x + x' - pp else x + x') \\<and>\n    (if p \\<le> int_of_uint64 x + int_of_uint64 x'\n     then int_of_uint64 x + int_of_uint64 x' - p\n     else int_of_uint64 x + int_of_uint64 x')\n    < p", "unfolding ppp le True if_True"], ["proof (prove)\nusing this:\n  int_of_uint64 pp \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < int_of_uint64 pp\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> int_of_uint64 pp\n\ngoal (1 subgoal):\n 1. int_of_uint64 x + int_of_uint64 x' - int_of_uint64 pp =\n    int_of_uint64 (x + x' - pp) \\<and>\n    int_of_uint64 x + int_of_uint64 x' - int_of_uint64 pp < int_of_uint64 pp", "using True"], ["proof (prove)\nusing this:\n  int_of_uint64 pp \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < int_of_uint64 pp\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> int_of_uint64 pp\n  (int_of_uint64 pp \\<le> int_of_uint64 x + int_of_uint64 x') = True\n\ngoal (1 subgoal):\n 1. int_of_uint64 x + int_of_uint64 x' - int_of_uint64 pp =\n    int_of_uint64 (x + x' - pp) \\<and>\n    int_of_uint64 x + int_of_uint64 x' - int_of_uint64 pp < int_of_uint64 pp", "by (auto simp: uint64_simps)"], ["proof (state)\nthis:\n  urel64 (plus_p64 pp x x') (plus_p p y y')\n\ngoal (1 subgoal):\n 1. \\<not> int_of_uint64 pp\n           \\<le> int_of_uint64 x + int_of_uint64 x' \\<Longrightarrow>\n    urel64 (plus_p64 pp x x') (plus_p p y y')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> int_of_uint64 pp\n           \\<le> int_of_uint64 x + int_of_uint64 x' \\<Longrightarrow>\n    urel64 (plus_p64 pp x x') (plus_p p y y')", "case False"], ["proof (state)\nthis:\n  \\<not> int_of_uint64 pp \\<le> int_of_uint64 x + int_of_uint64 x'\n\ngoal (1 subgoal):\n 1. \\<not> int_of_uint64 pp\n           \\<le> int_of_uint64 x + int_of_uint64 x' \\<Longrightarrow>\n    urel64 (plus_p64 pp x x') (plus_p p y y')", "hence False: \"(?p \\<le> ?x + ?x') = False\""], ["proof (prove)\nusing this:\n  \\<not> int_of_uint64 pp \\<le> int_of_uint64 x + int_of_uint64 x'\n\ngoal (1 subgoal):\n 1. (int_of_uint64 pp \\<le> int_of_uint64 x + int_of_uint64 x') = False", "by simp"], ["proof (state)\nthis:\n  (int_of_uint64 pp \\<le> int_of_uint64 x + int_of_uint64 x') = False\n\ngoal (1 subgoal):\n 1. \\<not> int_of_uint64 pp\n           \\<le> int_of_uint64 x + int_of_uint64 x' \\<Longrightarrow>\n    urel64 (plus_p64 pp x x') (plus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (plus_p64 pp x x') (plus_p p y y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (plus_p64 pp x x')\n     (plus_p p (int_of_uint64 x) (int_of_uint64 x'))", "using small rel"], ["proof (prove)\nusing this:\n  p \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel64 (plus_p64 pp x x')\n     (plus_p p (int_of_uint64 x) (int_of_uint64 x'))", "unfolding plus_p64_def plus_p_def Let_def urel64_def"], ["proof (prove)\nusing this:\n  p \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> p\n\ngoal (1 subgoal):\n 1. (if p \\<le> int_of_uint64 x + int_of_uint64 x'\n     then int_of_uint64 x + int_of_uint64 x' - p\n     else int_of_uint64 x + int_of_uint64 x') =\n    int_of_uint64 (if pp \\<le> x + x' then x + x' - pp else x + x') \\<and>\n    (if p \\<le> int_of_uint64 x + int_of_uint64 x'\n     then int_of_uint64 x + int_of_uint64 x' - p\n     else int_of_uint64 x + int_of_uint64 x')\n    < p", "unfolding ppp le False if_False"], ["proof (prove)\nusing this:\n  int_of_uint64 pp \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < int_of_uint64 pp\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> int_of_uint64 pp\n\ngoal (1 subgoal):\n 1. int_of_uint64 x + int_of_uint64 x' = int_of_uint64 (x + x') \\<and>\n    int_of_uint64 x + int_of_uint64 x' < int_of_uint64 pp", "using False"], ["proof (prove)\nusing this:\n  int_of_uint64 pp \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < int_of_uint64 pp\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> int_of_uint64 pp\n  (int_of_uint64 pp \\<le> int_of_uint64 x + int_of_uint64 x') = False\n\ngoal (1 subgoal):\n 1. int_of_uint64 x + int_of_uint64 x' = int_of_uint64 (x + x') \\<and>\n    int_of_uint64 x + int_of_uint64 x' < int_of_uint64 pp", "by (auto simp: uint64_simps)"], ["proof (state)\nthis:\n  urel64 (plus_p64 pp x x') (plus_p p y y')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  urel64 (plus_p64 pp x x') (plus_p p y y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel64_minus: assumes \"urel64 x y\" \"urel64 x' y'\"\n  shows \"urel64 (minus_p64 pp x x') (minus_p p y y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (minus_p64 pp x x') (minus_p p y y')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. urel64 (minus_p64 pp x x') (minus_p p y y')", "let ?x = \"int_of_uint64 x\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel64 (minus_p64 pp x x') (minus_p p y y')", "let ?x' = \"int_of_uint64 x'\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel64 (minus_p64 pp x x') (minus_p p y y')", "from assms int_of_uint64_ge_0"], ["proof (chain)\npicking this:\n  urel64 x y\n  urel64 x' y'\n  0 \\<le> int_of_uint64 ?n", "have id: \"y = ?x\" \"y' = ?x'\" \n    and rel: \"0 \\<le> ?x\" \"?x < p\" \n      \"0 \\<le> ?x'\" \"?x' \\<le> p\""], ["proof (prove)\nusing this:\n  urel64 x y\n  urel64 x' y'\n  0 \\<le> int_of_uint64 ?n\n\ngoal (1 subgoal):\n 1. (y = int_of_uint64 x &&& y' = int_of_uint64 x') &&&\n    (0 \\<le> int_of_uint64 x &&& int_of_uint64 x < p) &&&\n    0 \\<le> int_of_uint64 x' &&& int_of_uint64 x' \\<le> p", "unfolding urel64_def"], ["proof (prove)\nusing this:\n  y = int_of_uint64 x \\<and> y < p\n  y' = int_of_uint64 x' \\<and> y' < p\n  0 \\<le> int_of_uint64 ?n\n\ngoal (1 subgoal):\n 1. (y = int_of_uint64 x &&& y' = int_of_uint64 x') &&&\n    (0 \\<le> int_of_uint64 x &&& int_of_uint64 x < p) &&&\n    0 \\<le> int_of_uint64 x' &&& int_of_uint64 x' \\<le> p", "by auto"], ["proof (state)\nthis:\n  y = int_of_uint64 x\n  y' = int_of_uint64 x'\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel64 (minus_p64 pp x x') (minus_p p y y')", "have le: \"(x' \\<le> x) = (?x' \\<le> ?x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x' \\<le> x) = (int_of_uint64 x' \\<le> int_of_uint64 x)", "unfolding le_int_of_uint64"], ["proof (prove)\ngoal (1 subgoal):\n 1. (int_of_uint64 x' \\<le> int_of_uint64 x) =\n    (int_of_uint64 x' \\<le> int_of_uint64 x)", "using rel small"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> p\n  p \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. (int_of_uint64 x' \\<le> int_of_uint64 x) =\n    (int_of_uint64 x' \\<le> int_of_uint64 x)", "by (auto simp: uint64_simps)"], ["proof (state)\nthis:\n  (x' \\<le> x) = (int_of_uint64 x' \\<le> int_of_uint64 x)\n\ngoal (1 subgoal):\n 1. urel64 (minus_p64 pp x x') (minus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (minus_p64 pp x x') (minus_p p y y')", "proof (cases \"?x' \\<le> ?x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. int_of_uint64 x' \\<le> int_of_uint64 x \\<Longrightarrow>\n    urel64 (minus_p64 pp x x') (minus_p p y y')\n 2. \\<not> int_of_uint64 x' \\<le> int_of_uint64 x \\<Longrightarrow>\n    urel64 (minus_p64 pp x x') (minus_p p y y')", "case True"], ["proof (state)\nthis:\n  int_of_uint64 x' \\<le> int_of_uint64 x\n\ngoal (2 subgoals):\n 1. int_of_uint64 x' \\<le> int_of_uint64 x \\<Longrightarrow>\n    urel64 (minus_p64 pp x x') (minus_p p y y')\n 2. \\<not> int_of_uint64 x' \\<le> int_of_uint64 x \\<Longrightarrow>\n    urel64 (minus_p64 pp x x') (minus_p p y y')", "hence True: \"(?x' \\<le> ?x) = True\""], ["proof (prove)\nusing this:\n  int_of_uint64 x' \\<le> int_of_uint64 x\n\ngoal (1 subgoal):\n 1. (int_of_uint64 x' \\<le> int_of_uint64 x) = True", "by simp"], ["proof (state)\nthis:\n  (int_of_uint64 x' \\<le> int_of_uint64 x) = True\n\ngoal (2 subgoals):\n 1. int_of_uint64 x' \\<le> int_of_uint64 x \\<Longrightarrow>\n    urel64 (minus_p64 pp x x') (minus_p p y y')\n 2. \\<not> int_of_uint64 x' \\<le> int_of_uint64 x \\<Longrightarrow>\n    urel64 (minus_p64 pp x x') (minus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (minus_p64 pp x x') (minus_p p y y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (minus_p64 pp x x')\n     (minus_p p (int_of_uint64 x) (int_of_uint64 x'))", "using small rel"], ["proof (prove)\nusing this:\n  p \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel64 (minus_p64 pp x x')\n     (minus_p p (int_of_uint64 x) (int_of_uint64 x'))", "unfolding minus_p64_def minus_p_def Let_def urel64_def"], ["proof (prove)\nusing this:\n  p \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> p\n\ngoal (1 subgoal):\n 1. (if int_of_uint64 x' \\<le> int_of_uint64 x\n     then int_of_uint64 x - int_of_uint64 x'\n     else int_of_uint64 x + p - int_of_uint64 x') =\n    int_of_uint64 (if x' \\<le> x then x - x' else x + pp - x') \\<and>\n    (if int_of_uint64 x' \\<le> int_of_uint64 x\n     then int_of_uint64 x - int_of_uint64 x'\n     else int_of_uint64 x + p - int_of_uint64 x')\n    < p", "unfolding ppp le True if_True"], ["proof (prove)\nusing this:\n  int_of_uint64 pp \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < int_of_uint64 pp\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> int_of_uint64 pp\n\ngoal (1 subgoal):\n 1. int_of_uint64 x - int_of_uint64 x' = int_of_uint64 (x - x') \\<and>\n    int_of_uint64 x - int_of_uint64 x' < int_of_uint64 pp", "using True"], ["proof (prove)\nusing this:\n  int_of_uint64 pp \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < int_of_uint64 pp\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> int_of_uint64 pp\n  (int_of_uint64 x' \\<le> int_of_uint64 x) = True\n\ngoal (1 subgoal):\n 1. int_of_uint64 x - int_of_uint64 x' = int_of_uint64 (x - x') \\<and>\n    int_of_uint64 x - int_of_uint64 x' < int_of_uint64 pp", "by (auto simp: uint64_simps)"], ["proof (state)\nthis:\n  urel64 (minus_p64 pp x x') (minus_p p y y')\n\ngoal (1 subgoal):\n 1. \\<not> int_of_uint64 x' \\<le> int_of_uint64 x \\<Longrightarrow>\n    urel64 (minus_p64 pp x x') (minus_p p y y')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> int_of_uint64 x' \\<le> int_of_uint64 x \\<Longrightarrow>\n    urel64 (minus_p64 pp x x') (minus_p p y y')", "case False"], ["proof (state)\nthis:\n  \\<not> int_of_uint64 x' \\<le> int_of_uint64 x\n\ngoal (1 subgoal):\n 1. \\<not> int_of_uint64 x' \\<le> int_of_uint64 x \\<Longrightarrow>\n    urel64 (minus_p64 pp x x') (minus_p p y y')", "hence False: \"(?x' \\<le> ?x) = False\""], ["proof (prove)\nusing this:\n  \\<not> int_of_uint64 x' \\<le> int_of_uint64 x\n\ngoal (1 subgoal):\n 1. (int_of_uint64 x' \\<le> int_of_uint64 x) = False", "by simp"], ["proof (state)\nthis:\n  (int_of_uint64 x' \\<le> int_of_uint64 x) = False\n\ngoal (1 subgoal):\n 1. \\<not> int_of_uint64 x' \\<le> int_of_uint64 x \\<Longrightarrow>\n    urel64 (minus_p64 pp x x') (minus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (minus_p64 pp x x') (minus_p p y y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (minus_p64 pp x x')\n     (minus_p p (int_of_uint64 x) (int_of_uint64 x'))", "using small rel"], ["proof (prove)\nusing this:\n  p \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel64 (minus_p64 pp x x')\n     (minus_p p (int_of_uint64 x) (int_of_uint64 x'))", "unfolding minus_p64_def minus_p_def Let_def urel64_def"], ["proof (prove)\nusing this:\n  p \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> p\n\ngoal (1 subgoal):\n 1. (if int_of_uint64 x' \\<le> int_of_uint64 x\n     then int_of_uint64 x - int_of_uint64 x'\n     else int_of_uint64 x + p - int_of_uint64 x') =\n    int_of_uint64 (if x' \\<le> x then x - x' else x + pp - x') \\<and>\n    (if int_of_uint64 x' \\<le> int_of_uint64 x\n     then int_of_uint64 x - int_of_uint64 x'\n     else int_of_uint64 x + p - int_of_uint64 x')\n    < p", "unfolding ppp le False if_False"], ["proof (prove)\nusing this:\n  int_of_uint64 pp \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < int_of_uint64 pp\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> int_of_uint64 pp\n\ngoal (1 subgoal):\n 1. int_of_uint64 x + int_of_uint64 pp - int_of_uint64 x' =\n    int_of_uint64 (x + pp - x') \\<and>\n    int_of_uint64 x + int_of_uint64 pp - int_of_uint64 x' < int_of_uint64 pp", "using False"], ["proof (prove)\nusing this:\n  int_of_uint64 pp \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < int_of_uint64 pp\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' \\<le> int_of_uint64 pp\n  (int_of_uint64 x' \\<le> int_of_uint64 x) = False\n\ngoal (1 subgoal):\n 1. int_of_uint64 x + int_of_uint64 pp - int_of_uint64 x' =\n    int_of_uint64 (x + pp - x') \\<and>\n    int_of_uint64 x + int_of_uint64 pp - int_of_uint64 x' < int_of_uint64 pp", "by (auto simp: uint64_simps)"], ["proof (state)\nthis:\n  urel64 (minus_p64 pp x x') (minus_p p y y')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  urel64 (minus_p64 pp x x') (minus_p p y y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel64_uminus: assumes \"urel64 x y\"\n  shows \"urel64 (uminus_p64 pp x) (uminus_p p y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (uminus_p64 pp x) (uminus_p p y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. urel64 (uminus_p64 pp x) (uminus_p p y)", "let ?x = \"int_of_uint64 x\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel64 (uminus_p64 pp x) (uminus_p p y)", "from assms int_of_uint64_ge_0"], ["proof (chain)\npicking this:\n  urel64 x y\n  0 \\<le> int_of_uint64 ?n", "have id: \"y = ?x\" \n    and rel: \"0 \\<le> ?x\" \"?x < p\""], ["proof (prove)\nusing this:\n  urel64 x y\n  0 \\<le> int_of_uint64 ?n\n\ngoal (1 subgoal):\n 1. y = int_of_uint64 x &&& 0 \\<le> int_of_uint64 x &&& int_of_uint64 x < p", "unfolding urel64_def"], ["proof (prove)\nusing this:\n  y = int_of_uint64 x \\<and> y < p\n  0 \\<le> int_of_uint64 ?n\n\ngoal (1 subgoal):\n 1. y = int_of_uint64 x &&& 0 \\<le> int_of_uint64 x &&& int_of_uint64 x < p", "by auto"], ["proof (state)\nthis:\n  y = int_of_uint64 x\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n\ngoal (1 subgoal):\n 1. urel64 (uminus_p64 pp x) (uminus_p p y)", "have le: \"(x = 0) = (?x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = 0) = (int_of_uint64 x = 0)", "unfolding int_of_uint64_0_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = 0) = (x = 0)", "using rel small"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  p \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. (x = 0) = (x = 0)", "by (auto simp: uint64_simps)"], ["proof (state)\nthis:\n  (x = 0) = (int_of_uint64 x = 0)\n\ngoal (1 subgoal):\n 1. urel64 (uminus_p64 pp x) (uminus_p p y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (uminus_p64 pp x) (uminus_p p y)", "proof (cases \"?x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. int_of_uint64 x = 0 \\<Longrightarrow>\n    urel64 (uminus_p64 pp x) (uminus_p p y)\n 2. int_of_uint64 x \\<noteq> 0 \\<Longrightarrow>\n    urel64 (uminus_p64 pp x) (uminus_p p y)", "case True"], ["proof (state)\nthis:\n  int_of_uint64 x = 0\n\ngoal (2 subgoals):\n 1. int_of_uint64 x = 0 \\<Longrightarrow>\n    urel64 (uminus_p64 pp x) (uminus_p p y)\n 2. int_of_uint64 x \\<noteq> 0 \\<Longrightarrow>\n    urel64 (uminus_p64 pp x) (uminus_p p y)", "hence True: \"(?x = 0) = True\""], ["proof (prove)\nusing this:\n  int_of_uint64 x = 0\n\ngoal (1 subgoal):\n 1. (int_of_uint64 x = 0) = True", "by simp"], ["proof (state)\nthis:\n  (int_of_uint64 x = 0) = True\n\ngoal (2 subgoals):\n 1. int_of_uint64 x = 0 \\<Longrightarrow>\n    urel64 (uminus_p64 pp x) (uminus_p p y)\n 2. int_of_uint64 x \\<noteq> 0 \\<Longrightarrow>\n    urel64 (uminus_p64 pp x) (uminus_p p y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (uminus_p64 pp x) (uminus_p p y)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (uminus_p64 pp x) (uminus_p p (int_of_uint64 x))", "using small rel"], ["proof (prove)\nusing this:\n  p \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n\ngoal (1 subgoal):\n 1. urel64 (uminus_p64 pp x) (uminus_p p (int_of_uint64 x))", "unfolding uminus_p64_def uminus_p_def Let_def urel64_def"], ["proof (prove)\nusing this:\n  p \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n\ngoal (1 subgoal):\n 1. (if int_of_uint64 x = 0 then 0 else p - int_of_uint64 x) =\n    int_of_uint64 (if x = 0 then 0 else pp - x) \\<and>\n    (if int_of_uint64 x = 0 then 0 else p - int_of_uint64 x) < p", "unfolding ppp le True if_True"], ["proof (prove)\nusing this:\n  int_of_uint64 pp \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < int_of_uint64 pp\n\ngoal (1 subgoal):\n 1. 0 = int_of_uint64 0 \\<and> 0 < int_of_uint64 pp", "using True"], ["proof (prove)\nusing this:\n  int_of_uint64 pp \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < int_of_uint64 pp\n  (int_of_uint64 x = 0) = True\n\ngoal (1 subgoal):\n 1. 0 = int_of_uint64 0 \\<and> 0 < int_of_uint64 pp", "by (auto simp: uint64_simps)"], ["proof (state)\nthis:\n  urel64 (uminus_p64 pp x) (uminus_p p y)\n\ngoal (1 subgoal):\n 1. int_of_uint64 x \\<noteq> 0 \\<Longrightarrow>\n    urel64 (uminus_p64 pp x) (uminus_p p y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. int_of_uint64 x \\<noteq> 0 \\<Longrightarrow>\n    urel64 (uminus_p64 pp x) (uminus_p p y)", "case False"], ["proof (state)\nthis:\n  int_of_uint64 x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int_of_uint64 x \\<noteq> 0 \\<Longrightarrow>\n    urel64 (uminus_p64 pp x) (uminus_p p y)", "hence False: \"(?x = 0) = False\""], ["proof (prove)\nusing this:\n  int_of_uint64 x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (int_of_uint64 x = 0) = False", "by simp"], ["proof (state)\nthis:\n  (int_of_uint64 x = 0) = False\n\ngoal (1 subgoal):\n 1. int_of_uint64 x \\<noteq> 0 \\<Longrightarrow>\n    urel64 (uminus_p64 pp x) (uminus_p p y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (uminus_p64 pp x) (uminus_p p y)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (uminus_p64 pp x) (uminus_p p (int_of_uint64 x))", "using small rel"], ["proof (prove)\nusing this:\n  p \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n\ngoal (1 subgoal):\n 1. urel64 (uminus_p64 pp x) (uminus_p p (int_of_uint64 x))", "unfolding uminus_p64_def uminus_p_def Let_def urel64_def"], ["proof (prove)\nusing this:\n  p \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n\ngoal (1 subgoal):\n 1. (if int_of_uint64 x = 0 then 0 else p - int_of_uint64 x) =\n    int_of_uint64 (if x = 0 then 0 else pp - x) \\<and>\n    (if int_of_uint64 x = 0 then 0 else p - int_of_uint64 x) < p", "unfolding ppp le False if_False"], ["proof (prove)\nusing this:\n  int_of_uint64 pp \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < int_of_uint64 pp\n\ngoal (1 subgoal):\n 1. int_of_uint64 pp - int_of_uint64 x = int_of_uint64 (pp - x) \\<and>\n    int_of_uint64 pp - int_of_uint64 x < int_of_uint64 pp", "using False"], ["proof (prove)\nusing this:\n  int_of_uint64 pp \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < int_of_uint64 pp\n  (int_of_uint64 x = 0) = False\n\ngoal (1 subgoal):\n 1. int_of_uint64 pp - int_of_uint64 x = int_of_uint64 (pp - x) \\<and>\n    int_of_uint64 pp - int_of_uint64 x < int_of_uint64 pp", "by (auto simp: uint64_simps)"], ["proof (state)\nthis:\n  urel64 (uminus_p64 pp x) (uminus_p p y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  urel64 (uminus_p64 pp x) (uminus_p p y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel64_mult: assumes \"urel64 x y\" \"urel64 x' y'\"\n  shows \"urel64 (mult_p64 pp x x') (mult_p p y y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (mult_p64 pp x x') (mult_p p y y')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. urel64 (mult_p64 pp x x') (mult_p p y y')", "let ?x = \"int_of_uint64 x\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel64 (mult_p64 pp x x') (mult_p p y y')", "let ?x' = \"int_of_uint64 x'\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel64 (mult_p64 pp x x') (mult_p p y y')", "from assms int_of_uint64_ge_0"], ["proof (chain)\npicking this:\n  urel64 x y\n  urel64 x' y'\n  0 \\<le> int_of_uint64 ?n", "have id: \"y = ?x\" \"y' = ?x'\" \n    and rel: \"0 \\<le> ?x\" \"?x < p\" \n      \"0 \\<le> ?x'\" \"?x' < p\""], ["proof (prove)\nusing this:\n  urel64 x y\n  urel64 x' y'\n  0 \\<le> int_of_uint64 ?n\n\ngoal (1 subgoal):\n 1. (y = int_of_uint64 x &&& y' = int_of_uint64 x') &&&\n    (0 \\<le> int_of_uint64 x &&& int_of_uint64 x < p) &&&\n    0 \\<le> int_of_uint64 x' &&& int_of_uint64 x' < p", "unfolding urel64_def"], ["proof (prove)\nusing this:\n  y = int_of_uint64 x \\<and> y < p\n  y' = int_of_uint64 x' \\<and> y' < p\n  0 \\<le> int_of_uint64 ?n\n\ngoal (1 subgoal):\n 1. (y = int_of_uint64 x &&& y' = int_of_uint64 x') &&&\n    (0 \\<le> int_of_uint64 x &&& int_of_uint64 x < p) &&&\n    0 \\<le> int_of_uint64 x' &&& int_of_uint64 x' < p", "by auto"], ["proof (state)\nthis:\n  y = int_of_uint64 x\n  y' = int_of_uint64 x'\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' < p\n\ngoal (1 subgoal):\n 1. urel64 (mult_p64 pp x x') (mult_p p y y')", "from rel"], ["proof (chain)\npicking this:\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' < p", "have \"?x * ?x' < p * p\""], ["proof (prove)\nusing this:\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' < p\n\ngoal (1 subgoal):\n 1. int_of_uint64 x * int_of_uint64 x' < p * p", "by (metis mult_strict_mono')"], ["proof (state)\nthis:\n  int_of_uint64 x * int_of_uint64 x' < p * p\n\ngoal (1 subgoal):\n 1. urel64 (mult_p64 pp x x') (mult_p p y y')", "also"], ["proof (state)\nthis:\n  int_of_uint64 x * int_of_uint64 x' < p * p\n\ngoal (1 subgoal):\n 1. urel64 (mult_p64 pp x x') (mult_p p y y')", "have \"\\<dots> \\<le> 4294967296 * 4294967296\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * p \\<le> 4294967296 * 4294967296", "by (rule mult_mono, insert p2 small, auto)"], ["proof (state)\nthis:\n  p * p \\<le> 4294967296 * 4294967296\n\ngoal (1 subgoal):\n 1. urel64 (mult_p64 pp x x') (mult_p p y y')", "finally"], ["proof (chain)\npicking this:\n  int_of_uint64 x * int_of_uint64 x' < 4294967296 * 4294967296", "have le: \"?x * ?x' < 18446744073709551616\""], ["proof (prove)\nusing this:\n  int_of_uint64 x * int_of_uint64 x' < 4294967296 * 4294967296\n\ngoal (1 subgoal):\n 1. int_of_uint64 x * int_of_uint64 x' < 18446744073709551616", "by simp"], ["proof (state)\nthis:\n  int_of_uint64 x * int_of_uint64 x' < 18446744073709551616\n\ngoal (1 subgoal):\n 1. urel64 (mult_p64 pp x x') (mult_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (mult_p64 pp x x') (mult_p p y y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (mult_p64 pp x x')\n     (mult_p p (int_of_uint64 x) (int_of_uint64 x'))", "using small rel"], ["proof (prove)\nusing this:\n  p \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' < p\n\ngoal (1 subgoal):\n 1. urel64 (mult_p64 pp x x')\n     (mult_p p (int_of_uint64 x) (int_of_uint64 x'))", "unfolding mult_p64_def mult_p_def Let_def urel64_def"], ["proof (prove)\nusing this:\n  p \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < p\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' < p\n\ngoal (1 subgoal):\n 1. mod_nonneg_pos_int (int_of_uint64 x * int_of_uint64 x') p =\n    int_of_uint64 (x * x' mod pp) \\<and>\n    mod_nonneg_pos_int (int_of_uint64 x * int_of_uint64 x') p < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  int_of_uint64 pp \\<le> 4294967295\n  0 \\<le> int_of_uint64 x\n  int_of_uint64 x < int_of_uint64 pp\n  0 \\<le> int_of_uint64 x'\n  int_of_uint64 x' < int_of_uint64 pp\n\ngoal (1 subgoal):\n 1. mod_nonneg_pos_int (int_of_uint64 x * int_of_uint64 x')\n     (int_of_uint64 pp) =\n    int_of_uint64 (x * x' mod pp) \\<and>\n    mod_nonneg_pos_int (int_of_uint64 x * int_of_uint64 x')\n     (int_of_uint64 pp)\n    < int_of_uint64 pp", "by (auto simp: uint64_simps, unfold int_of_uint64_mod int_of_uint64_mult, \n        subst mod_pos_pos_trivial[of _ 18446744073709551616], insert le, auto)"], ["proof (state)\nthis:\n  urel64 (mult_p64 pp x x') (mult_p p y y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel64_eq: assumes \"urel64 x y\" \"urel64 x' y'\" \n  shows \"(x = x') = (y = y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "let ?x = \"int_of_uint64 x\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "let ?x' = \"int_of_uint64 x'\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "from assms int_of_uint64_ge_0"], ["proof (chain)\npicking this:\n  urel64 x y\n  urel64 x' y'\n  0 \\<le> int_of_uint64 ?n", "have id: \"y = ?x\" \"y' = ?x'\""], ["proof (prove)\nusing this:\n  urel64 x y\n  urel64 x' y'\n  0 \\<le> int_of_uint64 ?n\n\ngoal (1 subgoal):\n 1. y = int_of_uint64 x &&& y' = int_of_uint64 x'", "unfolding urel64_def"], ["proof (prove)\nusing this:\n  y = int_of_uint64 x \\<and> y < p\n  y' = int_of_uint64 x' \\<and> y' < p\n  0 \\<le> int_of_uint64 ?n\n\ngoal (1 subgoal):\n 1. y = int_of_uint64 x &&& y' = int_of_uint64 x'", "by auto"], ["proof (state)\nthis:\n  y = int_of_uint64 x\n  y' = int_of_uint64 x'\n\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = x') = (int_of_uint64 x = int_of_uint64 x')", "by (transfer, transfer) rule"], ["proof (state)\nthis:\n  (x = x') = (y = y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel64_normalize: \nassumes x: \"urel64 x y\"\nshows \"urel64 (if x = 0 then 0 else 1) (if y = 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (if x = 0 then 0 else 1) (if y = 0 then 0 else 1)", "unfolding urel64_eq[OF x urel64_0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (if y = 0 then 0 else 1) (if y = 0 then 0 else 1)", "using urel64_0 urel64_1"], ["proof (prove)\nusing this:\n  urel64 0 0\n  urel64 1 1\n\ngoal (1 subgoal):\n 1. urel64 (if y = 0 then 0 else 1) (if y = 0 then 0 else 1)", "by auto"], ["", "lemma urel64_mod: \nassumes x: \"urel64 x x'\" and y: \"urel64 y y'\" \nshows \"urel64 (if y = 0 then x else 0) (if y' = 0 then x' else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (if y = 0 then x else 0) (if y' = 0 then x' else 0)", "unfolding urel64_eq[OF y urel64_0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (if y' = 0 then x else 0) (if y' = 0 then x' else 0)", "using urel64_0 x"], ["proof (prove)\nusing this:\n  urel64 0 0\n  urel64 x x'\n\ngoal (1 subgoal):\n 1. urel64 (if y' = 0 then x else 0) (if y' = 0 then x' else 0)", "by auto"], ["", "lemma urel64_power: \"urel64 x x' \\<Longrightarrow> urel64 y (int y') \\<Longrightarrow> urel64 (power_p64 pp x y) (power_p p x' y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>urel64 x x'; urel64 y (int y')\\<rbrakk>\n    \\<Longrightarrow> urel64 (power_p64 pp x y) (power_p p x' y')", "proof (induct x' y' arbitrary: x y rule: power_p.induct[of _ p])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x n xa y.\n       \\<lbrakk>\\<And>xa xb y xc ya.\n                   \\<lbrakk>n \\<noteq> 0; xa = divmod_nat n 2; (xb, y) = xa;\n                    urel64 xc (mult_p p x x); urel64 ya (int xb)\\<rbrakk>\n                   \\<Longrightarrow> urel64 (power_p64 pp xc ya)\n(power_p p (mult_p p x x) xb);\n        urel64 xa x; urel64 y (int n)\\<rbrakk>\n       \\<Longrightarrow> urel64 (power_p64 pp xa y) (power_p p x n)", "case (1 x' y' x y)"], ["proof (state)\nthis:\n  \\<lbrakk>y' \\<noteq> 0; ?xa = divmod_nat y' 2; (?xb, ?y) = ?xa;\n   urel64 ?x (mult_p p x' x'); urel64 ?ya (int ?xb)\\<rbrakk>\n  \\<Longrightarrow> urel64 (power_p64 pp ?x ?ya)\n                     (power_p p (mult_p p x' x') ?xb)\n  urel64 x x'\n  urel64 y (int y')\n\ngoal (1 subgoal):\n 1. \\<And>x n xa y.\n       \\<lbrakk>\\<And>xa xb y xc ya.\n                   \\<lbrakk>n \\<noteq> 0; xa = divmod_nat n 2; (xb, y) = xa;\n                    urel64 xc (mult_p p x x); urel64 ya (int xb)\\<rbrakk>\n                   \\<Longrightarrow> urel64 (power_p64 pp xc ya)\n(power_p p (mult_p p x x) xb);\n        urel64 xa x; urel64 y (int n)\\<rbrakk>\n       \\<Longrightarrow> urel64 (power_p64 pp xa y) (power_p p x n)", "note x = 1(2)"], ["proof (state)\nthis:\n  urel64 x x'\n\ngoal (1 subgoal):\n 1. \\<And>x n xa y.\n       \\<lbrakk>\\<And>xa xb y xc ya.\n                   \\<lbrakk>n \\<noteq> 0; xa = divmod_nat n 2; (xb, y) = xa;\n                    urel64 xc (mult_p p x x); urel64 ya (int xb)\\<rbrakk>\n                   \\<Longrightarrow> urel64 (power_p64 pp xc ya)\n(power_p p (mult_p p x x) xb);\n        urel64 xa x; urel64 y (int n)\\<rbrakk>\n       \\<Longrightarrow> urel64 (power_p64 pp xa y) (power_p p x n)", "note y = 1(3)"], ["proof (state)\nthis:\n  urel64 y (int y')\n\ngoal (1 subgoal):\n 1. \\<And>x n xa y.\n       \\<lbrakk>\\<And>xa xb y xc ya.\n                   \\<lbrakk>n \\<noteq> 0; xa = divmod_nat n 2; (xb, y) = xa;\n                    urel64 xc (mult_p p x x); urel64 ya (int xb)\\<rbrakk>\n                   \\<Longrightarrow> urel64 (power_p64 pp xc ya)\n(power_p p (mult_p p x x) xb);\n        urel64 xa x; urel64 y (int n)\\<rbrakk>\n       \\<Longrightarrow> urel64 (power_p64 pp xa y) (power_p p x n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (power_p64 pp x y) (power_p p x' y')", "proof (cases \"y' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y' = 0 \\<Longrightarrow> urel64 (power_p64 pp x y) (power_p p x' y')\n 2. y' \\<noteq> 0 \\<Longrightarrow>\n    urel64 (power_p64 pp x y) (power_p p x' y')", "case True"], ["proof (state)\nthis:\n  y' = 0\n\ngoal (2 subgoals):\n 1. y' = 0 \\<Longrightarrow> urel64 (power_p64 pp x y) (power_p p x' y')\n 2. y' \\<noteq> 0 \\<Longrightarrow>\n    urel64 (power_p64 pp x y) (power_p p x' y')", "hence y: \"y = 0\""], ["proof (prove)\nusing this:\n  y' = 0\n\ngoal (1 subgoal):\n 1. y = 0", "using urel64_eq[OF y urel64_0]"], ["proof (prove)\nusing this:\n  y' = 0\n  (y = 0) = (int y' = 0)\n\ngoal (1 subgoal):\n 1. y = 0", "by auto"], ["proof (state)\nthis:\n  y = 0\n\ngoal (2 subgoals):\n 1. y' = 0 \\<Longrightarrow> urel64 (power_p64 pp x y) (power_p p x' y')\n 2. y' \\<noteq> 0 \\<Longrightarrow>\n    urel64 (power_p64 pp x y) (power_p p x' y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (power_p64 pp x y) (power_p p x' y')", "unfolding y True"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (power_p64 pp x 0) (power_p p x' 0)", "by (simp add: power_p.simps urel64_1)"], ["proof (state)\nthis:\n  urel64 (power_p64 pp x y) (power_p p x' y')\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel64 (power_p64 pp x y) (power_p p x' y')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel64 (power_p64 pp x y) (power_p p x' y')", "case False"], ["proof (state)\nthis:\n  y' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel64 (power_p64 pp x y) (power_p p x' y')", "hence id: \"(y = 0) = False\" \"(y' = 0) = False\""], ["proof (prove)\nusing this:\n  y' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (y = 0) = False &&& (y' = 0) = False", "using urel64_eq[OF y urel64_0]"], ["proof (prove)\nusing this:\n  y' \\<noteq> 0\n  (y = 0) = (int y' = 0)\n\ngoal (1 subgoal):\n 1. (y = 0) = False &&& (y' = 0) = False", "by auto"], ["proof (state)\nthis:\n  (y = 0) = False\n  (y' = 0) = False\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel64 (power_p64 pp x y) (power_p p x' y')", "obtain d' r' where dr': \"Divides.divmod_nat y' 2 = (d',r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d' r'.\n        divmod_nat y' 2 = (d', r') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  divmod_nat y' 2 = (d', r')\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel64 (power_p64 pp x y) (power_p p x' y')", "from divmod_nat_def[of y' 2, unfolded dr']"], ["proof (chain)\npicking this:\n  (d', r') = (y' div 2, y' mod 2)", "have r': \"r' = y' mod 2\" and d': \"d' = y' div 2\""], ["proof (prove)\nusing this:\n  (d', r') = (y' div 2, y' mod 2)\n\ngoal (1 subgoal):\n 1. r' = y' mod 2 &&& d' = y' div 2", "by auto"], ["proof (state)\nthis:\n  r' = y' mod 2\n  d' = y' div 2\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel64 (power_p64 pp x y) (power_p p x' y')", "have \"urel64 (y AND 1) r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (y AND 1) (int r')", "unfolding r'"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (y AND 1) (int (y' mod 2))", "using y"], ["proof (prove)\nusing this:\n  urel64 y (int y')\n\ngoal (1 subgoal):\n 1. urel64 (y AND 1) (int (y' mod 2))", "unfolding urel64_def"], ["proof (prove)\nusing this:\n  int y' = int_of_uint64 y \\<and> int y' < p\n\ngoal (1 subgoal):\n 1. int (y' mod 2) = int_of_uint64 (y AND 1) \\<and> int (y' mod 2) < p", "using small"], ["proof (prove)\nusing this:\n  int y' = int_of_uint64 y \\<and> int y' < p\n  p \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. int (y' mod 2) = int_of_uint64 (y AND 1) \\<and> int (y' mod 2) < p", "apply (simp add: ppp and_one_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>int y' = int_of_uint64 y \\<and> int y' < int_of_uint64 pp;\n     int_of_uint64 pp \\<le> 4294967295\\<rbrakk>\n    \\<Longrightarrow> int (y' mod 2) = int_of_uint64 (y mod 2) \\<and>\n                      int (y' mod 2) < int_of_uint64 pp", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y' y pp.\n       \\<lbrakk>int y' = uint y \\<and> int y' < uint pp;\n        uint pp \\<le> 4294967295\\<rbrakk>\n       \\<Longrightarrow> int (y' mod 2) = uint (y mod 2) \\<and>\n                         int (y' mod 2) < uint pp", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y' y pp.\n       \\<lbrakk>int y' = take_bit LENGTH(64) y \\<and>\n                int y' < take_bit LENGTH(64) pp;\n        take_bit LENGTH(64) pp \\<le> 4294967295\\<rbrakk>\n       \\<Longrightarrow> int (y' mod 2) =\n                         take_bit LENGTH(64)\n                          (take_bit LENGTH(64) y mod\n                           take_bit LENGTH(64) 2) \\<and>\n                         int (y' mod 2) < take_bit LENGTH(64) pp", "apply (auto simp add: int_eq_iff nat_take_bit_eq nat_mod_distrib zmod_int)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y pp.\n       \\<lbrakk>take_bit 64 y < take_bit 64 pp;\n        take_bit 64 pp \\<le> 4294967295\\<rbrakk>\n       \\<Longrightarrow> take_bit 64 y mod 2 =\n                         take_bit 64 (take_bit 64 y mod 2)\n 2. \\<And>y pp.\n       \\<lbrakk>take_bit 64 y < take_bit 64 pp;\n        take_bit 64 pp \\<le> 4294967295\\<rbrakk>\n       \\<Longrightarrow> take_bit 64 y mod 2 < take_bit 64 pp", "apply (auto simp add: zmod_int mod_2_eq_odd)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y pp.\n       \\<lbrakk>take_bit 64 y < take_bit 64 pp;\n        take_bit 64 pp \\<le> 4294967295; odd y\\<rbrakk>\n       \\<Longrightarrow> 1 < take_bit 64 pp\n 2. \\<And>y pp.\n       \\<lbrakk>take_bit 64 y < take_bit 64 pp;\n        take_bit 64 pp \\<le> 4294967295; even y\\<rbrakk>\n       \\<Longrightarrow> 0 < take_bit 64 pp", "apply (metis (full_types) even_take_bit_eq le_less_trans odd_iff_mod_2_eq_one take_bit_nonnegative zero_neq_numeral zmod_le_nonneg_dividend)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y pp.\n       \\<lbrakk>take_bit 64 y < take_bit 64 pp;\n        take_bit 64 pp \\<le> 4294967295; even y\\<rbrakk>\n       \\<Longrightarrow> 0 < take_bit 64 pp", "apply (auto simp add: less_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y pp.\n       \\<lbrakk>even y; take_bit 64 y \\<le> 0; take_bit 64 y \\<noteq> 0;\n        take_bit 64 pp = 0\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: le_less)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  urel64 (y AND 1) (int r')\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel64 (power_p64 pp x y) (power_p p x' y')", "from urel64_eq[OF this urel64_0]"], ["proof (chain)\npicking this:\n  (y AND 1 = 0) = (int r' = 0)", "have rem: \"(y AND 1 = 0) = (r' = 0)\""], ["proof (prove)\nusing this:\n  (y AND 1 = 0) = (int r' = 0)\n\ngoal (1 subgoal):\n 1. (y AND 1 = 0) = (r' = 0)", "by simp"], ["proof (state)\nthis:\n  (y AND 1 = 0) = (r' = 0)\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel64 (power_p64 pp x y) (power_p p x' y')", "have div: \"urel64 (shiftr y 1) (int d')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (y >> 1) (int d')", "unfolding d'"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (y >> 1) (int (y' div 2))", "using y"], ["proof (prove)\nusing this:\n  urel64 y (int y')\n\ngoal (1 subgoal):\n 1. urel64 (y >> 1) (int (y' div 2))", "unfolding urel64_def"], ["proof (prove)\nusing this:\n  int y' = int_of_uint64 y \\<and> int y' < p\n\ngoal (1 subgoal):\n 1. int (y' div 2) = int_of_uint64 (y >> 1) \\<and> int (y' div 2) < p", "using small"], ["proof (prove)\nusing this:\n  int y' = int_of_uint64 y \\<and> int y' < p\n  p \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. int (y' div 2) = int_of_uint64 (y >> 1) \\<and> int (y' div 2) < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  int y' = int_of_uint64 y \\<and> int y' < int_of_uint64 pp\n  int_of_uint64 pp \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. int (y' div 2) = int_of_uint64 (y >> 1) \\<and>\n    int (y' div 2) < int_of_uint64 pp", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y' y pp.\n       \\<lbrakk>int y' = uint y \\<and> int y' < uint pp;\n        uint pp \\<le> 4294967295\\<rbrakk>\n       \\<Longrightarrow> int (y' div 2) = uint (drop_bit 1 y) \\<and>\n                         int (y' div 2) < uint pp", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y' y pp.\n       \\<lbrakk>int y' = take_bit LENGTH(64) y \\<and>\n                int y' < take_bit LENGTH(64) pp;\n        take_bit LENGTH(64) pp \\<le> 4294967295\\<rbrakk>\n       \\<Longrightarrow> int (y' div 2) =\n                         take_bit LENGTH(64)\n                          ((drop_bit 1 \\<circ> take_bit LENGTH(64))\n                            y) \\<and>\n                         int (y' div 2) < take_bit LENGTH(64) pp", "apply (auto simp add: drop_bit_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  urel64 (y >> 1) (int d')\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel64 (power_p64 pp x y) (power_p p x' y')", "note IH = 1(1)[OF False refl dr'[symmetric] urel64_mult[OF x x] div]"], ["proof (state)\nthis:\n  urel64 (power_p64 pp (mult_p64 pp x x) (y >> 1))\n   (power_p p (mult_p p x' x') d')\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0 \\<Longrightarrow>\n    urel64 (power_p64 pp x y) (power_p p x' y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (power_p64 pp x y) (power_p p x' y')", "unfolding power_p.simps[of _ _ \"y'\"] power_p64.simps[of _ _ y] dr' id if_False rem"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64\n     (let rec = power_p64 pp (mult_p64 pp x x) (y >> 1)\n      in if r' = 0 then rec else mult_p64 pp rec x)\n     (let (d, r) = (d', r'); rec = power_p p (mult_p p x' x') d\n      in if r = 0 then rec else mult_p p rec x')", "using IH urel64_mult[OF IH x]"], ["proof (prove)\nusing this:\n  urel64 (power_p64 pp (mult_p64 pp x x) (y >> 1))\n   (power_p p (mult_p p x' x') d')\n  urel64 (mult_p64 pp (power_p64 pp (mult_p64 pp x x) (y >> 1)) x)\n   (mult_p p (power_p p (mult_p p x' x') d') x')\n\ngoal (1 subgoal):\n 1. urel64\n     (let rec = power_p64 pp (mult_p64 pp x x) (y >> 1)\n      in if r' = 0 then rec else mult_p64 pp rec x)\n     (let (d, r) = (d', r'); rec = power_p p (mult_p p x' x') d\n      in if r = 0 then rec else mult_p p rec x')", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  urel64 (power_p64 pp x y) (power_p p x' y')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  urel64 (power_p64 pp x y) (power_p p x' y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel64_inverse: assumes x: \"urel64 x x'\" \n  shows \"urel64 (inverse_p64 pp x) (inverse_p p x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (inverse_p64 pp x) (inverse_p p x')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. urel64 (inverse_p64 pp x) (inverse_p p x')", "have p: \"urel64 (pp - 2) (int (nat (p - 2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (pp - 2) (int (nat (p - 2)))", "using p2 small"], ["proof (prove)\nusing this:\n  2 \\<le> p\n  p \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. urel64 (pp - 2) (int (nat (p - 2)))", "unfolding urel64_def"], ["proof (prove)\nusing this:\n  2 \\<le> p\n  p \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. int (nat (p - 2)) = int_of_uint64 (pp - 2) \\<and> int (nat (p - 2)) < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  2 \\<le> int_of_uint64 pp\n  int_of_uint64 pp \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. int (nat (int_of_uint64 pp - 2)) = int_of_uint64 (pp - 2) \\<and>\n    int (nat (int_of_uint64 pp - 2)) < int_of_uint64 pp", "by (transfer, auto simp: uint_word_ariths)"], ["proof (state)\nthis:\n  urel64 (pp - 2) (int (nat (p - 2)))\n\ngoal (1 subgoal):\n 1. urel64 (inverse_p64 pp x) (inverse_p p x')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (inverse_p64 pp x) (inverse_p p x')", "unfolding inverse_p64_def inverse_p_def urel64_eq[OF x urel64_0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 (if x' = 0 then 0 else power_p64 pp x (pp - 2))\n     (if x' = 0 then 0 else power_p p x' (nat (p - 2)))", "using urel64_0 urel64_power[OF x p]"], ["proof (prove)\nusing this:\n  urel64 0 0\n  urel64 (power_p64 pp x (pp - 2)) (power_p p x' (nat (p - 2)))\n\ngoal (1 subgoal):\n 1. urel64 (if x' = 0 then 0 else power_p64 pp x (pp - 2))\n     (if x' = 0 then 0 else power_p p x' (nat (p - 2)))", "by auto"], ["proof (state)\nthis:\n  urel64 (inverse_p64 pp x) (inverse_p p x')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_ring_0_64: \"mod_ring_rel64 0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel64 0 0", "using urel64_0 mod_ring_0"], ["proof (prove)\nusing this:\n  urel64 0 0\n  mod_ring_rel 0 0\n\ngoal (1 subgoal):\n 1. mod_ring_rel64 0 0", "unfolding mod_ring_rel64_def"], ["proof (prove)\nusing this:\n  urel64 0 0\n  mod_ring_rel 0 0\n\ngoal (1 subgoal):\n 1. \\<exists>z. urel64 0 z \\<and> mod_ring_rel z 0", "by blast"], ["", "lemma mod_ring_1_64: \"mod_ring_rel64 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel64 1 1", "using urel64_1 mod_ring_1"], ["proof (prove)\nusing this:\n  urel64 1 1\n  mod_ring_rel 1 1\n\ngoal (1 subgoal):\n 1. mod_ring_rel64 1 1", "unfolding mod_ring_rel64_def"], ["proof (prove)\nusing this:\n  urel64 1 1\n  mod_ring_rel 1 1\n\ngoal (1 subgoal):\n 1. \\<exists>z. urel64 1 z \\<and> mod_ring_rel z 1", "by blast"], ["", "lemma mod_ring_uminus64: \"(mod_ring_rel64 ===> mod_ring_rel64) (uminus_p64 pp) uminus\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64) (uminus_p64 pp) uminus", "using urel64_uminus mod_ring_uminus"], ["proof (prove)\nusing this:\n  urel64 ?x ?y \\<Longrightarrow> urel64 (uminus_p64 pp ?x) (uminus_p p ?y)\n  (mod_ring_rel ===> mod_ring_rel) (uminus_p p) uminus\n\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64) (uminus_p64 pp) uminus", "unfolding mod_ring_rel64_def rel_fun_def"], ["proof (prove)\nusing this:\n  urel64 ?x ?y \\<Longrightarrow> urel64 (uminus_p64 pp ?x) (uminus_p p ?y)\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow> mod_ring_rel (uminus_p p x) (- y)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel64 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<exists>z. urel64 (uminus_p64 pp x) z \\<and> mod_ring_rel z (- y))", "by blast"], ["", "lemma mod_ring_plus64: \"(mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (plus_p64 pp) (+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (plus_p64 pp)\n     (+)", "using urel64_plus mod_ring_plus"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel64 ?x ?y; urel64 ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel64 (plus_p64 pp ?x ?x') (plus_p p ?y ?y')\n  (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (plus_p p) (+)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (plus_p64 pp)\n     (+)", "unfolding mod_ring_rel64_def rel_fun_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel64 ?x ?y; urel64 ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel64 (plus_p64 pp ?x ?x') (plus_p p ?y ?y')\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel xa ya \\<longrightarrow>\n         mod_ring_rel (plus_p p x xa) (y + ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel64 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<exists>z.\n               urel64 xa z \\<and> mod_ring_rel z ya) \\<longrightarrow>\n           (\\<exists>z.\n               urel64 (plus_p64 pp x xa) z \\<and> mod_ring_rel z (y + ya)))", "by blast"], ["", "lemma mod_ring_minus64: \"(mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (minus_p64 pp) (-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (minus_p64 pp)\n     (-)", "using urel64_minus mod_ring_minus"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel64 ?x ?y; urel64 ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel64 (minus_p64 pp ?x ?x') (minus_p p ?y ?y')\n  (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (minus_p p) (-)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (minus_p64 pp)\n     (-)", "unfolding mod_ring_rel64_def rel_fun_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel64 ?x ?y; urel64 ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel64 (minus_p64 pp ?x ?x') (minus_p p ?y ?y')\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel xa ya \\<longrightarrow>\n         mod_ring_rel (minus_p p x xa) (y - ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel64 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<exists>z.\n               urel64 xa z \\<and> mod_ring_rel z ya) \\<longrightarrow>\n           (\\<exists>z.\n               urel64 (minus_p64 pp x xa) z \\<and> mod_ring_rel z (y - ya)))", "by blast"], ["", "lemma mod_ring_mult64: \"(mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (mult_p64 pp) ((*))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (mult_p64 pp)\n     (*)", "using urel64_mult mod_ring_mult"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel64 ?x ?y; urel64 ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel64 (mult_p64 pp ?x ?x') (mult_p p ?y ?y')\n  (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (mult_p p) (*)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (mult_p64 pp)\n     (*)", "unfolding mod_ring_rel64_def rel_fun_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel64 ?x ?y; urel64 ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel64 (mult_p64 pp ?x ?x') (mult_p p ?y ?y')\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel xa ya \\<longrightarrow>\n         mod_ring_rel (mult_p p x xa) (y * ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel64 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<exists>z.\n               urel64 xa z \\<and> mod_ring_rel z ya) \\<longrightarrow>\n           (\\<exists>z.\n               urel64 (mult_p64 pp x xa) z \\<and> mod_ring_rel z (y * ya)))", "by blast"], ["", "lemma mod_ring_eq64: \"(mod_ring_rel64 ===> mod_ring_rel64 ===> (=)) (=) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64 ===> (=)) (=) (=)", "using urel64_eq mod_ring_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel64 ?x ?y; urel64 ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> (?x = ?x') = (?y = ?y')\n  (mod_ring_rel ===> mod_ring_rel ===> (=)) (=) (=)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64 ===> (=)) (=) (=)", "unfolding mod_ring_rel64_def rel_fun_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel64 ?x ?y; urel64 ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> (?x = ?x') = (?y = ?y')\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel xa ya \\<longrightarrow> (x = xa) = (y = ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel64 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<exists>z.\n               urel64 xa z \\<and> mod_ring_rel z ya) \\<longrightarrow>\n           (x = xa) = (y = ya))", "by blast"], ["", "lemma urel64_inj: \"urel64 x y \\<Longrightarrow> urel64 x z \\<Longrightarrow> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>urel64 x y; urel64 x z\\<rbrakk> \\<Longrightarrow> y = z", "using urel64_eq[of x y x z]"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel64 x y; urel64 x z\\<rbrakk>\n  \\<Longrightarrow> (x = x) = (y = z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>urel64 x y; urel64 x z\\<rbrakk> \\<Longrightarrow> y = z", "by auto"], ["", "lemma urel64_inj': \"urel64 x z \\<Longrightarrow> urel64 y z \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>urel64 x z; urel64 y z\\<rbrakk> \\<Longrightarrow> x = y", "using urel64_eq[of x z y z]"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel64 x z; urel64 y z\\<rbrakk>\n  \\<Longrightarrow> (x = y) = (z = z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>urel64 x z; urel64 y z\\<rbrakk> \\<Longrightarrow> x = y", "by auto"], ["", "lemma bi_unique_mod_ring_rel64:\n  \"bi_unique mod_ring_rel64\" \"left_unique mod_ring_rel64\" \"right_unique mod_ring_rel64\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique mod_ring_rel64 &&&\n    left_unique mod_ring_rel64 &&& right_unique mod_ring_rel64", "using bi_unique_mod_ring_rel urel64_inj'"], ["proof (prove)\nusing this:\n  bi_unique mod_ring_rel\n  left_unique mod_ring_rel\n  right_unique mod_ring_rel\n  \\<lbrakk>urel64 ?x ?z; urel64 ?y ?z\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. bi_unique mod_ring_rel64 &&&\n    left_unique mod_ring_rel64 &&& right_unique mod_ring_rel64", "unfolding mod_ring_rel64_def bi_unique_def left_unique_def right_unique_def"], ["proof (prove)\nusing this:\n  (\\<forall>x y z.\n      mod_ring_rel x y \\<longrightarrow>\n      mod_ring_rel x z \\<longrightarrow> y = z) \\<and>\n  (\\<forall>x y z.\n      mod_ring_rel x z \\<longrightarrow>\n      mod_ring_rel y z \\<longrightarrow> x = y)\n  \\<forall>x y z.\n     mod_ring_rel x z \\<longrightarrow>\n     mod_ring_rel y z \\<longrightarrow> x = y\n  \\<forall>x y z.\n     mod_ring_rel x y \\<longrightarrow>\n     mod_ring_rel x z \\<longrightarrow> y = z\n  \\<lbrakk>urel64 ?x ?z; urel64 ?y ?z\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        (\\<exists>z. urel64 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n        (\\<exists>za.\n            urel64 x za \\<and> mod_ring_rel za z) \\<longrightarrow>\n        y = z) \\<and>\n    (\\<forall>x y z.\n        (\\<exists>za.\n            urel64 x za \\<and> mod_ring_rel za z) \\<longrightarrow>\n        (\\<exists>za.\n            urel64 y za \\<and> mod_ring_rel za z) \\<longrightarrow>\n        x = y) &&&\n    \\<forall>x y z.\n       (\\<exists>za. urel64 x za \\<and> mod_ring_rel za z) \\<longrightarrow>\n       (\\<exists>za. urel64 y za \\<and> mod_ring_rel za z) \\<longrightarrow>\n       x = y &&&\n    \\<forall>x y z.\n       (\\<exists>z. urel64 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<exists>za. urel64 x za \\<and> mod_ring_rel za z) \\<longrightarrow>\n       y = z", "by (auto simp: urel64_def)"], ["", "lemma right_total_mod_ring_rel64: \"right_total mod_ring_rel64\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total mod_ring_rel64", "unfolding mod_ring_rel64_def right_total_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x z. urel64 x z \\<and> mod_ring_rel z y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x z. urel64 x z \\<and> mod_ring_rel z y", "fix y :: \"'a mod_ring\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x z. urel64 x z \\<and> mod_ring_rel z y", "from right_total_mod_ring_rel[unfolded right_total_def, rule_format, of y]"], ["proof (chain)\npicking this:\n  \\<exists>x. mod_ring_rel x y", "obtain z where zy: \"mod_ring_rel z y\""], ["proof (prove)\nusing this:\n  \\<exists>x. mod_ring_rel x y\n\ngoal (1 subgoal):\n 1. (\\<And>z. mod_ring_rel z y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mod_ring_rel z y\n\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x z. urel64 x z \\<and> mod_ring_rel z y", "hence zp: \"0 \\<le> z\" \"z < p\""], ["proof (prove)\nusing this:\n  mod_ring_rel z y\n\ngoal (1 subgoal):\n 1. 0 \\<le> z &&& z < p", "unfolding mod_ring_rel_def p"], ["proof (prove)\nusing this:\n  z = to_int_mod_ring y\n\ngoal (1 subgoal):\n 1. 0 \\<le> z &&& z < int CARD('a)", "using range_to_int_mod_ring[where 'a = 'a]"], ["proof (prove)\nusing this:\n  z = to_int_mod_ring y\n  range to_int_mod_ring = {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. 0 \\<le> z &&& z < int CARD('a)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x z. urel64 x z \\<and> mod_ring_rel z y", "hence \"urel64 (uint64_of_int z) z\""], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. urel64 (uint64_of_int z) z", "unfolding urel64_def"], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. z = int_of_uint64 (uint64_of_int z) \\<and> z < p", "using small"], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z < p\n  p \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. z = int_of_uint64 (uint64_of_int z) \\<and> z < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z < int_of_uint64 pp\n  int_of_uint64 pp \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. z = int_of_uint64 (uint64_of_int z) \\<and> z < int_of_uint64 pp", "by (auto simp: int_of_uint64_inv)"], ["proof (state)\nthis:\n  urel64 (uint64_of_int z) z\n\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x z. urel64 x z \\<and> mod_ring_rel z y", "with zy"], ["proof (chain)\npicking this:\n  mod_ring_rel z y\n  urel64 (uint64_of_int z) z", "show \"\\<exists> x z. urel64 x z \\<and> mod_ring_rel z y\""], ["proof (prove)\nusing this:\n  mod_ring_rel z y\n  urel64 (uint64_of_int z) z\n\ngoal (1 subgoal):\n 1. \\<exists>x z. urel64 x z \\<and> mod_ring_rel z y", "by blast"], ["proof (state)\nthis:\n  \\<exists>x z. urel64 x z \\<and> mod_ring_rel z y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Domainp_mod_ring_rel64: \"Domainp mod_ring_rel64 = (\\<lambda>x. 0 \\<le> x \\<and> x < pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel64 = (\\<lambda>x. 0 \\<le> x \\<and> x < pp)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Domainp mod_ring_rel64 x = (0 \\<le> x \\<and> x < pp)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Domainp mod_ring_rel64 x = (0 \\<le> x \\<and> x < pp)", "show \"Domainp mod_ring_rel64 x = (0 \\<le> x \\<and> x < pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel64 x = (0 \\<le> x \\<and> x < pp)", "unfolding Domainp.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a b. x = a \\<and> mod_ring_rel64 a b) =\n    (0 \\<le> x \\<and> x < pp)", "unfolding mod_ring_rel64_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a b.\n        x = a \\<and> (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b)) =\n    (0 \\<le> x \\<and> x < pp)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b)", "let ?i = \"int_of_uint64\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b)", "assume *: \"0 \\<le> x \\<and> x < pp\""], ["proof (state)\nthis:\n  0 \\<le> x \\<and> x < pp\n\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b)", "hence \"0 \\<le> ?i x \\<and> ?i x < p\""], ["proof (prove)\nusing this:\n  0 \\<le> x \\<and> x < pp\n\ngoal (1 subgoal):\n 1. 0 \\<le> int_of_uint64 x \\<and> int_of_uint64 x < p", "using small"], ["proof (prove)\nusing this:\n  0 \\<le> x \\<and> x < pp\n  p \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. 0 \\<le> int_of_uint64 x \\<and> int_of_uint64 x < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  0 \\<le> x \\<and> x < pp\n  int_of_uint64 pp \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. 0 \\<le> int_of_uint64 x \\<and> int_of_uint64 x < int_of_uint64 pp", "by (transfer, auto simp: word_less_def)"], ["proof (state)\nthis:\n  0 \\<le> int_of_uint64 x \\<and> int_of_uint64 x < p\n\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b)", "hence \"?i x \\<in> {0 ..< p}\""], ["proof (prove)\nusing this:\n  0 \\<le> int_of_uint64 x \\<and> int_of_uint64 x < p\n\ngoal (1 subgoal):\n 1. int_of_uint64 x \\<in> {0..<p}", "by auto"], ["proof (state)\nthis:\n  int_of_uint64 x \\<in> {0..<p}\n\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b)", "with Domainp_mod_ring_rel"], ["proof (chain)\npicking this:\n  Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})\n  int_of_uint64 x \\<in> {0..<p}", "have \"Domainp mod_ring_rel (?i x)\""], ["proof (prove)\nusing this:\n  Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})\n  int_of_uint64 x \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel (int_of_uint64 x)", "by auto"], ["proof (state)\nthis:\n  Domainp mod_ring_rel (int_of_uint64 x)\n\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b)", "from this[unfolded Domainp.simps]"], ["proof (chain)\npicking this:\n  \\<exists>a b. int_of_uint64 x = a \\<and> mod_ring_rel a b", "obtain b where b: \"mod_ring_rel (?i x) b\""], ["proof (prove)\nusing this:\n  \\<exists>a b. int_of_uint64 x = a \\<and> mod_ring_rel a b\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        mod_ring_rel (int_of_uint64 x) b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mod_ring_rel (int_of_uint64 x) b\n\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b)", "show \"\\<exists>a b. x = a \\<and> (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b)", "proof (intro exI, rule conjI[OF refl], rule exI, rule conjI[OF _ b])"], ["proof (state)\ngoal (1 subgoal):\n 1. urel64 x (int_of_uint64 x)", "show \"urel64 x (?i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel64 x (int_of_uint64 x)", "unfolding urel64_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint64 x = int_of_uint64 x \\<and> int_of_uint64 x < p", "using small *"], ["proof (prove)\nusing this:\n  p \\<le> 4294967295\n  0 \\<le> x \\<and> x < pp\n\ngoal (1 subgoal):\n 1. int_of_uint64 x = int_of_uint64 x \\<and> int_of_uint64 x < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  int_of_uint64 pp \\<le> 4294967295\n  0 \\<le> x \\<and> x < pp\n\ngoal (1 subgoal):\n 1. int_of_uint64 x = int_of_uint64 x \\<and>\n    int_of_uint64 x < int_of_uint64 pp", "by (transfer, auto simp: word_less_def)"], ["proof (state)\nthis:\n  urel64 x (int_of_uint64 x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a b.\n     x = a \\<and> (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b)\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "assume \"\\<exists>a b. x = a \\<and> (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b)\""], ["proof (state)\nthis:\n  \\<exists>a b.\n     x = a \\<and> (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b)\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "then"], ["proof (chain)\npicking this:\n  \\<exists>a b.\n     x = a \\<and> (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b)", "obtain b z where xz: \"urel64 x z\" and zb: \"mod_ring_rel z b\""], ["proof (prove)\nusing this:\n  \\<exists>a b.\n     x = a \\<and> (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b)\n\ngoal (1 subgoal):\n 1. (\\<And>z b.\n        \\<lbrakk>urel64 x z; mod_ring_rel z b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  urel64 x z\n  mod_ring_rel z b\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "hence \"Domainp mod_ring_rel z\""], ["proof (prove)\nusing this:\n  urel64 x z\n  mod_ring_rel z b\n\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel z", "by auto"], ["proof (state)\nthis:\n  Domainp mod_ring_rel z\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "with Domainp_mod_ring_rel"], ["proof (chain)\npicking this:\n  Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})\n  Domainp mod_ring_rel z", "have \"0 \\<le> z\" \"z < p\""], ["proof (prove)\nusing this:\n  Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})\n  Domainp mod_ring_rel z\n\ngoal (1 subgoal):\n 1. 0 \\<le> z &&& z < p", "by auto"], ["proof (state)\nthis:\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z. urel64 a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "with xz"], ["proof (chain)\npicking this:\n  urel64 x z\n  0 \\<le> z\n  z < p", "show \"0 \\<le> x \\<and> x < pp\""], ["proof (prove)\nusing this:\n  urel64 x z\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x < pp", "unfolding urel64_def"], ["proof (prove)\nusing this:\n  z = int_of_uint64 x \\<and> z < p\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x < pp", "using small"], ["proof (prove)\nusing this:\n  z = int_of_uint64 x \\<and> z < p\n  0 \\<le> z\n  z < p\n  p \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x < pp", "unfolding ppp"], ["proof (prove)\nusing this:\n  z = int_of_uint64 x \\<and> z < int_of_uint64 pp\n  0 \\<le> z\n  z < int_of_uint64 pp\n  int_of_uint64 pp \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x < pp", "by (transfer, auto simp: word_less_def)"], ["proof (state)\nthis:\n  0 \\<le> x \\<and> x < pp\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Domainp mod_ring_rel64 x = (0 \\<le> x \\<and> x < pp)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ring_finite_field_ops64: \"ring_ops (finite_field_ops64 pp) mod_ring_rel64\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_ops (finite_field_ops64 pp) mod_ring_rel64", "by (unfold_locales, auto simp:\n  finite_field_ops64_def\n  bi_unique_mod_ring_rel64\n  right_total_mod_ring_rel64\n  mod_ring_plus64\n  mod_ring_minus64\n  mod_ring_uminus64\n  mod_ring_mult64\n  mod_ring_eq64\n  mod_ring_0_64\n  mod_ring_1_64\n  Domainp_mod_ring_rel64)"], ["", "end"], ["", "end"], ["", "context prime_field\nbegin"], ["", "context fixes pp :: \"uint64\" \n  assumes *: \"p = int_of_uint64 pp\" \"p \\<le> 4294967295\" \nbegin"], ["", "lemma mod_ring_normalize64: \"(mod_ring_rel64 ===> mod_ring_rel64) (\\<lambda>x. if x = 0 then 0 else 1) normalize\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64)\n     (\\<lambda>x. if x = 0 then 0 else 1) normalize", "using urel64_normalize[OF *] mod_ring_normalize"], ["proof (prove)\nusing this:\n  urel64 ?x ?y \\<Longrightarrow>\n  urel64 (if ?x = 0 then 0 else 1) (if ?y = 0 then 0 else 1)\n  (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. if x = 0 then 0 else 1)\n   normalize\n\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64)\n     (\\<lambda>x. if x = 0 then 0 else 1) normalize", "unfolding mod_ring_rel64_def[OF *] rel_fun_def"], ["proof (prove)\nusing this:\n  urel64 ?x ?y \\<Longrightarrow>\n  urel64 (if ?x = 0 then 0 else 1) (if ?y = 0 then 0 else 1)\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     mod_ring_rel (if x = 0 then 0 else 1) (normalize y)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel64 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<exists>z.\n           urel64 (if x = 0 then 0 else 1) z \\<and>\n           mod_ring_rel z (normalize y))", "by blast"], ["", "lemma mod_ring_mod64: \"(mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (\\<lambda>x y. if y = 0 then x else 0) (mod)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64)\n     (\\<lambda>x y. if y = 0 then x else 0) (mod)", "using urel64_mod[OF *] mod_ring_mod"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel64 ?x ?x'; urel64 ?y ?y'\\<rbrakk>\n  \\<Longrightarrow> urel64 (if ?y = 0 then ?x else 0)\n                     (if ?y' = 0 then ?x' else 0)\n  (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel)\n   (\\<lambda>x y. if y = 0 then x else 0) (mod)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64)\n     (\\<lambda>x y. if y = 0 then x else 0) (mod)", "unfolding mod_ring_rel64_def[OF *] rel_fun_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel64 ?x ?x'; urel64 ?y ?y'\\<rbrakk>\n  \\<Longrightarrow> urel64 (if ?y = 0 then ?x else 0)\n                     (if ?y' = 0 then ?x' else 0)\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel xa ya \\<longrightarrow>\n         mod_ring_rel (if xa = 0 then x else 0) (y mod ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel64 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<exists>z.\n               urel64 xa z \\<and> mod_ring_rel z ya) \\<longrightarrow>\n           (\\<exists>z.\n               urel64 (if xa = 0 then x else 0) z \\<and>\n               mod_ring_rel z (y mod ya)))", "by blast"], ["", "lemma mod_ring_unit_factor64: \"(mod_ring_rel64 ===> mod_ring_rel64) (\\<lambda>x. x) unit_factor\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64) (\\<lambda>x. x) unit_factor", "using mod_ring_unit_factor"], ["proof (prove)\nusing this:\n  (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. x) unit_factor\n\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64) (\\<lambda>x. x) unit_factor", "unfolding mod_ring_rel64_def[OF *] rel_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow> mod_ring_rel x (unit_factor y)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel64 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<exists>z. urel64 x z \\<and> mod_ring_rel z (unit_factor y))", "by blast"], ["", "lemma mod_ring_inverse64: \"(mod_ring_rel64 ===> mod_ring_rel64) (inverse_p64 pp) inverse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64) (inverse_p64 pp) inverse", "using urel64_inverse[OF *] mod_ring_inverse"], ["proof (prove)\nusing this:\n  urel64 ?x ?x' \\<Longrightarrow>\n  urel64 (inverse_p64 pp ?x) (inverse_p p ?x')\n  (mod_ring_rel ===> mod_ring_rel) (inverse_p p) inverse\n\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64) (inverse_p64 pp) inverse", "unfolding mod_ring_rel64_def[OF *] rel_fun_def"], ["proof (prove)\nusing this:\n  urel64 ?x ?x' \\<Longrightarrow>\n  urel64 (inverse_p64 pp ?x) (inverse_p p ?x')\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     mod_ring_rel (inverse_p p x) (inverse y)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z. urel64 x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<exists>z.\n           urel64 (inverse_p64 pp x) z \\<and> mod_ring_rel z (inverse y))", "by blast"], ["", "lemma mod_ring_divide64: \"(mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (divide_p64 pp) (/)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (divide_p64 pp)\n     (/)", "using mod_ring_inverse64 mod_ring_mult64[OF *]"], ["proof (prove)\nusing this:\n  (mod_ring_rel64 ===> mod_ring_rel64) (inverse_p64 pp) inverse\n  (mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (mult_p64 pp) (*)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel64 ===> mod_ring_rel64 ===> mod_ring_rel64) (divide_p64 pp)\n     (/)", "unfolding divide_p64_def divide_mod_ring_def inverse_mod_ring_def[symmetric]\n    rel_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     mod_ring_rel64 x y \\<longrightarrow>\n     mod_ring_rel64 (inverse_p64 pp x) (inverse y)\n  \\<forall>x y.\n     mod_ring_rel64 x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel64 xa ya \\<longrightarrow>\n         mod_ring_rel64 (mult_p64 pp x xa) (y * ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       mod_ring_rel64 x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           mod_ring_rel64 xa ya \\<longrightarrow>\n           mod_ring_rel64 (mult_p64 pp x (inverse_p64 pp xa))\n            (y * inverse ya))", "by blast"], ["", "lemma finite_field_ops64: \"field_ops (finite_field_ops64 pp) mod_ring_rel64\""], ["proof (prove)\ngoal (1 subgoal):\n 1. field_ops (finite_field_ops64 pp) mod_ring_rel64", "by (unfold_locales, insert ring_finite_field_ops64[OF *], auto simp:\n  ring_ops_def\n  finite_field_ops64_def\n  mod_ring_divide64\n  mod_ring_inverse64\n  mod_ring_mod64\n  mod_ring_normalize64)"], ["", "end"], ["", "end"], ["", "(* and a final implementation via integer *)"], ["", "context\n  fixes p :: integer\nbegin"], ["", "definition plus_p_integer :: \"integer \\<Rightarrow> integer \\<Rightarrow> integer\" where\n  \"plus_p_integer x y \\<equiv> let z = x + y in if z \\<ge> p then z - p else z\""], ["", "definition minus_p_integer :: \"integer \\<Rightarrow> integer \\<Rightarrow> integer\" where\n  \"minus_p_integer x y \\<equiv> if y \\<le> x then x - y else (x + p) - y\""], ["", "definition uminus_p_integer :: \"integer \\<Rightarrow> integer\" where\n  \"uminus_p_integer x = (if x = 0 then 0 else p - x)\""], ["", "definition mult_p_integer :: \"integer \\<Rightarrow> integer \\<Rightarrow> integer\" where\n  \"mult_p_integer x y = (x * y mod p)\""], ["", "lemma int_of_integer_0_iff: \"int_of_integer n = 0 \\<longleftrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int_of_integer n = 0) = (n = 0)", "using integer_eqI"], ["proof (prove)\nusing this:\n  int_of_integer ?k = int_of_integer ?l \\<Longrightarrow> ?k = ?l\n\ngoal (1 subgoal):\n 1. (int_of_integer n = 0) = (n = 0)", "by auto"], ["", "lemma int_of_integer_0: \"int_of_integer 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_integer 0 = 0", "unfolding int_of_integer_0_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = 0", "by simp"], ["", "lemma int_of_integer_plus: \"int_of_integer (x + y) = (int_of_integer x + int_of_integer y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_integer (x + y) = int_of_integer x + int_of_integer y", "by simp"], ["", "lemma int_of_integer_minus: \"int_of_integer (x - y) = (int_of_integer x - int_of_integer y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_integer (x - y) = int_of_integer x - int_of_integer y", "by simp"], ["", "lemma int_of_integer_mult: \"int_of_integer (x * y) = (int_of_integer x * int_of_integer y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_integer (x * y) = int_of_integer x * int_of_integer y", "by simp"], ["", "lemma int_of_integer_mod: \"int_of_integer (x mod y) = (int_of_integer x mod int_of_integer y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_integer (x mod y) = int_of_integer x mod int_of_integer y", "by simp"], ["", "lemma int_of_integer_inv: \"int_of_integer (integer_of_int x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_integer (integer_of_int x) = x", "by simp"], ["", "lemma int_of_integer_shift: \"int_of_integer (shiftr n k) = (int_of_integer n) div (2 ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_integer (n >> k) = int_of_integer n div 2 ^ k", "by transfer (simp add: int_of_integer_pow shiftr_integer_conv_div_pow2)"], ["", "function power_p_integer :: \"integer \\<Rightarrow> integer \\<Rightarrow> integer\" where\n  \"power_p_integer x n = (if n \\<le> 0 then 1 else\n    let rec = power_p_integer (mult_p_integer x x) (shiftr n 1) in\n    if n AND 1 = 0 then rec else mult_p_integer rec x)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>xa n. x = (xa, n) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>x n xa na.\n       (x, n) = (xa, na) \\<Longrightarrow>\n       (if n \\<le> 0 then 1\n        else let rec =\n                   power_p_integer_sumC (local.mult_p_integer x x, n >> 1)\n             in if n AND 1 = 0 then rec else local.mult_p_integer rec x) =\n       (if na \\<le> 0 then 1\n        else let rec =\n                   power_p_integer_sumC\n                    (local.mult_p_integer xa xa, na >> 1)\n             in if na AND 1 = 0 then rec else local.mult_p_integer rec xa)", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All local.power_p_integer_dom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. All local.power_p_integer_dom", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. All local.power_p_integer_dom", "fix n :: integer"], ["proof (state)\ngoal (1 subgoal):\n 1. All local.power_p_integer_dom", "assume \"\\<not> (n \\<le> 0)\""], ["proof (state)\nthis:\n  \\<not> n \\<le> 0\n\ngoal (1 subgoal):\n 1. All local.power_p_integer_dom", "hence \"n > 0\""], ["proof (prove)\nusing this:\n  \\<not> n \\<le> 0\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. All local.power_p_integer_dom", "hence \"int_of_integer n > 0\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. 0 < int_of_integer n", "by (simp add: less_integer.rep_eq)"], ["proof (state)\nthis:\n  0 < int_of_integer n\n\ngoal (1 subgoal):\n 1. All local.power_p_integer_dom", "hence \"0 < int_of_integer n\" \"int_of_integer n div 2 < int_of_integer n\""], ["proof (prove)\nusing this:\n  0 < int_of_integer n\n\ngoal (1 subgoal):\n 1. 0 < int_of_integer n &&& int_of_integer n div 2 < int_of_integer n", "by auto"], ["proof (state)\nthis:\n  0 < int_of_integer n\n  int_of_integer n div 2 < int_of_integer n\n\ngoal (1 subgoal):\n 1. All local.power_p_integer_dom", "}"], ["proof (state)\nthis:\n  \\<not> ?n2 \\<le> 0 \\<Longrightarrow> 0 < int_of_integer ?n2\n  \\<not> ?n2 \\<le> 0 \\<Longrightarrow>\n  int_of_integer ?n2 div 2 < int_of_integer ?n2\n\ngoal (1 subgoal):\n 1. All local.power_p_integer_dom", "note * = this"], ["proof (state)\nthis:\n  \\<not> ?n2 \\<le> 0 \\<Longrightarrow> 0 < int_of_integer ?n2\n  \\<not> ?n2 \\<le> 0 \\<Longrightarrow>\n  int_of_integer ?n2 div 2 < int_of_integer ?n2\n\ngoal (1 subgoal):\n 1. All local.power_p_integer_dom", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. All local.power_p_integer_dom", "by (relation \"measure (\\<lambda> (x,n). nat (int_of_integer n))\", auto simp: * int_of_integer_shift)"], ["proof (state)\nthis:\n  All local.power_p_integer_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In experiments with Berlekamp-factorization (where the prime $p$ is usually small),\n  it turned out that taking the below implementation of inverse via exponentiation\n  is faster than the one based on the extended Euclidean algorithm.\\<close>"], ["", "definition inverse_p_integer :: \"integer \\<Rightarrow> integer\" where\n  \"inverse_p_integer x = (if x = 0 then 0 else power_p_integer x (p - 2))\""], ["", "definition divide_p_integer :: \"integer \\<Rightarrow> integer \\<Rightarrow> integer\"  where\n  \"divide_p_integer x y = mult_p_integer x (inverse_p_integer y)\""], ["", "definition finite_field_ops_integer :: \"integer arith_ops_record\" where\n  \"finite_field_ops_integer \\<equiv> Arith_Ops_Record\n      0\n      1\n      plus_p_integer\n      mult_p_integer\n      minus_p_integer\n      uminus_p_integer\n      divide_p_integer\n      inverse_p_integer\n      (\\<lambda> x y . if y = 0 then x else 0)\n      (\\<lambda> x . if x = 0 then 0 else 1)\n      (\\<lambda> x . x)\n      integer_of_int\n      int_of_integer\n      (\\<lambda> x. 0 \\<le> x \\<and> x < p)\""], ["", "end"], ["", "lemma shiftr_integer_code [code_unfold]: \"drop_bit 1 x = (integer_shiftr x 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit 1 x = integer_shiftr x 1", "unfolding shiftr_integer_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_shiftr x (integer_of_nat 1) = integer_shiftr x 1", "using integer_of_nat_1"], ["proof (prove)\nusing this:\n  integer_of_nat 1 = 1\n\ngoal (1 subgoal):\n 1. integer_shiftr x (integer_of_nat 1) = integer_shiftr x 1", "by auto"], ["", "text \\<open>For soundness of the integer implementation, we mainly prove that this implementation\n  implements the int-based implementation of GF(p).\\<close>"], ["", "context mod_ring_locale\nbegin"], ["", "context fixes pp :: \"integer\" \n  assumes ppp: \"p = int_of_integer pp\" \nbegin"], ["", "lemmas integer_simps = \n  int_of_integer_0\n  int_of_integer_plus \n  int_of_integer_minus\n  int_of_integer_mult"], ["", "definition urel_integer :: \"integer \\<Rightarrow> int \\<Rightarrow> bool\" where \"urel_integer x y = (y = int_of_integer x \\<and> y \\<ge> 0 \\<and> y < p)\""], ["", "definition mod_ring_rel_integer :: \"integer \\<Rightarrow> 'a mod_ring \\<Rightarrow> bool\" where\n  \"mod_ring_rel_integer x y = (\\<exists> z. urel_integer x z \\<and> mod_ring_rel z y)\""], ["", "lemma urel_integer_0: \"urel_integer 0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer 0 0", "unfolding urel_integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = int_of_integer 0 \\<and> 0 \\<le> 0 \\<and> 0 < p", "using p2"], ["proof (prove)\nusing this:\n  2 \\<le> p\n\ngoal (1 subgoal):\n 1. 0 = int_of_integer 0 \\<and> 0 \\<le> 0 \\<and> 0 < p", "by simp"], ["", "lemma urel_integer_1: \"urel_integer 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer 1 1", "unfolding urel_integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = int_of_integer 1 \\<and> 0 \\<le> 1 \\<and> 1 < p", "using p2"], ["proof (prove)\nusing this:\n  2 \\<le> p\n\ngoal (1 subgoal):\n 1. 1 = int_of_integer 1 \\<and> 0 \\<le> 1 \\<and> 1 < p", "by simp"], ["", "lemma le_int_of_integer: \"(x \\<le> y) = (int_of_integer x \\<le> int_of_integer y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (int_of_integer x \\<le> int_of_integer y)", "by (rule less_eq_integer.rep_eq)"], ["", "lemma urel_integer_plus: assumes \"urel_integer x y\" \"urel_integer x' y'\"\n  shows \"urel_integer (plus_p_integer pp x x') (plus_p p y y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (plus_p_integer pp x x') (plus_p p y y')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. urel_integer (plus_p_integer pp x x') (plus_p p y y')", "let ?x = \"int_of_integer x\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel_integer (plus_p_integer pp x x') (plus_p p y y')", "let ?x' = \"int_of_integer x'\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel_integer (plus_p_integer pp x x') (plus_p p y y')", "let ?p = \"int_of_integer pp\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel_integer (plus_p_integer pp x x') (plus_p p y y')", "from assms"], ["proof (chain)\npicking this:\n  urel_integer x y\n  urel_integer x' y'", "have id: \"y = ?x\" \"y' = ?x'\" \n    and rel: \"0 \\<le> ?x\" \"?x < p\" \n      \"0 \\<le> ?x'\" \"?x' \\<le> p\""], ["proof (prove)\nusing this:\n  urel_integer x y\n  urel_integer x' y'\n\ngoal (1 subgoal):\n 1. (y = int_of_integer x &&& y' = int_of_integer x') &&&\n    (0 \\<le> int_of_integer x &&& int_of_integer x < p) &&&\n    0 \\<le> int_of_integer x' &&& int_of_integer x' \\<le> p", "unfolding urel_integer_def"], ["proof (prove)\nusing this:\n  y = int_of_integer x \\<and> 0 \\<le> y \\<and> y < p\n  y' = int_of_integer x' \\<and> 0 \\<le> y' \\<and> y' < p\n\ngoal (1 subgoal):\n 1. (y = int_of_integer x &&& y' = int_of_integer x') &&&\n    (0 \\<le> int_of_integer x &&& int_of_integer x < p) &&&\n    0 \\<le> int_of_integer x' &&& int_of_integer x' \\<le> p", "by auto"], ["proof (state)\nthis:\n  y = int_of_integer x\n  y' = int_of_integer x'\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel_integer (plus_p_integer pp x x') (plus_p p y y')", "have le: \"(pp \\<le> x + x') = (?p \\<le> ?x + ?x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pp \\<le> x + x') =\n    (int_of_integer pp \\<le> int_of_integer x + int_of_integer x')", "unfolding le_int_of_integer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (int_of_integer pp \\<le> int_of_integer (x + x')) =\n    (int_of_integer pp \\<le> int_of_integer x + int_of_integer x')", "using rel"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> p\n\ngoal (1 subgoal):\n 1. (int_of_integer pp \\<le> int_of_integer (x + x')) =\n    (int_of_integer pp \\<le> int_of_integer x + int_of_integer x')", "by auto"], ["proof (state)\nthis:\n  (pp \\<le> x + x') =\n  (int_of_integer pp \\<le> int_of_integer x + int_of_integer x')\n\ngoal (1 subgoal):\n 1. urel_integer (plus_p_integer pp x x') (plus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (plus_p_integer pp x x') (plus_p p y y')", "proof (cases \"?p \\<le> ?x + ?x'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. int_of_integer pp\n    \\<le> int_of_integer x + int_of_integer x' \\<Longrightarrow>\n    urel_integer (plus_p_integer pp x x') (plus_p p y y')\n 2. \\<not> int_of_integer pp\n           \\<le> int_of_integer x + int_of_integer x' \\<Longrightarrow>\n    urel_integer (plus_p_integer pp x x') (plus_p p y y')", "case True"], ["proof (state)\nthis:\n  int_of_integer pp \\<le> int_of_integer x + int_of_integer x'\n\ngoal (2 subgoals):\n 1. int_of_integer pp\n    \\<le> int_of_integer x + int_of_integer x' \\<Longrightarrow>\n    urel_integer (plus_p_integer pp x x') (plus_p p y y')\n 2. \\<not> int_of_integer pp\n           \\<le> int_of_integer x + int_of_integer x' \\<Longrightarrow>\n    urel_integer (plus_p_integer pp x x') (plus_p p y y')", "hence True: \"(?p \\<le> ?x + ?x') = True\""], ["proof (prove)\nusing this:\n  int_of_integer pp \\<le> int_of_integer x + int_of_integer x'\n\ngoal (1 subgoal):\n 1. (int_of_integer pp \\<le> int_of_integer x + int_of_integer x') = True", "by simp"], ["proof (state)\nthis:\n  (int_of_integer pp \\<le> int_of_integer x + int_of_integer x') = True\n\ngoal (2 subgoals):\n 1. int_of_integer pp\n    \\<le> int_of_integer x + int_of_integer x' \\<Longrightarrow>\n    urel_integer (plus_p_integer pp x x') (plus_p p y y')\n 2. \\<not> int_of_integer pp\n           \\<le> int_of_integer x + int_of_integer x' \\<Longrightarrow>\n    urel_integer (plus_p_integer pp x x') (plus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (plus_p_integer pp x x') (plus_p p y y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (plus_p_integer pp x x')\n     (plus_p p (int_of_integer x) (int_of_integer x'))", "using rel"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel_integer (plus_p_integer pp x x')\n     (plus_p p (int_of_integer x) (int_of_integer x'))", "unfolding plus_p_integer_def plus_p_def Let_def urel_integer_def"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> p\n\ngoal (1 subgoal):\n 1. (if p \\<le> int_of_integer x + int_of_integer x'\n     then int_of_integer x + int_of_integer x' - p\n     else int_of_integer x + int_of_integer x') =\n    int_of_integer (if pp \\<le> x + x' then x + x' - pp else x + x') \\<and>\n    0 \\<le> (if p \\<le> int_of_integer x + int_of_integer x'\n             then int_of_integer x + int_of_integer x' - p\n             else int_of_integer x + int_of_integer x') \\<and>\n    (if p \\<le> int_of_integer x + int_of_integer x'\n     then int_of_integer x + int_of_integer x' - p\n     else int_of_integer x + int_of_integer x')\n    < p", "unfolding ppp le True if_True"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < int_of_integer pp\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> int_of_integer pp\n\ngoal (1 subgoal):\n 1. int_of_integer x + int_of_integer x' - int_of_integer pp =\n    int_of_integer (x + x' - pp) \\<and>\n    0 \\<le> int_of_integer x + int_of_integer x' - int_of_integer pp \\<and>\n    int_of_integer x + int_of_integer x' - int_of_integer pp\n    < int_of_integer pp", "using True"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < int_of_integer pp\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> int_of_integer pp\n  (int_of_integer pp \\<le> int_of_integer x + int_of_integer x') = True\n\ngoal (1 subgoal):\n 1. int_of_integer x + int_of_integer x' - int_of_integer pp =\n    int_of_integer (x + x' - pp) \\<and>\n    0 \\<le> int_of_integer x + int_of_integer x' - int_of_integer pp \\<and>\n    int_of_integer x + int_of_integer x' - int_of_integer pp\n    < int_of_integer pp", "by auto"], ["proof (state)\nthis:\n  urel_integer (plus_p_integer pp x x') (plus_p p y y')\n\ngoal (1 subgoal):\n 1. \\<not> int_of_integer pp\n           \\<le> int_of_integer x + int_of_integer x' \\<Longrightarrow>\n    urel_integer (plus_p_integer pp x x') (plus_p p y y')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> int_of_integer pp\n           \\<le> int_of_integer x + int_of_integer x' \\<Longrightarrow>\n    urel_integer (plus_p_integer pp x x') (plus_p p y y')", "case False"], ["proof (state)\nthis:\n  \\<not> int_of_integer pp \\<le> int_of_integer x + int_of_integer x'\n\ngoal (1 subgoal):\n 1. \\<not> int_of_integer pp\n           \\<le> int_of_integer x + int_of_integer x' \\<Longrightarrow>\n    urel_integer (plus_p_integer pp x x') (plus_p p y y')", "hence False: \"(?p \\<le> ?x + ?x') = False\""], ["proof (prove)\nusing this:\n  \\<not> int_of_integer pp \\<le> int_of_integer x + int_of_integer x'\n\ngoal (1 subgoal):\n 1. (int_of_integer pp \\<le> int_of_integer x + int_of_integer x') = False", "by simp"], ["proof (state)\nthis:\n  (int_of_integer pp \\<le> int_of_integer x + int_of_integer x') = False\n\ngoal (1 subgoal):\n 1. \\<not> int_of_integer pp\n           \\<le> int_of_integer x + int_of_integer x' \\<Longrightarrow>\n    urel_integer (plus_p_integer pp x x') (plus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (plus_p_integer pp x x') (plus_p p y y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (plus_p_integer pp x x')\n     (plus_p p (int_of_integer x) (int_of_integer x'))", "using rel"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel_integer (plus_p_integer pp x x')\n     (plus_p p (int_of_integer x) (int_of_integer x'))", "unfolding plus_p_integer_def plus_p_def Let_def urel_integer_def"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> p\n\ngoal (1 subgoal):\n 1. (if p \\<le> int_of_integer x + int_of_integer x'\n     then int_of_integer x + int_of_integer x' - p\n     else int_of_integer x + int_of_integer x') =\n    int_of_integer (if pp \\<le> x + x' then x + x' - pp else x + x') \\<and>\n    0 \\<le> (if p \\<le> int_of_integer x + int_of_integer x'\n             then int_of_integer x + int_of_integer x' - p\n             else int_of_integer x + int_of_integer x') \\<and>\n    (if p \\<le> int_of_integer x + int_of_integer x'\n     then int_of_integer x + int_of_integer x' - p\n     else int_of_integer x + int_of_integer x')\n    < p", "unfolding ppp le False if_False"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < int_of_integer pp\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> int_of_integer pp\n\ngoal (1 subgoal):\n 1. int_of_integer x + int_of_integer x' = int_of_integer (x + x') \\<and>\n    0 \\<le> int_of_integer x + int_of_integer x' \\<and>\n    int_of_integer x + int_of_integer x' < int_of_integer pp", "using False"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < int_of_integer pp\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> int_of_integer pp\n  (int_of_integer pp \\<le> int_of_integer x + int_of_integer x') = False\n\ngoal (1 subgoal):\n 1. int_of_integer x + int_of_integer x' = int_of_integer (x + x') \\<and>\n    0 \\<le> int_of_integer x + int_of_integer x' \\<and>\n    int_of_integer x + int_of_integer x' < int_of_integer pp", "by auto"], ["proof (state)\nthis:\n  urel_integer (plus_p_integer pp x x') (plus_p p y y')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  urel_integer (plus_p_integer pp x x') (plus_p p y y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel_integer_minus: assumes \"urel_integer x y\" \"urel_integer x' y'\"\n  shows \"urel_integer (minus_p_integer pp x x') (minus_p p y y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (minus_p_integer pp x x') (minus_p p y y')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. urel_integer (minus_p_integer pp x x') (minus_p p y y')", "let ?x = \"int_of_integer x\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel_integer (minus_p_integer pp x x') (minus_p p y y')", "let ?x' = \"int_of_integer x'\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel_integer (minus_p_integer pp x x') (minus_p p y y')", "from assms"], ["proof (chain)\npicking this:\n  urel_integer x y\n  urel_integer x' y'", "have id: \"y = ?x\" \"y' = ?x'\" \n    and rel: \"0 \\<le> ?x\" \"?x < p\" \n      \"0 \\<le> ?x'\" \"?x' \\<le> p\""], ["proof (prove)\nusing this:\n  urel_integer x y\n  urel_integer x' y'\n\ngoal (1 subgoal):\n 1. (y = int_of_integer x &&& y' = int_of_integer x') &&&\n    (0 \\<le> int_of_integer x &&& int_of_integer x < p) &&&\n    0 \\<le> int_of_integer x' &&& int_of_integer x' \\<le> p", "unfolding urel_integer_def"], ["proof (prove)\nusing this:\n  y = int_of_integer x \\<and> 0 \\<le> y \\<and> y < p\n  y' = int_of_integer x' \\<and> 0 \\<le> y' \\<and> y' < p\n\ngoal (1 subgoal):\n 1. (y = int_of_integer x &&& y' = int_of_integer x') &&&\n    (0 \\<le> int_of_integer x &&& int_of_integer x < p) &&&\n    0 \\<le> int_of_integer x' &&& int_of_integer x' \\<le> p", "by auto"], ["proof (state)\nthis:\n  y = int_of_integer x\n  y' = int_of_integer x'\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel_integer (minus_p_integer pp x x') (minus_p p y y')", "have le: \"(x' \\<le> x) = (?x' \\<le> ?x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x' \\<le> x) = (int_of_integer x' \\<le> int_of_integer x)", "unfolding le_int_of_integer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (int_of_integer x' \\<le> int_of_integer x) =\n    (int_of_integer x' \\<le> int_of_integer x)", "using rel"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> p\n\ngoal (1 subgoal):\n 1. (int_of_integer x' \\<le> int_of_integer x) =\n    (int_of_integer x' \\<le> int_of_integer x)", "by auto"], ["proof (state)\nthis:\n  (x' \\<le> x) = (int_of_integer x' \\<le> int_of_integer x)\n\ngoal (1 subgoal):\n 1. urel_integer (minus_p_integer pp x x') (minus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (minus_p_integer pp x x') (minus_p p y y')", "proof (cases \"?x' \\<le> ?x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. int_of_integer x' \\<le> int_of_integer x \\<Longrightarrow>\n    urel_integer (minus_p_integer pp x x') (minus_p p y y')\n 2. \\<not> int_of_integer x' \\<le> int_of_integer x \\<Longrightarrow>\n    urel_integer (minus_p_integer pp x x') (minus_p p y y')", "case True"], ["proof (state)\nthis:\n  int_of_integer x' \\<le> int_of_integer x\n\ngoal (2 subgoals):\n 1. int_of_integer x' \\<le> int_of_integer x \\<Longrightarrow>\n    urel_integer (minus_p_integer pp x x') (minus_p p y y')\n 2. \\<not> int_of_integer x' \\<le> int_of_integer x \\<Longrightarrow>\n    urel_integer (minus_p_integer pp x x') (minus_p p y y')", "hence True: \"(?x' \\<le> ?x) = True\""], ["proof (prove)\nusing this:\n  int_of_integer x' \\<le> int_of_integer x\n\ngoal (1 subgoal):\n 1. (int_of_integer x' \\<le> int_of_integer x) = True", "by simp"], ["proof (state)\nthis:\n  (int_of_integer x' \\<le> int_of_integer x) = True\n\ngoal (2 subgoals):\n 1. int_of_integer x' \\<le> int_of_integer x \\<Longrightarrow>\n    urel_integer (minus_p_integer pp x x') (minus_p p y y')\n 2. \\<not> int_of_integer x' \\<le> int_of_integer x \\<Longrightarrow>\n    urel_integer (minus_p_integer pp x x') (minus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (minus_p_integer pp x x') (minus_p p y y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (minus_p_integer pp x x')\n     (minus_p p (int_of_integer x) (int_of_integer x'))", "using rel"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel_integer (minus_p_integer pp x x')\n     (minus_p p (int_of_integer x) (int_of_integer x'))", "unfolding minus_p_integer_def minus_p_def Let_def urel_integer_def"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> p\n\ngoal (1 subgoal):\n 1. (if int_of_integer x' \\<le> int_of_integer x\n     then int_of_integer x - int_of_integer x'\n     else int_of_integer x + p - int_of_integer x') =\n    int_of_integer (if x' \\<le> x then x - x' else x + pp - x') \\<and>\n    0 \\<le> (if int_of_integer x' \\<le> int_of_integer x\n             then int_of_integer x - int_of_integer x'\n             else int_of_integer x + p - int_of_integer x') \\<and>\n    (if int_of_integer x' \\<le> int_of_integer x\n     then int_of_integer x - int_of_integer x'\n     else int_of_integer x + p - int_of_integer x')\n    < p", "unfolding ppp le True if_True"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < int_of_integer pp\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> int_of_integer pp\n\ngoal (1 subgoal):\n 1. int_of_integer x - int_of_integer x' = int_of_integer (x - x') \\<and>\n    0 \\<le> int_of_integer x - int_of_integer x' \\<and>\n    int_of_integer x - int_of_integer x' < int_of_integer pp", "using True"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < int_of_integer pp\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> int_of_integer pp\n  (int_of_integer x' \\<le> int_of_integer x) = True\n\ngoal (1 subgoal):\n 1. int_of_integer x - int_of_integer x' = int_of_integer (x - x') \\<and>\n    0 \\<le> int_of_integer x - int_of_integer x' \\<and>\n    int_of_integer x - int_of_integer x' < int_of_integer pp", "by auto"], ["proof (state)\nthis:\n  urel_integer (minus_p_integer pp x x') (minus_p p y y')\n\ngoal (1 subgoal):\n 1. \\<not> int_of_integer x' \\<le> int_of_integer x \\<Longrightarrow>\n    urel_integer (minus_p_integer pp x x') (minus_p p y y')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> int_of_integer x' \\<le> int_of_integer x \\<Longrightarrow>\n    urel_integer (minus_p_integer pp x x') (minus_p p y y')", "case False"], ["proof (state)\nthis:\n  \\<not> int_of_integer x' \\<le> int_of_integer x\n\ngoal (1 subgoal):\n 1. \\<not> int_of_integer x' \\<le> int_of_integer x \\<Longrightarrow>\n    urel_integer (minus_p_integer pp x x') (minus_p p y y')", "hence False: \"(?x' \\<le> ?x) = False\""], ["proof (prove)\nusing this:\n  \\<not> int_of_integer x' \\<le> int_of_integer x\n\ngoal (1 subgoal):\n 1. (int_of_integer x' \\<le> int_of_integer x) = False", "by simp"], ["proof (state)\nthis:\n  (int_of_integer x' \\<le> int_of_integer x) = False\n\ngoal (1 subgoal):\n 1. \\<not> int_of_integer x' \\<le> int_of_integer x \\<Longrightarrow>\n    urel_integer (minus_p_integer pp x x') (minus_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (minus_p_integer pp x x') (minus_p p y y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (minus_p_integer pp x x')\n     (minus_p p (int_of_integer x) (int_of_integer x'))", "using rel"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> p\n\ngoal (1 subgoal):\n 1. urel_integer (minus_p_integer pp x x')\n     (minus_p p (int_of_integer x) (int_of_integer x'))", "unfolding minus_p_integer_def minus_p_def Let_def urel_integer_def"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> p\n\ngoal (1 subgoal):\n 1. (if int_of_integer x' \\<le> int_of_integer x\n     then int_of_integer x - int_of_integer x'\n     else int_of_integer x + p - int_of_integer x') =\n    int_of_integer (if x' \\<le> x then x - x' else x + pp - x') \\<and>\n    0 \\<le> (if int_of_integer x' \\<le> int_of_integer x\n             then int_of_integer x - int_of_integer x'\n             else int_of_integer x + p - int_of_integer x') \\<and>\n    (if int_of_integer x' \\<le> int_of_integer x\n     then int_of_integer x - int_of_integer x'\n     else int_of_integer x + p - int_of_integer x')\n    < p", "unfolding ppp le False if_False"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < int_of_integer pp\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> int_of_integer pp\n\ngoal (1 subgoal):\n 1. int_of_integer x + int_of_integer pp - int_of_integer x' =\n    int_of_integer (x + pp - x') \\<and>\n    0 \\<le> int_of_integer x + int_of_integer pp - int_of_integer x' \\<and>\n    int_of_integer x + int_of_integer pp - int_of_integer x'\n    < int_of_integer pp", "using False"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < int_of_integer pp\n  0 \\<le> int_of_integer x'\n  int_of_integer x' \\<le> int_of_integer pp\n  (int_of_integer x' \\<le> int_of_integer x) = False\n\ngoal (1 subgoal):\n 1. int_of_integer x + int_of_integer pp - int_of_integer x' =\n    int_of_integer (x + pp - x') \\<and>\n    0 \\<le> int_of_integer x + int_of_integer pp - int_of_integer x' \\<and>\n    int_of_integer x + int_of_integer pp - int_of_integer x'\n    < int_of_integer pp", "by auto"], ["proof (state)\nthis:\n  urel_integer (minus_p_integer pp x x') (minus_p p y y')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  urel_integer (minus_p_integer pp x x') (minus_p p y y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel_integer_uminus: assumes \"urel_integer x y\"\n  shows \"urel_integer (uminus_p_integer pp x) (uminus_p p y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (uminus_p_integer pp x) (uminus_p p y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. urel_integer (uminus_p_integer pp x) (uminus_p p y)", "let ?x = \"int_of_integer x\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel_integer (uminus_p_integer pp x) (uminus_p p y)", "from assms"], ["proof (chain)\npicking this:\n  urel_integer x y", "have id: \"y = ?x\" \n    and rel: \"0 \\<le> ?x\" \"?x < p\""], ["proof (prove)\nusing this:\n  urel_integer x y\n\ngoal (1 subgoal):\n 1. y = int_of_integer x &&&\n    0 \\<le> int_of_integer x &&& int_of_integer x < p", "unfolding urel_integer_def"], ["proof (prove)\nusing this:\n  y = int_of_integer x \\<and> 0 \\<le> y \\<and> y < p\n\ngoal (1 subgoal):\n 1. y = int_of_integer x &&&\n    0 \\<le> int_of_integer x &&& int_of_integer x < p", "by auto"], ["proof (state)\nthis:\n  y = int_of_integer x\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n\ngoal (1 subgoal):\n 1. urel_integer (uminus_p_integer pp x) (uminus_p p y)", "have le: \"(x = 0) = (?x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = 0) = (int_of_integer x = 0)", "unfolding int_of_integer_0_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = 0) = (x = 0)", "using rel"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n\ngoal (1 subgoal):\n 1. (x = 0) = (x = 0)", "by auto"], ["proof (state)\nthis:\n  (x = 0) = (int_of_integer x = 0)\n\ngoal (1 subgoal):\n 1. urel_integer (uminus_p_integer pp x) (uminus_p p y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (uminus_p_integer pp x) (uminus_p p y)", "proof (cases \"?x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. int_of_integer x = 0 \\<Longrightarrow>\n    urel_integer (uminus_p_integer pp x) (uminus_p p y)\n 2. int_of_integer x \\<noteq> 0 \\<Longrightarrow>\n    urel_integer (uminus_p_integer pp x) (uminus_p p y)", "case True"], ["proof (state)\nthis:\n  int_of_integer x = 0\n\ngoal (2 subgoals):\n 1. int_of_integer x = 0 \\<Longrightarrow>\n    urel_integer (uminus_p_integer pp x) (uminus_p p y)\n 2. int_of_integer x \\<noteq> 0 \\<Longrightarrow>\n    urel_integer (uminus_p_integer pp x) (uminus_p p y)", "hence True: \"(?x = 0) = True\""], ["proof (prove)\nusing this:\n  int_of_integer x = 0\n\ngoal (1 subgoal):\n 1. (int_of_integer x = 0) = True", "by simp"], ["proof (state)\nthis:\n  (int_of_integer x = 0) = True\n\ngoal (2 subgoals):\n 1. int_of_integer x = 0 \\<Longrightarrow>\n    urel_integer (uminus_p_integer pp x) (uminus_p p y)\n 2. int_of_integer x \\<noteq> 0 \\<Longrightarrow>\n    urel_integer (uminus_p_integer pp x) (uminus_p p y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (uminus_p_integer pp x) (uminus_p p y)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (uminus_p_integer pp x) (uminus_p p (int_of_integer x))", "using rel"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n\ngoal (1 subgoal):\n 1. urel_integer (uminus_p_integer pp x) (uminus_p p (int_of_integer x))", "unfolding uminus_p_integer_def uminus_p_def Let_def urel_integer_def"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n\ngoal (1 subgoal):\n 1. (if int_of_integer x = 0 then 0 else p - int_of_integer x) =\n    int_of_integer (if x = 0 then 0 else pp - x) \\<and>\n    0 \\<le> (if int_of_integer x = 0 then 0\n             else p - int_of_integer x) \\<and>\n    (if int_of_integer x = 0 then 0 else p - int_of_integer x) < p", "unfolding ppp le True if_True"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < int_of_integer pp\n\ngoal (1 subgoal):\n 1. 0 = int_of_integer 0 \\<and> 0 \\<le> 0 \\<and> 0 < int_of_integer pp", "using True"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < int_of_integer pp\n  (int_of_integer x = 0) = True\n\ngoal (1 subgoal):\n 1. 0 = int_of_integer 0 \\<and> 0 \\<le> 0 \\<and> 0 < int_of_integer pp", "by auto"], ["proof (state)\nthis:\n  urel_integer (uminus_p_integer pp x) (uminus_p p y)\n\ngoal (1 subgoal):\n 1. int_of_integer x \\<noteq> 0 \\<Longrightarrow>\n    urel_integer (uminus_p_integer pp x) (uminus_p p y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. int_of_integer x \\<noteq> 0 \\<Longrightarrow>\n    urel_integer (uminus_p_integer pp x) (uminus_p p y)", "case False"], ["proof (state)\nthis:\n  int_of_integer x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int_of_integer x \\<noteq> 0 \\<Longrightarrow>\n    urel_integer (uminus_p_integer pp x) (uminus_p p y)", "hence False: \"(?x = 0) = False\""], ["proof (prove)\nusing this:\n  int_of_integer x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (int_of_integer x = 0) = False", "by simp"], ["proof (state)\nthis:\n  (int_of_integer x = 0) = False\n\ngoal (1 subgoal):\n 1. int_of_integer x \\<noteq> 0 \\<Longrightarrow>\n    urel_integer (uminus_p_integer pp x) (uminus_p p y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (uminus_p_integer pp x) (uminus_p p y)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (uminus_p_integer pp x) (uminus_p p (int_of_integer x))", "using rel"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n\ngoal (1 subgoal):\n 1. urel_integer (uminus_p_integer pp x) (uminus_p p (int_of_integer x))", "unfolding uminus_p_integer_def uminus_p_def Let_def urel_integer_def"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n\ngoal (1 subgoal):\n 1. (if int_of_integer x = 0 then 0 else p - int_of_integer x) =\n    int_of_integer (if x = 0 then 0 else pp - x) \\<and>\n    0 \\<le> (if int_of_integer x = 0 then 0\n             else p - int_of_integer x) \\<and>\n    (if int_of_integer x = 0 then 0 else p - int_of_integer x) < p", "unfolding ppp le False if_False"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < int_of_integer pp\n\ngoal (1 subgoal):\n 1. int_of_integer pp - int_of_integer x = int_of_integer (pp - x) \\<and>\n    0 \\<le> int_of_integer pp - int_of_integer x \\<and>\n    int_of_integer pp - int_of_integer x < int_of_integer pp", "using False"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < int_of_integer pp\n  (int_of_integer x = 0) = False\n\ngoal (1 subgoal):\n 1. int_of_integer pp - int_of_integer x = int_of_integer (pp - x) \\<and>\n    0 \\<le> int_of_integer pp - int_of_integer x \\<and>\n    int_of_integer pp - int_of_integer x < int_of_integer pp", "by auto"], ["proof (state)\nthis:\n  urel_integer (uminus_p_integer pp x) (uminus_p p y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  urel_integer (uminus_p_integer pp x) (uminus_p p y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pp_pos: \"int_of_integer pp > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < int_of_integer pp", "using ppp nontriv[where 'a = 'a]"], ["proof (prove)\nusing this:\n  p = int_of_integer pp\n  1 < CARD('a)\n\ngoal (1 subgoal):\n 1. 0 < int_of_integer pp", "unfolding p"], ["proof (prove)\nusing this:\n  int CARD('a) = int_of_integer pp\n  1 < CARD('a)\n\ngoal (1 subgoal):\n 1. 0 < int_of_integer pp", "by (simp add: less_integer.rep_eq)"], ["", "lemma urel_integer_mult: assumes \"urel_integer x y\" \"urel_integer x' y'\"\n  shows \"urel_integer (mult_p_integer pp x x') (mult_p p y y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (mult_p_integer pp x x') (mult_p p y y')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. urel_integer (mult_p_integer pp x x') (mult_p p y y')", "let ?x = \"int_of_integer x\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel_integer (mult_p_integer pp x x') (mult_p p y y')", "let ?x' = \"int_of_integer x'\""], ["proof (state)\ngoal (1 subgoal):\n 1. urel_integer (mult_p_integer pp x x') (mult_p p y y')", "from assms"], ["proof (chain)\npicking this:\n  urel_integer x y\n  urel_integer x' y'", "have id: \"y = ?x\" \"y' = ?x'\" \n    and rel: \"0 \\<le> ?x\" \"?x < p\" \n      \"0 \\<le> ?x'\" \"?x' < p\""], ["proof (prove)\nusing this:\n  urel_integer x y\n  urel_integer x' y'\n\ngoal (1 subgoal):\n 1. (y = int_of_integer x &&& y' = int_of_integer x') &&&\n    (0 \\<le> int_of_integer x &&& int_of_integer x < p) &&&\n    0 \\<le> int_of_integer x' &&& int_of_integer x' < p", "unfolding urel_integer_def"], ["proof (prove)\nusing this:\n  y = int_of_integer x \\<and> 0 \\<le> y \\<and> y < p\n  y' = int_of_integer x' \\<and> 0 \\<le> y' \\<and> y' < p\n\ngoal (1 subgoal):\n 1. (y = int_of_integer x &&& y' = int_of_integer x') &&&\n    (0 \\<le> int_of_integer x &&& int_of_integer x < p) &&&\n    0 \\<le> int_of_integer x' &&& int_of_integer x' < p", "by auto"], ["proof (state)\nthis:\n  y = int_of_integer x\n  y' = int_of_integer x'\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n  0 \\<le> int_of_integer x'\n  int_of_integer x' < p\n\ngoal (1 subgoal):\n 1. urel_integer (mult_p_integer pp x x') (mult_p p y y')", "from rel(1,3)"], ["proof (chain)\npicking this:\n  0 \\<le> int_of_integer x\n  0 \\<le> int_of_integer x'", "have xx: \"0 \\<le> ?x * ?x'\""], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  0 \\<le> int_of_integer x'\n\ngoal (1 subgoal):\n 1. 0 \\<le> int_of_integer x * int_of_integer x'", "by simp"], ["proof (state)\nthis:\n  0 \\<le> int_of_integer x * int_of_integer x'\n\ngoal (1 subgoal):\n 1. urel_integer (mult_p_integer pp x x') (mult_p p y y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (mult_p_integer pp x x') (mult_p p y y')", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (mult_p_integer pp x x')\n     (mult_p p (int_of_integer x) (int_of_integer x'))", "using rel"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n  0 \\<le> int_of_integer x'\n  int_of_integer x' < p\n\ngoal (1 subgoal):\n 1. urel_integer (mult_p_integer pp x x')\n     (mult_p p (int_of_integer x) (int_of_integer x'))", "unfolding mult_p_integer_def mult_p_def Let_def urel_integer_def"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < p\n  0 \\<le> int_of_integer x'\n  int_of_integer x' < p\n\ngoal (1 subgoal):\n 1. mod_nonneg_pos_int (int_of_integer x * int_of_integer x') p =\n    int_of_integer (x * x' mod pp) \\<and>\n    0 \\<le> mod_nonneg_pos_int (int_of_integer x * int_of_integer x')\n             p \\<and>\n    mod_nonneg_pos_int (int_of_integer x * int_of_integer x') p < p", "unfolding ppp mod_nonneg_pos_int[OF xx pp_pos]"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < int_of_integer pp\n  0 \\<le> int_of_integer x'\n  int_of_integer x' < int_of_integer pp\n\ngoal (1 subgoal):\n 1. int_of_integer x * int_of_integer x' mod int_of_integer pp =\n    int_of_integer (x * x' mod pp) \\<and>\n    0 \\<le> int_of_integer x * int_of_integer x' mod\n            int_of_integer pp \\<and>\n    int_of_integer x * int_of_integer x' mod int_of_integer pp\n    < int_of_integer pp", "using xx pp_pos"], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x\n  int_of_integer x < int_of_integer pp\n  0 \\<le> int_of_integer x'\n  int_of_integer x' < int_of_integer pp\n  0 \\<le> int_of_integer x * int_of_integer x'\n  0 < int_of_integer pp\n\ngoal (1 subgoal):\n 1. int_of_integer x * int_of_integer x' mod int_of_integer pp =\n    int_of_integer (x * x' mod pp) \\<and>\n    0 \\<le> int_of_integer x * int_of_integer x' mod\n            int_of_integer pp \\<and>\n    int_of_integer x * int_of_integer x' mod int_of_integer pp\n    < int_of_integer pp", "by simp"], ["proof (state)\nthis:\n  urel_integer (mult_p_integer pp x x') (mult_p p y y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel_integer_eq: assumes \"urel_integer x y\" \"urel_integer x' y'\" \n  shows \"(x = x') = (y = y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "let ?x = \"int_of_integer x\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "let ?x' = \"int_of_integer x'\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "from assms"], ["proof (chain)\npicking this:\n  urel_integer x y\n  urel_integer x' y'", "have id: \"y = ?x\" \"y' = ?x'\""], ["proof (prove)\nusing this:\n  urel_integer x y\n  urel_integer x' y'\n\ngoal (1 subgoal):\n 1. y = int_of_integer x &&& y' = int_of_integer x'", "unfolding urel_integer_def"], ["proof (prove)\nusing this:\n  y = int_of_integer x \\<and> 0 \\<le> y \\<and> y < p\n  y' = int_of_integer x' \\<and> 0 \\<le> y' \\<and> y' < p\n\ngoal (1 subgoal):\n 1. y = int_of_integer x &&& y' = int_of_integer x'", "by auto"], ["proof (state)\nthis:\n  y = int_of_integer x\n  y' = int_of_integer x'\n\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = x') = (y = y')", "unfolding id integer_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (int_of_integer x = int_of_integer x') =\n    (int_of_integer x = int_of_integer x')", ".."], ["proof (state)\nthis:\n  (x = x') = (y = y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel_integer_normalize: \nassumes x: \"urel_integer x y\"\nshows \"urel_integer (if x = 0 then 0 else 1) (if y = 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (if x = 0 then 0 else 1) (if y = 0 then 0 else 1)", "unfolding urel_integer_eq[OF x urel_integer_0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (if y = 0 then 0 else 1) (if y = 0 then 0 else 1)", "using urel_integer_0 urel_integer_1"], ["proof (prove)\nusing this:\n  urel_integer 0 0\n  urel_integer 1 1\n\ngoal (1 subgoal):\n 1. urel_integer (if y = 0 then 0 else 1) (if y = 0 then 0 else 1)", "by auto"], ["", "lemma urel_integer_mod: \nassumes x: \"urel_integer x x'\" and y: \"urel_integer y y'\" \nshows \"urel_integer (if y = 0 then x else 0) (if y' = 0 then x' else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (if y = 0 then x else 0) (if y' = 0 then x' else 0)", "unfolding urel_integer_eq[OF y urel_integer_0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (if y' = 0 then x else 0) (if y' = 0 then x' else 0)", "using urel_integer_0 x"], ["proof (prove)\nusing this:\n  urel_integer 0 0\n  urel_integer x x'\n\ngoal (1 subgoal):\n 1. urel_integer (if y' = 0 then x else 0) (if y' = 0 then x' else 0)", "by auto"], ["", "lemma urel_integer_power: \"urel_integer x x' \\<Longrightarrow> urel_integer y (int y') \\<Longrightarrow> urel_integer (power_p_integer pp x y) (power_p p x' y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>urel_integer x x'; urel_integer y (int y')\\<rbrakk>\n    \\<Longrightarrow> urel_integer (power_p_integer pp x y)\n                       (power_p p x' y')", "proof (induct x' y' arbitrary: x y rule: power_p.induct[of _ p])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x n xa y.\n       \\<lbrakk>\\<And>xa xb y xc ya.\n                   \\<lbrakk>n \\<noteq> 0; xa = divmod_nat n 2; (xb, y) = xa;\n                    urel_integer xc (mult_p p x x);\n                    urel_integer ya (int xb)\\<rbrakk>\n                   \\<Longrightarrow> urel_integer (power_p_integer pp xc ya)\n(power_p p (mult_p p x x) xb);\n        urel_integer xa x; urel_integer y (int n)\\<rbrakk>\n       \\<Longrightarrow> urel_integer (power_p_integer pp xa y)\n                          (power_p p x n)", "case (1 x' y' x y)"], ["proof (state)\nthis:\n  \\<lbrakk>y' \\<noteq> 0; ?xa = divmod_nat y' 2; (?xb, ?y) = ?xa;\n   urel_integer ?x (mult_p p x' x'); urel_integer ?ya (int ?xb)\\<rbrakk>\n  \\<Longrightarrow> urel_integer (power_p_integer pp ?x ?ya)\n                     (power_p p (mult_p p x' x') ?xb)\n  urel_integer x x'\n  urel_integer y (int y')\n\ngoal (1 subgoal):\n 1. \\<And>x n xa y.\n       \\<lbrakk>\\<And>xa xb y xc ya.\n                   \\<lbrakk>n \\<noteq> 0; xa = divmod_nat n 2; (xb, y) = xa;\n                    urel_integer xc (mult_p p x x);\n                    urel_integer ya (int xb)\\<rbrakk>\n                   \\<Longrightarrow> urel_integer (power_p_integer pp xc ya)\n(power_p p (mult_p p x x) xb);\n        urel_integer xa x; urel_integer y (int n)\\<rbrakk>\n       \\<Longrightarrow> urel_integer (power_p_integer pp xa y)\n                          (power_p p x n)", "note x = 1(2)"], ["proof (state)\nthis:\n  urel_integer x x'\n\ngoal (1 subgoal):\n 1. \\<And>x n xa y.\n       \\<lbrakk>\\<And>xa xb y xc ya.\n                   \\<lbrakk>n \\<noteq> 0; xa = divmod_nat n 2; (xb, y) = xa;\n                    urel_integer xc (mult_p p x x);\n                    urel_integer ya (int xb)\\<rbrakk>\n                   \\<Longrightarrow> urel_integer (power_p_integer pp xc ya)\n(power_p p (mult_p p x x) xb);\n        urel_integer xa x; urel_integer y (int n)\\<rbrakk>\n       \\<Longrightarrow> urel_integer (power_p_integer pp xa y)\n                          (power_p p x n)", "note y = 1(3)"], ["proof (state)\nthis:\n  urel_integer y (int y')\n\ngoal (1 subgoal):\n 1. \\<And>x n xa y.\n       \\<lbrakk>\\<And>xa xb y xc ya.\n                   \\<lbrakk>n \\<noteq> 0; xa = divmod_nat n 2; (xb, y) = xa;\n                    urel_integer xc (mult_p p x x);\n                    urel_integer ya (int xb)\\<rbrakk>\n                   \\<Longrightarrow> urel_integer (power_p_integer pp xc ya)\n(power_p p (mult_p p x x) xb);\n        urel_integer xa x; urel_integer y (int n)\\<rbrakk>\n       \\<Longrightarrow> urel_integer (power_p_integer pp xa y)\n                          (power_p p x n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (power_p_integer pp x y) (power_p p x' y')", "proof (cases \"y' \\<le> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')\n 2. \\<not> y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')", "case True"], ["proof (state)\nthis:\n  y' \\<le> 0\n\ngoal (2 subgoals):\n 1. y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')\n 2. \\<not> y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')", "hence y: \"y = 0\" \"y' = 0\""], ["proof (prove)\nusing this:\n  y' \\<le> 0\n\ngoal (1 subgoal):\n 1. y = 0 &&& y' = 0", "using urel_integer_eq[OF y urel_integer_0]"], ["proof (prove)\nusing this:\n  y' \\<le> 0\n  (y = 0) = (int y' = 0)\n\ngoal (1 subgoal):\n 1. y = 0 &&& y' = 0", "by auto"], ["proof (state)\nthis:\n  y = 0\n  y' = 0\n\ngoal (2 subgoals):\n 1. y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')\n 2. \\<not> y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (power_p_integer pp x y) (power_p p x' y')", "unfolding y True"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (power_p_integer pp x 0) (power_p p x' 0)", "by (simp add: power_p.simps urel_integer_1)"], ["proof (state)\nthis:\n  urel_integer (power_p_integer pp x y) (power_p p x' y')\n\ngoal (1 subgoal):\n 1. \\<not> y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')", "case False"], ["proof (state)\nthis:\n  \\<not> y' \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<not> y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')", "hence id: \"(y \\<le> 0) = False\" \"(y' = 0) = False\""], ["proof (prove)\nusing this:\n  \\<not> y' \\<le> 0\n\ngoal (1 subgoal):\n 1. (y \\<le> 0) = False &&& (y' = 0) = False", "using False y"], ["proof (prove)\nusing this:\n  \\<not> y' \\<le> 0\n  \\<not> y' \\<le> 0\n  urel_integer y (int y')\n\ngoal (1 subgoal):\n 1. (y \\<le> 0) = False &&& (y' = 0) = False", "by (auto simp add: urel_integer_def not_le) (metis of_int_integer_of of_int_of_nat_eq of_nat_0_less_iff)"], ["proof (state)\nthis:\n  (y \\<le> 0) = False\n  (y' = 0) = False\n\ngoal (1 subgoal):\n 1. \\<not> y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')", "obtain d' r' where dr': \"Divides.divmod_nat y' 2 = (d',r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d' r'.\n        divmod_nat y' 2 = (d', r') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  divmod_nat y' 2 = (d', r')\n\ngoal (1 subgoal):\n 1. \\<not> y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')", "from divmod_nat_def[of y' 2, unfolded dr']"], ["proof (chain)\npicking this:\n  (d', r') = (y' div 2, y' mod 2)", "have r': \"r' = y' mod 2\" and d': \"d' = y' div 2\""], ["proof (prove)\nusing this:\n  (d', r') = (y' div 2, y' mod 2)\n\ngoal (1 subgoal):\n 1. r' = y' mod 2 &&& d' = y' div 2", "by auto"], ["proof (state)\nthis:\n  r' = y' mod 2\n  d' = y' div 2\n\ngoal (1 subgoal):\n 1. \\<not> y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')", "have aux: \"\\<And> y'. int (y' mod 2) = int y' mod 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y'. int (y' mod 2) = int y' mod 2", "by presburger"], ["proof (state)\nthis:\n  int (?y' mod 2) = int ?y' mod 2\n\ngoal (1 subgoal):\n 1. \\<not> y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')", "have \"urel_integer (y AND 1) r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (y AND 1) (int r')", "unfolding r'"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (y AND 1) (int (y' mod 2))", "using y"], ["proof (prove)\nusing this:\n  urel_integer y (int y')\n\ngoal (1 subgoal):\n 1. urel_integer (y AND 1) (int (y' mod 2))", "unfolding urel_integer_def"], ["proof (prove)\nusing this:\n  int y' = int_of_integer y \\<and> 0 \\<le> int y' \\<and> int y' < p\n\ngoal (1 subgoal):\n 1. int (y' mod 2) = int_of_integer (y AND 1) \\<and>\n    0 \\<le> int (y' mod 2) \\<and> int (y' mod 2) < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  int y' = int_of_integer y \\<and>\n  0 \\<le> int y' \\<and> int y' < int_of_integer pp\n\ngoal (1 subgoal):\n 1. int (y' mod 2) = int_of_integer (y AND 1) \\<and>\n    0 \\<le> int (y' mod 2) \\<and> int (y' mod 2) < int_of_integer pp", "apply (auto simp add: and_one_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>int y' = int_of_integer y;\n     int_of_integer y < int_of_integer pp\\<rbrakk>\n    \\<Longrightarrow> int (y' mod 2) = int_of_integer y mod 2", "apply (simp add: of_nat_mod)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  urel_integer (y AND 1) (int r')\n\ngoal (1 subgoal):\n 1. \\<not> y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')", "from urel_integer_eq[OF this urel_integer_0]"], ["proof (chain)\npicking this:\n  (y AND 1 = 0) = (int r' = 0)", "have rem: \"(y AND 1 = 0) = (r' = 0)\""], ["proof (prove)\nusing this:\n  (y AND 1 = 0) = (int r' = 0)\n\ngoal (1 subgoal):\n 1. (y AND 1 = 0) = (r' = 0)", "by simp"], ["proof (state)\nthis:\n  (y AND 1 = 0) = (r' = 0)\n\ngoal (1 subgoal):\n 1. \\<not> y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')", "have div: \"urel_integer (shiftr y 1) (int d')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (y >> 1) (int d')", "unfolding d'"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (y >> 1) (int (y' div 2))", "using y"], ["proof (prove)\nusing this:\n  urel_integer y (int y')\n\ngoal (1 subgoal):\n 1. urel_integer (y >> 1) (int (y' div 2))", "unfolding urel_integer_def"], ["proof (prove)\nusing this:\n  int y' = int_of_integer y \\<and> 0 \\<le> int y' \\<and> int y' < p\n\ngoal (1 subgoal):\n 1. int (y' div 2) = int_of_integer (y >> 1) \\<and>\n    0 \\<le> int (y' div 2) \\<and> int (y' div 2) < p", "unfolding ppp shiftr_integer_conv_div_pow2"], ["proof (prove)\nusing this:\n  int y' = int_of_integer y \\<and>\n  0 \\<le> int y' \\<and> int y' < int_of_integer pp\n\ngoal (1 subgoal):\n 1. int (y' div 2) = int_of_integer (y div 2 ^ 1) \\<and>\n    0 \\<le> int (y' div 2) \\<and> int (y' div 2) < int_of_integer pp", "by auto"], ["proof (state)\nthis:\n  urel_integer (y >> 1) (int d')\n\ngoal (1 subgoal):\n 1. \\<not> y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')", "from id"], ["proof (chain)\npicking this:\n  (y \\<le> 0) = False\n  (y' = 0) = False", "have \"y' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (y \\<le> 0) = False\n  (y' = 0) = False\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  y' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')", "note IH = 1(1)[OF this refl dr'[symmetric] urel_integer_mult[OF x x] div]"], ["proof (state)\nthis:\n  urel_integer (power_p_integer pp (mult_p_integer pp x x) (y >> 1))\n   (power_p p (mult_p p x' x') d')\n\ngoal (1 subgoal):\n 1. \\<not> y' \\<le> 0 \\<Longrightarrow>\n    urel_integer (power_p_integer pp x y) (power_p p x' y')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (power_p_integer pp x y) (power_p p x' y')", "unfolding power_p.simps[of _ _ \"y'\"] power_p_integer.simps[of _ _ y] dr' id if_False rem"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer\n     (let rec = power_p_integer pp (mult_p_integer pp x x) (y >> 1)\n      in if r' = 0 then rec else mult_p_integer pp rec x)\n     (let (d, r) = (d', r'); rec = power_p p (mult_p p x' x') d\n      in if r = 0 then rec else mult_p p rec x')", "using IH urel_integer_mult[OF IH x]"], ["proof (prove)\nusing this:\n  urel_integer (power_p_integer pp (mult_p_integer pp x x) (y >> 1))\n   (power_p p (mult_p p x' x') d')\n  urel_integer\n   (mult_p_integer pp (power_p_integer pp (mult_p_integer pp x x) (y >> 1))\n     x)\n   (mult_p p (power_p p (mult_p p x' x') d') x')\n\ngoal (1 subgoal):\n 1. urel_integer\n     (let rec = power_p_integer pp (mult_p_integer pp x x) (y >> 1)\n      in if r' = 0 then rec else mult_p_integer pp rec x)\n     (let (d, r) = (d', r'); rec = power_p p (mult_p p x' x') d\n      in if r = 0 then rec else mult_p p rec x')", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  urel_integer (power_p_integer pp x y) (power_p p x' y')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  urel_integer (power_p_integer pp x y) (power_p p x' y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma urel_integer_inverse: assumes x: \"urel_integer x x'\" \n  shows \"urel_integer (inverse_p_integer pp x) (inverse_p p x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (inverse_p_integer pp x) (inverse_p p x')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. urel_integer (inverse_p_integer pp x) (inverse_p p x')", "have p: \"urel_integer (pp - 2) (int (nat (p - 2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (pp - 2) (int (nat (p - 2)))", "using p2"], ["proof (prove)\nusing this:\n  2 \\<le> p\n\ngoal (1 subgoal):\n 1. urel_integer (pp - 2) (int (nat (p - 2)))", "unfolding urel_integer_def"], ["proof (prove)\nusing this:\n  2 \\<le> p\n\ngoal (1 subgoal):\n 1. int (nat (p - 2)) = int_of_integer (pp - 2) \\<and>\n    0 \\<le> int (nat (p - 2)) \\<and> int (nat (p - 2)) < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  2 \\<le> int_of_integer pp\n\ngoal (1 subgoal):\n 1. int (nat (int_of_integer pp - 2)) = int_of_integer (pp - 2) \\<and>\n    0 \\<le> int (nat (int_of_integer pp - 2)) \\<and>\n    int (nat (int_of_integer pp - 2)) < int_of_integer pp", "by auto"], ["proof (state)\nthis:\n  urel_integer (pp - 2) (int (nat (p - 2)))\n\ngoal (1 subgoal):\n 1. urel_integer (inverse_p_integer pp x) (inverse_p p x')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (inverse_p_integer pp x) (inverse_p p x')", "unfolding inverse_p_integer_def inverse_p_def urel_integer_eq[OF x urel_integer_0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer (if x' = 0 then 0 else power_p_integer pp x (pp - 2))\n     (if x' = 0 then 0 else power_p p x' (nat (p - 2)))", "using urel_integer_0 urel_integer_power[OF x p]"], ["proof (prove)\nusing this:\n  urel_integer 0 0\n  urel_integer (power_p_integer pp x (pp - 2)) (power_p p x' (nat (p - 2)))\n\ngoal (1 subgoal):\n 1. urel_integer (if x' = 0 then 0 else power_p_integer pp x (pp - 2))\n     (if x' = 0 then 0 else power_p p x' (nat (p - 2)))", "by auto"], ["proof (state)\nthis:\n  urel_integer (inverse_p_integer pp x) (inverse_p p x')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_ring_0__integer: \"mod_ring_rel_integer 0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel_integer 0 0", "using urel_integer_0 mod_ring_0"], ["proof (prove)\nusing this:\n  urel_integer 0 0\n  mod_ring_rel 0 0\n\ngoal (1 subgoal):\n 1. mod_ring_rel_integer 0 0", "unfolding mod_ring_rel_integer_def"], ["proof (prove)\nusing this:\n  urel_integer 0 0\n  mod_ring_rel 0 0\n\ngoal (1 subgoal):\n 1. \\<exists>z. urel_integer 0 z \\<and> mod_ring_rel z 0", "by blast"], ["", "lemma mod_ring_1__integer: \"mod_ring_rel_integer 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_rel_integer 1 1", "using urel_integer_1 mod_ring_1"], ["proof (prove)\nusing this:\n  urel_integer 1 1\n  mod_ring_rel 1 1\n\ngoal (1 subgoal):\n 1. mod_ring_rel_integer 1 1", "unfolding mod_ring_rel_integer_def"], ["proof (prove)\nusing this:\n  urel_integer 1 1\n  mod_ring_rel 1 1\n\ngoal (1 subgoal):\n 1. \\<exists>z. urel_integer 1 z \\<and> mod_ring_rel z 1", "by blast"], ["", "lemma mod_ring_uminus_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer) (uminus_p_integer pp) uminus\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===> mod_ring_rel_integer) (uminus_p_integer pp)\n     uminus", "using urel_integer_uminus mod_ring_uminus"], ["proof (prove)\nusing this:\n  urel_integer ?x ?y \\<Longrightarrow>\n  urel_integer (uminus_p_integer pp ?x) (uminus_p p ?y)\n  (mod_ring_rel ===> mod_ring_rel) (uminus_p p) uminus\n\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===> mod_ring_rel_integer) (uminus_p_integer pp)\n     uminus", "unfolding mod_ring_rel_integer_def rel_fun_def"], ["proof (prove)\nusing this:\n  urel_integer ?x ?y \\<Longrightarrow>\n  urel_integer (uminus_p_integer pp ?x) (uminus_p p ?y)\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow> mod_ring_rel (uminus_p p x) (- y)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z.\n           urel_integer x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<exists>z.\n           urel_integer (uminus_p_integer pp x) z \\<and>\n           mod_ring_rel z (- y))", "by blast"], ["", "lemma mod_ring_plus_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer ===> mod_ring_rel_integer) (plus_p_integer pp) (+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===>\n     mod_ring_rel_integer ===> mod_ring_rel_integer)\n     (plus_p_integer pp) (+)", "using urel_integer_plus mod_ring_plus"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel_integer ?x ?y; urel_integer ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel_integer (plus_p_integer pp ?x ?x')\n                     (plus_p p ?y ?y')\n  (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (plus_p p) (+)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===>\n     mod_ring_rel_integer ===> mod_ring_rel_integer)\n     (plus_p_integer pp) (+)", "unfolding mod_ring_rel_integer_def rel_fun_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel_integer ?x ?y; urel_integer ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel_integer (plus_p_integer pp ?x ?x')\n                     (plus_p p ?y ?y')\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel xa ya \\<longrightarrow>\n         mod_ring_rel (plus_p p x xa) (y + ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z.\n           urel_integer x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<exists>z.\n               urel_integer xa z \\<and> mod_ring_rel z ya) \\<longrightarrow>\n           (\\<exists>z.\n               urel_integer (plus_p_integer pp x xa) z \\<and>\n               mod_ring_rel z (y + ya)))", "by blast"], ["", "lemma mod_ring_minus_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer ===> mod_ring_rel_integer) (minus_p_integer pp) (-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===>\n     mod_ring_rel_integer ===> mod_ring_rel_integer)\n     (minus_p_integer pp) (-)", "using urel_integer_minus mod_ring_minus"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel_integer ?x ?y; urel_integer ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel_integer (minus_p_integer pp ?x ?x')\n                     (minus_p p ?y ?y')\n  (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (minus_p p) (-)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===>\n     mod_ring_rel_integer ===> mod_ring_rel_integer)\n     (minus_p_integer pp) (-)", "unfolding mod_ring_rel_integer_def rel_fun_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel_integer ?x ?y; urel_integer ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel_integer (minus_p_integer pp ?x ?x')\n                     (minus_p p ?y ?y')\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel xa ya \\<longrightarrow>\n         mod_ring_rel (minus_p p x xa) (y - ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z.\n           urel_integer x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<exists>z.\n               urel_integer xa z \\<and> mod_ring_rel z ya) \\<longrightarrow>\n           (\\<exists>z.\n               urel_integer (minus_p_integer pp x xa) z \\<and>\n               mod_ring_rel z (y - ya)))", "by blast"], ["", "lemma mod_ring_mult_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer ===> mod_ring_rel_integer) (mult_p_integer pp) ((*))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===>\n     mod_ring_rel_integer ===> mod_ring_rel_integer)\n     (mult_p_integer pp) (*)", "using urel_integer_mult mod_ring_mult"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel_integer ?x ?y; urel_integer ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel_integer (mult_p_integer pp ?x ?x')\n                     (mult_p p ?y ?y')\n  (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel) (mult_p p) (*)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===>\n     mod_ring_rel_integer ===> mod_ring_rel_integer)\n     (mult_p_integer pp) (*)", "unfolding mod_ring_rel_integer_def rel_fun_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel_integer ?x ?y; urel_integer ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> urel_integer (mult_p_integer pp ?x ?x')\n                     (mult_p p ?y ?y')\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel xa ya \\<longrightarrow>\n         mod_ring_rel (mult_p p x xa) (y * ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z.\n           urel_integer x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<exists>z.\n               urel_integer xa z \\<and> mod_ring_rel z ya) \\<longrightarrow>\n           (\\<exists>z.\n               urel_integer (mult_p_integer pp x xa) z \\<and>\n               mod_ring_rel z (y * ya)))", "by blast"], ["", "lemma mod_ring_eq_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer ===> (=)) (=) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===> mod_ring_rel_integer ===> (=)) (=) (=)", "using urel_integer_eq mod_ring_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel_integer ?x ?y; urel_integer ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> (?x = ?x') = (?y = ?y')\n  (mod_ring_rel ===> mod_ring_rel ===> (=)) (=) (=)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===> mod_ring_rel_integer ===> (=)) (=) (=)", "unfolding mod_ring_rel_integer_def rel_fun_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel_integer ?x ?y; urel_integer ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> (?x = ?x') = (?y = ?y')\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel xa ya \\<longrightarrow> (x = xa) = (y = ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z.\n           urel_integer x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<exists>z.\n               urel_integer xa z \\<and> mod_ring_rel z ya) \\<longrightarrow>\n           (x = xa) = (y = ya))", "by blast"], ["", "lemma urel_integer_inj: \"urel_integer x y \\<Longrightarrow> urel_integer x z \\<Longrightarrow> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>urel_integer x y; urel_integer x z\\<rbrakk>\n    \\<Longrightarrow> y = z", "using urel_integer_eq[of x y x z]"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel_integer x y; urel_integer x z\\<rbrakk>\n  \\<Longrightarrow> (x = x) = (y = z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>urel_integer x y; urel_integer x z\\<rbrakk>\n    \\<Longrightarrow> y = z", "by auto"], ["", "lemma urel_integer_inj': \"urel_integer x z \\<Longrightarrow> urel_integer y z \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>urel_integer x z; urel_integer y z\\<rbrakk>\n    \\<Longrightarrow> x = y", "using urel_integer_eq[of x z y z]"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel_integer x z; urel_integer y z\\<rbrakk>\n  \\<Longrightarrow> (x = y) = (z = z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>urel_integer x z; urel_integer y z\\<rbrakk>\n    \\<Longrightarrow> x = y", "by auto"], ["", "lemma bi_unique_mod_ring_rel_integer:\n  \"bi_unique mod_ring_rel_integer\" \"left_unique mod_ring_rel_integer\" \"right_unique mod_ring_rel_integer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique mod_ring_rel_integer &&&\n    left_unique mod_ring_rel_integer &&& right_unique mod_ring_rel_integer", "using bi_unique_mod_ring_rel urel_integer_inj'"], ["proof (prove)\nusing this:\n  bi_unique mod_ring_rel\n  left_unique mod_ring_rel\n  right_unique mod_ring_rel\n  \\<lbrakk>urel_integer ?x ?z; urel_integer ?y ?z\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. bi_unique mod_ring_rel_integer &&&\n    left_unique mod_ring_rel_integer &&& right_unique mod_ring_rel_integer", "unfolding mod_ring_rel_integer_def bi_unique_def left_unique_def right_unique_def"], ["proof (prove)\nusing this:\n  (\\<forall>x y z.\n      mod_ring_rel x y \\<longrightarrow>\n      mod_ring_rel x z \\<longrightarrow> y = z) \\<and>\n  (\\<forall>x y z.\n      mod_ring_rel x z \\<longrightarrow>\n      mod_ring_rel y z \\<longrightarrow> x = y)\n  \\<forall>x y z.\n     mod_ring_rel x z \\<longrightarrow>\n     mod_ring_rel y z \\<longrightarrow> x = y\n  \\<forall>x y z.\n     mod_ring_rel x y \\<longrightarrow>\n     mod_ring_rel x z \\<longrightarrow> y = z\n  \\<lbrakk>urel_integer ?x ?z; urel_integer ?y ?z\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        (\\<exists>z.\n            urel_integer x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n        (\\<exists>za.\n            urel_integer x za \\<and> mod_ring_rel za z) \\<longrightarrow>\n        y = z) \\<and>\n    (\\<forall>x y z.\n        (\\<exists>za.\n            urel_integer x za \\<and> mod_ring_rel za z) \\<longrightarrow>\n        (\\<exists>za.\n            urel_integer y za \\<and> mod_ring_rel za z) \\<longrightarrow>\n        x = y) &&&\n    \\<forall>x y z.\n       (\\<exists>za.\n           urel_integer x za \\<and> mod_ring_rel za z) \\<longrightarrow>\n       (\\<exists>za.\n           urel_integer y za \\<and> mod_ring_rel za z) \\<longrightarrow>\n       x = y &&&\n    \\<forall>x y z.\n       (\\<exists>z.\n           urel_integer x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<exists>za.\n           urel_integer x za \\<and> mod_ring_rel za z) \\<longrightarrow>\n       y = z", "by (auto simp: urel_integer_def)"], ["", "lemma right_total_mod_ring_rel_integer: \"right_total mod_ring_rel_integer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total mod_ring_rel_integer", "unfolding mod_ring_rel_integer_def right_total_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x z. urel_integer x z \\<and> mod_ring_rel z y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x z. urel_integer x z \\<and> mod_ring_rel z y", "fix y :: \"'a mod_ring\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x z. urel_integer x z \\<and> mod_ring_rel z y", "from right_total_mod_ring_rel[unfolded right_total_def, rule_format, of y]"], ["proof (chain)\npicking this:\n  \\<exists>x. mod_ring_rel x y", "obtain z where zy: \"mod_ring_rel z y\""], ["proof (prove)\nusing this:\n  \\<exists>x. mod_ring_rel x y\n\ngoal (1 subgoal):\n 1. (\\<And>z. mod_ring_rel z y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mod_ring_rel z y\n\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x z. urel_integer x z \\<and> mod_ring_rel z y", "hence zp: \"0 \\<le> z\" \"z < p\""], ["proof (prove)\nusing this:\n  mod_ring_rel z y\n\ngoal (1 subgoal):\n 1. 0 \\<le> z &&& z < p", "unfolding mod_ring_rel_def p"], ["proof (prove)\nusing this:\n  z = to_int_mod_ring y\n\ngoal (1 subgoal):\n 1. 0 \\<le> z &&& z < int CARD('a)", "using range_to_int_mod_ring[where 'a = 'a]"], ["proof (prove)\nusing this:\n  z = to_int_mod_ring y\n  range to_int_mod_ring = {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. 0 \\<le> z &&& z < int CARD('a)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x z. urel_integer x z \\<and> mod_ring_rel z y", "hence \"urel_integer (integer_of_int z) z\""], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. urel_integer (integer_of_int z) z", "unfolding urel_integer_def"], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. z = int_of_integer (integer_of_int z) \\<and> 0 \\<le> z \\<and> z < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z < int_of_integer pp\n\ngoal (1 subgoal):\n 1. z = int_of_integer (integer_of_int z) \\<and>\n    0 \\<le> z \\<and> z < int_of_integer pp", "by auto"], ["proof (state)\nthis:\n  urel_integer (integer_of_int z) z\n\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x z. urel_integer x z \\<and> mod_ring_rel z y", "with zy"], ["proof (chain)\npicking this:\n  mod_ring_rel z y\n  urel_integer (integer_of_int z) z", "show \"\\<exists> x z. urel_integer x z \\<and> mod_ring_rel z y\""], ["proof (prove)\nusing this:\n  mod_ring_rel z y\n  urel_integer (integer_of_int z) z\n\ngoal (1 subgoal):\n 1. \\<exists>x z. urel_integer x z \\<and> mod_ring_rel z y", "by blast"], ["proof (state)\nthis:\n  \\<exists>x z. urel_integer x z \\<and> mod_ring_rel z y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Domainp_mod_ring_rel_integer: \"Domainp mod_ring_rel_integer = (\\<lambda>x. 0 \\<le> x \\<and> x < pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel_integer = (\\<lambda>x. 0 \\<le> x \\<and> x < pp)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Domainp mod_ring_rel_integer x = (0 \\<le> x \\<and> x < pp)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Domainp mod_ring_rel_integer x = (0 \\<le> x \\<and> x < pp)", "show \"Domainp mod_ring_rel_integer x = (0 \\<le> x \\<and> x < pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel_integer x = (0 \\<le> x \\<and> x < pp)", "unfolding Domainp.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a b. x = a \\<and> mod_ring_rel_integer a b) =\n    (0 \\<le> x \\<and> x < pp)", "unfolding mod_ring_rel_integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a b.\n        x = a \\<and>\n        (\\<exists>z. urel_integer a z \\<and> mod_ring_rel z b)) =\n    (0 \\<le> x \\<and> x < pp)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z.\n           urel_integer a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel_integer a z \\<and> mod_ring_rel z b)", "let ?i = \"int_of_integer\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z.\n           urel_integer a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel_integer a z \\<and> mod_ring_rel z b)", "assume *: \"0 \\<le> x \\<and> x < pp\""], ["proof (state)\nthis:\n  0 \\<le> x \\<and> x < pp\n\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z.\n           urel_integer a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel_integer a z \\<and> mod_ring_rel z b)", "hence \"0 \\<le> ?i x \\<and> ?i x < p\""], ["proof (prove)\nusing this:\n  0 \\<le> x \\<and> x < pp\n\ngoal (1 subgoal):\n 1. 0 \\<le> int_of_integer x \\<and> int_of_integer x < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  0 \\<le> x \\<and> x < pp\n\ngoal (1 subgoal):\n 1. 0 \\<le> int_of_integer x \\<and> int_of_integer x < int_of_integer pp", "by (simp add: le_int_of_integer less_integer.rep_eq)"], ["proof (state)\nthis:\n  0 \\<le> int_of_integer x \\<and> int_of_integer x < p\n\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z.\n           urel_integer a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel_integer a z \\<and> mod_ring_rel z b)", "hence \"?i x \\<in> {0 ..< p}\""], ["proof (prove)\nusing this:\n  0 \\<le> int_of_integer x \\<and> int_of_integer x < p\n\ngoal (1 subgoal):\n 1. int_of_integer x \\<in> {0..<p}", "by auto"], ["proof (state)\nthis:\n  int_of_integer x \\<in> {0..<p}\n\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z.\n           urel_integer a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel_integer a z \\<and> mod_ring_rel z b)", "with Domainp_mod_ring_rel"], ["proof (chain)\npicking this:\n  Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})\n  int_of_integer x \\<in> {0..<p}", "have \"Domainp mod_ring_rel (?i x)\""], ["proof (prove)\nusing this:\n  Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})\n  int_of_integer x \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel (int_of_integer x)", "by auto"], ["proof (state)\nthis:\n  Domainp mod_ring_rel (int_of_integer x)\n\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z.\n           urel_integer a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel_integer a z \\<and> mod_ring_rel z b)", "from this[unfolded Domainp.simps]"], ["proof (chain)\npicking this:\n  \\<exists>a b. int_of_integer x = a \\<and> mod_ring_rel a b", "obtain b where b: \"mod_ring_rel (?i x) b\""], ["proof (prove)\nusing this:\n  \\<exists>a b. int_of_integer x = a \\<and> mod_ring_rel a b\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        mod_ring_rel (int_of_integer x) b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mod_ring_rel (int_of_integer x) b\n\ngoal (2 subgoals):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z.\n           urel_integer a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp\n 2. 0 \\<le> x \\<and> x < pp \\<Longrightarrow>\n    \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel_integer a z \\<and> mod_ring_rel z b)", "show \"\\<exists>a b. x = a \\<and> (\\<exists>z. urel_integer a z \\<and> mod_ring_rel z b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and> (\\<exists>z. urel_integer a z \\<and> mod_ring_rel z b)", "proof (intro exI, rule conjI[OF refl], rule exI, rule conjI[OF _ b])"], ["proof (state)\ngoal (1 subgoal):\n 1. urel_integer x (int_of_integer x)", "show \"urel_integer x (?i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. urel_integer x (int_of_integer x)", "unfolding urel_integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_integer x = int_of_integer x \\<and>\n    0 \\<le> int_of_integer x \\<and> int_of_integer x < p", "using *"], ["proof (prove)\nusing this:\n  0 \\<le> x \\<and> x < pp\n\ngoal (1 subgoal):\n 1. int_of_integer x = int_of_integer x \\<and>\n    0 \\<le> int_of_integer x \\<and> int_of_integer x < p", "unfolding ppp"], ["proof (prove)\nusing this:\n  0 \\<le> x \\<and> x < pp\n\ngoal (1 subgoal):\n 1. int_of_integer x = int_of_integer x \\<and>\n    0 \\<le> int_of_integer x \\<and> int_of_integer x < int_of_integer pp", "by (simp add: le_int_of_integer less_integer.rep_eq)"], ["proof (state)\nthis:\n  urel_integer x (int_of_integer x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a b.\n     x = a \\<and> (\\<exists>z. urel_integer a z \\<and> mod_ring_rel z b)\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z.\n           urel_integer a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z.\n           urel_integer a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "assume \"\\<exists>a b. x = a \\<and> (\\<exists>z. urel_integer a z \\<and> mod_ring_rel z b)\""], ["proof (state)\nthis:\n  \\<exists>a b.\n     x = a \\<and> (\\<exists>z. urel_integer a z \\<and> mod_ring_rel z b)\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z.\n           urel_integer a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "then"], ["proof (chain)\npicking this:\n  \\<exists>a b.\n     x = a \\<and> (\\<exists>z. urel_integer a z \\<and> mod_ring_rel z b)", "obtain b z where xz: \"urel_integer x z\" and zb: \"mod_ring_rel z b\""], ["proof (prove)\nusing this:\n  \\<exists>a b.\n     x = a \\<and> (\\<exists>z. urel_integer a z \\<and> mod_ring_rel z b)\n\ngoal (1 subgoal):\n 1. (\\<And>z b.\n        \\<lbrakk>urel_integer x z; mod_ring_rel z b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  urel_integer x z\n  mod_ring_rel z b\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z.\n           urel_integer a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "hence \"Domainp mod_ring_rel z\""], ["proof (prove)\nusing this:\n  urel_integer x z\n  mod_ring_rel z b\n\ngoal (1 subgoal):\n 1. Domainp mod_ring_rel z", "by auto"], ["proof (state)\nthis:\n  Domainp mod_ring_rel z\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z.\n           urel_integer a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "with Domainp_mod_ring_rel"], ["proof (chain)\npicking this:\n  Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})\n  Domainp mod_ring_rel z", "have \"0 \\<le> z\" \"z < p\""], ["proof (prove)\nusing this:\n  Domainp mod_ring_rel = (\\<lambda>v. v \\<in> {0..<p})\n  Domainp mod_ring_rel z\n\ngoal (1 subgoal):\n 1. 0 \\<le> z &&& z < p", "by auto"], ["proof (state)\nthis:\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       x = a \\<and>\n       (\\<exists>z.\n           urel_integer a z \\<and> mod_ring_rel z b) \\<Longrightarrow>\n    0 \\<le> x \\<and> x < pp", "with xz"], ["proof (chain)\npicking this:\n  urel_integer x z\n  0 \\<le> z\n  z < p", "show \"0 \\<le> x \\<and> x < pp\""], ["proof (prove)\nusing this:\n  urel_integer x z\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x < pp", "unfolding urel_integer_def"], ["proof (prove)\nusing this:\n  z = int_of_integer x \\<and> 0 \\<le> z \\<and> z < p\n  0 \\<le> z\n  z < p\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x < pp", "unfolding ppp"], ["proof (prove)\nusing this:\n  z = int_of_integer x \\<and> 0 \\<le> z \\<and> z < int_of_integer pp\n  0 \\<le> z\n  z < int_of_integer pp\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x < pp", "by (simp add: le_int_of_integer less_integer.rep_eq)"], ["proof (state)\nthis:\n  0 \\<le> x \\<and> x < pp\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Domainp mod_ring_rel_integer x = (0 \\<le> x \\<and> x < pp)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ring_finite_field_ops_integer: \"ring_ops (finite_field_ops_integer pp) mod_ring_rel_integer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_ops (finite_field_ops_integer pp) mod_ring_rel_integer", "by (unfold_locales, auto simp:\n  finite_field_ops_integer_def\n  bi_unique_mod_ring_rel_integer\n  right_total_mod_ring_rel_integer\n  mod_ring_plus_integer\n  mod_ring_minus_integer\n  mod_ring_uminus_integer\n  mod_ring_mult_integer\n  mod_ring_eq_integer\n  mod_ring_0__integer\n  mod_ring_1__integer\n  Domainp_mod_ring_rel_integer)"], ["", "end"], ["", "end"], ["", "context prime_field\nbegin"], ["", "context fixes pp :: \"integer\" \n  assumes *: \"p = int_of_integer pp\"  \nbegin"], ["", "lemma mod_ring_normalize_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer) (\\<lambda>x. if x = 0 then 0 else 1) normalize\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===> mod_ring_rel_integer)\n     (\\<lambda>x. if x = 0 then 0 else 1) normalize", "using urel_integer_normalize[OF *] mod_ring_normalize"], ["proof (prove)\nusing this:\n  urel_integer ?x ?y \\<Longrightarrow>\n  urel_integer (if ?x = 0 then 0 else 1) (if ?y = 0 then 0 else 1)\n  (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. if x = 0 then 0 else 1)\n   normalize\n\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===> mod_ring_rel_integer)\n     (\\<lambda>x. if x = 0 then 0 else 1) normalize", "unfolding mod_ring_rel_integer_def[OF *] rel_fun_def"], ["proof (prove)\nusing this:\n  urel_integer ?x ?y \\<Longrightarrow>\n  urel_integer (if ?x = 0 then 0 else 1) (if ?y = 0 then 0 else 1)\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     mod_ring_rel (if x = 0 then 0 else 1) (normalize y)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z.\n           urel_integer x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<exists>z.\n           urel_integer (if x = 0 then 0 else 1) z \\<and>\n           mod_ring_rel z (normalize y))", "by blast"], ["", "lemma mod_ring_mod_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer ===> mod_ring_rel_integer) (\\<lambda>x y. if y = 0 then x else 0) (mod)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===>\n     mod_ring_rel_integer ===> mod_ring_rel_integer)\n     (\\<lambda>x y. if y = 0 then x else 0) (mod)", "using urel_integer_mod[OF *] mod_ring_mod"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel_integer ?x ?x'; urel_integer ?y ?y'\\<rbrakk>\n  \\<Longrightarrow> urel_integer (if ?y = 0 then ?x else 0)\n                     (if ?y' = 0 then ?x' else 0)\n  (mod_ring_rel ===> mod_ring_rel ===> mod_ring_rel)\n   (\\<lambda>x y. if y = 0 then x else 0) (mod)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===>\n     mod_ring_rel_integer ===> mod_ring_rel_integer)\n     (\\<lambda>x y. if y = 0 then x else 0) (mod)", "unfolding mod_ring_rel_integer_def[OF *] rel_fun_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>urel_integer ?x ?x'; urel_integer ?y ?y'\\<rbrakk>\n  \\<Longrightarrow> urel_integer (if ?y = 0 then ?x else 0)\n                     (if ?y' = 0 then ?x' else 0)\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel xa ya \\<longrightarrow>\n         mod_ring_rel (if xa = 0 then x else 0) (y mod ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z.\n           urel_integer x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<exists>z.\n               urel_integer xa z \\<and> mod_ring_rel z ya) \\<longrightarrow>\n           (\\<exists>z.\n               urel_integer (if xa = 0 then x else 0) z \\<and>\n               mod_ring_rel z (y mod ya)))", "by blast"], ["", "lemma mod_ring_unit_factor_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer) (\\<lambda>x. x) unit_factor\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===> mod_ring_rel_integer) (\\<lambda>x. x)\n     unit_factor", "using mod_ring_unit_factor"], ["proof (prove)\nusing this:\n  (mod_ring_rel ===> mod_ring_rel) (\\<lambda>x. x) unit_factor\n\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===> mod_ring_rel_integer) (\\<lambda>x. x)\n     unit_factor", "unfolding mod_ring_rel_integer_def[OF *] rel_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow> mod_ring_rel x (unit_factor y)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z.\n           urel_integer x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<exists>z. urel_integer x z \\<and> mod_ring_rel z (unit_factor y))", "by blast"], ["", "lemma mod_ring_inverse_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer) (inverse_p_integer pp) inverse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===> mod_ring_rel_integer) (inverse_p_integer pp)\n     inverse", "using urel_integer_inverse[OF *] mod_ring_inverse"], ["proof (prove)\nusing this:\n  urel_integer ?x ?x' \\<Longrightarrow>\n  urel_integer (inverse_p_integer pp ?x) (inverse_p p ?x')\n  (mod_ring_rel ===> mod_ring_rel) (inverse_p p) inverse\n\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===> mod_ring_rel_integer) (inverse_p_integer pp)\n     inverse", "unfolding mod_ring_rel_integer_def[OF *] rel_fun_def"], ["proof (prove)\nusing this:\n  urel_integer ?x ?x' \\<Longrightarrow>\n  urel_integer (inverse_p_integer pp ?x) (inverse_p p ?x')\n  \\<forall>x y.\n     mod_ring_rel x y \\<longrightarrow>\n     mod_ring_rel (inverse_p p x) (inverse y)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>z.\n           urel_integer x z \\<and> mod_ring_rel z y) \\<longrightarrow>\n       (\\<exists>z.\n           urel_integer (inverse_p_integer pp x) z \\<and>\n           mod_ring_rel z (inverse y))", "by blast"], ["", "lemma mod_ring_divide_integer: \"(mod_ring_rel_integer ===> mod_ring_rel_integer ===> mod_ring_rel_integer) (divide_p_integer pp) (/)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===>\n     mod_ring_rel_integer ===> mod_ring_rel_integer)\n     (divide_p_integer pp) (/)", "using mod_ring_inverse_integer mod_ring_mult_integer[OF *]"], ["proof (prove)\nusing this:\n  (mod_ring_rel_integer ===> mod_ring_rel_integer) (inverse_p_integer pp)\n   inverse\n  (mod_ring_rel_integer ===> mod_ring_rel_integer ===> mod_ring_rel_integer)\n   (mult_p_integer pp) (*)\n\ngoal (1 subgoal):\n 1. (mod_ring_rel_integer ===>\n     mod_ring_rel_integer ===> mod_ring_rel_integer)\n     (divide_p_integer pp) (/)", "unfolding divide_p_integer_def divide_mod_ring_def inverse_mod_ring_def[symmetric]\n    rel_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     mod_ring_rel_integer x y \\<longrightarrow>\n     mod_ring_rel_integer (inverse_p_integer pp x) (inverse y)\n  \\<forall>x y.\n     mod_ring_rel_integer x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         mod_ring_rel_integer xa ya \\<longrightarrow>\n         mod_ring_rel_integer (mult_p_integer pp x xa) (y * ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       mod_ring_rel_integer x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           mod_ring_rel_integer xa ya \\<longrightarrow>\n           mod_ring_rel_integer\n            (mult_p_integer pp x (inverse_p_integer pp xa))\n            (y * inverse ya))", "by blast"], ["", "lemma finite_field_ops_integer: \"field_ops (finite_field_ops_integer pp) mod_ring_rel_integer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. field_ops (finite_field_ops_integer pp) mod_ring_rel_integer", "by (unfold_locales, insert ring_finite_field_ops_integer[OF *], auto simp:\n  ring_ops_def\n  finite_field_ops_integer_def\n  mod_ring_divide_integer\n  mod_ring_inverse_integer\n  mod_ring_mod_integer\n  mod_ring_normalize_integer)"], ["", "end"], ["", "end"], ["", "context prime_field\nbegin"], ["", "(* four implementations of modular integer arithmetic for finite fields *)"], ["", "thm \n  finite_field_ops64\n  finite_field_ops32\n  finite_field_ops_integer\n  finite_field_ops_int"], ["", "end"], ["", "context mod_ring_locale\nbegin"], ["", "(* four implementations of modular integer arithmetic for finite rings *)"], ["", "thm \n  ring_finite_field_ops64\n  ring_finite_field_ops32\n  ring_finite_field_ops_integer\n  ring_finite_field_ops_int"], ["", "end"], ["", "no_notation shiftr (infixl \">>\" 55)"], ["", "(* to avoid conflict with bind *)"], ["", "end"]]}