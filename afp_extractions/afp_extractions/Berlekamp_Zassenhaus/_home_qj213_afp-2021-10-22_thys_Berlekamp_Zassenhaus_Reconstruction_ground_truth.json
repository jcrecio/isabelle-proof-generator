{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Reconstruction.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma foldr_of_Cons[simp]: \"foldr Cons xs ys = xs @ ys\"", "lemma foldr_map_prod[simp]:\n  \"foldr (\\<lambda>x. map_prod (f x) (g x)) xs base = (foldr f xs (fst base), foldr g xs (snd base))\"", "lemma coeff_mult_0: \"coeff (f * g) 0 = coeff f 0 * coeff g 0\"", "lemma lead_coeff_factor: assumes u: \"u = v * (w :: 'a ::idom poly)\"\n  shows \"smult (lead_coeff u) u = (smult (lead_coeff w) v) * (smult (lead_coeff v) w)\"\n  \"lead_coeff (smult (lead_coeff w) v) = lead_coeff u\" \"lead_coeff (smult (lead_coeff v) w) = lead_coeff u\"", "lemma not_irreducible\\<^sub>d_lead_coeff_factors: assumes \"\\<not> irreducible\\<^sub>d (u :: 'a :: idom poly)\" \"degree u \\<noteq> 0\" \n  shows \"\\<exists> f g. smult (lead_coeff u) u = f * g \\<and> lead_coeff f = lead_coeff u \\<and> lead_coeff g = lead_coeff u\n  \\<and> degree f < degree u \\<and> degree g < degree u\"", "lemma mset_subseqs_size: \"mset ` {ys. ys \\<in> set (subseqs xs) \\<and> length ys = n} = \n  {ws. ws \\<subseteq># mset xs \\<and> size ws = n}\"", "lemma prod_list_m[simp]: \"prod_list_m fs = Mp (prod_list fs)\"", "lemma inv_Mp_coeff: \"coeff (inv_Mp f) n = inv_M (coeff f n)\"", "lemma Mp_inv_Mp_id[simp]: \"Mp (inv_Mp f) = Mp f\"", "lemma inv_Mp_rev: assumes bnd: \"\\<And> n. 2 * abs (coeff f n) < m\" \n  shows \"inv_Mp (Mp f) = f\"", "lemma mul_const_commute_below: \"mul_const x (mul_const y z) = mul_const y (mul_const x z)\"", "lemma large_m_factor: \"large_m u vs \\<Longrightarrow> v dvd u \\<Longrightarrow> large_m v vs\"", "lemma test_dvd_factor: assumes u: \"u \\<noteq> 0\" and test: \"test_dvd u ws\" and vu: \"v dvd u\" \n  shows \"test_dvd v ws\"", "lemma coprime_exp_mod: \"coprime lu p \\<Longrightarrow> prime p \\<Longrightarrow> n \\<noteq> 0 \\<Longrightarrow> lu mod p ^ n \\<noteq> 0\"", "lemma reconstruction: assumes\n    res: \"reconstruction sl_impl m2 state u (smult lu u) lu d r vs res cands = fs\"\n  and f: \"f = u * prod_list res\"\n  and meas: \"meas = (r - d, cands)\" \n  and dr: \"d + d \\<le> r\" \n  and r: \"r = length vs\" \n  and cands: \"set cands \\<subseteq> S (lu,[]) vs d\"\n  and d0: \"d = 0 \\<Longrightarrow> cands = []\" \n  and lu: \"lu = lead_coeff u\" \n  and factors: \"unique_factorization_m u (lu,mset vs)\" \n  and sf: \"poly_mod.square_free_m p u\" \n  and cop: \"coprime lu p\"\n  and norm: \"\\<And> v.  v \\<in> set vs \\<Longrightarrow> Mp v = v\" \n  and tests: \"\\<And> ws. ws \\<subseteq># mset vs \\<Longrightarrow> ws \\<noteq> {#} \\<Longrightarrow> \n    size ws < d \\<or> size ws = d \\<and> ws \\<notin> (mset o snd) ` set cands \n    \\<Longrightarrow> test_dvd u ws\"\n  and irr: \"\\<And> f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f\" \n  and deg: \"degree u > 0\" \n  and cands_ne: \"cands \\<noteq> [] \\<Longrightarrow> d < r\" \n  and large: \"\\<forall> v n. v dvd smult lu u \\<longrightarrow> degree v \\<le> degree_bound vs \n    \\<longrightarrow> 2 * abs (coeff v n) < m\" \n  and f0: \"f \\<noteq> 0\"\n  and state: \"sli (lu,[]) vs d state\" \n  and m2: \"m2 = m div 2\" \n  shows \"f = prod_list fs \\<and> (\\<forall> fi \\<in> set fs. irreducible\\<^sub>d fi)\"", "lemma n: \"n \\<noteq> 0\"", "lemma zassenhaus_reconstruction_generic:\n  assumes sl_impl: \"correct_subseqs_foldr_impl (\\<lambda>v. map_prod (poly_mod.mul_const (p^n) v) (Cons v)) sl_impl sli\"\n  and res: \"zassenhaus_reconstruction_generic sl_impl hs p n f = fs\" \n  shows \"f = prod_list fs \\<and> (\\<forall> fi \\<in> set fs. irreducible\\<^sub>d fi)\"", "lemma zassenhaus_reconstruction_irreducible\\<^sub>d:\n  assumes res: \"zassenhaus_reconstruction hs p n f = fs\"\n  shows \"f = prod_list fs \\<and> (\\<forall> fi \\<in> set fs. irreducible\\<^sub>d fi)\""], "translations": [["", "lemma foldr_of_Cons[simp]: \"foldr Cons xs ys = xs @ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (#) xs ys = xs @ ys", "by (induct xs, auto)"], ["", "lemma foldr_map_prod[simp]:\n  \"foldr (\\<lambda>x. map_prod (f x) (g x)) xs base = (foldr f xs (fst base), foldr g xs (snd base))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x. map_prod (f x) (g x)) xs base =\n    (foldr f xs (fst base), foldr g xs (snd base))", "by (induct xs, auto)"], ["", "paragraph \\<open>The main part\\<close>"], ["", "context poly_mod\nbegin"], ["", "definition inv_Mp :: \"int poly \\<Rightarrow> int poly\" where\n  \"inv_Mp = map_poly inv_M\""], ["", "definition mul_const :: \"int poly \\<Rightarrow> int \\<Rightarrow> int\" where\n  \"mul_const p c = (coeff p 0 * c) mod m\""], ["", "fun prod_list_m :: \"int poly list \\<Rightarrow> int poly\" where\n  \"prod_list_m (f # fs) = Mp (f * prod_list_m fs)\" \n| \"prod_list_m [] = 1\""], ["", "context\n  fixes sl_impl :: \"(int poly, int \\<times> int poly list, 'state)subseqs_foldr_impl\" \n  and m2 :: \"int\" \nbegin"], ["", "definition inv_M2 :: \"int \\<Rightarrow> int\" where\n  \"inv_M2 = (\\<lambda> x. if x \\<le> m2 then x else x - m)\""], ["", "definition inv_Mp2 :: \"int poly \\<Rightarrow> int poly\" where\n  \"inv_Mp2 = map_poly inv_M2\""], ["", "partial_function (tailrec) reconstruction :: \"'state \\<Rightarrow> int poly \\<Rightarrow> int poly \n  \\<Rightarrow> int \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> int poly list \\<Rightarrow> int poly list \n  \\<Rightarrow> (int \\<times> (int poly list)) list \\<Rightarrow> int poly list\" where\n  \"reconstruction state u luu lu d r vs res cands = (case cands of Nil\n    \\<Rightarrow> let d' = Suc d\n      in if d' + d' > r then (u # res) else \n      (case next_subseqs_foldr sl_impl state of (cands,state') \\<Rightarrow>\n        reconstruction state' u luu lu d' r vs res cands)\n   | (lv',ws) # cands' \\<Rightarrow> let\n       lv = inv_M2 lv' \\<comment> \\<open>\\<open>lv\\<close> is last coefficient of \\<open>vb\\<close> below\\<close>\n     in if lv dvd coeff luu 0 then let\n       vb = inv_Mp2 (Mp (smult lu (prod_list_m ws))) \n    in if vb dvd luu then \n      let pp_vb = primitive_part vb;\n          u' = u div pp_vb;\n          r' = r - length ws;\n          res' = pp_vb # res\n        in if d + d > r' \n          then u' # res'\n          else let \n              lu' = lead_coeff u';\n              vs' = fold remove1 ws vs;\n              (cands'', state') = subseqs_foldr sl_impl (lu',[]) vs' d\n            in reconstruction state' u' (smult lu' u') lu' d r' vs' res' cands''\n     else reconstruction state u luu lu d r vs res cands'\n     else reconstruction state u luu lu d r vs res cands')\""], ["", "end"], ["", "end"], ["", "declare poly_mod.reconstruction.simps[code]"], ["", "declare poly_mod.prod_list_m.simps[code]"], ["", "declare poly_mod.mul_const_def[code]"], ["", "declare poly_mod.inv_M2_def[code]"], ["", "declare poly_mod.inv_Mp2_def[code_unfold]"], ["", "declare poly_mod.inv_Mp_def[code_unfold]"], ["", "definition zassenhaus_reconstruction_generic :: \n  \"(int poly, int \\<times> int poly list, 'state) subseqs_foldr_impl\n  \\<Rightarrow> int poly list \\<Rightarrow> int \\<Rightarrow> nat \\<Rightarrow> int poly \\<Rightarrow> int poly list\" where\n  \"zassenhaus_reconstruction_generic sl_impl vs p n f = (let\n     lf = lead_coeff f;\n     pn = p^n;\n     (_, state) = subseqs_foldr sl_impl (lf,[]) vs 0\n   in \n     poly_mod.reconstruction pn sl_impl (pn div 2) state f (smult lf f) lf 0 (length vs) vs [] [])\""], ["", "lemma coeff_mult_0: \"coeff (f * g) 0 = coeff f 0 * coeff g 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (f * g) 0 = coeff f 0 * coeff g 0", "by (metis poly_0_coeff_0 poly_mult)"], ["", "lemma lead_coeff_factor: assumes u: \"u = v * (w :: 'a ::idom poly)\"\n  shows \"smult (lead_coeff u) u = (smult (lead_coeff w) v) * (smult (lead_coeff v) w)\"\n  \"lead_coeff (smult (lead_coeff w) v) = lead_coeff u\" \"lead_coeff (smult (lead_coeff v) w) = lead_coeff u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (lead_coeff u) u =\n    Polynomial.smult (lead_coeff w) v *\n    Polynomial.smult (lead_coeff v) w &&&\n    lead_coeff (Polynomial.smult (lead_coeff w) v) = lead_coeff u &&&\n    lead_coeff (Polynomial.smult (lead_coeff v) w) = lead_coeff u", "unfolding u"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (lead_coeff (v * w)) (v * w) =\n    Polynomial.smult (lead_coeff w) v *\n    Polynomial.smult (lead_coeff v) w &&&\n    lead_coeff (Polynomial.smult (lead_coeff w) v) = lead_coeff (v * w) &&&\n    lead_coeff (Polynomial.smult (lead_coeff v) w) = lead_coeff (v * w)", "by (auto simp: lead_coeff_mult lead_coeff_smult)"], ["", "lemma not_irreducible\\<^sub>d_lead_coeff_factors: assumes \"\\<not> irreducible\\<^sub>d (u :: 'a :: idom poly)\" \"degree u \\<noteq> 0\" \n  shows \"\\<exists> f g. smult (lead_coeff u) u = f * g \\<and> lead_coeff f = lead_coeff u \\<and> lead_coeff g = lead_coeff u\n  \\<and> degree f < degree u \\<and> degree g < degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f g.\n       Polynomial.smult (lead_coeff u) u = f * g \\<and>\n       lead_coeff f = lead_coeff u \\<and>\n       lead_coeff g = lead_coeff u \\<and>\n       degree f < degree u \\<and> degree g < degree u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f g.\n       Polynomial.smult (lead_coeff u) u = f * g \\<and>\n       lead_coeff f = lead_coeff u \\<and>\n       lead_coeff g = lead_coeff u \\<and>\n       degree f < degree u \\<and> degree g < degree u", "from assms[unfolded irreducible\\<^sub>d_def, simplified]"], ["proof (chain)\npicking this:\n  degree u = 0 \\<or>\n  (\\<exists>q.\n      degree q < degree u \\<and>\n      (\\<exists>r. degree r < degree u \\<and> u = q * r))\n  0 < degree u", "obtain v w where deg: \"degree v < degree u\" \"degree w < degree u\" and u: \"u = v * w\""], ["proof (prove)\nusing this:\n  degree u = 0 \\<or>\n  (\\<exists>q.\n      degree q < degree u \\<and>\n      (\\<exists>r. degree r < degree u \\<and> u = q * r))\n  0 < degree u\n\ngoal (1 subgoal):\n 1. (\\<And>v w.\n        \\<lbrakk>degree v < degree u; degree w < degree u;\n         u = v * w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  degree v < degree u\n  degree w < degree u\n  u = v * w\n\ngoal (1 subgoal):\n 1. \\<exists>f g.\n       Polynomial.smult (lead_coeff u) u = f * g \\<and>\n       lead_coeff f = lead_coeff u \\<and>\n       lead_coeff g = lead_coeff u \\<and>\n       degree f < degree u \\<and> degree g < degree u", "define f where \"f = smult (lead_coeff w) v\""], ["proof (state)\nthis:\n  f = Polynomial.smult (lead_coeff w) v\n\ngoal (1 subgoal):\n 1. \\<exists>f g.\n       Polynomial.smult (lead_coeff u) u = f * g \\<and>\n       lead_coeff f = lead_coeff u \\<and>\n       lead_coeff g = lead_coeff u \\<and>\n       degree f < degree u \\<and> degree g < degree u", "define g where \"g = smult (lead_coeff v) w\""], ["proof (state)\nthis:\n  g = Polynomial.smult (lead_coeff v) w\n\ngoal (1 subgoal):\n 1. \\<exists>f g.\n       Polynomial.smult (lead_coeff u) u = f * g \\<and>\n       lead_coeff f = lead_coeff u \\<and>\n       lead_coeff g = lead_coeff u \\<and>\n       degree f < degree u \\<and> degree g < degree u", "note lf = lead_coeff_factor[OF u, folded f_def g_def]"], ["proof (state)\nthis:\n  Polynomial.smult (lead_coeff u) u = f * g\n  lead_coeff f = lead_coeff u\n  lead_coeff g = lead_coeff u\n\ngoal (1 subgoal):\n 1. \\<exists>f g.\n       Polynomial.smult (lead_coeff u) u = f * g \\<and>\n       lead_coeff f = lead_coeff u \\<and>\n       lead_coeff g = lead_coeff u \\<and>\n       degree f < degree u \\<and> degree g < degree u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f g.\n       Polynomial.smult (lead_coeff u) u = f * g \\<and>\n       lead_coeff f = lead_coeff u \\<and>\n       lead_coeff g = lead_coeff u \\<and>\n       degree f < degree u \\<and> degree g < degree u", "proof (intro exI conjI, (rule lf)+)"], ["proof (state)\ngoal (2 subgoals):\n 1. degree f < degree u\n 2. degree g < degree u", "show \"degree f < degree u\" \"degree g < degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f < degree u &&& degree g < degree u", "unfolding f_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Polynomial.smult (lead_coeff w) v) < degree u &&&\n    degree (Polynomial.smult (lead_coeff v) w) < degree u", "using deg u"], ["proof (prove)\nusing this:\n  degree v < degree u\n  degree w < degree u\n  u = v * w\n\ngoal (1 subgoal):\n 1. degree (Polynomial.smult (lead_coeff w) v) < degree u &&&\n    degree (Polynomial.smult (lead_coeff v) w) < degree u", "by auto"], ["proof (state)\nthis:\n  degree f < degree u\n  degree g < degree u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f g.\n     Polynomial.smult (lead_coeff u) u = f * g \\<and>\n     lead_coeff f = lead_coeff u \\<and>\n     lead_coeff g = lead_coeff u \\<and>\n     degree f < degree u \\<and> degree g < degree u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_subseqs_size: \"mset ` {ys. ys \\<in> set (subseqs xs) \\<and> length ys = n} = \n  {ws. ws \\<subseteq># mset xs \\<and> size ws = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ` {ys \\<in> set (subseqs xs). length ys = n} =\n    {ws. ws \\<subseteq># mset xs \\<and> size ws = n}", "proof (induct xs arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       mset ` {ys \\<in> set (subseqs []). length ys = n} =\n       {ws. ws \\<subseteq># mset [] \\<and> size ws = n}\n 2. \\<And>a xs n.\n       (\\<And>n.\n           mset ` {ys \\<in> set (subseqs xs). length ys = n} =\n           {ws.\n            ws \\<subseteq># mset xs \\<and> size ws = n}) \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (a # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (a # xs) \\<and> size ws = n}", "case (Cons x xs n)"], ["proof (state)\nthis:\n  mset ` {ys \\<in> set (subseqs xs). length ys = ?n} =\n  {ws. ws \\<subseteq># mset xs \\<and> size ws = ?n}\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       mset ` {ys \\<in> set (subseqs []). length ys = n} =\n       {ws. ws \\<subseteq># mset [] \\<and> size ws = n}\n 2. \\<And>a xs n.\n       (\\<And>n.\n           mset ` {ys \\<in> set (subseqs xs). length ys = n} =\n           {ws.\n            ws \\<subseteq># mset xs \\<and> size ws = n}) \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (a # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (a # xs) \\<and> size ws = n}", "show ?case (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n    {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n    {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n    {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n    {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n  {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "have \"?r = {ws. ws \\<subseteq># mset (x # xs)} \\<inter> {ps. size ps = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n} =\n    {ws. ws \\<subseteq># mset (x # xs)} \\<inter> {ps. size ps = n}", "by auto"], ["proof (state)\nthis:\n  {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n} =\n  {ws. ws \\<subseteq># mset (x # xs)} \\<inter> {ps. size ps = n}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "also"], ["proof (state)\nthis:\n  {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n} =\n  {ws. ws \\<subseteq># mset (x # xs)} \\<inter> {ps. size ps = n}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "have \"{ws. ws \\<subseteq># mset (x # xs)} = {ps. ps \\<subseteq># mset xs} \\<union> ((\\<lambda> ps. ps + {#x#}) ` {ps. ps \\<subseteq># mset xs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ws. ws \\<subseteq># mset (x # xs)} =\n    {ps. ps \\<subseteq># mset xs} \\<union>\n    (\\<lambda>ps. ps + {#x#}) ` {ps. ps \\<subseteq># mset xs}", "by (simp add: multiset_subset_insert)"], ["proof (state)\nthis:\n  {ws. ws \\<subseteq># mset (x # xs)} =\n  {ps. ps \\<subseteq># mset xs} \\<union>\n  (\\<lambda>ps. ps + {#x#}) ` {ps. ps \\<subseteq># mset xs}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "also"], ["proof (state)\nthis:\n  {ws. ws \\<subseteq># mset (x # xs)} =\n  {ps. ps \\<subseteq># mset xs} \\<union>\n  (\\<lambda>ps. ps + {#x#}) ` {ps. ps \\<subseteq># mset xs}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "have \"\\<dots> \\<inter> {ps. size ps = n} = {ps. ps \\<subseteq># mset xs \\<and> size ps = n} \n      \\<union> ((\\<lambda> ps. ps + {#x#}) ` {ps. ps \\<subseteq># mset xs \\<and> size ps = m})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({ps. ps \\<subseteq># mset xs} \\<union>\n     (\\<lambda>ps. ps + {#x#}) ` {ps. ps \\<subseteq># mset xs}) \\<inter>\n    {ps. size ps = n} =\n    {ps. ps \\<subseteq># mset xs \\<and> size ps = n} \\<union>\n    (\\<lambda>ps. ps + {#x#}) `\n    {ps. ps \\<subseteq># mset xs \\<and> size ps = m}", "unfolding Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({ps. ps \\<subseteq># mset xs} \\<union>\n     (\\<lambda>ps. ps + {#x#}) ` {ps. ps \\<subseteq># mset xs}) \\<inter>\n    {ps. size ps = Suc m} =\n    {ps. ps \\<subseteq># mset xs \\<and> size ps = Suc m} \\<union>\n    (\\<lambda>ps. ps + {#x#}) `\n    {ps. ps \\<subseteq># mset xs \\<and> size ps = m}", "by auto"], ["proof (state)\nthis:\n  ({ps. ps \\<subseteq># mset xs} \\<union>\n   (\\<lambda>ps. ps + {#x#}) ` {ps. ps \\<subseteq># mset xs}) \\<inter>\n  {ps. size ps = n} =\n  {ps. ps \\<subseteq># mset xs \\<and> size ps = n} \\<union>\n  (\\<lambda>ps. ps + {#x#}) `\n  {ps. ps \\<subseteq># mset xs \\<and> size ps = m}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "finally"], ["proof (chain)\npicking this:\n  {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n} =\n  {ps. ps \\<subseteq># mset xs \\<and> size ps = n} \\<union>\n  (\\<lambda>ps. ps + {#x#}) `\n  {ps. ps \\<subseteq># mset xs \\<and> size ps = m}", "have id: \"?r =\n      {ps. ps \\<subseteq># mset xs \\<and> size ps = n} \\<union> (\\<lambda>ps. ps + {#x#}) ` {ps. ps \\<subseteq># mset xs \\<and> size ps = m}\""], ["proof (prove)\nusing this:\n  {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n} =\n  {ps. ps \\<subseteq># mset xs \\<and> size ps = n} \\<union>\n  (\\<lambda>ps. ps + {#x#}) `\n  {ps. ps \\<subseteq># mset xs \\<and> size ps = m}\n\ngoal (1 subgoal):\n 1. {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n} =\n    {ps. ps \\<subseteq># mset xs \\<and> size ps = n} \\<union>\n    (\\<lambda>ps. ps + {#x#}) `\n    {ps. ps \\<subseteq># mset xs \\<and> size ps = m}", "."], ["proof (state)\nthis:\n  {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n} =\n  {ps. ps \\<subseteq># mset xs \\<and> size ps = n} \\<union>\n  (\\<lambda>ps. ps + {#x#}) `\n  {ps. ps \\<subseteq># mset xs \\<and> size ps = m}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "have \"?l = mset ` {ys \\<in> set (subseqs xs). length ys = Suc m}\n      \\<union> mset ` {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n    mset ` {ys \\<in> set (subseqs xs). length ys = Suc m} \\<union>\n    mset ` {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc m}", "unfolding Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ` {ys \\<in> set (subseqs (x # xs)). length ys = Suc m} =\n    mset ` {ys \\<in> set (subseqs xs). length ys = Suc m} \\<union>\n    mset ` {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc m}", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n  mset ` {ys \\<in> set (subseqs xs). length ys = Suc m} \\<union>\n  mset ` {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc m}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "also"], ["proof (state)\nthis:\n  mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n  mset ` {ys \\<in> set (subseqs xs). length ys = Suc m} \\<union>\n  mset ` {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc m}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "have \"mset ` {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc m}\n      = (\\<lambda>ps. ps + {#x#}) ` mset ` {ys \\<in> set (subseqs xs). length ys = m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ` {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc m} =\n    (\\<lambda>ps. ps + {#x#}) `\n    mset ` {ys \\<in> set (subseqs xs). length ys = m}", "by force"], ["proof (state)\nthis:\n  mset ` {ys \\<in> (#) x ` set (subseqs xs). length ys = Suc m} =\n  (\\<lambda>ps. ps + {#x#}) `\n  mset ` {ys \\<in> set (subseqs xs). length ys = m}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "finally"], ["proof (chain)\npicking this:\n  mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n  mset ` {ys \\<in> set (subseqs xs). length ys = Suc m} \\<union>\n  (\\<lambda>ps. ps + {#x#}) `\n  mset ` {ys \\<in> set (subseqs xs). length ys = m}", "have id': \"?l = mset ` {ys \\<in> set (subseqs xs). length ys = Suc m} \\<union>\n      (\\<lambda>ps. ps + {#x#}) ` mset ` {ys \\<in> set (subseqs xs). length ys = m}\""], ["proof (prove)\nusing this:\n  mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n  mset ` {ys \\<in> set (subseqs xs). length ys = Suc m} \\<union>\n  (\\<lambda>ps. ps + {#x#}) `\n  mset ` {ys \\<in> set (subseqs xs). length ys = m}\n\ngoal (1 subgoal):\n 1. mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n    mset ` {ys \\<in> set (subseqs xs). length ys = Suc m} \\<union>\n    (\\<lambda>ps. ps + {#x#}) `\n    mset ` {ys \\<in> set (subseqs xs). length ys = m}", "."], ["proof (state)\nthis:\n  mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n  mset ` {ys \\<in> set (subseqs xs). length ys = Suc m} \\<union>\n  (\\<lambda>ps. ps + {#x#}) `\n  mset ` {ys \\<in> set (subseqs xs). length ys = m}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n       {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n    {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}", "unfolding id id' Cons[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ` {ys \\<in> set (subseqs xs). length ys = Suc m} \\<union>\n    (\\<lambda>ps. ps + {#x#}) `\n    mset ` {ys \\<in> set (subseqs xs). length ys = m} =\n    mset ` {ys \\<in> set (subseqs xs). length ys = n} \\<union>\n    (\\<lambda>ps. ps + {#x#}) `\n    mset ` {ys \\<in> set (subseqs xs). length ys = m}", "unfolding Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ` {ys \\<in> set (subseqs xs). length ys = Suc m} \\<union>\n    (\\<lambda>ps. ps + {#x#}) `\n    mset ` {ys \\<in> set (subseqs xs). length ys = m} =\n    mset ` {ys \\<in> set (subseqs xs). length ys = Suc m} \\<union>\n    (\\<lambda>ps. ps + {#x#}) `\n    mset ` {ys \\<in> set (subseqs xs). length ys = m}", "by simp"], ["proof (state)\nthis:\n  mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n  {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset ` {ys \\<in> set (subseqs (x # xs)). length ys = n} =\n  {ws. ws \\<subseteq># mset (x # xs) \\<and> size ws = n}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       mset ` {ys \\<in> set (subseqs []). length ys = n} =\n       {ws. ws \\<subseteq># mset [] \\<and> size ws = n}", "qed auto"], ["", "context poly_mod_2\nbegin"], ["", "lemma prod_list_m[simp]: \"prod_list_m fs = Mp (prod_list fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list_m fs = Mp (prod_list fs)", "by (induct fs, auto)"], ["", "lemma inv_Mp_coeff: \"coeff (inv_Mp f) n = inv_M (coeff f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (inv_Mp f) n = inv_M (coeff f n)", "unfolding inv_Mp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (map_poly inv_M f) n = inv_M (coeff f n)", "by (rule coeff_map_poly, insert m1, auto simp: inv_M_def)"], ["", "lemma Mp_inv_Mp_id[simp]: \"Mp (inv_Mp f) = Mp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_Mp f =m f", "unfolding poly_eq_iff Mp_coeff inv_Mp_coeff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. M (inv_M (coeff f n)) = M (coeff f n)", "by simp"], ["", "lemma inv_Mp_rev: assumes bnd: \"\\<And> n. 2 * abs (coeff f n) < m\" \n  shows \"inv_Mp (Mp f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_Mp (Mp f) = f", "proof (rule poly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. coeff (inv_Mp (Mp f)) n = coeff f n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. coeff (inv_Mp (Mp f)) n = coeff f n", "define c where \"c = coeff f n\""], ["proof (state)\nthis:\n  c = coeff f n\n\ngoal (1 subgoal):\n 1. \\<And>n. coeff (inv_Mp (Mp f)) n = coeff f n", "from bnd[of n, folded c_def]"], ["proof (chain)\npicking this:\n  2 * \\<bar>c\\<bar> < m", "have bnd: \"2 * abs c < m\""], ["proof (prove)\nusing this:\n  2 * \\<bar>c\\<bar> < m\n\ngoal (1 subgoal):\n 1. 2 * \\<bar>c\\<bar> < m", "by auto"], ["proof (state)\nthis:\n  2 * \\<bar>c\\<bar> < m\n\ngoal (1 subgoal):\n 1. \\<And>n. coeff (inv_Mp (Mp f)) n = coeff f n", "show \"coeff (inv_Mp (Mp f)) n = coeff f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (inv_Mp (Mp f)) n = coeff f n", "unfolding inv_Mp_coeff Mp_coeff c_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_M (M c) = c", "using inv_M_rev[OF bnd]"], ["proof (prove)\nusing this:\n  inv_M (M c) = c\n\ngoal (1 subgoal):\n 1. inv_M (M c) = c", "."], ["proof (state)\nthis:\n  coeff (inv_Mp (Mp f)) n = coeff f n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mul_const_commute_below: \"mul_const x (mul_const y z) = mul_const y (mul_const x z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mul_const x (mul_const y z) = mul_const y (mul_const x z)", "unfolding mul_const_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff x 0 * (coeff y 0 * z mod m) mod m =\n    coeff y 0 * (coeff x 0 * z mod m) mod m", "by (metis mod_mult_right_eq mult.left_commute)"], ["", "context\n  fixes p n \n    and sl_impl :: \"(int poly, int \\<times> int poly list, 'state)subseqs_foldr_impl\" \n    and sli :: \"int \\<times> int poly list \\<Rightarrow> int poly list \\<Rightarrow> nat \\<Rightarrow> 'state \\<Rightarrow> bool\" \n  assumes prime: \"prime p\" \n  and m: \"m = p^n\" \n  and n: \"n \\<noteq> 0\" \n  and sl_impl: \"correct_subseqs_foldr_impl (\\<lambda>x. map_prod (mul_const x) (Cons x)) sl_impl sli\"\nbegin"], ["", "private"], ["", "definition \"test_dvd_exec lu u ws = (\\<not> inv_Mp (Mp (smult lu (prod_mset ws))) dvd smult lu u)\""], ["", "private"], ["", "definition \"test_dvd u ws = (\\<forall> v l. v dvd u \\<longrightarrow> 0 < degree v \\<longrightarrow> degree v < degree u\n  \\<longrightarrow> \\<not> v =m smult l (prod_mset ws))\""], ["", "private"], ["", "definition \"large_m u vs = (\\<forall> v n. v dvd u \\<longrightarrow> degree v \\<le> degree_bound vs \\<longrightarrow> 2 * abs (coeff v n) < m)\""], ["", "lemma large_m_factor: \"large_m u vs \\<Longrightarrow> v dvd u \\<Longrightarrow> large_m v vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>large_m u vs; v dvd u\\<rbrakk> \\<Longrightarrow> large_m v vs", "unfolding large_m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v n.\n                v dvd u \\<longrightarrow>\n                degree v \\<le> degree_bound vs \\<longrightarrow>\n                2 * \\<bar>coeff v n\\<bar> < m;\n     v dvd u\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va n.\n                         va dvd v \\<longrightarrow>\n                         degree va \\<le> degree_bound vs \\<longrightarrow>\n                         2 * \\<bar>coeff va n\\<bar> < m", "using dvd_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a dvd ?b; ?b dvd ?c\\<rbrakk> \\<Longrightarrow> ?a dvd ?c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v n.\n                v dvd u \\<longrightarrow>\n                degree v \\<le> degree_bound vs \\<longrightarrow>\n                2 * \\<bar>coeff v n\\<bar> < m;\n     v dvd u\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va n.\n                         va dvd v \\<longrightarrow>\n                         degree va \\<le> degree_bound vs \\<longrightarrow>\n                         2 * \\<bar>coeff va n\\<bar> < m", "by auto"], ["", "lemma test_dvd_factor: assumes u: \"u \\<noteq> 0\" and test: \"test_dvd u ws\" and vu: \"v dvd u\" \n  shows \"test_dvd v ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test_dvd v ws", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. test_dvd v ws", "from vu"], ["proof (chain)\npicking this:\n  v dvd u", "obtain w where uv: \"u = v * w\""], ["proof (prove)\nusing this:\n  v dvd u\n\ngoal (1 subgoal):\n 1. (\\<And>w. u = v * w \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. u = v * k\n\ngoal (1 subgoal):\n 1. (\\<And>w. u = v * w \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  u = v * w\n\ngoal (1 subgoal):\n 1. test_dvd v ws", "from u"], ["proof (chain)\npicking this:\n  u \\<noteq> 0", "have deg: \"degree u = degree v + degree w\""], ["proof (prove)\nusing this:\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree u = degree v + degree w", "unfolding uv"], ["proof (prove)\nusing this:\n  v * w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (v * w) = degree v + degree w", "by (subst degree_mult_eq, auto)"], ["proof (state)\nthis:\n  degree u = degree v + degree w\n\ngoal (1 subgoal):\n 1. test_dvd v ws", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. test_dvd v ws", "unfolding test_dvd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>va l.\n       va dvd v \\<longrightarrow>\n       0 < degree va \\<longrightarrow>\n       degree va < degree v \\<longrightarrow>\n       Mp va \\<noteq> Mp (Polynomial.smult l (\\<Prod>\\<^sub># ws))", "proof (intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va l.\n       \\<lbrakk>va dvd v; 0 < degree va; degree va < degree v\\<rbrakk>\n       \\<Longrightarrow> Mp va \\<noteq>\n                         Mp (Polynomial.smult l (\\<Prod>\\<^sub># ws))", "case (1 f l)"], ["proof (state)\nthis:\n  f dvd v\n  0 < degree f\n  degree f < degree v\n\ngoal (1 subgoal):\n 1. \\<And>va l.\n       \\<lbrakk>va dvd v; 0 < degree va; degree va < degree v\\<rbrakk>\n       \\<Longrightarrow> Mp va \\<noteq>\n                         Mp (Polynomial.smult l (\\<Prod>\\<^sub># ws))", "from 1(1)"], ["proof (chain)\npicking this:\n  f dvd v", "have fu: \"f dvd u\""], ["proof (prove)\nusing this:\n  f dvd v\n\ngoal (1 subgoal):\n 1. f dvd u", "unfolding uv"], ["proof (prove)\nusing this:\n  f dvd v\n\ngoal (1 subgoal):\n 1. f dvd v * w", "by auto"], ["proof (state)\nthis:\n  f dvd u\n\ngoal (1 subgoal):\n 1. \\<And>va l.\n       \\<lbrakk>va dvd v; 0 < degree va; degree va < degree v\\<rbrakk>\n       \\<Longrightarrow> Mp va \\<noteq>\n                         Mp (Polynomial.smult l (\\<Prod>\\<^sub># ws))", "from 1(3)"], ["proof (chain)\npicking this:\n  degree f < degree v", "have deg: \"degree f < degree u\""], ["proof (prove)\nusing this:\n  degree f < degree v\n\ngoal (1 subgoal):\n 1. degree f < degree u", "unfolding deg"], ["proof (prove)\nusing this:\n  degree f < degree v\n\ngoal (1 subgoal):\n 1. degree f < degree v + degree w", "by auto"], ["proof (state)\nthis:\n  degree f < degree u\n\ngoal (1 subgoal):\n 1. \\<And>va l.\n       \\<lbrakk>va dvd v; 0 < degree va; degree va < degree v\\<rbrakk>\n       \\<Longrightarrow> Mp va \\<noteq>\n                         Mp (Polynomial.smult l (\\<Prod>\\<^sub># ws))", "from test[unfolded test_dvd_def, rule_format, OF fu 1(2) deg]"], ["proof (chain)\npicking this:\n  Mp f \\<noteq> Mp (Polynomial.smult ?l (\\<Prod>\\<^sub># ws))", "show ?case"], ["proof (prove)\nusing this:\n  Mp f \\<noteq> Mp (Polynomial.smult ?l (\\<Prod>\\<^sub># ws))\n\ngoal (1 subgoal):\n 1. Mp f \\<noteq> Mp (Polynomial.smult l (\\<Prod>\\<^sub># ws))", "."], ["proof (state)\nthis:\n  Mp f \\<noteq> Mp (Polynomial.smult l (\\<Prod>\\<^sub># ws))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  test_dvd v ws\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coprime_exp_mod: \"coprime lu p \\<Longrightarrow> prime p \\<Longrightarrow> n \\<noteq> 0 \\<Longrightarrow> lu mod p ^ n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>comm_monoid_mult_class.coprime lu p; prime p;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> lu mod p ^ n \\<noteq> 0", "by (auto simp add: abs_of_pos prime_gt_0_int)"], ["", "interpretation correct_subseqs_foldr_impl \"\\<lambda>x. map_prod (mul_const x) (Cons x)\" sl_impl sli"], ["proof (prove)\ngoal (1 subgoal):\n 1. correct_subseqs_foldr_impl (\\<lambda>x. map_prod (mul_const x) ((#) x))\n     sl_impl sli", "by fact"], ["", "lemma reconstruction: assumes\n    res: \"reconstruction sl_impl m2 state u (smult lu u) lu d r vs res cands = fs\"\n  and f: \"f = u * prod_list res\"\n  and meas: \"meas = (r - d, cands)\" \n  and dr: \"d + d \\<le> r\" \n  and r: \"r = length vs\" \n  and cands: \"set cands \\<subseteq> S (lu,[]) vs d\"\n  and d0: \"d = 0 \\<Longrightarrow> cands = []\" \n  and lu: \"lu = lead_coeff u\" \n  and factors: \"unique_factorization_m u (lu,mset vs)\" \n  and sf: \"poly_mod.square_free_m p u\" \n  and cop: \"coprime lu p\"\n  and norm: \"\\<And> v.  v \\<in> set vs \\<Longrightarrow> Mp v = v\" \n  and tests: \"\\<And> ws. ws \\<subseteq># mset vs \\<Longrightarrow> ws \\<noteq> {#} \\<Longrightarrow> \n    size ws < d \\<or> size ws = d \\<and> ws \\<notin> (mset o snd) ` set cands \n    \\<Longrightarrow> test_dvd u ws\"\n  and irr: \"\\<And> f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f\" \n  and deg: \"degree u > 0\" \n  and cands_ne: \"cands \\<noteq> [] \\<Longrightarrow> d < r\" \n  and large: \"\\<forall> v n. v dvd smult lu u \\<longrightarrow> degree v \\<le> degree_bound vs \n    \\<longrightarrow> 2 * abs (coeff v n) < m\" \n  and f0: \"f \\<noteq> 0\"\n  and state: \"sli (lu,[]) vs d state\" \n  and m2: \"m2 = m div 2\" \n  shows \"f = prod_list fs \\<and> (\\<forall> fi \\<in> set fs. irreducible\\<^sub>d fi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "from large"], ["proof (chain)\npicking this:\n  \\<forall>v n.\n     v dvd Polynomial.smult lu u \\<longrightarrow>\n     degree v \\<le> degree_bound vs \\<longrightarrow>\n     2 * \\<bar>coeff v n\\<bar> < m", "have large: \"large_m (smult lu u) vs\""], ["proof (prove)\nusing this:\n  \\<forall>v n.\n     v dvd Polynomial.smult lu u \\<longrightarrow>\n     degree v \\<le> degree_bound vs \\<longrightarrow>\n     2 * \\<bar>coeff v n\\<bar> < m\n\ngoal (1 subgoal):\n 1. large_m (Polynomial.smult lu u) vs", "unfolding large_m_def"], ["proof (prove)\nusing this:\n  \\<forall>v n.\n     v dvd Polynomial.smult lu u \\<longrightarrow>\n     degree v \\<le> degree_bound vs \\<longrightarrow>\n     2 * \\<bar>coeff v n\\<bar> < m\n\ngoal (1 subgoal):\n 1. \\<forall>v n.\n       v dvd Polynomial.smult lu u \\<longrightarrow>\n       degree v \\<le> degree_bound vs \\<longrightarrow>\n       2 * \\<bar>coeff v n\\<bar> < m", "by auto"], ["proof (state)\nthis:\n  large_m (Polynomial.smult lu u) vs\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "interpret p: poly_mod_prime p"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_prime p", "using prime"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. poly_mod_prime p", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "define R where \"R \\<equiv> measures [\n    \\<lambda> (n :: nat,cds :: (int \\<times> int poly list) list). n, \n    \\<lambda> (n,cds). length cds]\""], ["proof (state)\nthis:\n  R \\<equiv> measures [\\<lambda>(n, cds). n, \\<lambda>(n, y). length y]\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have wf: \"wf R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf R", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measures [\\<lambda>(n, cds). n, \\<lambda>(n, y). length y])", "by simp"], ["proof (state)\nthis:\n  wf R\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have mset_snd_S: \"\\<And> vs lu d. (mset \\<circ> snd) ` S (lu,[]) vs d = \n    { ws. ws \\<subseteq># mset vs \\<and> size ws = d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vs lu d.\n       (mset \\<circ> snd) ` S (lu, []) vs d =\n       {ws. ws \\<subseteq># mset vs \\<and> size ws = d}", "by (fold mset_subseqs_size image_comp, unfold S_def image_Collect, auto)"], ["proof (state)\nthis:\n  (mset \\<circ> snd) ` S (?lu2, []) ?vs2 ?d2 =\n  {ws. ws \\<subseteq># mset ?vs2 \\<and> size ws = ?d2}\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have inv_M2[simp]: \"inv_M2 m2 = inv_M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_M2 m2 = inv_M", "unfolding inv_M2_def m2 inv_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<le> m div 2 then x else x - m) =\n    (\\<lambda>x. if x + x \\<le> m then x else x - m)", "by (intro ext, auto)"], ["proof (state)\nthis:\n  inv_M2 m2 = inv_M\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have inv_Mp2[simp]: \"inv_Mp2 m2 = inv_Mp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_Mp2 m2 = inv_Mp", "unfolding inv_Mp2_def inv_Mp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly (inv_M2 m2) = map_poly inv_M", "by simp"], ["proof (state)\nthis:\n  inv_Mp2 m2 = inv_Mp\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have p_Mp[simp]: \"\\<And> f. p.Mp (Mp f) = p.Mp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. p.eq_m (Mp f) f", "using m p.m1 n Mp_Mp_pow_is_Mp"], ["proof (prove)\nusing this:\n  m = p ^ n\n  1 < p\n  n \\<noteq> 0\n  \\<lbrakk>?n \\<noteq> 0; 1 < ?p\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp ?p (poly_mod.Mp (?p ^ ?n) ?f) =\n                    poly_mod.Mp ?p ?f\n\ngoal (1 subgoal):\n 1. \\<And>f. p.eq_m (Mp f) f", "by blast"], ["proof (state)\nthis:\n  p.eq_m (Mp ?f2) ?f2\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "{"], ["proof (state)\nthis:\n  p.eq_m (Mp ?f2) ?f2\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "fix u lu vs"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "assume eq: \"Mp u = Mp (smult lu (prod_mset vs))\" and cop: \"coprime lu p\" and size: \"size vs \\<noteq> 0\"\n      and mi: \"\\<And> v. v \\<in># vs \\<Longrightarrow> irreducible\\<^sub>d_m v \\<and> monic v\""], ["proof (state)\nthis:\n  u =m Polynomial.smult lu (\\<Prod>\\<^sub># vs)\n  comm_monoid_mult_class.coprime lu p\n  size vs \\<noteq> 0\n  ?v2 \\<in># vs \\<Longrightarrow> irreducible\\<^sub>d_m ?v2 \\<and> monic ?v2\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "from cop p.m1"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime lu p\n  1 < p", "have lu0: \"lu \\<noteq> 0\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime lu p\n  1 < p\n\ngoal (1 subgoal):\n 1. lu \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lu \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "from size"], ["proof (chain)\npicking this:\n  size vs \\<noteq> 0", "have \"vs \\<noteq> {#}\""], ["proof (prove)\nusing this:\n  size vs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vs \\<noteq> {#}", "by auto"], ["proof (state)\nthis:\n  vs \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "then"], ["proof (chain)\npicking this:\n  vs \\<noteq> {#}", "obtain v vs' where vs_v: \"vs = vs' + {#v#}\""], ["proof (prove)\nusing this:\n  vs \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. (\\<And>vs' v.\n        vs = vs' + {#v#} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases vs, auto)"], ["proof (state)\nthis:\n  vs = vs' + {#v#}\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have mon: \"monic (prod_mset vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>\\<^sub># vs)", "by (rule monic_prod_mset, insert mi, auto)"], ["proof (state)\nthis:\n  monic (\\<Prod>\\<^sub># vs)\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "hence vs0: \"prod_mset vs \\<noteq> 0\""], ["proof (prove)\nusing this:\n  monic (\\<Prod>\\<^sub># vs)\n\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># vs \\<noteq> 0", "by (metis coeff_0 zero_neq_one)"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># vs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "from mon"], ["proof (chain)\npicking this:\n  monic (\\<Prod>\\<^sub># vs)", "have l_vs: \"lead_coeff (prod_mset vs) = 1\""], ["proof (prove)\nusing this:\n  monic (\\<Prod>\\<^sub># vs)\n\ngoal (1 subgoal):\n 1. monic (\\<Prod>\\<^sub># vs)", "."], ["proof (state)\nthis:\n  monic (\\<Prod>\\<^sub># vs)\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have deg_ws: \"degree_m (smult lu (prod_mset vs)) = degree (smult lu (prod_mset vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m (Polynomial.smult lu (\\<Prod>\\<^sub># vs)) =\n    degree (Polynomial.smult lu (\\<Prod>\\<^sub># vs))", "by (rule degree_m_eq[OF _ m1], unfold lead_coeff_smult,\n      insert cop n p.m1 l_vs, auto simp: m)"], ["proof (state)\nthis:\n  degree_m (Polynomial.smult lu (\\<Prod>\\<^sub># vs)) =\n  degree (Polynomial.smult lu (\\<Prod>\\<^sub># vs))\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "with eq"], ["proof (chain)\npicking this:\n  u =m Polynomial.smult lu (\\<Prod>\\<^sub># vs)\n  degree_m (Polynomial.smult lu (\\<Prod>\\<^sub># vs)) =\n  degree (Polynomial.smult lu (\\<Prod>\\<^sub># vs))", "have \"degree_m u = degree (smult lu (prod_mset vs))\""], ["proof (prove)\nusing this:\n  u =m Polynomial.smult lu (\\<Prod>\\<^sub># vs)\n  degree_m (Polynomial.smult lu (\\<Prod>\\<^sub># vs)) =\n  degree (Polynomial.smult lu (\\<Prod>\\<^sub># vs))\n\ngoal (1 subgoal):\n 1. degree_m u = degree (Polynomial.smult lu (\\<Prod>\\<^sub># vs))", "by auto"], ["proof (state)\nthis:\n  degree_m u = degree (Polynomial.smult lu (\\<Prod>\\<^sub># vs))\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "also"], ["proof (state)\nthis:\n  degree_m u = degree (Polynomial.smult lu (\\<Prod>\\<^sub># vs))\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have \"\\<dots> = degree (prod_mset vs' * v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Polynomial.smult lu (\\<Prod>\\<^sub># vs)) =\n    degree (\\<Prod>\\<^sub># vs' * v)", "unfolding degree_smult_eq vs_v"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if lu = 0 then 0 else degree (\\<Prod>\\<^sub># (vs' + {#v#}))) =\n    degree (\\<Prod>\\<^sub># vs' * v)", "using lu0"], ["proof (prove)\nusing this:\n  lu \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if lu = 0 then 0 else degree (\\<Prod>\\<^sub># (vs' + {#v#}))) =\n    degree (\\<Prod>\\<^sub># vs' * v)", "by (simp add:ac_simps)"], ["proof (state)\nthis:\n  degree (Polynomial.smult lu (\\<Prod>\\<^sub># vs)) =\n  degree (\\<Prod>\\<^sub># vs' * v)\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "also"], ["proof (state)\nthis:\n  degree (Polynomial.smult lu (\\<Prod>\\<^sub># vs)) =\n  degree (\\<Prod>\\<^sub># vs' * v)\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have \"\\<dots> = degree (prod_mset vs') + degree v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>\\<^sub># vs' * v) =\n    degree (\\<Prod>\\<^sub># vs') + degree v", "by (rule degree_mult_eq, insert vs0[unfolded vs_v], auto)"], ["proof (state)\nthis:\n  degree (\\<Prod>\\<^sub># vs' * v) = degree (\\<Prod>\\<^sub># vs') + degree v\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "also"], ["proof (state)\nthis:\n  degree (\\<Prod>\\<^sub># vs' * v) = degree (\\<Prod>\\<^sub># vs') + degree v\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have \"\\<dots> \\<ge> degree v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree v \\<le> degree (\\<Prod>\\<^sub># vs') + degree v", "by simp"], ["proof (state)\nthis:\n  degree v \\<le> degree (\\<Prod>\\<^sub># vs') + degree v\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "finally"], ["proof (chain)\npicking this:\n  degree v \\<le> degree_m u", "have deg_v: \"degree v \\<le> degree_m u\""], ["proof (prove)\nusing this:\n  degree v \\<le> degree_m u\n\ngoal (1 subgoal):\n 1. degree v \\<le> degree_m u", "."], ["proof (state)\nthis:\n  degree v \\<le> degree_m u\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "from mi[unfolded vs_v, of v]"], ["proof (chain)\npicking this:\n  v \\<in># vs' + {#v#} \\<Longrightarrow>\n  irreducible\\<^sub>d_m v \\<and> monic v", "have \"irreducible\\<^sub>d_m v\""], ["proof (prove)\nusing this:\n  v \\<in># vs' + {#v#} \\<Longrightarrow>\n  irreducible\\<^sub>d_m v \\<and> monic v\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d_m v", "by auto"], ["proof (state)\nthis:\n  irreducible\\<^sub>d_m v\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "hence \"0 < degree_m v\""], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d_m v\n\ngoal (1 subgoal):\n 1. 0 < degree_m v", "unfolding irreducible\\<^sub>d_m_def"], ["proof (prove)\nusing this:\n  0 < degree_m v \\<and>\n  (\\<forall>g h.\n      degree_m g < degree_m v \\<longrightarrow>\n      degree_m h < degree_m v \\<longrightarrow> Mp v \\<noteq> Mp (g * h))\n\ngoal (1 subgoal):\n 1. 0 < degree_m v", "by auto"], ["proof (state)\nthis:\n  0 < degree_m v\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "also"], ["proof (state)\nthis:\n  0 < degree_m v\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have \"\\<dots> \\<le> degree v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m v \\<le> degree v", "by (rule degree_m_le)"], ["proof (state)\nthis:\n  degree_m v \\<le> degree v\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "also"], ["proof (state)\nthis:\n  degree_m v \\<le> degree v\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have \"\\<dots> \\<le> degree_m u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree v \\<le> degree_m u", "by (rule deg_v)"], ["proof (state)\nthis:\n  degree v \\<le> degree_m u\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "also"], ["proof (state)\nthis:\n  degree v \\<le> degree_m u\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have \"\\<dots> \\<le> degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m u \\<le> degree u", "by (rule degree_m_le)"], ["proof (state)\nthis:\n  degree_m u \\<le> degree u\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "finally"], ["proof (chain)\npicking this:\n  0 < degree u", "have \"degree u > 0\""], ["proof (prove)\nusing this:\n  0 < degree u\n\ngoal (1 subgoal):\n 1. 0 < degree u", "by auto"], ["proof (state)\nthis:\n  0 < degree u\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ua4 =m Polynomial.smult ?lua4 (\\<Prod>\\<^sub># ?vsa4);\n   comm_monoid_mult_class.coprime ?lua4 p; size ?vsa4 \\<noteq> 0;\n   \\<And>v.\n      v \\<in># ?vsa4 \\<Longrightarrow>\n      irreducible\\<^sub>d_m v \\<and> monic v\\<rbrakk>\n  \\<Longrightarrow> 0 < degree ?ua4\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "note deg_non_zero = this"], ["proof (state)\nthis:\n  \\<lbrakk>?ua4 =m Polynomial.smult ?lua4 (\\<Prod>\\<^sub># ?vsa4);\n   comm_monoid_mult_class.coprime ?lua4 p; size ?vsa4 \\<noteq> 0;\n   \\<And>v.\n      v \\<in># ?vsa4 \\<Longrightarrow>\n      irreducible\\<^sub>d_m v \\<and> monic v\\<rbrakk>\n  \\<Longrightarrow> 0 < degree ?ua4\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?ua4 =m Polynomial.smult ?lua4 (\\<Prod>\\<^sub># ?vsa4);\n   comm_monoid_mult_class.coprime ?lua4 p; size ?vsa4 \\<noteq> 0;\n   \\<And>v.\n      v \\<in># ?vsa4 \\<Longrightarrow>\n      irreducible\\<^sub>d_m v \\<and> monic v\\<rbrakk>\n  \\<Longrightarrow> 0 < degree ?ua4\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "fix u :: \"int poly\" and vs :: \"int poly list\" and d :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "assume deg_u: \"degree u > 0\"\n    and cop: \"coprime (lead_coeff u) p\"\n    and uf: \"unique_factorization_m u (lead_coeff u, mset vs)\" \n    and sf: \"p.square_free_m u\"\n    and norm: \"\\<And> v. v \\<in> set vs \\<Longrightarrow> Mp v = v\"\n    and d: \"size (mset vs) < d + d\"\n    and tests: \"\\<And> ws. ws \\<subseteq># mset vs \\<Longrightarrow> ws \\<noteq> {#} \\<Longrightarrow> size ws < d \\<Longrightarrow> test_dvd u ws\""], ["proof (state)\nthis:\n  0 < degree u\n  comm_monoid_mult_class.coprime (lead_coeff u) p\n  unique_factorization_m u (lead_coeff u, mset vs)\n  p.square_free_m u\n  ?v2 \\<in> set vs \\<Longrightarrow> Mp ?v2 = ?v2\n  size (mset vs) < d + d\n  \\<lbrakk>?ws2 \\<subseteq># mset vs; ?ws2 \\<noteq> {#};\n   size ?ws2 < d\\<rbrakk>\n  \\<Longrightarrow> test_dvd u ?ws2\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "from deg_u"], ["proof (chain)\npicking this:\n  0 < degree u", "have u0: \"u \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree u\n\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have \"irreducible\\<^sub>d u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d u", "proof (rule irreducible\\<^sub>dI[OF deg_u])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "fix q q' :: \"int poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "assume deg: \"degree q > 0\" \"degree q < degree u\" \"degree q' > 0\" \"degree q' < degree u\"\n         and uq: \"u = q * q'\""], ["proof (state)\nthis:\n  0 < degree q\n  degree q < degree u\n  0 < degree q'\n  degree q' < degree u\n  u = q * q'\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < degree q\n  degree q < degree u\n  0 < degree q'\n  degree q' < degree u\n  u = q * q'", "have qu: \"q dvd u\" and q'u: \"q' dvd u\""], ["proof (prove)\nusing this:\n  0 < degree q\n  degree q < degree u\n  0 < degree q'\n  degree q' < degree u\n  u = q * q'\n\ngoal (1 subgoal):\n 1. q dvd u &&& q' dvd u", "by auto"], ["proof (state)\nthis:\n  q dvd u\n  q' dvd u\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from u0"], ["proof (chain)\npicking this:\n  u \\<noteq> 0", "have deg_u: \"degree u = degree q + degree q'\""], ["proof (prove)\nusing this:\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree u = degree q + degree q'", "unfolding uq"], ["proof (prove)\nusing this:\n  q * q' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (q * q') = degree q + degree q'", "by (subst degree_mult_eq, auto)"], ["proof (state)\nthis:\n  degree u = degree q + degree q'\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from coprime_lead_coeff_factor[OF prime cop[unfolded uq]]"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime (lead_coeff q) p\n  comm_monoid_mult_class.coprime (lead_coeff q') p", "have cop_q: \"coprime (lead_coeff q) p\" \"coprime (lead_coeff q') p\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lead_coeff q) p\n  comm_monoid_mult_class.coprime (lead_coeff q') p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff q) p &&&\n    comm_monoid_mult_class.coprime (lead_coeff q') p", "by auto"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff q) p\n  comm_monoid_mult_class.coprime (lead_coeff q') p\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from unique_factorization_m_factor[OF prime uf[unfolded uq] _ _ n m, folded uq, \n        OF cop sf]"], ["proof (chain)\npicking this:\n  \\<exists>fs gs.\n     unique_factorization_m q (lead_coeff q, fs) \\<and>\n     unique_factorization_m q' (lead_coeff q', gs) \\<and>\n     Mf (lead_coeff u, mset vs) =\n     Mf (lead_coeff q * lead_coeff q', fs + gs) \\<and>\n     image_mset Mp fs = fs \\<and> image_mset Mp gs = gs", "obtain fs gs l where uf_q: \"unique_factorization_m q (lead_coeff q, fs)\"\n        and uf_q': \"unique_factorization_m q' (lead_coeff q', gs)\"\n        and Mf_eq: \"Mf (l, mset vs) = Mf (lead_coeff q * lead_coeff q', fs + gs)\" \n        and fs_id: \"image_mset Mp fs = fs\" \n        and gs_id: \"image_mset Mp gs = gs\""], ["proof (prove)\nusing this:\n  \\<exists>fs gs.\n     unique_factorization_m q (lead_coeff q, fs) \\<and>\n     unique_factorization_m q' (lead_coeff q', gs) \\<and>\n     Mf (lead_coeff u, mset vs) =\n     Mf (lead_coeff q * lead_coeff q', fs + gs) \\<and>\n     image_mset Mp fs = fs \\<and> image_mset Mp gs = gs\n\ngoal (1 subgoal):\n 1. (\\<And>fs gs l.\n        \\<lbrakk>unique_factorization_m q (lead_coeff q, fs);\n         unique_factorization_m q' (lead_coeff q', gs);\n         Mf (l, mset vs) = Mf (lead_coeff q * lead_coeff q', fs + gs);\n         image_mset Mp fs = fs; image_mset Mp gs = gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  unique_factorization_m q (lead_coeff q, fs)\n  unique_factorization_m q' (lead_coeff q', gs)\n  Mf (l, mset vs) = Mf (lead_coeff q * lead_coeff q', fs + gs)\n  image_mset Mp fs = fs\n  image_mset Mp gs = gs\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from Mf_eq fs_id gs_id"], ["proof (chain)\npicking this:\n  Mf (l, mset vs) = Mf (lead_coeff q * lead_coeff q', fs + gs)\n  image_mset Mp fs = fs\n  image_mset Mp gs = gs", "have \"image_mset Mp (mset vs) = fs + gs\""], ["proof (prove)\nusing this:\n  Mf (l, mset vs) = Mf (lead_coeff q * lead_coeff q', fs + gs)\n  image_mset Mp fs = fs\n  image_mset Mp gs = gs\n\ngoal (1 subgoal):\n 1. image_mset Mp (mset vs) = fs + gs", "unfolding Mf_def"], ["proof (prove)\nusing this:\n  (case (l, mset vs) of (c, fs) \\<Rightarrow> (M c, image_mset Mp fs)) =\n  (case (lead_coeff q * lead_coeff q', fs + gs) of\n   (c, fs) \\<Rightarrow> (M c, image_mset Mp fs))\n  image_mset Mp fs = fs\n  image_mset Mp gs = gs\n\ngoal (1 subgoal):\n 1. image_mset Mp (mset vs) = fs + gs", "by auto"], ["proof (state)\nthis:\n  image_mset Mp (mset vs) = fs + gs\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  image_mset Mp (mset vs) = fs + gs\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "have \"image_mset Mp (mset vs) = mset vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset Mp (mset vs) = mset vs", "using norm"], ["proof (prove)\nusing this:\n  ?v2 \\<in> set vs \\<Longrightarrow> Mp ?v2 = ?v2\n\ngoal (1 subgoal):\n 1. image_mset Mp (mset vs) = mset vs", "by (induct vs, auto)"], ["proof (state)\nthis:\n  image_mset Mp (mset vs) = mset vs\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  mset vs = fs + gs", "have eq: \"mset vs = fs + gs\""], ["proof (prove)\nusing this:\n  mset vs = fs + gs\n\ngoal (1 subgoal):\n 1. mset vs = fs + gs", "by simp"], ["proof (state)\nthis:\n  mset vs = fs + gs\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from uf_q[unfolded unique_factorization_m_alt_def factorization_m_def split]"], ["proof (chain)\npicking this:\n  (q =m Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs) \\<and>\n   (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<and>\n  (\\<forall>dgs.\n      (case dgs of\n       (c, fs) \\<Rightarrow>\n         q =m Polynomial.smult c (\\<Prod>\\<^sub># fs) \\<and>\n         (\\<forall>f\\<in>#fs.\n             irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<longrightarrow>\n      Mf dgs = Mf (lead_coeff q, fs))", "have q_eq: \"q =m smult (lead_coeff q) (prod_mset fs)\""], ["proof (prove)\nusing this:\n  (q =m Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs) \\<and>\n   (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<and>\n  (\\<forall>dgs.\n      (case dgs of\n       (c, fs) \\<Rightarrow>\n         q =m Polynomial.smult c (\\<Prod>\\<^sub># fs) \\<and>\n         (\\<forall>f\\<in>#fs.\n             irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<longrightarrow>\n      Mf dgs = Mf (lead_coeff q, fs))\n\ngoal (1 subgoal):\n 1. q =m Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs)", "by auto"], ["proof (state)\nthis:\n  q =m Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "have \"degree_m q = degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m q = degree q", "by (rule degree_m_eq[OF _ m1], insert cop_q(1) n p.m1, unfold m, \n          auto simp:)"], ["proof (state)\nthis:\n  degree_m q = degree q\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "with q_eq"], ["proof (chain)\npicking this:\n  q =m Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs)\n  degree_m q = degree q", "have degm_q: \"degree q = degree (Mp (smult (lead_coeff q) (prod_mset fs)))\""], ["proof (prove)\nusing this:\n  q =m Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs)\n  degree_m q = degree q\n\ngoal (1 subgoal):\n 1. degree q =\n    degree_m (Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs))", "by auto"], ["proof (state)\nthis:\n  degree q = degree_m (Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs))\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "with deg"], ["proof (chain)\npicking this:\n  0 < degree q\n  degree q < degree u\n  0 < degree q'\n  degree q' < degree u\n  degree q = degree_m (Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs))", "have fs_nempty: \"fs \\<noteq> {#}\""], ["proof (prove)\nusing this:\n  0 < degree q\n  degree q < degree u\n  0 < degree q'\n  degree q' < degree u\n  degree q = degree_m (Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs))\n\ngoal (1 subgoal):\n 1. fs \\<noteq> {#}", "by (cases fs; cases \"lead_coeff q = 0\"; auto simp: Mp_def)"], ["proof (state)\nthis:\n  fs \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from uf_q'[unfolded unique_factorization_m_alt_def factorization_m_def split]"], ["proof (chain)\npicking this:\n  (q' =m Polynomial.smult (lead_coeff q') (\\<Prod>\\<^sub># gs) \\<and>\n   (\\<forall>f\\<in>#gs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<and>\n  (\\<forall>dgs.\n      (case dgs of\n       (c, fs) \\<Rightarrow>\n         q' =m Polynomial.smult c (\\<Prod>\\<^sub># fs) \\<and>\n         (\\<forall>f\\<in>#fs.\n             irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<longrightarrow>\n      Mf dgs = Mf (lead_coeff q', gs))", "have q'_eq: \"q' =m smult (lead_coeff q') (prod_mset gs)\""], ["proof (prove)\nusing this:\n  (q' =m Polynomial.smult (lead_coeff q') (\\<Prod>\\<^sub># gs) \\<and>\n   (\\<forall>f\\<in>#gs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<and>\n  (\\<forall>dgs.\n      (case dgs of\n       (c, fs) \\<Rightarrow>\n         q' =m Polynomial.smult c (\\<Prod>\\<^sub># fs) \\<and>\n         (\\<forall>f\\<in>#fs.\n             irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<longrightarrow>\n      Mf dgs = Mf (lead_coeff q', gs))\n\ngoal (1 subgoal):\n 1. q' =m Polynomial.smult (lead_coeff q') (\\<Prod>\\<^sub># gs)", "by auto"], ["proof (state)\nthis:\n  q' =m Polynomial.smult (lead_coeff q') (\\<Prod>\\<^sub># gs)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "have \"degree_m q' = degree q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m q' = degree q'", "by (rule degree_m_eq[OF _ m1], insert cop_q(2) n p.m1, unfold m, \n          auto simp:)"], ["proof (state)\nthis:\n  degree_m q' = degree q'\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "with q'_eq"], ["proof (chain)\npicking this:\n  q' =m Polynomial.smult (lead_coeff q') (\\<Prod>\\<^sub># gs)\n  degree_m q' = degree q'", "have degm_q': \"degree q' = degree (Mp (smult (lead_coeff q') (prod_mset gs)))\""], ["proof (prove)\nusing this:\n  q' =m Polynomial.smult (lead_coeff q') (\\<Prod>\\<^sub># gs)\n  degree_m q' = degree q'\n\ngoal (1 subgoal):\n 1. degree q' =\n    degree_m (Polynomial.smult (lead_coeff q') (\\<Prod>\\<^sub># gs))", "by auto"], ["proof (state)\nthis:\n  degree q' =\n  degree_m (Polynomial.smult (lead_coeff q') (\\<Prod>\\<^sub># gs))\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "with deg"], ["proof (chain)\npicking this:\n  0 < degree q\n  degree q < degree u\n  0 < degree q'\n  degree q' < degree u\n  degree q' =\n  degree_m (Polynomial.smult (lead_coeff q') (\\<Prod>\\<^sub># gs))", "have gs_nempty: \"gs \\<noteq> {#}\""], ["proof (prove)\nusing this:\n  0 < degree q\n  degree q < degree u\n  0 < degree q'\n  degree q' < degree u\n  degree q' =\n  degree_m (Polynomial.smult (lead_coeff q') (\\<Prod>\\<^sub># gs))\n\ngoal (1 subgoal):\n 1. gs \\<noteq> {#}", "by (cases gs; cases \"lead_coeff q' = 0\"; auto simp: Mp_def)"], ["proof (state)\nthis:\n  gs \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from eq"], ["proof (chain)\npicking this:\n  mset vs = fs + gs", "have size: \"size fs + size gs = size (mset vs)\""], ["proof (prove)\nusing this:\n  mset vs = fs + gs\n\ngoal (1 subgoal):\n 1. size fs + size gs = size (mset vs)", "by auto"], ["proof (state)\nthis:\n  size fs + size gs = size (mset vs)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "with d"], ["proof (chain)\npicking this:\n  size (mset vs) < d + d\n  size fs + size gs = size (mset vs)", "have choice: \"size fs < d \\<or> size gs < d\""], ["proof (prove)\nusing this:\n  size (mset vs) < d + d\n  size fs + size gs = size (mset vs)\n\ngoal (1 subgoal):\n 1. size fs < d \\<or> size gs < d", "by auto"], ["proof (state)\nthis:\n  size fs < d \\<or> size gs < d\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree u; 0 < degree r;\n        degree r < degree u; u = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from choice"], ["proof (chain)\npicking this:\n  size fs < d \\<or> size gs < d", "show False"], ["proof (prove)\nusing this:\n  size fs < d \\<or> size gs < d\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. size fs < d \\<Longrightarrow> False\n 2. size gs < d \\<Longrightarrow> False", "assume fs: \"size fs < d\""], ["proof (state)\nthis:\n  size fs < d\n\ngoal (2 subgoals):\n 1. size fs < d \\<Longrightarrow> False\n 2. size gs < d \\<Longrightarrow> False", "from eq"], ["proof (chain)\npicking this:\n  mset vs = fs + gs", "have sub: \"fs \\<subseteq># mset vs\""], ["proof (prove)\nusing this:\n  mset vs = fs + gs\n\ngoal (1 subgoal):\n 1. fs \\<subseteq># mset vs", "using mset_subset_eq_add_left[of fs gs]"], ["proof (prove)\nusing this:\n  mset vs = fs + gs\n  fs \\<subseteq># fs + gs\n\ngoal (1 subgoal):\n 1. fs \\<subseteq># mset vs", "by auto"], ["proof (state)\nthis:\n  fs \\<subseteq># mset vs\n\ngoal (2 subgoals):\n 1. size fs < d \\<Longrightarrow> False\n 2. size gs < d \\<Longrightarrow> False", "have \"test_dvd u fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test_dvd u fs", "by (rule tests[OF sub fs_nempty, unfolded Nil], insert fs, auto)"], ["proof (state)\nthis:\n  test_dvd u fs\n\ngoal (2 subgoals):\n 1. size fs < d \\<Longrightarrow> False\n 2. size gs < d \\<Longrightarrow> False", "from this[unfolded test_dvd_def] uq deg q_eq"], ["proof (chain)\npicking this:\n  \\<forall>v l.\n     v dvd u \\<longrightarrow>\n     0 < degree v \\<longrightarrow>\n     degree v < degree u \\<longrightarrow>\n     Mp v \\<noteq> Mp (Polynomial.smult l (\\<Prod>\\<^sub># fs))\n  u = q * q'\n  0 < degree q\n  degree q < degree u\n  0 < degree q'\n  degree q' < degree u\n  q =m Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs)", "show False"], ["proof (prove)\nusing this:\n  \\<forall>v l.\n     v dvd u \\<longrightarrow>\n     0 < degree v \\<longrightarrow>\n     degree v < degree u \\<longrightarrow>\n     Mp v \\<noteq> Mp (Polynomial.smult l (\\<Prod>\\<^sub># fs))\n  u = q * q'\n  0 < degree q\n  degree q < degree u\n  0 < degree q'\n  degree q' < degree u\n  q =m Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. size gs < d \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. size gs < d \\<Longrightarrow> False", "assume gs: \"size gs < d\""], ["proof (state)\nthis:\n  size gs < d\n\ngoal (1 subgoal):\n 1. size gs < d \\<Longrightarrow> False", "from eq"], ["proof (chain)\npicking this:\n  mset vs = fs + gs", "have sub: \"gs \\<subseteq># mset vs\""], ["proof (prove)\nusing this:\n  mset vs = fs + gs\n\ngoal (1 subgoal):\n 1. gs \\<subseteq># mset vs", "using mset_subset_eq_add_left[of fs gs]"], ["proof (prove)\nusing this:\n  mset vs = fs + gs\n  fs \\<subseteq># fs + gs\n\ngoal (1 subgoal):\n 1. gs \\<subseteq># mset vs", "by auto"], ["proof (state)\nthis:\n  gs \\<subseteq># mset vs\n\ngoal (1 subgoal):\n 1. size gs < d \\<Longrightarrow> False", "have \"test_dvd u gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test_dvd u gs", "by (rule tests[OF sub gs_nempty, unfolded Nil], insert gs, auto)"], ["proof (state)\nthis:\n  test_dvd u gs\n\ngoal (1 subgoal):\n 1. size gs < d \\<Longrightarrow> False", "from this[unfolded test_dvd_def] uq deg q'_eq"], ["proof (chain)\npicking this:\n  \\<forall>v l.\n     v dvd u \\<longrightarrow>\n     0 < degree v \\<longrightarrow>\n     degree v < degree u \\<longrightarrow>\n     Mp v \\<noteq> Mp (Polynomial.smult l (\\<Prod>\\<^sub># gs))\n  u = q * q'\n  0 < degree q\n  degree q < degree u\n  0 < degree q'\n  degree q' < degree u\n  q' =m Polynomial.smult (lead_coeff q') (\\<Prod>\\<^sub># gs)", "show False"], ["proof (prove)\nusing this:\n  \\<forall>v l.\n     v dvd u \\<longrightarrow>\n     0 < degree v \\<longrightarrow>\n     degree v < degree u \\<longrightarrow>\n     Mp v \\<noteq> Mp (Polynomial.smult l (\\<Prod>\\<^sub># gs))\n  u = q * q'\n  0 < degree q\n  degree q < degree u\n  0 < degree q'\n  degree q' < degree u\n  q' =m Polynomial.smult (lead_coeff q') (\\<Prod>\\<^sub># gs)\n\ngoal (1 subgoal):\n 1. False", "unfolding uq"], ["proof (prove)\nusing this:\n  \\<forall>v l.\n     v dvd q * q' \\<longrightarrow>\n     0 < degree v \\<longrightarrow>\n     degree v < degree (q * q') \\<longrightarrow>\n     Mp v \\<noteq> Mp (Polynomial.smult l (\\<Prod>\\<^sub># gs))\n  q * q' = q * q'\n  0 < degree q\n  degree q < degree (q * q')\n  0 < degree q'\n  degree q' < degree (q * q')\n  q' =m Polynomial.smult (lead_coeff q') (\\<Prod>\\<^sub># gs)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  irreducible\\<^sub>d u\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < degree ?ua4;\n   comm_monoid_mult_class.coprime (lead_coeff ?ua4) p;\n   unique_factorization_m ?ua4 (lead_coeff ?ua4, mset ?vsa4);\n   p.square_free_m ?ua4;\n   \\<And>v. v \\<in> set ?vsa4 \\<Longrightarrow> Mp v = v;\n   size (mset ?vsa4) < ?da4 + ?da4;\n   \\<And>ws.\n      \\<lbrakk>ws \\<subseteq># mset ?vsa4; ws \\<noteq> {#};\n       size ws < ?da4\\<rbrakk>\n      \\<Longrightarrow> test_dvd ?ua4 ws\\<rbrakk>\n  \\<Longrightarrow> irreducible\\<^sub>d ?ua4\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "note irreducible\\<^sub>d_via_tests = this"], ["proof (state)\nthis:\n  \\<lbrakk>0 < degree ?ua4;\n   comm_monoid_mult_class.coprime (lead_coeff ?ua4) p;\n   unique_factorization_m ?ua4 (lead_coeff ?ua4, mset ?vsa4);\n   p.square_free_m ?ua4;\n   \\<And>v. v \\<in> set ?vsa4 \\<Longrightarrow> Mp v = v;\n   size (mset ?vsa4) < ?da4 + ?da4;\n   \\<And>ws.\n      \\<lbrakk>ws \\<subseteq># mset ?vsa4; ws \\<noteq> {#};\n       size ws < ?da4\\<rbrakk>\n      \\<Longrightarrow> test_dvd ?ua4 ws\\<rbrakk>\n  \\<Longrightarrow> irreducible\\<^sub>d ?ua4\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "using assms(1-16) large state"], ["proof (prove)\nusing this:\n  reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs res\n   cands =\n  fs\n  f = u * prod_list res\n  meas = (r - d, cands)\n  d + d \\<le> r\n  r = length vs\n  set cands \\<subseteq> S (lu, []) vs d\n  d = 0 \\<Longrightarrow> cands = []\n  lu = lead_coeff u\n  unique_factorization_m u (lu, mset vs)\n  p.square_free_m u\n  comm_monoid_mult_class.coprime lu p\n  ?v2 \\<in> set vs \\<Longrightarrow> Mp ?v2 = ?v2\n  \\<lbrakk>?ws2 \\<subseteq># mset vs; ?ws2 \\<noteq> {#};\n   size ?ws2 < d \\<or>\n   size ?ws2 = d \\<and>\n   ?ws2 \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n  \\<Longrightarrow> test_dvd u ?ws2\n  ?f2 \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d ?f2\n  0 < degree u\n  cands \\<noteq> [] \\<Longrightarrow> d < r\n  large_m (Polynomial.smult lu u) vs\n  sli (lu, []) vs d state\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "proof (induct meas arbitrary: u lu d r vs res cands state rule: wf_induct[OF wf])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "case (1 meas u lu d r vs res cands state)"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, meas) \\<in> R \\<longrightarrow>\n     (\\<forall>x xa xb xc xd xe xf xg.\n         reconstruction sl_impl m2 xg x (Polynomial.smult xa x) xa xb xc xd\n          xe xf =\n         fs \\<longrightarrow>\n         f = x * prod_list xe \\<longrightarrow>\n         y = (xc - xb, xf) \\<longrightarrow>\n         xb + xb \\<le> xc \\<longrightarrow>\n         xc = length xd \\<longrightarrow>\n         set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n         (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n         xa = lead_coeff x \\<longrightarrow>\n         unique_factorization_m x (xa, mset xd) \\<longrightarrow>\n         p.square_free_m x \\<longrightarrow>\n         comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n         (\\<forall>x.\n             x \\<in> set xd \\<longrightarrow> Mp x = x) \\<longrightarrow>\n         (\\<forall>xa.\n             xa \\<subseteq># mset xd \\<longrightarrow>\n             xa \\<noteq> {#} \\<longrightarrow>\n             size xa < xb \\<or>\n             size xa = xb \\<and>\n             xa \\<notin> (mset \\<circ> snd) ` set xf \\<longrightarrow>\n             test_dvd x xa) \\<longrightarrow>\n         (\\<forall>x.\n             x \\<in> set xe \\<longrightarrow>\n             irreducible\\<^sub>d x) \\<longrightarrow>\n         0 < degree x \\<longrightarrow>\n         (xf \\<noteq> [] \\<longrightarrow> xb < xc) \\<longrightarrow>\n         large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n         sli (xa, []) xd xb xg \\<longrightarrow>\n         f = prod_list fs \\<and>\n         (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a))\n  reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs res\n   cands =\n  fs\n  f = u * prod_list res\n  meas = (r - d, cands)\n  d + d \\<le> r\n  r = length vs\n  set cands \\<subseteq> S (lu, []) vs d\n  d = 0 \\<Longrightarrow> cands = []\n  lu = lead_coeff u\n  unique_factorization_m u (lu, mset vs)\n  p.square_free_m u\n  comm_monoid_mult_class.coprime lu p\n  ?v2 \\<in> set vs \\<Longrightarrow> Mp ?v2 = ?v2\n  \\<lbrakk>?ws2 \\<subseteq># mset vs; ?ws2 \\<noteq> {#};\n   size ?ws2 < d \\<or>\n   size ?ws2 = d \\<and>\n   ?ws2 \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n  \\<Longrightarrow> test_dvd u ?ws2\n  ?f2 \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d ?f2\n  0 < degree u\n  cands \\<noteq> [] \\<Longrightarrow> d < r\n  large_m (Polynomial.smult lu u) vs\n  sli (lu, []) vs d state\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note IH = 1(1)[rule_format]"], ["proof (state)\nthis:\n  \\<lbrakk>(?y, meas) \\<in> R;\n   reconstruction sl_impl m2 ?xg ?x (Polynomial.smult ?xa ?x) ?xa ?xb ?xc\n    ?xd ?xe ?xf =\n   fs;\n   f = ?x * prod_list ?xe; ?y = (?xc - ?xb, ?xf); ?xb + ?xb \\<le> ?xc;\n   ?xc = length ?xd; set ?xf \\<subseteq> S (?xa, []) ?xd ?xb;\n   ?xb = 0 \\<Longrightarrow> ?xf = []; ?xa = lead_coeff ?x;\n   unique_factorization_m ?x (?xa, mset ?xd); p.square_free_m ?x;\n   comm_monoid_mult_class.coprime ?xa p;\n   \\<And>x. x \\<in> set ?xd \\<Longrightarrow> Mp x = x;\n   \\<And>x.\n      \\<lbrakk>x \\<subseteq># mset ?xd; x \\<noteq> {#};\n       size x < ?xb \\<or>\n       size x = ?xb \\<and> x \\<notin> (mset \\<circ> snd) ` set ?xf\\<rbrakk>\n      \\<Longrightarrow> test_dvd ?x x;\n   \\<And>x. x \\<in> set ?xe \\<Longrightarrow> irreducible\\<^sub>d x;\n   0 < degree ?x; ?xf \\<noteq> [] \\<Longrightarrow> ?xb < ?xc;\n   large_m (Polynomial.smult ?xa ?x) ?xd; sli (?xa, []) ?xd ?xb ?xg\\<rbrakk>\n  \\<Longrightarrow> f = prod_list fs \\<and>\n                    Ball (set fs) irreducible\\<^sub>d\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note res = 1(2)[unfolded reconstruction.simps[where cands = cands]]"], ["proof (state)\nthis:\n  (case cands of\n   [] \\<Rightarrow>\n     let d' = Suc d\n     in if r < d' + d' then u # res\n        else case next_subseqs_foldr sl_impl state of\n             (cands, state') \\<Rightarrow>\n               reconstruction sl_impl m2 state' u (Polynomial.smult lu u) lu\n                d' r vs res cands\n   | (lv', ws) # cands' \\<Rightarrow>\n       let lv = inv_M2 m2 lv'\n       in if lv dvd coeff (Polynomial.smult lu u) 0\n          then let vb = inv_Mp2 m2\n                         (Mp (Polynomial.smult lu (prod_list_m ws)))\n               in if vb dvd Polynomial.smult lu u\n                  then let pp_vb = primitive_part vb; u' = u div pp_vb;\n                           r' = r - length ws; res' = pp_vb # res\n                       in if r' < d + d then u' # res'\n                          else let lu' = lead_coeff u';\n                                   vs' = fold remove1 ws vs;\n                                   (cands'', state') =\n                                     subseqs_foldr sl_impl (lu', []) vs' d\n                               in reconstruction sl_impl m2 state' u'\n                                   (Polynomial.smult lu' u') lu' d r' vs'\n                                   res' cands''\n                  else reconstruction sl_impl m2 state u\n                        (Polynomial.smult lu u) lu d r vs res cands'\n          else reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu\n                d r vs res cands') =\n  fs\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note f = 1(3)"], ["proof (state)\nthis:\n  f = u * prod_list res\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note meas = 1(4)"], ["proof (state)\nthis:\n  meas = (r - d, cands)\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note dr = 1(5)"], ["proof (state)\nthis:\n  d + d \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note r = 1(6)"], ["proof (state)\nthis:\n  r = length vs\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note cands = 1(7)"], ["proof (state)\nthis:\n  set cands \\<subseteq> S (lu, []) vs d\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note d0 = 1(8)"], ["proof (state)\nthis:\n  d = 0 \\<Longrightarrow> cands = []\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note lu = 1(9)"], ["proof (state)\nthis:\n  lu = lead_coeff u\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note factors = 1(10)"], ["proof (state)\nthis:\n  unique_factorization_m u (lu, mset vs)\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note sf = 1(11)"], ["proof (state)\nthis:\n  p.square_free_m u\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note cop = 1(12)"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime lu p\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note norm = 1(13)"], ["proof (state)\nthis:\n  ?v2 \\<in> set vs \\<Longrightarrow> Mp ?v2 = ?v2\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note tests = 1(14)"], ["proof (state)\nthis:\n  \\<lbrakk>?ws2 \\<subseteq># mset vs; ?ws2 \\<noteq> {#};\n   size ?ws2 < d \\<or>\n   size ?ws2 = d \\<and>\n   ?ws2 \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n  \\<Longrightarrow> test_dvd u ?ws2\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note irr = 1(15)"], ["proof (state)\nthis:\n  ?f2 \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d ?f2\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note deg_u = 1(16)"], ["proof (state)\nthis:\n  0 < degree u\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note cands_empty = 1(17)"], ["proof (state)\nthis:\n  cands \\<noteq> [] \\<Longrightarrow> d < r\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note large = 1(18)"], ["proof (state)\nthis:\n  large_m (Polynomial.smult lu u) vs\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "note state = 1(19)"], ["proof (state)\nthis:\n  sli (lu, []) vs d state\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "from unique_factorization_m_zero[OF factors]"], ["proof (chain)\npicking this:\n  M lu \\<noteq> 0", "have Mlu0: \"M lu \\<noteq> 0\""], ["proof (prove)\nusing this:\n  M lu \\<noteq> 0\n\ngoal (1 subgoal):\n 1. M lu \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  M lu \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "from Mlu0"], ["proof (chain)\npicking this:\n  M lu \\<noteq> 0", "have lu0: \"lu \\<noteq> 0\""], ["proof (prove)\nusing this:\n  M lu \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lu \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lu \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "from this[unfolded lu]"], ["proof (chain)\npicking this:\n  lead_coeff u \\<noteq> 0", "have u0: \"u \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lead_coeff u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. u \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "from unique_factorization_m_imp_factorization[OF factors]"], ["proof (chain)\npicking this:\n  factorization_m u (lu, mset vs)", "have fact: \"factorization_m u (lu,mset vs)\""], ["proof (prove)\nusing this:\n  factorization_m u (lu, mset vs)\n\ngoal (1 subgoal):\n 1. factorization_m u (lu, mset vs)", "by auto"], ["proof (state)\nthis:\n  factorization_m u (lu, mset vs)\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "from this[unfolded factorization_m_def split] norm"], ["proof (chain)\npicking this:\n  u =m Polynomial.smult lu (\\<Prod>\\<^sub># (mset vs)) \\<and>\n  (\\<forall>f\\<in>#mset vs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n  ?v2 \\<in> set vs \\<Longrightarrow> Mp ?v2 = ?v2", "have vs: \"u =m smult lu (prod_list vs)\" and \n      vs_mi: \"\\<And> f. f\\<in>#mset vs \\<Longrightarrow> irreducible\\<^sub>d_m f \\<and> monic f\""], ["proof (prove)\nusing this:\n  u =m Polynomial.smult lu (\\<Prod>\\<^sub># (mset vs)) \\<and>\n  (\\<forall>f\\<in>#mset vs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n  ?v2 \\<in> set vs \\<Longrightarrow> Mp ?v2 = ?v2\n\ngoal (1 subgoal):\n 1. u =m Polynomial.smult lu (prod_list vs) &&&\n    (\\<And>f.\n        f \\<in># mset vs \\<Longrightarrow>\n        irreducible\\<^sub>d_m f \\<and> monic f)", "by auto"], ["proof (state)\nthis:\n  u =m Polynomial.smult lu (prod_list vs)\n  ?f2 \\<in># mset vs \\<Longrightarrow>\n  irreducible\\<^sub>d_m ?f2 \\<and> monic ?f2\n\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "let ?luu = \"smult lu u\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x u lu d r vs res cands state.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa xb xc xd xe xf xg.\n                       reconstruction sl_impl m2 xg x\n                        (Polynomial.smult xa x) xa xb xc xd xe xf =\n                       fs \\<longrightarrow>\n                       f = x * prod_list xe \\<longrightarrow>\n                       y = (xc - xb, xf) \\<longrightarrow>\n                       xb + xb \\<le> xc \\<longrightarrow>\n                       xc = length xd \\<longrightarrow>\n                       set xf \\<subseteq> S (xa, []) xd xb \\<longrightarrow>\n                       (xb = 0 \\<longrightarrow> xf = []) \\<longrightarrow>\n                       xa = lead_coeff x \\<longrightarrow>\n                       unique_factorization_m x\n                        (xa, mset xd) \\<longrightarrow>\n                       p.square_free_m x \\<longrightarrow>\n                       comm_monoid_mult_class.coprime xa p \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xd \\<longrightarrow>\n                           Mp x = x) \\<longrightarrow>\n                       (\\<forall>xa.\n                           xa \\<subseteq># mset xd \\<longrightarrow>\n                           xa \\<noteq> {#} \\<longrightarrow>\n                           size xa < xb \\<or>\n                           size xa = xb \\<and>\n                           xa \\<notin> (mset \\<circ> snd) `\n set xf \\<longrightarrow>\n                           test_dvd x xa) \\<longrightarrow>\n                       (\\<forall>x.\n                           x \\<in> set xe \\<longrightarrow>\n                           irreducible\\<^sub>d x) \\<longrightarrow>\n                       0 < degree x \\<longrightarrow>\n                       (xf \\<noteq> [] \\<longrightarrow>\n                        xb < xc) \\<longrightarrow>\n                       large_m (Polynomial.smult xa x) xd \\<longrightarrow>\n                       sli (xa, []) xd xb xg \\<longrightarrow>\n                       f = prod_list fs \\<and>\n                       Ball (set fs) irreducible\\<^sub>d);\n        reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cands =\n        fs;\n        f = u * prod_list res; x = (r - d, cands); d + d \\<le> r;\n        r = length vs; set cands \\<subseteq> S (lu, []) vs d;\n        d = 0 \\<Longrightarrow> cands = []; lu = lead_coeff u;\n        unique_factorization_m u (lu, mset vs); p.square_free_m u;\n        comm_monoid_mult_class.coprime lu p;\n        \\<And>v. v \\<in> set vs \\<Longrightarrow> Mp v = v;\n        \\<And>ws.\n           \\<lbrakk>ws \\<subseteq># mset vs; ws \\<noteq> {#};\n            size ws < d \\<or>\n            size ws = d \\<and>\n            ws \\<notin> (mset \\<circ> snd) ` set cands\\<rbrakk>\n           \\<Longrightarrow> test_dvd u ws;\n        \\<And>f. f \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d f;\n        0 < degree u; cands \\<noteq> [] \\<Longrightarrow> d < r;\n        large_m (Polynomial.smult lu u) vs; sli (lu, []) vs d state\\<rbrakk>\n       \\<Longrightarrow> f = prod_list fs \\<and>\n                         Ball (set fs) irreducible\\<^sub>d", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "proof (cases cands)"], ["proof (state)\ngoal (2 subgoals):\n 1. cands = [] \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "case Nil"], ["proof (state)\nthis:\n  cands = []\n\ngoal (2 subgoals):\n 1. cands = [] \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "note res = res[unfolded this]"], ["proof (state)\nthis:\n  (case [] of\n   [] \\<Rightarrow>\n     let d' = Suc d\n     in if r < d' + d' then u # res\n        else case next_subseqs_foldr sl_impl state of\n             (cands, state') \\<Rightarrow>\n               reconstruction sl_impl m2 state' u (Polynomial.smult lu u) lu\n                d' r vs res cands\n   | (lv', ws) # cands' \\<Rightarrow>\n       let lv = inv_M2 m2 lv'\n       in if lv dvd coeff (Polynomial.smult lu u) 0\n          then let vb = inv_Mp2 m2\n                         (Mp (Polynomial.smult lu (prod_list_m ws)))\n               in if vb dvd Polynomial.smult lu u\n                  then let pp_vb = primitive_part vb; u' = u div pp_vb;\n                           r' = r - length ws; res' = pp_vb # res\n                       in if r' < d + d then u' # res'\n                          else let lu' = lead_coeff u';\n                                   vs' = fold remove1 ws vs;\n                                   (cands'', state') =\n                                     subseqs_foldr sl_impl (lu', []) vs' d\n                               in reconstruction sl_impl m2 state' u'\n                                   (Polynomial.smult lu' u') lu' d r' vs'\n                                   res' cands''\n                  else reconstruction sl_impl m2 state u\n                        (Polynomial.smult lu u) lu d r vs res cands'\n          else reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu\n                d r vs res cands') =\n  fs\n\ngoal (2 subgoals):\n 1. cands = [] \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "let ?d' = \"Suc d\""], ["proof (state)\ngoal (2 subgoals):\n 1. cands = [] \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "proof (cases \"r < ?d' + ?d'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<not> r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "case True"], ["proof (state)\nthis:\n  r < Suc d + Suc d\n\ngoal (2 subgoals):\n 1. r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<not> r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "with res"], ["proof (chain)\npicking this:\n  (case [] of\n   [] \\<Rightarrow>\n     let d' = Suc d\n     in if r < d' + d' then u # res\n        else case next_subseqs_foldr sl_impl state of\n             (cands, state') \\<Rightarrow>\n               reconstruction sl_impl m2 state' u (Polynomial.smult lu u) lu\n                d' r vs res cands\n   | (lv', ws) # cands' \\<Rightarrow>\n       let lv = inv_M2 m2 lv'\n       in if lv dvd coeff (Polynomial.smult lu u) 0\n          then let vb = inv_Mp2 m2\n                         (Mp (Polynomial.smult lu (prod_list_m ws)))\n               in if vb dvd Polynomial.smult lu u\n                  then let pp_vb = primitive_part vb; u' = u div pp_vb;\n                           r' = r - length ws; res' = pp_vb # res\n                       in if r' < d + d then u' # res'\n                          else let lu' = lead_coeff u';\n                                   vs' = fold remove1 ws vs;\n                                   (cands'', state') =\n                                     subseqs_foldr sl_impl (lu', []) vs' d\n                               in reconstruction sl_impl m2 state' u'\n                                   (Polynomial.smult lu' u') lu' d r' vs'\n                                   res' cands''\n                  else reconstruction sl_impl m2 state u\n                        (Polynomial.smult lu u) lu d r vs res cands'\n          else reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu\n                d r vs res cands') =\n  fs\n  r < Suc d + Suc d", "have fs: \"fs = u # res\""], ["proof (prove)\nusing this:\n  (case [] of\n   [] \\<Rightarrow>\n     let d' = Suc d\n     in if r < d' + d' then u # res\n        else case next_subseqs_foldr sl_impl state of\n             (cands, state') \\<Rightarrow>\n               reconstruction sl_impl m2 state' u (Polynomial.smult lu u) lu\n                d' r vs res cands\n   | (lv', ws) # cands' \\<Rightarrow>\n       let lv = inv_M2 m2 lv'\n       in if lv dvd coeff (Polynomial.smult lu u) 0\n          then let vb = inv_Mp2 m2\n                         (Mp (Polynomial.smult lu (prod_list_m ws)))\n               in if vb dvd Polynomial.smult lu u\n                  then let pp_vb = primitive_part vb; u' = u div pp_vb;\n                           r' = r - length ws; res' = pp_vb # res\n                       in if r' < d + d then u' # res'\n                          else let lu' = lead_coeff u';\n                                   vs' = fold remove1 ws vs;\n                                   (cands'', state') =\n                                     subseqs_foldr sl_impl (lu', []) vs' d\n                               in reconstruction sl_impl m2 state' u'\n                                   (Polynomial.smult lu' u') lu' d r' vs'\n                                   res' cands''\n                  else reconstruction sl_impl m2 state u\n                        (Polynomial.smult lu u) lu d r vs res cands'\n          else reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu\n                d r vs res cands') =\n  fs\n  r < Suc d + Suc d\n\ngoal (1 subgoal):\n 1. fs = u # res", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  fs = u # res\n\ngoal (2 subgoals):\n 1. r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<not> r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from True[unfolded r]"], ["proof (chain)\npicking this:\n  length vs < Suc d + Suc d", "have size: \"size (mset vs) < ?d' + ?d'\""], ["proof (prove)\nusing this:\n  length vs < Suc d + Suc d\n\ngoal (1 subgoal):\n 1. size (mset vs) < Suc d + Suc d", "by auto"], ["proof (state)\nthis:\n  size (mset vs) < Suc d + Suc d\n\ngoal (2 subgoals):\n 1. r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<not> r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have \"irreducible\\<^sub>d u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d u", "by (rule irreducible\\<^sub>d_via_tests[OF deg_u cop[unfolded lu] factors(1)[unfolded lu] \n          sf norm size tests], auto simp: Nil)"], ["proof (state)\nthis:\n  irreducible\\<^sub>d u\n\ngoal (2 subgoals):\n 1. r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<not> r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "with fs f irr"], ["proof (chain)\npicking this:\n  fs = u # res\n  f = u * prod_list res\n  ?f2 \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d ?f2\n  irreducible\\<^sub>d u", "show ?thesis"], ["proof (prove)\nusing this:\n  fs = u # res\n  f = u * prod_list res\n  ?f2 \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d ?f2\n  irreducible\\<^sub>d u\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "by simp"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n\ngoal (1 subgoal):\n 1. \\<not> r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "case False"], ["proof (state)\nthis:\n  \\<not> r < Suc d + Suc d\n\ngoal (1 subgoal):\n 1. \\<not> r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "with dr"], ["proof (chain)\npicking this:\n  d + d \\<le> r\n  \\<not> r < Suc d + Suc d", "have dr: \"?d' + ?d' \\<le> r\" and dr': \"?d' < r\""], ["proof (prove)\nusing this:\n  d + d \\<le> r\n  \\<not> r < Suc d + Suc d\n\ngoal (1 subgoal):\n 1. Suc d + Suc d \\<le> r &&& Suc d < r", "by auto"], ["proof (state)\nthis:\n  Suc d + Suc d \\<le> r\n  Suc d < r\n\ngoal (1 subgoal):\n 1. \\<not> r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "obtain state' cands' where sln: \"next_subseqs_foldr sl_impl state = (cands',state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cands' state'.\n        next_subseqs_foldr sl_impl state =\n        (cands', state') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  next_subseqs_foldr sl_impl state = (cands', state')\n\ngoal (1 subgoal):\n 1. \\<not> r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from next_subseqs_foldr[OF sln state]"], ["proof (chain)\npicking this:\n  sli (lu, []) vs (Suc d) state' \\<and> set cands' = S (lu, []) vs (Suc d)", "have state': \"sli (lu,[]) vs (Suc d) state'\"\n          and cands': \"set cands' = S (lu,[]) vs (Suc d)\""], ["proof (prove)\nusing this:\n  sli (lu, []) vs (Suc d) state' \\<and> set cands' = S (lu, []) vs (Suc d)\n\ngoal (1 subgoal):\n 1. sli (lu, []) vs (Suc d) state' &&& set cands' = S (lu, []) vs (Suc d)", "by auto"], ["proof (state)\nthis:\n  sli (lu, []) vs (Suc d) state'\n  set cands' = S (lu, []) vs (Suc d)\n\ngoal (1 subgoal):\n 1. \\<not> r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "let ?new = \"subseqs_length mul_const lu ?d' vs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have R: \"((r - Suc d, cands'), meas) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((r - Suc d, cands'), meas) \\<in> R", "unfolding meas R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((r - Suc d, cands'), r - d, cands)\n    \\<in> measures [\\<lambda>(n, cds). n, \\<lambda>(n, y). length y]", "using False"], ["proof (prove)\nusing this:\n  \\<not> r < Suc d + Suc d\n\ngoal (1 subgoal):\n 1. ((r - Suc d, cands'), r - d, cands)\n    \\<in> measures [\\<lambda>(n, cds). n, \\<lambda>(n, y). length y]", "by auto"], ["proof (state)\nthis:\n  ((r - Suc d, cands'), meas) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<not> r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from res False sln"], ["proof (chain)\npicking this:\n  (case [] of\n   [] \\<Rightarrow>\n     let d' = Suc d\n     in if r < d' + d' then u # res\n        else case next_subseqs_foldr sl_impl state of\n             (cands, state') \\<Rightarrow>\n               reconstruction sl_impl m2 state' u (Polynomial.smult lu u) lu\n                d' r vs res cands\n   | (lv', ws) # cands' \\<Rightarrow>\n       let lv = inv_M2 m2 lv'\n       in if lv dvd coeff (Polynomial.smult lu u) 0\n          then let vb = inv_Mp2 m2\n                         (Mp (Polynomial.smult lu (prod_list_m ws)))\n               in if vb dvd Polynomial.smult lu u\n                  then let pp_vb = primitive_part vb; u' = u div pp_vb;\n                           r' = r - length ws; res' = pp_vb # res\n                       in if r' < d + d then u' # res'\n                          else let lu' = lead_coeff u';\n                                   vs' = fold remove1 ws vs;\n                                   (cands'', state') =\n                                     subseqs_foldr sl_impl (lu', []) vs' d\n                               in reconstruction sl_impl m2 state' u'\n                                   (Polynomial.smult lu' u') lu' d r' vs'\n                                   res' cands''\n                  else reconstruction sl_impl m2 state u\n                        (Polynomial.smult lu u) lu d r vs res cands'\n          else reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu\n                d r vs res cands') =\n  fs\n  \\<not> r < Suc d + Suc d\n  next_subseqs_foldr sl_impl state = (cands', state')", "have fact: \"reconstruction sl_impl m2 state' u ?luu lu ?d' r vs res cands' = fs\""], ["proof (prove)\nusing this:\n  (case [] of\n   [] \\<Rightarrow>\n     let d' = Suc d\n     in if r < d' + d' then u # res\n        else case next_subseqs_foldr sl_impl state of\n             (cands, state') \\<Rightarrow>\n               reconstruction sl_impl m2 state' u (Polynomial.smult lu u) lu\n                d' r vs res cands\n   | (lv', ws) # cands' \\<Rightarrow>\n       let lv = inv_M2 m2 lv'\n       in if lv dvd coeff (Polynomial.smult lu u) 0\n          then let vb = inv_Mp2 m2\n                         (Mp (Polynomial.smult lu (prod_list_m ws)))\n               in if vb dvd Polynomial.smult lu u\n                  then let pp_vb = primitive_part vb; u' = u div pp_vb;\n                           r' = r - length ws; res' = pp_vb # res\n                       in if r' < d + d then u' # res'\n                          else let lu' = lead_coeff u';\n                                   vs' = fold remove1 ws vs;\n                                   (cands'', state') =\n                                     subseqs_foldr sl_impl (lu', []) vs' d\n                               in reconstruction sl_impl m2 state' u'\n                                   (Polynomial.smult lu' u') lu' d r' vs'\n                                   res' cands''\n                  else reconstruction sl_impl m2 state u\n                        (Polynomial.smult lu u) lu d r vs res cands'\n          else reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu\n                d r vs res cands') =\n  fs\n  \\<not> r < Suc d + Suc d\n  next_subseqs_foldr sl_impl state = (cands', state')\n\ngoal (1 subgoal):\n 1. reconstruction sl_impl m2 state' u (Polynomial.smult lu u) lu (Suc d) r\n     vs res cands' =\n    fs", "by auto"], ["proof (state)\nthis:\n  reconstruction sl_impl m2 state' u (Polynomial.smult lu u) lu (Suc d) r vs\n   res cands' =\n  fs\n\ngoal (1 subgoal):\n 1. \\<not> r < Suc d + Suc d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "proof (rule IH[OF R fact f refl dr r _ _ lu factors sf cop norm _ irr deg_u dr' large state'], goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. set cands' \\<subseteq> S (lu, []) vs (Suc d)\n 2. Suc d = 0 \\<Longrightarrow> cands' = []\n 3. \\<And>x. x \\<in> set vs \\<Longrightarrow> x \\<in> set vs\n 4. \\<And>x.\n       \\<lbrakk>x \\<subseteq># mset vs; x \\<noteq> {#};\n        size x < Suc d \\<or>\n        size x = Suc d \\<and>\n        x \\<notin> (mset \\<circ> snd) ` set cands'\\<rbrakk>\n       \\<Longrightarrow> test_dvd u x\n 5. \\<And>x. x \\<in> set res \\<Longrightarrow> x \\<in> set res", "case (4 ws)"], ["proof (state)\nthis:\n  ws \\<subseteq># mset vs\n  ws \\<noteq> {#}\n  size ws < Suc d \\<or>\n  size ws = Suc d \\<and> ws \\<notin> (mset \\<circ> snd) ` set cands'\n\ngoal (5 subgoals):\n 1. set cands' \\<subseteq> S (lu, []) vs (Suc d)\n 2. Suc d = 0 \\<Longrightarrow> cands' = []\n 3. \\<And>x. x \\<in> set vs \\<Longrightarrow> x \\<in> set vs\n 4. \\<And>x.\n       \\<lbrakk>x \\<subseteq># mset vs; x \\<noteq> {#};\n        size x < Suc d \\<or>\n        size x = Suc d \\<and>\n        x \\<notin> (mset \\<circ> snd) ` set cands'\\<rbrakk>\n       \\<Longrightarrow> test_dvd u x\n 5. \\<And>x. x \\<in> set res \\<Longrightarrow> x \\<in> set res", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. test_dvd u ws", "proof (cases \"size ws = Suc d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. size ws = Suc d \\<Longrightarrow> test_dvd u ws\n 2. size ws \\<noteq> Suc d \\<Longrightarrow> test_dvd u ws", "case False"], ["proof (state)\nthis:\n  size ws \\<noteq> Suc d\n\ngoal (2 subgoals):\n 1. size ws = Suc d \\<Longrightarrow> test_dvd u ws\n 2. size ws \\<noteq> Suc d \\<Longrightarrow> test_dvd u ws", "with 4"], ["proof (chain)\npicking this:\n  ws \\<subseteq># mset vs\n  ws \\<noteq> {#}\n  size ws < Suc d \\<or>\n  size ws = Suc d \\<and> ws \\<notin> (mset \\<circ> snd) ` set cands'\n  size ws \\<noteq> Suc d", "have \"size ws < Suc d\""], ["proof (prove)\nusing this:\n  ws \\<subseteq># mset vs\n  ws \\<noteq> {#}\n  size ws < Suc d \\<or>\n  size ws = Suc d \\<and> ws \\<notin> (mset \\<circ> snd) ` set cands'\n  size ws \\<noteq> Suc d\n\ngoal (1 subgoal):\n 1. size ws < Suc d", "by auto"], ["proof (state)\nthis:\n  size ws < Suc d\n\ngoal (2 subgoals):\n 1. size ws = Suc d \\<Longrightarrow> test_dvd u ws\n 2. size ws \\<noteq> Suc d \\<Longrightarrow> test_dvd u ws", "thus ?thesis"], ["proof (prove)\nusing this:\n  size ws < Suc d\n\ngoal (1 subgoal):\n 1. test_dvd u ws", "by (intro tests[OF 4(1-2)], unfold Nil, auto)"], ["proof (state)\nthis:\n  test_dvd u ws\n\ngoal (1 subgoal):\n 1. size ws = Suc d \\<Longrightarrow> test_dvd u ws", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. size ws = Suc d \\<Longrightarrow> test_dvd u ws", "case True"], ["proof (state)\nthis:\n  size ws = Suc d\n\ngoal (1 subgoal):\n 1. size ws = Suc d \\<Longrightarrow> test_dvd u ws", "from 4(3)[unfolded cands' mset_snd_S] True 4(1)"], ["proof (chain)\npicking this:\n  size ws < Suc d \\<or>\n  size ws = Suc d \\<and>\n  ws \\<notin> {ws. ws \\<subseteq># mset vs \\<and> size ws = Suc d}\n  size ws = Suc d\n  ws \\<subseteq># mset vs", "show ?thesis"], ["proof (prove)\nusing this:\n  size ws < Suc d \\<or>\n  size ws = Suc d \\<and>\n  ws \\<notin> {ws. ws \\<subseteq># mset vs \\<and> size ws = Suc d}\n  size ws = Suc d\n  ws \\<subseteq># mset vs\n\ngoal (1 subgoal):\n 1. test_dvd u ws", "by auto"], ["proof (state)\nthis:\n  test_dvd u ws\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  test_dvd u ws\n\ngoal (4 subgoals):\n 1. set cands' \\<subseteq> S (lu, []) vs (Suc d)\n 2. Suc d = 0 \\<Longrightarrow> cands' = []\n 3. \\<And>x. x \\<in> set vs \\<Longrightarrow> x \\<in> set vs\n 4. \\<And>x. x \\<in> set res \\<Longrightarrow> x \\<in> set res", "qed (auto simp: cands')"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "case (Cons c cds)"], ["proof (state)\nthis:\n  cands = c # cds\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "with d0"], ["proof (chain)\npicking this:\n  d = 0 \\<Longrightarrow> cands = []\n  cands = c # cds", "have d0: \"d > 0\""], ["proof (prove)\nusing this:\n  d = 0 \\<Longrightarrow> cands = []\n  cands = c # cds\n\ngoal (1 subgoal):\n 1. 0 < d", "by auto"], ["proof (state)\nthis:\n  0 < d\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "obtain lv' ws where c: \"c = (lv',ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lv' ws. c = (lv', ws) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  c = (lv', ws)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "let ?lv = \"inv_M lv'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "define vb where \"vb \\<equiv> inv_Mp (Mp (smult lu (prod_list ws)))\""], ["proof (state)\nthis:\n  vb \\<equiv> inv_Mp (Mp (Polynomial.smult lu (prod_list ws)))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "note res = res[unfolded Cons c list.simps split]"], ["proof (state)\nthis:\n  (let lv = inv_M2 m2 lv'\n   in if lv dvd coeff (Polynomial.smult lu u) 0\n      then let vb = inv_Mp2 m2 (Mp (Polynomial.smult lu (prod_list_m ws)))\n           in if vb dvd Polynomial.smult lu u\n              then let pp_vb = primitive_part vb; u' = u div pp_vb;\n                       r' = r - length ws; res' = pp_vb # res\n                   in if r' < d + d then u' # res'\n                      else let lu' = lead_coeff u';\n                               vs' = fold remove1 ws vs;\n                               (cands'', state') =\n                                 subseqs_foldr sl_impl (lu', []) vs' d\n                           in reconstruction sl_impl m2 state' u'\n                               (Polynomial.smult lu' u') lu' d r' vs' res'\n                               cands''\n              else reconstruction sl_impl m2 state u (Polynomial.smult lu u)\n                    lu d r vs res cds\n      else reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r\n            vs res cds) =\n  fs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from cands[unfolded Cons c S_def]"], ["proof (chain)\npicking this:\n  set ((lv', ws) # cds)\n  \\<subseteq> {foldr (\\<lambda>x. map_prod (mul_const x) ((#) x)) ys\n                (lu, []) |\n               ys. subseq_of_length d vs ys}", "have ws: \"ws \\<in> set (subseqs vs)\" \"length ws = d\" \n        and lv'': \"lv' = foldr mul_const ws lu\""], ["proof (prove)\nusing this:\n  set ((lv', ws) # cds)\n  \\<subseteq> {foldr (\\<lambda>x. map_prod (mul_const x) ((#) x)) ys\n                (lu, []) |\n               ys. subseq_of_length d vs ys}\n\ngoal (1 subgoal):\n 1. (ws \\<in> set (subseqs vs) &&& length ws = d) &&&\n    lv' = foldr mul_const ws lu", "by auto"], ["proof (state)\nthis:\n  ws \\<in> set (subseqs vs)\n  length ws = d\n  lv' = foldr mul_const ws lu\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from subseqs_sub_mset[OF ws(1)]"], ["proof (chain)\npicking this:\n  mset ws \\<subseteq># mset vs", "have ws_vs: \"mset ws \\<subseteq># mset vs\" \"set ws \\<subseteq> set vs\""], ["proof (prove)\nusing this:\n  mset ws \\<subseteq># mset vs\n\ngoal (1 subgoal):\n 1. mset ws \\<subseteq># mset vs &&& set ws \\<subseteq> set vs", "using set_mset_mono subseqs_length_simple_False"], ["proof (prove)\nusing this:\n  mset ws \\<subseteq># mset vs\n  ?A \\<subseteq># ?B \\<Longrightarrow> set_mset ?A \\<subseteq> set_mset ?B\n  \\<lbrakk>?b \\<in> set (subseqs ?xs); length ?xs < length ?b\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. mset ws \\<subseteq># mset vs &&& set ws \\<subseteq> set vs", "by auto fastforce"], ["proof (state)\nthis:\n  mset ws \\<subseteq># mset vs\n  set ws \\<subseteq> set vs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have mon_ws: \"monic (prod_mset (mset ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>\\<^sub># (mset ws))", "by (rule monic_prod_mset, insert ws_vs vs_mi, auto)"], ["proof (state)\nthis:\n  monic (\\<Prod>\\<^sub># (mset ws))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have l_ws: \"lead_coeff (prod_mset (mset ws)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>\\<^sub># (mset ws))", "using mon_ws"], ["proof (prove)\nusing this:\n  monic (\\<Prod>\\<^sub># (mset ws))\n\ngoal (1 subgoal):\n 1. monic (\\<Prod>\\<^sub># (mset ws))", "."], ["proof (state)\nthis:\n  monic (\\<Prod>\\<^sub># (mset ws))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have lv': \"M lv' = M (coeff (smult lu (prod_list ws)) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M lv' = M (coeff (Polynomial.smult lu (prod_list ws)) 0)", "unfolding lv'' coeff_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. M (foldr mul_const ws lu) = M (lu * coeff (prod_list ws) 0)", "by (induct ws arbitrary: lu, auto simp: mul_const_def M_def coeff_mult_0)\n           (metis mod_mult_right_eq mult.left_commute)"], ["proof (state)\nthis:\n  M lv' = M (coeff (Polynomial.smult lu (prod_list ws)) 0)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cands = a # list \\<Longrightarrow>\n       f = prod_list fs \\<and>\n       (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "proof (cases \"?lv dvd coeff ?luu 0 \\<and> vb dvd ?luu\")"], ["proof (state)\ngoal (2 subgoals):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<not> (inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n            vb dvd Polynomial.smult lu u) \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "case False"], ["proof (state)\nthis:\n  \\<not> (inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n          vb dvd Polynomial.smult lu u)\n\ngoal (2 subgoals):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<not> (inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n            vb dvd Polynomial.smult lu u) \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have ndvd: \"\\<not> vb dvd ?luu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> vb dvd Polynomial.smult lu u", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. vb dvd Polynomial.smult lu u \\<Longrightarrow> False", "assume dvd: \"vb dvd ?luu\""], ["proof (state)\nthis:\n  vb dvd Polynomial.smult lu u\n\ngoal (1 subgoal):\n 1. vb dvd Polynomial.smult lu u \\<Longrightarrow> False", "hence \"coeff vb 0 dvd coeff ?luu 0\""], ["proof (prove)\nusing this:\n  vb dvd Polynomial.smult lu u\n\ngoal (1 subgoal):\n 1. coeff vb 0 dvd coeff (Polynomial.smult lu u) 0", "by (metis coeff_mult_0 dvd_def)"], ["proof (state)\nthis:\n  coeff vb 0 dvd coeff (Polynomial.smult lu u) 0\n\ngoal (1 subgoal):\n 1. vb dvd Polynomial.smult lu u \\<Longrightarrow> False", "with dvd False"], ["proof (chain)\npicking this:\n  vb dvd Polynomial.smult lu u\n  \\<not> (inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n          vb dvd Polynomial.smult lu u)\n  coeff vb 0 dvd coeff (Polynomial.smult lu u) 0", "have \"?lv \\<noteq> coeff vb 0\""], ["proof (prove)\nusing this:\n  vb dvd Polynomial.smult lu u\n  \\<not> (inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n          vb dvd Polynomial.smult lu u)\n  coeff vb 0 dvd coeff (Polynomial.smult lu u) 0\n\ngoal (1 subgoal):\n 1. inv_M lv' \\<noteq> coeff vb 0", "by auto"], ["proof (state)\nthis:\n  inv_M lv' \\<noteq> coeff vb 0\n\ngoal (1 subgoal):\n 1. vb dvd Polynomial.smult lu u \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  inv_M lv' \\<noteq> coeff vb 0\n\ngoal (1 subgoal):\n 1. vb dvd Polynomial.smult lu u \\<Longrightarrow> False", "have \"lv' = M lv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv' = M lv'", "using ws(2) d0"], ["proof (prove)\nusing this:\n  length ws = d\n  0 < d\n\ngoal (1 subgoal):\n 1. lv' = M lv'", "unfolding lv''"], ["proof (prove)\nusing this:\n  length ws = d\n  0 < d\n\ngoal (1 subgoal):\n 1. foldr mul_const ws lu = M (foldr mul_const ws lu)", "by (cases ws, force, simp add: M_def mul_const_def)"], ["proof (state)\nthis:\n  lv' = M lv'\n\ngoal (1 subgoal):\n 1. vb dvd Polynomial.smult lu u \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lv' = M lv'\n\ngoal (1 subgoal):\n 1. vb dvd Polynomial.smult lu u \\<Longrightarrow> False", "have \"inv_M (M lv') = coeff vb 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_M (M lv') = coeff vb 0", "unfolding vb_def inv_Mp_coeff Mp_coeff lv'"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_M (M (coeff (Polynomial.smult lu (prod_list ws)) 0)) =\n    inv_M (M (coeff (Polynomial.smult lu (prod_list ws)) 0))", "by simp"], ["proof (state)\nthis:\n  inv_M (M lv') = coeff vb 0\n\ngoal (1 subgoal):\n 1. vb dvd Polynomial.smult lu u \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  coeff vb 0 \\<noteq> coeff vb 0", "show False"], ["proof (prove)\nusing this:\n  coeff vb 0 \\<noteq> coeff vb 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> vb dvd Polynomial.smult lu u\n\ngoal (2 subgoals):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<not> (inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n            vb dvd Polynomial.smult lu u) \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from False res"], ["proof (chain)\npicking this:\n  \\<not> (inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n          vb dvd Polynomial.smult lu u)\n  (let lv = inv_M2 m2 lv'\n   in if lv dvd coeff (Polynomial.smult lu u) 0\n      then let vb = inv_Mp2 m2 (Mp (Polynomial.smult lu (prod_list_m ws)))\n           in if vb dvd Polynomial.smult lu u\n              then let pp_vb = primitive_part vb; u' = u div pp_vb;\n                       r' = r - length ws; res' = pp_vb # res\n                   in if r' < d + d then u' # res'\n                      else let lu' = lead_coeff u';\n                               vs' = fold remove1 ws vs;\n                               (cands'', state') =\n                                 subseqs_foldr sl_impl (lu', []) vs' d\n                           in reconstruction sl_impl m2 state' u'\n                               (Polynomial.smult lu' u') lu' d r' vs' res'\n                               cands''\n              else reconstruction sl_impl m2 state u (Polynomial.smult lu u)\n                    lu d r vs res cds\n      else reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r\n            vs res cds) =\n  fs", "have res: \"reconstruction sl_impl m2 state u ?luu lu d r vs res cds = fs\""], ["proof (prove)\nusing this:\n  \\<not> (inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n          vb dvd Polynomial.smult lu u)\n  (let lv = inv_M2 m2 lv'\n   in if lv dvd coeff (Polynomial.smult lu u) 0\n      then let vb = inv_Mp2 m2 (Mp (Polynomial.smult lu (prod_list_m ws)))\n           in if vb dvd Polynomial.smult lu u\n              then let pp_vb = primitive_part vb; u' = u div pp_vb;\n                       r' = r - length ws; res' = pp_vb # res\n                   in if r' < d + d then u' # res'\n                      else let lu' = lead_coeff u';\n                               vs' = fold remove1 ws vs;\n                               (cands'', state') =\n                                 subseqs_foldr sl_impl (lu', []) vs' d\n                           in reconstruction sl_impl m2 state' u'\n                               (Polynomial.smult lu' u') lu' d r' vs' res'\n                               cands''\n              else reconstruction sl_impl m2 state u (Polynomial.smult lu u)\n                    lu d r vs res cds\n      else reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r\n            vs res cds) =\n  fs\n\ngoal (1 subgoal):\n 1. reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs res\n     cds =\n    fs", "unfolding vb_def Let_def"], ["proof (prove)\nusing this:\n  \\<not> (inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n          inv_Mp (Mp (Polynomial.smult lu (prod_list ws))) dvd\n          Polynomial.smult lu u)\n  (if inv_M2 m2 lv' dvd coeff (Polynomial.smult lu u) 0\n   then if inv_Mp2 m2 (Mp (Polynomial.smult lu (prod_list_m ws))) dvd\n           Polynomial.smult lu u\n        then if r - length ws < d + d\n             then u div\n                  primitive_part\n                   (inv_Mp2 m2\n                     (Mp (Polynomial.smult lu (prod_list_m ws)))) #\n                  primitive_part\n                   (inv_Mp2 m2\n                     (Mp (Polynomial.smult lu (prod_list_m ws)))) #\n                  res\n             else case subseqs_foldr sl_impl\n                        (lead_coeff\n                          (u div\n                           primitive_part\n                            (inv_Mp2 m2\n                              (Mp (Polynomial.smult lu (prod_list_m ws))))),\n                         [])\n                        (fold remove1 ws vs) d of\n                  (cands'', state') \\<Rightarrow>\n                    reconstruction sl_impl m2 state'\n                     (u div\n                      primitive_part\n                       (inv_Mp2 m2\n                         (Mp (Polynomial.smult lu (prod_list_m ws)))))\n                     (Polynomial.smult\n                       (lead_coeff\n                         (u div\n                          primitive_part\n                           (inv_Mp2 m2\n                             (Mp (Polynomial.smult lu (prod_list_m ws))))))\n                       (u div\n                        primitive_part\n                         (inv_Mp2 m2\n                           (Mp (Polynomial.smult lu (prod_list_m ws))))))\n                     (lead_coeff\n                       (u div\n                        primitive_part\n                         (inv_Mp2 m2\n                           (Mp (Polynomial.smult lu (prod_list_m ws))))))\n                     d (r - length ws) (fold remove1 ws vs)\n                     (primitive_part\n                       (inv_Mp2 m2\n                         (Mp (Polynomial.smult lu (prod_list_m ws)))) #\n                      res)\n                     cands''\n        else reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d\n              r vs res cds\n   else reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cds) =\n  fs\n\ngoal (1 subgoal):\n 1. reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs res\n     cds =\n    fs", "by auto"], ["proof (state)\nthis:\n  reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs res\n   cds =\n  fs\n\ngoal (2 subgoals):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<not> (inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n            vb dvd Polynomial.smult lu u) \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have R: \"((r - d, cds), meas) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((r - d, cds), meas) \\<in> R", "unfolding meas Cons R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((r - d, cds), r - d, c # cds)\n    \\<in> measures [\\<lambda>(n, cds). n, \\<lambda>(n, y). length y]", "by auto"], ["proof (state)\nthis:\n  ((r - d, cds), meas) \\<in> R\n\ngoal (2 subgoals):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<not> (inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n            vb dvd Polynomial.smult lu u) \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from cands"], ["proof (chain)\npicking this:\n  set cands \\<subseteq> S (lu, []) vs d", "have cands: \"set cds \\<subseteq> S (lu,[]) vs d\""], ["proof (prove)\nusing this:\n  set cands \\<subseteq> S (lu, []) vs d\n\ngoal (1 subgoal):\n 1. set cds \\<subseteq> S (lu, []) vs d", "unfolding Cons"], ["proof (prove)\nusing this:\n  set (c # cds) \\<subseteq> S (lu, []) vs d\n\ngoal (1 subgoal):\n 1. set cds \\<subseteq> S (lu, []) vs d", "by auto"], ["proof (state)\nthis:\n  set cds \\<subseteq> S (lu, []) vs d\n\ngoal (2 subgoals):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<not> (inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n            vb dvd Polynomial.smult lu u) \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "proof (rule IH[OF R res f refl dr r cands _ lu factors sf cop norm _ irr deg_u _ large state], goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. d = 0 \\<Longrightarrow> cds = []\n 2. \\<And>x. x \\<in> set vs \\<Longrightarrow> x \\<in> set vs\n 3. \\<And>x.\n       \\<lbrakk>x \\<subseteq># mset vs; x \\<noteq> {#};\n        size x < d \\<or>\n        size x = d \\<and> x \\<notin> (mset \\<circ> snd) ` set cds\\<rbrakk>\n       \\<Longrightarrow> test_dvd u x\n 4. \\<And>x. x \\<in> set res \\<Longrightarrow> x \\<in> set res\n 5. cds \\<noteq> [] \\<Longrightarrow> d < r", "case (3 ws')"], ["proof (state)\nthis:\n  ws' \\<subseteq># mset vs\n  ws' \\<noteq> {#}\n  size ws' < d \\<or>\n  size ws' = d \\<and> ws' \\<notin> (mset \\<circ> snd) ` set cds\n\ngoal (5 subgoals):\n 1. d = 0 \\<Longrightarrow> cds = []\n 2. \\<And>x. x \\<in> set vs \\<Longrightarrow> x \\<in> set vs\n 3. \\<And>x.\n       \\<lbrakk>x \\<subseteq># mset vs; x \\<noteq> {#};\n        size x < d \\<or>\n        size x = d \\<and> x \\<notin> (mset \\<circ> snd) ` set cds\\<rbrakk>\n       \\<Longrightarrow> test_dvd u x\n 4. \\<And>x. x \\<in> set res \\<Longrightarrow> x \\<in> set res\n 5. cds \\<noteq> [] \\<Longrightarrow> d < r", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. test_dvd u ws'", "proof (cases \"ws' = mset ws\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ws' = mset ws \\<Longrightarrow> test_dvd u ws'\n 2. ws' \\<noteq> mset ws \\<Longrightarrow> test_dvd u ws'", "case False"], ["proof (state)\nthis:\n  ws' \\<noteq> mset ws\n\ngoal (2 subgoals):\n 1. ws' = mset ws \\<Longrightarrow> test_dvd u ws'\n 2. ws' \\<noteq> mset ws \\<Longrightarrow> test_dvd u ws'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. test_dvd u ws'", "by (rule tests[OF 3(1-2)], insert 3(3) False, force simp: Cons c)"], ["proof (state)\nthis:\n  test_dvd u ws'\n\ngoal (1 subgoal):\n 1. ws' = mset ws \\<Longrightarrow> test_dvd u ws'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ws' = mset ws \\<Longrightarrow> test_dvd u ws'", "case True"], ["proof (state)\nthis:\n  ws' = mset ws\n\ngoal (1 subgoal):\n 1. ws' = mset ws \\<Longrightarrow> test_dvd u ws'", "have test: \"test_dvd_exec lu u ws'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test_dvd_exec lu u ws'", "unfolding True test_dvd_exec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> inv_Mp (Mp (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))) dvd\n           Polynomial.smult lu u", "using ndvd"], ["proof (prove)\nusing this:\n  \\<not> vb dvd Polynomial.smult lu u\n\ngoal (1 subgoal):\n 1. \\<not> inv_Mp (Mp (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))) dvd\n           Polynomial.smult lu u", "unfolding vb_def"], ["proof (prove)\nusing this:\n  \\<not> inv_Mp (Mp (Polynomial.smult lu (prod_list ws))) dvd\n         Polynomial.smult lu u\n\ngoal (1 subgoal):\n 1. \\<not> inv_Mp (Mp (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))) dvd\n           Polynomial.smult lu u", "by simp"], ["proof (state)\nthis:\n  test_dvd_exec lu u ws'\n\ngoal (1 subgoal):\n 1. ws' = mset ws \\<Longrightarrow> test_dvd u ws'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. test_dvd u ws'", "unfolding test_dvd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v l.\n       v dvd u \\<longrightarrow>\n       0 < degree v \\<longrightarrow>\n       degree v < degree u \\<longrightarrow>\n       Mp v \\<noteq> Mp (Polynomial.smult l (\\<Prod>\\<^sub># ws'))", "proof (intro allI impI notI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "case (1 v l)"], ["proof (state)\nthis:\n  v dvd u\n  0 < degree v\n  degree v < degree u\n  v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "note deg_v = 1(2-3)"], ["proof (state)\nthis:\n  0 < degree v\n  degree v < degree u\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "from 1(1)"], ["proof (chain)\npicking this:\n  v dvd u", "obtain w where u: \"u = v * w\""], ["proof (prove)\nusing this:\n  v dvd u\n\ngoal (1 subgoal):\n 1. (\\<And>w. u = v * w \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. u = v * k\n\ngoal (1 subgoal):\n 1. (\\<And>w. u = v * w \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  u = v * w\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "from u0"], ["proof (chain)\npicking this:\n  u \\<noteq> 0", "have deg: \"degree u = degree v + degree w\""], ["proof (prove)\nusing this:\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree u = degree v + degree w", "unfolding u"], ["proof (prove)\nusing this:\n  v * w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (v * w) = degree v + degree w", "by (subst degree_mult_eq, auto)"], ["proof (state)\nthis:\n  degree u = degree v + degree w\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "define v' where \"v' = smult (lead_coeff w) v\""], ["proof (state)\nthis:\n  v' = Polynomial.smult (lead_coeff w) v\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "define w' where \"w' = smult (lead_coeff v) w\""], ["proof (state)\nthis:\n  w' = Polynomial.smult (lead_coeff v) w\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "let ?ws = \"smult (lead_coeff w * l) (prod_mset ws')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "from arg_cong[OF 1(4), of \"\\<lambda> f. Mp (smult (lead_coeff w) f)\"]"], ["proof (chain)\npicking this:\n  Polynomial.smult (lead_coeff w) (Mp v) =m\n  Polynomial.smult (lead_coeff w)\n   (Mp (Polynomial.smult l (\\<Prod>\\<^sub># ws')))", "have v'_ws': \"Mp v' = Mp ?ws\""], ["proof (prove)\nusing this:\n  Polynomial.smult (lead_coeff w) (Mp v) =m\n  Polynomial.smult (lead_coeff w)\n   (Mp (Polynomial.smult l (\\<Prod>\\<^sub># ws')))\n\ngoal (1 subgoal):\n 1. v' =m Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')", "unfolding v'_def"], ["proof (prove)\nusing this:\n  Polynomial.smult (lead_coeff w) (Mp v) =m\n  Polynomial.smult (lead_coeff w)\n   (Mp (Polynomial.smult l (\\<Prod>\\<^sub># ws')))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (lead_coeff w) v =m\n    Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')", "by simp"], ["proof (state)\nthis:\n  v' =m Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "from lead_coeff_factor[OF u, folded v'_def w'_def]"], ["proof (chain)\npicking this:\n  Polynomial.smult (lead_coeff u) u = v' * w'\n  lead_coeff v' = lead_coeff u\n  lead_coeff w' = lead_coeff u", "have prod: \"?luu = v' * w'\" and lc: \"lead_coeff v' = lu\" and \"lead_coeff w' = lu\""], ["proof (prove)\nusing this:\n  Polynomial.smult (lead_coeff u) u = v' * w'\n  lead_coeff v' = lead_coeff u\n  lead_coeff w' = lead_coeff u\n\ngoal (1 subgoal):\n 1. Polynomial.smult lu u = v' * w' &&&\n    lead_coeff v' = lu &&& lead_coeff w' = lu", "unfolding lu"], ["proof (prove)\nusing this:\n  Polynomial.smult (lead_coeff u) u = v' * w'\n  lead_coeff v' = lead_coeff u\n  lead_coeff w' = lead_coeff u\n\ngoal (1 subgoal):\n 1. Polynomial.smult (lead_coeff u) u = v' * w' &&&\n    lead_coeff v' = lead_coeff u &&& lead_coeff w' = lead_coeff u", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult lu u = v' * w'\n  lead_coeff v' = lu\n  lead_coeff w' = lu\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "with lu0"], ["proof (chain)\npicking this:\n  lu \\<noteq> 0\n  Polynomial.smult lu u = v' * w'\n  lead_coeff v' = lu\n  lead_coeff w' = lu", "have lc0: \"lead_coeff v \\<noteq> 0\" \"lead_coeff w \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lu \\<noteq> 0\n  Polynomial.smult lu u = v' * w'\n  lead_coeff v' = lu\n  lead_coeff w' = lu\n\ngoal (1 subgoal):\n 1. lead_coeff v \\<noteq> 0 &&& lead_coeff w \\<noteq> 0", "unfolding v'_def w'_def"], ["proof (prove)\nusing this:\n  lu \\<noteq> 0\n  Polynomial.smult lu u =\n  Polynomial.smult (lead_coeff w) v * Polynomial.smult (lead_coeff v) w\n  lead_coeff (Polynomial.smult (lead_coeff w) v) = lu\n  lead_coeff (Polynomial.smult (lead_coeff v) w) = lu\n\ngoal (1 subgoal):\n 1. lead_coeff v \\<noteq> 0 &&& lead_coeff w \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lead_coeff v \\<noteq> 0\n  lead_coeff w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "from deg_v"], ["proof (chain)\npicking this:\n  0 < degree v\n  degree v < degree u", "have deg_w: \"0 < degree w\" \"degree w < degree u\""], ["proof (prove)\nusing this:\n  0 < degree v\n  degree v < degree u\n\ngoal (1 subgoal):\n 1. 0 < degree w &&& degree w < degree u", "unfolding deg"], ["proof (prove)\nusing this:\n  0 < degree v\n  degree v < degree v + degree w\n\ngoal (1 subgoal):\n 1. 0 < degree w &&& degree w < degree v + degree w", "by auto"], ["proof (state)\nthis:\n  0 < degree w\n  degree w < degree u\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "from deg_v deg_w lc0"], ["proof (chain)\npicking this:\n  0 < degree v\n  degree v < degree u\n  0 < degree w\n  degree w < degree u\n  lead_coeff v \\<noteq> 0\n  lead_coeff w \\<noteq> 0", "have deg: \"0 < degree v'\" \"degree v' < degree u\" \"0 < degree w'\" \"degree w' < degree u\""], ["proof (prove)\nusing this:\n  0 < degree v\n  degree v < degree u\n  0 < degree w\n  degree w < degree u\n  lead_coeff v \\<noteq> 0\n  lead_coeff w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 < degree v' &&& degree v' < degree u) &&&\n    0 < degree w' &&& degree w' < degree u", "unfolding v'_def w'_def"], ["proof (prove)\nusing this:\n  0 < degree v\n  degree v < degree u\n  0 < degree w\n  degree w < degree u\n  lead_coeff v \\<noteq> 0\n  lead_coeff w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 < degree (Polynomial.smult (lead_coeff w) v) &&&\n     degree (Polynomial.smult (lead_coeff w) v) < degree u) &&&\n    0 < degree (Polynomial.smult (lead_coeff v) w) &&&\n    degree (Polynomial.smult (lead_coeff v) w) < degree u", "by auto"], ["proof (state)\nthis:\n  0 < degree v'\n  degree v' < degree u\n  0 < degree w'\n  degree w' < degree u\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "from prod"], ["proof (chain)\npicking this:\n  Polynomial.smult lu u = v' * w'", "have v_dvd: \"v' dvd ?luu\""], ["proof (prove)\nusing this:\n  Polynomial.smult lu u = v' * w'\n\ngoal (1 subgoal):\n 1. v' dvd Polynomial.smult lu u", "by auto"], ["proof (state)\nthis:\n  v' dvd Polynomial.smult lu u\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "with test[unfolded test_dvd_exec_def]"], ["proof (chain)\npicking this:\n  \\<not> inv_Mp (Mp (Polynomial.smult lu (\\<Prod>\\<^sub># ws'))) dvd\n         Polynomial.smult lu u\n  v' dvd Polynomial.smult lu u", "have neq: \"v' \\<noteq> inv_Mp (Mp (smult lu (prod_mset ws')))\""], ["proof (prove)\nusing this:\n  \\<not> inv_Mp (Mp (Polynomial.smult lu (\\<Prod>\\<^sub># ws'))) dvd\n         Polynomial.smult lu u\n  v' dvd Polynomial.smult lu u\n\ngoal (1 subgoal):\n 1. v' \\<noteq> inv_Mp (Mp (Polynomial.smult lu (\\<Prod>\\<^sub># ws')))", "by auto"], ["proof (state)\nthis:\n  v' \\<noteq> inv_Mp (Mp (Polynomial.smult lu (\\<Prod>\\<^sub># ws')))\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "have deg_m_v': \"degree_m v' = degree v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m v' = degree v'", "by (rule degree_m_eq[OF _ m1], unfold lc m, \n                insert cop prime n coprime_exp_mod, auto)"], ["proof (state)\nthis:\n  degree_m v' = degree v'\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "with v'_ws'"], ["proof (chain)\npicking this:\n  v' =m Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')\n  degree_m v' = degree v'", "have \"degree v' = degree_m ?ws\""], ["proof (prove)\nusing this:\n  v' =m Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')\n  degree_m v' = degree v'\n\ngoal (1 subgoal):\n 1. degree v' =\n    degree_m (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws'))", "by simp"], ["proof (state)\nthis:\n  degree v' =\n  degree_m (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws'))\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree v' =\n  degree_m (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws'))\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> \\<le> degree_m (prod_mset ws')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws'))\n    \\<le> degree_m (\\<Prod>\\<^sub># ws')", "by (rule degree_m_smult_le)"], ["proof (state)\nthis:\n  degree_m (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws'))\n  \\<le> degree_m (\\<Prod>\\<^sub># ws')\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree_m (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws'))\n  \\<le> degree_m (\\<Prod>\\<^sub># ws')\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> = degree_m (prod_list ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m (\\<Prod>\\<^sub># ws') = degree_m (prod_list ws)", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m (\\<Prod>\\<^sub># (mset ws)) = degree_m (prod_list ws)", "by simp"], ["proof (state)\nthis:\n  degree_m (\\<Prod>\\<^sub># ws') = degree_m (prod_list ws)\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree_m (\\<Prod>\\<^sub># ws') = degree_m (prod_list ws)\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> \\<le> degree (prod_list ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m (prod_list ws) \\<le> degree (prod_list ws)", "by (rule degree_m_le)"], ["proof (state)\nthis:\n  degree_m (prod_list ws) \\<le> degree (prod_list ws)\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree_m (prod_list ws) \\<le> degree (prod_list ws)\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> \\<le> degree_bound vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod_list ws) \\<le> degree_bound vs", "using ws_vs(1) ws(2) dr[unfolded r] degree_bound"], ["proof (prove)\nusing this:\n  mset ws \\<subseteq># mset vs\n  length ws = d\n  d + d \\<le> length vs\n  \\<lbrakk>mset ?ws \\<subseteq># mset ?vs;\n   length ?ws + length ?ws \\<le> length ?vs\\<rbrakk>\n  \\<Longrightarrow> degree (prod_list ?ws) \\<le> degree_bound ?vs\n\ngoal (1 subgoal):\n 1. degree (prod_list ws) \\<le> degree_bound vs", "by auto"], ["proof (state)\nthis:\n  degree (prod_list ws) \\<le> degree_bound vs\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  degree v' \\<le> degree_bound vs", "have \"degree v' \\<le> degree_bound vs\""], ["proof (prove)\nusing this:\n  degree v' \\<le> degree_bound vs\n\ngoal (1 subgoal):\n 1. degree v' \\<le> degree_bound vs", "."], ["proof (state)\nthis:\n  degree v' \\<le> degree_bound vs\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "from inv_Mp_rev[OF large[unfolded large_m_def, rule_format, OF v_dvd this]]"], ["proof (chain)\npicking this:\n  inv_Mp (Mp v') = v'", "have inv: \"inv_Mp (Mp v') = v'\""], ["proof (prove)\nusing this:\n  inv_Mp (Mp v') = v'\n\ngoal (1 subgoal):\n 1. inv_Mp (Mp v') = v'", "by simp"], ["proof (state)\nthis:\n  inv_Mp (Mp v') = v'\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "from arg_cong[OF v'_ws', of inv_Mp, unfolded inv]"], ["proof (chain)\npicking this:\n  v' =\n  inv_Mp (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))", "have v': \"v' = inv_Mp (Mp ?ws)\""], ["proof (prove)\nusing this:\n  v' =\n  inv_Mp (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))\n\ngoal (1 subgoal):\n 1. v' =\n    inv_Mp (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))", "by auto"], ["proof (state)\nthis:\n  v' =\n  inv_Mp (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "have deg_ws: \"degree_m ?ws = degree ?ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')) =\n    degree (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws'))", "proof (rule degree_m_eq[OF _ m1], \n                unfold lead_coeff_smult True l_ws, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. lead_coeff w * l * 1 mod m = 0 \\<Longrightarrow> False", "assume \"lead_coeff w * l * 1 mod m = 0\""], ["proof (state)\nthis:\n  lead_coeff w * l * 1 mod m = 0\n\ngoal (1 subgoal):\n 1. lead_coeff w * l * 1 mod m = 0 \\<Longrightarrow> False", "hence 0: \"M (lead_coeff w * l) = 0\""], ["proof (prove)\nusing this:\n  lead_coeff w * l * 1 mod m = 0\n\ngoal (1 subgoal):\n 1. M (lead_coeff w * l) = 0", "unfolding M_def"], ["proof (prove)\nusing this:\n  lead_coeff w * l * 1 mod m = 0\n\ngoal (1 subgoal):\n 1. lead_coeff w * l mod m = 0", "by simp"], ["proof (state)\nthis:\n  M (lead_coeff w * l) = 0\n\ngoal (1 subgoal):\n 1. lead_coeff w * l * 1 mod m = 0 \\<Longrightarrow> False", "have \"Mp ?ws = Mp (smult (M (lead_coeff w * l)) (prod_mset ws'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws') =m\n    Polynomial.smult (M (lead_coeff w * l)) (\\<Prod>\\<^sub># ws')", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws') =m\n  Polynomial.smult (M (lead_coeff w * l)) (\\<Prod>\\<^sub># ws')\n\ngoal (1 subgoal):\n 1. lead_coeff w * l * 1 mod m = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws') =m\n  Polynomial.smult (M (lead_coeff w * l)) (\\<Prod>\\<^sub># ws')\n\ngoal (1 subgoal):\n 1. lead_coeff w * l * 1 mod m = 0 \\<Longrightarrow> False", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (Polynomial.smult (M (lead_coeff w * l)) (\\<Prod>\\<^sub># ws')) = 0", "unfolding 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (Polynomial.smult 0 (\\<Prod>\\<^sub># ws')) = 0", "by simp"], ["proof (state)\nthis:\n  Mp (Polynomial.smult (M (lead_coeff w * l)) (\\<Prod>\\<^sub># ws')) = 0\n\ngoal (1 subgoal):\n 1. lead_coeff w * l * 1 mod m = 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')) = 0", "have \"Mp ?ws = 0\""], ["proof (prove)\nusing this:\n  Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')) = 0\n\ngoal (1 subgoal):\n 1. Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')) = 0", "by simp"], ["proof (state)\nthis:\n  Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')) = 0\n\ngoal (1 subgoal):\n 1. lead_coeff w * l * 1 mod m = 0 \\<Longrightarrow> False", "hence \"v' = 0\""], ["proof (prove)\nusing this:\n  Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')) = 0\n\ngoal (1 subgoal):\n 1. v' = 0", "unfolding v'"], ["proof (prove)\nusing this:\n  Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')) = 0\n\ngoal (1 subgoal):\n 1. inv_Mp\n     (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws'))) =\n    0", "by (simp add: inv_Mp_def)"], ["proof (state)\nthis:\n  v' = 0\n\ngoal (1 subgoal):\n 1. lead_coeff w * l * 1 mod m = 0 \\<Longrightarrow> False", "with deg"], ["proof (chain)\npicking this:\n  0 < degree v'\n  degree v' < degree u\n  0 < degree w'\n  degree w' < degree u\n  v' = 0", "show False"], ["proof (prove)\nusing this:\n  0 < degree v'\n  degree v' < degree u\n  0 < degree w'\n  degree w' < degree u\n  v' = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree_m (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')) =\n  degree (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws'))\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "from arg_cong[OF v', of \"\\<lambda> f. lead_coeff (Mp f)\", simplified]"], ["proof (chain)\npicking this:\n  lead_coeff (Mp v') =\n  lead_coeff\n   (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))", "have \"M lu = M (lead_coeff v')\""], ["proof (prove)\nusing this:\n  lead_coeff (Mp v') =\n  lead_coeff\n   (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))\n\ngoal (1 subgoal):\n 1. M lu = M (lead_coeff v')", "using lc"], ["proof (prove)\nusing this:\n  lead_coeff (Mp v') =\n  lead_coeff\n   (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))\n  lead_coeff v' = lu\n\ngoal (1 subgoal):\n 1. M lu = M (lead_coeff v')", "by simp"], ["proof (state)\nthis:\n  M lu = M (lead_coeff v')\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  M lu = M (lead_coeff v')\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> = lead_coeff (Mp v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (lead_coeff v') = lead_coeff (Mp v')", "by (rule degree_m_eq_lead_coeff[OF deg_m_v', symmetric])"], ["proof (state)\nthis:\n  M (lead_coeff v') = lead_coeff (Mp v')\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  M (lead_coeff v') = lead_coeff (Mp v')\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> = lead_coeff (Mp ?ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (Mp v') =\n    lead_coeff\n     (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))", "using arg_cong[OF v', of \"\\<lambda> f. lead_coeff (Mp f)\"]"], ["proof (prove)\nusing this:\n  lead_coeff (Mp v') =\n  lead_coeff\n   (Mp (inv_Mp\n         (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))))\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp v') =\n    lead_coeff\n     (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))", "by simp"], ["proof (state)\nthis:\n  lead_coeff (Mp v') =\n  lead_coeff\n   (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lead_coeff (Mp v') =\n  lead_coeff\n   (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> = M (lead_coeff ?ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff\n     (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws'))) =\n    M (lead_coeff\n        (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))", "by (rule degree_m_eq_lead_coeff[OF deg_ws])"], ["proof (state)\nthis:\n  lead_coeff\n   (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws'))) =\n  M (lead_coeff (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lead_coeff\n   (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws'))) =\n  M (lead_coeff (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> = M (lead_coeff w * l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (lead_coeff\n        (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws'))) =\n    M (lead_coeff w * l)", "unfolding lead_coeff_smult True l_ws"], ["proof (prove)\ngoal (1 subgoal):\n 1. M (lead_coeff w * l * 1) = M (lead_coeff w * l)", "by simp"], ["proof (state)\nthis:\n  M (lead_coeff\n      (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws'))) =\n  M (lead_coeff w * l)\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  M lu = M (lead_coeff w * l)", "have id: \"M lu = M (lead_coeff w * l)\""], ["proof (prove)\nusing this:\n  M lu = M (lead_coeff w * l)\n\ngoal (1 subgoal):\n 1. M lu = M (lead_coeff w * l)", "."], ["proof (state)\nthis:\n  M lu = M (lead_coeff w * l)\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "note v'"], ["proof (state)\nthis:\n  v' =\n  inv_Mp (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  v' =\n  inv_Mp (Mp (Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws')))\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "have \"Mp ?ws = Mp (smult (M (lead_coeff w * l)) (prod_mset ws'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws') =m\n    Polynomial.smult (M (lead_coeff w * l)) (\\<Prod>\\<^sub># ws')", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws') =m\n  Polynomial.smult (M (lead_coeff w * l)) (\\<Prod>\\<^sub># ws')\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Polynomial.smult (lead_coeff w * l) (\\<Prod>\\<^sub># ws') =m\n  Polynomial.smult (M (lead_coeff w * l)) (\\<Prod>\\<^sub># ws')\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> = Mp (smult lu (prod_mset ws'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (M (lead_coeff w * l)) (\\<Prod>\\<^sub># ws') =m\n    Polynomial.smult lu (\\<Prod>\\<^sub># ws')", "unfolding id[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (M lu) (\\<Prod>\\<^sub># ws') =m\n    Polynomial.smult lu (\\<Prod>\\<^sub># ws')", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult (M (lead_coeff w * l)) (\\<Prod>\\<^sub># ws') =m\n  Polynomial.smult lu (\\<Prod>\\<^sub># ws')\n\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>v dvd u; 0 < degree v; degree v < degree u;\n        v =m Polynomial.smult l (\\<Prod>\\<^sub># ws')\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  v' = inv_Mp (Mp (Polynomial.smult lu (\\<Prod>\\<^sub># ws')))", "show False"], ["proof (prove)\nusing this:\n  v' = inv_Mp (Mp (Polynomial.smult lu (\\<Prod>\\<^sub># ws')))\n\ngoal (1 subgoal):\n 1. False", "using neq"], ["proof (prove)\nusing this:\n  v' = inv_Mp (Mp (Polynomial.smult lu (\\<Prod>\\<^sub># ws')))\n  v' \\<noteq> inv_Mp (Mp (Polynomial.smult lu (\\<Prod>\\<^sub># ws')))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  test_dvd u ws'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  test_dvd u ws'\n\ngoal (4 subgoals):\n 1. d = 0 \\<Longrightarrow> cds = []\n 2. \\<And>x. x \\<in> set vs \\<Longrightarrow> x \\<in> set vs\n 3. \\<And>x. x \\<in> set res \\<Longrightarrow> x \\<in> set res\n 4. cds \\<noteq> [] \\<Longrightarrow> d < r", "qed (insert d0 Cons cands_empty, auto)"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "case True"], ["proof (state)\nthis:\n  inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n  vb dvd Polynomial.smult lu u\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "define pp_vb where \"pp_vb \\<equiv> primitive_part vb\""], ["proof (state)\nthis:\n  pp_vb \\<equiv> primitive_part vb\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "define u' where \"u' \\<equiv> u div pp_vb\""], ["proof (state)\nthis:\n  u' \\<equiv> u div pp_vb\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "define lu' where \"lu' \\<equiv> lead_coeff u'\""], ["proof (state)\nthis:\n  lu' \\<equiv> lead_coeff u'\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "let ?luu' = \"smult lu' u'\""], ["proof (state)\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "define vs' where \"vs' \\<equiv> fold remove1 ws vs\""], ["proof (state)\nthis:\n  vs' \\<equiv> fold remove1 ws vs\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "obtain state' cands' where slc: \"subseqs_foldr sl_impl (lu',[]) vs' d = (cands', state')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cands' state'.\n        subseqs_foldr sl_impl (lu', []) vs' d =\n        (cands', state') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  subseqs_foldr sl_impl (lu', []) vs' d = (cands', state')\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from subseqs_foldr[OF slc]"], ["proof (chain)\npicking this:\n  sli (lu', []) vs' d state' \\<and> set cands' = S (lu', []) vs' d", "have state': \"sli (lu',[]) vs' d state'\"\n          and cands': \"set cands' = S (lu',[]) vs' d\""], ["proof (prove)\nusing this:\n  sli (lu', []) vs' d state' \\<and> set cands' = S (lu', []) vs' d\n\ngoal (1 subgoal):\n 1. sli (lu', []) vs' d state' &&& set cands' = S (lu', []) vs' d", "by auto"], ["proof (state)\nthis:\n  sli (lu', []) vs' d state'\n  set cands' = S (lu', []) vs' d\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "let ?res' = \"pp_vb # res\""], ["proof (state)\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "let ?r' = \"r - length ws\""], ["proof (state)\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "note defs = vb_def pp_vb_def u'_def lu'_def vs'_def slc"], ["proof (state)\nthis:\n  vb \\<equiv> inv_Mp (Mp (Polynomial.smult lu (prod_list ws)))\n  pp_vb \\<equiv> primitive_part vb\n  u' \\<equiv> u div pp_vb\n  lu' \\<equiv> lead_coeff u'\n  vs' \\<equiv> fold remove1 ws vs\n  subseqs_foldr sl_impl (lu', []) vs' d = (cands', state')\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from fold_remove1_mset[OF subseqs_sub_mset[OF ws(1)]]"], ["proof (chain)\npicking this:\n  mset (fold remove1 ws vs) + mset ws = mset vs", "have vs_split: \"mset vs = mset vs' + mset ws\""], ["proof (prove)\nusing this:\n  mset (fold remove1 ws vs) + mset ws = mset vs\n\ngoal (1 subgoal):\n 1. mset vs = mset vs' + mset ws", "unfolding vs'_def"], ["proof (prove)\nusing this:\n  mset (fold remove1 ws vs) + mset ws = mset vs\n\ngoal (1 subgoal):\n 1. mset vs = mset (fold remove1 ws vs) + mset ws", "by auto"], ["proof (state)\nthis:\n  mset vs = mset vs' + mset ws\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "hence vs'_diff: \"mset vs' = mset vs - mset ws\" and ws_sub: \"mset ws \\<subseteq># mset vs\""], ["proof (prove)\nusing this:\n  mset vs = mset vs' + mset ws\n\ngoal (1 subgoal):\n 1. mset vs' = mset vs - mset ws &&& mset ws \\<subseteq># mset vs", "by auto"], ["proof (state)\nthis:\n  mset vs' = mset vs - mset ws\n  mset ws \\<subseteq># mset vs\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from arg_cong[OF vs_split, of size]"], ["proof (chain)\npicking this:\n  size (mset vs) = size (mset vs' + mset ws)", "have r': \"?r' = length vs'\""], ["proof (prove)\nusing this:\n  size (mset vs) = size (mset vs' + mset ws)\n\ngoal (1 subgoal):\n 1. r - length ws = length vs'", "unfolding defs r"], ["proof (prove)\nusing this:\n  size (mset vs) = size (mset (fold remove1 ws vs) + mset ws)\n\ngoal (1 subgoal):\n 1. length vs - length ws = length (fold remove1 ws vs)", "by simp"], ["proof (state)\nthis:\n  r - length ws = length vs'\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from arg_cong[OF vs_split, of prod_mset]"], ["proof (chain)\npicking this:\n  \\<Prod>\\<^sub># (mset vs) = \\<Prod>\\<^sub># (mset vs' + mset ws)", "have prod_vs: \"prod_list vs = prod_list vs' * prod_list ws\""], ["proof (prove)\nusing this:\n  \\<Prod>\\<^sub># (mset vs) = \\<Prod>\\<^sub># (mset vs' + mset ws)\n\ngoal (1 subgoal):\n 1. prod_list vs = prod_list vs' * prod_list ws", "by simp"], ["proof (state)\nthis:\n  prod_list vs = prod_list vs' * prod_list ws\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from arg_cong[OF vs_split, of set_mset]"], ["proof (chain)\npicking this:\n  set_mset (mset vs) = set_mset (mset vs' + mset ws)", "have set_vs: \"set vs = set vs' \\<union> set ws\""], ["proof (prove)\nusing this:\n  set_mset (mset vs) = set_mset (mset vs' + mset ws)\n\ngoal (1 subgoal):\n 1. set vs = set vs' \\<union> set ws", "by auto"], ["proof (state)\nthis:\n  set vs = set vs' \\<union> set ws\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "note inv = inverse_mod_coprime_exp[OF m prime n]"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime ?x p \\<Longrightarrow>\n  M (inverse_mod ?x m * ?x) = 1\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "note p_inv = p.inverse_mod_coprime[OF prime]"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime ?x p \\<Longrightarrow>\n  p.M (inverse_mod ?x p * ?x) = 1\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from True res slc"], ["proof (chain)\npicking this:\n  inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n  vb dvd Polynomial.smult lu u\n  (let lv = inv_M2 m2 lv'\n   in if lv dvd coeff (Polynomial.smult lu u) 0\n      then let vb = inv_Mp2 m2 (Mp (Polynomial.smult lu (prod_list_m ws)))\n           in if vb dvd Polynomial.smult lu u\n              then let pp_vb = primitive_part vb; u' = u div pp_vb;\n                       r' = r - length ws; res' = pp_vb # res\n                   in if r' < d + d then u' # res'\n                      else let lu' = lead_coeff u';\n                               vs' = fold remove1 ws vs;\n                               (cands'', state') =\n                                 subseqs_foldr sl_impl (lu', []) vs' d\n                           in reconstruction sl_impl m2 state' u'\n                               (Polynomial.smult lu' u') lu' d r' vs' res'\n                               cands''\n              else reconstruction sl_impl m2 state u (Polynomial.smult lu u)\n                    lu d r vs res cds\n      else reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r\n            vs res cds) =\n  fs\n  subseqs_foldr sl_impl (lu', []) vs' d = (cands', state')", "have res: \"(if ?r' < d + d then u' # ?res' else reconstruction sl_impl m2 state'\n          u' ?luu' lu' d ?r' vs' ?res' cands') = fs\""], ["proof (prove)\nusing this:\n  inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n  vb dvd Polynomial.smult lu u\n  (let lv = inv_M2 m2 lv'\n   in if lv dvd coeff (Polynomial.smult lu u) 0\n      then let vb = inv_Mp2 m2 (Mp (Polynomial.smult lu (prod_list_m ws)))\n           in if vb dvd Polynomial.smult lu u\n              then let pp_vb = primitive_part vb; u' = u div pp_vb;\n                       r' = r - length ws; res' = pp_vb # res\n                   in if r' < d + d then u' # res'\n                      else let lu' = lead_coeff u';\n                               vs' = fold remove1 ws vs;\n                               (cands'', state') =\n                                 subseqs_foldr sl_impl (lu', []) vs' d\n                           in reconstruction sl_impl m2 state' u'\n                               (Polynomial.smult lu' u') lu' d r' vs' res'\n                               cands''\n              else reconstruction sl_impl m2 state u (Polynomial.smult lu u)\n                    lu d r vs res cds\n      else reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r\n            vs res cds) =\n  fs\n  subseqs_foldr sl_impl (lu', []) vs' d = (cands', state')\n\ngoal (1 subgoal):\n 1. (if r - length ws < d + d then u' # pp_vb # res\n     else reconstruction sl_impl m2 state' u' (Polynomial.smult lu' u') lu'\n           d (r - length ws) vs' (pp_vb # res) cands') =\n    fs", "unfolding Let_def defs"], ["proof (prove)\nusing this:\n  inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n  inv_Mp (Mp (Polynomial.smult lu (prod_list ws))) dvd Polynomial.smult lu u\n  (if inv_M2 m2 lv' dvd coeff (Polynomial.smult lu u) 0\n   then if inv_Mp2 m2 (Mp (Polynomial.smult lu (prod_list_m ws))) dvd\n           Polynomial.smult lu u\n        then if r - length ws < d + d\n             then u div\n                  primitive_part\n                   (inv_Mp2 m2\n                     (Mp (Polynomial.smult lu (prod_list_m ws)))) #\n                  primitive_part\n                   (inv_Mp2 m2\n                     (Mp (Polynomial.smult lu (prod_list_m ws)))) #\n                  res\n             else case subseqs_foldr sl_impl\n                        (lead_coeff\n                          (u div\n                           primitive_part\n                            (inv_Mp2 m2\n                              (Mp (Polynomial.smult lu (prod_list_m ws))))),\n                         [])\n                        (fold remove1 ws vs) d of\n                  (cands'', state') \\<Rightarrow>\n                    reconstruction sl_impl m2 state'\n                     (u div\n                      primitive_part\n                       (inv_Mp2 m2\n                         (Mp (Polynomial.smult lu (prod_list_m ws)))))\n                     (Polynomial.smult\n                       (lead_coeff\n                         (u div\n                          primitive_part\n                           (inv_Mp2 m2\n                             (Mp (Polynomial.smult lu (prod_list_m ws))))))\n                       (u div\n                        primitive_part\n                         (inv_Mp2 m2\n                           (Mp (Polynomial.smult lu (prod_list_m ws))))))\n                     (lead_coeff\n                       (u div\n                        primitive_part\n                         (inv_Mp2 m2\n                           (Mp (Polynomial.smult lu (prod_list_m ws))))))\n                     d (r - length ws) (fold remove1 ws vs)\n                     (primitive_part\n                       (inv_Mp2 m2\n                         (Mp (Polynomial.smult lu (prod_list_m ws)))) #\n                      res)\n                     cands''\n        else reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d\n              r vs res cds\n   else reconstruction sl_impl m2 state u (Polynomial.smult lu u) lu d r vs\n         res cds) =\n  fs\n  subseqs_foldr sl_impl\n   (lead_coeff\n     (u div\n      primitive_part (inv_Mp (Mp (Polynomial.smult lu (prod_list ws))))),\n    [])\n   (fold remove1 ws vs) d =\n  (cands', state')\n\ngoal (1 subgoal):\n 1. (if r - length ws < d + d\n     then u div\n          primitive_part\n           (inv_Mp (Mp (Polynomial.smult lu (prod_list ws)))) #\n          primitive_part\n           (inv_Mp (Mp (Polynomial.smult lu (prod_list ws)))) #\n          res\n     else reconstruction sl_impl m2 state'\n           (u div\n            primitive_part\n             (inv_Mp (Mp (Polynomial.smult lu (prod_list ws)))))\n           (Polynomial.smult\n             (lead_coeff\n               (u div\n                primitive_part\n                 (inv_Mp (Mp (Polynomial.smult lu (prod_list ws))))))\n             (u div\n              primitive_part\n               (inv_Mp (Mp (Polynomial.smult lu (prod_list ws))))))\n           (lead_coeff\n             (u div\n              primitive_part\n               (inv_Mp (Mp (Polynomial.smult lu (prod_list ws))))))\n           d (r - length ws) (fold remove1 ws vs)\n           (primitive_part\n             (inv_Mp (Mp (Polynomial.smult lu (prod_list ws)))) #\n            res)\n           cands') =\n    fs", "by auto"], ["proof (state)\nthis:\n  (if r - length ws < d + d then u' # pp_vb # res\n   else reconstruction sl_impl m2 state' u' (Polynomial.smult lu' u') lu' d\n         (r - length ws) vs' (pp_vb # res) cands') =\n  fs\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from True"], ["proof (chain)\npicking this:\n  inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n  vb dvd Polynomial.smult lu u", "have dvd: \"vb dvd ?luu\""], ["proof (prove)\nusing this:\n  inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n  vb dvd Polynomial.smult lu u\n\ngoal (1 subgoal):\n 1. vb dvd Polynomial.smult lu u", "by simp"], ["proof (state)\nthis:\n  vb dvd Polynomial.smult lu u\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from dvd_smult_int[OF lu0 this]"], ["proof (chain)\npicking this:\n  primitive_part vb dvd u", "have ppu: \"pp_vb dvd u\""], ["proof (prove)\nusing this:\n  primitive_part vb dvd u\n\ngoal (1 subgoal):\n 1. pp_vb dvd u", "unfolding defs"], ["proof (prove)\nusing this:\n  primitive_part (inv_Mp (Mp (Polynomial.smult lu (prod_list ws)))) dvd u\n\ngoal (1 subgoal):\n 1. primitive_part (inv_Mp (Mp (Polynomial.smult lu (prod_list ws)))) dvd u", "by simp"], ["proof (state)\nthis:\n  pp_vb dvd u\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "hence u: \"u = pp_vb * u'\""], ["proof (prove)\nusing this:\n  pp_vb dvd u\n\ngoal (1 subgoal):\n 1. u = pp_vb * u'", "unfolding u'_def"], ["proof (prove)\nusing this:\n  pp_vb dvd u\n\ngoal (1 subgoal):\n 1. u = pp_vb * (u div pp_vb)", "by (metis dvdE mult_eq_0_iff nonzero_mult_div_cancel_left)"], ["proof (state)\nthis:\n  u = pp_vb * u'\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "hence uu': \"u' dvd u\""], ["proof (prove)\nusing this:\n  u = pp_vb * u'\n\ngoal (1 subgoal):\n 1. u' dvd u", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  u = pp_vb * u'\n\ngoal (1 subgoal):\n 1. \\<exists>k. u = u' * k", "by auto"], ["proof (state)\nthis:\n  u' dvd u\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have f: \"f = u' * prod_list ?res'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = u' * prod_list (pp_vb # res)", "using f u"], ["proof (prove)\nusing this:\n  f = u * prod_list res\n  u = pp_vb * u'\n\ngoal (1 subgoal):\n 1. f = u' * prod_list (pp_vb # res)", "by auto"], ["proof (state)\nthis:\n  f = u' * prod_list (pp_vb # res)\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "let ?fact = \"smult lu (prod_mset (mset ws))\""], ["proof (state)\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have Mp_vb: \"Mp vb = Mp (smult lu (prod_list ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vb =m Polynomial.smult lu (prod_list ws)", "unfolding vb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_Mp (Mp (Polynomial.smult lu (prod_list ws))) =m\n    Polynomial.smult lu (prod_list ws)", "by simp"], ["proof (state)\nthis:\n  vb =m Polynomial.smult lu (prod_list ws)\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have pp_vb_vb: \"smult (content vb) pp_vb = vb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (content vb) pp_vb = vb", "unfolding pp_vb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (content vb) (primitive_part vb) = vb", "by (rule content_times_primitive_part)"], ["proof (state)\nthis:\n  Polynomial.smult (content vb) pp_vb = vb\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "{"], ["proof (state)\nthis:\n  Polynomial.smult (content vb) pp_vb = vb\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have \"smult (content vb) u = (smult (content vb) pp_vb) * u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (content vb) u =\n    Polynomial.smult (content vb) pp_vb * u'", "unfolding u"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (content vb) (pp_vb * u') =\n    Polynomial.smult (content vb) pp_vb * u'", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult (content vb) u = Polynomial.smult (content vb) pp_vb * u'\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "also"], ["proof (state)\nthis:\n  Polynomial.smult (content vb) u = Polynomial.smult (content vb) pp_vb * u'\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have \"smult (content vb) pp_vb = vb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (content vb) pp_vb = vb", "by fact"], ["proof (state)\nthis:\n  Polynomial.smult (content vb) pp_vb = vb\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "finally"], ["proof (chain)\npicking this:\n  Polynomial.smult (content vb) u = vb * u'", "have \"smult (content vb) u = vb * u'\""], ["proof (prove)\nusing this:\n  Polynomial.smult (content vb) u = vb * u'\n\ngoal (1 subgoal):\n 1. Polynomial.smult (content vb) u = vb * u'", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult (content vb) u = vb * u'\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from arg_cong[OF this, of Mp]"], ["proof (chain)\npicking this:\n  Polynomial.smult (content vb) u =m vb * u'", "have \"Mp (Mp vb * u') = Mp (smult (content vb) u)\""], ["proof (prove)\nusing this:\n  Polynomial.smult (content vb) u =m vb * u'\n\ngoal (1 subgoal):\n 1. Mp vb * u' =m Polynomial.smult (content vb) u", "by simp"], ["proof (state)\nthis:\n  Mp vb * u' =m Polynomial.smult (content vb) u\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "hence \"Mp (smult (content vb) u) = Mp (?fact * u')\""], ["proof (prove)\nusing this:\n  Mp vb * u' =m Polynomial.smult (content vb) u\n\ngoal (1 subgoal):\n 1. Polynomial.smult (content vb) u =m\n    Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u'", "unfolding Mp_vb"], ["proof (prove)\nusing this:\n  Mp (Polynomial.smult lu (prod_list ws)) * u' =m\n  Polynomial.smult (content vb) u\n\ngoal (1 subgoal):\n 1. Polynomial.smult (content vb) u =m\n    Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u'", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult (content vb) u =m\n  Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u'\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "}"], ["proof (state)\nthis:\n  Polynomial.smult (content vb) u =m\n  Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u'\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "note prod = this"], ["proof (state)\nthis:\n  Polynomial.smult (content vb) u =m\n  Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u'\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from arg_cong[OF this, of p.Mp]"], ["proof (chain)\npicking this:\n  p.eq_m (Mp (Polynomial.smult (content vb) u))\n   (Mp (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u'))", "have prod': \"p.Mp (smult (content vb) u) = p.Mp (?fact * u')\""], ["proof (prove)\nusing this:\n  p.eq_m (Mp (Polynomial.smult (content vb) u))\n   (Mp (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u'))\n\ngoal (1 subgoal):\n 1. p.eq_m (Polynomial.smult (content vb) u)\n     (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u')", "by simp"], ["proof (state)\nthis:\n  p.eq_m (Polynomial.smult (content vb) u)\n   (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u')\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from dvd"], ["proof (chain)\npicking this:\n  vb dvd Polynomial.smult lu u", "have \"lead_coeff vb dvd lead_coeff (smult lu u)\""], ["proof (prove)\nusing this:\n  vb dvd Polynomial.smult lu u\n\ngoal (1 subgoal):\n 1. lead_coeff vb dvd lead_coeff (Polynomial.smult lu u)", "by (metis dvd_def lead_coeff_mult)"], ["proof (state)\nthis:\n  lead_coeff vb dvd lead_coeff (Polynomial.smult lu u)\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "hence ldvd: \"lead_coeff vb dvd lu * lu\""], ["proof (prove)\nusing this:\n  lead_coeff vb dvd lead_coeff (Polynomial.smult lu u)\n\ngoal (1 subgoal):\n 1. lead_coeff vb dvd lu * lu", "unfolding lead_coeff_smult lu"], ["proof (prove)\nusing this:\n  lead_coeff vb dvd lead_coeff u * lead_coeff u\n\ngoal (1 subgoal):\n 1. lead_coeff vb dvd lead_coeff u * lead_coeff u", "by simp"], ["proof (state)\nthis:\n  lead_coeff vb dvd lu * lu\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from cop"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime lu p", "have cop_lu: \"coprime (lu * lu) p\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime lu p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lu * lu) p", "by simp"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lu * lu) p\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from coprime_divisors [OF ldvd dvd_refl] cop_lu"], ["proof (chain)\npicking this:\n  algebraic_semidom_class.coprime (lu * lu) ?b \\<Longrightarrow>\n  algebraic_semidom_class.coprime (lead_coeff vb) ?b\n  comm_monoid_mult_class.coprime (lu * lu) p", "have cop_lvb: \"coprime (lead_coeff vb) p\""], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime (lu * lu) ?b \\<Longrightarrow>\n  algebraic_semidom_class.coprime (lead_coeff vb) ?b\n  comm_monoid_mult_class.coprime (lu * lu) p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff vb) p", "by simp"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff vb) p\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "then"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime (lead_coeff vb) p", "have cop_vb: \"coprime (content vb) p\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lead_coeff vb) p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (content vb) p", "by (auto intro: coprime_divisors[OF content_dvd_coeff dvd_refl])"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (content vb) p\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from u"], ["proof (chain)\npicking this:\n  u = pp_vb * u'", "have \"u' dvd u\""], ["proof (prove)\nusing this:\n  u = pp_vb * u'\n\ngoal (1 subgoal):\n 1. u' dvd u", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  u = pp_vb * u'\n\ngoal (1 subgoal):\n 1. \\<exists>k. u = u' * k", "by auto"], ["proof (state)\nthis:\n  u' dvd u\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "hence \"lead_coeff u' dvd lu\""], ["proof (prove)\nusing this:\n  u' dvd u\n\ngoal (1 subgoal):\n 1. lead_coeff u' dvd lu", "unfolding lu"], ["proof (prove)\nusing this:\n  u' dvd u\n\ngoal (1 subgoal):\n 1. lead_coeff u' dvd lead_coeff u", "by (metis dvd_def lead_coeff_mult)"], ["proof (state)\nthis:\n  lead_coeff u' dvd lu\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from coprime_divisors[OF this dvd_refl] cop"], ["proof (chain)\npicking this:\n  algebraic_semidom_class.coprime lu ?b \\<Longrightarrow>\n  algebraic_semidom_class.coprime (lead_coeff u') ?b\n  comm_monoid_mult_class.coprime lu p", "have \"coprime (lead_coeff u') p\""], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime lu ?b \\<Longrightarrow>\n  algebraic_semidom_class.coprime (lead_coeff u') ?b\n  comm_monoid_mult_class.coprime lu p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff u') p", "by simp"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff u') p\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "hence \"coprime (lu * lead_coeff u') p\" and cop_lu': \"coprime lu' p\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lead_coeff u') p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lu * lead_coeff u') p &&&\n    comm_monoid_mult_class.coprime lu' p", "using cop"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lead_coeff u') p\n  comm_monoid_mult_class.coprime lu p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lu * lead_coeff u') p &&&\n    comm_monoid_mult_class.coprime lu' p", "by (auto simp: lu'_def)"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lu * lead_coeff u') p\n  comm_monoid_mult_class.coprime lu' p\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "hence cop': \"coprime (lead_coeff (?fact * u')) p\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lu * lead_coeff u') p\n  comm_monoid_mult_class.coprime lu' p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime\n     (lead_coeff (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u')) p", "unfolding lead_coeff_mult lead_coeff_smult l_ws"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lu * lead_coeff u') p\n  comm_monoid_mult_class.coprime lu' p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lu * 1 * lead_coeff u') p", "by simp"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime\n   (lead_coeff (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u')) p\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have \"p.square_free_m (smult (content vb) u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p.square_free_m (Polynomial.smult (content vb) u)", "using cop_vb sf p_inv"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (content vb) p\n  p.square_free_m u\n  comm_monoid_mult_class.coprime ?x p \\<Longrightarrow>\n  p.M (inverse_mod ?x p * ?x) = 1\n\ngoal (1 subgoal):\n 1. p.square_free_m (Polynomial.smult (content vb) u)", "by (auto intro!: p.square_free_m_smultI)"], ["proof (state)\nthis:\n  p.square_free_m (Polynomial.smult (content vb) u)\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from p.square_free_m_cong[OF this prod']"], ["proof (chain)\npicking this:\n  p.square_free_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u')", "have sf': \"p.square_free_m (?fact * u')\""], ["proof (prove)\nusing this:\n  p.square_free_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u')\n\ngoal (1 subgoal):\n 1. p.square_free_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u')", "by simp"], ["proof (state)\nthis:\n  p.square_free_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u')\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from p.square_free_m_factor[OF this]"], ["proof (chain)\npicking this:\n  p.square_free_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n  p.square_free_m u'", "have sf_u': \"p.square_free_m u'\""], ["proof (prove)\nusing this:\n  p.square_free_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n  p.square_free_m u'\n\ngoal (1 subgoal):\n 1. p.square_free_m u'", "by simp"], ["proof (state)\nthis:\n  p.square_free_m u'\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have \"unique_factorization_m (smult (content vb) u) (lu * content vb, mset vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_factorization_m (Polynomial.smult (content vb) u)\n     (lu * content vb, mset vs)", "using cop_vb factors inv"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (content vb) p\n  unique_factorization_m u (lu, mset vs)\n  comm_monoid_mult_class.coprime ?x p \\<Longrightarrow>\n  M (inverse_mod ?x m * ?x) = 1\n\ngoal (1 subgoal):\n 1. unique_factorization_m (Polynomial.smult (content vb) u)\n     (lu * content vb, mset vs)", "by (auto intro: unique_factorization_m_smult)"], ["proof (state)\nthis:\n  unique_factorization_m (Polynomial.smult (content vb) u)\n   (lu * content vb, mset vs)\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from unique_factorization_m_cong[OF this prod]"], ["proof (chain)\npicking this:\n  unique_factorization_m\n   (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u')\n   (lu * content vb, mset vs)", "have uf: \"unique_factorization_m (?fact * u') (lu * content vb, mset vs)\""], ["proof (prove)\nusing this:\n  unique_factorization_m\n   (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u')\n   (lu * content vb, mset vs)\n\ngoal (1 subgoal):\n 1. unique_factorization_m\n     (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u')\n     (lu * content vb, mset vs)", "."], ["proof (state)\nthis:\n  unique_factorization_m\n   (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u')\n   (lu * content vb, mset vs)\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "{"], ["proof (state)\nthis:\n  unique_factorization_m\n   (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) * u')\n   (lu * content vb, mset vs)\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from unique_factorization_m_factor[OF prime uf cop' sf' n m]"], ["proof (chain)\npicking this:\n  \\<exists>fs gs.\n     unique_factorization_m\n      (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n      (lead_coeff (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws))),\n       fs) \\<and>\n     unique_factorization_m u' (lead_coeff u', gs) \\<and>\n     Mf (lu * content vb, mset vs) =\n     Mf (lead_coeff (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws))) *\n         lead_coeff u',\n         fs + gs) \\<and>\n     image_mset Mp fs = fs \\<and> image_mset Mp gs = gs", "obtain fs gs where uf1: \"unique_factorization_m ?fact (lu, fs)\"\n            and uf2: \"unique_factorization_m u' (lu', gs)\"\n            and eq: \"Mf (lu * content vb, mset vs) = Mf (lu * lead_coeff u', fs + gs)\""], ["proof (prove)\nusing this:\n  \\<exists>fs gs.\n     unique_factorization_m\n      (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n      (lead_coeff (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws))),\n       fs) \\<and>\n     unique_factorization_m u' (lead_coeff u', gs) \\<and>\n     Mf (lu * content vb, mset vs) =\n     Mf (lead_coeff (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws))) *\n         lead_coeff u',\n         fs + gs) \\<and>\n     image_mset Mp fs = fs \\<and> image_mset Mp gs = gs\n\ngoal (1 subgoal):\n 1. (\\<And>fs gs.\n        \\<lbrakk>unique_factorization_m\n                  (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n                  (lu, fs);\n         unique_factorization_m u' (lu', gs);\n         Mf (lu * content vb, mset vs) =\n         Mf (lu * lead_coeff u', fs + gs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lead_coeff_smult l_ws lu'_def"], ["proof (prove)\nusing this:\n  \\<exists>fs gs.\n     unique_factorization_m\n      (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws))) (lu * 1, fs) \\<and>\n     unique_factorization_m u' (lead_coeff u', gs) \\<and>\n     Mf (lu * content vb, mset vs) =\n     Mf (lu * 1 * lead_coeff u', fs + gs) \\<and>\n     image_mset Mp fs = fs \\<and> image_mset Mp gs = gs\n\ngoal (1 subgoal):\n 1. (\\<And>fs gs.\n        \\<lbrakk>unique_factorization_m\n                  (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n                  (lu, fs);\n         unique_factorization_m u' (lead_coeff u', gs);\n         Mf (lu * content vb, mset vs) =\n         Mf (lu * lead_coeff u', fs + gs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  unique_factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n   (lu, fs)\n  unique_factorization_m u' (lu', gs)\n  Mf (lu * content vb, mset vs) = Mf (lu * lead_coeff u', fs + gs)\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have \"factorization_m ?fact (lu, mset ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n     (lu, mset ws)", "unfolding factorization_m_def split"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) =m\n    Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) \\<and>\n    (\\<forall>f\\<in>#mset ws. irreducible\\<^sub>d_m f \\<and> monic (Mp f))", "using set_vs vs_mi norm"], ["proof (prove)\nusing this:\n  set vs = set vs' \\<union> set ws\n  ?f2 \\<in># mset vs \\<Longrightarrow>\n  irreducible\\<^sub>d_m ?f2 \\<and> monic ?f2\n  ?v2 \\<in> set vs \\<Longrightarrow> Mp ?v2 = ?v2\n\ngoal (1 subgoal):\n 1. Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) =m\n    Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)) \\<and>\n    (\\<forall>f\\<in>#mset ws. irreducible\\<^sub>d_m f \\<and> monic (Mp f))", "by auto"], ["proof (state)\nthis:\n  factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n   (lu, mset ws)\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "with uf1[unfolded unique_factorization_m_alt_def]"], ["proof (chain)\npicking this:\n  factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n   (lu, fs) \\<and>\n  (\\<forall>dgs.\n      factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n       dgs \\<longrightarrow>\n      Mf dgs = Mf (lu, fs))\n  factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n   (lu, mset ws)", "have \"Mf (lu,mset ws) = Mf (lu, fs)\""], ["proof (prove)\nusing this:\n  factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n   (lu, fs) \\<and>\n  (\\<forall>dgs.\n      factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n       dgs \\<longrightarrow>\n      Mf dgs = Mf (lu, fs))\n  factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n   (lu, mset ws)\n\ngoal (1 subgoal):\n 1. Mf (lu, mset ws) = Mf (lu, fs)", "by blast"], ["proof (state)\nthis:\n  Mf (lu, mset ws) = Mf (lu, fs)\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "hence fs_ws: \"image_mset Mp fs = image_mset Mp (mset ws)\""], ["proof (prove)\nusing this:\n  Mf (lu, mset ws) = Mf (lu, fs)\n\ngoal (1 subgoal):\n 1. image_mset Mp fs = image_mset Mp (mset ws)", "unfolding Mf_def split"], ["proof (prove)\nusing this:\n  (M lu, image_mset Mp (mset ws)) = (M lu, image_mset Mp fs)\n\ngoal (1 subgoal):\n 1. image_mset Mp fs = image_mset Mp (mset ws)", "by auto"], ["proof (state)\nthis:\n  image_mset Mp fs = image_mset Mp (mset ws)\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from eq[unfolded Mf_def split]"], ["proof (chain)\npicking this:\n  (M (lu * content vb), image_mset Mp (mset vs)) =\n  (M (lu * lead_coeff u'), image_mset Mp (fs + gs))", "have \"image_mset Mp (mset vs) = image_mset Mp fs + image_mset Mp gs\""], ["proof (prove)\nusing this:\n  (M (lu * content vb), image_mset Mp (mset vs)) =\n  (M (lu * lead_coeff u'), image_mset Mp (fs + gs))\n\ngoal (1 subgoal):\n 1. image_mset Mp (mset vs) = image_mset Mp fs + image_mset Mp gs", "by auto"], ["proof (state)\nthis:\n  image_mset Mp (mset vs) = image_mset Mp fs + image_mset Mp gs\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from this[unfolded fs_ws vs_split]"], ["proof (chain)\npicking this:\n  image_mset Mp (mset vs' + mset ws) =\n  image_mset Mp (mset ws) + image_mset Mp gs", "have gs: \"image_mset Mp gs = image_mset Mp (mset vs')\""], ["proof (prove)\nusing this:\n  image_mset Mp (mset vs' + mset ws) =\n  image_mset Mp (mset ws) + image_mset Mp gs\n\ngoal (1 subgoal):\n 1. image_mset Mp gs = image_mset Mp (mset vs')", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  image_mset Mp gs = image_mset Mp (mset vs')\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from uf1"], ["proof (chain)\npicking this:\n  unique_factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n   (lu, fs)", "have uf1: \"unique_factorization_m ?fact (lu, mset ws)\""], ["proof (prove)\nusing this:\n  unique_factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n   (lu, fs)\n\ngoal (1 subgoal):\n 1. unique_factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n     (lu, mset ws)", "unfolding unique_factorization_m_def Mf_def split fs_ws"], ["proof (prove)\nusing this:\n  (\\<lambda>cfs.\n      case cfs of (c, fs) \\<Rightarrow> (M c, image_mset Mp fs)) `\n  Collect\n   (factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))) =\n  {(M lu, image_mset Mp (mset ws))}\n\ngoal (1 subgoal):\n 1. (\\<lambda>cfs.\n        case cfs of (c, fs) \\<Rightarrow> (M c, image_mset Mp fs)) `\n    Collect\n     (factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))) =\n    {(M lu, image_mset Mp (mset ws))}", "by simp"], ["proof (state)\nthis:\n  unique_factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n   (lu, mset ws)\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from uf2"], ["proof (chain)\npicking this:\n  unique_factorization_m u' (lu', gs)", "have uf2: \"unique_factorization_m u' (lu', mset vs')\""], ["proof (prove)\nusing this:\n  unique_factorization_m u' (lu', gs)\n\ngoal (1 subgoal):\n 1. unique_factorization_m u' (lu', mset vs')", "unfolding unique_factorization_m_def Mf_def split gs"], ["proof (prove)\nusing this:\n  (\\<lambda>cfs.\n      case cfs of (c, fs) \\<Rightarrow> (M c, image_mset Mp fs)) `\n  Collect (factorization_m u') =\n  {(M lu', image_mset Mp (mset vs'))}\n\ngoal (1 subgoal):\n 1. (\\<lambda>cfs.\n        case cfs of (c, fs) \\<Rightarrow> (M c, image_mset Mp fs)) `\n    Collect (factorization_m u') =\n    {(M lu', image_mset Mp (mset vs'))}", "by simp"], ["proof (state)\nthis:\n  unique_factorization_m u' (lu', mset vs')\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "note uf1 uf2"], ["proof (state)\nthis:\n  unique_factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n   (lu, mset ws)\n  unique_factorization_m u' (lu', mset vs')\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "}"], ["proof (state)\nthis:\n  unique_factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n   (lu, mset ws)\n  unique_factorization_m u' (lu', mset vs')\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "hence factors: \"unique_factorization_m u' (lu', mset vs')\" \n          \"unique_factorization_m ?fact (lu, mset ws)\""], ["proof (prove)\nusing this:\n  unique_factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n   (lu, mset ws)\n  unique_factorization_m u' (lu', mset vs')\n\ngoal (1 subgoal):\n 1. unique_factorization_m u' (lu', mset vs') &&&\n    unique_factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n     (lu, mset ws)", "by auto"], ["proof (state)\nthis:\n  unique_factorization_m u' (lu', mset vs')\n  unique_factorization_m (Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws)))\n   (lu, mset ws)\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have lu': \"lu' = lead_coeff u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lu' = lead_coeff u'", "unfolding lu'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff u' = lead_coeff u'", "by simp"], ["proof (state)\nthis:\n  lu' = lead_coeff u'\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have vb0: \"vb \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vb \\<noteq> 0", "using dvd lu0 u0"], ["proof (prove)\nusing this:\n  vb dvd Polynomial.smult lu u\n  lu \\<noteq> 0\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vb \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  vb \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from ws(2)"], ["proof (chain)\npicking this:\n  length ws = d", "have size_ws: \"size (mset ws) = d\""], ["proof (prove)\nusing this:\n  length ws = d\n\ngoal (1 subgoal):\n 1. size (mset ws) = d", "by auto"], ["proof (state)\nthis:\n  size (mset ws) = d\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "with d0"], ["proof (chain)\npicking this:\n  0 < d\n  size (mset ws) = d", "have size_ws0: \"size (mset ws) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < d\n  size (mset ws) = d\n\ngoal (1 subgoal):\n 1. size (mset ws) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  size (mset ws) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "then"], ["proof (chain)\npicking this:\n  size (mset ws) \\<noteq> 0", "obtain w ws' where ws_w: \"ws = w # ws'\""], ["proof (prove)\nusing this:\n  size (mset ws) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>w ws'. ws = w # ws' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ws, auto)"], ["proof (state)\nthis:\n  ws = w # ws'\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from Mp_vb"], ["proof (chain)\npicking this:\n  vb =m Polynomial.smult lu (prod_list ws)", "have Mp_vb': \"Mp vb = Mp (smult lu (prod_mset (mset ws)))\""], ["proof (prove)\nusing this:\n  vb =m Polynomial.smult lu (prod_list ws)\n\ngoal (1 subgoal):\n 1. vb =m Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws))", "by auto"], ["proof (state)\nthis:\n  vb =m Polynomial.smult lu (\\<Prod>\\<^sub># (mset ws))\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have deg_vb: \"degree vb > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree vb", "by (rule deg_non_zero[OF Mp_vb' cop size_ws0 vs_mi], insert vs_split, auto)"], ["proof (state)\nthis:\n  0 < degree vb\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "also"], ["proof (state)\nthis:\n  0 < degree vb\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have \"degree vb = degree pp_vb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree vb = degree pp_vb", "using arg_cong[OF pp_vb_vb, of degree]"], ["proof (prove)\nusing this:\n  degree (Polynomial.smult (content vb) pp_vb) = degree vb\n\ngoal (1 subgoal):\n 1. degree vb = degree pp_vb", "unfolding degree_smult_eq"], ["proof (prove)\nusing this:\n  (if content vb = 0 then 0 else degree pp_vb) = degree vb\n\ngoal (1 subgoal):\n 1. degree vb = degree pp_vb", "using vb0"], ["proof (prove)\nusing this:\n  (if content vb = 0 then 0 else degree pp_vb) = degree vb\n  vb \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree vb = degree pp_vb", "by auto"], ["proof (state)\nthis:\n  degree vb = degree pp_vb\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "finally"], ["proof (chain)\npicking this:\n  0 < degree pp_vb", "have deg_pp: \"degree pp_vb > 0\""], ["proof (prove)\nusing this:\n  0 < degree pp_vb\n\ngoal (1 subgoal):\n 1. 0 < degree pp_vb", "by auto"], ["proof (state)\nthis:\n  0 < degree pp_vb\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "hence pp_vb0: \"pp_vb \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree pp_vb\n\ngoal (1 subgoal):\n 1. pp_vb \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  pp_vb \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from factors(1)[unfolded unique_factorization_m_alt_def factorization_m_def]"], ["proof (chain)\npicking this:\n  (case (lu', mset vs') of\n   (c, fs) \\<Rightarrow>\n     u' =m Polynomial.smult c (\\<Prod>\\<^sub># fs) \\<and>\n     (\\<forall>f\\<in>#fs.\n         irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<and>\n  (\\<forall>dgs.\n      (case dgs of\n       (c, fs) \\<Rightarrow>\n         u' =m Polynomial.smult c (\\<Prod>\\<^sub># fs) \\<and>\n         (\\<forall>f\\<in>#fs.\n             irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<longrightarrow>\n      Mf dgs = Mf (lu', mset vs'))", "have eq_u': \"Mp u' = Mp (smult lu' (prod_mset (mset vs')))\""], ["proof (prove)\nusing this:\n  (case (lu', mset vs') of\n   (c, fs) \\<Rightarrow>\n     u' =m Polynomial.smult c (\\<Prod>\\<^sub># fs) \\<and>\n     (\\<forall>f\\<in>#fs.\n         irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<and>\n  (\\<forall>dgs.\n      (case dgs of\n       (c, fs) \\<Rightarrow>\n         u' =m Polynomial.smult c (\\<Prod>\\<^sub># fs) \\<and>\n         (\\<forall>f\\<in>#fs.\n             irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<longrightarrow>\n      Mf dgs = Mf (lu', mset vs'))\n\ngoal (1 subgoal):\n 1. u' =m Polynomial.smult lu' (\\<Prod>\\<^sub># (mset vs'))", "by auto"], ["proof (state)\nthis:\n  u' =m Polynomial.smult lu' (\\<Prod>\\<^sub># (mset vs'))\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from r'[unfolded ws(2)] dr"], ["proof (chain)\npicking this:\n  r - d = length vs'\n  d + d \\<le> r", "have \"length vs' + d = r\""], ["proof (prove)\nusing this:\n  r - d = length vs'\n  d + d \\<le> r\n\ngoal (1 subgoal):\n 1. length vs' + d = r", "by auto"], ["proof (state)\nthis:\n  length vs' + d = r\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from this cands_empty[unfolded Cons]"], ["proof (chain)\npicking this:\n  length vs' + d = r\n  c # cds \\<noteq> [] \\<Longrightarrow> d < r", "have \"size (mset vs') \\<noteq> 0\""], ["proof (prove)\nusing this:\n  length vs' + d = r\n  c # cds \\<noteq> [] \\<Longrightarrow> d < r\n\ngoal (1 subgoal):\n 1. size (mset vs') \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  size (mset vs') \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from deg_non_zero[OF eq_u' cop_lu' this vs_mi]"], ["proof (chain)\npicking this:\n  (\\<And>v.\n      v \\<in># mset vs' \\<Longrightarrow>\n      v \\<in># mset vs) \\<Longrightarrow>\n  0 < degree u'", "have deg_u': \"degree u' > 0\""], ["proof (prove)\nusing this:\n  (\\<And>v.\n      v \\<in># mset vs' \\<Longrightarrow>\n      v \\<in># mset vs) \\<Longrightarrow>\n  0 < degree u'\n\ngoal (1 subgoal):\n 1. 0 < degree u'", "unfolding vs_split"], ["proof (prove)\nusing this:\n  (\\<And>v.\n      v \\<in># mset vs' \\<Longrightarrow>\n      v \\<in># mset vs' + mset ws) \\<Longrightarrow>\n  0 < degree u'\n\ngoal (1 subgoal):\n 1. 0 < degree u'", "by auto"], ["proof (state)\nthis:\n  0 < degree u'\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have irr_pp: \"irreducible\\<^sub>d pp_vb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d pp_vb", "proof (rule irreducible\\<^sub>dI[OF deg_pp])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "fix q r :: \"int poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "assume deg_q: \"degree q > 0\" \"degree q < degree pp_vb\"\n            and deg_r:  \"degree r > 0\" \"degree r < degree pp_vb\"\n            and pp_qr: \"pp_vb = q * r\""], ["proof (state)\nthis:\n  0 < degree q\n  degree q < degree pp_vb\n  0 < degree r\n  degree r < degree pp_vb\n  pp_vb = q * r\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < degree q\n  degree q < degree pp_vb\n  0 < degree r\n  degree r < degree pp_vb\n  pp_vb = q * r", "have qvb: \"q dvd pp_vb\""], ["proof (prove)\nusing this:\n  0 < degree q\n  degree q < degree pp_vb\n  0 < degree r\n  degree r < degree pp_vb\n  pp_vb = q * r\n\ngoal (1 subgoal):\n 1. q dvd pp_vb", "by auto"], ["proof (state)\nthis:\n  q dvd pp_vb\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from dvd_trans[OF qvb ppu]"], ["proof (chain)\npicking this:\n  q dvd u", "have qu: \"q dvd u\""], ["proof (prove)\nusing this:\n  q dvd u\n\ngoal (1 subgoal):\n 1. q dvd u", "."], ["proof (state)\nthis:\n  q dvd u\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "have \"degree pp_vb = degree q + degree r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree pp_vb = degree q + degree r", "unfolding pp_qr"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (q * r) = degree q + degree r", "by (subst degree_mult_eq, insert pp_qr pp_vb0, auto)"], ["proof (state)\nthis:\n  degree pp_vb = degree q + degree r\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "have uf: \"unique_factorization_m (smult (content vb) pp_vb) (lu, mset ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_factorization_m (Polynomial.smult (content vb) pp_vb)\n     (lu, mset ws)", "unfolding pp_vb_vb"], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_factorization_m vb (lu, mset ws)", "by (rule unique_factorization_m_cong[OF factors(2)], insert Mp_vb, auto)"], ["proof (state)\nthis:\n  unique_factorization_m (Polynomial.smult (content vb) pp_vb) (lu, mset ws)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from unique_factorization_m_smultD[OF uf inv] cop_vb"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime (content vb) p \\<Longrightarrow>\n  unique_factorization_m pp_vb (lu * inverse_mod (content vb) m, mset ws)\n  comm_monoid_mult_class.coprime (content vb) p", "have uf: \"unique_factorization_m pp_vb (lu * inverse_mod (content vb) m, mset ws)\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (content vb) p \\<Longrightarrow>\n  unique_factorization_m pp_vb (lu * inverse_mod (content vb) m, mset ws)\n  comm_monoid_mult_class.coprime (content vb) p\n\ngoal (1 subgoal):\n 1. unique_factorization_m pp_vb (lu * inverse_mod (content vb) m, mset ws)", "by auto"], ["proof (state)\nthis:\n  unique_factorization_m pp_vb (lu * inverse_mod (content vb) m, mset ws)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from ppu"], ["proof (chain)\npicking this:\n  pp_vb dvd u", "have \"lead_coeff pp_vb dvd lu\""], ["proof (prove)\nusing this:\n  pp_vb dvd u\n\ngoal (1 subgoal):\n 1. lead_coeff pp_vb dvd lu", "unfolding lu"], ["proof (prove)\nusing this:\n  pp_vb dvd u\n\ngoal (1 subgoal):\n 1. lead_coeff pp_vb dvd lead_coeff u", "by (metis dvd_def lead_coeff_mult)"], ["proof (state)\nthis:\n  lead_coeff pp_vb dvd lu\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from coprime_divisors[OF this dvd_refl] cop"], ["proof (chain)\npicking this:\n  algebraic_semidom_class.coprime lu ?b \\<Longrightarrow>\n  algebraic_semidom_class.coprime (lead_coeff pp_vb) ?b\n  comm_monoid_mult_class.coprime lu p", "have cop_pp: \"coprime (lead_coeff pp_vb) p\""], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime lu ?b \\<Longrightarrow>\n  algebraic_semidom_class.coprime (lead_coeff pp_vb) ?b\n  comm_monoid_mult_class.coprime lu p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff pp_vb) p", "by simp"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff pp_vb) p\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from coprime_lead_coeff_factor[OF prime cop_pp[unfolded pp_qr]]"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime (lead_coeff q) p\n  comm_monoid_mult_class.coprime (lead_coeff r) p", "have cop_qr: \"coprime (lead_coeff q) p\" \"coprime (lead_coeff r) p\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lead_coeff q) p\n  comm_monoid_mult_class.coprime (lead_coeff r) p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff q) p &&&\n    comm_monoid_mult_class.coprime (lead_coeff r) p", "by auto"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff q) p\n  comm_monoid_mult_class.coprime (lead_coeff r) p\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from p.square_free_m_factor[OF sf[unfolded u]]"], ["proof (chain)\npicking this:\n  p.square_free_m pp_vb\n  p.square_free_m u'", "have sf_pp: \"p.square_free_m pp_vb\""], ["proof (prove)\nusing this:\n  p.square_free_m pp_vb\n  p.square_free_m u'\n\ngoal (1 subgoal):\n 1. p.square_free_m pp_vb", "by simp"], ["proof (state)\nthis:\n  p.square_free_m pp_vb\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from unique_factorization_m_factor[OF prime uf[unfolded pp_qr] _ _ n m, \n            folded pp_qr, OF cop_pp sf_pp]"], ["proof (chain)\npicking this:\n  \\<exists>fs gs.\n     unique_factorization_m q (lead_coeff q, fs) \\<and>\n     unique_factorization_m r (lead_coeff r, gs) \\<and>\n     Mf (lu * inverse_mod (content vb) m, mset ws) =\n     Mf (lead_coeff q * lead_coeff r, fs + gs) \\<and>\n     image_mset Mp fs = fs \\<and> image_mset Mp gs = gs", "obtain fs gs l where uf_q: \"unique_factorization_m q (lead_coeff q, fs)\"\n            and uf_r: \"unique_factorization_m r (lead_coeff r, gs)\"\n            and Mf_eq: \"Mf (l, mset ws) = Mf (lead_coeff q * lead_coeff r, fs + gs)\" \n            and fs_id: \"image_mset Mp fs = fs\" \n            and gs_id: \"image_mset Mp gs = gs\""], ["proof (prove)\nusing this:\n  \\<exists>fs gs.\n     unique_factorization_m q (lead_coeff q, fs) \\<and>\n     unique_factorization_m r (lead_coeff r, gs) \\<and>\n     Mf (lu * inverse_mod (content vb) m, mset ws) =\n     Mf (lead_coeff q * lead_coeff r, fs + gs) \\<and>\n     image_mset Mp fs = fs \\<and> image_mset Mp gs = gs\n\ngoal (1 subgoal):\n 1. (\\<And>fs gs l.\n        \\<lbrakk>unique_factorization_m q (lead_coeff q, fs);\n         unique_factorization_m r (lead_coeff r, gs);\n         Mf (l, mset ws) = Mf (lead_coeff q * lead_coeff r, fs + gs);\n         image_mset Mp fs = fs; image_mset Mp gs = gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  unique_factorization_m q (lead_coeff q, fs)\n  unique_factorization_m r (lead_coeff r, gs)\n  Mf (l, mset ws) = Mf (lead_coeff q * lead_coeff r, fs + gs)\n  image_mset Mp fs = fs\n  image_mset Mp gs = gs\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from Mf_eq"], ["proof (chain)\npicking this:\n  Mf (l, mset ws) = Mf (lead_coeff q * lead_coeff r, fs + gs)", "have \"image_mset Mp (mset ws) = image_mset Mp fs + image_mset Mp gs\""], ["proof (prove)\nusing this:\n  Mf (l, mset ws) = Mf (lead_coeff q * lead_coeff r, fs + gs)\n\ngoal (1 subgoal):\n 1. image_mset Mp (mset ws) = image_mset Mp fs + image_mset Mp gs", "unfolding Mf_def"], ["proof (prove)\nusing this:\n  (case (l, mset ws) of (c, fs) \\<Rightarrow> (M c, image_mset Mp fs)) =\n  (case (lead_coeff q * lead_coeff r, fs + gs) of\n   (c, fs) \\<Rightarrow> (M c, image_mset Mp fs))\n\ngoal (1 subgoal):\n 1. image_mset Mp (mset ws) = image_mset Mp fs + image_mset Mp gs", "by auto"], ["proof (state)\nthis:\n  image_mset Mp (mset ws) = image_mset Mp fs + image_mset Mp gs\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  image_mset Mp (mset ws) = image_mset Mp fs + image_mset Mp gs\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "have \"image_mset Mp (mset ws) = mset ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset Mp (mset ws) = mset ws", "using norm ws_vs(2)"], ["proof (prove)\nusing this:\n  ?v2 \\<in> set vs \\<Longrightarrow> Mp ?v2 = ?v2\n  set ws \\<subseteq> set vs\n\ngoal (1 subgoal):\n 1. image_mset Mp (mset ws) = mset ws", "by (induct ws, auto)"], ["proof (state)\nthis:\n  image_mset Mp (mset ws) = mset ws\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  mset ws = image_mset Mp fs + image_mset Mp gs", "have eq: \"mset ws = image_mset Mp fs + image_mset Mp gs\""], ["proof (prove)\nusing this:\n  mset ws = image_mset Mp fs + image_mset Mp gs\n\ngoal (1 subgoal):\n 1. mset ws = image_mset Mp fs + image_mset Mp gs", "by simp"], ["proof (state)\nthis:\n  mset ws = image_mset Mp fs + image_mset Mp gs\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from arg_cong[OF this, of size, unfolded size_ws]"], ["proof (chain)\npicking this:\n  d = size (image_mset Mp fs + image_mset Mp gs)", "have size: \"size fs + size gs = d\""], ["proof (prove)\nusing this:\n  d = size (image_mset Mp fs + image_mset Mp gs)\n\ngoal (1 subgoal):\n 1. size fs + size gs = d", "by auto"], ["proof (state)\nthis:\n  size fs + size gs = d\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from uf_q[unfolded unique_factorization_m_alt_def factorization_m_def split]"], ["proof (chain)\npicking this:\n  (q =m Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs) \\<and>\n   (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<and>\n  (\\<forall>dgs.\n      (case dgs of\n       (c, fs) \\<Rightarrow>\n         q =m Polynomial.smult c (\\<Prod>\\<^sub># fs) \\<and>\n         (\\<forall>f\\<in>#fs.\n             irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<longrightarrow>\n      Mf dgs = Mf (lead_coeff q, fs))", "have q_eq: \"q =m smult (lead_coeff q) (prod_mset fs)\""], ["proof (prove)\nusing this:\n  (q =m Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs) \\<and>\n   (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<and>\n  (\\<forall>dgs.\n      (case dgs of\n       (c, fs) \\<Rightarrow>\n         q =m Polynomial.smult c (\\<Prod>\\<^sub># fs) \\<and>\n         (\\<forall>f\\<in>#fs.\n             irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<longrightarrow>\n      Mf dgs = Mf (lead_coeff q, fs))\n\ngoal (1 subgoal):\n 1. q =m Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs)", "by auto"], ["proof (state)\nthis:\n  q =m Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "have \"degree_m q = degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m q = degree q", "by (rule degree_m_eq[OF _ m1], insert cop_qr(1) n p.m1, unfold m, \n              auto simp:)"], ["proof (state)\nthis:\n  degree_m q = degree q\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "with q_eq"], ["proof (chain)\npicking this:\n  q =m Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs)\n  degree_m q = degree q", "have degm_q: \"degree q = degree (Mp (smult (lead_coeff q) (prod_mset fs)))\""], ["proof (prove)\nusing this:\n  q =m Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs)\n  degree_m q = degree q\n\ngoal (1 subgoal):\n 1. degree q =\n    degree_m (Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs))", "by auto"], ["proof (state)\nthis:\n  degree q = degree_m (Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs))\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "with deg_q"], ["proof (chain)\npicking this:\n  0 < degree q\n  degree q < degree pp_vb\n  degree q = degree_m (Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs))", "have fs_nempty: \"fs \\<noteq> {#}\""], ["proof (prove)\nusing this:\n  0 < degree q\n  degree q < degree pp_vb\n  degree q = degree_m (Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs))\n\ngoal (1 subgoal):\n 1. fs \\<noteq> {#}", "by (cases fs; cases \"lead_coeff q = 0\"; auto simp: Mp_def)"], ["proof (state)\nthis:\n  fs \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from uf_r[unfolded unique_factorization_m_alt_def factorization_m_def split]"], ["proof (chain)\npicking this:\n  (r =m Polynomial.smult (lead_coeff r) (\\<Prod>\\<^sub># gs) \\<and>\n   (\\<forall>f\\<in>#gs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<and>\n  (\\<forall>dgs.\n      (case dgs of\n       (c, fs) \\<Rightarrow>\n         r =m Polynomial.smult c (\\<Prod>\\<^sub># fs) \\<and>\n         (\\<forall>f\\<in>#fs.\n             irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<longrightarrow>\n      Mf dgs = Mf (lead_coeff r, gs))", "have r_eq: \"r =m smult (lead_coeff r) (prod_mset gs)\""], ["proof (prove)\nusing this:\n  (r =m Polynomial.smult (lead_coeff r) (\\<Prod>\\<^sub># gs) \\<and>\n   (\\<forall>f\\<in>#gs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<and>\n  (\\<forall>dgs.\n      (case dgs of\n       (c, fs) \\<Rightarrow>\n         r =m Polynomial.smult c (\\<Prod>\\<^sub># fs) \\<and>\n         (\\<forall>f\\<in>#fs.\n             irreducible\\<^sub>d_m f \\<and> monic (Mp f))) \\<longrightarrow>\n      Mf dgs = Mf (lead_coeff r, gs))\n\ngoal (1 subgoal):\n 1. r =m Polynomial.smult (lead_coeff r) (\\<Prod>\\<^sub># gs)", "by auto"], ["proof (state)\nthis:\n  r =m Polynomial.smult (lead_coeff r) (\\<Prod>\\<^sub># gs)\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "have \"degree_m r = degree r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m r = degree r", "by (rule degree_m_eq[OF _ m1], insert cop_qr(2) n p.m1, unfold m, \n              auto simp:)"], ["proof (state)\nthis:\n  degree_m r = degree r\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "with r_eq"], ["proof (chain)\npicking this:\n  r =m Polynomial.smult (lead_coeff r) (\\<Prod>\\<^sub># gs)\n  degree_m r = degree r", "have degm_r: \"degree r = degree (Mp (smult (lead_coeff r) (prod_mset gs)))\""], ["proof (prove)\nusing this:\n  r =m Polynomial.smult (lead_coeff r) (\\<Prod>\\<^sub># gs)\n  degree_m r = degree r\n\ngoal (1 subgoal):\n 1. degree r =\n    degree_m (Polynomial.smult (lead_coeff r) (\\<Prod>\\<^sub># gs))", "by auto"], ["proof (state)\nthis:\n  degree r = degree_m (Polynomial.smult (lead_coeff r) (\\<Prod>\\<^sub># gs))\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "with deg_r"], ["proof (chain)\npicking this:\n  0 < degree r\n  degree r < degree pp_vb\n  degree r = degree_m (Polynomial.smult (lead_coeff r) (\\<Prod>\\<^sub># gs))", "have gs_nempty: \"gs \\<noteq> {#}\""], ["proof (prove)\nusing this:\n  0 < degree r\n  degree r < degree pp_vb\n  degree r = degree_m (Polynomial.smult (lead_coeff r) (\\<Prod>\\<^sub># gs))\n\ngoal (1 subgoal):\n 1. gs \\<noteq> {#}", "by (cases gs; cases \"lead_coeff r = 0\"; auto simp: Mp_def)"], ["proof (state)\nthis:\n  gs \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from gs_nempty"], ["proof (chain)\npicking this:\n  gs \\<noteq> {#}", "have \"size gs \\<noteq> 0\""], ["proof (prove)\nusing this:\n  gs \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. size gs \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  size gs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "with size"], ["proof (chain)\npicking this:\n  size fs + size gs = d\n  size gs \\<noteq> 0", "have size_fs: \"size fs < d\""], ["proof (prove)\nusing this:\n  size fs + size gs = d\n  size gs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. size fs < d", "by linarith"], ["proof (state)\nthis:\n  size fs < d\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "note * = tests[unfolded test_dvd_def, rule_format, OF _ fs_nempty _ qu, of \"lead_coeff q\"]"], ["proof (state)\nthis:\n  \\<lbrakk>fs \\<subseteq># mset vs;\n   size fs < d \\<or>\n   size fs = d \\<and> fs \\<notin> (mset \\<circ> snd) ` set cands;\n   0 < degree q; degree q < degree u\\<rbrakk>\n  \\<Longrightarrow> Mp q \\<noteq>\n                    Mp (Polynomial.smult (lead_coeff q)\n                         (\\<Prod>\\<^sub># fs))\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from ppu"], ["proof (chain)\npicking this:\n  pp_vb dvd u", "have \"degree pp_vb \\<le> degree u\""], ["proof (prove)\nusing this:\n  pp_vb dvd u\n\ngoal (1 subgoal):\n 1. degree pp_vb \\<le> degree u", "using dvd_imp_degree_le u0"], ["proof (prove)\nusing this:\n  pp_vb dvd u\n  \\<lbrakk>?p dvd ?q; ?q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> degree ?p \\<le> degree ?q\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree pp_vb \\<le> degree u", "by blast"], ["proof (state)\nthis:\n  degree pp_vb \\<le> degree u\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "with deg_q q_eq size_fs"], ["proof (chain)\npicking this:\n  0 < degree q\n  degree q < degree pp_vb\n  q =m Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs)\n  size fs < d\n  degree pp_vb \\<le> degree u", "have \"\\<not> fs \\<subseteq># mset vs\""], ["proof (prove)\nusing this:\n  0 < degree q\n  degree q < degree pp_vb\n  q =m Polynomial.smult (lead_coeff q) (\\<Prod>\\<^sub># fs)\n  size fs < d\n  degree pp_vb \\<le> degree u\n\ngoal (1 subgoal):\n 1. \\<not> fs \\<subseteq># mset vs", "by (auto dest!:*)"], ["proof (state)\nthis:\n  \\<not> fs \\<subseteq># mset vs\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree pp_vb; 0 < degree r;\n        degree r < degree pp_vb; pp_vb = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<not> fs \\<subseteq># mset vs\n\ngoal (1 subgoal):\n 1. False", "unfolding vs_split eq fs_id gs_id"], ["proof (prove)\nusing this:\n  \\<not> fs \\<subseteq># mset vs' + (fs + gs)\n\ngoal (1 subgoal):\n 1. False", "using mset_subset_eq_add_left[of fs \"mset vs' + gs\"]"], ["proof (prove)\nusing this:\n  \\<not> fs \\<subseteq># mset vs' + (fs + gs)\n  fs \\<subseteq># fs + (mset vs' + gs)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  irreducible\\<^sub>d pp_vb\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "{"], ["proof (state)\nthis:\n  irreducible\\<^sub>d pp_vb\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "fix ws'"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "assume *: \"ws' \\<subseteq># mset vs'\" \"ws' \\<noteq> {#}\" \n            \"size ws' < d \\<or> size ws' = d \\<and> ws' \\<notin> (mset \\<circ> snd) ` set cands'\""], ["proof (state)\nthis:\n  ws' \\<subseteq># mset vs'\n  ws' \\<noteq> {#}\n  size ws' < d \\<or>\n  size ws' = d \\<and> ws' \\<notin> (mset \\<circ> snd) ` set cands'\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from *(1)"], ["proof (chain)\npicking this:\n  ws' \\<subseteq># mset vs'", "have \"ws' \\<subseteq># mset vs\""], ["proof (prove)\nusing this:\n  ws' \\<subseteq># mset vs'\n\ngoal (1 subgoal):\n 1. ws' \\<subseteq># mset vs", "unfolding vs_split"], ["proof (prove)\nusing this:\n  ws' \\<subseteq># mset vs'\n\ngoal (1 subgoal):\n 1. ws' \\<subseteq># mset vs' + mset ws", "by (simp add: subset_mset.add_increasing2)"], ["proof (state)\nthis:\n  ws' \\<subseteq># mset vs\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from tests[OF this *(2)] *(3)[unfolded cands' mset_snd_S] *(1)"], ["proof (chain)\npicking this:\n  size ws' < d \\<or>\n  size ws' = d \\<and>\n  ws' \\<notin> (mset \\<circ> snd) ` set cands \\<Longrightarrow>\n  test_dvd u ws'\n  size ws' < d \\<or>\n  size ws' = d \\<and>\n  ws' \\<notin> {ws. ws \\<subseteq># mset vs' \\<and> size ws = d}\n  ws' \\<subseteq># mset vs'", "have \"test_dvd u ws'\""], ["proof (prove)\nusing this:\n  size ws' < d \\<or>\n  size ws' = d \\<and>\n  ws' \\<notin> (mset \\<circ> snd) ` set cands \\<Longrightarrow>\n  test_dvd u ws'\n  size ws' < d \\<or>\n  size ws' = d \\<and>\n  ws' \\<notin> {ws. ws \\<subseteq># mset vs' \\<and> size ws = d}\n  ws' \\<subseteq># mset vs'\n\ngoal (1 subgoal):\n 1. test_dvd u ws'", "by auto"], ["proof (state)\nthis:\n  test_dvd u ws'\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from test_dvd_factor[OF u0 this[unfolded lu] uu']"], ["proof (chain)\npicking this:\n  test_dvd u' ws'", "have \"test_dvd u' ws'\""], ["proof (prove)\nusing this:\n  test_dvd u' ws'\n\ngoal (1 subgoal):\n 1. test_dvd u' ws'", "."], ["proof (state)\nthis:\n  test_dvd u' ws'\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ws'a4 \\<subseteq># mset vs'; ?ws'a4 \\<noteq> {#};\n   size ?ws'a4 < d \\<or>\n   size ?ws'a4 = d \\<and>\n   ?ws'a4 \\<notin> (mset \\<circ> snd) ` set cands'\\<rbrakk>\n  \\<Longrightarrow> test_dvd u' ?ws'a4\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "note tests' = this"], ["proof (state)\nthis:\n  \\<lbrakk>?ws'a4 \\<subseteq># mset vs'; ?ws'a4 \\<noteq> {#};\n   size ?ws'a4 < d \\<or>\n   size ?ws'a4 = d \\<and>\n   ?ws'a4 \\<notin> (mset \\<circ> snd) ` set cands'\\<rbrakk>\n  \\<Longrightarrow> test_dvd u' ?ws'a4\n\ngoal (1 subgoal):\n 1. inv_M lv' dvd coeff (Polynomial.smult lu u) 0 \\<and>\n    vb dvd Polynomial.smult lu u \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "proof (cases \"?r' < d + d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "case True"], ["proof (state)\nthis:\n  r - length ws < d + d\n\ngoal (2 subgoals):\n 1. r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "with res"], ["proof (chain)\npicking this:\n  (if r - length ws < d + d then u' # pp_vb # res\n   else reconstruction sl_impl m2 state' u' (Polynomial.smult lu' u') lu' d\n         (r - length ws) vs' (pp_vb # res) cands') =\n  fs\n  r - length ws < d + d", "have res: \"fs = u' # ?res'\""], ["proof (prove)\nusing this:\n  (if r - length ws < d + d then u' # pp_vb # res\n   else reconstruction sl_impl m2 state' u' (Polynomial.smult lu' u') lu' d\n         (r - length ws) vs' (pp_vb # res) cands') =\n  fs\n  r - length ws < d + d\n\ngoal (1 subgoal):\n 1. fs = u' # pp_vb # res", "by auto"], ["proof (state)\nthis:\n  fs = u' # pp_vb # res\n\ngoal (2 subgoals):\n 1. r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from True r'"], ["proof (chain)\npicking this:\n  r - length ws < d + d\n  r - length ws = length vs'", "have size: \"size (mset vs') < d + d\""], ["proof (prove)\nusing this:\n  r - length ws < d + d\n  r - length ws = length vs'\n\ngoal (1 subgoal):\n 1. size (mset vs') < d + d", "by auto"], ["proof (state)\nthis:\n  size (mset vs') < d + d\n\ngoal (2 subgoals):\n 1. r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have \"irreducible\\<^sub>d u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d u'", "by (rule irreducible\\<^sub>d_via_tests[OF deg_u' cop_lu'[unfolded lu'] factors(1)[unfolded lu'] \n            sf_u' norm size tests'], insert set_vs, auto)"], ["proof (state)\nthis:\n  irreducible\\<^sub>d u'\n\ngoal (2 subgoals):\n 1. r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n 2. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "with f res irr irr_pp"], ["proof (chain)\npicking this:\n  f = u' * prod_list (pp_vb # res)\n  fs = u' # pp_vb # res\n  ?f2 \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d ?f2\n  irreducible\\<^sub>d pp_vb\n  irreducible\\<^sub>d u'", "show ?thesis"], ["proof (prove)\nusing this:\n  f = u' * prod_list (pp_vb # res)\n  fs = u' # pp_vb # res\n  ?f2 \\<in> set res \\<Longrightarrow> irreducible\\<^sub>d ?f2\n  irreducible\\<^sub>d pp_vb\n  irreducible\\<^sub>d u'\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "by auto"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n\ngoal (1 subgoal):\n 1. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "case False"], ["proof (state)\nthis:\n  \\<not> r - length ws < d + d\n\ngoal (1 subgoal):\n 1. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have res: \"reconstruction sl_impl m2 state' u' ?luu' lu' d ?r' vs' ?res' cands' = fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reconstruction sl_impl m2 state' u' (Polynomial.smult lu' u') lu' d\n     (r - length ws) vs' (pp_vb # res) cands' =\n    fs", "using False res"], ["proof (prove)\nusing this:\n  \\<not> r - length ws < d + d\n  (if r - length ws < d + d then u' # pp_vb # res\n   else reconstruction sl_impl m2 state' u' (Polynomial.smult lu' u') lu' d\n         (r - length ws) vs' (pp_vb # res) cands') =\n  fs\n\ngoal (1 subgoal):\n 1. reconstruction sl_impl m2 state' u' (Polynomial.smult lu' u') lu' d\n     (r - length ws) vs' (pp_vb # res) cands' =\n    fs", "by auto"], ["proof (state)\nthis:\n  reconstruction sl_impl m2 state' u' (Polynomial.smult lu' u') lu' d\n   (r - length ws) vs' (pp_vb # res) cands' =\n  fs\n\ngoal (1 subgoal):\n 1. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from False"], ["proof (chain)\npicking this:\n  \\<not> r - length ws < d + d", "have dr: \"d + d \\<le> ?r'\""], ["proof (prove)\nusing this:\n  \\<not> r - length ws < d + d\n\ngoal (1 subgoal):\n 1. d + d \\<le> r - length ws", "by auto"], ["proof (state)\nthis:\n  d + d \\<le> r - length ws\n\ngoal (1 subgoal):\n 1. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "from False dr r r' d0 ws Cons"], ["proof (chain)\npicking this:\n  \\<not> r - length ws < d + d\n  d + d \\<le> r - length ws\n  r = length vs\n  r - length ws = length vs'\n  0 < d\n  ws \\<in> set (subseqs vs)\n  length ws = d\n  cands = c # cds", "have le: \"?r' - d < r - d\""], ["proof (prove)\nusing this:\n  \\<not> r - length ws < d + d\n  d + d \\<le> r - length ws\n  r = length vs\n  r - length ws = length vs'\n  0 < d\n  ws \\<in> set (subseqs vs)\n  length ws = d\n  cands = c # cds\n\ngoal (1 subgoal):\n 1. r - length ws - d < r - d", "by (cases ws, auto)"], ["proof (state)\nthis:\n  r - length ws - d < r - d\n\ngoal (1 subgoal):\n 1. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "hence R: \"((?r' - d, cands'), meas) \\<in> R\""], ["proof (prove)\nusing this:\n  r - length ws - d < r - d\n\ngoal (1 subgoal):\n 1. ((r - length ws - d, cands'), meas) \\<in> R", "unfolding meas R_def"], ["proof (prove)\nusing this:\n  r - length ws - d < r - d\n\ngoal (1 subgoal):\n 1. ((r - length ws - d, cands'), r - d, cands)\n    \\<in> measures [\\<lambda>(n, cds). n, \\<lambda>(n, y). length y]", "by simp"], ["proof (state)\nthis:\n  ((r - length ws - d, cands'), meas) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have dr': \"d < ?r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < r - length ws", "using le False ws(2)"], ["proof (prove)\nusing this:\n  r - length ws - d < r - d\n  \\<not> r - length ws < d + d\n  length ws = d\n\ngoal (1 subgoal):\n 1. d < r - length ws", "by linarith"], ["proof (state)\nthis:\n  d < r - length ws\n\ngoal (1 subgoal):\n 1. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have luu': \"lu' dvd lu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lu' dvd lu", "using \\<open>lead_coeff u' dvd lu\\<close>"], ["proof (prove)\nusing this:\n  lead_coeff u' dvd lu\n\ngoal (1 subgoal):\n 1. lu' dvd lu", "unfolding lu'"], ["proof (prove)\nusing this:\n  lead_coeff u' dvd lu\n\ngoal (1 subgoal):\n 1. lead_coeff u' dvd lu", "."], ["proof (state)\nthis:\n  lu' dvd lu\n\ngoal (1 subgoal):\n 1. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have \"large_m (smult lu' u') vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. large_m (Polynomial.smult lu' u') vs", "by (rule large_m_factor[OF large dvd_dvd_smult], insert uu' luu')"], ["proof (state)\nthis:\n  large_m (Polynomial.smult lu' u') vs\n\ngoal (1 subgoal):\n 1. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "moreover"], ["proof (state)\nthis:\n  large_m (Polynomial.smult lu' u') vs\n\ngoal (1 subgoal):\n 1. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "have \"degree_bound vs' \\<le> degree_bound vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_bound vs' \\<le> degree_bound vs", "unfolding vs'_def degree_bound_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_factor_degree (map degree (fold remove1 ws vs))\n    \\<le> max_factor_degree (map degree vs)", "by (rule max_factor_degree_mono)"], ["proof (state)\nthis:\n  degree_bound vs' \\<le> degree_bound vs\n\ngoal (1 subgoal):\n 1. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "ultimately"], ["proof (chain)\npicking this:\n  large_m (Polynomial.smult lu' u') vs\n  degree_bound vs' \\<le> degree_bound vs", "have large': \"large_m (smult lu' u') vs'\""], ["proof (prove)\nusing this:\n  large_m (Polynomial.smult lu' u') vs\n  degree_bound vs' \\<le> degree_bound vs\n\ngoal (1 subgoal):\n 1. large_m (Polynomial.smult lu' u') vs'", "unfolding large_m_def"], ["proof (prove)\nusing this:\n  \\<forall>v n.\n     v dvd Polynomial.smult lu' u' \\<longrightarrow>\n     degree v \\<le> degree_bound vs \\<longrightarrow>\n     2 * \\<bar>coeff v n\\<bar> < m\n  degree_bound vs' \\<le> degree_bound vs\n\ngoal (1 subgoal):\n 1. \\<forall>v n.\n       v dvd Polynomial.smult lu' u' \\<longrightarrow>\n       degree v \\<le> degree_bound vs' \\<longrightarrow>\n       2 * \\<bar>coeff v n\\<bar> < m", "by auto"], ["proof (state)\nthis:\n  large_m (Polynomial.smult lu' u') vs'\n\ngoal (1 subgoal):\n 1. \\<not> r - length ws < d + d \\<Longrightarrow>\n    f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)", "by (rule IH[OF R res f refl dr r' _ _ lu' factors(1) sf_u' cop_lu' norm tests' _ deg_u' \n            dr' large' state'], insert irr irr_pp d0 Cons set_vs, auto simp: cands')"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>a\\<in>set fs. irreducible\\<^sub>d a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "(* select implementation of subseqs *)"], ["", "definition zassenhaus_reconstruction :: \n  \"int poly list \\<Rightarrow> int \\<Rightarrow> nat \\<Rightarrow> int poly \\<Rightarrow> int poly list\" where\n  \"zassenhaus_reconstruction vs p n f = (let\n     mul = poly_mod.mul_const (p^n);\n     sl_impl = my_subseqs.impl (\\<lambda>x. map_prod (mul x) (Cons x))\n     in zassenhaus_reconstruction_generic sl_impl vs p n f)\""], ["", "context\n  fixes p n f hs\n  assumes prime: \"prime p\" \n  and cop: \"coprime (lead_coeff f) p\"\n  and sf: \"poly_mod.square_free_m p f\"\n  and deg: \"degree f > 0\" \n  and bh: \"berlekamp_hensel p n f = hs\" \n  and bnd: \"2 * \\<bar>lead_coeff f\\<bar> * factor_bound f (degree_bound hs) < p ^ n\" \nbegin"], ["", "private"], ["", "lemma n: \"n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "assume n: \"n = 0\""], ["proof (state)\nthis:\n  n = 0\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "hence pn: \"p^n = 1\""], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. p ^ n = 1", "by auto"], ["proof (state)\nthis:\n  p ^ n = 1\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "let ?f = \"smult (lead_coeff f) f\""], ["proof (state)\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "let ?d = \"degree_bound hs\""], ["proof (state)\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "have f: \"f \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "using deg"], ["proof (prove)\nusing this:\n  0 < degree f\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "hence \"lead_coeff f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lead_coeff f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "hence lf: \"abs (lead_coeff f) > 0\""], ["proof (prove)\nusing this:\n  lead_coeff f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < \\<bar>lead_coeff f\\<bar>", "by auto"], ["proof (state)\nthis:\n  0 < \\<bar>lead_coeff f\\<bar>\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "obtain c d where c: \"factor_bound f (degree_bound hs) = c\" \"abs (lead_coeff f) = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c d.\n        \\<lbrakk>factor_bound f (degree_bound hs) = c;\n         \\<bar>lead_coeff f\\<bar> = d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  factor_bound f (degree_bound hs) = c\n  \\<bar>lead_coeff f\\<bar> = d\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  factor_bound f (degree_bound hs) = c\n  \\<bar>lead_coeff f\\<bar> = d\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "assume *: \"1 \\<le> c\" \"2 * d * c < 1\" \"0 < d\""], ["proof (state)\nthis:\n  1 \\<le> c\n  2 * d * c < 1\n  0 < d\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "hence \"1 \\<le> d\""], ["proof (prove)\nusing this:\n  1 \\<le> c\n  2 * d * c < 1\n  0 < d\n\ngoal (1 subgoal):\n 1. 1 \\<le> d", "by auto"], ["proof (state)\nthis:\n  1 \\<le> d\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "from mult_mono[OF this *(1)] *"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> d; 0 \\<le> 1\\<rbrakk> \\<Longrightarrow> 1 * 1 \\<le> d * c\n  1 \\<le> c\n  2 * d * c < 1\n  0 < d", "have \"1 \\<le> d * c\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> d; 0 \\<le> 1\\<rbrakk> \\<Longrightarrow> 1 * 1 \\<le> d * c\n  1 \\<le> c\n  2 * d * c < 1\n  0 < d\n\ngoal (1 subgoal):\n 1. 1 \\<le> d * c", "by auto"], ["proof (state)\nthis:\n  1 \\<le> d * c\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "hence \"2 * d * c \\<ge> 2\""], ["proof (prove)\nusing this:\n  1 \\<le> d * c\n\ngoal (1 subgoal):\n 1. 2 \\<le> 2 * d * c", "by auto"], ["proof (state)\nthis:\n  2 \\<le> 2 * d * c\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  1 \\<le> c\n  2 * d * c < 1\n  0 < d\n  2 \\<le> 2 * d * c", "have False"], ["proof (prove)\nusing this:\n  1 \\<le> c\n  2 * d * c < 1\n  0 < d\n  2 \\<le> 2 * d * c\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  \\<lbrakk>1 \\<le> c; 2 * d * c < 1; 0 < d\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "note tedious = this"], ["proof (state)\nthis:\n  \\<lbrakk>1 \\<le> c; 2 * d * c < 1; 0 < d\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "have \"1 \\<le> factor_bound f ?d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> factor_bound f (degree_bound hs)", "using factor_bound[OF f, of 1 ?d 0]"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 dvd f; degree 1 \\<le> degree_bound hs\\<rbrakk>\n  \\<Longrightarrow> \\<bar>coeff 1 0\\<bar>\n                    \\<le> factor_bound f (degree_bound hs)\n\ngoal (1 subgoal):\n 1. 1 \\<le> factor_bound f (degree_bound hs)", "by auto"], ["proof (state)\nthis:\n  1 \\<le> factor_bound f (degree_bound hs)\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  1 \\<le> factor_bound f (degree_bound hs)\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factor_bound f (degree_bound hs) = 0", "using bnd"], ["proof (prove)\nusing this:\n  2 * \\<bar>lead_coeff f\\<bar> * factor_bound f (degree_bound hs) < p ^ n\n\ngoal (1 subgoal):\n 1. factor_bound f (degree_bound hs) = 0", "unfolding pn"], ["proof (prove)\nusing this:\n  2 * \\<bar>lead_coeff f\\<bar> * factor_bound f (degree_bound hs) < 1\n\ngoal (1 subgoal):\n 1. factor_bound f (degree_bound hs) = 0", "using factor_bound_ge_0[of f \"degree_bound hs\", OF f] lf"], ["proof (prove)\nusing this:\n  2 * \\<bar>lead_coeff f\\<bar> * factor_bound f (degree_bound hs) < 1\n  0 \\<le> factor_bound f (degree_bound hs)\n  0 < \\<bar>lead_coeff f\\<bar>\n\ngoal (1 subgoal):\n 1. factor_bound f (degree_bound hs) = 0", "unfolding c"], ["proof (prove)\nusing this:\n  2 * d * c < 1\n  0 \\<le> c\n  0 < d\n\ngoal (1 subgoal):\n 1. c = 0", "by (cases \"c \\<ge> 1\"; insert tedious, auto)"], ["proof (state)\nthis:\n  factor_bound f (degree_bound hs) = 0\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> 0", "show False"], ["proof (prove)\nusing this:\n  1 \\<le> 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation p: poly_mod_prime p"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_prime p", "using prime"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. poly_mod_prime p", "by unfold_locales"], ["", "lemma zassenhaus_reconstruction_generic:\n  assumes sl_impl: \"correct_subseqs_foldr_impl (\\<lambda>v. map_prod (poly_mod.mul_const (p^n) v) (Cons v)) sl_impl sli\"\n  and res: \"zassenhaus_reconstruction_generic sl_impl hs p n f = fs\" \n  shows \"f = prod_list fs \\<and> (\\<forall> fi \\<in> set fs. irreducible\\<^sub>d fi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "let ?lc = \"lead_coeff f\""], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "let ?ff = \"smult ?lc f\""], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "let ?q = \"p^n\""], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have p1: \"p > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < p", "using prime"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. 1 < p", "unfolding prime_int_iff"], ["proof (prove)\nusing this:\n  1 < p \\<and>\n  (\\<forall>m. 0 \\<le> m \\<and> m dvd p \\<longrightarrow> m = 1 \\<or> m = p)\n\ngoal (1 subgoal):\n 1. 1 < p", "by simp"], ["proof (state)\nthis:\n  1 < p\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "interpret poly_mod_2 \"p^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 (p ^ n)", "using p1 n"], ["proof (prove)\nusing this:\n  1 < p\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_mod_2 (p ^ n)", "unfolding poly_mod_2_def"], ["proof (prove)\nusing this:\n  1 < p\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 < p ^ n", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "obtain cands state where slc: \"subseqs_foldr sl_impl (lead_coeff f, []) hs 0 = (cands, state)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cands state.\n        subseqs_foldr sl_impl (lead_coeff f, []) hs 0 =\n        (cands, state) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  subseqs_foldr sl_impl (lead_coeff f, []) hs 0 = (cands, state)\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "interpret correct_subseqs_foldr_impl \"\\<lambda>x. map_prod (mul_const x) (Cons x)\" sl_impl sli"], ["proof (prove)\ngoal (1 subgoal):\n 1. correct_subseqs_foldr_impl (\\<lambda>x. map_prod (mul_const x) ((#) x))\n     sl_impl sli", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "from subseqs_foldr[OF slc]"], ["proof (chain)\npicking this:\n  sli (lead_coeff f, []) hs 0 state \\<and>\n  set cands = S (lead_coeff f, []) hs 0", "have state: \"sli (lead_coeff f, []) hs 0 state\""], ["proof (prove)\nusing this:\n  sli (lead_coeff f, []) hs 0 state \\<and>\n  set cands = S (lead_coeff f, []) hs 0\n\ngoal (1 subgoal):\n 1. sli (lead_coeff f, []) hs 0 state", "by auto"], ["proof (state)\nthis:\n  sli (lead_coeff f, []) hs 0 state\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "from res[unfolded zassenhaus_reconstruction_generic_def bh split Let_def slc fst_conv]"], ["proof (chain)\npicking this:\n  reconstruction sl_impl (p ^ n div 2) state f\n   (Polynomial.smult (lead_coeff f) f) (lead_coeff f) 0 (length hs) hs []\n   [] =\n  fs", "have res: \"reconstruction sl_impl (?q div 2) state f ?ff ?lc 0 (length hs) hs [] [] = fs\""], ["proof (prove)\nusing this:\n  reconstruction sl_impl (p ^ n div 2) state f\n   (Polynomial.smult (lead_coeff f) f) (lead_coeff f) 0 (length hs) hs []\n   [] =\n  fs\n\ngoal (1 subgoal):\n 1. reconstruction sl_impl (p ^ n div 2) state f\n     (Polynomial.smult (lead_coeff f) f) (lead_coeff f) 0 (length hs) hs []\n     [] =\n    fs", "by auto"], ["proof (state)\nthis:\n  reconstruction sl_impl (p ^ n div 2) state f\n   (Polynomial.smult (lead_coeff f) f) (lead_coeff f) 0 (length hs) hs []\n   [] =\n  fs\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "from p.berlekamp_hensel_unique[OF cop sf bh n]"], ["proof (chain)\npicking this:\n  unique_factorization_m f (lead_coeff f, mset hs)\n  ?g \\<in> set hs \\<Longrightarrow> Mp ?g = ?g", "have ufact: \"unique_factorization_m f (?lc, mset hs)\""], ["proof (prove)\nusing this:\n  unique_factorization_m f (lead_coeff f, mset hs)\n  ?g \\<in> set hs \\<Longrightarrow> Mp ?g = ?g\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (lead_coeff f, mset hs)", "by simp"], ["proof (state)\nthis:\n  unique_factorization_m f (lead_coeff f, mset hs)\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "note bh = p.berlekamp_hensel[OF cop sf bh n]"], ["proof (state)\nthis:\n  factorization_m f (lead_coeff f, mset hs)\n  ?g \\<in> set hs \\<Longrightarrow> Mp ?g = ?g \\<and> p.irreducible_m ?g\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "from deg"], ["proof (chain)\npicking this:\n  0 < degree f", "have f0: \"f \\<noteq> 0\" and lf0: \"?lc \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree f\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 &&& lead_coeff f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n  lead_coeff f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "hence ff0: \"?ff \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  lead_coeff f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Polynomial.smult (lead_coeff f) f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult (lead_coeff f) f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have bnd: \"\\<forall>g k. g dvd ?ff \\<longrightarrow> degree g \\<le> degree_bound hs \\<longrightarrow> 2 * \\<bar>coeff g k\\<bar> < p ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g k.\n       g dvd Polynomial.smult (lead_coeff f) f \\<longrightarrow>\n       degree g \\<le> degree_bound hs \\<longrightarrow>\n       2 * \\<bar>coeff g k\\<bar> < p ^ n", "proof (intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g k.\n       \\<lbrakk>g dvd Polynomial.smult (lead_coeff f) f;\n        degree g \\<le> degree_bound hs\\<rbrakk>\n       \\<Longrightarrow> 2 * \\<bar>coeff g k\\<bar> < p ^ n", "case (1 g k)"], ["proof (state)\nthis:\n  g dvd Polynomial.smult (lead_coeff f) f\n  degree g \\<le> degree_bound hs\n\ngoal (1 subgoal):\n 1. \\<And>g k.\n       \\<lbrakk>g dvd Polynomial.smult (lead_coeff f) f;\n        degree g \\<le> degree_bound hs\\<rbrakk>\n       \\<Longrightarrow> 2 * \\<bar>coeff g k\\<bar> < p ^ n", "from factor_bound_smult[OF f0 lf0 1, of k]"], ["proof (chain)\npicking this:\n  \\<bar>coeff g k\\<bar>\n  \\<le> \\<bar>lead_coeff f\\<bar> * factor_bound f (degree_bound hs)", "have \"\\<bar>coeff g k\\<bar> \\<le> \\<bar>?lc\\<bar> * factor_bound f (degree_bound hs)\""], ["proof (prove)\nusing this:\n  \\<bar>coeff g k\\<bar>\n  \\<le> \\<bar>lead_coeff f\\<bar> * factor_bound f (degree_bound hs)\n\ngoal (1 subgoal):\n 1. \\<bar>coeff g k\\<bar>\n    \\<le> \\<bar>lead_coeff f\\<bar> * factor_bound f (degree_bound hs)", "."], ["proof (state)\nthis:\n  \\<bar>coeff g k\\<bar>\n  \\<le> \\<bar>lead_coeff f\\<bar> * factor_bound f (degree_bound hs)\n\ngoal (1 subgoal):\n 1. \\<And>g k.\n       \\<lbrakk>g dvd Polynomial.smult (lead_coeff f) f;\n        degree g \\<le> degree_bound hs\\<rbrakk>\n       \\<Longrightarrow> 2 * \\<bar>coeff g k\\<bar> < p ^ n", "hence \"2 * \\<bar>coeff g k\\<bar> \\<le> 2 * \\<bar>?lc\\<bar> * factor_bound f (degree_bound hs)\""], ["proof (prove)\nusing this:\n  \\<bar>coeff g k\\<bar>\n  \\<le> \\<bar>lead_coeff f\\<bar> * factor_bound f (degree_bound hs)\n\ngoal (1 subgoal):\n 1. 2 * \\<bar>coeff g k\\<bar>\n    \\<le> 2 * \\<bar>lead_coeff f\\<bar> * factor_bound f (degree_bound hs)", "by auto"], ["proof (state)\nthis:\n  2 * \\<bar>coeff g k\\<bar>\n  \\<le> 2 * \\<bar>lead_coeff f\\<bar> * factor_bound f (degree_bound hs)\n\ngoal (1 subgoal):\n 1. \\<And>g k.\n       \\<lbrakk>g dvd Polynomial.smult (lead_coeff f) f;\n        degree g \\<le> degree_bound hs\\<rbrakk>\n       \\<Longrightarrow> 2 * \\<bar>coeff g k\\<bar> < p ^ n", "also"], ["proof (state)\nthis:\n  2 * \\<bar>coeff g k\\<bar>\n  \\<le> 2 * \\<bar>lead_coeff f\\<bar> * factor_bound f (degree_bound hs)\n\ngoal (1 subgoal):\n 1. \\<And>g k.\n       \\<lbrakk>g dvd Polynomial.smult (lead_coeff f) f;\n        degree g \\<le> degree_bound hs\\<rbrakk>\n       \\<Longrightarrow> 2 * \\<bar>coeff g k\\<bar> < p ^ n", "have \"\\<dots> < p^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * \\<bar>lead_coeff f\\<bar> * factor_bound f (degree_bound hs) < p ^ n", "using bnd"], ["proof (prove)\nusing this:\n  2 * \\<bar>lead_coeff f\\<bar> * factor_bound f (degree_bound hs) < p ^ n\n\ngoal (1 subgoal):\n 1. 2 * \\<bar>lead_coeff f\\<bar> * factor_bound f (degree_bound hs) < p ^ n", "."], ["proof (state)\nthis:\n  2 * \\<bar>lead_coeff f\\<bar> * factor_bound f (degree_bound hs) < p ^ n\n\ngoal (1 subgoal):\n 1. \\<And>g k.\n       \\<lbrakk>g dvd Polynomial.smult (lead_coeff f) f;\n        degree g \\<le> degree_bound hs\\<rbrakk>\n       \\<Longrightarrow> 2 * \\<bar>coeff g k\\<bar> < p ^ n", "finally"], ["proof (chain)\npicking this:\n  2 * \\<bar>coeff g k\\<bar> < p ^ n", "show ?case"], ["proof (prove)\nusing this:\n  2 * \\<bar>coeff g k\\<bar> < p ^ n\n\ngoal (1 subgoal):\n 1. 2 * \\<bar>coeff g k\\<bar> < p ^ n", "."], ["proof (state)\nthis:\n  2 * \\<bar>coeff g k\\<bar> < p ^ n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>g k.\n     g dvd Polynomial.smult (lead_coeff f) f \\<longrightarrow>\n     degree g \\<le> degree_bound hs \\<longrightarrow>\n     2 * \\<bar>coeff g k\\<bar> < p ^ n\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "note bh' = bh[unfolded factorization_m_def split]"], ["proof (state)\nthis:\n  f =m Polynomial.smult (lead_coeff f) (\\<Prod>\\<^sub># (mset hs)) \\<and>\n  (\\<forall>f\\<in>#mset hs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n  ?g \\<in> set hs \\<Longrightarrow> Mp ?g = ?g \\<and> p.irreducible_m ?g\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have deg_f: \"degree_m f = degree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m f = degree f", "using cop unique_factorization_m_zero [OF ufact] n"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n  M (lead_coeff f) \\<noteq> 0\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree_m f = degree f", "by (auto simp add: M_def intro: degree_m_eq [OF _ m1])"], ["proof (state)\nthis:\n  degree_m f = degree f\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have mon_hs: \"monic (prod_list hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (prod_list hs)", "using bh'"], ["proof (prove)\nusing this:\n  f =m Polynomial.smult (lead_coeff f) (\\<Prod>\\<^sub># (mset hs)) \\<and>\n  (\\<forall>f\\<in>#mset hs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n  ?g \\<in> set hs \\<Longrightarrow> Mp ?g = ?g \\<and> p.irreducible_m ?g\n\ngoal (1 subgoal):\n 1. monic (prod_list hs)", "by (auto intro: monic_prod_list)"], ["proof (state)\nthis:\n  monic (prod_list hs)\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have Mlc: \"M ?lc \\<in> {1 ..< p^n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (lead_coeff f) \\<in> {1..<p ^ n}", "by (rule prime_cop_exp_poly_mod[OF prime cop n])"], ["proof (state)\nthis:\n  M (lead_coeff f) \\<in> {1..<p ^ n}\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "hence \"?lc \\<noteq> 0\""], ["proof (prove)\nusing this:\n  M (lead_coeff f) \\<in> {1..<p ^ n}\n\ngoal (1 subgoal):\n 1. lead_coeff f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lead_coeff f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "hence f0: \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lead_coeff f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "have degm: \"degree_m (smult ?lc (prod_list hs)) = degree (smult ?lc (prod_list hs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m (Polynomial.smult (lead_coeff f) (prod_list hs)) =\n    degree (Polynomial.smult (lead_coeff f) (prod_list hs))", "by (rule degree_m_eq[OF _ m1], insert n bh mon_hs Mlc, auto simp: M_def)"], ["proof (state)\nthis:\n  degree_m (Polynomial.smult (lead_coeff f) (prod_list hs)) =\n  degree (Polynomial.smult (lead_coeff f) (prod_list hs))\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "from reconstruction[OF prime refl n sl_impl res _ refl _ refl _ refl refl ufact sf \n      cop _ _ _ deg _ bnd f0] bh(2) state"], ["proof (chain)\npicking this:\n  \\<lbrakk>f = f * prod_list []; 0 + 0 \\<le> length hs;\n   set [] \\<subseteq> S (lead_coeff f, []) hs 0;\n   \\<And>v. v \\<in> set hs \\<Longrightarrow> Mp v = v;\n   \\<And>ws.\n      \\<lbrakk>ws \\<subseteq># mset hs; ws \\<noteq> {#};\n       size ws < 0 \\<or>\n       size ws = 0 \\<and> ws \\<notin> (mset \\<circ> snd) ` set []\\<rbrakk>\n      \\<Longrightarrow> ??.local.test_dvd f ws;\n   \\<And>f. f \\<in> set [] \\<Longrightarrow> irreducible\\<^sub>d f;\n   [] \\<noteq> [] \\<Longrightarrow> 0 < length hs;\n   sli (lead_coeff f, []) hs 0 state; p ^ n div 2 = p ^ n div 2\\<rbrakk>\n  \\<Longrightarrow> f = prod_list fs \\<and>\n                    (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)\n  ?g \\<in> set hs \\<Longrightarrow> Mp ?g = ?g \\<and> p.irreducible_m ?g\n  sli (lead_coeff f, []) hs 0 state", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>f = f * prod_list []; 0 + 0 \\<le> length hs;\n   set [] \\<subseteq> S (lead_coeff f, []) hs 0;\n   \\<And>v. v \\<in> set hs \\<Longrightarrow> Mp v = v;\n   \\<And>ws.\n      \\<lbrakk>ws \\<subseteq># mset hs; ws \\<noteq> {#};\n       size ws < 0 \\<or>\n       size ws = 0 \\<and> ws \\<notin> (mset \\<circ> snd) ` set []\\<rbrakk>\n      \\<Longrightarrow> ??.local.test_dvd f ws;\n   \\<And>f. f \\<in> set [] \\<Longrightarrow> irreducible\\<^sub>d f;\n   [] \\<noteq> [] \\<Longrightarrow> 0 < length hs;\n   sli (lead_coeff f, []) hs 0 state; p ^ n div 2 = p ^ n div 2\\<rbrakk>\n  \\<Longrightarrow> f = prod_list fs \\<and>\n                    (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)\n  ?g \\<in> set hs \\<Longrightarrow> Mp ?g = ?g \\<and> p.irreducible_m ?g\n  sli (lead_coeff f, []) hs 0 state\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "by simp"], ["proof (state)\nthis:\n  f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zassenhaus_reconstruction_irreducible\\<^sub>d:\n  assumes res: \"zassenhaus_reconstruction hs p n f = fs\"\n  shows \"f = prod_list fs \\<and> (\\<forall> fi \\<in> set fs. irreducible\\<^sub>d fi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)", "by (rule zassenhaus_reconstruction_generic[OF my_subseqs.impl_correct \n      res[unfolded zassenhaus_reconstruction_def Let_def]])"], ["", "corollary zassenhaus_reconstruction:\n  assumes pr: \"primitive f\"\n  assumes res: \"zassenhaus_reconstruction hs p n f = fs\"\n  shows \"f = prod_list fs \\<and> (\\<forall> fi \\<in> set fs. irreducible fi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible fi)", "using zassenhaus_reconstruction_irreducible\\<^sub>d[OF res] pr\n    irreducible_primitive_connect[OF primitive_prod_list]"], ["proof (prove)\nusing this:\n  f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible\\<^sub>d fi)\n  primitive f\n  \\<lbrakk>primitive (prod_list ?fs1); ?f \\<in> set ?fs1\\<rbrakk>\n  \\<Longrightarrow> irreducible\\<^sub>d ?f = irreducible ?f\n\ngoal (1 subgoal):\n 1. f = prod_list fs \\<and> (\\<forall>fi\\<in>set fs. irreducible fi)", "by auto"], ["", "end"], ["", "end"]]}