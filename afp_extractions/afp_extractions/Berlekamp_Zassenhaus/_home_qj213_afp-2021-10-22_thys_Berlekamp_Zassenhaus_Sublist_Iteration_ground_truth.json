{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Sublist_Iteration.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma mem_snd_map: \"(\\<exists>x. (x, y) \\<in> S) \\<longleftrightarrow> y \\<in> snd ` S\"", "lemma filter_upt: assumes \"l \\<le> m\" \"m < n\" shows \"filter ((\\<le>) m) [l..<n] = [m..<n]\"", "lemma upt_append: \"i < j \\<Longrightarrow> j < k \\<Longrightarrow> [i..<j]@[j..<k] = [i..<k]\"", "lemma IArray_sub[simp]: \"(!!) as = (!) (IArray.list_of as)\"", "lemma subseqs_Cons[simp]: \"subseqs (x#xs) = map (Cons x) (subseqs xs) @ subseqs xs\"", "lemma singleton_mem_set_subseqs [simp]: \"[x] \\<in> set (subseqs xs) \\<longleftrightarrow> x \\<in> set xs\"", "lemma Cons_mem_set_subseqsD: \"y#ys \\<in> set (subseqs xs) \\<Longrightarrow> y \\<in> set xs\"", "lemma subseqs_subset: \"ys \\<in> set (subseqs xs) \\<Longrightarrow> set ys \\<subseteq> set xs\"", "lemma Cons_mem_set_subseqs_Cons:\n  \"y#ys \\<in> set (subseqs (x#xs)) \\<longleftrightarrow> (y = x \\<and> ys \\<in> set (subseqs xs)) \\<or> y#ys \\<in> set (subseqs xs)\"", "lemma sorted_subseqs_sorted:\n  \"sorted xs \\<Longrightarrow> ys \\<in> set (subseqs xs) \\<Longrightarrow> sorted ys\"", "lemma subseqs_of_subseq: \"ys \\<in> set (subseqs xs) \\<Longrightarrow> set (subseqs ys) \\<subseteq> set (subseqs xs)\"", "lemma mem_set_subseqs_append: \"xs \\<in> set (subseqs ys) \\<Longrightarrow> xs \\<in> set (subseqs (zs @ ys))\"", "lemma Cons_mem_set_subseqs_append:\n  \"x \\<in> set ys \\<Longrightarrow> xs \\<in> set (subseqs zs) \\<Longrightarrow> x#xs \\<in> set (subseqs (ys@zs))\"", "lemma Cons_mem_set_subseqs_sorted:\n  \"sorted xs \\<Longrightarrow> y#ys \\<in> set (subseqs xs) \\<Longrightarrow> y#ys \\<in> set (subseqs (filter (\\<lambda>x. y \\<le> x) xs))\"", "lemma subseqs_map[simp]: \"subseqs (map f xs) = map (map f) (subseqs xs)\"", "lemma subseqs_of_indices: \"map (map (nth xs)) (subseqs [0..<length xs]) = subseqs xs\"", "lemma subseq_of_lengthI[intro]:\n  assumes \"ys \\<in> set (subseqs xs)\" \"length ys = n\"\n  shows \"subseq_of_length n xs ys\"", "lemma subseq_of_lengthD[dest]:\n  assumes \"subseq_of_length n xs ys\"\n  shows \"ys \\<in> set (subseqs xs)\" \"length ys = n\"", "lemma subseq_of_length0[simp]: \"subseq_of_length 0 xs ys \\<longleftrightarrow> ys = []\"", "lemma subseq_of_length_Nil[simp]: \"subseq_of_length n [] ys \\<longleftrightarrow> n = 0 \\<and> ys = []\"", "lemma subseq_of_length_Suc_upt:\n  \"subseq_of_length (Suc n) [0..<m] xs \\<longleftrightarrow>\n   (if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs))\" (is \"?l \\<longleftrightarrow> ?r\")", "lemma subseqs_of_length_of_indices:\n  \"{ ys. subseq_of_length n xs ys } = { map (nth xs) is | is. subseq_of_length n [0..<length xs] is }\"", "lemma subseqs_of_length_Suc_Cons:\n  \"{ ys. subseq_of_length (Suc n) (x#xs) ys } =\n   Cons x ` { ys. subseq_of_length n xs ys } \\<union> { ys. subseq_of_length (Suc n) xs ys }\"", "lemma subseqs_length: assumes f_ac: \"\\<And> x y z. f x (f y z) = f y (f x z)\" \n  shows \"set (subseqs_length f a n xs) = \n  { (foldr f ys a, ys) | ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\"", "lemma basic_subseqs_impl: assumes f_ac: \"\\<And> x y z. f x (f y z) = f y (f x z)\"\n  shows \"correct_subseqs_impl f (basic_subseqs_impl f) \n    (\\<lambda> a xs n triple. (a,xs,n) = triple)\"", "lemma next_subseqs2_Cons:\n  \"next_subseqs2_set v (j#js) = insert (j, f (tail!!j) v) (next_subseqs2_set v js)\"", "lemma out_subseqs2_Cons:\n  \"out_subseqs2_set v (j#js) = insert (f (tail!!j) v) (out_subseqs2_set v js)\"", "lemma next_subseqs1_set_as_next_subseqs2_set:\n  \"next_subseqs1_set ((i,v) # prevs) = next_subseqs1_set prevs \\<union> next_subseqs2_set v [0..<i]\"", "lemma out_subseqs1_set_as_out_subseqs2_set:\n  \"out_subseqs1_set ((i,v) # prevs) =\n   { f head v } \\<union> out_subseqs1_set prevs \\<union> out_subseqs2_set v [0..<i]\"", "lemma next_subseqs1_spec:\n  shows \"\\<And>out nexts. next_subseqs1_spec out nexts prevs (next_subseqs1 out nexts prevs)\"\n    and \"\\<And>out nexts. next_subseqs2_spec out nexts prevs v js (next_subseqs2 out nexts prevs v js)\"", "lemma snd_set_prevs:\n  \"snd ` (set_prevs base tail n) = (\\<lambda>as. foldr f as base) ` { as. subseq_of_length n tail as }\"", "lemma next_subseq_preserve:\n  assumes \"next_subseqs (head,tail,prevs) = (out, (head',tail',prevs'))\"\n  shows \"head' = head\" \"tail' = tail\"", "lemma next_subseqs_spec:\n  assumes nxt: \"next_subseqs (head,tail,prevs) = (out, (head',tail',prevs'))\"\n  shows \"set prevs' = { (j, f (tail !! j) v) | v i j. (i,v) \\<in> set prevs \\<and> j < i }\" (is \"?g1\")\n    and \"set out = (f head \\<circ> snd) ` set prevs \\<union> snd ` set prevs'\" (is \"?g2\")", "lemma next_subseq_prevs:\n  assumes nxt: \"next_subseqs (head,tail,prevs) = (out, (head',tail',prevs'))\"\n      and inv_prevs: \"set prevs = set_prevs base (IArray.list_of tail) n\"\n  shows \"set prevs' = set_prevs base (IArray.list_of tail) (Suc n)\" (is \"?l = ?r\")", "lemma invariant_next_subseqs:\n  assumes inv: \"invariant base elements n state\"\n      and nxt: \"next_subseqs state = (out, state')\"\n  shows \"invariant base elements (Suc n) state'\"", "lemma out_next_subseqs:\n  assumes inv: \"invariant base elements n state\"\n      and nxt: \"next_subseqs state = (out, state')\"\n  shows \"set out = S base elements (Suc n)\"", "lemma create_subseqs:\n  \"create_subseqs base elements n = (out, state) \\<Longrightarrow>\n   invariant base elements n state \\<and> set out = S base elements n\"", "lemma impl_correct: \"correct_subseqs_foldr_impl f impl invariant\"", "lemmas [code] =\n  my_subseqs.next_subseqs.simps\n  my_subseqs.next_subseqs1.simps\n  my_subseqs.next_subseqs2.simps\n  my_subseqs.create_subseqs.simps\n  my_subseqs.impl_def"], "translations": [["", "lemma mem_snd_map: \"(\\<exists>x. (x, y) \\<in> S) \\<longleftrightarrow> y \\<in> snd ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. (x, y) \\<in> S) = (y \\<in> snd ` S)", "by force"], ["", "lemma filter_upt: assumes \"l \\<le> m\" \"m < n\" shows \"filter ((\\<le>) m) [l..<n] = [m..<n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter ((\\<le>) m) [l..<n] = [m..<n]", "proof(insert assms, induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>l \\<le> m; m < 0\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<le>) m) [l..<0] = [m..<0]\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>l \\<le> m; m < n\\<rbrakk>\n                \\<Longrightarrow> filter ((\\<le>) m) [l..<n] = [m..<n];\n        l \\<le> m; m < Suc n\\<rbrakk>\n       \\<Longrightarrow> filter ((\\<le>) m) [l..<Suc n] = [m..<Suc n]", "case 0"], ["proof (state)\nthis:\n  l \\<le> m\n  m < 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l \\<le> m; m < 0\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<le>) m) [l..<0] = [m..<0]\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>l \\<le> m; m < n\\<rbrakk>\n                \\<Longrightarrow> filter ((\\<le>) m) [l..<n] = [m..<n];\n        l \\<le> m; m < Suc n\\<rbrakk>\n       \\<Longrightarrow> filter ((\\<le>) m) [l..<Suc n] = [m..<Suc n]", "then"], ["proof (chain)\npicking this:\n  l \\<le> m\n  m < 0", "show ?case"], ["proof (prove)\nusing this:\n  l \\<le> m\n  m < 0\n\ngoal (1 subgoal):\n 1. filter ((\\<le>) m) [l..<0] = [m..<0]", "by auto"], ["proof (state)\nthis:\n  filter ((\\<le>) m) [l..<0] = [m..<0]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>l \\<le> m; m < n\\<rbrakk>\n                \\<Longrightarrow> filter ((\\<le>) m) [l..<n] = [m..<n];\n        l \\<le> m; m < Suc n\\<rbrakk>\n       \\<Longrightarrow> filter ((\\<le>) m) [l..<Suc n] = [m..<Suc n]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>l \\<le> m; m < n\\<rbrakk>\n                \\<Longrightarrow> filter ((\\<le>) m) [l..<n] = [m..<n];\n        l \\<le> m; m < Suc n\\<rbrakk>\n       \\<Longrightarrow> filter ((\\<le>) m) [l..<Suc n] = [m..<Suc n]", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>l \\<le> m; m < n\\<rbrakk>\n  \\<Longrightarrow> filter ((\\<le>) m) [l..<n] = [m..<n]\n  l \\<le> m\n  m < Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>l \\<le> m; m < n\\<rbrakk>\n                \\<Longrightarrow> filter ((\\<le>) m) [l..<n] = [m..<n];\n        l \\<le> m; m < Suc n\\<rbrakk>\n       \\<Longrightarrow> filter ((\\<le>) m) [l..<Suc n] = [m..<Suc n]", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>l \\<le> m; m < n\\<rbrakk>\n  \\<Longrightarrow> filter ((\\<le>) m) [l..<n] = [m..<n]\n  l \\<le> m\n  m < Suc n", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>l \\<le> m; m < n\\<rbrakk>\n  \\<Longrightarrow> filter ((\\<le>) m) [l..<n] = [m..<n]\n  l \\<le> m\n  m < Suc n\n\ngoal (1 subgoal):\n 1. filter ((\\<le>) m) [l..<Suc n] = [m..<Suc n]", "by (cases \"m = n\", auto)"], ["proof (state)\nthis:\n  filter ((\\<le>) m) [l..<Suc n] = [m..<Suc n]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upt_append: \"i < j \\<Longrightarrow> j < k \\<Longrightarrow> [i..<j]@[j..<k] = [i..<k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j < k\\<rbrakk>\n    \\<Longrightarrow> [i..<j] @ [j..<k] = [i..<k]", "proof(induct k arbitrary: j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>i < j; j < 0\\<rbrakk>\n       \\<Longrightarrow> [i..<j] @ [j..<0] = [i..<0]\n 2. \\<And>k j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>i < j; j < k\\<rbrakk>\n                   \\<Longrightarrow> [i..<j] @ [j..<k] = [i..<k];\n        i < j; j < Suc k\\<rbrakk>\n       \\<Longrightarrow> [i..<j] @ [j..<Suc k] = [i..<Suc k]", "case 0"], ["proof (state)\nthis:\n  i < j\n  j < 0\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>i < j; j < 0\\<rbrakk>\n       \\<Longrightarrow> [i..<j] @ [j..<0] = [i..<0]\n 2. \\<And>k j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>i < j; j < k\\<rbrakk>\n                   \\<Longrightarrow> [i..<j] @ [j..<k] = [i..<k];\n        i < j; j < Suc k\\<rbrakk>\n       \\<Longrightarrow> [i..<j] @ [j..<Suc k] = [i..<Suc k]", "then"], ["proof (chain)\npicking this:\n  i < j\n  j < 0", "show ?case"], ["proof (prove)\nusing this:\n  i < j\n  j < 0\n\ngoal (1 subgoal):\n 1. [i..<j] @ [j..<0] = [i..<0]", "by auto"], ["proof (state)\nthis:\n  [i..<j] @ [j..<0] = [i..<0]\n\ngoal (1 subgoal):\n 1. \\<And>k j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>i < j; j < k\\<rbrakk>\n                   \\<Longrightarrow> [i..<j] @ [j..<k] = [i..<k];\n        i < j; j < Suc k\\<rbrakk>\n       \\<Longrightarrow> [i..<j] @ [j..<Suc k] = [i..<Suc k]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>i < j; j < k\\<rbrakk>\n                   \\<Longrightarrow> [i..<j] @ [j..<k] = [i..<k];\n        i < j; j < Suc k\\<rbrakk>\n       \\<Longrightarrow> [i..<j] @ [j..<Suc k] = [i..<Suc k]", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>i < ?j; ?j < k\\<rbrakk>\n  \\<Longrightarrow> [i..<?j] @ [?j..<k] = [i..<k]\n  i < j\n  j < Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>i < j; j < k\\<rbrakk>\n                   \\<Longrightarrow> [i..<j] @ [j..<k] = [i..<k];\n        i < j; j < Suc k\\<rbrakk>\n       \\<Longrightarrow> [i..<j] @ [j..<Suc k] = [i..<Suc k]", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < ?j; ?j < k\\<rbrakk>\n  \\<Longrightarrow> [i..<?j] @ [?j..<k] = [i..<k]\n  i < j\n  j < Suc k", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < ?j; ?j < k\\<rbrakk>\n  \\<Longrightarrow> [i..<?j] @ [?j..<k] = [i..<k]\n  i < j\n  j < Suc k\n\ngoal (1 subgoal):\n 1. [i..<j] @ [j..<Suc k] = [i..<Suc k]", "by (cases \"j = k\", auto)"], ["proof (state)\nthis:\n  [i..<j] @ [j..<Suc k] = [i..<Suc k]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma IArray_sub[simp]: \"(!!) as = (!) (IArray.list_of as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (!!) as = (!) (IArray.list_of as)", "by auto"], ["", "declare IArray.sub_def[simp del]"], ["", "text \\<open>Following lemmas in this section are for @{const subseqs}\\<close>"], ["", "lemma subseqs_Cons[simp]: \"subseqs (x#xs) = map (Cons x) (subseqs xs) @ subseqs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subseqs (x # xs) = map ((#) x) (subseqs xs) @ subseqs xs", "by (simp add: Let_def)"], ["", "declare subseqs.simps(2) [simp del]"], ["", "lemma singleton_mem_set_subseqs [simp]: \"[x] \\<in> set (subseqs xs) \\<longleftrightarrow> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([x] \\<in> set (subseqs xs)) = (x \\<in> set xs)", "by (induct xs, auto)"], ["", "lemma Cons_mem_set_subseqsD: \"y#ys \\<in> set (subseqs xs) \\<Longrightarrow> y \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y # ys \\<in> set (subseqs xs) \\<Longrightarrow> y \\<in> set xs", "by (induct xs, auto)"], ["", "lemma subseqs_subset: \"ys \\<in> set (subseqs xs) \\<Longrightarrow> set ys \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> set (subseqs xs) \\<Longrightarrow> set ys \\<subseteq> set xs", "by (metis Pow_iff image_eqI subseqs_powset)"], ["", "lemma Cons_mem_set_subseqs_Cons:\n  \"y#ys \\<in> set (subseqs (x#xs)) \\<longleftrightarrow> (y = x \\<and> ys \\<in> set (subseqs xs)) \\<or> y#ys \\<in> set (subseqs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y # ys \\<in> set (subseqs (x # xs))) =\n    (y = x \\<and> ys \\<in> set (subseqs xs) \\<or>\n     y # ys \\<in> set (subseqs xs))", "by auto"], ["", "lemma sorted_subseqs_sorted:\n  \"sorted xs \\<Longrightarrow> ys \\<in> set (subseqs xs) \\<Longrightarrow> sorted ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs; ys \\<in> set (subseqs xs)\\<rbrakk>\n    \\<Longrightarrow> sorted ys", "proof(induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>sorted []; ys \\<in> set (subseqs [])\\<rbrakk>\n       \\<Longrightarrow> sorted ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>sorted xs; ys \\<in> set (subseqs xs)\\<rbrakk>\n                   \\<Longrightarrow> sorted ys;\n        sorted (a # xs); ys \\<in> set (subseqs (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted ys", "case Nil"], ["proof (state)\nthis:\n  sorted []\n  ys \\<in> set (subseqs [])\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>sorted []; ys \\<in> set (subseqs [])\\<rbrakk>\n       \\<Longrightarrow> sorted ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>sorted xs; ys \\<in> set (subseqs xs)\\<rbrakk>\n                   \\<Longrightarrow> sorted ys;\n        sorted (a # xs); ys \\<in> set (subseqs (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted ys", "thus ?case"], ["proof (prove)\nusing this:\n  sorted []\n  ys \\<in> set (subseqs [])\n\ngoal (1 subgoal):\n 1. sorted ys", "by simp"], ["proof (state)\nthis:\n  sorted ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>sorted xs; ys \\<in> set (subseqs xs)\\<rbrakk>\n                   \\<Longrightarrow> sorted ys;\n        sorted (a # xs); ys \\<in> set (subseqs (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>sorted xs; ys \\<in> set (subseqs xs)\\<rbrakk>\n                   \\<Longrightarrow> sorted ys;\n        sorted (a # xs); ys \\<in> set (subseqs (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted ys", "case Cons"], ["proof (state)\nthis:\n  \\<lbrakk>sorted xs_; ?ys \\<in> set (subseqs xs_)\\<rbrakk>\n  \\<Longrightarrow> sorted ?ys\n  sorted (a_ # xs_)\n  ys \\<in> set (subseqs (a_ # xs_))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>sorted xs; ys \\<in> set (subseqs xs)\\<rbrakk>\n                   \\<Longrightarrow> sorted ys;\n        sorted (a # xs); ys \\<in> set (subseqs (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted ys", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted xs_; ?ys \\<in> set (subseqs xs_)\\<rbrakk>\n  \\<Longrightarrow> sorted ?ys\n  sorted (a_ # xs_)\n  ys \\<in> set (subseqs (a_ # xs_))\n\ngoal (1 subgoal):\n 1. sorted ys", "using subseqs_subset"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted xs_; ?ys \\<in> set (subseqs xs_)\\<rbrakk>\n  \\<Longrightarrow> sorted ?ys\n  sorted (a_ # xs_)\n  ys \\<in> set (subseqs (a_ # xs_))\n  ?ys \\<in> set (subseqs ?xs) \\<Longrightarrow> set ?ys \\<subseteq> set ?xs\n\ngoal (1 subgoal):\n 1. sorted ys", "by fastforce"], ["proof (state)\nthis:\n  sorted ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subseqs_of_subseq: \"ys \\<in> set (subseqs xs) \\<Longrightarrow> set (subseqs ys) \\<subseteq> set (subseqs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> set (subseqs xs) \\<Longrightarrow>\n    set (subseqs ys) \\<subseteq> set (subseqs xs)", "proof(induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       ys \\<in> set (subseqs []) \\<Longrightarrow>\n       set (subseqs ys) \\<subseteq> set (subseqs [])\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   ys \\<in> set (subseqs xs) \\<Longrightarrow>\n                   set (subseqs ys) \\<subseteq> set (subseqs xs);\n        ys \\<in> set (subseqs (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (subseqs ys) \\<subseteq> set (subseqs (a # xs))", "case Nil"], ["proof (state)\nthis:\n  ys \\<in> set (subseqs [])\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       ys \\<in> set (subseqs []) \\<Longrightarrow>\n       set (subseqs ys) \\<subseteq> set (subseqs [])\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   ys \\<in> set (subseqs xs) \\<Longrightarrow>\n                   set (subseqs ys) \\<subseteq> set (subseqs xs);\n        ys \\<in> set (subseqs (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (subseqs ys) \\<subseteq> set (subseqs (a # xs))", "then"], ["proof (chain)\npicking this:\n  ys \\<in> set (subseqs [])", "show ?case"], ["proof (prove)\nusing this:\n  ys \\<in> set (subseqs [])\n\ngoal (1 subgoal):\n 1. set (subseqs ys) \\<subseteq> set (subseqs [])", "by auto"], ["proof (state)\nthis:\n  set (subseqs ys) \\<subseteq> set (subseqs [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   ys \\<in> set (subseqs xs) \\<Longrightarrow>\n                   set (subseqs ys) \\<subseteq> set (subseqs xs);\n        ys \\<in> set (subseqs (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (subseqs ys) \\<subseteq> set (subseqs (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   ys \\<in> set (subseqs xs) \\<Longrightarrow>\n                   set (subseqs ys) \\<subseteq> set (subseqs xs);\n        ys \\<in> set (subseqs (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (subseqs ys) \\<subseteq> set (subseqs (a # xs))", "case IHx: (Cons x xs)"], ["proof (state)\nthis:\n  ?ys \\<in> set (subseqs xs) \\<Longrightarrow>\n  set (subseqs ?ys) \\<subseteq> set (subseqs xs)\n  ys \\<in> set (subseqs (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   ys \\<in> set (subseqs xs) \\<Longrightarrow>\n                   set (subseqs ys) \\<subseteq> set (subseqs xs);\n        ys \\<in> set (subseqs (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (subseqs ys) \\<subseteq> set (subseqs (a # xs))", "from IHx.prems"], ["proof (chain)\npicking this:\n  ys \\<in> set (subseqs (x # xs))", "show ?case"], ["proof (prove)\nusing this:\n  ys \\<in> set (subseqs (x # xs))\n\ngoal (1 subgoal):\n 1. set (subseqs ys) \\<subseteq> set (subseqs (x # xs))", "proof(induct ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> set (subseqs (x # xs)) \\<Longrightarrow>\n    set (subseqs []) \\<subseteq> set (subseqs (x # xs))\n 2. \\<And>a ys.\n       \\<lbrakk>ys \\<in> set (subseqs (x # xs)) \\<Longrightarrow>\n                set (subseqs ys) \\<subseteq> set (subseqs (x # xs));\n        a # ys \\<in> set (subseqs (x # xs))\\<rbrakk>\n       \\<Longrightarrow> set (subseqs (a # ys))\n                         \\<subseteq> set (subseqs (x # xs))", "case Nil"], ["proof (state)\nthis:\n  [] \\<in> set (subseqs (x # xs))\n\ngoal (2 subgoals):\n 1. [] \\<in> set (subseqs (x # xs)) \\<Longrightarrow>\n    set (subseqs []) \\<subseteq> set (subseqs (x # xs))\n 2. \\<And>a ys.\n       \\<lbrakk>ys \\<in> set (subseqs (x # xs)) \\<Longrightarrow>\n                set (subseqs ys) \\<subseteq> set (subseqs (x # xs));\n        a # ys \\<in> set (subseqs (x # xs))\\<rbrakk>\n       \\<Longrightarrow> set (subseqs (a # ys))\n                         \\<subseteq> set (subseqs (x # xs))", "then"], ["proof (chain)\npicking this:\n  [] \\<in> set (subseqs (x # xs))", "show ?case"], ["proof (prove)\nusing this:\n  [] \\<in> set (subseqs (x # xs))\n\ngoal (1 subgoal):\n 1. set (subseqs []) \\<subseteq> set (subseqs (x # xs))", "by auto"], ["proof (state)\nthis:\n  set (subseqs []) \\<subseteq> set (subseqs (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>ys \\<in> set (subseqs (x # xs)) \\<Longrightarrow>\n                set (subseqs ys) \\<subseteq> set (subseqs (x # xs));\n        a # ys \\<in> set (subseqs (x # xs))\\<rbrakk>\n       \\<Longrightarrow> set (subseqs (a # ys))\n                         \\<subseteq> set (subseqs (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>ys \\<in> set (subseqs (x # xs)) \\<Longrightarrow>\n                set (subseqs ys) \\<subseteq> set (subseqs (x # xs));\n        a # ys \\<in> set (subseqs (x # xs))\\<rbrakk>\n       \\<Longrightarrow> set (subseqs (a # ys))\n                         \\<subseteq> set (subseqs (x # xs))", "case IHy: (Cons y ys)"], ["proof (state)\nthis:\n  ys \\<in> set (subseqs (x # xs)) \\<Longrightarrow>\n  set (subseqs ys) \\<subseteq> set (subseqs (x # xs))\n  y # ys \\<in> set (subseqs (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>ys \\<in> set (subseqs (x # xs)) \\<Longrightarrow>\n                set (subseqs ys) \\<subseteq> set (subseqs (x # xs));\n        a # ys \\<in> set (subseqs (x # xs))\\<rbrakk>\n       \\<Longrightarrow> set (subseqs (a # ys))\n                         \\<subseteq> set (subseqs (x # xs))", "from IHy.prems[unfolded subseqs_Cons]"], ["proof (chain)\npicking this:\n  y # ys \\<in> set (map ((#) x) (subseqs xs) @ subseqs xs)", "consider \"y = x\" \"ys \\<in> set (subseqs xs)\" | \"y # ys \\<in> set (subseqs xs)\""], ["proof (prove)\nusing this:\n  y # ys \\<in> set (map ((#) x) (subseqs xs) @ subseqs xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>y = x; ys \\<in> set (subseqs xs)\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     y # ys \\<in> set (subseqs xs) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>y = x; ys \\<in> set (subseqs xs)\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   y # ys \\<in> set (subseqs xs) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>ys \\<in> set (subseqs (x # xs)) \\<Longrightarrow>\n                set (subseqs ys) \\<subseteq> set (subseqs (x # xs));\n        a # ys \\<in> set (subseqs (x # xs))\\<rbrakk>\n       \\<Longrightarrow> set (subseqs (a # ys))\n                         \\<subseteq> set (subseqs (x # xs))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<lbrakk>y = x; ys \\<in> set (subseqs xs)\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   y # ys \\<in> set (subseqs xs) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>y = x; ys \\<in> set (subseqs xs)\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   y # ys \\<in> set (subseqs xs) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. set (subseqs (y # ys)) \\<subseteq> set (subseqs (x # xs))", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = x; ys \\<in> set (subseqs xs)\\<rbrakk>\n    \\<Longrightarrow> set (subseqs (y # ys))\n                      \\<subseteq> set (subseqs (x # xs))\n 2. y # ys \\<in> set (subseqs xs) \\<Longrightarrow>\n    set (subseqs (y # ys)) \\<subseteq> set (subseqs (x # xs))", "case 1"], ["proof (state)\nthis:\n  y = x\n  ys \\<in> set (subseqs xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y = x; ys \\<in> set (subseqs xs)\\<rbrakk>\n    \\<Longrightarrow> set (subseqs (y # ys))\n                      \\<subseteq> set (subseqs (x # xs))\n 2. y # ys \\<in> set (subseqs xs) \\<Longrightarrow>\n    set (subseqs (y # ys)) \\<subseteq> set (subseqs (x # xs))", "with IHx.hyps"], ["proof (chain)\npicking this:\n  ?ys \\<in> set (subseqs xs) \\<Longrightarrow>\n  set (subseqs ?ys) \\<subseteq> set (subseqs xs)\n  y = x\n  ys \\<in> set (subseqs xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?ys \\<in> set (subseqs xs) \\<Longrightarrow>\n  set (subseqs ?ys) \\<subseteq> set (subseqs xs)\n  y = x\n  ys \\<in> set (subseqs xs)\n\ngoal (1 subgoal):\n 1. set (subseqs (y # ys)) \\<subseteq> set (subseqs (x # xs))", "by auto"], ["proof (state)\nthis:\n  set (subseqs (y # ys)) \\<subseteq> set (subseqs (x # xs))\n\ngoal (1 subgoal):\n 1. y # ys \\<in> set (subseqs xs) \\<Longrightarrow>\n    set (subseqs (y # ys)) \\<subseteq> set (subseqs (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y # ys \\<in> set (subseqs xs) \\<Longrightarrow>\n    set (subseqs (y # ys)) \\<subseteq> set (subseqs (x # xs))", "case 2"], ["proof (state)\nthis:\n  y # ys \\<in> set (subseqs xs)\n\ngoal (1 subgoal):\n 1. y # ys \\<in> set (subseqs xs) \\<Longrightarrow>\n    set (subseqs (y # ys)) \\<subseteq> set (subseqs (x # xs))", "from IHx.hyps[OF this]"], ["proof (chain)\npicking this:\n  set (subseqs (y # ys)) \\<subseteq> set (subseqs xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (subseqs (y # ys)) \\<subseteq> set (subseqs xs)\n\ngoal (1 subgoal):\n 1. set (subseqs (y # ys)) \\<subseteq> set (subseqs (x # xs))", "by auto"], ["proof (state)\nthis:\n  set (subseqs (y # ys)) \\<subseteq> set (subseqs (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (subseqs (y # ys)) \\<subseteq> set (subseqs (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (subseqs ys) \\<subseteq> set (subseqs (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mem_set_subseqs_append: \"xs \\<in> set (subseqs ys) \\<Longrightarrow> xs \\<in> set (subseqs (zs @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> set (subseqs ys) \\<Longrightarrow>\n    xs \\<in> set (subseqs (zs @ ys))", "by (induct zs, auto)"], ["", "lemma Cons_mem_set_subseqs_append:\n  \"x \\<in> set ys \\<Longrightarrow> xs \\<in> set (subseqs zs) \\<Longrightarrow> x#xs \\<in> set (subseqs (ys@zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set ys; xs \\<in> set (subseqs zs)\\<rbrakk>\n    \\<Longrightarrow> x # xs \\<in> set (subseqs (ys @ zs))", "proof(induct ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set []; xs \\<in> set (subseqs zs)\\<rbrakk>\n    \\<Longrightarrow> x # xs \\<in> set (subseqs ([] @ zs))\n 2. \\<And>a ys.\n       \\<lbrakk>\\<lbrakk>x \\<in> set ys; xs \\<in> set (subseqs zs)\\<rbrakk>\n                \\<Longrightarrow> x # xs \\<in> set (subseqs (ys @ zs));\n        x \\<in> set (a # ys); xs \\<in> set (subseqs zs)\\<rbrakk>\n       \\<Longrightarrow> x # xs \\<in> set (subseqs ((a # ys) @ zs))", "case Nil"], ["proof (state)\nthis:\n  x \\<in> set []\n  xs \\<in> set (subseqs zs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set []; xs \\<in> set (subseqs zs)\\<rbrakk>\n    \\<Longrightarrow> x # xs \\<in> set (subseqs ([] @ zs))\n 2. \\<And>a ys.\n       \\<lbrakk>\\<lbrakk>x \\<in> set ys; xs \\<in> set (subseqs zs)\\<rbrakk>\n                \\<Longrightarrow> x # xs \\<in> set (subseqs (ys @ zs));\n        x \\<in> set (a # ys); xs \\<in> set (subseqs zs)\\<rbrakk>\n       \\<Longrightarrow> x # xs \\<in> set (subseqs ((a # ys) @ zs))", "then"], ["proof (chain)\npicking this:\n  x \\<in> set []\n  xs \\<in> set (subseqs zs)", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> set []\n  xs \\<in> set (subseqs zs)\n\ngoal (1 subgoal):\n 1. x # xs \\<in> set (subseqs ([] @ zs))", "by auto"], ["proof (state)\nthis:\n  x # xs \\<in> set (subseqs ([] @ zs))\n\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>\\<lbrakk>x \\<in> set ys; xs \\<in> set (subseqs zs)\\<rbrakk>\n                \\<Longrightarrow> x # xs \\<in> set (subseqs (ys @ zs));\n        x \\<in> set (a # ys); xs \\<in> set (subseqs zs)\\<rbrakk>\n       \\<Longrightarrow> x # xs \\<in> set (subseqs ((a # ys) @ zs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>\\<lbrakk>x \\<in> set ys; xs \\<in> set (subseqs zs)\\<rbrakk>\n                \\<Longrightarrow> x # xs \\<in> set (subseqs (ys @ zs));\n        x \\<in> set (a # ys); xs \\<in> set (subseqs zs)\\<rbrakk>\n       \\<Longrightarrow> x # xs \\<in> set (subseqs ((a # ys) @ zs))", "case IH: (Cons y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> set ys; xs \\<in> set (subseqs zs)\\<rbrakk>\n  \\<Longrightarrow> x # xs \\<in> set (subseqs (ys @ zs))\n  x \\<in> set (y # ys)\n  xs \\<in> set (subseqs zs)\n\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>\\<lbrakk>x \\<in> set ys; xs \\<in> set (subseqs zs)\\<rbrakk>\n                \\<Longrightarrow> x # xs \\<in> set (subseqs (ys @ zs));\n        x \\<in> set (a # ys); xs \\<in> set (subseqs zs)\\<rbrakk>\n       \\<Longrightarrow> x # xs \\<in> set (subseqs ((a # ys) @ zs))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> set ys; xs \\<in> set (subseqs zs)\\<rbrakk>\n  \\<Longrightarrow> x # xs \\<in> set (subseqs (ys @ zs))\n  x \\<in> set (y # ys)\n  xs \\<in> set (subseqs zs)", "consider \"x = y\" | \"x \\<in> set ys\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> set ys; xs \\<in> set (subseqs zs)\\<rbrakk>\n  \\<Longrightarrow> x # xs \\<in> set (subseqs (ys @ zs))\n  x \\<in> set (y # ys)\n  xs \\<in> set (subseqs zs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = y \\<Longrightarrow> thesis;\n     x \\<in> set ys \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>x = y \\<Longrightarrow> ?thesis;\n   x \\<in> set ys \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>\\<lbrakk>x \\<in> set ys; xs \\<in> set (subseqs zs)\\<rbrakk>\n                \\<Longrightarrow> x # xs \\<in> set (subseqs (ys @ zs));\n        x \\<in> set (a # ys); xs \\<in> set (subseqs zs)\\<rbrakk>\n       \\<Longrightarrow> x # xs \\<in> set (subseqs ((a # ys) @ zs))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = y \\<Longrightarrow> ?thesis;\n   x \\<in> set ys \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = y \\<Longrightarrow> ?thesis;\n   x \\<in> set ys \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. x # xs \\<in> set (subseqs ((y # ys) @ zs))", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> x # xs \\<in> set (subseqs ((y # ys) @ zs))\n 2. x \\<in> set ys \\<Longrightarrow>\n    x # xs \\<in> set (subseqs ((y # ys) @ zs))", "case 1"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> x # xs \\<in> set (subseqs ((y # ys) @ zs))\n 2. x \\<in> set ys \\<Longrightarrow>\n    x # xs \\<in> set (subseqs ((y # ys) @ zs))", "with IH"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> set ys; xs \\<in> set (subseqs zs)\\<rbrakk>\n  \\<Longrightarrow> x # xs \\<in> set (subseqs (ys @ zs))\n  x \\<in> set (y # ys)\n  xs \\<in> set (subseqs zs)\n  x = y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> set ys; xs \\<in> set (subseqs zs)\\<rbrakk>\n  \\<Longrightarrow> x # xs \\<in> set (subseqs (ys @ zs))\n  x \\<in> set (y # ys)\n  xs \\<in> set (subseqs zs)\n  x = y\n\ngoal (1 subgoal):\n 1. x # xs \\<in> set (subseqs ((y # ys) @ zs))", "by (auto intro: mem_set_subseqs_append)"], ["proof (state)\nthis:\n  x # xs \\<in> set (subseqs ((y # ys) @ zs))\n\ngoal (1 subgoal):\n 1. x \\<in> set ys \\<Longrightarrow>\n    x # xs \\<in> set (subseqs ((y # ys) @ zs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> set ys \\<Longrightarrow>\n    x # xs \\<in> set (subseqs ((y # ys) @ zs))", "case 2"], ["proof (state)\nthis:\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. x \\<in> set ys \\<Longrightarrow>\n    x # xs \\<in> set (subseqs ((y # ys) @ zs))", "from IH.hyps[OF this IH.prems(2)]"], ["proof (chain)\npicking this:\n  x # xs \\<in> set (subseqs (ys @ zs))", "show ?thesis"], ["proof (prove)\nusing this:\n  x # xs \\<in> set (subseqs (ys @ zs))\n\ngoal (1 subgoal):\n 1. x # xs \\<in> set (subseqs ((y # ys) @ zs))", "by auto"], ["proof (state)\nthis:\n  x # xs \\<in> set (subseqs ((y # ys) @ zs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x # xs \\<in> set (subseqs ((y # ys) @ zs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Cons_mem_set_subseqs_sorted:\n  \"sorted xs \\<Longrightarrow> y#ys \\<in> set (subseqs xs) \\<Longrightarrow> y#ys \\<in> set (subseqs (filter (\\<lambda>x. y \\<le> x) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs; y # ys \\<in> set (subseqs xs)\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<in> set (subseqs (filter ((\\<le>) y) xs))", "by (induct xs) (auto simp: Let_def)"], ["", "lemma subseqs_map[simp]: \"subseqs (map f xs) = map (map f) (subseqs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subseqs (map f xs) = map (map f) (subseqs xs)", "by (induct xs, auto)"], ["", "lemma subseqs_of_indices: \"map (map (nth xs)) (subseqs [0..<length xs]) = subseqs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map ((!) xs)) (subseqs [0..<length xs]) = subseqs xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. map (map ((!) [])) (subseqs [0..<length []]) = subseqs []\n 2. \\<And>a xs.\n       map (map ((!) xs)) (subseqs [0..<length xs]) =\n       subseqs xs \\<Longrightarrow>\n       map (map ((!) (a # xs))) (subseqs [0..<length (a # xs)]) =\n       subseqs (a # xs)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. map (map ((!) [])) (subseqs [0..<length []]) = subseqs []\n 2. \\<And>a xs.\n       map (map ((!) xs)) (subseqs [0..<length xs]) =\n       subseqs xs \\<Longrightarrow>\n       map (map ((!) (a # xs))) (subseqs [0..<length (a # xs)]) =\n       subseqs (a # xs)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map ((!) [])) (subseqs [0..<length []]) = subseqs []", "by auto"], ["proof (state)\nthis:\n  map (map ((!) [])) (subseqs [0..<length []]) = subseqs []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       map (map ((!) xs)) (subseqs [0..<length xs]) =\n       subseqs xs \\<Longrightarrow>\n       map (map ((!) (a # xs))) (subseqs [0..<length (a # xs)]) =\n       subseqs (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       map (map ((!) xs)) (subseqs [0..<length xs]) =\n       subseqs xs \\<Longrightarrow>\n       map (map ((!) (a # xs))) (subseqs [0..<length (a # xs)]) =\n       subseqs (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  map (map ((!) xs)) (subseqs [0..<length xs]) = subseqs xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       map (map ((!) xs)) (subseqs [0..<length xs]) =\n       subseqs xs \\<Longrightarrow>\n       map (map ((!) (a # xs))) (subseqs [0..<length (a # xs)]) =\n       subseqs (a # xs)", "from this[symmetric]"], ["proof (chain)\npicking this:\n  subseqs xs = map (map ((!) xs)) (subseqs [0..<length xs])", "have \"subseqs xs = map (map ((!) (x#xs))) (subseqs [Suc 0..<Suc (length xs)])\""], ["proof (prove)\nusing this:\n  subseqs xs = map (map ((!) xs)) (subseqs [0..<length xs])\n\ngoal (1 subgoal):\n 1. subseqs xs =\n    map (map ((!) (x # xs))) (subseqs [Suc 0..<Suc (length xs)])", "by (fold map_Suc_upt, simp)"], ["proof (state)\nthis:\n  subseqs xs = map (map ((!) (x # xs))) (subseqs [Suc 0..<Suc (length xs)])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       map (map ((!) xs)) (subseqs [0..<length xs]) =\n       subseqs xs \\<Longrightarrow>\n       map (map ((!) (a # xs))) (subseqs [0..<length (a # xs)]) =\n       subseqs (a # xs)", "then"], ["proof (chain)\npicking this:\n  subseqs xs = map (map ((!) (x # xs))) (subseqs [Suc 0..<Suc (length xs)])", "show ?case"], ["proof (prove)\nusing this:\n  subseqs xs = map (map ((!) (x # xs))) (subseqs [Suc 0..<Suc (length xs)])\n\ngoal (1 subgoal):\n 1. map (map ((!) (x # xs))) (subseqs [0..<length (x # xs)]) =\n    subseqs (x # xs)", "by (unfold length_Cons upt_conv_Cons[OF zero_less_Suc], simp)"], ["proof (state)\nthis:\n  map (map ((!) (x # xs))) (subseqs [0..<length (x # xs)]) =\n  subseqs (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "paragraph \\<open>Specification\\<close>"], ["", "definition \"subseq_of_length n xs ys \\<equiv> ys \\<in> set (subseqs xs) \\<and> length ys = n\""], ["", "lemma subseq_of_lengthI[intro]:\n  assumes \"ys \\<in> set (subseqs xs)\" \"length ys = n\"\n  shows \"subseq_of_length n xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subseq_of_length n xs ys", "by (insert assms, unfold subseq_of_length_def, auto)"], ["", "lemma subseq_of_lengthD[dest]:\n  assumes \"subseq_of_length n xs ys\"\n  shows \"ys \\<in> set (subseqs xs)\" \"length ys = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> set (subseqs xs) &&& length ys = n", "by (insert assms, unfold subseq_of_length_def, auto)"], ["", "lemma subseq_of_length0[simp]: \"subseq_of_length 0 xs ys \\<longleftrightarrow> ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subseq_of_length 0 xs ys = (ys = [])", "by auto"], ["", "lemma subseq_of_length_Nil[simp]: \"subseq_of_length n [] ys \\<longleftrightarrow> n = 0 \\<and> ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subseq_of_length n [] ys = (n = 0 \\<and> ys = [])", "by (auto simp: subseq_of_length_def)"], ["", "lemma subseq_of_length_Suc_upt:\n  \"subseq_of_length (Suc n) [0..<m] xs \\<longleftrightarrow>\n   (if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs))\" (is \"?l \\<longleftrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. subseq_of_length (Suc n) [0..<m] xs =\n    (if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n     else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs))", "proof(cases \"n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs =\n    (if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n     else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       subseq_of_length (Suc n) [0..<m] xs =\n       (if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n        else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs))", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs =\n    (if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n     else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       subseq_of_length (Suc n) [0..<m] xs =\n       (if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n        else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subseq_of_length (Suc n) [0..<m] xs =\n    (if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n     else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs))", "proof(intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "assume l: \"?l\""], ["proof (state)\nthis:\n  subseq_of_length (Suc n) [0..<m] xs\n\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "with 0"], ["proof (chain)\npicking this:\n  n = 0\n  subseq_of_length (Suc n) [0..<m] xs", "have 1: \"length xs = Suc 0\""], ["proof (prove)\nusing this:\n  n = 0\n  subseq_of_length (Suc n) [0..<m] xs\n\ngoal (1 subgoal):\n 1. length xs = Suc 0", "by auto"], ["proof (state)\nthis:\n  length xs = Suc 0\n\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "then"], ["proof (chain)\npicking this:\n  length xs = Suc 0", "have xs: \"xs = [hd xs]\""], ["proof (prove)\nusing this:\n  length xs = Suc 0\n\ngoal (1 subgoal):\n 1. xs = [hd xs]", "by (metis length_0_conv length_Suc_conv list.sel(1))"], ["proof (state)\nthis:\n  xs = [hd xs]\n\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "with l"], ["proof (chain)\npicking this:\n  subseq_of_length (Suc n) [0..<m] xs\n  xs = [hd xs]", "have \"[hd xs] \\<in> set (subseqs [0..<m])\""], ["proof (prove)\nusing this:\n  subseq_of_length (Suc n) [0..<m] xs\n  xs = [hd xs]\n\ngoal (1 subgoal):\n 1. [hd xs] \\<in> set (subseqs [0..<m])", "by auto"], ["proof (state)\nthis:\n  [hd xs] \\<in> set (subseqs [0..<m])\n\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "with 1"], ["proof (chain)\npicking this:\n  length xs = Suc 0\n  [hd xs] \\<in> set (subseqs [0..<m])", "show \"?r\""], ["proof (prove)\nusing this:\n  length xs = Suc 0\n  [hd xs] \\<in> set (subseqs [0..<m])\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)", "by (unfold 0, auto)"], ["proof (state)\nthis:\n  if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n  else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "assume ?r"], ["proof (state)\nthis:\n  if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n  else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "with 0"], ["proof (chain)\npicking this:\n  n = 0\n  if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n  else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)", "have 1: \"length xs = Suc 0\" and 2: \"hd xs < m\""], ["proof (prove)\nusing this:\n  n = 0\n  if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n  else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n\ngoal (1 subgoal):\n 1. length xs = Suc 0 &&& hd xs < m", "by auto"], ["proof (state)\nthis:\n  length xs = Suc 0\n  hd xs < m\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "then"], ["proof (chain)\npicking this:\n  length xs = Suc 0\n  hd xs < m", "have xs: \"xs = [hd xs]\""], ["proof (prove)\nusing this:\n  length xs = Suc 0\n  hd xs < m\n\ngoal (1 subgoal):\n 1. xs = [hd xs]", "by (metis length_0_conv length_Suc_conv list.sel(1))"], ["proof (state)\nthis:\n  xs = [hd xs]\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "from 2"], ["proof (chain)\npicking this:\n  hd xs < m", "show \"?l\""], ["proof (prove)\nusing this:\n  hd xs < m\n\ngoal (1 subgoal):\n 1. subseq_of_length (Suc n) [0..<m] xs", "by (subst xs, auto simp: 0)"], ["proof (state)\nthis:\n  subseq_of_length (Suc n) [0..<m] xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subseq_of_length (Suc n) [0..<m] xs =\n  (if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n   else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       subseq_of_length (Suc n) [0..<m] xs =\n       (if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n        else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       subseq_of_length (Suc n) [0..<m] xs =\n       (if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n        else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs))", "case n: (Suc n')"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       subseq_of_length (Suc n) [0..<m] xs =\n       (if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n        else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subseq_of_length (Suc n) [0..<m] xs =\n    (if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n     else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs))", "proof (intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "assume \"?l\""], ["proof (state)\nthis:\n  subseq_of_length (Suc n) [0..<m] xs\n\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "with n"], ["proof (chain)\npicking this:\n  n = Suc n'\n  subseq_of_length (Suc n) [0..<m] xs", "have 1: \"length xs = Suc (Suc n')\" and 2: \"xs \\<in> set (subseqs [0..<m])\""], ["proof (prove)\nusing this:\n  n = Suc n'\n  subseq_of_length (Suc n) [0..<m] xs\n\ngoal (1 subgoal):\n 1. length xs = Suc (Suc n') &&& xs \\<in> set (subseqs [0..<m])", "by auto"], ["proof (state)\nthis:\n  length xs = Suc (Suc n')\n  xs \\<in> set (subseqs [0..<m])\n\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "from 1[unfolded length_Suc_conv]"], ["proof (chain)\npicking this:\n  \\<exists>y ys.\n     xs = y # ys \\<and>\n     (\\<exists>y ysa. ys = y # ysa \\<and> length ysa = n')", "obtain x y ys where xs: \"xs = x#y#ys\" and n': \"length ys = n'\""], ["proof (prove)\nusing this:\n  \\<exists>y ys.\n     xs = y # ys \\<and>\n     (\\<exists>y ysa. ys = y # ysa \\<and> length ysa = n')\n\ngoal (1 subgoal):\n 1. (\\<And>x y ys.\n        \\<lbrakk>xs = x # y # ys; length ys = n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs = x # y # ys\n  length ys = n'\n\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "have \"sorted xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted xs", "by(rule sorted_subseqs_sorted[OF _ 2], auto)"], ["proof (state)\nthis:\n  sorted xs\n\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "from this[unfolded xs]"], ["proof (chain)\npicking this:\n  sorted (x # y # ys)", "have \"x \\<le> y\""], ["proof (prove)\nusing this:\n  sorted (x # y # ys)\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by auto"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "moreover"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "from 2"], ["proof (chain)\npicking this:\n  xs \\<in> set (subseqs [0..<m])", "have \"distinct xs\""], ["proof (prove)\nusing this:\n  xs \\<in> set (subseqs [0..<m])\n\ngoal (1 subgoal):\n 1. distinct xs", "by (rule subseqs_distinctD, auto)"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "from this[unfolded xs]"], ["proof (chain)\npicking this:\n  distinct (x # y # ys)", "have \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  distinct (x # y # ys)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "ultimately"], ["proof (chain)\npicking this:\n  x \\<le> y\n  x \\<noteq> y", "have \"x < y\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x < y", "by auto"], ["proof (state)\nthis:\n  x < y\n\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "moreover"], ["proof (state)\nthis:\n  x < y\n\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "from 2"], ["proof (chain)\npicking this:\n  xs \\<in> set (subseqs [0..<m])", "have \"y#ys \\<in> set (subseqs [0..<m])\""], ["proof (prove)\nusing this:\n  xs \\<in> set (subseqs [0..<m])\n\ngoal (1 subgoal):\n 1. y # ys \\<in> set (subseqs [0..<m])", "by (unfold xs, auto dest: Cons_in_subseqsD)"], ["proof (state)\nthis:\n  y # ys \\<in> set (subseqs [0..<m])\n\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "with n n'"], ["proof (chain)\npicking this:\n  n = Suc n'\n  length ys = n'\n  y # ys \\<in> set (subseqs [0..<m])", "have \"subseq_of_length n [0..<m] (y#ys)\""], ["proof (prove)\nusing this:\n  n = Suc n'\n  length ys = n'\n  y # ys \\<in> set (subseqs [0..<m])\n\ngoal (1 subgoal):\n 1. subseq_of_length n [0..<m] (y # ys)", "by auto"], ["proof (state)\nthis:\n  subseq_of_length n [0..<m] (y # ys)\n\ngoal (2 subgoals):\n 1. subseq_of_length (Suc n) [0..<m] xs \\<Longrightarrow>\n    if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n 2. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "ultimately"], ["proof (chain)\npicking this:\n  x < y\n  subseq_of_length n [0..<m] (y # ys)", "show ?r"], ["proof (prove)\nusing this:\n  x < y\n  subseq_of_length n [0..<m] (y # ys)\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)", "by (auto simp: xs)"], ["proof (state)\nthis:\n  if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n  else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "assume r: \"?r\""], ["proof (state)\nthis:\n  if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n  else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "with n"], ["proof (chain)\npicking this:\n  n = Suc n'\n  if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n  else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)", "have len: \"length xs = Suc (Suc n')\"\n     and *: \"hd xs < hd (tl xs)\" \"tl xs \\<in> set (subseqs [0..<m])\""], ["proof (prove)\nusing this:\n  n = Suc n'\n  if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n  else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs)\n\ngoal (1 subgoal):\n 1. length xs = Suc (Suc n') &&&\n    hd xs < hd (tl xs) &&& tl xs \\<in> set (subseqs [0..<m])", "by auto"], ["proof (state)\nthis:\n  length xs = Suc (Suc n')\n  hd xs < hd (tl xs)\n  tl xs \\<in> set (subseqs [0..<m])\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "from len[unfolded length_Suc_conv]"], ["proof (chain)\npicking this:\n  \\<exists>y ys.\n     xs = y # ys \\<and>\n     (\\<exists>y ysa. ys = y # ysa \\<and> length ysa = n')", "obtain x y ys\n    where xs: \"xs = x#y#ys\" and n': \"length ys = n'\""], ["proof (prove)\nusing this:\n  \\<exists>y ys.\n     xs = y # ys \\<and>\n     (\\<exists>y ysa. ys = y # ysa \\<and> length ysa = n')\n\ngoal (1 subgoal):\n 1. (\\<And>x y ys.\n        \\<lbrakk>xs = x # y # ys; length ys = n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs = x # y # ys\n  length ys = n'\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "with *"], ["proof (chain)\npicking this:\n  hd xs < hd (tl xs)\n  tl xs \\<in> set (subseqs [0..<m])\n  xs = x # y # ys\n  length ys = n'", "have xy: \"x < y\" and yys: \"y#ys \\<in> set (subseqs [0..<m])\""], ["proof (prove)\nusing this:\n  hd xs < hd (tl xs)\n  tl xs \\<in> set (subseqs [0..<m])\n  xs = x # y # ys\n  length ys = n'\n\ngoal (1 subgoal):\n 1. x < y &&& y # ys \\<in> set (subseqs [0..<m])", "by auto"], ["proof (state)\nthis:\n  x < y\n  y # ys \\<in> set (subseqs [0..<m])\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "from Cons_mem_set_subseqs_sorted[OF _ yys]"], ["proof (chain)\npicking this:\n  sorted [0..<m] \\<Longrightarrow>\n  y # ys \\<in> set (subseqs (filter ((\\<le>) y) [0..<m]))", "have \"y#ys \\<in> set (subseqs (filter ((\\<le>) y) [0..<m]))\""], ["proof (prove)\nusing this:\n  sorted [0..<m] \\<Longrightarrow>\n  y # ys \\<in> set (subseqs (filter ((\\<le>) y) [0..<m]))\n\ngoal (1 subgoal):\n 1. y # ys \\<in> set (subseqs (filter ((\\<le>) y) [0..<m]))", "by auto"], ["proof (state)\nthis:\n  y # ys \\<in> set (subseqs (filter ((\\<le>) y) [0..<m]))\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "also"], ["proof (state)\nthis:\n  y # ys \\<in> set (subseqs (filter ((\\<le>) y) [0..<m]))\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "from Cons_mem_set_subseqsD[OF yys]"], ["proof (chain)\npicking this:\n  y \\<in> set [0..<m]", "have ym: \"y < m\""], ["proof (prove)\nusing this:\n  y \\<in> set [0..<m]\n\ngoal (1 subgoal):\n 1. y < m", "by auto"], ["proof (state)\nthis:\n  y < m\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "then"], ["proof (chain)\npicking this:\n  y < m", "have \"filter ((\\<le>) y) [0..<m] = [y..<m]\""], ["proof (prove)\nusing this:\n  y < m\n\ngoal (1 subgoal):\n 1. filter ((\\<le>) y) [0..<m] = [y..<m]", "by (auto intro: filter_upt)"], ["proof (state)\nthis:\n  filter ((\\<le>) y) [0..<m] = [y..<m]\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "finally"], ["proof (chain)\npicking this:\n  y # ys \\<in> set (subseqs [y..<m])", "have \"y#ys \\<in> set (subseqs [y..<m])\""], ["proof (prove)\nusing this:\n  y # ys \\<in> set (subseqs [y..<m])\n\ngoal (1 subgoal):\n 1. y # ys \\<in> set (subseqs [y..<m])", "by auto"], ["proof (state)\nthis:\n  y # ys \\<in> set (subseqs [y..<m])\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "with xy"], ["proof (chain)\npicking this:\n  x < y\n  y # ys \\<in> set (subseqs [y..<m])", "have \"x#y#ys \\<in> set (subseqs (x#[y..<m]))\""], ["proof (prove)\nusing this:\n  x < y\n  y # ys \\<in> set (subseqs [y..<m])\n\ngoal (1 subgoal):\n 1. x # y # ys \\<in> set (subseqs (x # [y..<m]))", "by auto"], ["proof (state)\nthis:\n  x # y # ys \\<in> set (subseqs (x # [y..<m]))\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "also"], ["proof (state)\nthis:\n  x # y # ys \\<in> set (subseqs (x # [y..<m]))\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "from xy"], ["proof (chain)\npicking this:\n  x < y", "have \"... \\<subseteq> set (subseqs ([0..<y] @ [y..<m]))\""], ["proof (prove)\nusing this:\n  x < y\n\ngoal (1 subgoal):\n 1. set (subseqs (x # [y..<m]))\n    \\<subseteq> set (subseqs ([0..<y] @ [y..<m]))", "by (intro subseqs_of_subseq Cons_mem_set_subseqs_append, auto intro: subseqs_refl)"], ["proof (state)\nthis:\n  set (subseqs (x # [y..<m])) \\<subseteq> set (subseqs ([0..<y] @ [y..<m]))\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "also"], ["proof (state)\nthis:\n  set (subseqs (x # [y..<m])) \\<subseteq> set (subseqs ([0..<y] @ [y..<m]))\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "from xy ym"], ["proof (chain)\npicking this:\n  x < y\n  y < m", "have \"[0..<y] @ [y..<m] = [0..<m]\""], ["proof (prove)\nusing this:\n  x < y\n  y < m\n\ngoal (1 subgoal):\n 1. [0..<y] @ [y..<m] = [0..<m]", "by (auto intro: upt_append)"], ["proof (state)\nthis:\n  [0..<y] @ [y..<m] = [0..<m]\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "finally"], ["proof (chain)\npicking this:\n  x # y # ys \\<in> set (subseqs [0..<m])", "have \"xs \\<in> set (subseqs [0..<m])\""], ["proof (prove)\nusing this:\n  x # y # ys \\<in> set (subseqs [0..<m])\n\ngoal (1 subgoal):\n 1. xs \\<in> set (subseqs [0..<m])", "by (unfold xs)"], ["proof (state)\nthis:\n  xs \\<in> set (subseqs [0..<m])\n\ngoal (1 subgoal):\n 1. if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n    else hd xs < hd (tl xs) \\<and>\n         subseq_of_length n [0..<m] (tl xs) \\<Longrightarrow>\n    subseq_of_length (Suc n) [0..<m] xs", "with len[folded n]"], ["proof (chain)\npicking this:\n  length xs = Suc n\n  xs \\<in> set (subseqs [0..<m])", "show ?l"], ["proof (prove)\nusing this:\n  length xs = Suc n\n  xs \\<in> set (subseqs [0..<m])\n\ngoal (1 subgoal):\n 1. subseq_of_length (Suc n) [0..<m] xs", "by auto"], ["proof (state)\nthis:\n  subseq_of_length (Suc n) [0..<m] xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subseq_of_length (Suc n) [0..<m] xs =\n  (if n = 0 then length xs = Suc 0 \\<and> hd xs < m\n   else hd xs < hd (tl xs) \\<and> subseq_of_length n [0..<m] (tl xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subseqs_of_length_of_indices:\n  \"{ ys. subseq_of_length n xs ys } = { map (nth xs) is | is. subseq_of_length n [0..<length xs] is }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ys. subseq_of_length n xs ys} =\n    {map ((!) xs) is |is. subseq_of_length n [0..<length xs] is}", "by(unfold subseq_of_length_def, subst subseqs_of_indices[symmetric], auto)"], ["", "lemma subseqs_of_length_Suc_Cons:\n  \"{ ys. subseq_of_length (Suc n) (x#xs) ys } =\n   Cons x ` { ys. subseq_of_length n xs ys } \\<union> { ys. subseq_of_length (Suc n) xs ys }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ys. subseq_of_length (Suc n) (x # xs) ys} =\n    (#) x ` {ys. subseq_of_length n xs ys} \\<union>\n    {ys. subseq_of_length (Suc n) xs ys}", "by (unfold subseq_of_length_def, auto)"], ["", "datatype ('a,'b,'state)subseqs_impl = Sublists_Impl\n  (create_subseqs: \"'b \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> ('b \\<times> 'a list)list \\<times> 'state\")\n  (next_subseqs: \"'state \\<Rightarrow> ('b \\<times> 'a list)list \\<times> 'state\")"], ["", "locale subseqs_impl = \n  fixes f :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'b\"\n  and sl_impl :: \"('a,'b,'state)subseqs_impl\"\nbegin"], ["", "definition S :: \"'b \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> ('b \\<times> 'a list)set\" where\n  \"S base elements n = { (foldr f ys base, ys) | ys. subseq_of_length n elements ys }\""], ["", "end"], ["", "locale correct_subseqs_impl = subseqs_impl f sl_impl\n  for f :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'b\" \n  and sl_impl :: \"('a,'b,'state)subseqs_impl\" +\n  fixes invariant :: \"'b \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> 'state \\<Rightarrow> bool\" \n  assumes create_subseqs: \"create_subseqs sl_impl base elements n = (out, state) \\<Longrightarrow> invariant base elements n state \\<and> set out = S base elements n\" \n  and next_subseqs:\n    \"invariant base elements n state \\<Longrightarrow> \n     next_subseqs sl_impl state = (out, state') \\<Longrightarrow> \n     invariant base elements (Suc n) state' \\<and> set out = S base elements (Suc n)\""], ["", "(* **** old implementation *********** *)"], ["", "paragraph \\<open>Basic Implementation\\<close>"], ["", "fun subseqs_i_n_main :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 'b \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> ('b \\<times> 'a list) list\" where\n  \"subseqs_i_n_main f b xs i n = (if i = 0 then [(b,[])] else if i = n then [(foldr f xs b, xs)]\n    else case xs of \n      (y # ys) \\<Rightarrow> map (\\<lambda> (c,zs) \\<Rightarrow> (c,y # zs)) (subseqs_i_n_main f (f y b) ys (i - 1) (n - 1)) \n        @ subseqs_i_n_main f b ys i (n - 1))\""], ["", "declare subseqs_i_n_main.simps[simp del]"], ["", "definition subseqs_length :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 'b \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> ('b \\<times> 'a list) list\" where\n  \"subseqs_length f b i xs = (\n    let n = length xs in if i > n then [] else subseqs_i_n_main f b xs i n)\""], ["", "lemma subseqs_length: assumes f_ac: \"\\<And> x y z. f x (f y z) = f y (f x z)\" \n  shows \"set (subseqs_length f a n xs) = \n  { (foldr f ys a, ys) | ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (subseqs_length f a n xs) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (subseqs_length f a n xs) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (subseqs_length f a n xs) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "proof (cases \"length xs < n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs < n \\<Longrightarrow>\n    set (subseqs_length f a n xs) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\n 2. \\<not> length xs < n \\<Longrightarrow>\n    set (subseqs_length f a n xs) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "case True"], ["proof (state)\nthis:\n  length xs < n\n\ngoal (2 subgoals):\n 1. length xs < n \\<Longrightarrow>\n    set (subseqs_length f a n xs) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\n 2. \\<not> length xs < n \\<Longrightarrow>\n    set (subseqs_length f a n xs) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  length xs < n\n\ngoal (1 subgoal):\n 1. set (subseqs_length f a n xs) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "unfolding subseqs_length_def Let_def"], ["proof (prove)\nusing this:\n  length xs < n\n\ngoal (1 subgoal):\n 1. set (if length xs < n then []\n         else subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "using length_subseqs[of xs] subseqs_length_simple_False"], ["proof (prove)\nusing this:\n  length xs < n\n  length (subseqs xs) = 2 ^ length xs\n  \\<lbrakk>?b \\<in> set (subseqs ?xs); length ?xs < length ?b\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. set (if length xs < n then []\n         else subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "by auto"], ["proof (state)\nthis:\n  set (subseqs_length f a n xs) =\n  {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\n\ngoal (1 subgoal):\n 1. \\<not> length xs < n \\<Longrightarrow>\n    set (subseqs_length f a n xs) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length xs < n \\<Longrightarrow>\n    set (subseqs_length f a n xs) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "case False"], ["proof (state)\nthis:\n  \\<not> length xs < n\n\ngoal (1 subgoal):\n 1. \\<not> length xs < n \\<Longrightarrow>\n    set (subseqs_length f a n xs) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "hence id: \"(length xs < n) = False\" and \"n \\<le> length xs\""], ["proof (prove)\nusing this:\n  \\<not> length xs < n\n\ngoal (1 subgoal):\n 1. (length xs < n) = False &&& n \\<le> length xs", "by auto"], ["proof (state)\nthis:\n  (length xs < n) = False\n  n \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs < n \\<Longrightarrow>\n    set (subseqs_length f a n xs) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "from this(2)"], ["proof (chain)\npicking this:\n  n \\<le> length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> length xs\n\ngoal (1 subgoal):\n 1. set (subseqs_length f a n xs) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "unfolding subseqs_length_def Let_def id if_False"], ["proof (prove)\nusing this:\n  n \\<le> length xs\n\ngoal (1 subgoal):\n 1. set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "proof (induct xs arbitrary: n a rule: length_induct[rule_format])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n a.\n       \\<lbrakk>\\<And>ys n a.\n                   \\<lbrakk>length ys < length xs;\n                    n \\<le> length ys\\<rbrakk>\n                   \\<Longrightarrow> set\n(subseqs_i_n_main f a ys n (length ys)) =\n                                     {(foldr f ysa a, ysa) |ysa.\nysa \\<in> set (subseqs ys) \\<and> length ysa = n};\n        n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> set (subseqs_i_n_main f a xs n (length xs)) =\n                         {(foldr f ys a, ys) |ys.\n                          ys \\<in> set (subseqs xs) \\<and> length ys = n}", "case (1 xs n a)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ys < length xs; ?n \\<le> length ?ys\\<rbrakk>\n  \\<Longrightarrow> set (subseqs_i_n_main f ?a ?ys ?n (length ?ys)) =\n                    {(foldr f ys ?a, ys) |ys.\n                     ys \\<in> set (subseqs ?ys) \\<and> length ys = ?n}\n  n \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<And>xs n a.\n       \\<lbrakk>\\<And>ys n a.\n                   \\<lbrakk>length ys < length xs;\n                    n \\<le> length ys\\<rbrakk>\n                   \\<Longrightarrow> set\n(subseqs_i_n_main f a ys n (length ys)) =\n                                     {(foldr f ysa a, ysa) |ysa.\nysa \\<in> set (subseqs ys) \\<and> length ysa = n};\n        n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> set (subseqs_i_n_main f a xs n (length xs)) =\n                         {(foldr f ys a, ys) |ys.\n                          ys \\<in> set (subseqs xs) \\<and> length ys = n}", "note n = 1(2)"], ["proof (state)\nthis:\n  n \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<And>xs n a.\n       \\<lbrakk>\\<And>ys n a.\n                   \\<lbrakk>length ys < length xs;\n                    n \\<le> length ys\\<rbrakk>\n                   \\<Longrightarrow> set\n(subseqs_i_n_main f a ys n (length ys)) =\n                                     {(foldr f ysa a, ysa) |ysa.\nysa \\<in> set (subseqs ys) \\<and> length ysa = n};\n        n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> set (subseqs_i_n_main f a xs n (length xs)) =\n                         {(foldr f ys a, ys) |ys.\n                          ys \\<in> set (subseqs xs) \\<and> length ys = n}", "note IH = 1(1)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ys < length xs; ?n \\<le> length ?ys\\<rbrakk>\n  \\<Longrightarrow> set (subseqs_i_n_main f ?a ?ys ?n (length ?ys)) =\n                    {(foldr f ys ?a, ys) |ys.\n                     ys \\<in> set (subseqs ?ys) \\<and> length ys = ?n}\n\ngoal (1 subgoal):\n 1. \\<And>xs n a.\n       \\<lbrakk>\\<And>ys n a.\n                   \\<lbrakk>length ys < length xs;\n                    n \\<le> length ys\\<rbrakk>\n                   \\<Longrightarrow> set\n(subseqs_i_n_main f a ys n (length ys)) =\n                                     {(foldr f ysa a, ysa) |ysa.\nysa \\<in> set (subseqs ys) \\<and> length ysa = n};\n        n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> set (subseqs_i_n_main f a xs n (length xs)) =\n                         {(foldr f ys a, ys) |ys.\n                          ys \\<in> set (subseqs xs) \\<and> length ys = n}", "note simp[simp] = subseqs_i_n_main.simps[of f _ xs n]"], ["proof (state)\nthis:\n  subseqs_i_n_main f ?b xs n ?n =\n  (if n = 0 then [(?b, [])]\n   else if n = ?n then [(foldr f xs ?b, xs)]\n        else case xs of\n             y # ys \\<Rightarrow>\n               map (\\<lambda>(c, zs). (c, y # zs))\n                (subseqs_i_n_main f (f y ?b) ys (n - 1) (?n - 1)) @\n               subseqs_i_n_main f ?b ys n (?n - 1))\n\ngoal (1 subgoal):\n 1. \\<And>xs n a.\n       \\<lbrakk>\\<And>ys n a.\n                   \\<lbrakk>length ys < length xs;\n                    n \\<le> length ys\\<rbrakk>\n                   \\<Longrightarrow> set\n(subseqs_i_n_main f a ys n (length ys)) =\n                                     {(foldr f ysa a, ysa) |ysa.\nysa \\<in> set (subseqs ys) \\<and> length ysa = n};\n        n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> set (subseqs_i_n_main f a xs n (length xs)) =\n                         {(foldr f ys a, ys) |ys.\n                          ys \\<in> set (subseqs xs) \\<and> length ys = n}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "unfolding simp"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. set (if n = 0 then [(a, [])]\n         else if n = length xs then [(foldr f xs a, xs)]\n              else case xs of\n                   y # ys \\<Rightarrow>\n                     map (\\<lambda>(c, zs). (c, y # zs))\n                      (subseqs_i_n_main f (f y a) ys (n - 1)\n                        (length xs - 1)) @\n                     subseqs_i_n_main f a ys n (length xs - 1)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "by simp"], ["proof (state)\nthis:\n  set (subseqs_i_n_main f a xs n (length xs)) =\n  {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "note 0 = this"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "proof (cases \"n = length xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = length xs \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\n 2. n \\<noteq> length xs \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "case True"], ["proof (state)\nthis:\n  n = length xs\n\ngoal (2 subgoals):\n 1. n = length xs \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\n 2. n \\<noteq> length xs \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "have \"?thesis = ({(foldr f xs a, xs)} = (\\<lambda> ys. (foldr f ys a, ys)) ` {ys. ys \\<in> set (subseqs xs) \\<and> length ys = length xs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (subseqs_i_n_main f a xs n (length xs)) =\n     {(foldr f ys a, ys) |ys.\n      ys \\<in> set (subseqs xs) \\<and> length ys = n}) =\n    ({(foldr f xs a, xs)} =\n     (\\<lambda>ys. (foldr f ys a, ys)) `\n     {ys \\<in> set (subseqs xs). length ys = length xs})", "unfolding simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (if n = 0 then [(a, [])]\n          else if n = length xs then [(foldr f xs a, xs)]\n               else case xs of\n                    y # ys \\<Rightarrow>\n                      map (\\<lambda>(c, zs). (c, y # zs))\n                       (subseqs_i_n_main f (f y a) ys (n - 1)\n                         (length xs - 1)) @\n                      subseqs_i_n_main f a ys n (length xs - 1)) =\n     {(foldr f ys a, ys) |ys.\n      ys \\<in> set (subseqs xs) \\<and> length ys = n}) =\n    ({(foldr f xs a, xs)} =\n     (\\<lambda>ys. (foldr f ys a, ys)) `\n     {ys \\<in> set (subseqs xs). length ys = length xs})", "using 0 True"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  n = length xs\n\ngoal (1 subgoal):\n 1. (set (if n = 0 then [(a, [])]\n          else if n = length xs then [(foldr f xs a, xs)]\n               else case xs of\n                    y # ys \\<Rightarrow>\n                      map (\\<lambda>(c, zs). (c, y # zs))\n                       (subseqs_i_n_main f (f y a) ys (n - 1)\n                         (length xs - 1)) @\n                      subseqs_i_n_main f a ys n (length xs - 1)) =\n     {(foldr f ys a, ys) |ys.\n      ys \\<in> set (subseqs xs) \\<and> length ys = n}) =\n    ({(foldr f xs a, xs)} =\n     (\\<lambda>ys. (foldr f ys a, ys)) `\n     {ys \\<in> set (subseqs xs). length ys = length xs})", "by auto"], ["proof (state)\nthis:\n  (set (subseqs_i_n_main f a xs n (length xs)) =\n   {(foldr f ys a, ys) |ys.\n    ys \\<in> set (subseqs xs) \\<and> length ys = n}) =\n  ({(foldr f xs a, xs)} =\n   (\\<lambda>ys. (foldr f ys a, ys)) `\n   {ys \\<in> set (subseqs xs). length ys = length xs})\n\ngoal (2 subgoals):\n 1. n = length xs \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\n 2. n \\<noteq> length xs \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "from this[unfolded full_list_subseqs]"], ["proof (chain)\npicking this:\n  (set (subseqs_i_n_main f a xs n (length xs)) =\n   {(foldr f ys a, ys) |ys.\n    ys \\<in> set (subseqs xs) \\<and> length ys = n}) =\n  ({(foldr f xs a, xs)} = (\\<lambda>ys. (foldr f ys a, ys)) ` {xs})", "show ?thesis"], ["proof (prove)\nusing this:\n  (set (subseqs_i_n_main f a xs n (length xs)) =\n   {(foldr f ys a, ys) |ys.\n    ys \\<in> set (subseqs xs) \\<and> length ys = n}) =\n  ({(foldr f xs a, xs)} = (\\<lambda>ys. (foldr f ys a, ys)) ` {xs})\n\ngoal (1 subgoal):\n 1. set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "by auto"], ["proof (state)\nthis:\n  set (subseqs_i_n_main f a xs n (length xs)) =\n  {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\n\ngoal (1 subgoal):\n 1. n \\<noteq> length xs \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> length xs \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "case False"], ["proof (state)\nthis:\n  n \\<noteq> length xs\n\ngoal (1 subgoal):\n 1. n \\<noteq> length xs \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "with n"], ["proof (chain)\npicking this:\n  n \\<le> length xs\n  n \\<noteq> length xs", "have n: \"n < length xs\""], ["proof (prove)\nusing this:\n  n \\<le> length xs\n  n \\<noteq> length xs\n\ngoal (1 subgoal):\n 1. n < length xs", "by auto"], ["proof (state)\nthis:\n  n < length xs\n\ngoal (1 subgoal):\n 1. n \\<noteq> length xs \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "from 0"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "obtain m where m: \"n = Suc m\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>m. n = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n, auto)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. n \\<noteq> length xs \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "from n 0"], ["proof (chain)\npicking this:\n  n < length xs\n  n \\<noteq> 0", "obtain y ys where xs: \"xs = y # ys\""], ["proof (prove)\nusing this:\n  n < length xs\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>y ys. xs = y # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs, auto)"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. n \\<noteq> length xs \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "from n m xs"], ["proof (chain)\npicking this:\n  n < length xs\n  n = Suc m\n  xs = y # ys", "have le: \"m \\<le> length ys\" \"n \\<le> length ys\""], ["proof (prove)\nusing this:\n  n < length xs\n  n = Suc m\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. m \\<le> length ys &&& n \\<le> length ys", "by auto"], ["proof (state)\nthis:\n  m \\<le> length ys\n  n \\<le> length ys\n\ngoal (1 subgoal):\n 1. n \\<noteq> length xs \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "from xs"], ["proof (chain)\npicking this:\n  xs = y # ys", "have lt: \"length ys < length xs\""], ["proof (prove)\nusing this:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. length ys < length xs", "by auto"], ["proof (state)\nthis:\n  length ys < length xs\n\ngoal (1 subgoal):\n 1. n \\<noteq> length xs \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "have sub: \"set (subseqs_i_n_main f a xs n (length xs)) = \n            (\\<lambda>(c, zs). (c, y # zs)) ` set (subseqs_i_n_main f (f y a) ys m (length ys)) \\<union>\n            set (subseqs_i_n_main f a ys n (length ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (subseqs_i_n_main f a xs n (length xs)) =\n    (\\<lambda>(c, zs). (c, y # zs)) `\n    set (subseqs_i_n_main f (f y a) ys m (length ys)) \\<union>\n    set (subseqs_i_n_main f a ys n (length ys))", "unfolding simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (if n = 0 then [(a, [])]\n         else if n = length xs then [(foldr f xs a, xs)]\n              else case xs of\n                   y # ys \\<Rightarrow>\n                     map (\\<lambda>(c, zs). (c, y # zs))\n                      (subseqs_i_n_main f (f y a) ys (n - 1)\n                        (length xs - 1)) @\n                     subseqs_i_n_main f a ys n (length xs - 1)) =\n    (\\<lambda>(c, zs). (c, y # zs)) `\n    set (subseqs_i_n_main f (f y a) ys m (length ys)) \\<union>\n    set (subseqs_i_n_main f a ys n (length ys))", "using 0 False"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  n \\<noteq> length xs\n\ngoal (1 subgoal):\n 1. set (if n = 0 then [(a, [])]\n         else if n = length xs then [(foldr f xs a, xs)]\n              else case xs of\n                   y # ys \\<Rightarrow>\n                     map (\\<lambda>(c, zs). (c, y # zs))\n                      (subseqs_i_n_main f (f y a) ys (n - 1)\n                        (length xs - 1)) @\n                     subseqs_i_n_main f a ys n (length xs - 1)) =\n    (\\<lambda>(c, zs). (c, y # zs)) `\n    set (subseqs_i_n_main f (f y a) ys m (length ys)) \\<union>\n    set (subseqs_i_n_main f a ys n (length ys))", "by (simp add: xs m)"], ["proof (state)\nthis:\n  set (subseqs_i_n_main f a xs n (length xs)) =\n  (\\<lambda>(c, zs). (c, y # zs)) `\n  set (subseqs_i_n_main f (f y a) ys m (length ys)) \\<union>\n  set (subseqs_i_n_main f a ys n (length ys))\n\ngoal (1 subgoal):\n 1. n \\<noteq> length xs \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "have fold: \"\\<And> ys. foldr f ys (f y a) = f y (foldr f ys a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys. foldr f ys (f y a) = f y (foldr f ys a)", "by (induct_tac ys, auto simp: f_ac)"], ["proof (state)\nthis:\n  foldr f ?ys (f y a) = f y (foldr f ?ys a)\n\ngoal (1 subgoal):\n 1. n \\<noteq> length xs \\<Longrightarrow>\n    set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (subseqs_i_n_main f a xs n (length xs)) =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "unfolding sub IH[OF lt le(1)] IH[OF lt le(2)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(c, zs). (c, y # zs)) `\n    {(foldr f ysa (f y a), ysa) |ysa.\n     ysa \\<in> set (subseqs ys) \\<and> length ysa = m} \\<union>\n    {(foldr f ysa a, ysa) |ysa.\n     ysa \\<in> set (subseqs ys) \\<and> length ysa = n} =\n    {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}", "unfolding m xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(c, zs). (c, y # zs)) `\n    {(foldr f ysa (f y a), ysa) |ysa.\n     ysa \\<in> set (subseqs ys) \\<and> length ysa = m} \\<union>\n    {(foldr f ysa a, ysa) |ysa.\n     ysa \\<in> set (subseqs ys) \\<and> length ysa = Suc m} =\n    {(foldr f ysa a, ysa) |ysa.\n     ysa \\<in> set (subseqs (y # ys)) \\<and> length ysa = Suc m}", "by (auto simp: Let_def fold)"], ["proof (state)\nthis:\n  set (subseqs_i_n_main f a xs n (length xs)) =\n  {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (subseqs_i_n_main f a xs n (length xs)) =\n  {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (subseqs_i_n_main f a xs n (length xs)) =\n  {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (subseqs_length f a n xs) =\n  {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (subseqs_length f a n xs) =\n  {(foldr f ys a, ys) |ys. ys \\<in> set (subseqs xs) \\<and> length ys = n}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition basic_subseqs_impl :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> ('a, 'b, 'b \\<times> 'a list \\<times> nat)subseqs_impl\" where\n  \"basic_subseqs_impl f = Sublists_Impl \n    (\\<lambda> a xs n. (subseqs_length f a n xs, (a,xs,n)))\n    (\\<lambda> (a,xs,n). (subseqs_length f a (Suc n) xs, (a,xs,Suc n)))\""], ["", "lemma basic_subseqs_impl: assumes f_ac: \"\\<And> x y z. f x (f y z) = f y (f x z)\"\n  shows \"correct_subseqs_impl f (basic_subseqs_impl f) \n    (\\<lambda> a xs n triple. (a,xs,n) = triple)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. correct_subseqs_impl f (basic_subseqs_impl f)\n     (\\<lambda>a xs n. (=) (a, xs, n))", "by (unfold_locales; unfold subseqs_impl.S_def basic_subseqs_impl_def subseq_of_length_def,\n      insert subseqs_length[of f, OF f_ac], auto)"], ["", "(******** new implementation ********)"], ["", "paragraph \\<open>Improved Implementation\\<close>"], ["", "datatype ('a,'b,'state) subseqs_foldr_impl = Sublists_Foldr_Impl\n  (subseqs_foldr: \"'b \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> 'b list \\<times> 'state\")\n  (next_subseqs_foldr: \"'state \\<Rightarrow> 'b list \\<times> 'state\")"], ["", "locale subseqs_foldr_impl =\n  fixes f :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'b\"\n  and impl :: \"('a,'b,'state) subseqs_foldr_impl\"\nbegin"], ["", "definition S where \"S base elements n \\<equiv> { foldr f ys base | ys. subseq_of_length n elements ys }\""], ["", "end"], ["", "locale correct_subseqs_foldr_impl = subseqs_foldr_impl f impl\n  for f and impl :: \"('a,'b,'state) subseqs_foldr_impl\" +\n  fixes invariant :: \"'b \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> 'state \\<Rightarrow> bool\"\n  assumes subseqs_foldr:\n    \"subseqs_foldr impl base elements n = (out, state) \\<Longrightarrow>\n     invariant base elements n state \\<and> set out = S base elements n\" \n  and next_subseqs_foldr:\n    \"next_subseqs_foldr impl state = (out, state') \\<Longrightarrow> invariant base elements n state \\<Longrightarrow>\n     invariant base elements (Suc n) state' \\<and> set out = S base elements (Suc n)\""], ["", "locale my_subseqs =\n  fixes f :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'b\"\nbegin"], ["", "context fixes head :: \"'a\" and tail :: \"'a iarray\"\nbegin"], ["", "fun next_subseqs1 and next_subseqs2\nwhere \"next_subseqs1 ret0 ret1 [] = (ret0, (head, tail, ret1))\"\n  |   \"next_subseqs1 ret0 ret1 ((i,v)#prevs) = next_subseqs2 (f head v # ret0) ret1 prevs v [0..<i]\"\n  |   \"next_subseqs2 ret0 ret1 prevs v [] = next_subseqs1 ret0 ret1 prevs\"\n  |   \"next_subseqs2 ret0 ret1 prevs v (j#js) =\n       (let v' = f (tail !! j) v in next_subseqs2 (v' # ret0) ((j,v') # ret1) prevs v js)\""], ["", "definition \"next_subseqs2_set v js \\<equiv> { (j, f (tail !! j) v) | j. j \\<in> set js }\""], ["", "definition \"out_subseqs2_set v js \\<equiv> { f (tail !! j) v | j. j \\<in> set js }\""], ["", "definition \"next_subseqs1_set prevs \\<equiv> \\<Union> { next_subseqs2_set v [0..<i] | v i. (i,v) \\<in> set prevs }\""], ["", "definition \"out_subseqs1_set prevs \\<equiv>\n  (f head \\<circ> snd) ` set prevs \\<union> (\\<Union> { out_subseqs2_set v [0..<i] | v i. (i,v) \\<in> set prevs })\""], ["", "fun next_subseqs1_spec where\n  \"next_subseqs1_spec out nexts prevs (out', (head',tail',nexts')) \\<longleftrightarrow>\n   set nexts' = set nexts \\<union> next_subseqs1_set prevs \\<and>\n   set out' = set out \\<union> out_subseqs1_set prevs\""], ["", "fun next_subseqs2_spec where\n  \"next_subseqs2_spec out nexts prevs v js (out', (head',tail',nexts')) \\<longleftrightarrow>\n   set nexts' = set nexts \\<union> next_subseqs1_set prevs \\<union> next_subseqs2_set v js \\<and>\n   set out' = set out \\<union> out_subseqs1_set prevs \\<union> out_subseqs2_set v js\""], ["", "lemma next_subseqs2_Cons:\n  \"next_subseqs2_set v (j#js) = insert (j, f (tail!!j) v) (next_subseqs2_set v js)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. next_subseqs2_set v (j # js) =\n    insert (j, f (tail !! j) v) (next_subseqs2_set v js)", "by (auto simp: next_subseqs2_set_def)"], ["", "lemma out_subseqs2_Cons:\n  \"out_subseqs2_set v (j#js) = insert (f (tail!!j) v) (out_subseqs2_set v js)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out_subseqs2_set v (j # js) =\n    insert (f (tail !! j) v) (out_subseqs2_set v js)", "by (auto simp: out_subseqs2_set_def)"], ["", "lemma next_subseqs1_set_as_next_subseqs2_set:\n  \"next_subseqs1_set ((i,v) # prevs) = next_subseqs1_set prevs \\<union> next_subseqs2_set v [0..<i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. next_subseqs1_set ((i, v) # prevs) =\n    next_subseqs1_set prevs \\<union> next_subseqs2_set v [0..<i]", "by (auto simp: next_subseqs1_set_def)"], ["", "lemma out_subseqs1_set_as_out_subseqs2_set:\n  \"out_subseqs1_set ((i,v) # prevs) =\n   { f head v } \\<union> out_subseqs1_set prevs \\<union> out_subseqs2_set v [0..<i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out_subseqs1_set ((i, v) # prevs) =\n    {f head v} \\<union> out_subseqs1_set prevs \\<union>\n    out_subseqs2_set v [0..<i]", "by (auto simp: out_subseqs1_set_def)"], ["", "lemma next_subseqs1_spec:\n  shows \"\\<And>out nexts. next_subseqs1_spec out nexts prevs (next_subseqs1 out nexts prevs)\"\n    and \"\\<And>out nexts. next_subseqs2_spec out nexts prevs v js (next_subseqs2 out nexts prevs v js)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out nexts.\n        next_subseqs1_spec out nexts prevs\n         (next_subseqs1 out nexts prevs)) &&&\n    (\\<And>out nexts.\n        next_subseqs2_spec out nexts prevs v js\n         (next_subseqs2 out nexts prevs v js))", "proof(induct rule: next_subseqs1_next_subseqs2.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ret0 ret1 out nexts.\n       next_subseqs1_spec out nexts [] (next_subseqs1 out nexts [])\n 2. \\<And>ret0 ret1 i v prevs out nexts.\n       (\\<And>out nexts.\n           next_subseqs2_spec out nexts prevs v [0..<i]\n            (next_subseqs2 out nexts prevs v [0..<i])) \\<Longrightarrow>\n       next_subseqs1_spec out nexts ((i, v) # prevs)\n        (next_subseqs1 out nexts ((i, v) # prevs))\n 3. \\<And>ret0 ret1 prevs v out nexts.\n       (\\<And>out nexts.\n           next_subseqs1_spec out nexts prevs\n            (next_subseqs1 out nexts prevs)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v []\n        (next_subseqs2 out nexts prevs v [])\n 4. \\<And>ret0 ret1 prevs v j js out nexts.\n       (\\<And>x out nexts.\n           x = f (tail !! j) v \\<Longrightarrow>\n           next_subseqs2_spec out nexts prevs v js\n            (next_subseqs2 out nexts prevs v js)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "case (1 ret0 ret1)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>ret0 ret1 out nexts.\n       next_subseqs1_spec out nexts [] (next_subseqs1 out nexts [])\n 2. \\<And>ret0 ret1 i v prevs out nexts.\n       (\\<And>out nexts.\n           next_subseqs2_spec out nexts prevs v [0..<i]\n            (next_subseqs2 out nexts prevs v [0..<i])) \\<Longrightarrow>\n       next_subseqs1_spec out nexts ((i, v) # prevs)\n        (next_subseqs1 out nexts ((i, v) # prevs))\n 3. \\<And>ret0 ret1 prevs v out nexts.\n       (\\<And>out nexts.\n           next_subseqs1_spec out nexts prevs\n            (next_subseqs1 out nexts prevs)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v []\n        (next_subseqs2 out nexts prevs v [])\n 4. \\<And>ret0 ret1 prevs v j js out nexts.\n       (\\<And>x out nexts.\n           x = f (tail !! j) v \\<Longrightarrow>\n           next_subseqs2_spec out nexts prevs v js\n            (next_subseqs2 out nexts prevs v js)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. next_subseqs1_spec out nexts [] (next_subseqs1 out nexts [])", "by (simp add: next_subseqs1_set_def out_subseqs1_set_def)"], ["proof (state)\nthis:\n  next_subseqs1_spec out nexts [] (next_subseqs1 out nexts [])\n\ngoal (3 subgoals):\n 1. \\<And>ret0 ret1 i v prevs out nexts.\n       (\\<And>out nexts.\n           next_subseqs2_spec out nexts prevs v [0..<i]\n            (next_subseqs2 out nexts prevs v [0..<i])) \\<Longrightarrow>\n       next_subseqs1_spec out nexts ((i, v) # prevs)\n        (next_subseqs1 out nexts ((i, v) # prevs))\n 2. \\<And>ret0 ret1 prevs v out nexts.\n       (\\<And>out nexts.\n           next_subseqs1_spec out nexts prevs\n            (next_subseqs1 out nexts prevs)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v []\n        (next_subseqs2 out nexts prevs v [])\n 3. \\<And>ret0 ret1 prevs v j js out nexts.\n       (\\<And>x out nexts.\n           x = f (tail !! j) v \\<Longrightarrow>\n           next_subseqs2_spec out nexts prevs v js\n            (next_subseqs2 out nexts prevs v js)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ret0 ret1 i v prevs out nexts.\n       (\\<And>out nexts.\n           next_subseqs2_spec out nexts prevs v [0..<i]\n            (next_subseqs2 out nexts prevs v [0..<i])) \\<Longrightarrow>\n       next_subseqs1_spec out nexts ((i, v) # prevs)\n        (next_subseqs1 out nexts ((i, v) # prevs))\n 2. \\<And>ret0 ret1 prevs v out nexts.\n       (\\<And>out nexts.\n           next_subseqs1_spec out nexts prevs\n            (next_subseqs1 out nexts prevs)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v []\n        (next_subseqs2 out nexts prevs v [])\n 3. \\<And>ret0 ret1 prevs v j js out nexts.\n       (\\<And>x out nexts.\n           x = f (tail !! j) v \\<Longrightarrow>\n           next_subseqs2_spec out nexts prevs v js\n            (next_subseqs2 out nexts prevs v js)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "case (2 ret0 ret1 i v prevs)"], ["proof (state)\nthis:\n  next_subseqs2_spec ?out10 ?nexts10 prevs v [0..<i]\n   (next_subseqs2 ?out10 ?nexts10 prevs v [0..<i])\n\ngoal (3 subgoals):\n 1. \\<And>ret0 ret1 i v prevs out nexts.\n       (\\<And>out nexts.\n           next_subseqs2_spec out nexts prevs v [0..<i]\n            (next_subseqs2 out nexts prevs v [0..<i])) \\<Longrightarrow>\n       next_subseqs1_spec out nexts ((i, v) # prevs)\n        (next_subseqs1 out nexts ((i, v) # prevs))\n 2. \\<And>ret0 ret1 prevs v out nexts.\n       (\\<And>out nexts.\n           next_subseqs1_spec out nexts prevs\n            (next_subseqs1 out nexts prevs)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v []\n        (next_subseqs2 out nexts prevs v [])\n 3. \\<And>ret0 ret1 prevs v j js out nexts.\n       (\\<And>x out nexts.\n           x = f (tail !! j) v \\<Longrightarrow>\n           next_subseqs2_spec out nexts prevs v js\n            (next_subseqs2 out nexts prevs v js)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. next_subseqs1_spec out nexts ((i, v) # prevs)\n     (next_subseqs1 out nexts ((i, v) # prevs))", "proof(cases \"next_subseqs1 out nexts ((i, v) # prevs)\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       next_subseqs1 out nexts ((i, v) # prevs) =\n       (a, b, c, d) \\<Longrightarrow>\n       next_subseqs1_spec out nexts ((i, v) # prevs)\n        (next_subseqs1 out nexts ((i, v) # prevs))", "case split: (fields out' head' tail' nexts')"], ["proof (state)\nthis:\n  next_subseqs1 out nexts ((i, v) # prevs) = (out', head', tail', nexts')\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       next_subseqs1 out nexts ((i, v) # prevs) =\n       (a, b, c, d) \\<Longrightarrow>\n       next_subseqs1_spec out nexts ((i, v) # prevs)\n        (next_subseqs1 out nexts ((i, v) # prevs))", "have \"next_subseqs2_spec (f head v # out) nexts prevs v [0..<i] (out', (head',tail',nexts'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. next_subseqs2_spec (f head v # out) nexts prevs v [0..<i]\n     (out', head', tail', nexts')", "by (fold split, unfold next_subseqs1.simps, rule 2)"], ["proof (state)\nthis:\n  next_subseqs2_spec (f head v # out) nexts prevs v [0..<i]\n   (out', head', tail', nexts')\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       next_subseqs1 out nexts ((i, v) # prevs) =\n       (a, b, c, d) \\<Longrightarrow>\n       next_subseqs1_spec out nexts ((i, v) # prevs)\n        (next_subseqs1 out nexts ((i, v) # prevs))", "then"], ["proof (chain)\npicking this:\n  next_subseqs2_spec (f head v # out) nexts prevs v [0..<i]\n   (out', head', tail', nexts')", "show ?thesis"], ["proof (prove)\nusing this:\n  next_subseqs2_spec (f head v # out) nexts prevs v [0..<i]\n   (out', head', tail', nexts')\n\ngoal (1 subgoal):\n 1. next_subseqs1_spec out nexts ((i, v) # prevs)\n     (next_subseqs1 out nexts ((i, v) # prevs))", "apply (unfold next_subseqs2_spec.simps split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set nexts' =\n    set nexts \\<union> next_subseqs1_set prevs \\<union>\n    next_subseqs2_set v [0..<i] \\<and>\n    set out' =\n    set (f head v # out) \\<union> out_subseqs1_set prevs \\<union>\n    out_subseqs2_set v [0..<i] \\<Longrightarrow>\n    next_subseqs1_spec out nexts ((i, v) # prevs)\n     (out', head', tail', nexts')", "by (auto simp: next_subseqs1_set_as_next_subseqs2_set out_subseqs1_set_as_out_subseqs2_set)"], ["proof (state)\nthis:\n  next_subseqs1_spec out nexts ((i, v) # prevs)\n   (next_subseqs1 out nexts ((i, v) # prevs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  next_subseqs1_spec out nexts ((i, v) # prevs)\n   (next_subseqs1 out nexts ((i, v) # prevs))\n\ngoal (2 subgoals):\n 1. \\<And>ret0 ret1 prevs v out nexts.\n       (\\<And>out nexts.\n           next_subseqs1_spec out nexts prevs\n            (next_subseqs1 out nexts prevs)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v []\n        (next_subseqs2 out nexts prevs v [])\n 2. \\<And>ret0 ret1 prevs v j js out nexts.\n       (\\<And>x out nexts.\n           x = f (tail !! j) v \\<Longrightarrow>\n           next_subseqs2_spec out nexts prevs v js\n            (next_subseqs2 out nexts prevs v js)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ret0 ret1 prevs v out nexts.\n       (\\<And>out nexts.\n           next_subseqs1_spec out nexts prevs\n            (next_subseqs1 out nexts prevs)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v []\n        (next_subseqs2 out nexts prevs v [])\n 2. \\<And>ret0 ret1 prevs v j js out nexts.\n       (\\<And>x out nexts.\n           x = f (tail !! j) v \\<Longrightarrow>\n           next_subseqs2_spec out nexts prevs v js\n            (next_subseqs2 out nexts prevs v js)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "case (3 ret0 ret1 prevs v)"], ["proof (state)\nthis:\n  next_subseqs1_spec ?out10 ?nexts10 prevs\n   (next_subseqs1 ?out10 ?nexts10 prevs)\n\ngoal (2 subgoals):\n 1. \\<And>ret0 ret1 prevs v out nexts.\n       (\\<And>out nexts.\n           next_subseqs1_spec out nexts prevs\n            (next_subseqs1 out nexts prevs)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v []\n        (next_subseqs2 out nexts prevs v [])\n 2. \\<And>ret0 ret1 prevs v j js out nexts.\n       (\\<And>x out nexts.\n           x = f (tail !! j) v \\<Longrightarrow>\n           next_subseqs2_spec out nexts prevs v js\n            (next_subseqs2 out nexts prevs v js)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. next_subseqs2_spec out nexts prevs v []\n     (next_subseqs2 out nexts prevs v [])", "proof (cases \"next_subseqs1 out nexts prevs\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       next_subseqs1 out nexts prevs = (a, b, c, d) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v []\n        (next_subseqs2 out nexts prevs v [])", "case split: (fields out' head' tail' nexts')"], ["proof (state)\nthis:\n  next_subseqs1 out nexts prevs = (out', head', tail', nexts')\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       next_subseqs1 out nexts prevs = (a, b, c, d) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v []\n        (next_subseqs2 out nexts prevs v [])", "from 3[of out nexts]"], ["proof (chain)\npicking this:\n  next_subseqs1_spec out nexts prevs (next_subseqs1 out nexts prevs)", "show ?thesis"], ["proof (prove)\nusing this:\n  next_subseqs1_spec out nexts prevs (next_subseqs1 out nexts prevs)\n\ngoal (1 subgoal):\n 1. next_subseqs2_spec out nexts prevs v []\n     (next_subseqs2 out nexts prevs v [])", "by(simp add: split next_subseqs2_set_def out_subseqs2_set_def)"], ["proof (state)\nthis:\n  next_subseqs2_spec out nexts prevs v []\n   (next_subseqs2 out nexts prevs v [])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  next_subseqs2_spec out nexts prevs v []\n   (next_subseqs2 out nexts prevs v [])\n\ngoal (1 subgoal):\n 1. \\<And>ret0 ret1 prevs v j js out nexts.\n       (\\<And>x out nexts.\n           x = f (tail !! j) v \\<Longrightarrow>\n           next_subseqs2_spec out nexts prevs v js\n            (next_subseqs2 out nexts prevs v js)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ret0 ret1 prevs v j js out nexts.\n       (\\<And>x out nexts.\n           x = f (tail !! j) v \\<Longrightarrow>\n           next_subseqs2_spec out nexts prevs v js\n            (next_subseqs2 out nexts prevs v js)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "case (4 ret0 ret1 prevs v j js)"], ["proof (state)\nthis:\n  ?x10 = f (tail !! j) v \\<Longrightarrow>\n  next_subseqs2_spec ?out10 ?nexts10 prevs v js\n   (next_subseqs2 ?out10 ?nexts10 prevs v js)\n\ngoal (1 subgoal):\n 1. \\<And>ret0 ret1 prevs v j js out nexts.\n       (\\<And>x out nexts.\n           x = f (tail !! j) v \\<Longrightarrow>\n           next_subseqs2_spec out nexts prevs v js\n            (next_subseqs2 out nexts prevs v js)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "define tj where \"tj = tail !! j\""], ["proof (state)\nthis:\n  tj = tail !! j\n\ngoal (1 subgoal):\n 1. \\<And>ret0 ret1 prevs v j js out nexts.\n       (\\<And>x out nexts.\n           x = f (tail !! j) v \\<Longrightarrow>\n           next_subseqs2_spec out nexts prevs v js\n            (next_subseqs2 out nexts prevs v js)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "define nexts'' where \"nexts'' = (j, f tj v) # nexts\""], ["proof (state)\nthis:\n  nexts'' = (j, f tj v) # nexts\n\ngoal (1 subgoal):\n 1. \\<And>ret0 ret1 prevs v j js out nexts.\n       (\\<And>x out nexts.\n           x = f (tail !! j) v \\<Longrightarrow>\n           next_subseqs2_spec out nexts prevs v js\n            (next_subseqs2 out nexts prevs v js)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "define out'' where \"out'' = (f tj v) # out\""], ["proof (state)\nthis:\n  out'' = f tj v # out\n\ngoal (1 subgoal):\n 1. \\<And>ret0 ret1 prevs v j js out nexts.\n       (\\<And>x out nexts.\n           x = f (tail !! j) v \\<Longrightarrow>\n           next_subseqs2_spec out nexts prevs v js\n            (next_subseqs2 out nexts prevs v js)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "let ?n = \"next_subseqs2 out'' nexts'' prevs v js\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ret0 ret1 prevs v j js out nexts.\n       (\\<And>x out nexts.\n           x = f (tail !! j) v \\<Longrightarrow>\n           next_subseqs2_spec out nexts prevs v js\n            (next_subseqs2 out nexts prevs v js)) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. next_subseqs2_spec out nexts prevs v (j # js)\n     (next_subseqs2 out nexts prevs v (j # js))", "proof (cases ?n)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       next_subseqs2 out'' nexts'' prevs v js =\n       (a, b, c, d) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "case split: (fields out' head' tail' nexts')"], ["proof (state)\nthis:\n  next_subseqs2 out'' nexts'' prevs v js = (out', head', tail', nexts')\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       next_subseqs2 out'' nexts'' prevs v js =\n       (a, b, c, d) \\<Longrightarrow>\n       next_subseqs2_spec out nexts prevs v (j # js)\n        (next_subseqs2 out nexts prevs v (j # js))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. next_subseqs2_spec out nexts prevs v (j # js)\n     (next_subseqs2 out nexts prevs v (j # js))", "apply (unfold next_subseqs2.simps Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. next_subseqs2_spec out nexts prevs v (j # js)\n     (next_subseqs2 (f (tail !! j) v # out) ((j, f (tail !! j) v) # nexts)\n       prevs v js)", "apply (fold tj_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. next_subseqs2_spec out nexts prevs v (j # js)\n     (next_subseqs2 (f tj v # out) ((j, f tj v) # nexts) prevs v js)", "apply (fold out''_def nexts''_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. next_subseqs2_spec out nexts prevs v (j # js)\n     (next_subseqs2 out'' nexts'' prevs v js)", "apply (unfold split next_subseqs2_spec.simps next_subseqs2_Cons out_subseqs2_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set nexts' =\n    set nexts \\<union> next_subseqs1_set prevs \\<union>\n    insert (j, f (tail !! j) v) (next_subseqs2_set v js) \\<and>\n    set out' =\n    set out \\<union> out_subseqs1_set prevs \\<union>\n    insert (f (tail !! j) v) (out_subseqs2_set v js)", "using 4[OF refl, of out'' nexts'', unfolded split]"], ["proof (prove)\nusing this:\n  next_subseqs2_spec out'' nexts'' prevs v js (out', head', tail', nexts')\n\ngoal (1 subgoal):\n 1. set nexts' =\n    set nexts \\<union> next_subseqs1_set prevs \\<union>\n    insert (j, f (tail !! j) v) (next_subseqs2_set v js) \\<and>\n    set out' =\n    set out \\<union> out_subseqs1_set prevs \\<union>\n    insert (f (tail !! j) v) (out_subseqs2_set v js)", "apply (auto simp: tj_def nexts''_def out''_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  next_subseqs2_spec out nexts prevs v (j # js)\n   (next_subseqs2 out nexts prevs v (j # js))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  next_subseqs2_spec out nexts prevs v (j # js)\n   (next_subseqs2 out nexts prevs v (j # js))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "fun next_subseqs where \"next_subseqs (head,tail,prevs) = next_subseqs1 head tail [] [] prevs\""], ["", "fun create_subseqs\nwhere \"create_subseqs base elements 0 = (\n       if elements = [] then ([base],(undefined, IArray [], []))\n       else let head = hd elements; tail = IArray (tl elements) in\n         ([base], (head, tail, [(IArray.length tail, base)])))\"\n  |   \"create_subseqs base elements (Suc n) =\n       next_subseqs (snd (create_subseqs base elements n))\""], ["", "definition impl where \"impl = Sublists_Foldr_Impl create_subseqs next_subseqs\""], ["", "sublocale subseqs_foldr_impl f impl"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition set_prevs where \"set_prevs base tail n \\<equiv>\n  { (i, foldr f (map ((!) tail) is) base) | i is.\n   subseq_of_length n [0..<length tail] is \\<and> i = (if n = 0 then length tail else hd is) }\""], ["", "lemma snd_set_prevs:\n  \"snd ` (set_prevs base tail n) = (\\<lambda>as. foldr f as base) ` { as. subseq_of_length n tail as }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` set_prevs base tail n =\n    (\\<lambda>as. foldr f as base) ` {as. subseq_of_length n tail as}", "by (subst subseqs_of_length_of_indices, auto simp: set_prevs_def image_Collect)"], ["", "fun invariant where \"invariant base elements n (head,tail,prevs) =\n  (if elements = [] then prevs = []\n   else head = hd elements \\<and> tail = IArray (tl elements) \\<and> set prevs = set_prevs base (tl elements) n)\""], ["", "lemma next_subseq_preserve:\n  assumes \"next_subseqs (head,tail,prevs) = (out, (head',tail',prevs'))\"\n  shows \"head' = head\" \"tail' = tail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head' = head &&& tail' = tail", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. head' = head\n 2. tail' = tail", "define P :: \"'b list \\<times> _ \\<times> _ \\<times> (nat \\<times> 'b) list \\<Rightarrow> bool\"\n  where \"P \\<equiv> \\<lambda> (out, (head',tail',prevs')). head' = head \\<and> tail' = tail\""], ["proof (state)\nthis:\n  P \\<equiv>\n  \\<lambda>(out, head', tail', prevs'). head' = head \\<and> tail' = tail\n\ngoal (2 subgoals):\n 1. head' = head\n 2. tail' = tail", "{"], ["proof (state)\nthis:\n  P \\<equiv>\n  \\<lambda>(out, head', tail', prevs'). head' = head \\<and> tail' = tail\n\ngoal (2 subgoals):\n 1. head' = head\n 2. tail' = tail", "fix ret0 ret1 v js"], ["proof (state)\ngoal (2 subgoals):\n 1. head' = head\n 2. tail' = tail", "have *: \"P (next_subseqs1 head tail ret0 ret1 prevs)\"\n     and  \"P (next_subseqs2 head tail ret0 ret1 prevs v js)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (next_subseqs1 head tail ret0 ret1 prevs) &&&\n    P (next_subseqs2 head tail ret0 ret1 prevs v js)", "by(induct rule: next_subseqs1_next_subseqs2.induct, simp add: P_def, auto simp: Let_def)"], ["proof (state)\nthis:\n  P (next_subseqs1 head tail ret0 ret1 prevs)\n  P (next_subseqs2 head tail ret0 ret1 prevs v js)\n\ngoal (2 subgoals):\n 1. head' = head\n 2. tail' = tail", "}"], ["proof (state)\nthis:\n  P (next_subseqs1 head tail ?ret0.12 ?ret1.12 prevs)\n  P (next_subseqs2 head tail ?ret0.12 ?ret1.12 prevs ?v12 ?js12)\n\ngoal (2 subgoals):\n 1. head' = head\n 2. tail' = tail", "from this(1)[unfolded P_def, of \"[]\" \"[]\", folded next_subseqs.simps] assms"], ["proof (chain)\npicking this:\n  case local.next_subseqs (head, tail, prevs) of\n  (out, head', tail', prevs') \\<Rightarrow> head' = head \\<and> tail' = tail\n  local.next_subseqs (head, tail, prevs) = (out, head', tail', prevs')", "show \"head' = head\" \"tail' = tail\""], ["proof (prove)\nusing this:\n  case local.next_subseqs (head, tail, prevs) of\n  (out, head', tail', prevs') \\<Rightarrow> head' = head \\<and> tail' = tail\n  local.next_subseqs (head, tail, prevs) = (out, head', tail', prevs')\n\ngoal (1 subgoal):\n 1. head' = head &&& tail' = tail", "by auto"], ["proof (state)\nthis:\n  head' = head\n  tail' = tail\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma next_subseqs_spec:\n  assumes nxt: \"next_subseqs (head,tail,prevs) = (out, (head',tail',prevs'))\"\n  shows \"set prevs' = { (j, f (tail !! j) v) | v i j. (i,v) \\<in> set prevs \\<and> j < i }\" (is \"?g1\")\n    and \"set out = (f head \\<circ> snd) ` set prevs \\<union> snd ` set prevs'\" (is \"?g2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set prevs' =\n    {uu_.\n     \\<exists>v i j.\n        uu_ = (j, f (tail !! j) v) \\<and>\n        (i, v) \\<in> set prevs \\<and> j < i} &&&\n    set out = (f head \\<circ> snd) ` set prevs \\<union> snd ` set prevs'", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. set prevs' =\n    {uu_.\n     \\<exists>v i j.\n        uu_ = (j, f (tail !! j) v) \\<and>\n        (i, v) \\<in> set prevs \\<and> j < i}\n 2. set out = (f head \\<circ> snd) ` set prevs \\<union> snd ` set prevs'", "note next_subseqs1_spec(1)[of head tail Nil Nil prevs]"], ["proof (state)\nthis:\n  next_subseqs1_spec head tail [] [] prevs\n   (next_subseqs1 head tail [] [] prevs)\n\ngoal (2 subgoals):\n 1. set prevs' =\n    {uu_.\n     \\<exists>v i j.\n        uu_ = (j, f (tail !! j) v) \\<and>\n        (i, v) \\<in> set prevs \\<and> j < i}\n 2. set out = (f head \\<circ> snd) ` set prevs \\<union> snd ` set prevs'", "note this[unfolded nxt[simplified]]"], ["proof (state)\nthis:\n  next_subseqs1_spec head tail [] [] prevs (out, head', tail', prevs')\n\ngoal (2 subgoals):\n 1. set prevs' =\n    {uu_.\n     \\<exists>v i j.\n        uu_ = (j, f (tail !! j) v) \\<and>\n        (i, v) \\<in> set prevs \\<and> j < i}\n 2. set out = (f head \\<circ> snd) ` set prevs \\<union> snd ` set prevs'", "note this[unfolded next_subseqs1_spec.simps]"], ["proof (state)\nthis:\n  set prevs' = set [] \\<union> next_subseqs1_set tail prevs \\<and>\n  set out = set [] \\<union> out_subseqs1_set head tail prevs\n\ngoal (2 subgoals):\n 1. set prevs' =\n    {uu_.\n     \\<exists>v i j.\n        uu_ = (j, f (tail !! j) v) \\<and>\n        (i, v) \\<in> set prevs \\<and> j < i}\n 2. set out = (f head \\<circ> snd) ` set prevs \\<union> snd ` set prevs'", "note this[unfolded next_subseqs1_set_def out_subseqs1_set_def]"], ["proof (state)\nthis:\n  set prevs' =\n  set [] \\<union>\n  \\<Union>\n   {next_subseqs2_set tail v [0..<i] |v i. (i, v) \\<in> set prevs} \\<and>\n  set out =\n  set [] \\<union>\n  ((f head \\<circ> snd) ` set prevs \\<union>\n   \\<Union> {out_subseqs2_set tail v [0..<i] |v i. (i, v) \\<in> set prevs})\n\ngoal (2 subgoals):\n 1. set prevs' =\n    {uu_.\n     \\<exists>v i j.\n        uu_ = (j, f (tail !! j) v) \\<and>\n        (i, v) \\<in> set prevs \\<and> j < i}\n 2. set out = (f head \\<circ> snd) ` set prevs \\<union> snd ` set prevs'", "note * = this[unfolded next_subseqs2_set_def out_subseqs2_set_def]"], ["proof (state)\nthis:\n  set prevs' =\n  set [] \\<union>\n  \\<Union>\n   {{(j, f (tail !! j) v) |j. j \\<in> set [0..<i]} |v i.\n    (i, v) \\<in> set prevs} \\<and>\n  set out =\n  set [] \\<union>\n  ((f head \\<circ> snd) ` set prevs \\<union>\n   \\<Union>\n    {{f (tail !! j) v |j. j \\<in> set [0..<i]} |v i.\n     (i, v) \\<in> set prevs})\n\ngoal (2 subgoals):\n 1. set prevs' =\n    {uu_.\n     \\<exists>v i j.\n        uu_ = (j, f (tail !! j) v) \\<and>\n        (i, v) \\<in> set prevs \\<and> j < i}\n 2. set out = (f head \\<circ> snd) ` set prevs \\<union> snd ` set prevs'", "then"], ["proof (chain)\npicking this:\n  set prevs' =\n  set [] \\<union>\n  \\<Union>\n   {{(j, f (tail !! j) v) |j. j \\<in> set [0..<i]} |v i.\n    (i, v) \\<in> set prevs} \\<and>\n  set out =\n  set [] \\<union>\n  ((f head \\<circ> snd) ` set prevs \\<union>\n   \\<Union>\n    {{f (tail !! j) v |j. j \\<in> set [0..<i]} |v i.\n     (i, v) \\<in> set prevs})", "show g1: ?g1"], ["proof (prove)\nusing this:\n  set prevs' =\n  set [] \\<union>\n  \\<Union>\n   {{(j, f (tail !! j) v) |j. j \\<in> set [0..<i]} |v i.\n    (i, v) \\<in> set prevs} \\<and>\n  set out =\n  set [] \\<union>\n  ((f head \\<circ> snd) ` set prevs \\<union>\n   \\<Union>\n    {{f (tail !! j) v |j. j \\<in> set [0..<i]} |v i.\n     (i, v) \\<in> set prevs})\n\ngoal (1 subgoal):\n 1. set prevs' =\n    {uu_.\n     \\<exists>v i j.\n        uu_ = (j, f (tail !! j) v) \\<and>\n        (i, v) \\<in> set prevs \\<and> j < i}", "by auto"], ["proof (state)\nthis:\n  set prevs' =\n  {uu_.\n   \\<exists>v i j.\n      uu_ = (j, f (tail !! j) v) \\<and> (i, v) \\<in> set prevs \\<and> j < i}\n\ngoal (1 subgoal):\n 1. set out = (f head \\<circ> snd) ` set prevs \\<union> snd ` set prevs'", "also"], ["proof (state)\nthis:\n  set prevs' =\n  {uu_.\n   \\<exists>v i j.\n      uu_ = (j, f (tail !! j) v) \\<and> (i, v) \\<in> set prevs \\<and> j < i}\n\ngoal (1 subgoal):\n 1. set out = (f head \\<circ> snd) ` set prevs \\<union> snd ` set prevs'", "have \"snd ` ... =  (\\<Union> {{(f (tail !! j) v) | j. j < i} | v i. (i, v) \\<in> set prevs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd `\n    {uu_.\n     \\<exists>v i j.\n        uu_ = (j, f (tail !! j) v) \\<and>\n        (i, v) \\<in> set prevs \\<and> j < i} =\n    \\<Union> {{f (tail !! j) v |j. j < i} |v i. (i, v) \\<in> set prevs}", "by (unfold image_Collect, auto)"], ["proof (state)\nthis:\n  snd `\n  {uu_.\n   \\<exists>v i j.\n      uu_ = (j, f (tail !! j) v) \\<and>\n      (i, v) \\<in> set prevs \\<and> j < i} =\n  \\<Union> {{f (tail !! j) v |j. j < i} |v i. (i, v) \\<in> set prevs}\n\ngoal (1 subgoal):\n 1. set out = (f head \\<circ> snd) ` set prevs \\<union> snd ` set prevs'", "finally"], ["proof (chain)\npicking this:\n  snd ` set prevs' =\n  \\<Union> {{f (tail !! j) v |j. j < i} |v i. (i, v) \\<in> set prevs}", "have **: \"snd ` set prevs' = ...\""], ["proof (prove)\nusing this:\n  snd ` set prevs' =\n  \\<Union> {{f (tail !! j) v |j. j < i} |v i. (i, v) \\<in> set prevs}\n\ngoal (1 subgoal):\n 1. snd ` set prevs' =\n    \\<Union> {{f (tail !! j) v |j. j < i} |v i. (i, v) \\<in> set prevs}", "."], ["proof (state)\nthis:\n  snd ` set prevs' =\n  \\<Union> {{f (tail !! j) v |j. j < i} |v i. (i, v) \\<in> set prevs}\n\ngoal (1 subgoal):\n 1. set out = (f head \\<circ> snd) ` set prevs \\<union> snd ` set prevs'", "with conjunct2[OF *]"], ["proof (chain)\npicking this:\n  set out =\n  set [] \\<union>\n  ((f head \\<circ> snd) ` set prevs \\<union>\n   \\<Union>\n    {{f (tail !! j) v |j. j \\<in> set [0..<i]} |v i.\n     (i, v) \\<in> set prevs})\n  snd ` set prevs' =\n  \\<Union> {{f (tail !! j) v |j. j < i} |v i. (i, v) \\<in> set prevs}", "show ?g2"], ["proof (prove)\nusing this:\n  set out =\n  set [] \\<union>\n  ((f head \\<circ> snd) ` set prevs \\<union>\n   \\<Union>\n    {{f (tail !! j) v |j. j \\<in> set [0..<i]} |v i.\n     (i, v) \\<in> set prevs})\n  snd ` set prevs' =\n  \\<Union> {{f (tail !! j) v |j. j < i} |v i. (i, v) \\<in> set prevs}\n\ngoal (1 subgoal):\n 1. set out = (f head \\<circ> snd) ` set prevs \\<union> snd ` set prevs'", "by simp"], ["proof (state)\nthis:\n  set out = (f head \\<circ> snd) ` set prevs \\<union> snd ` set prevs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma next_subseq_prevs:\n  assumes nxt: \"next_subseqs (head,tail,prevs) = (out, (head',tail',prevs'))\"\n      and inv_prevs: \"set prevs = set_prevs base (IArray.list_of tail) n\"\n  shows \"set prevs' = set_prevs base (IArray.list_of tail) (Suc n)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set prevs' = set_prevs base (IArray.list_of tail) (Suc n)", "proof(intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set prevs' \\<Longrightarrow>\n       x \\<in> set_prevs base (IArray.list_of tail) (Suc n)\n 2. \\<And>x.\n       x \\<in> set_prevs base (IArray.list_of tail)\n                (Suc n) \\<Longrightarrow>\n       x \\<in> set prevs'", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set prevs' \\<Longrightarrow>\n       x \\<in> set_prevs base (IArray.list_of tail) (Suc n)\n 2. \\<And>x.\n       x \\<in> set_prevs base (IArray.list_of tail)\n                (Suc n) \\<Longrightarrow>\n       x \\<in> set prevs'", "assume r: \"t \\<in> ?r\""], ["proof (state)\nthis:\n  t \\<in> set_prevs base (IArray.list_of tail) (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set prevs' \\<Longrightarrow>\n       x \\<in> set_prevs base (IArray.list_of tail) (Suc n)\n 2. \\<And>x.\n       x \\<in> set_prevs base (IArray.list_of tail)\n                (Suc n) \\<Longrightarrow>\n       x \\<in> set prevs'", "from this[unfolded set_prevs_def]"], ["proof (chain)\npicking this:\n  t \\<in> {(i, foldr f (map ((!) (IArray.list_of tail)) is) base) |i is.\n           subseq_of_length (Suc n) [0..<length (IArray.list_of tail)]\n            is \\<and>\n           i = (if Suc n = 0 then length (IArray.list_of tail) else hd is)}", "obtain iis\n  where t: \"t = (hd iis, foldr f (map ((!!) tail) iis) base)\"\n    and sl: \"subseq_of_length (Suc n) [0..<IArray.length tail] iis\""], ["proof (prove)\nusing this:\n  t \\<in> {(i, foldr f (map ((!) (IArray.list_of tail)) is) base) |i is.\n           subseq_of_length (Suc n) [0..<length (IArray.list_of tail)]\n            is \\<and>\n           i = (if Suc n = 0 then length (IArray.list_of tail) else hd is)}\n\ngoal (1 subgoal):\n 1. (\\<And>iis.\n        \\<lbrakk>t = (hd iis, foldr f (map ((!!) tail) iis) base);\n         subseq_of_length (Suc n) [0..<IArray.length tail] iis\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t = (hd iis, foldr f (map ((!!) tail) iis) base)\n  subseq_of_length (Suc n) [0..<IArray.length tail] iis\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set prevs' \\<Longrightarrow>\n       x \\<in> set_prevs base (IArray.list_of tail) (Suc n)\n 2. \\<And>x.\n       x \\<in> set_prevs base (IArray.list_of tail)\n                (Suc n) \\<Longrightarrow>\n       x \\<in> set prevs'", "from sl"], ["proof (chain)\npicking this:\n  subseq_of_length (Suc n) [0..<IArray.length tail] iis", "have \"length iis > 0\""], ["proof (prove)\nusing this:\n  subseq_of_length (Suc n) [0..<IArray.length tail] iis\n\ngoal (1 subgoal):\n 1. 0 < length iis", "by auto"], ["proof (state)\nthis:\n  0 < length iis\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set prevs' \\<Longrightarrow>\n       x \\<in> set_prevs base (IArray.list_of tail) (Suc n)\n 2. \\<And>x.\n       x \\<in> set_prevs base (IArray.list_of tail)\n                (Suc n) \\<Longrightarrow>\n       x \\<in> set prevs'", "then"], ["proof (chain)\npicking this:\n  0 < length iis", "obtain i \"is\" where iis: \"iis = i#is\""], ["proof (prove)\nusing this:\n  0 < length iis\n\ngoal (1 subgoal):\n 1. (\\<And>i is. iis = i # is \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson list.set_cases nth_mem)"], ["proof (state)\nthis:\n  iis = i # is\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set prevs' \\<Longrightarrow>\n       x \\<in> set_prevs base (IArray.list_of tail) (Suc n)\n 2. \\<And>x.\n       x \\<in> set_prevs base (IArray.list_of tail)\n                (Suc n) \\<Longrightarrow>\n       x \\<in> set prevs'", "define v where \"v = foldr f (map ((!!) tail) is) base\""], ["proof (state)\nthis:\n  v = foldr f (map ((!!) tail) is) base\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set prevs' \\<Longrightarrow>\n       x \\<in> set_prevs base (IArray.list_of tail) (Suc n)\n 2. \\<And>x.\n       x \\<in> set_prevs base (IArray.list_of tail)\n                (Suc n) \\<Longrightarrow>\n       x \\<in> set prevs'", "note sl[unfolded subseq_of_length_Suc_upt]"], ["proof (state)\nthis:\n  if n = 0 then length iis = Suc 0 \\<and> hd iis < IArray.length tail\n  else hd iis < hd (tl iis) \\<and>\n       subseq_of_length n [0..<IArray.length tail] (tl iis)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set prevs' \\<Longrightarrow>\n       x \\<in> set_prevs base (IArray.list_of tail) (Suc n)\n 2. \\<And>x.\n       x \\<in> set_prevs base (IArray.list_of tail)\n                (Suc n) \\<Longrightarrow>\n       x \\<in> set prevs'", "note nxt = next_subseqs_spec[OF nxt]"], ["proof (state)\nthis:\n  set prevs' =\n  {uu_.\n   \\<exists>v i j.\n      uu_ = (j, f (tail !! j) v) \\<and> (i, v) \\<in> set prevs \\<and> j < i}\n  set out = (f head \\<circ> snd) ` set prevs \\<union> snd ` set prevs'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set prevs' \\<Longrightarrow>\n       x \\<in> set_prevs base (IArray.list_of tail) (Suc n)\n 2. \\<And>x.\n       x \\<in> set_prevs base (IArray.list_of tail)\n                (Suc n) \\<Longrightarrow>\n       x \\<in> set prevs'", "show \"t \\<in> ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> set prevs'", "proof(cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> t \\<in> set prevs'\n 2. n \\<noteq> 0 \\<Longrightarrow> t \\<in> set prevs'", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> t \\<in> set prevs'\n 2. n \\<noteq> 0 \\<Longrightarrow> t \\<in> set prevs'", "from sl[unfolded subseq_of_length_Suc_upt] t"], ["proof (chain)\npicking this:\n  if n = 0 then length iis = Suc 0 \\<and> hd iis < IArray.length tail\n  else hd iis < hd (tl iis) \\<and>\n       subseq_of_length n [0..<IArray.length tail] (tl iis)\n  t = (hd iis, foldr f (map ((!!) tail) iis) base)", "show ?thesis"], ["proof (prove)\nusing this:\n  if n = 0 then length iis = Suc 0 \\<and> hd iis < IArray.length tail\n  else hd iis < hd (tl iis) \\<and>\n       subseq_of_length n [0..<IArray.length tail] (tl iis)\n  t = (hd iis, foldr f (map ((!!) tail) iis) base)\n\ngoal (1 subgoal):\n 1. t \\<in> set prevs'", "by (unfold nxt[unfolded inv_prevs] True set_prevs_def length_Suc_conv, auto)"], ["proof (state)\nthis:\n  t \\<in> set prevs'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> t \\<in> set prevs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> t \\<in> set prevs'", "case [simp]: False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> t \\<in> set prevs'", "from sl[unfolded subseq_of_length_Suc_upt iis,simplified]"], ["proof (chain)\npicking this:\n  i < hd is \\<and> subseq_of_length n [0..<length (IArray.list_of tail)] is", "have i: \"i < hd is\" and \"is\": \"subseq_of_length n [0..<IArray.length tail] is\""], ["proof (prove)\nusing this:\n  i < hd is \\<and> subseq_of_length n [0..<length (IArray.list_of tail)] is\n\ngoal (1 subgoal):\n 1. i < hd is &&& subseq_of_length n [0..<IArray.length tail] is", "by auto"], ["proof (state)\nthis:\n  i < hd is\n  subseq_of_length n [0..<IArray.length tail] is\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> t \\<in> set prevs'", "then"], ["proof (chain)\npicking this:\n  i < hd is\n  subseq_of_length n [0..<IArray.length tail] is", "have *: \"(hd is, v) \\<in> set_prevs base (IArray.list_of tail) n\""], ["proof (prove)\nusing this:\n  i < hd is\n  subseq_of_length n [0..<IArray.length tail] is\n\ngoal (1 subgoal):\n 1. (hd is, v) \\<in> set_prevs base (IArray.list_of tail) n", "by (unfold set_prevs_def, auto intro!: exI[of _ \"is\"] simp: v_def)"], ["proof (state)\nthis:\n  (hd is, v) \\<in> set_prevs base (IArray.list_of tail) n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> t \\<in> set prevs'", "with i"], ["proof (chain)\npicking this:\n  i < hd is\n  (hd is, v) \\<in> set_prevs base (IArray.list_of tail) n", "have \"(i, f (tail !! i) v) \\<in> {(j, f (tail !! j) v) | j. j < hd is}\""], ["proof (prove)\nusing this:\n  i < hd is\n  (hd is, v) \\<in> set_prevs base (IArray.list_of tail) n\n\ngoal (1 subgoal):\n 1. (i, f (tail !! i) v) \\<in> {(j, f (tail !! j) v) |j. j < hd is}", "by auto"], ["proof (state)\nthis:\n  (i, f (tail !! i) v) \\<in> {(j, f (tail !! j) v) |j. j < hd is}\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> t \\<in> set prevs'", "with t[unfolded iis]"], ["proof (chain)\npicking this:\n  t = (hd (i # is), foldr f (map ((!!) tail) (i # is)) base)\n  (i, f (tail !! i) v) \\<in> {(j, f (tail !! j) v) |j. j < hd is}", "have \"t \\<in> ...\""], ["proof (prove)\nusing this:\n  t = (hd (i # is), foldr f (map ((!!) tail) (i # is)) base)\n  (i, f (tail !! i) v) \\<in> {(j, f (tail !! j) v) |j. j < hd is}\n\ngoal (1 subgoal):\n 1. t \\<in> {(j, f (tail !! j) v) |j. j < hd is}", "by (auto simp: v_def)"], ["proof (state)\nthis:\n  t \\<in> {(j, f (tail !! j) v) |j. j < hd is}\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> t \\<in> set prevs'", "with *"], ["proof (chain)\npicking this:\n  (hd is, v) \\<in> set_prevs base (IArray.list_of tail) n\n  t \\<in> {(j, f (tail !! j) v) |j. j < hd is}", "show ?thesis"], ["proof (prove)\nusing this:\n  (hd is, v) \\<in> set_prevs base (IArray.list_of tail) n\n  t \\<in> {(j, f (tail !! j) v) |j. j < hd is}\n\ngoal (1 subgoal):\n 1. t \\<in> set prevs'", "by (unfold nxt[unfolded inv_prevs], auto)"], ["proof (state)\nthis:\n  t \\<in> set prevs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<in> set prevs'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set prevs' \\<Longrightarrow>\n       x \\<in> set_prevs base (IArray.list_of tail) (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set prevs' \\<Longrightarrow>\n       x \\<in> set_prevs base (IArray.list_of tail) (Suc n)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set prevs' \\<Longrightarrow>\n       x \\<in> set_prevs base (IArray.list_of tail) (Suc n)", "assume l: \"t \\<in> ?l\""], ["proof (state)\nthis:\n  t \\<in> set prevs'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set prevs' \\<Longrightarrow>\n       x \\<in> set_prevs base (IArray.list_of tail) (Suc n)", "from l[unfolded next_subseqs_spec(1)[OF nxt]]"], ["proof (chain)\npicking this:\n  t \\<in> {uu_.\n           \\<exists>v i j.\n              uu_ = (j, f (tail !! j) v) \\<and>\n              (i, v) \\<in> set prevs \\<and> j < i}", "obtain j v i\n  where t: \"t = (j, f (tail!!j) v)\"\n    and j: \"j < i\"\n    and iv: \"(i,v) \\<in> set prevs\""], ["proof (prove)\nusing this:\n  t \\<in> {uu_.\n           \\<exists>v i j.\n              uu_ = (j, f (tail !! j) v) \\<and>\n              (i, v) \\<in> set prevs \\<and> j < i}\n\ngoal (1 subgoal):\n 1. (\\<And>j v i.\n        \\<lbrakk>t = (j, f (tail !! j) v); j < i;\n         (i, v) \\<in> set prevs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t = (j, f (tail !! j) v)\n  j < i\n  (i, v) \\<in> set prevs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set prevs' \\<Longrightarrow>\n       x \\<in> set_prevs base (IArray.list_of tail) (Suc n)", "from iv[unfolded inv_prevs set_prevs_def, simplified]"], ["proof (chain)\npicking this:\n  \\<exists>is.\n     i = (if n = 0 then length (IArray.list_of tail) else hd is) \\<and>\n     v = foldr f (map ((!) (IArray.list_of tail)) is) base \\<and>\n     subseq_of_length n [0..<length (IArray.list_of tail)] is", "obtain \"is\"\n  where v: \"v = foldr f (map ((!!) tail) is) base\"\n    and \"is\": \"subseq_of_length n [0..<IArray.length tail] is\"\n    and i: \"if n = 0 then i = IArray.length tail else i = hd is\""], ["proof (prove)\nusing this:\n  \\<exists>is.\n     i = (if n = 0 then length (IArray.list_of tail) else hd is) \\<and>\n     v = foldr f (map ((!) (IArray.list_of tail)) is) base \\<and>\n     subseq_of_length n [0..<length (IArray.list_of tail)] is\n\ngoal (1 subgoal):\n 1. (\\<And>is.\n        \\<lbrakk>v = foldr f (map ((!!) tail) is) base;\n         subseq_of_length n [0..<IArray.length tail] is;\n         if n = 0 then i = IArray.length tail else i = hd is\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v = foldr f (map ((!!) tail) is) base\n  subseq_of_length n [0..<IArray.length tail] is\n  if n = 0 then i = IArray.length tail else i = hd is\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set prevs' \\<Longrightarrow>\n       x \\<in> set_prevs base (IArray.list_of tail) (Suc n)", "from \"is\" j i"], ["proof (chain)\npicking this:\n  subseq_of_length n [0..<IArray.length tail] is\n  j < i\n  if n = 0 then i = IArray.length tail else i = hd is", "have jis: \"subseq_of_length (Suc n) [0..<IArray.length tail] (j#is)\""], ["proof (prove)\nusing this:\n  subseq_of_length n [0..<IArray.length tail] is\n  j < i\n  if n = 0 then i = IArray.length tail else i = hd is\n\ngoal (1 subgoal):\n 1. subseq_of_length (Suc n) [0..<IArray.length tail] (j # is)", "by (unfold subseq_of_length_Suc_upt, auto)"], ["proof (state)\nthis:\n  subseq_of_length (Suc n) [0..<IArray.length tail] (j # is)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set prevs' \\<Longrightarrow>\n       x \\<in> set_prevs base (IArray.list_of tail) (Suc n)", "then"], ["proof (chain)\npicking this:\n  subseq_of_length (Suc n) [0..<IArray.length tail] (j # is)", "show \"t \\<in> ?r\""], ["proof (prove)\nusing this:\n  subseq_of_length (Suc n) [0..<IArray.length tail] (j # is)\n\ngoal (1 subgoal):\n 1. t \\<in> set_prevs base (IArray.list_of tail) (Suc n)", "by (auto intro!: exI[of _ \"j#is\"] simp: set_prevs_def t v)"], ["proof (state)\nthis:\n  t \\<in> set_prevs base (IArray.list_of tail) (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invariant_next_subseqs:\n  assumes inv: \"invariant base elements n state\"\n      and nxt: \"next_subseqs state = (out, state')\"\n  shows \"invariant base elements (Suc n) state'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant base elements (Suc n) state'", "proof(cases \"elements = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. elements = [] \\<Longrightarrow> invariant base elements (Suc n) state'\n 2. elements \\<noteq> [] \\<Longrightarrow>\n    invariant base elements (Suc n) state'", "case True"], ["proof (state)\nthis:\n  elements = []\n\ngoal (2 subgoals):\n 1. elements = [] \\<Longrightarrow> invariant base elements (Suc n) state'\n 2. elements \\<noteq> [] \\<Longrightarrow>\n    invariant base elements (Suc n) state'", "with inv nxt"], ["proof (chain)\npicking this:\n  invariant base elements n state\n  local.next_subseqs state = (out, state')\n  elements = []", "show ?thesis"], ["proof (prove)\nusing this:\n  invariant base elements n state\n  local.next_subseqs state = (out, state')\n  elements = []\n\ngoal (1 subgoal):\n 1. invariant base elements (Suc n) state'", "by(cases state, auto)"], ["proof (state)\nthis:\n  invariant base elements (Suc n) state'\n\ngoal (1 subgoal):\n 1. elements \\<noteq> [] \\<Longrightarrow>\n    invariant base elements (Suc n) state'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. elements \\<noteq> [] \\<Longrightarrow>\n    invariant base elements (Suc n) state'", "case False"], ["proof (state)\nthis:\n  elements \\<noteq> []\n\ngoal (1 subgoal):\n 1. elements \\<noteq> [] \\<Longrightarrow>\n    invariant base elements (Suc n) state'", "with inv nxt"], ["proof (chain)\npicking this:\n  invariant base elements n state\n  local.next_subseqs state = (out, state')\n  elements \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  invariant base elements n state\n  local.next_subseqs state = (out, state')\n  elements \\<noteq> []\n\ngoal (1 subgoal):\n 1. invariant base elements (Suc n) state'", "proof (cases state)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>invariant base elements n state;\n        local.next_subseqs state = (out, state'); elements \\<noteq> [];\n        state = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> invariant base elements (Suc n) state'", "case state: (fields head tail prevs)"], ["proof (state)\nthis:\n  state = (head, tail, prevs)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>invariant base elements n state;\n        local.next_subseqs state = (out, state'); elements \\<noteq> [];\n        state = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> invariant base elements (Suc n) state'", "note inv = inv[unfolded state]"], ["proof (state)\nthis:\n  invariant base elements n (head, tail, prevs)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>invariant base elements n state;\n        local.next_subseqs state = (out, state'); elements \\<noteq> [];\n        state = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> invariant base elements (Suc n) state'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant base elements (Suc n) state'", "proof (cases state')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       state' = (a, b, c) \\<Longrightarrow>\n       invariant base elements (Suc n) state'", "case state': (fields head' tail' prevs')"], ["proof (state)\nthis:\n  state' = (head', tail', prevs')\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       state' = (a, b, c) \\<Longrightarrow>\n       invariant base elements (Suc n) state'", "note nxt = nxt[unfolded state state']"], ["proof (state)\nthis:\n  local.next_subseqs (head, tail, prevs) = (out, head', tail', prevs')\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       state' = (a, b, c) \\<Longrightarrow>\n       invariant base elements (Suc n) state'", "note [simp] = next_subseq_preserve[OF nxt]"], ["proof (state)\nthis:\n  head' = head\n  tail' = tail\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       state' = (a, b, c) \\<Longrightarrow>\n       invariant base elements (Suc n) state'", "from False inv"], ["proof (chain)\npicking this:\n  elements \\<noteq> []\n  invariant base elements n (head, tail, prevs)", "have \"set prevs = set_prevs base (IArray.list_of tail) n\""], ["proof (prove)\nusing this:\n  elements \\<noteq> []\n  invariant base elements n (head, tail, prevs)\n\ngoal (1 subgoal):\n 1. set prevs = set_prevs base (IArray.list_of tail) n", "by auto"], ["proof (state)\nthis:\n  set prevs = set_prevs base (IArray.list_of tail) n\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       state' = (a, b, c) \\<Longrightarrow>\n       invariant base elements (Suc n) state'", "from False next_subseq_prevs[OF nxt this] inv"], ["proof (chain)\npicking this:\n  elements \\<noteq> []\n  set prevs' = set_prevs base (IArray.list_of tail) (Suc n)\n  invariant base elements n (head, tail, prevs)", "show ?thesis"], ["proof (prove)\nusing this:\n  elements \\<noteq> []\n  set prevs' = set_prevs base (IArray.list_of tail) (Suc n)\n  invariant base elements n (head, tail, prevs)\n\ngoal (1 subgoal):\n 1. invariant base elements (Suc n) state'", "by(auto simp: state')"], ["proof (state)\nthis:\n  invariant base elements (Suc n) state'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invariant base elements (Suc n) state'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invariant base elements (Suc n) state'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma out_next_subseqs:\n  assumes inv: \"invariant base elements n state\"\n      and nxt: \"next_subseqs state = (out, state')\"\n  shows \"set out = S base elements (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set out = S base elements (Suc n)", "proof (cases state)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       state = (a, b, c) \\<Longrightarrow> set out = S base elements (Suc n)", "case state: (fields head tail prevs)"], ["proof (state)\nthis:\n  state = (head, tail, prevs)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       state = (a, b, c) \\<Longrightarrow> set out = S base elements (Suc n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set out = S base elements (Suc n)", "proof(cases \"elements = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. elements = [] \\<Longrightarrow> set out = S base elements (Suc n)\n 2. elements \\<noteq> [] \\<Longrightarrow> set out = S base elements (Suc n)", "case True"], ["proof (state)\nthis:\n  elements = []\n\ngoal (2 subgoals):\n 1. elements = [] \\<Longrightarrow> set out = S base elements (Suc n)\n 2. elements \\<noteq> [] \\<Longrightarrow> set out = S base elements (Suc n)", "with inv nxt"], ["proof (chain)\npicking this:\n  invariant base elements n state\n  local.next_subseqs state = (out, state')\n  elements = []", "show ?thesis"], ["proof (prove)\nusing this:\n  invariant base elements n state\n  local.next_subseqs state = (out, state')\n  elements = []\n\ngoal (1 subgoal):\n 1. set out = S base elements (Suc n)", "by (auto simp: state S_def)"], ["proof (state)\nthis:\n  set out = S base elements (Suc n)\n\ngoal (1 subgoal):\n 1. elements \\<noteq> [] \\<Longrightarrow> set out = S base elements (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. elements \\<noteq> [] \\<Longrightarrow> set out = S base elements (Suc n)", "case elements: False"], ["proof (state)\nthis:\n  elements \\<noteq> []\n\ngoal (1 subgoal):\n 1. elements \\<noteq> [] \\<Longrightarrow> set out = S base elements (Suc n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set out = S base elements (Suc n)", "proof(cases state')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       state' = (a, b, c) \\<Longrightarrow>\n       set out = S base elements (Suc n)", "case state': (fields head' tail' prevs')"], ["proof (state)\nthis:\n  state' = (head', tail', prevs')\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       state' = (a, b, c) \\<Longrightarrow>\n       set out = S base elements (Suc n)", "from elements inv[unfolded state,simplified]"], ["proof (chain)\npicking this:\n  elements \\<noteq> []\n  if elements = [] then prevs = []\n  else head = hd elements \\<and>\n       tail = IArray (tl elements) \\<and>\n       set prevs = set_prevs base (tl elements) n", "have \"head = hd elements\"\n       and \"tail = IArray (tl elements)\"\n       and prevs: \"set prevs = set_prevs base (tl elements) n\""], ["proof (prove)\nusing this:\n  elements \\<noteq> []\n  if elements = [] then prevs = []\n  else head = hd elements \\<and>\n       tail = IArray (tl elements) \\<and>\n       set prevs = set_prevs base (tl elements) n\n\ngoal (1 subgoal):\n 1. head = hd elements &&&\n    tail = IArray (tl elements) &&&\n    set prevs = set_prevs base (tl elements) n", "by auto"], ["proof (state)\nthis:\n  head = hd elements\n  tail = IArray (tl elements)\n  set prevs = set_prevs base (tl elements) n\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       state' = (a, b, c) \\<Longrightarrow>\n       set out = S base elements (Suc n)", "with elements"], ["proof (chain)\npicking this:\n  elements \\<noteq> []\n  head = hd elements\n  tail = IArray (tl elements)\n  set prevs = set_prevs base (tl elements) n", "have elements2: \"elements = head # IArray.list_of tail\""], ["proof (prove)\nusing this:\n  elements \\<noteq> []\n  head = hd elements\n  tail = IArray (tl elements)\n  set prevs = set_prevs base (tl elements) n\n\ngoal (1 subgoal):\n 1. elements = head # IArray.list_of tail", "by auto"], ["proof (state)\nthis:\n  elements = head # IArray.list_of tail\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       state' = (a, b, c) \\<Longrightarrow>\n       set out = S base elements (Suc n)", "let ?f = \"\\<lambda>as. (foldr f as base)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       state' = (a, b, c) \\<Longrightarrow>\n       set out = S base elements (Suc n)", "have \"set out = ?f ` {ys. subseq_of_length (Suc n) elements ys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set out =\n    (\\<lambda>as. foldr f as base) `\n    {ys. subseq_of_length (Suc n) elements ys}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. set out =\n    (\\<lambda>as. foldr f as base) `\n    {ys. subseq_of_length (Suc n) elements ys}", "from invariant_next_subseqs[OF inv nxt, unfolded state' invariant.simps if_not_P[OF elements]]"], ["proof (chain)\npicking this:\n  head' = hd elements \\<and>\n  tail' = IArray (tl elements) \\<and>\n  set prevs' = set_prevs base (tl elements) (Suc n)", "have tail': \"tail' = IArray (tl elements)\"\n         and prevs': \"set prevs' = set_prevs base (tl elements) (Suc n)\""], ["proof (prove)\nusing this:\n  head' = hd elements \\<and>\n  tail' = IArray (tl elements) \\<and>\n  set prevs' = set_prevs base (tl elements) (Suc n)\n\ngoal (1 subgoal):\n 1. tail' = IArray (tl elements) &&&\n    set prevs' = set_prevs base (tl elements) (Suc n)", "by auto"], ["proof (state)\nthis:\n  tail' = IArray (tl elements)\n  set prevs' = set_prevs base (tl elements) (Suc n)\n\ngoal (1 subgoal):\n 1. set out =\n    (\\<lambda>as. foldr f as base) `\n    {ys. subseq_of_length (Suc n) elements ys}", "note next_subseqs_spec(2)[OF nxt[unfolded state state'], unfolded this]"], ["proof (state)\nthis:\n  set out =\n  (f head \\<circ> snd) ` set prevs \\<union>\n  snd ` set_prevs base (tl elements) (Suc n)\n\ngoal (1 subgoal):\n 1. set out =\n    (\\<lambda>as. foldr f as base) `\n    {ys. subseq_of_length (Suc n) elements ys}", "note this[folded image_comp, unfolded snd_set_prevs]"], ["proof (state)\nthis:\n  set out =\n  f head ` snd ` set prevs \\<union>\n  (\\<lambda>as. foldr f as base) `\n  Collect (subseq_of_length (Suc n) (tl elements))\n\ngoal (1 subgoal):\n 1. set out =\n    (\\<lambda>as. foldr f as base) `\n    {ys. subseq_of_length (Suc n) elements ys}", "also"], ["proof (state)\nthis:\n  set out =\n  f head ` snd ` set prevs \\<union>\n  (\\<lambda>as. foldr f as base) `\n  Collect (subseq_of_length (Suc n) (tl elements))\n\ngoal (1 subgoal):\n 1. set out =\n    (\\<lambda>as. foldr f as base) `\n    {ys. subseq_of_length (Suc n) elements ys}", "note prevs"], ["proof (state)\nthis:\n  set prevs = set_prevs base (tl elements) n\n\ngoal (1 subgoal):\n 1. set out =\n    (\\<lambda>as. foldr f as base) `\n    {ys. subseq_of_length (Suc n) elements ys}", "also"], ["proof (state)\nthis:\n  set prevs = set_prevs base (tl elements) n\n\ngoal (1 subgoal):\n 1. set out =\n    (\\<lambda>as. foldr f as base) `\n    {ys. subseq_of_length (Suc n) elements ys}", "note snd_set_prevs"], ["proof (state)\nthis:\n  snd ` set_prevs ?base ?tail ?n =\n  (\\<lambda>as. foldr f as ?base) ` {as. subseq_of_length ?n ?tail as}\n\ngoal (1 subgoal):\n 1. set out =\n    (\\<lambda>as. foldr f as base) `\n    {ys. subseq_of_length (Suc n) elements ys}", "also"], ["proof (state)\nthis:\n  snd ` set_prevs ?base ?tail ?n =\n  (\\<lambda>as. foldr f as ?base) ` {as. subseq_of_length ?n ?tail as}\n\ngoal (1 subgoal):\n 1. set out =\n    (\\<lambda>as. foldr f as base) `\n    {ys. subseq_of_length (Suc n) elements ys}", "have \"f head ` ?f ` { as. subseq_of_length n (tl elements) as } =\n          ?f ` Cons head ` { as. subseq_of_length n (tl elements) as }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f head `\n    (\\<lambda>as. foldr f as base) `\n    {as. subseq_of_length n (tl elements) as} =\n    (\\<lambda>as. foldr f as base) `\n    (#) head ` {as. subseq_of_length n (tl elements) as}", "by (auto simp: image_def)"], ["proof (state)\nthis:\n  f head `\n  (\\<lambda>as. foldr f as base) `\n  {as. subseq_of_length n (tl elements) as} =\n  (\\<lambda>as. foldr f as base) `\n  (#) head ` {as. subseq_of_length n (tl elements) as}\n\ngoal (1 subgoal):\n 1. set out =\n    (\\<lambda>as. foldr f as base) `\n    {ys. subseq_of_length (Suc n) elements ys}", "also"], ["proof (state)\nthis:\n  f head `\n  (\\<lambda>as. foldr f as base) `\n  {as. subseq_of_length n (tl elements) as} =\n  (\\<lambda>as. foldr f as base) `\n  (#) head ` {as. subseq_of_length n (tl elements) as}\n\ngoal (1 subgoal):\n 1. set out =\n    (\\<lambda>as. foldr f as base) `\n    {ys. subseq_of_length (Suc n) elements ys}", "note image_Un[symmetric]"], ["proof (state)\nthis:\n  ?f ` ?A \\<union> ?f ` ?B = ?f ` (?A \\<union> ?B)\n\ngoal (1 subgoal):\n 1. set out =\n    (\\<lambda>as. foldr f as base) `\n    {ys. subseq_of_length (Suc n) elements ys}", "also"], ["proof (state)\nthis:\n  ?f ` ?A \\<union> ?f ` ?B = ?f ` (?A \\<union> ?B)\n\ngoal (1 subgoal):\n 1. set out =\n    (\\<lambda>as. foldr f as base) `\n    {ys. subseq_of_length (Suc n) elements ys}", "have\n          \"((#) head ` {as. subseq_of_length n (tl elements) as} \\<union>\n           {as. subseq_of_length (Suc n) (tl elements) as}) =\n           {as. subseq_of_length (Suc n) elements as}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (#) head ` {as. subseq_of_length n (tl elements) as} \\<union>\n    {as. subseq_of_length (Suc n) (tl elements) as} =\n    {as. subseq_of_length (Suc n) elements as}", "by (unfold subseqs_of_length_Suc_Cons elements2, auto)"], ["proof (state)\nthis:\n  (#) head ` {as. subseq_of_length n (tl elements) as} \\<union>\n  {as. subseq_of_length (Suc n) (tl elements) as} =\n  {as. subseq_of_length (Suc n) elements as}\n\ngoal (1 subgoal):\n 1. set out =\n    (\\<lambda>as. foldr f as base) `\n    {ys. subseq_of_length (Suc n) elements ys}", "finally"], ["proof (chain)\npicking this:\n  set out =\n  (\\<lambda>as. foldr f as base) `\n  {as. subseq_of_length (Suc n) elements as}", "show ?thesis"], ["proof (prove)\nusing this:\n  set out =\n  (\\<lambda>as. foldr f as base) `\n  {as. subseq_of_length (Suc n) elements as}\n\ngoal (1 subgoal):\n 1. set out =\n    (\\<lambda>as. foldr f as base) `\n    {ys. subseq_of_length (Suc n) elements ys}", "."], ["proof (state)\nthis:\n  set out =\n  (\\<lambda>as. foldr f as base) `\n  {ys. subseq_of_length (Suc n) elements ys}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set out =\n  (\\<lambda>as. foldr f as base) `\n  {ys. subseq_of_length (Suc n) elements ys}\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       state' = (a, b, c) \\<Longrightarrow>\n       set out = S base elements (Suc n)", "then"], ["proof (chain)\npicking this:\n  set out =\n  (\\<lambda>as. foldr f as base) `\n  {ys. subseq_of_length (Suc n) elements ys}", "show ?thesis"], ["proof (prove)\nusing this:\n  set out =\n  (\\<lambda>as. foldr f as base) `\n  {ys. subseq_of_length (Suc n) elements ys}\n\ngoal (1 subgoal):\n 1. set out = S base elements (Suc n)", "by (auto simp: S_def)"], ["proof (state)\nthis:\n  set out = S base elements (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set out = S base elements (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set out = S base elements (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma create_subseqs:\n  \"create_subseqs base elements n = (out, state) \\<Longrightarrow>\n   invariant base elements n state \\<and> set out = S base elements n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.create_subseqs base elements n = (out, state) \\<Longrightarrow>\n    invariant base elements n state \\<and> set out = S base elements n", "proof(induct n arbitrary: out state)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>out state.\n       local.create_subseqs base elements 0 = (out, state) \\<Longrightarrow>\n       invariant base elements 0 state \\<and> set out = S base elements 0\n 2. \\<And>n out state.\n       \\<lbrakk>\\<And>out state.\n                   local.create_subseqs base elements n =\n                   (out, state) \\<Longrightarrow>\n                   invariant base elements n state \\<and>\n                   set out = S base elements n;\n        local.create_subseqs base elements (Suc n) = (out, state)\\<rbrakk>\n       \\<Longrightarrow> invariant base elements (Suc n) state \\<and>\n                         set out = S base elements (Suc n)", "case 0"], ["proof (state)\nthis:\n  local.create_subseqs base elements 0 = (out, state)\n\ngoal (2 subgoals):\n 1. \\<And>out state.\n       local.create_subseqs base elements 0 = (out, state) \\<Longrightarrow>\n       invariant base elements 0 state \\<and> set out = S base elements 0\n 2. \\<And>n out state.\n       \\<lbrakk>\\<And>out state.\n                   local.create_subseqs base elements n =\n                   (out, state) \\<Longrightarrow>\n                   invariant base elements n state \\<and>\n                   set out = S base elements n;\n        local.create_subseqs base elements (Suc n) = (out, state)\\<rbrakk>\n       \\<Longrightarrow> invariant base elements (Suc n) state \\<and>\n                         set out = S base elements (Suc n)", "then"], ["proof (chain)\npicking this:\n  local.create_subseqs base elements 0 = (out, state)", "show ?case"], ["proof (prove)\nusing this:\n  local.create_subseqs base elements 0 = (out, state)\n\ngoal (1 subgoal):\n 1. invariant base elements 0 state \\<and> set out = S base elements 0", "by (cases \"elements\", cases state, auto simp: S_def Let_def set_prevs_def)"], ["proof (state)\nthis:\n  invariant base elements 0 state \\<and> set out = S base elements 0\n\ngoal (1 subgoal):\n 1. \\<And>n out state.\n       \\<lbrakk>\\<And>out state.\n                   local.create_subseqs base elements n =\n                   (out, state) \\<Longrightarrow>\n                   invariant base elements n state \\<and>\n                   set out = S base elements n;\n        local.create_subseqs base elements (Suc n) = (out, state)\\<rbrakk>\n       \\<Longrightarrow> invariant base elements (Suc n) state \\<and>\n                         set out = S base elements (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n out state.\n       \\<lbrakk>\\<And>out state.\n                   local.create_subseqs base elements n =\n                   (out, state) \\<Longrightarrow>\n                   invariant base elements n state \\<and>\n                   set out = S base elements n;\n        local.create_subseqs base elements (Suc n) = (out, state)\\<rbrakk>\n       \\<Longrightarrow> invariant base elements (Suc n) state \\<and>\n                         set out = S base elements (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  local.create_subseqs base elements n =\n  (?out10, ?state10) \\<Longrightarrow>\n  invariant base elements n ?state10 \\<and> set ?out10 = S base elements n\n  local.create_subseqs base elements (Suc n) = (out, state)\n\ngoal (1 subgoal):\n 1. \\<And>n out state.\n       \\<lbrakk>\\<And>out state.\n                   local.create_subseqs base elements n =\n                   (out, state) \\<Longrightarrow>\n                   invariant base elements n state \\<and>\n                   set out = S base elements n;\n        local.create_subseqs base elements (Suc n) = (out, state)\\<rbrakk>\n       \\<Longrightarrow> invariant base elements (Suc n) state \\<and>\n                         set out = S base elements (Suc n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant base elements (Suc n) state \\<and>\n    set out = S base elements (Suc n)", "proof (cases \"create_subseqs base elements n\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       local.create_subseqs base elements n = (a, b, c, d) \\<Longrightarrow>\n       invariant base elements (Suc n) state \\<and>\n       set out = S base elements (Suc n)", "case 1: (fields out'' head tail prevs)"], ["proof (state)\nthis:\n  local.create_subseqs base elements n = (out'', head, tail, prevs)\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       local.create_subseqs base elements n = (a, b, c, d) \\<Longrightarrow>\n       invariant base elements (Suc n) state \\<and>\n       set out = S base elements (Suc n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant base elements (Suc n) state \\<and>\n    set out = S base elements (Suc n)", "proof (cases \"next_subseqs (head, tail, prevs)\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       local.next_subseqs (head, tail, prevs) =\n       (a, b, c, d) \\<Longrightarrow>\n       invariant base elements (Suc n) state \\<and>\n       set out = S base elements (Suc n)", "case (fields out' head' tail' prevs')"], ["proof (state)\nthis:\n  local.next_subseqs (head, tail, prevs) = (out', head', tail', prevs')\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       local.next_subseqs (head, tail, prevs) =\n       (a, b, c, d) \\<Longrightarrow>\n       invariant base elements (Suc n) state \\<and>\n       set out = S base elements (Suc n)", "note 2 = this[unfolded next_subseq_preserve[OF this]]"], ["proof (state)\nthis:\n  local.next_subseqs (head, tail, prevs) = (out', head, tail, prevs')\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       local.next_subseqs (head, tail, prevs) =\n       (a, b, c, d) \\<Longrightarrow>\n       invariant base elements (Suc n) state \\<and>\n       set out = S base elements (Suc n)", "from Suc(2)[unfolded create_subseqs.simps 1 snd_conv 2]"], ["proof (chain)\npicking this:\n  (out', head, tail, prevs') = (out, state)", "have 3: \"out' = out\" \"state = (head,tail,prevs')\""], ["proof (prove)\nusing this:\n  (out', head, tail, prevs') = (out, state)\n\ngoal (1 subgoal):\n 1. out' = out &&& state = (head, tail, prevs')", "by auto"], ["proof (state)\nthis:\n  out' = out\n  state = (head, tail, prevs')\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       local.next_subseqs (head, tail, prevs) =\n       (a, b, c, d) \\<Longrightarrow>\n       invariant base elements (Suc n) state \\<and>\n       set out = S base elements (Suc n)", "from Suc(1)[OF 1]"], ["proof (chain)\npicking this:\n  invariant base elements n (head, tail, prevs) \\<and>\n  set out'' = S base elements n", "have inv: \"invariant base elements n (head, tail, prevs)\""], ["proof (prove)\nusing this:\n  invariant base elements n (head, tail, prevs) \\<and>\n  set out'' = S base elements n\n\ngoal (1 subgoal):\n 1. invariant base elements n (head, tail, prevs)", "by auto"], ["proof (state)\nthis:\n  invariant base elements n (head, tail, prevs)\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       local.next_subseqs (head, tail, prevs) =\n       (a, b, c, d) \\<Longrightarrow>\n       invariant base elements (Suc n) state \\<and>\n       set out = S base elements (Suc n)", "from out_next_subseqs[OF inv 2] invariant_next_subseqs[OF inv 2]"], ["proof (chain)\npicking this:\n  set out' = S base elements (Suc n)\n  invariant base elements (Suc n) (head, tail, prevs')", "show ?thesis"], ["proof (prove)\nusing this:\n  set out' = S base elements (Suc n)\n  invariant base elements (Suc n) (head, tail, prevs')\n\ngoal (1 subgoal):\n 1. invariant base elements (Suc n) state \\<and>\n    set out = S base elements (Suc n)", "by (auto simp: 3)"], ["proof (state)\nthis:\n  invariant base elements (Suc n) state \\<and>\n  set out = S base elements (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invariant base elements (Suc n) state \\<and>\n  set out = S base elements (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invariant base elements (Suc n) state \\<and>\n  set out = S base elements (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale correct_subseqs_foldr_impl f impl invariant"], ["proof (prove)\ngoal (1 subgoal):\n 1. correct_subseqs_foldr_impl f impl invariant", "by (unfold_locales; auto simp: impl_def invariant_next_subseqs out_next_subseqs create_subseqs)"], ["", "lemma impl_correct: \"correct_subseqs_foldr_impl f impl invariant\""], ["proof (prove)\ngoal (1 subgoal):\n 1. correct_subseqs_foldr_impl f impl invariant", ".."], ["", "end"], ["", "lemmas [code] =\n  my_subseqs.next_subseqs.simps\n  my_subseqs.next_subseqs1.simps\n  my_subseqs.next_subseqs2.simps\n  my_subseqs.create_subseqs.simps\n  my_subseqs.impl_def"], ["", "end"]]}