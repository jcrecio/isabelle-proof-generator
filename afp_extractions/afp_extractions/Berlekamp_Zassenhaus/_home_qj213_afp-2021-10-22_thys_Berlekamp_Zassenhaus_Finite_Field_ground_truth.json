{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Finite_Field.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma CARD_mod_ring[simp]: \"CARD('a mod_ring) = CARD('a::finite)\"", "lemma int_nat_card[simp]: \"int (nat CARD('a::finite)) = CARD('a)\"", "lemma of_int_mod_ring_to_int_mod_ring[simp]:\n  \"of_int_mod_ring (to_int_mod_ring x) = x\"", "lemma to_int_mod_ring_of_int_mod_ring[simp]: \"0 \\<le> x \\<Longrightarrow> x < int CARD('a :: finite) \\<Longrightarrow>\n  to_int_mod_ring (of_int_mod_ring x :: 'a mod_ring) = x\"", "lemma range_to_int_mod_ring:\n  \"range (to_int_mod_ring :: ('a :: finite mod_ring \\<Rightarrow> int)) = {0 ..< CARD('a)}\"", "lemma of_nat_of_int_mod_ring [code_unfold]:\n  \"of_nat = of_int_mod_ring o int\"", "lemma of_nat_card_eq_0[simp]: \"(of_nat (CARD('a::nontriv)) :: 'a mod_ring) = 0\"", "lemma of_int_of_int_mod_ring[code_unfold]: \"of_int = of_int_mod_ring\"", "lemma pcr_mod_ring_to_int_mod_ring: \"pcr_mod_ring = (\\<lambda>x y. x = to_int_mod_ring y)\"", "lemma [transfer_rule]:\n  \"((=) ===> pcr_mod_ring) (\\<lambda> x. int x mod int (CARD('a :: nontriv))) (of_nat :: nat \\<Rightarrow> 'a mod_ring)\"", "lemma [transfer_rule]:\n  \"((=) ===> pcr_mod_ring) (\\<lambda> x. x mod int (CARD('a :: nontriv))) (of_int :: int \\<Rightarrow> 'a mod_ring)\"", "lemma one_mod_card [simp]: \"1 mod CARD('a::nontriv) = 1\"", "lemma Suc_0_mod_card [simp]: \"Suc 0 mod CARD('a::nontriv) = 1\"", "lemma one_mod_card_int [simp]: \"1 mod int CARD('a::nontriv) = 1\"", "lemma pow_mod_ring_transfer[transfer_rule]:\n  \"(pcr_mod_ring ===> (=) ===> pcr_mod_ring) \n   (\\<lambda>a::int. \\<lambda>n. a^n mod CARD('a::nontriv)) ((^)::'a mod_ring \\<Rightarrow> nat \\<Rightarrow> 'a mod_ring)\"", "lemma dvd_mod_ring_transfer[transfer_rule]:\n\"((pcr_mod_ring :: int \\<Rightarrow> 'a :: nontriv mod_ring \\<Rightarrow> bool) ===>\n  (pcr_mod_ring :: int \\<Rightarrow> 'a mod_ring \\<Rightarrow> bool) ===> (=))\n  (\\<lambda> i j. \\<exists>k \\<in> {0..<int CARD('a)}. j = i * k mod int CARD('a)) (dvd)\"", "lemma Rep_mod_ring_mod[simp]: \"Rep_mod_ring (a :: 'a :: nontriv mod_ring) mod CARD('a) = Rep_mod_ring a\"", "lemma prime_card_int: \"prime (int (CARD('a)))\"", "lemma surj_of_nat_mod_ring: \"\\<exists> i. i < CARD('a :: prime_card) \\<and> (x :: 'a mod_ring) = of_nat i\"", "lemma of_nat_0_mod_ring_dvd: assumes x: \"of_nat x = (0 :: 'a ::prime_card mod_ring)\"\n  shows \"CARD('a) dvd x\""], "translations": [["", "lemma CARD_mod_ring[simp]: \"CARD('a mod_ring) = CARD('a::finite)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a mod_ring) = CARD('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CARD('a mod_ring) = CARD('a)", "have \"card {y. \\<exists>x\\<in>{0..<int CARD('a)}. (y::'a mod_ring) = Abs_mod_ring x} = card {0..<int CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x} =\n    card {0..<int CARD('a)}", "proof (rule bij_betw_same_card)"], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw ?f {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x}\n     {0..<int CARD('a)}", "have \"inj_on Rep_mod_ring {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Rep_mod_ring\n     {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x}", "by (meson Rep_mod_ring_inject inj_onI)"], ["proof (state)\nthis:\n  inj_on Rep_mod_ring\n   {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x}\n\ngoal (1 subgoal):\n 1. bij_betw ?f {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x}\n     {0..<int CARD('a)}", "moreover"], ["proof (state)\nthis:\n  inj_on Rep_mod_ring\n   {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x}\n\ngoal (1 subgoal):\n 1. bij_betw ?f {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x}\n     {0..<int CARD('a)}", "have \"Rep_mod_ring ` {y. \\<exists>x\\<in>{0..<int CARD('a)}. (y::'a mod_ring) = Abs_mod_ring x} = {0..<int CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_mod_ring `\n    {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x} =\n    {0..<int CARD('a)}", "proof (auto simp add: image_def Rep_mod_ring_inject)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xb.\n       \\<lbrakk>0 \\<le> xb; xb < int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> Rep_mod_ring (Abs_mod_ring xb)\n 2. \\<And>xb.\n       \\<lbrakk>0 \\<le> xb; xb < int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> Rep_mod_ring (Abs_mod_ring xb) < int CARD('a)\n 3. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>x\\<in>{0..<int CARD('a)}.\n                                xa = Abs_mod_ring x) \\<and>\n                            x = Rep_mod_ring xa", "fix xb"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xb.\n       \\<lbrakk>0 \\<le> xb; xb < int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> Rep_mod_ring (Abs_mod_ring xb)\n 2. \\<And>xb.\n       \\<lbrakk>0 \\<le> xb; xb < int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> Rep_mod_ring (Abs_mod_ring xb) < int CARD('a)\n 3. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>x\\<in>{0..<int CARD('a)}.\n                                xa = Abs_mod_ring x) \\<and>\n                            x = Rep_mod_ring xa", "show \"0 \\<le> Rep_mod_ring (Abs_mod_ring xb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Rep_mod_ring (Abs_mod_ring xb)", "using Rep_mod_ring atLeastLessThan_iff"], ["proof (prove)\nusing this:\n  Rep_mod_ring ?x \\<in> {0..<int CARD(?'a)}\n  (?i \\<in> {?l..<?u}) = (?l \\<le> ?i \\<and> ?i < ?u)\n\ngoal (1 subgoal):\n 1. 0 \\<le> Rep_mod_ring (Abs_mod_ring xb)", "by blast"], ["proof (state)\nthis:\n  0 \\<le> Rep_mod_ring (Abs_mod_ring xb)\n\ngoal (2 subgoals):\n 1. \\<And>xb.\n       \\<lbrakk>0 \\<le> xb; xb < int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> Rep_mod_ring (Abs_mod_ring xb) < int CARD('a)\n 2. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>x\\<in>{0..<int CARD('a)}.\n                                xa = Abs_mod_ring x) \\<and>\n                            x = Rep_mod_ring xa", "assume xb1: \"0 \\<le> xb\" and xb2: \"xb < int CARD('a)\""], ["proof (state)\nthis:\n  0 \\<le> xb\n  xb < int CARD('a)\n\ngoal (2 subgoals):\n 1. \\<And>xb.\n       \\<lbrakk>0 \\<le> xb; xb < int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> Rep_mod_ring (Abs_mod_ring xb) < int CARD('a)\n 2. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>x\\<in>{0..<int CARD('a)}.\n                                xa = Abs_mod_ring x) \\<and>\n                            x = Rep_mod_ring xa", "thus \" Rep_mod_ring (Abs_mod_ring xb) < int CARD('a)\""], ["proof (prove)\nusing this:\n  0 \\<le> xb\n  xb < int CARD('a)\n\ngoal (1 subgoal):\n 1. Rep_mod_ring (Abs_mod_ring xb) < int CARD('a)", "by (metis Abs_mod_ring_inverse Rep_mod_ring atLeastLessThan_iff le_less_trans linear)"], ["proof (state)\nthis:\n  Rep_mod_ring (Abs_mod_ring xb) < int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>x\\<in>{0..<int CARD('a)}.\n                                xa = Abs_mod_ring x) \\<and>\n                            x = Rep_mod_ring xa", "have xb: \"xb \\<in> {0..<int CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xb \\<in> {0..<int CARD('a)}", "using xb1 xb2"], ["proof (prove)\nusing this:\n  0 \\<le> xb\n  xb < int CARD('a)\n\ngoal (1 subgoal):\n 1. xb \\<in> {0..<int CARD('a)}", "by simp"], ["proof (state)\nthis:\n  xb \\<in> {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>x\\<in>{0..<int CARD('a)}.\n                                xa = Abs_mod_ring x) \\<and>\n                            x = Rep_mod_ring xa", "show \"\\<exists>xa::'a mod_ring. (\\<exists>x\\<in>{0..<int CARD('a)}. xa = Abs_mod_ring x) \\<and> xb = Rep_mod_ring xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xa.\n       (\\<exists>x\\<in>{0..<int CARD('a)}. xa = Abs_mod_ring x) \\<and>\n       xb = Rep_mod_ring xa", "by (rule exI[of _ \"Abs_mod_ring xb\"], auto simp add: xb1 xb2, rule Abs_mod_ring_inverse[OF xb, symmetric])"], ["proof (state)\nthis:\n  \\<exists>xa.\n     (\\<exists>x\\<in>{0..<int CARD('a)}. xa = Abs_mod_ring x) \\<and>\n     xb = Rep_mod_ring xa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Rep_mod_ring `\n  {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x} =\n  {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. bij_betw ?f {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x}\n     {0..<int CARD('a)}", "ultimately"], ["proof (chain)\npicking this:\n  inj_on Rep_mod_ring\n   {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x}\n  Rep_mod_ring `\n  {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x} =\n  {0..<int CARD('a)}", "show \"bij_betw Rep_mod_ring\n      {y. \\<exists>x\\<in>{0..<int CARD('a)}. (y::'a mod_ring) = Abs_mod_ring x} \n      {0..<int CARD('a)}\""], ["proof (prove)\nusing this:\n  inj_on Rep_mod_ring\n   {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x}\n  Rep_mod_ring `\n  {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x} =\n  {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. bij_betw Rep_mod_ring\n     {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x}\n     {0..<int CARD('a)}", "by (simp add: bij_betw_def)"], ["proof (state)\nthis:\n  bij_betw Rep_mod_ring\n   {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x}\n   {0..<int CARD('a)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x} =\n  card {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. CARD('a mod_ring) = CARD('a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  card {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x} =\n  card {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. CARD('a mod_ring) = CARD('a)", "unfolding type_definition.univ[OF type_definition_mod_ring]"], ["proof (prove)\nusing this:\n  card {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x} =\n  card {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. card (Abs_mod_ring ` {0..<int CARD('a)}) = CARD('a)", "unfolding image_def"], ["proof (prove)\nusing this:\n  card {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x} =\n  card {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. card {y. \\<exists>x\\<in>{0..<int CARD('a)}. y = Abs_mod_ring x} =\n    CARD('a)", "by auto"], ["proof (state)\nthis:\n  CARD('a mod_ring) = CARD('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance mod_ring :: (finite) finite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mod_ring, finite_class)", "proof (intro_classes)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV", "show \"finite (UNIV::'a mod_ring set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV", "unfolding type_definition.univ[OF type_definition_mod_ring]"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Abs_mod_ring ` {0..<int CARD('a)})", "using finite"], ["proof (prove)\nusing this:\n  finite ?A\n\ngoal (1 subgoal):\n 1. finite (Abs_mod_ring ` {0..<int CARD('a)})", "by simp"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation mod_ring :: (finite) equal\nbegin"], ["", "lift_definition equal_mod_ring :: \"'a mod_ring \\<Rightarrow> 'a mod_ring \\<Rightarrow> bool\" is \"(=)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mod_ring, equal_class)", "by (intro_classes, transfer, auto)"], ["", "end"], ["", "instantiation mod_ring :: (finite) comm_ring\nbegin"], ["", "lift_definition plus_mod_ring :: \"'a mod_ring \\<Rightarrow> 'a mod_ring \\<Rightarrow> 'a mod_ring\" is\n  \"\\<lambda> x y. (x + y) mod int (CARD('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>int1 int2.\n       \\<lbrakk>int1 \\<in> {0..<int CARD('a)};\n        int2 \\<in> {0..<int CARD('a)}\\<rbrakk>\n       \\<Longrightarrow> (int1 + int2) mod int CARD('a)\n                         \\<in> {0..<int CARD('a)}", "by simp"], ["", "lift_definition uminus_mod_ring :: \"'a mod_ring \\<Rightarrow> 'a mod_ring\" is\n  \"\\<lambda> x. if x = 0 then 0 else int (CARD('a)) - x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>inta.\n       inta \\<in> {0..<int CARD('a)} \\<Longrightarrow>\n       (if inta = 0 then 0 else int CARD('a) - inta)\n       \\<in> {0..<int CARD('a)}", "by simp"], ["", "lift_definition minus_mod_ring :: \"'a mod_ring \\<Rightarrow> 'a mod_ring \\<Rightarrow> 'a mod_ring\" is\n  \"\\<lambda> x y. (x - y) mod int (CARD('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>int1 int2.\n       \\<lbrakk>int1 \\<in> {0..<int CARD('a)};\n        int2 \\<in> {0..<int CARD('a)}\\<rbrakk>\n       \\<Longrightarrow> (int1 - int2) mod int CARD('a)\n                         \\<in> {0..<int CARD('a)}", "by simp"], ["", "lift_definition times_mod_ring :: \"'a mod_ring \\<Rightarrow> 'a mod_ring \\<Rightarrow> 'a mod_ring\" is\n  \"\\<lambda> x y. (x * y) mod int (CARD('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>int1 int2.\n       \\<lbrakk>int1 \\<in> {0..<int CARD('a)};\n        int2 \\<in> {0..<int CARD('a)}\\<rbrakk>\n       \\<Longrightarrow> int1 * int2 mod int CARD('a)\n                         \\<in> {0..<int CARD('a)}", "by simp"], ["", "lift_definition zero_mod_ring :: \"'a mod_ring\" is 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> {0..<int CARD('a)}", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mod_ring, comm_ring_class)", "by standard\n    (transfer; auto simp add: mod_simps algebra_simps intro: mod_diff_cong)+"], ["", "end"], ["", "lift_definition to_int_mod_ring :: \"'a::finite mod_ring \\<Rightarrow> int\" is \"\\<lambda> x. x\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition of_int_mod_ring :: \"int \\<Rightarrow> 'a::finite mod_ring\" is\n  \"\\<lambda> x. x mod int (CARD('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>inta. inta mod int CARD('a) \\<in> {0..<int CARD('a)}", "by simp"], ["", "interpretation to_int_mod_ring_hom: inj_zero_hom to_int_mod_ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_zero_hom to_int_mod_ring", "by (unfold_locales; transfer, auto)"], ["", "lemma int_nat_card[simp]: \"int (nat CARD('a::finite)) = CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (nat (int CARD('a))) = int CARD('a)", "by auto"], ["", "interpretation of_int_mod_ring_hom: zero_hom of_int_mod_ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_hom of_int_mod_ring", "by (unfold_locales, transfer, auto)"], ["", "lemma of_int_mod_ring_to_int_mod_ring[simp]:\n  \"of_int_mod_ring (to_int_mod_ring x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_mod_ring (to_int_mod_ring x) = x", "by (transfer, auto)"], ["", "lemma to_int_mod_ring_of_int_mod_ring[simp]: \"0 \\<le> x \\<Longrightarrow> x < int CARD('a :: finite) \\<Longrightarrow>\n  to_int_mod_ring (of_int_mod_ring x :: 'a mod_ring) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; x < int CARD('a)\\<rbrakk>\n    \\<Longrightarrow> to_int_mod_ring (of_int_mod_ring x) = x", "by (transfer, auto)"], ["", "lemma range_to_int_mod_ring:\n  \"range (to_int_mod_ring :: ('a :: finite mod_ring \\<Rightarrow> int)) = {0 ..< CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range to_int_mod_ring = {0..<int CARD('a)}", "apply (intro equalityI subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> range to_int_mod_ring \\<Longrightarrow>\n       x \\<in> {0..<int CARD('a)}\n 2. \\<And>x.\n       x \\<in> {0..<int CARD('a)} \\<Longrightarrow>\n       x \\<in> range to_int_mod_ring", "apply (elim rangeE, transfer, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<int CARD('a)} \\<Longrightarrow>\n       x \\<in> range to_int_mod_ring", "by (auto intro!: range_eqI to_int_mod_ring_of_int_mod_ring[symmetric])"], ["", "subsection \\<open>Nontrivial Finite Rings\\<close>"], ["", "class nontriv = assumes nontriv: \"CARD('a) > 1\""], ["", "subclass(in nontriv) finite"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.finite TYPE('a)", "by(intro_classes,insert nontriv,auto intro:card_ge_0_finite)"], ["", "instantiation mod_ring :: (nontriv) comm_ring_1\nbegin"], ["", "lift_definition one_mod_ring :: \"'a mod_ring\" is 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> {0..<int CARD('a)}", "using nontriv[where ?'a='a]"], ["proof (prove)\nusing this:\n  1 < CARD('a)\n\ngoal (1 subgoal):\n 1. 1 \\<in> {0..<int CARD('a)}", "by auto"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mod_ring, comm_ring_1_class)", "by (intro_classes; transfer, simp)"], ["", "end"], ["", "interpretation to_int_mod_ring_hom: inj_one_hom to_int_mod_ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_one_hom to_int_mod_ring", "by (unfold_locales, transfer, simp)"], ["", "lemma of_nat_of_int_mod_ring [code_unfold]:\n  \"of_nat = of_int_mod_ring o int\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat = of_int_mod_ring \\<circ> int", "proof (rule ext, unfold o_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. of_nat x = of_int_mod_ring (int x)", "show \"of_nat n = of_int_mod_ring (int n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n = of_int_mod_ring (int n)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. of_nat 0 = of_int_mod_ring (int 0)\n 2. \\<And>n.\n       of_nat n = of_int_mod_ring (int n) \\<Longrightarrow>\n       of_nat (Suc n) = of_int_mod_ring (int (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  of_nat n = of_int_mod_ring (int n)\n\ngoal (2 subgoals):\n 1. of_nat 0 = of_int_mod_ring (int 0)\n 2. \\<And>n.\n       of_nat n = of_int_mod_ring (int n) \\<Longrightarrow>\n       of_nat (Suc n) = of_int_mod_ring (int (Suc n))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (Suc n) = of_int_mod_ring (int (Suc n))", "by (simp only: of_nat_Suc Suc, transfer) (simp add: mod_simps)"], ["proof (state)\nthis:\n  of_nat (Suc n) = of_int_mod_ring (int (Suc n))\n\ngoal (1 subgoal):\n 1. of_nat 0 = of_int_mod_ring (int 0)", "qed simp"], ["proof (state)\nthis:\n  of_nat ?n1 = of_int_mod_ring (int ?n1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma of_nat_card_eq_0[simp]: \"(of_nat (CARD('a::nontriv)) :: 'a mod_ring) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat CARD('a) = 0", "by (unfold of_nat_of_int_mod_ring, transfer, auto)"], ["", "lemma of_int_of_int_mod_ring[code_unfold]: \"of_int = of_int_mod_ring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int = of_int_mod_ring", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. of_int x = of_int_mod_ring x", "fix x :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. of_int x = of_int_mod_ring x", "obtain n1 n2 where x: \"x = int n1 - int n2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n1 n2.\n        x = int n1 - int n2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule int_diff_cases)"], ["proof (state)\nthis:\n  x = int n1 - int n2\n\ngoal (1 subgoal):\n 1. \\<And>x. of_int x = of_int_mod_ring x", "show \"of_int x = of_int_mod_ring x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int x = of_int_mod_ring x", "unfolding x of_int_diff of_int_of_nat_eq of_nat_of_int_mod_ring o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_mod_ring (int n1) - of_int_mod_ring (int n2) =\n    of_int_mod_ring (int n1 - int n2)", "by (transfer, simp add: mod_diff_right_eq mod_diff_left_eq)"], ["proof (state)\nthis:\n  of_int x = of_int_mod_ring x\n\ngoal:\nNo subgoals!", "qed"], ["", "unbundle lifting_syntax"], ["", "lemma pcr_mod_ring_to_int_mod_ring: \"pcr_mod_ring = (\\<lambda>x y. x = to_int_mod_ring y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pcr_mod_ring = (\\<lambda>x y. x = to_int_mod_ring y)", "unfolding mod_ring.pcr_cr_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_mod_ring = (\\<lambda>x y. x = to_int_mod_ring y)", "unfolding cr_mod_ring_def to_int_mod_ring.rep_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y. x = Rep_mod_ring y) = (\\<lambda>x y. x = Rep_mod_ring y)", ".."], ["", "lemma [transfer_rule]:\n  \"((=) ===> pcr_mod_ring) (\\<lambda> x. int x mod int (CARD('a :: nontriv))) (of_nat :: nat \\<Rightarrow> 'a mod_ring)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> pcr_mod_ring) (\\<lambda>x. int x mod int CARD('a)) of_nat", "by (intro rel_funI, unfold pcr_mod_ring_to_int_mod_ring of_nat_of_int_mod_ring, transfer, auto)"], ["", "lemma [transfer_rule]:\n  \"((=) ===> pcr_mod_ring) (\\<lambda> x. x mod int (CARD('a :: nontriv))) (of_int :: int \\<Rightarrow> 'a mod_ring)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> pcr_mod_ring) (\\<lambda>x. x mod int CARD('a)) of_int", "by (intro rel_funI, unfold pcr_mod_ring_to_int_mod_ring of_int_of_int_mod_ring, transfer, auto)"], ["", "lemma one_mod_card [simp]: \"1 mod CARD('a::nontriv) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 mod CARD('a) = 1", "using mod_less nontriv"], ["proof (prove)\nusing this:\n  ?m < ?n \\<Longrightarrow> ?m mod ?n = ?m\n  1 < CARD(?'a)\n\ngoal (1 subgoal):\n 1. 1 mod CARD('a) = 1", "by blast"], ["", "lemma Suc_0_mod_card [simp]: \"Suc 0 mod CARD('a::nontriv) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 mod CARD('a) = 1", "using one_mod_card"], ["proof (prove)\nusing this:\n  1 mod CARD(?'a) = 1\n\ngoal (1 subgoal):\n 1. Suc 0 mod CARD('a) = 1", "by simp"], ["", "lemma one_mod_card_int [simp]: \"1 mod int CARD('a::nontriv) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 mod int CARD('a) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 mod int CARD('a) = 1", "from nontriv [where ?'a = 'a]"], ["proof (chain)\npicking this:\n  1 < CARD('a)", "have \"int (1 mod CARD('a::nontriv)) = 1\""], ["proof (prove)\nusing this:\n  1 < CARD('a)\n\ngoal (1 subgoal):\n 1. int (1 mod CARD('a)) = 1", "by simp"], ["proof (state)\nthis:\n  int (1 mod CARD('a)) = 1\n\ngoal (1 subgoal):\n 1. 1 mod int CARD('a) = 1", "then"], ["proof (chain)\npicking this:\n  int (1 mod CARD('a)) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  int (1 mod CARD('a)) = 1\n\ngoal (1 subgoal):\n 1. 1 mod int CARD('a) = 1", "using of_nat_mod [of 1 \"CARD('a)\", where ?'a = int]"], ["proof (prove)\nusing this:\n  int (1 mod CARD('a)) = 1\n  int (1 mod CARD('a)) = int 1 mod int CARD('a)\n\ngoal (1 subgoal):\n 1. 1 mod int CARD('a) = 1", "by simp"], ["proof (state)\nthis:\n  1 mod int CARD('a) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pow_mod_ring_transfer[transfer_rule]:\n  \"(pcr_mod_ring ===> (=) ===> pcr_mod_ring) \n   (\\<lambda>a::int. \\<lambda>n. a^n mod CARD('a::nontriv)) ((^)::'a mod_ring \\<Rightarrow> nat \\<Rightarrow> 'a mod_ring)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_mod_ring ===> (=) ===> pcr_mod_ring)\n     (\\<lambda>a n. a ^ n mod int CARD('a)) (^)", "unfolding pcr_mod_ring_to_int_mod_ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x y. x = to_int_mod_ring y) ===>\n     (=) ===> (\\<lambda>x y. x = to_int_mod_ring y))\n     (\\<lambda>a n. a ^ n mod int CARD('a)) (^)", "proof (intro rel_funI,simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> to_int_mod_ring y ^ ya mod int CARD('a) =\n                         to_int_mod_ring (y ^ ya)", "fix x::\"'a mod_ring\" and n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> to_int_mod_ring y ^ ya mod int CARD('a) =\n                         to_int_mod_ring (y ^ ya)", "show \"to_int_mod_ring x ^ n mod int CARD('a) = to_int_mod_ring (x ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring x ^ n mod int CARD('a) = to_int_mod_ring (x ^ n)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. to_int_mod_ring x ^ 0 mod int CARD('a) = to_int_mod_ring (x ^ 0)\n 2. \\<And>n.\n       to_int_mod_ring x ^ n mod int CARD('a) =\n       to_int_mod_ring (x ^ n) \\<Longrightarrow>\n       to_int_mod_ring x ^ Suc n mod int CARD('a) =\n       to_int_mod_ring (x ^ Suc n)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. to_int_mod_ring x ^ 0 mod int CARD('a) = to_int_mod_ring (x ^ 0)\n 2. \\<And>n.\n       to_int_mod_ring x ^ n mod int CARD('a) =\n       to_int_mod_ring (x ^ n) \\<Longrightarrow>\n       to_int_mod_ring x ^ Suc n mod int CARD('a) =\n       to_int_mod_ring (x ^ Suc n)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring x ^ 0 mod int CARD('a) = to_int_mod_ring (x ^ 0)", "by auto"], ["proof (state)\nthis:\n  to_int_mod_ring x ^ 0 mod int CARD('a) = to_int_mod_ring (x ^ 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       to_int_mod_ring x ^ n mod int CARD('a) =\n       to_int_mod_ring (x ^ n) \\<Longrightarrow>\n       to_int_mod_ring x ^ Suc n mod int CARD('a) =\n       to_int_mod_ring (x ^ Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       to_int_mod_ring x ^ n mod int CARD('a) =\n       to_int_mod_ring (x ^ n) \\<Longrightarrow>\n       to_int_mod_ring x ^ Suc n mod int CARD('a) =\n       to_int_mod_ring (x ^ Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  to_int_mod_ring x ^ n mod int CARD('a) = to_int_mod_ring (x ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       to_int_mod_ring x ^ n mod int CARD('a) =\n       to_int_mod_ring (x ^ n) \\<Longrightarrow>\n       to_int_mod_ring x ^ Suc n mod int CARD('a) =\n       to_int_mod_ring (x ^ Suc n)", "have \"to_int_mod_ring (x ^ Suc n) = to_int_mod_ring (x * x ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring (x ^ Suc n) = to_int_mod_ring (x * x ^ n)", "by auto"], ["proof (state)\nthis:\n  to_int_mod_ring (x ^ Suc n) = to_int_mod_ring (x * x ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       to_int_mod_ring x ^ n mod int CARD('a) =\n       to_int_mod_ring (x ^ n) \\<Longrightarrow>\n       to_int_mod_ring x ^ Suc n mod int CARD('a) =\n       to_int_mod_ring (x ^ Suc n)", "also"], ["proof (state)\nthis:\n  to_int_mod_ring (x ^ Suc n) = to_int_mod_ring (x * x ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       to_int_mod_ring x ^ n mod int CARD('a) =\n       to_int_mod_ring (x ^ n) \\<Longrightarrow>\n       to_int_mod_ring x ^ Suc n mod int CARD('a) =\n       to_int_mod_ring (x ^ Suc n)", "have \"... = to_int_mod_ring x * to_int_mod_ring (x ^ n) mod CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring (x * x ^ n) =\n    to_int_mod_ring x * to_int_mod_ring (x ^ n) mod int CARD('a)", "unfolding to_int_mod_ring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Rep_mod_ring ---> id) (\\<lambda>x. x) (x * x ^ n) =\n    (Rep_mod_ring ---> id) (\\<lambda>x. x) x *\n    (Rep_mod_ring ---> id) (\\<lambda>x. x) (x ^ n) mod\n    int CARD('a)", "using times_mod_ring.rep_eq"], ["proof (prove)\nusing this:\n  Rep_mod_ring (?x * ?xa) =\n  Rep_mod_ring ?x * Rep_mod_ring ?xa mod int CARD(?'a)\n\ngoal (1 subgoal):\n 1. (Rep_mod_ring ---> id) (\\<lambda>x. x) (x * x ^ n) =\n    (Rep_mod_ring ---> id) (\\<lambda>x. x) x *\n    (Rep_mod_ring ---> id) (\\<lambda>x. x) (x ^ n) mod\n    int CARD('a)", "by auto"], ["proof (state)\nthis:\n  to_int_mod_ring (x * x ^ n) =\n  to_int_mod_ring x * to_int_mod_ring (x ^ n) mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       to_int_mod_ring x ^ n mod int CARD('a) =\n       to_int_mod_ring (x ^ n) \\<Longrightarrow>\n       to_int_mod_ring x ^ Suc n mod int CARD('a) =\n       to_int_mod_ring (x ^ Suc n)", "also"], ["proof (state)\nthis:\n  to_int_mod_ring (x * x ^ n) =\n  to_int_mod_ring x * to_int_mod_ring (x ^ n) mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       to_int_mod_ring x ^ n mod int CARD('a) =\n       to_int_mod_ring (x ^ n) \\<Longrightarrow>\n       to_int_mod_ring x ^ Suc n mod int CARD('a) =\n       to_int_mod_ring (x ^ Suc n)", "have \"... = to_int_mod_ring x * (to_int_mod_ring x ^ n mod CARD('a)) mod CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring x * to_int_mod_ring (x ^ n) mod int CARD('a) =\n    to_int_mod_ring x * (to_int_mod_ring x ^ n mod int CARD('a)) mod\n    int CARD('a)", "using Suc.hyps"], ["proof (prove)\nusing this:\n  to_int_mod_ring x ^ n mod int CARD('a) = to_int_mod_ring (x ^ n)\n\ngoal (1 subgoal):\n 1. to_int_mod_ring x * to_int_mod_ring (x ^ n) mod int CARD('a) =\n    to_int_mod_ring x * (to_int_mod_ring x ^ n mod int CARD('a)) mod\n    int CARD('a)", "by auto"], ["proof (state)\nthis:\n  to_int_mod_ring x * to_int_mod_ring (x ^ n) mod int CARD('a) =\n  to_int_mod_ring x * (to_int_mod_ring x ^ n mod int CARD('a)) mod\n  int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       to_int_mod_ring x ^ n mod int CARD('a) =\n       to_int_mod_ring (x ^ n) \\<Longrightarrow>\n       to_int_mod_ring x ^ Suc n mod int CARD('a) =\n       to_int_mod_ring (x ^ Suc n)", "also"], ["proof (state)\nthis:\n  to_int_mod_ring x * to_int_mod_ring (x ^ n) mod int CARD('a) =\n  to_int_mod_ring x * (to_int_mod_ring x ^ n mod int CARD('a)) mod\n  int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       to_int_mod_ring x ^ n mod int CARD('a) =\n       to_int_mod_ring (x ^ n) \\<Longrightarrow>\n       to_int_mod_ring x ^ Suc n mod int CARD('a) =\n       to_int_mod_ring (x ^ Suc n)", "have \"... = to_int_mod_ring x ^ Suc n mod int CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring x * (to_int_mod_ring x ^ n mod int CARD('a)) mod\n    int CARD('a) =\n    to_int_mod_ring x ^ Suc n mod int CARD('a)", "by (simp add: mod_simps)"], ["proof (state)\nthis:\n  to_int_mod_ring x * (to_int_mod_ring x ^ n mod int CARD('a)) mod\n  int CARD('a) =\n  to_int_mod_ring x ^ Suc n mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       to_int_mod_ring x ^ n mod int CARD('a) =\n       to_int_mod_ring (x ^ n) \\<Longrightarrow>\n       to_int_mod_ring x ^ Suc n mod int CARD('a) =\n       to_int_mod_ring (x ^ Suc n)", "finally"], ["proof (chain)\npicking this:\n  to_int_mod_ring (x ^ Suc n) = to_int_mod_ring x ^ Suc n mod int CARD('a)", "show ?case"], ["proof (prove)\nusing this:\n  to_int_mod_ring (x ^ Suc n) = to_int_mod_ring x ^ Suc n mod int CARD('a)\n\ngoal (1 subgoal):\n 1. to_int_mod_ring x ^ Suc n mod int CARD('a) = to_int_mod_ring (x ^ Suc n)", ".."], ["proof (state)\nthis:\n  to_int_mod_ring x ^ Suc n mod int CARD('a) = to_int_mod_ring (x ^ Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  to_int_mod_ring x ^ n mod int CARD('a) = to_int_mod_ring (x ^ n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvd_mod_ring_transfer[transfer_rule]:\n\"((pcr_mod_ring :: int \\<Rightarrow> 'a :: nontriv mod_ring \\<Rightarrow> bool) ===>\n  (pcr_mod_ring :: int \\<Rightarrow> 'a mod_ring \\<Rightarrow> bool) ===> (=))\n  (\\<lambda> i j. \\<exists>k \\<in> {0..<int CARD('a)}. j = i * k mod int CARD('a)) (dvd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_mod_ring ===> pcr_mod_ring ===> (=))\n     (\\<lambda>i j.\n         \\<exists>k\\<in>{0..<int CARD('a)}. j = i * k mod int CARD('a))\n     (dvd)", "proof (unfold pcr_mod_ring_to_int_mod_ring, intro rel_funI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        \\<exists>k\\<in>{0..<int CARD('a)}.\n           xa = x * k mod int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> y dvd ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        y dvd ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<in>{0..<int CARD('a)}.\n                            xa = x * k mod int CARD('a)", "fix x y :: \"'a mod_ring\" and i j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        \\<exists>k\\<in>{0..<int CARD('a)}.\n           xa = x * k mod int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> y dvd ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        y dvd ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<in>{0..<int CARD('a)}.\n                            xa = x * k mod int CARD('a)", "assume i: \"i = to_int_mod_ring x\" and j: \"j = to_int_mod_ring y\""], ["proof (state)\nthis:\n  i = to_int_mod_ring x\n  j = to_int_mod_ring y\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        \\<exists>k\\<in>{0..<int CARD('a)}.\n           xa = x * k mod int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> y dvd ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        y dvd ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<in>{0..<int CARD('a)}.\n                            xa = x * k mod int CARD('a)", "{"], ["proof (state)\nthis:\n  i = to_int_mod_ring x\n  j = to_int_mod_ring y\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        \\<exists>k\\<in>{0..<int CARD('a)}.\n           xa = x * k mod int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> y dvd ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        y dvd ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<in>{0..<int CARD('a)}.\n                            xa = x * k mod int CARD('a)", "assume \"x dvd y\""], ["proof (state)\nthis:\n  x dvd y\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        \\<exists>k\\<in>{0..<int CARD('a)}.\n           xa = x * k mod int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> y dvd ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        y dvd ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<in>{0..<int CARD('a)}.\n                            xa = x * k mod int CARD('a)", "then"], ["proof (chain)\npicking this:\n  x dvd y", "obtain z where \"y = x * z\""], ["proof (prove)\nusing this:\n  x dvd y\n\ngoal (1 subgoal):\n 1. (\\<And>z. y = x * z \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (elim dvdE, auto)"], ["proof (state)\nthis:\n  y = x * z\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        \\<exists>k\\<in>{0..<int CARD('a)}.\n           xa = x * k mod int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> y dvd ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        y dvd ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<in>{0..<int CARD('a)}.\n                            xa = x * k mod int CARD('a)", "then"], ["proof (chain)\npicking this:\n  y = x * z", "have \"j = i * to_int_mod_ring z mod CARD('a)\""], ["proof (prove)\nusing this:\n  y = x * z\n\ngoal (1 subgoal):\n 1. j = i * to_int_mod_ring z mod int CARD('a)", "by (unfold i j, transfer)"], ["proof (state)\nthis:\n  j = i * to_int_mod_ring z mod int CARD('a)\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        \\<exists>k\\<in>{0..<int CARD('a)}.\n           xa = x * k mod int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> y dvd ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        y dvd ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k\\<in>{0..<int CARD('a)}.\n                            xa = x * k mod int CARD('a)", "with range_to_int_mod_ring"], ["proof (chain)\npicking this:\n  range to_int_mod_ring = {0..<int CARD(?'a)}\n  j = i * to_int_mod_ring z mod int CARD('a)", "show \"\\<exists>k \\<in> {0..<int CARD('a)}. j = i * k mod CARD('a)\""], ["proof (prove)\nusing this:\n  range to_int_mod_ring = {0..<int CARD(?'a)}\n  j = i * to_int_mod_ring z mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>{0..<int CARD('a)}. j = i * k mod int CARD('a)", "by auto"], ["proof (state)\nthis:\n  \\<exists>k\\<in>{0..<int CARD('a)}. j = i * k mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        \\<exists>k\\<in>{0..<int CARD('a)}.\n           xa = x * k mod int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> y dvd ya", "}"], ["proof (state)\nthis:\n  x dvd y \\<Longrightarrow>\n  \\<exists>k\\<in>{0..<int CARD('a)}. j = i * k mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        \\<exists>k\\<in>{0..<int CARD('a)}.\n           xa = x * k mod int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> y dvd ya", "assume \"\\<exists>k \\<in> {0..<int CARD('a)}. j = i * k mod CARD('a)\""], ["proof (state)\nthis:\n  \\<exists>k\\<in>{0..<int CARD('a)}. j = i * k mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        \\<exists>k\\<in>{0..<int CARD('a)}.\n           xa = x * k mod int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> y dvd ya", "then"], ["proof (chain)\npicking this:\n  \\<exists>k\\<in>{0..<int CARD('a)}. j = i * k mod int CARD('a)", "obtain k where k: \"k \\<in> {0..<int CARD('a)}\" and dvd: \"j = i * k mod CARD('a)\""], ["proof (prove)\nusing this:\n  \\<exists>k\\<in>{0..<int CARD('a)}. j = i * k mod int CARD('a)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> {0..<int CARD('a)};\n         j = i * k mod int CARD('a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k \\<in> {0..<int CARD('a)}\n  j = i * k mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        \\<exists>k\\<in>{0..<int CARD('a)}.\n           xa = x * k mod int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> y dvd ya", "from k"], ["proof (chain)\npicking this:\n  k \\<in> {0..<int CARD('a)}", "have \"to_int_mod_ring (of_int k :: 'a mod_ring) = k\""], ["proof (prove)\nusing this:\n  k \\<in> {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. to_int_mod_ring (of_int k) = k", "by (transfer, auto)"], ["proof (state)\nthis:\n  to_int_mod_ring (of_int k) = k\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        \\<exists>k\\<in>{0..<int CARD('a)}.\n           xa = x * k mod int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> y dvd ya", "also"], ["proof (state)\nthis:\n  to_int_mod_ring (of_int k) = k\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        \\<exists>k\\<in>{0..<int CARD('a)}.\n           xa = x * k mod int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> y dvd ya", "from dvd"], ["proof (chain)\npicking this:\n  j = i * k mod int CARD('a)", "have \"j = i * ... mod CARD('a)\""], ["proof (prove)\nusing this:\n  j = i * k mod int CARD('a)\n\ngoal (1 subgoal):\n 1. j = i * k mod int CARD('a)", "by auto"], ["proof (state)\nthis:\n  j = i * k mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        \\<exists>k\\<in>{0..<int CARD('a)}.\n           xa = x * k mod int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> y dvd ya", "finally"], ["proof (chain)\npicking this:\n  j = i * to_int_mod_ring (of_int k) mod int CARD('a)", "have \"y = x * (of_int k :: 'a mod_ring)\""], ["proof (prove)\nusing this:\n  j = i * to_int_mod_ring (of_int k) mod int CARD('a)\n\ngoal (1 subgoal):\n 1. y = x * of_int k", "unfolding i j"], ["proof (prove)\nusing this:\n  to_int_mod_ring y =\n  to_int_mod_ring x * to_int_mod_ring (of_int k) mod int CARD('a)\n\ngoal (1 subgoal):\n 1. y = x * of_int k", "using k"], ["proof (prove)\nusing this:\n  to_int_mod_ring y =\n  to_int_mod_ring x * to_int_mod_ring (of_int k) mod int CARD('a)\n  k \\<in> {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. y = x * of_int k", "by (transfer, auto)"], ["proof (state)\nthis:\n  y = x * of_int k\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = to_int_mod_ring y; xa = to_int_mod_ring ya;\n        \\<exists>k\\<in>{0..<int CARD('a)}.\n           xa = x * k mod int CARD('a)\\<rbrakk>\n       \\<Longrightarrow> y dvd ya", "then"], ["proof (chain)\npicking this:\n  y = x * of_int k", "show \"x dvd y\""], ["proof (prove)\nusing this:\n  y = x * of_int k\n\ngoal (1 subgoal):\n 1. x dvd y", "by auto"], ["proof (state)\nthis:\n  x dvd y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Rep_mod_ring_mod[simp]: \"Rep_mod_ring (a :: 'a :: nontriv mod_ring) mod CARD('a) = Rep_mod_ring a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_mod_ring a mod int CARD('a) = Rep_mod_ring a", "using Rep_mod_ring[where 'a = 'a]"], ["proof (prove)\nusing this:\n  Rep_mod_ring ?x \\<in> {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. Rep_mod_ring a mod int CARD('a) = Rep_mod_ring a", "by auto"], ["", "subsection \\<open>Finite Fields\\<close>"], ["", "text \\<open>When the domain is prime, the ring becomes a field\\<close>"], ["", "class prime_card = assumes prime_card: \"prime (CARD('a))\"\nbegin"], ["", "lemma prime_card_int: \"prime (int (CARD('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime (int CARD('a))", "using prime_card"], ["proof (prove)\nusing this:\n  prime CARD('a)\n\ngoal (1 subgoal):\n 1. prime (int CARD('a))", "by auto"], ["", "subclass nontriv"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.nontriv TYPE('a)", "using prime_card prime_gt_1_nat"], ["proof (prove)\nusing this:\n  prime CARD('a)\n  prime ?p \\<Longrightarrow> 1 < ?p\n\ngoal (1 subgoal):\n 1. class.nontriv TYPE('a)", "by (intro_classes,auto)"], ["", "end"], ["", "instantiation mod_ring :: (prime_card) field\nbegin"], ["", "definition inverse_mod_ring :: \"'a mod_ring \\<Rightarrow> 'a mod_ring\" where\n  \"inverse_mod_ring x = (if x = 0 then 0 else x ^ (nat (CARD('a) - 2)))\""], ["", "definition divide_mod_ring :: \"'a mod_ring \\<Rightarrow> 'a mod_ring \\<Rightarrow> 'a mod_ring\"  where\n  \"divide_mod_ring x y = x * ((\\<lambda>c. if c = 0 then 0 else c ^ (nat (CARD('a) - 2))) y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mod_ring, field_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> inverse a * a = 1\n 2. \\<And>a b. a div b = a * inverse b\n 3. inverse 0 = 0", "fix a b c::\"'a mod_ring\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> inverse a * a = 1\n 2. \\<And>a b. a div b = a * inverse b\n 3. inverse 0 = 0", "show \"inverse 0 = (0::'a mod_ring)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse 0 = 0", "by (simp add: inverse_mod_ring_def)"], ["proof (state)\nthis:\n  inverse 0 = 0\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> inverse a * a = 1\n 2. \\<And>a b. a div b = a * inverse b", "show \"a div b = a * inverse b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a div b = a * inverse b", "unfolding inverse_mod_ring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a div b = a * (if b = 0 then 0 else b ^ nat (int (CARD('a) - 2)))", "by (transfer', simp add: divide_mod_ring_def)"], ["proof (state)\nthis:\n  a div b = a * inverse b\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> inverse a * a = 1", "show \"a \\<noteq> 0 \\<Longrightarrow> inverse a * a = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> inverse a * a = 1", "proof (unfold inverse_mod_ring_def, transfer)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "let ?p=\"CARD('a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "assume x: \"x \\<in> {0..<int CARD('a)}\" and x0: \"x \\<noteq> 0\""], ["proof (state)\nthis:\n  x \\<in> {0..<int CARD('a)}\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "have p0': \"0\\<le>?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> CARD('a)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "have \"\\<not> ?p dvd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> int CARD('a) dvd x", "using x x0 zdvd_imp_le"], ["proof (prove)\nusing this:\n  x \\<in> {0..<int CARD('a)}\n  x \\<noteq> 0\n  \\<lbrakk>?z dvd ?n; 0 < ?n\\<rbrakk> \\<Longrightarrow> ?z \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<not> int CARD('a) dvd x", "by fastforce"], ["proof (state)\nthis:\n  \\<not> int CARD('a) dvd x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "then"], ["proof (chain)\npicking this:\n  \\<not> int CARD('a) dvd x", "have \"\\<not> CARD('a) dvd nat \\<bar>x\\<bar>\""], ["proof (prove)\nusing this:\n  \\<not> int CARD('a) dvd x\n\ngoal (1 subgoal):\n 1. \\<not> CARD('a) dvd nat \\<bar>x\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<not> CARD('a) dvd nat \\<bar>x\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "with x"], ["proof (chain)\npicking this:\n  x \\<in> {0..<int CARD('a)}\n  \\<not> CARD('a) dvd nat \\<bar>x\\<bar>", "have \"\\<not> CARD('a) dvd nat x\""], ["proof (prove)\nusing this:\n  x \\<in> {0..<int CARD('a)}\n  \\<not> CARD('a) dvd nat \\<bar>x\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> CARD('a) dvd nat x", "by simp"], ["proof (state)\nthis:\n  \\<not> CARD('a) dvd nat x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "have rw: \"x ^ nat (int (?p - 2)) * x = x ^ nat (?p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ nat (int (CARD('a) - 2)) * x = x ^ nat (int (CARD('a) - 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x ^ nat (int (CARD('a) - 2)) * x = x ^ nat (int (CARD('a) - 1))", "have p2: \"0 \\<le> int (?p-2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> int (CARD('a) - 2)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. 0 \\<le> int (CARD('a) - 2)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> int (CARD('a) - 2)\n\ngoal (1 subgoal):\n 1. x ^ nat (int (CARD('a) - 2)) * x = x ^ nat (int (CARD('a) - 1))", "have card_rw: \"(CARD('a) - Suc 0) = nat (1 + int (CARD('a) - 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a) - Suc 0 = nat (1 + int (CARD('a) - 2))", "using nat_eq_iff x x0"], ["proof (prove)\nusing this:\n  (nat ?w = ?m) = (if 0 \\<le> ?w then ?w = int ?m else ?m = 0)\n  x \\<in> {0..<int CARD('a)}\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. CARD('a) - Suc 0 = nat (1 + int (CARD('a) - 2))", "by auto"], ["proof (state)\nthis:\n  CARD('a) - Suc 0 = nat (1 + int (CARD('a) - 2))\n\ngoal (1 subgoal):\n 1. x ^ nat (int (CARD('a) - 2)) * x = x ^ nat (int (CARD('a) - 1))", "have \"x ^ nat (?p - 2)*x = x ^ (Suc (nat (?p - 2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ nat (int (CARD('a) - 2)) * x = x ^ Suc (nat (int (CARD('a) - 2)))", "by simp"], ["proof (state)\nthis:\n  x ^ nat (int (CARD('a) - 2)) * x = x ^ Suc (nat (int (CARD('a) - 2)))\n\ngoal (1 subgoal):\n 1. x ^ nat (int (CARD('a) - 2)) * x = x ^ nat (int (CARD('a) - 1))", "also"], ["proof (state)\nthis:\n  x ^ nat (int (CARD('a) - 2)) * x = x ^ Suc (nat (int (CARD('a) - 2)))\n\ngoal (1 subgoal):\n 1. x ^ nat (int (CARD('a) - 2)) * x = x ^ nat (int (CARD('a) - 1))", "have \"... = x ^ (nat (?p - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ Suc (nat (int (CARD('a) - 2))) = x ^ nat (int (CARD('a) - 1))", "using Suc_nat_eq_nat_zadd1[OF p2] card_rw"], ["proof (prove)\nusing this:\n  Suc (nat (int (CARD('a) - 2))) = nat (1 + int (CARD('a) - 2))\n  CARD('a) - Suc 0 = nat (1 + int (CARD('a) - 2))\n\ngoal (1 subgoal):\n 1. x ^ Suc (nat (int (CARD('a) - 2))) = x ^ nat (int (CARD('a) - 1))", "by auto"], ["proof (state)\nthis:\n  x ^ Suc (nat (int (CARD('a) - 2))) = x ^ nat (int (CARD('a) - 1))\n\ngoal (1 subgoal):\n 1. x ^ nat (int (CARD('a) - 2)) * x = x ^ nat (int (CARD('a) - 1))", "finally"], ["proof (chain)\npicking this:\n  x ^ nat (int (CARD('a) - 2)) * x = x ^ nat (int (CARD('a) - 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  x ^ nat (int (CARD('a) - 2)) * x = x ^ nat (int (CARD('a) - 1))\n\ngoal (1 subgoal):\n 1. x ^ nat (int (CARD('a) - 2)) * x = x ^ nat (int (CARD('a) - 1))", "."], ["proof (state)\nthis:\n  x ^ nat (int (CARD('a) - 2)) * x = x ^ nat (int (CARD('a) - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x ^ nat (int (CARD('a) - 2)) * x = x ^ nat (int (CARD('a) - 1))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "have \"[int (nat x ^ (CARD('a) - 1)) = int 1] (mod CARD('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [int (nat x ^ (CARD('a) - 1)) = int 1] (mod int CARD('a))", "using fermat_theorem [OF prime_card \\<open>\\<not> CARD('a) dvd nat x\\<close>]"], ["proof (prove)\nusing this:\n  [nat x ^ (CARD('a) - 1) = 1] (mod CARD('a))\n\ngoal (1 subgoal):\n 1. [int (nat x ^ (CARD('a) - 1)) = int 1] (mod int CARD('a))", "by (simp only: cong_def cong_def of_nat_mod [symmetric])"], ["proof (state)\nthis:\n  [int (nat x ^ (CARD('a) - 1)) = int 1] (mod int CARD('a))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "then"], ["proof (chain)\npicking this:\n  [int (nat x ^ (CARD('a) - 1)) = int 1] (mod int CARD('a))", "have *: \"[x ^ (CARD('a) - 1) = 1] (mod CARD('a))\""], ["proof (prove)\nusing this:\n  [int (nat x ^ (CARD('a) - 1)) = int 1] (mod int CARD('a))\n\ngoal (1 subgoal):\n 1. [x ^ (CARD('a) - 1) = 1] (mod int CARD('a))", "using x"], ["proof (prove)\nusing this:\n  [int (nat x ^ (CARD('a) - 1)) = int 1] (mod int CARD('a))\n  x \\<in> {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. [x ^ (CARD('a) - 1) = 1] (mod int CARD('a))", "by auto"], ["proof (state)\nthis:\n  [x ^ (CARD('a) - 1) = 1] (mod int CARD('a))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "have \"x ^ (CARD('a) - 2) mod CARD('a) * x mod CARD('a) \n      = (x ^ nat (CARD('a) - 2) * x) mod CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ (CARD('a) - 2) mod int CARD('a) * x mod int CARD('a) =\n    x ^ nat (int (CARD('a) - 2)) * x mod int CARD('a)", "by (simp add: mod_simps)"], ["proof (state)\nthis:\n  x ^ (CARD('a) - 2) mod int CARD('a) * x mod int CARD('a) =\n  x ^ nat (int (CARD('a) - 2)) * x mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "also"], ["proof (state)\nthis:\n  x ^ (CARD('a) - 2) mod int CARD('a) * x mod int CARD('a) =\n  x ^ nat (int (CARD('a) - 2)) * x mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "have \"... =  (x ^ nat (?p - 1) mod ?p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ nat (int (CARD('a) - 2)) * x mod int CARD('a) =\n    x ^ nat (int (CARD('a) - 1)) mod int CARD('a)", "unfolding rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ nat (int (CARD('a) - 1)) mod int CARD('a) =\n    x ^ nat (int (CARD('a) - 1)) mod int CARD('a)", "by simp"], ["proof (state)\nthis:\n  x ^ nat (int (CARD('a) - 2)) * x mod int CARD('a) =\n  x ^ nat (int (CARD('a) - 1)) mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "also"], ["proof (state)\nthis:\n  x ^ nat (int (CARD('a) - 2)) * x mod int CARD('a) =\n  x ^ nat (int (CARD('a) - 1)) mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "have \"... = (x ^ (nat ?p - 1) mod ?p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ nat (int (CARD('a) - 1)) mod int CARD('a) =\n    x ^ (nat (int CARD('a)) - 1) mod int CARD('a)", "using p0'"], ["proof (prove)\nusing this:\n  0 \\<le> CARD('a)\n\ngoal (1 subgoal):\n 1. x ^ nat (int (CARD('a) - 1)) mod int CARD('a) =\n    x ^ (nat (int CARD('a)) - 1) mod int CARD('a)", "by (simp add: nat_diff_distrib')"], ["proof (state)\nthis:\n  x ^ nat (int (CARD('a) - 1)) mod int CARD('a) =\n  x ^ (nat (int CARD('a)) - 1) mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "also"], ["proof (state)\nthis:\n  x ^ nat (int (CARD('a) - 1)) mod int CARD('a) =\n  x ^ (nat (int CARD('a)) - 1) mod int CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "have \"... = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ (nat (int CARD('a)) - 1) mod int CARD('a) = 1", "using *"], ["proof (prove)\nusing this:\n  [x ^ (CARD('a) - 1) = 1] (mod int CARD('a))\n\ngoal (1 subgoal):\n 1. x ^ (nat (int CARD('a)) - 1) mod int CARD('a) = 1", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  x ^ (nat (int CARD('a)) - 1) mod int CARD('a) = 1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> {0..<int CARD('a)}; a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (if a = 0 then 0\n                          else a ^ nat (int (CARD('a) - 2)) mod\n                               int CARD('a)) *\n                         a mod\n                         int CARD('a) =\n                         1", "finally"], ["proof (chain)\npicking this:\n  x ^ (CARD('a) - 2) mod int CARD('a) * x mod int CARD('a) = 1", "show \"(if x = 0 then 0 else x ^ nat (int (CARD('a) - 2)) mod CARD('a)) * x mod CARD('a) = 1\""], ["proof (prove)\nusing this:\n  x ^ (CARD('a) - 2) mod int CARD('a) * x mod int CARD('a) = 1\n\ngoal (1 subgoal):\n 1. (if x = 0 then 0 else x ^ nat (int (CARD('a) - 2)) mod int CARD('a)) *\n    x mod\n    int CARD('a) =\n    1", "using x0"], ["proof (prove)\nusing this:\n  x ^ (CARD('a) - 2) mod int CARD('a) * x mod int CARD('a) = 1\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if x = 0 then 0 else x ^ nat (int (CARD('a) - 2)) mod int CARD('a)) *\n    x mod\n    int CARD('a) =\n    1", "by auto"], ["proof (state)\nthis:\n  (if x = 0 then 0 else x ^ nat (int (CARD('a) - 2)) mod int CARD('a)) *\n  x mod\n  int CARD('a) =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<noteq> 0 \\<Longrightarrow> inverse a * a = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation mod_ring :: (prime_card) \"{normalization_euclidean_semiring, euclidean_ring}\"\nbegin"], ["", "definition modulo_mod_ring :: \"'a mod_ring \\<Rightarrow> 'a mod_ring \\<Rightarrow> 'a mod_ring\" where \"modulo_mod_ring x y = (if y = 0 then x else 0)\""], ["", "definition normalize_mod_ring :: \"'a mod_ring \\<Rightarrow> 'a mod_ring\" where \"normalize_mod_ring x = (if x = 0 then 0 else 1)\""], ["", "definition unit_factor_mod_ring :: \"'a mod_ring \\<Rightarrow> 'a mod_ring\" where \"unit_factor_mod_ring x = x\""], ["", "definition euclidean_size_mod_ring :: \"'a mod_ring \\<Rightarrow> nat\" where \"euclidean_size_mod_ring x = (if x = 0 then 0 else 1)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mod_ring, normalization_euclidean_semiring_class) &&&\n    OFCLASS('a mod_ring, euclidean_ring_class)", "proof (intro_classes)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>a b. a / b * b + a mod b = a\n 2. euclidean_size 0 = 0\n 3. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size (a mod b) < euclidean_size b\n 4. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size a \\<le> euclidean_size (a * b)\n 5. unit_factor 0 = 0\n 6. \\<And>a. a dvd 1 \\<Longrightarrow> unit_factor a = a\n 7. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> unit_factor a dvd 1\n 8. \\<And>a b.\n       a dvd 1 \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b\n 9. \\<And>a. unit_factor a * normalize a = a\n 10. normalize 0 = 0", "fix a :: \"'a mod_ring\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>a b. a / b * b + a mod b = a\n 2. euclidean_size 0 = 0\n 3. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size (a mod b) < euclidean_size b\n 4. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size a \\<le> euclidean_size (a * b)\n 5. unit_factor 0 = 0\n 6. \\<And>a. a dvd 1 \\<Longrightarrow> unit_factor a = a\n 7. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> unit_factor a dvd 1\n 8. \\<And>a b.\n       a dvd 1 \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b\n 9. \\<And>a. unit_factor a * normalize a = a\n 10. normalize 0 = 0", "show \"a \\<noteq> 0 \\<Longrightarrow> unit_factor a dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> unit_factor a dvd 1", "unfolding dvd_def unit_factor_mod_ring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> \\<exists>k. 1 = a * k", "by (intro exI[of _ \"inverse a\"], auto)"], ["proof (state)\nthis:\n  a \\<noteq> 0 \\<Longrightarrow> unit_factor a dvd 1\n\ngoal (9 subgoals):\n 1. \\<And>a b. a / b * b + a mod b = a\n 2. euclidean_size 0 = 0\n 3. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size (a mod b) < euclidean_size b\n 4. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size a \\<le> euclidean_size (a * b)\n 5. unit_factor 0 = 0\n 6. \\<And>a. a dvd 1 \\<Longrightarrow> unit_factor a = a\n 7. \\<And>a b.\n       a dvd 1 \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b\n 8. \\<And>a. unit_factor a * normalize a = a\n 9. normalize 0 = 0", "qed (auto simp: normalize_mod_ring_def unit_factor_mod_ring_def modulo_mod_ring_def\n     euclidean_size_mod_ring_def field_simps)"], ["", "end"], ["", "instantiation mod_ring :: (prime_card) euclidean_ring_gcd\nbegin"], ["", "definition gcd_mod_ring :: \"'a mod_ring \\<Rightarrow> 'a mod_ring \\<Rightarrow> 'a mod_ring\" where \"gcd_mod_ring = Euclidean_Algorithm.gcd\""], ["", "definition lcm_mod_ring :: \"'a mod_ring \\<Rightarrow> 'a mod_ring \\<Rightarrow> 'a mod_ring\" where \"lcm_mod_ring = Euclidean_Algorithm.lcm\""], ["", "definition Gcd_mod_ring :: \"'a mod_ring set \\<Rightarrow> 'a mod_ring\" where \"Gcd_mod_ring = Euclidean_Algorithm.Gcd\""], ["", "definition Lcm_mod_ring :: \"'a mod_ring set \\<Rightarrow> 'a mod_ring\" where \"Lcm_mod_ring = Euclidean_Algorithm.Lcm\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mod_ring, euclidean_ring_gcd_class)", "by (intro_classes, auto simp: gcd_mod_ring_def lcm_mod_ring_def Gcd_mod_ring_def Lcm_mod_ring_def)"], ["", "end"], ["", "instantiation mod_ring :: (prime_card) unique_euclidean_ring\nbegin"], ["", "definition [simp]: \"division_segment_mod_ring (x :: 'a mod_ring) = (1 :: 'a mod_ring)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mod_ring, unique_euclidean_ring_class)", "by intro_classes (auto simp: euclidean_size_mod_ring_def split: if_splits)"], ["", "end"], ["", "instance mod_ring :: (prime_card) field_gcd"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mod_ring, field_gcd_class)", "by intro_classes auto"], ["", "lemma surj_of_nat_mod_ring: \"\\<exists> i. i < CARD('a :: prime_card) \\<and> (x :: 'a mod_ring) = of_nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<CARD('a). x = of_nat i", "by (rule exI[of _ \"nat (to_int_mod_ring x)\"], unfold of_nat_of_int_mod_ring o_def,\n  subst nat_0_le, transfer, simp, simp, transfer, auto)"], ["", "lemma of_nat_0_mod_ring_dvd: assumes x: \"of_nat x = (0 :: 'a ::prime_card mod_ring)\"\n  shows \"CARD('a) dvd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a) dvd x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CARD('a) dvd x", "let ?x = \"of_nat x :: int\""], ["proof (state)\ngoal (1 subgoal):\n 1. CARD('a) dvd x", "from x"], ["proof (chain)\npicking this:\n  of_nat x = 0", "have \"of_int_mod_ring ?x = (0 :: 'a mod_ring)\""], ["proof (prove)\nusing this:\n  of_nat x = 0\n\ngoal (1 subgoal):\n 1. of_int_mod_ring (int x) = 0", "by (fold of_int_of_int_mod_ring, simp)"], ["proof (state)\nthis:\n  of_int_mod_ring (int x) = 0\n\ngoal (1 subgoal):\n 1. CARD('a) dvd x", "hence \"?x mod CARD('a) = 0\""], ["proof (prove)\nusing this:\n  of_int_mod_ring (int x) = 0\n\ngoal (1 subgoal):\n 1. int x mod int CARD('a) = 0", "by (transfer, auto)"], ["proof (state)\nthis:\n  int x mod int CARD('a) = 0\n\ngoal (1 subgoal):\n 1. CARD('a) dvd x", "hence \"x mod CARD('a) = 0\""], ["proof (prove)\nusing this:\n  int x mod int CARD('a) = 0\n\ngoal (1 subgoal):\n 1. x mod CARD('a) = 0", "by presburger"], ["proof (state)\nthis:\n  x mod CARD('a) = 0\n\ngoal (1 subgoal):\n 1. CARD('a) dvd x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x mod CARD('a) = 0\n\ngoal (1 subgoal):\n 1. CARD('a) dvd x", "unfolding mod_eq_0_iff_dvd"], ["proof (prove)\nusing this:\n  CARD('a) dvd x\n\ngoal (1 subgoal):\n 1. CARD('a) dvd x", "."], ["proof (state)\nthis:\n  CARD('a) dvd x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}