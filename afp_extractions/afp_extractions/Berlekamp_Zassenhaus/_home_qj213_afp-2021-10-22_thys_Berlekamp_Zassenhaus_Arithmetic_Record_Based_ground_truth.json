{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Arithmetic_Record_Based.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma left_right_unique[transfer_rule]: \"left_unique R\" \"right_unique R\"", "lemma listprod_i[transfer_rule]: \"(list_all2 R ===> R) (listprod_i ops) prod_list\"", "lemma gcd_eucl_i [transfer_rule]: \"(R ===> R ===> R) gcd_eucl_i Euclidean_Algorithm.gcd\"", "lemma euclid_ext_aux_i[transfer_rule]: \n  \"(R ===> R ===> R ===> R ===> R ===> R ===> rel_prod (rel_prod R R) R) euclid_ext_aux_i euclid_ext_aux\"", "lemma euclid_ext_i [transfer_rule]:\n  \"(R ===> R ===> rel_prod (rel_prod R R) R) euclid_ext_i euclid_ext\"", "lemma nth_default_rel[transfer_rule]: \"(S ===> list_all2 S ===> (=) ===> S) nth_default nth_default\"", "lemma strip_while_rel[transfer_rule]: \n  \"((A ===> (=)) ===> list_all2 A ===> list_all2 A) strip_while strip_while\"", "lemma list_all2_last[simp]: \"list_all2 A (xs @ [x]) (ys @ [y]) \\<longleftrightarrow> list_all2 A xs ys \\<and> A x y\""], "translations": [["", "lemma left_right_unique[transfer_rule]: \"left_unique R\" \"right_unique R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_unique R &&& right_unique R", "using bi_unique"], ["proof (prove)\nusing this:\n  bi_unique R\n\ngoal (1 subgoal):\n 1. left_unique R &&& right_unique R", "unfolding bi_unique_def left_unique_def right_unique_def"], ["proof (prove)\nusing this:\n  (\\<forall>x y z.\n      R x y \\<longrightarrow> R x z \\<longrightarrow> y = z) \\<and>\n  (\\<forall>x y z. R x z \\<longrightarrow> R y z \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       R x z \\<longrightarrow> R y z \\<longrightarrow> x = y &&&\n    \\<forall>x y z. R x y \\<longrightarrow> R x z \\<longrightarrow> y = z", "by auto"], ["", "lemma listprod_i[transfer_rule]: \"(list_all2 R ===> R) (listprod_i ops) prod_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all2 R ===> R) (listprod_i ops) prod_list", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       list_all2 R x y \\<Longrightarrow> R (listprod_i ops x) (prod_list y)", "case (1 xs ys)"], ["proof (state)\nthis:\n  list_all2 R xs ys\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       list_all2 R x y \\<Longrightarrow> R (listprod_i ops x) (prod_list y)", "thus ?case"], ["proof (prove)\nusing this:\n  list_all2 R xs ys\n\ngoal (1 subgoal):\n 1. R (listprod_i ops xs) (prod_list ys)", "proof (induct xs ys rule: list_all2_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. R (listprod_i ops []) (prod_list [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>R x y; list_all2 R xs ys;\n        R (listprod_i ops xs) (prod_list ys)\\<rbrakk>\n       \\<Longrightarrow> R (listprod_i ops (x # xs)) (prod_list (y # ys))", "case (Cons x xs y ys)"], ["proof (state)\nthis:\n  R x y\n  list_all2 R xs ys\n  R (listprod_i ops xs) (prod_list ys)\n\ngoal (2 subgoals):\n 1. R (listprod_i ops []) (prod_list [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>R x y; list_all2 R xs ys;\n        R (listprod_i ops xs) (prod_list ys)\\<rbrakk>\n       \\<Longrightarrow> R (listprod_i ops (x # xs)) (prod_list (y # ys))", "note [transfer_rule] = this"], ["proof (state)\nthis:\n  R x y\n  list_all2 R xs ys\n  R (listprod_i ops xs) (prod_list ys)\n\ngoal (2 subgoals):\n 1. R (listprod_i ops []) (prod_list [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>R x y; list_all2 R xs ys;\n        R (listprod_i ops xs) (prod_list ys)\\<rbrakk>\n       \\<Longrightarrow> R (listprod_i ops (x # xs)) (prod_list (y # ys))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (listprod_i ops (x # xs)) (prod_list (y # ys))", "by simp transfer_prover"], ["proof (state)\nthis:\n  R (listprod_i ops (x # xs)) (prod_list (y # ys))\n\ngoal (1 subgoal):\n 1. R (listprod_i ops []) (prod_list [])", "qed (simp add: one)"], ["proof (state)\nthis:\n  R (listprod_i ops xs) (prod_list ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale idom_ops = ring_ops ops R for ops :: \"'i arith_ops_record\" and\n  R :: \"'i \\<Rightarrow> 'a :: idom \\<Rightarrow> bool\""], ["", "locale idom_divide_ops = idom_ops ops R for ops :: \"'i arith_ops_record\" and\n  R :: \"'i \\<Rightarrow> 'a :: idom_divide \\<Rightarrow> bool\" +\n  assumes divide[transfer_rule]: \"(R ===> R ===> R) divide Rings.divide\""], ["", "locale euclidean_semiring_ops = idom_ops ops R for ops :: \"'i arith_ops_record\" and\n  R :: \"'i \\<Rightarrow> 'a :: {idom,normalization_euclidean_semiring} \\<Rightarrow> bool\"  +\n  assumes modulo[transfer_rule]: \"(R ===> R ===> R) modulo (mod)\"\n    and normalize[transfer_rule]: \"(R ===> R) normalize Rings.normalize\"\n    and unit_factor[transfer_rule]: \"(R ===> R) unit_factor Rings.unit_factor\"\nbegin"], ["", "lemma gcd_eucl_i [transfer_rule]: \"(R ===> R ===> R) gcd_eucl_i Euclidean_Algorithm.gcd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R ===> R ===> R) gcd_eucl_i normalization_euclidean_semiring_class.gcd", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>R x y; R xa ya\\<rbrakk>\n       \\<Longrightarrow> R (gcd_eucl_i x xa)\n                          (normalization_euclidean_semiring_class.gcd y ya)", "case (1 x X y Y)"], ["proof (state)\nthis:\n  R x X\n  R y Y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>R x y; R xa ya\\<rbrakk>\n       \\<Longrightarrow> R (gcd_eucl_i x xa)\n                          (normalization_euclidean_semiring_class.gcd y ya)", "thus ?case"], ["proof (prove)\nusing this:\n  R x X\n  R y Y\n\ngoal (1 subgoal):\n 1. R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)", "proof (induct X Y arbitrary: x y rule: Euclidean_Algorithm.gcd.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>b \\<noteq> (0::'a); R x b;\n                    R y (a mod b)\\<rbrakk>\n                   \\<Longrightarrow> R (gcd_eucl_i x y)\n(normalization_euclidean_semiring_class.gcd b (a mod b));\n        R x a; R y b\\<rbrakk>\n       \\<Longrightarrow> R (gcd_eucl_i x y)\n                          (normalization_euclidean_semiring_class.gcd a b)", "case (1 X Y x y)"], ["proof (state)\nthis:\n  \\<lbrakk>Y \\<noteq> (0::'a); R ?x Y; R ?y (X mod Y)\\<rbrakk>\n  \\<Longrightarrow> R (gcd_eucl_i ?x ?y)\n                     (normalization_euclidean_semiring_class.gcd Y\n                       (X mod Y))\n  R x X\n  R y Y\n\ngoal (1 subgoal):\n 1. \\<And>a b x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>b \\<noteq> (0::'a); R x b;\n                    R y (a mod b)\\<rbrakk>\n                   \\<Longrightarrow> R (gcd_eucl_i x y)\n(normalization_euclidean_semiring_class.gcd b (a mod b));\n        R x a; R y b\\<rbrakk>\n       \\<Longrightarrow> R (gcd_eucl_i x y)\n                          (normalization_euclidean_semiring_class.gcd a b)", "note [transfer_rule] = 1(2-)"], ["proof (state)\nthis:\n  R x X\n  R y Y\n\ngoal (1 subgoal):\n 1. \\<And>a b x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>b \\<noteq> (0::'a); R x b;\n                    R y (a mod b)\\<rbrakk>\n                   \\<Longrightarrow> R (gcd_eucl_i x y)\n(normalization_euclidean_semiring_class.gcd b (a mod b));\n        R x a; R y b\\<rbrakk>\n       \\<Longrightarrow> R (gcd_eucl_i x y)\n                          (normalization_euclidean_semiring_class.gcd a b)", "note simps = gcd_eucl_i.simps[of x y] Euclidean_Algorithm.gcd.simps[of X Y]"], ["proof (state)\nthis:\n  gcd_eucl_i x y =\n  (if y = arith_ops_record.zero ops then arith_ops_record.normalize ops x\n   else gcd_eucl_i y (arith_ops_record.modulo ops x y))\n  normalization_euclidean_semiring_class.gcd X Y =\n  (if Y = (0::'a) then normalization_semidom_class.normalize X\n   else normalization_euclidean_semiring_class.gcd Y (X mod Y))\n\ngoal (1 subgoal):\n 1. \\<And>a b x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>b \\<noteq> (0::'a); R x b;\n                    R y (a mod b)\\<rbrakk>\n                   \\<Longrightarrow> R (gcd_eucl_i x y)\n(normalization_euclidean_semiring_class.gcd b (a mod b));\n        R x a; R y b\\<rbrakk>\n       \\<Longrightarrow> R (gcd_eucl_i x y)\n                          (normalization_euclidean_semiring_class.gcd a b)", "have eq: \"(y = zero) = (Y = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y = arith_ops_record.zero ops) = (Y = (0::'a))", "by transfer_prover"], ["proof (state)\nthis:\n  (y = arith_ops_record.zero ops) = (Y = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>a b x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>b \\<noteq> (0::'a); R x b;\n                    R y (a mod b)\\<rbrakk>\n                   \\<Longrightarrow> R (gcd_eucl_i x y)\n(normalization_euclidean_semiring_class.gcd b (a mod b));\n        R x a; R y b\\<rbrakk>\n       \\<Longrightarrow> R (gcd_eucl_i x y)\n                          (normalization_euclidean_semiring_class.gcd a b)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)", "proof (cases \"Y = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Y = (0::'a) \\<Longrightarrow>\n    R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)\n 2. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)", "case True"], ["proof (state)\nthis:\n  Y = (0::'a)\n\ngoal (2 subgoals):\n 1. Y = (0::'a) \\<Longrightarrow>\n    R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)\n 2. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)", "hence *: \"y = zero\""], ["proof (prove)\nusing this:\n  Y = (0::'a)\n\ngoal (1 subgoal):\n 1. y = arith_ops_record.zero ops", "using eq"], ["proof (prove)\nusing this:\n  Y = (0::'a)\n  (y = arith_ops_record.zero ops) = (Y = (0::'a))\n\ngoal (1 subgoal):\n 1. y = arith_ops_record.zero ops", "by simp"], ["proof (state)\nthis:\n  y = arith_ops_record.zero ops\n\ngoal (2 subgoals):\n 1. Y = (0::'a) \\<Longrightarrow>\n    R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)\n 2. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)", "have \"R (normalize x) (Rings.normalize X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (arith_ops_record.normalize ops x)\n     (normalization_semidom_class.normalize X)", "by transfer_prover"], ["proof (state)\nthis:\n  R (arith_ops_record.normalize ops x)\n   (normalization_semidom_class.normalize X)\n\ngoal (2 subgoals):\n 1. Y = (0::'a) \\<Longrightarrow>\n    R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)\n 2. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  R (arith_ops_record.normalize ops x)\n   (normalization_semidom_class.normalize X)\n\ngoal (1 subgoal):\n 1. R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)", "unfolding simps"], ["proof (prove)\nusing this:\n  R (arith_ops_record.normalize ops x)\n   (normalization_semidom_class.normalize X)\n\ngoal (1 subgoal):\n 1. R (if y = arith_ops_record.zero ops\n       then arith_ops_record.normalize ops x\n       else gcd_eucl_i y (arith_ops_record.modulo ops x y))\n     (if Y = (0::'a) then normalization_semidom_class.normalize X\n      else normalization_euclidean_semiring_class.gcd Y (X mod Y))", "unfolding True *"], ["proof (prove)\nusing this:\n  R (arith_ops_record.normalize ops x)\n   (normalization_semidom_class.normalize X)\n\ngoal (1 subgoal):\n 1. R (if arith_ops_record.zero ops = arith_ops_record.zero ops\n       then arith_ops_record.normalize ops x\n       else gcd_eucl_i (arith_ops_record.zero ops)\n             (arith_ops_record.modulo ops x (arith_ops_record.zero ops)))\n     (if (0::'a) = (0::'a) then normalization_semidom_class.normalize X\n      else normalization_euclidean_semiring_class.gcd (0::'a)\n            (X mod (0::'a)))", "by simp"], ["proof (state)\nthis:\n  R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)\n\ngoal (1 subgoal):\n 1. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)", "case False"], ["proof (state)\nthis:\n  Y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)", "with eq"], ["proof (chain)\npicking this:\n  (y = arith_ops_record.zero ops) = (Y = (0::'a))\n  Y \\<noteq> (0::'a)", "have yz: \"y \\<noteq> zero\""], ["proof (prove)\nusing this:\n  (y = arith_ops_record.zero ops) = (Y = (0::'a))\n  Y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. y \\<noteq> arith_ops_record.zero ops", "by simp"], ["proof (state)\nthis:\n  y \\<noteq> arith_ops_record.zero ops\n\ngoal (1 subgoal):\n 1. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)", "have \"R (gcd_eucl_i y (modulo x y)) (Euclidean_Algorithm.gcd Y (X mod Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (gcd_eucl_i y (arith_ops_record.modulo ops x y))\n     (normalization_euclidean_semiring_class.gcd Y (X mod Y))", "by (rule 1(1)[OF False], transfer_prover+)"], ["proof (state)\nthis:\n  R (gcd_eucl_i y (arith_ops_record.modulo ops x y))\n   (normalization_euclidean_semiring_class.gcd Y (X mod Y))\n\ngoal (1 subgoal):\n 1. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  R (gcd_eucl_i y (arith_ops_record.modulo ops x y))\n   (normalization_euclidean_semiring_class.gcd Y (X mod Y))\n\ngoal (1 subgoal):\n 1. R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)", "unfolding simps"], ["proof (prove)\nusing this:\n  R (gcd_eucl_i y (arith_ops_record.modulo ops x y))\n   (normalization_euclidean_semiring_class.gcd Y (X mod Y))\n\ngoal (1 subgoal):\n 1. R (if y = arith_ops_record.zero ops\n       then arith_ops_record.normalize ops x\n       else gcd_eucl_i y (arith_ops_record.modulo ops x y))\n     (if Y = (0::'a) then normalization_semidom_class.normalize X\n      else normalization_euclidean_semiring_class.gcd Y (X mod Y))", "using False yz"], ["proof (prove)\nusing this:\n  R (gcd_eucl_i y (arith_ops_record.modulo ops x y))\n   (normalization_euclidean_semiring_class.gcd Y (X mod Y))\n  Y \\<noteq> (0::'a)\n  y \\<noteq> arith_ops_record.zero ops\n\ngoal (1 subgoal):\n 1. R (if y = arith_ops_record.zero ops\n       then arith_ops_record.normalize ops x\n       else gcd_eucl_i y (arith_ops_record.modulo ops x y))\n     (if Y = (0::'a) then normalization_semidom_class.normalize X\n      else normalization_euclidean_semiring_class.gcd Y (X mod Y))", "by simp"], ["proof (state)\nthis:\n  R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R (gcd_eucl_i x y) (normalization_euclidean_semiring_class.gcd X Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale euclidean_ring_ops = euclidean_semiring_ops ops R for ops :: \"'i arith_ops_record\" and\n  R :: \"'i \\<Rightarrow> 'a :: {idom,euclidean_ring_gcd} \\<Rightarrow> bool\"  +\n  assumes divide[transfer_rule]: \"(R ===> R ===> R) divide (div)\"\nbegin"], ["", "lemma euclid_ext_aux_i[transfer_rule]: \n  \"(R ===> R ===> R ===> R ===> R ===> R ===> rel_prod (rel_prod R R) R) euclid_ext_aux_i euclid_ext_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R ===> R ===> R ===> R ===> R ===> R ===> rel_prod (rel_prod R R) R)\n     euclid_ext_aux_i euclid_ext_aux", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd xe ye.\n       \\<lbrakk>R x y; R xa ya; R xb yb; R xc yc; R xd yd; R xe ye\\<rbrakk>\n       \\<Longrightarrow> rel_prod (rel_prod R R) R\n                          (euclid_ext_aux_i x xa xb xc xd xe)\n                          (euclid_ext_aux y ya yb yc yd ye)", "case (1 z Z a A b B c C x X y Y)"], ["proof (state)\nthis:\n  R z Z\n  R a A\n  R b B\n  R c C\n  R x X\n  R y Y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd xe ye.\n       \\<lbrakk>R x y; R xa ya; R xb yb; R xc yc; R xd yd; R xe ye\\<rbrakk>\n       \\<Longrightarrow> rel_prod (rel_prod R R) R\n                          (euclid_ext_aux_i x xa xb xc xd xe)\n                          (euclid_ext_aux y ya yb yc yd ye)", "thus ?case"], ["proof (prove)\nusing this:\n  R z Z\n  R a A\n  R b B\n  R c C\n  R x X\n  R y Y\n\ngoal (1 subgoal):\n 1. rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)", "proof (induct Z A B C X Y arbitrary: z a b c x y rule: euclid_ext_aux.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' s t' t r' r z a b c x y.\n       \\<lbrakk>\\<And>x z a b c xa y.\n                   \\<lbrakk>r \\<noteq> (0::'a); x = r' div r; R z s;\n                    R a (s' - x * s); R b t; R c (t' - x * t); R xa r;\n                    R y (r' mod r)\\<rbrakk>\n                   \\<Longrightarrow> rel_prod (rel_prod R R) R\n(euclid_ext_aux_i z a b c xa y)\n(euclid_ext_aux s (s' - x * s) t (t' - x * t) r (r' mod r));\n        R z s'; R a s; R b t'; R c t; R x r'; R y r\\<rbrakk>\n       \\<Longrightarrow> rel_prod (rel_prod R R) R\n                          (euclid_ext_aux_i z a b c x y)\n                          (euclid_ext_aux s' s t' t r' r)", "case (1 Z A B C X Y z a b c x y)"], ["proof (state)\nthis:\n  \\<lbrakk>Y \\<noteq> (0::'a); ?x = X div Y; R ?z A; R ?a (Z - ?x * A);\n   R ?b C; R ?c (B - ?x * C); R ?xa Y; R ?y (X mod Y)\\<rbrakk>\n  \\<Longrightarrow> rel_prod (rel_prod R R) R\n                     (euclid_ext_aux_i ?z ?a ?b ?c ?xa ?y)\n                     (euclid_ext_aux A (Z - ?x * A) C (B - ?x * C) Y\n                       (X mod Y))\n  R z Z\n  R a A\n  R b B\n  R c C\n  R x X\n  R y Y\n\ngoal (1 subgoal):\n 1. \\<And>s' s t' t r' r z a b c x y.\n       \\<lbrakk>\\<And>x z a b c xa y.\n                   \\<lbrakk>r \\<noteq> (0::'a); x = r' div r; R z s;\n                    R a (s' - x * s); R b t; R c (t' - x * t); R xa r;\n                    R y (r' mod r)\\<rbrakk>\n                   \\<Longrightarrow> rel_prod (rel_prod R R) R\n(euclid_ext_aux_i z a b c xa y)\n(euclid_ext_aux s (s' - x * s) t (t' - x * t) r (r' mod r));\n        R z s'; R a s; R b t'; R c t; R x r'; R y r\\<rbrakk>\n       \\<Longrightarrow> rel_prod (rel_prod R R) R\n                          (euclid_ext_aux_i z a b c x y)\n                          (euclid_ext_aux s' s t' t r' r)", "note [transfer_rule] = 1(2-)"], ["proof (state)\nthis:\n  R z Z\n  R a A\n  R b B\n  R c C\n  R x X\n  R y Y\n\ngoal (1 subgoal):\n 1. \\<And>s' s t' t r' r z a b c x y.\n       \\<lbrakk>\\<And>x z a b c xa y.\n                   \\<lbrakk>r \\<noteq> (0::'a); x = r' div r; R z s;\n                    R a (s' - x * s); R b t; R c (t' - x * t); R xa r;\n                    R y (r' mod r)\\<rbrakk>\n                   \\<Longrightarrow> rel_prod (rel_prod R R) R\n(euclid_ext_aux_i z a b c xa y)\n(euclid_ext_aux s (s' - x * s) t (t' - x * t) r (r' mod r));\n        R z s'; R a s; R b t'; R c t; R x r'; R y r\\<rbrakk>\n       \\<Longrightarrow> rel_prod (rel_prod R R) R\n                          (euclid_ext_aux_i z a b c x y)\n                          (euclid_ext_aux s' s t' t r' r)", "note simps = euclid_ext_aux_i.simps[of z a b c x y] euclid_ext_aux.simps[of Z A B C X Y]"], ["proof (state)\nthis:\n  euclid_ext_aux_i z a b c x y =\n  (if y = arith_ops_record.zero ops\n   then let c = arith_ops_record.divide ops (arith_ops_record.one ops)\n                 (arith_ops_record.unit_factor ops x)\n        in ((arith_ops_record.times ops z c,\n             arith_ops_record.times ops b c),\n            arith_ops_record.normalize ops x)\n   else let q = arith_ops_record.divide ops x y\n        in euclid_ext_aux_i a\n            (arith_ops_record.minus ops z (arith_ops_record.times ops q a))\n            c (arith_ops_record.minus ops b\n                (arith_ops_record.times ops q c))\n            y (arith_ops_record.modulo ops x y))\n  euclid_ext_aux Z A B C X Y =\n  (if Y = (0::'a)\n   then let c = (1::'a) div unit_factor_class.unit_factor X\n        in ((Z * c, B * c), normalization_semidom_class.normalize X)\n   else let q = X div Y\n        in euclid_ext_aux A (Z - q * A) C (B - q * C) Y (X mod Y))\n\ngoal (1 subgoal):\n 1. \\<And>s' s t' t r' r z a b c x y.\n       \\<lbrakk>\\<And>x z a b c xa y.\n                   \\<lbrakk>r \\<noteq> (0::'a); x = r' div r; R z s;\n                    R a (s' - x * s); R b t; R c (t' - x * t); R xa r;\n                    R y (r' mod r)\\<rbrakk>\n                   \\<Longrightarrow> rel_prod (rel_prod R R) R\n(euclid_ext_aux_i z a b c xa y)\n(euclid_ext_aux s (s' - x * s) t (t' - x * t) r (r' mod r));\n        R z s'; R a s; R b t'; R c t; R x r'; R y r\\<rbrakk>\n       \\<Longrightarrow> rel_prod (rel_prod R R) R\n                          (euclid_ext_aux_i z a b c x y)\n                          (euclid_ext_aux s' s t' t r' r)", "have eq: \"(y = zero) = (Y = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y = arith_ops_record.zero ops) = (Y = (0::'a))", "by transfer_prover"], ["proof (state)\nthis:\n  (y = arith_ops_record.zero ops) = (Y = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>s' s t' t r' r z a b c x y.\n       \\<lbrakk>\\<And>x z a b c xa y.\n                   \\<lbrakk>r \\<noteq> (0::'a); x = r' div r; R z s;\n                    R a (s' - x * s); R b t; R c (t' - x * t); R xa r;\n                    R y (r' mod r)\\<rbrakk>\n                   \\<Longrightarrow> rel_prod (rel_prod R R) R\n(euclid_ext_aux_i z a b c xa y)\n(euclid_ext_aux s (s' - x * s) t (t' - x * t) r (r' mod r));\n        R z s'; R a s; R b t'; R c t; R x r'; R y r\\<rbrakk>\n       \\<Longrightarrow> rel_prod (rel_prod R R) R\n                          (euclid_ext_aux_i z a b c x y)\n                          (euclid_ext_aux s' s t' t r' r)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)", "proof (cases \"Y = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Y = (0::'a) \\<Longrightarrow>\n    rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)\n 2. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)", "case True"], ["proof (state)\nthis:\n  Y = (0::'a)\n\ngoal (2 subgoals):\n 1. Y = (0::'a) \\<Longrightarrow>\n    rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)\n 2. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)", "hence *: \"(y = zero) = True\" \"(Y = 0) = True\""], ["proof (prove)\nusing this:\n  Y = (0::'a)\n\ngoal (1 subgoal):\n 1. (y = arith_ops_record.zero ops) = True &&& (Y = (0::'a)) = True", "using eq"], ["proof (prove)\nusing this:\n  Y = (0::'a)\n  (y = arith_ops_record.zero ops) = (Y = (0::'a))\n\ngoal (1 subgoal):\n 1. (y = arith_ops_record.zero ops) = True &&& (Y = (0::'a)) = True", "by auto"], ["proof (state)\nthis:\n  (y = arith_ops_record.zero ops) = True\n  (Y = (0::'a)) = True\n\ngoal (2 subgoals):\n 1. Y = (0::'a) \\<Longrightarrow>\n    rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)\n 2. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)", "unfolding simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod (rel_prod R R) R\n     (if y = arith_ops_record.zero ops\n      then let c = arith_ops_record.divide ops (arith_ops_record.one ops)\n                    (arith_ops_record.unit_factor ops x)\n           in ((arith_ops_record.times ops z c,\n                arith_ops_record.times ops b c),\n               arith_ops_record.normalize ops x)\n      else let q = arith_ops_record.divide ops x y\n           in euclid_ext_aux_i a\n               (arith_ops_record.minus ops z\n                 (arith_ops_record.times ops q a))\n               c (arith_ops_record.minus ops b\n                   (arith_ops_record.times ops q c))\n               y (arith_ops_record.modulo ops x y))\n     (if Y = (0::'a)\n      then let c = (1::'a) div unit_factor_class.unit_factor X\n           in ((Z * c, B * c), normalization_semidom_class.normalize X)\n      else let q = X div Y\n           in euclid_ext_aux A (Z - q * A) C (B - q * C) Y (X mod Y))", "unfolding * if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod (rel_prod R R) R\n     (let c = arith_ops_record.divide ops (arith_ops_record.one ops)\n               (arith_ops_record.unit_factor ops x)\n      in ((arith_ops_record.times ops z c, arith_ops_record.times ops b c),\n          arith_ops_record.normalize ops x))\n     (let c = (1::'a) div unit_factor_class.unit_factor X\n      in ((Z * c, B * c), normalization_semidom_class.normalize X))", "by transfer_prover"], ["proof (state)\nthis:\n  rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n   (euclid_ext_aux Z A B C X Y)\n\ngoal (1 subgoal):\n 1. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)", "case False"], ["proof (state)\nthis:\n  Y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)", "hence *: \"(y = zero) = False\" \"(Y = 0) = False\""], ["proof (prove)\nusing this:\n  Y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (y = arith_ops_record.zero ops) = False &&& (Y = (0::'a)) = False", "using eq"], ["proof (prove)\nusing this:\n  Y \\<noteq> (0::'a)\n  (y = arith_ops_record.zero ops) = (Y = (0::'a))\n\ngoal (1 subgoal):\n 1. (y = arith_ops_record.zero ops) = False &&& (Y = (0::'a)) = False", "by auto"], ["proof (state)\nthis:\n  (y = arith_ops_record.zero ops) = False\n  (Y = (0::'a)) = False\n\ngoal (1 subgoal):\n 1. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)", "have XY: \"R (modulo x y) (X mod Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (arith_ops_record.modulo ops x y) (X mod Y)", "by transfer_prover"], ["proof (state)\nthis:\n  R (arith_ops_record.modulo ops x y) (X mod Y)\n\ngoal (1 subgoal):\n 1. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)", "have YA: \"R (minus z (times (divide x y) a)) (Z - X div Y * A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (arith_ops_record.minus ops z\n        (arith_ops_record.times ops (arith_ops_record.divide ops x y) a))\n     (Z - X div Y * A)", "by transfer_prover"], ["proof (state)\nthis:\n  R (arith_ops_record.minus ops z\n      (arith_ops_record.times ops (arith_ops_record.divide ops x y) a))\n   (Z - X div Y * A)\n\ngoal (1 subgoal):\n 1. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)", "have YC: \"R (minus b (times (divide x y) c)) (B - X div Y * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (arith_ops_record.minus ops b\n        (arith_ops_record.times ops (arith_ops_record.divide ops x y) c))\n     (B - X div Y * C)", "by transfer_prover"], ["proof (state)\nthis:\n  R (arith_ops_record.minus ops b\n      (arith_ops_record.times ops (arith_ops_record.divide ops x y) c))\n   (B - X div Y * C)\n\ngoal (1 subgoal):\n 1. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)", "note [transfer_rule] = 1(1)[OF False refl 1(3) YA 1(5) YC 1(7) XY]"], ["proof (state)\nthis:\n  rel_prod (rel_prod R R) R\n   (euclid_ext_aux_i a\n     (arith_ops_record.minus ops z\n       (arith_ops_record.times ops (arith_ops_record.divide ops x y) a))\n     c (arith_ops_record.minus ops b\n         (arith_ops_record.times ops (arith_ops_record.divide ops x y) c))\n     y (arith_ops_record.modulo ops x y))\n   (euclid_ext_aux A (Z - X div Y * A) C (B - X div Y * C) Y (X mod Y))\n\ngoal (1 subgoal):\n 1. Y \\<noteq> (0::'a) \\<Longrightarrow>\n    rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n     (euclid_ext_aux Z A B C X Y)", "unfolding simps * if_False Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod (rel_prod R R) R\n     (euclid_ext_aux_i a\n       (arith_ops_record.minus ops z\n         (arith_ops_record.times ops (arith_ops_record.divide ops x y) a))\n       c (arith_ops_record.minus ops b\n           (arith_ops_record.times ops (arith_ops_record.divide ops x y) c))\n       y (arith_ops_record.modulo ops x y))\n     (euclid_ext_aux A (Z - X div Y * A) C (B - X div Y * C) Y (X mod Y))", "by transfer_prover"], ["proof (state)\nthis:\n  rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n   (euclid_ext_aux Z A B C X Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n   (euclid_ext_aux Z A B C X Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_prod (rel_prod R R) R (euclid_ext_aux_i z a b c x y)\n   (euclid_ext_aux Z A B C X Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma euclid_ext_i [transfer_rule]:\n  \"(R ===> R ===> rel_prod (rel_prod R R) R) euclid_ext_i euclid_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R ===> R ===> rel_prod (rel_prod R R) R)\n     (euclid_ext_aux_i (arith_ops_record.one ops)\n       (arith_ops_record.zero ops) (arith_ops_record.zero ops)\n       (arith_ops_record.one ops))\n     (euclid_ext_aux (1::'a) (0::'a) (0::'a) (1::'a))", "by transfer_prover"], ["", "end"], ["", "locale field_ops = idom_divide_ops ops R + euclidean_semiring_ops ops R for ops :: \"'i arith_ops_record\" and\n  R :: \"'i \\<Rightarrow> 'a :: {field_gcd} \\<Rightarrow> bool\" +\n  assumes inverse[transfer_rule]: \"(R ===> R) inverse Fields.inverse\""], ["", "lemma nth_default_rel[transfer_rule]: \"(S ===> list_all2 S ===> (=) ===> S) nth_default nth_default\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S ===> list_all2 S ===> (=) ===> S) nth_default nth_default", "proof (intro rel_funI, clarify, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>S x y; list_all2 S xa ya\\<rbrakk>\n       \\<Longrightarrow> S (nth_default x xa yb) (nth_default y ya yb)", "case (1 x y xs ys _ n)"], ["proof (state)\nthis:\n  S x y\n  list_all2 S xs ys\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>S x y; list_all2 S xa ya\\<rbrakk>\n       \\<Longrightarrow> S (nth_default x xa yb) (nth_default y ya yb)", "from 1(2)"], ["proof (chain)\npicking this:\n  list_all2 S xs ys", "show ?case"], ["proof (prove)\nusing this:\n  list_all2 S xs ys\n\ngoal (1 subgoal):\n 1. S (nth_default x xs n) (nth_default y ys n)", "proof (induct arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. S (nth_default x [] n) (nth_default y [] n)\n 2. \\<And>xa xs ya ys n.\n       \\<lbrakk>S xa ya; list_all2 S xs ys;\n        \\<And>n. S (nth_default x xs n) (nth_default y ys n)\\<rbrakk>\n       \\<Longrightarrow> S (nth_default x (xa # xs) n)\n                          (nth_default y (ya # ys) n)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>n. S (nth_default x [] n) (nth_default y [] n)\n 2. \\<And>xa xs ya ys n.\n       \\<lbrakk>S xa ya; list_all2 S xs ys;\n        \\<And>n. S (nth_default x xs n) (nth_default y ys n)\\<rbrakk>\n       \\<Longrightarrow> S (nth_default x (xa # xs) n)\n                          (nth_default y (ya # ys) n)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. S (nth_default x [] n) (nth_default y [] n)", "using 1(1)"], ["proof (prove)\nusing this:\n  S x y\n\ngoal (1 subgoal):\n 1. S (nth_default x [] n) (nth_default y [] n)", "by simp"], ["proof (state)\nthis:\n  S (nth_default x [] n) (nth_default y [] n)\n\ngoal (1 subgoal):\n 1. \\<And>xa xs ya ys n.\n       \\<lbrakk>S xa ya; list_all2 S xs ys;\n        \\<And>n. S (nth_default x xs n) (nth_default y ys n)\\<rbrakk>\n       \\<Longrightarrow> S (nth_default x (xa # xs) n)\n                          (nth_default y (ya # ys) n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs ya ys n.\n       \\<lbrakk>S xa ya; list_all2 S xs ys;\n        \\<And>n. S (nth_default x xs n) (nth_default y ys n)\\<rbrakk>\n       \\<Longrightarrow> S (nth_default x (xa # xs) n)\n                          (nth_default y (ya # ys) n)", "case (Cons x y xs ys n)"], ["proof (state)\nthis:\n  S x xs\n  list_all2 S y ys\n  S (nth_default x__ y ?n) (nth_default y__ ys ?n)\n\ngoal (1 subgoal):\n 1. \\<And>xa xs ya ys n.\n       \\<lbrakk>S xa ya; list_all2 S xs ys;\n        \\<And>n. S (nth_default x__ xs n) (nth_default y__ ys n)\\<rbrakk>\n       \\<Longrightarrow> S (nth_default x__ (xa # xs) n)\n                          (nth_default y__ (ya # ys) n)", "thus ?case"], ["proof (prove)\nusing this:\n  S x xs\n  list_all2 S y ys\n  S (nth_default x__ y ?n) (nth_default y__ ys ?n)\n\ngoal (1 subgoal):\n 1. S (nth_default x__ (x # y) n) (nth_default y__ (xs # ys) n)", "by (cases n, auto)"], ["proof (state)\nthis:\n  S (nth_default x__ (x # y) n) (nth_default y__ (xs # ys) n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S (nth_default x xs n) (nth_default y ys n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strip_while_rel[transfer_rule]: \n  \"((A ===> (=)) ===> list_all2 A ===> list_all2 A) strip_while strip_while\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===> list_all2 A ===> list_all2 A) strip_while strip_while", "unfolding strip_while_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===> list_all2 A ===> list_all2 A)\n     (\\<lambda>P. rev \\<circ> dropWhile P \\<circ> rev)\n     (\\<lambda>P. rev \\<circ> dropWhile P \\<circ> rev)", "by transfer_prover"], ["", "lemma list_all2_last[simp]: \"list_all2 A (xs @ [x]) (ys @ [y]) \\<longleftrightarrow> list_all2 A xs ys \\<and> A x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 A (xs @ [x]) (ys @ [y]) = (list_all2 A xs ys \\<and> A x y)", "proof (cases \"length xs = length ys\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs = length ys \\<Longrightarrow>\n    list_all2 A (xs @ [x]) (ys @ [y]) = (list_all2 A xs ys \\<and> A x y)\n 2. length xs \\<noteq> length ys \\<Longrightarrow>\n    list_all2 A (xs @ [x]) (ys @ [y]) = (list_all2 A xs ys \\<and> A x y)", "case True"], ["proof (state)\nthis:\n  length xs = length ys\n\ngoal (2 subgoals):\n 1. length xs = length ys \\<Longrightarrow>\n    list_all2 A (xs @ [x]) (ys @ [y]) = (list_all2 A xs ys \\<and> A x y)\n 2. length xs \\<noteq> length ys \\<Longrightarrow>\n    list_all2 A (xs @ [x]) (ys @ [y]) = (list_all2 A xs ys \\<and> A x y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 A (xs @ [x]) (ys @ [y]) = (list_all2 A xs ys \\<and> A x y)", "by (simp add: list_all2_append[OF True])"], ["proof (state)\nthis:\n  list_all2 A (xs @ [x]) (ys @ [y]) = (list_all2 A xs ys \\<and> A x y)\n\ngoal (1 subgoal):\n 1. length xs \\<noteq> length ys \\<Longrightarrow>\n    list_all2 A (xs @ [x]) (ys @ [y]) = (list_all2 A xs ys \\<and> A x y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length xs \\<noteq> length ys \\<Longrightarrow>\n    list_all2 A (xs @ [x]) (ys @ [y]) = (list_all2 A xs ys \\<and> A x y)", "case False"], ["proof (state)\nthis:\n  length xs \\<noteq> length ys\n\ngoal (1 subgoal):\n 1. length xs \\<noteq> length ys \\<Longrightarrow>\n    list_all2 A (xs @ [x]) (ys @ [y]) = (list_all2 A xs ys \\<and> A x y)", "note len = list_all2_lengthD[of A]"], ["proof (state)\nthis:\n  list_all2 A ?xs ?ys \\<Longrightarrow> length ?xs = length ?ys\n\ngoal (1 subgoal):\n 1. length xs \\<noteq> length ys \\<Longrightarrow>\n    list_all2 A (xs @ [x]) (ys @ [y]) = (list_all2 A xs ys \\<and> A x y)", "from len[of xs ys] len[of \"xs @ [x]\" \"ys @ [y]\"] False"], ["proof (chain)\npicking this:\n  list_all2 A xs ys \\<Longrightarrow> length xs = length ys\n  list_all2 A (xs @ [x]) (ys @ [y]) \\<Longrightarrow>\n  length (xs @ [x]) = length (ys @ [y])\n  length xs \\<noteq> length ys", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all2 A xs ys \\<Longrightarrow> length xs = length ys\n  list_all2 A (xs @ [x]) (ys @ [y]) \\<Longrightarrow>\n  length (xs @ [x]) = length (ys @ [y])\n  length xs \\<noteq> length ys\n\ngoal (1 subgoal):\n 1. list_all2 A (xs @ [x]) (ys @ [y]) = (list_all2 A xs ys \\<and> A x y)", "by auto"], ["proof (state)\nthis:\n  list_all2 A (xs @ [x]) (ys @ [y]) = (list_all2 A xs ys \\<and> A x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}