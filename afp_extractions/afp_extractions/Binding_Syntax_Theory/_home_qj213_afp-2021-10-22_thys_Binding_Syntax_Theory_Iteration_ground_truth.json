{"file_name": "/home/qj213/afp-2021-10-22/thys/Binding_Syntax_Theory/Iteration.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Binding_Syntax_Theory", "problem_names": ["lemmas igWlsInp_defs = igWlsInp_def sameDom_def liftAll2_def", "lemmas igWlsBinp_defs = igWlsBinp_def sameDom_def liftAll2_def", "lemmas igWlsAllDisj_defs =\nigWlsAllDisj_def\nigWlsDisj_def igWlsAbsDisj_def", "lemma igAbsIPresIGWlsSTR_imp_igAbsIPresIGWls:\n\"igAbsIPresIGWlsSTR MOD \\<Longrightarrow> igAbsIPresIGWls MOD\"", "lemma igOpIPresIGWlsSTR_imp_igOpIPresIGWls:\n\"igOpIPresIGWlsSTR MOD \\<Longrightarrow> igOpIPresIGWls MOD\"", "lemmas igConsIPresIGWls_defs = igConsIPresIGWls_def\nigVarIPresIGWls_def\nigAbsIPresIGWls_def\nigOpIPresIGWls_def", "lemmas igConsIPresIGWlsSTR_defs = igConsIPresIGWlsSTR_def\nigVarIPresIGWls_def\nigAbsIPresIGWlsSTR_def\nigOpIPresIGWlsSTR_def", "lemma igConsIPresIGWlsSTR_imp_igConsIPresIGWls:\n\"igConsIPresIGWlsSTR MOD \\<Longrightarrow> igConsIPresIGWls MOD\"", "lemma igSwapIPresIGWlsSTR_imp_igSwapIPresIGWls:\n\"igSwapIPresIGWlsSTR MOD \\<Longrightarrow> igSwapIPresIGWls MOD\"", "lemma igSwapAbsIPresIGWlsAbsSTR_imp_igSwapAbsIPresIGWlsAbs:\n\"igSwapAbsIPresIGWlsAbsSTR MOD \\<Longrightarrow> igSwapAbsIPresIGWlsAbs MOD\"", "lemmas igSwapAllIPresIGWlsAll_defs = igSwapAllIPresIGWlsAll_def\nigSwapIPresIGWls_def igSwapAbsIPresIGWlsAbs_def", "lemmas igSwapAllIPresIGWlsAllSTR_defs = igSwapAllIPresIGWlsAllSTR_def\nigSwapIPresIGWlsSTR_def igSwapAbsIPresIGWlsAbsSTR_def", "lemma igSwapAllIPresIGWlsAllSTR_imp_igSwapAllIPresIGWlsAll:\n\"igSwapAllIPresIGWlsAllSTR MOD \\<Longrightarrow> igSwapAllIPresIGWlsAll MOD\"", "lemma igSubstIPresIGWlsSTR_imp_igSubstIPresIGWls:\n\"igSubstIPresIGWlsSTR MOD \\<Longrightarrow> igSubstIPresIGWls MOD\"", "lemma igSubstAbsIPresIGWlsAbsSTR_imp_igSubstAbsIPresIGWlsAbs:\n\"igSubstAbsIPresIGWlsAbsSTR MOD \\<Longrightarrow> igSubstAbsIPresIGWlsAbs MOD\"", "lemmas igSubstAllIPresIGWlsAll_defs = igSubstAllIPresIGWlsAll_def\nigSubstIPresIGWls_def igSubstAbsIPresIGWlsAbs_def", "lemmas igSubstAllIPresIGWlsAllSTR_defs = igSubstAllIPresIGWlsAllSTR_def\nigSubstIPresIGWlsSTR_def igSubstAbsIPresIGWlsAbsSTR_def", "lemma igSubstAllIPresIGWlsAllSTR_imp_igSubstAllIPresIGWlsAll:\n\"igSubstAllIPresIGWlsAllSTR MOD \\<Longrightarrow> igSubstAllIPresIGWlsAll MOD\"", "lemma igFreshIGAbs1STR_imp_igFreshIGAbs1:\n\"igFreshIGAbs1STR MOD \\<Longrightarrow> igFreshIGAbs1 MOD\"", "lemma igFreshIGAbs2STR_imp_igFreshIGAbs2:\n\"igFreshIGAbs2STR MOD \\<Longrightarrow> igFreshIGAbs2 MOD\"", "lemma igFreshIGOpSTR_imp_igFreshIGOp:\n\"igFreshIGOpSTR MOD \\<Longrightarrow> igFreshIGOp MOD\"", "lemmas igFreshCls_defs = igFreshCls_def\nigFreshIGVar_def\nigFreshIGAbs1_def igFreshIGAbs2_def\nigFreshIGOp_def", "lemmas igFreshClsSTR_defs = igFreshClsSTR_def\nigFreshIGVar_def\nigFreshIGAbs1STR_def igFreshIGAbs2STR_def\nigFreshIGOpSTR_def", "lemma igFreshClsSTR_imp_igFreshCls:\n\"igFreshClsSTR MOD \\<Longrightarrow> igFreshCls MOD\"", "lemma igSwapIGAbsSTR_imp_igSwapIGAbs:\n\"igSwapIGAbsSTR MOD \\<Longrightarrow> igSwapIGAbs MOD\"", "lemma igSwapIGOpSTR_imp_igSwapIGOp:\n\"igSwapIGOpSTR MOD \\<Longrightarrow> igSwapIGOp MOD\"", "lemmas igSwapCls_defs = igSwapCls_def\nigSwapIGVar_def\nigSwapIGAbs_def\nigSwapIGOp_def", "lemmas igSwapClsSTR_defs = igSwapClsSTR_def\nigSwapIGVar_def\nigSwapIGAbsSTR_def\nigSwapIGOpSTR_def", "lemma igSwapClsSTR_imp_igSwapCls:\n\"igSwapClsSTR MOD \\<Longrightarrow> igSwapCls MOD\"", "lemma igSubstIGVar1STR_imp_igSubstIGVar1:\n\"igSubstIGVar1STR MOD \\<Longrightarrow> igSubstIGVar1 MOD\"", "lemma igSubstIGVar2STR_imp_igSubstIGVar2:\n\"igSubstIGVar2STR MOD \\<Longrightarrow> igSubstIGVar2 MOD\"", "lemma igSubstIGAbsSTR_imp_igSubstIGAbs:\n\"igSubstIGAbsSTR MOD \\<Longrightarrow> igSubstIGAbs MOD\"", "lemma igSubstIGOpSTR_imp_igSubstIGOp:\n\"igSubstIGOpSTR MOD \\<Longrightarrow> igSubstIGOp MOD\"", "lemmas igSubstCls_defs = igSubstCls_def\nigSubstIGVar1_def igSubstIGVar2_def\nigSubstIGAbs_def\nigSubstIGOp_def", "lemmas igSubstClsSTR_defs = igSubstClsSTR_def\nigSubstIGVar1STR_def igSubstIGVar2STR_def\nigSubstIGAbsSTR_def\nigSubstIGOpSTR_def", "lemma igSubstClsSTR_imp_igSubstCls:\n\"igSubstClsSTR MOD \\<Longrightarrow> igSubstCls MOD\"", "lemma igAbsCongSSTR_imp_igAbsCongS:\n\"igAbsCongSSTR MOD \\<Longrightarrow> igAbsCongS MOD\"", "lemma igAbsCongUSTR_imp_igAbsCongU:\n\"igAbsCongUSTR MOD \\<Longrightarrow> igAbsCongU MOD\"", "lemma igAbsRenSTR_imp_igAbsRen:\n\"igAbsRenSTR MOD \\<Longrightarrow> igAbsRen MOD\"", "lemma igAbsRenSTR_imp_igAbsCongUSTR:\n\"igAbsRenSTR MOD \\<Longrightarrow> igAbsCongUSTR MOD\"", "lemmas iwlsFSw_defs1 = iwlsFSw_def\nigWlsAllDisj_def igWlsAbsIsInBar_def\nigConsIPresIGWls_def igSwapAllIPresIGWlsAll_def\nigFreshCls_def igSwapCls_def igAbsCongS_def", "lemmas iwlsFSw_defs = iwlsFSw_def\nigWlsAllDisj_defs igWlsAbsIsInBar_def\nigConsIPresIGWls_defs igSwapAllIPresIGWlsAll_defs\nigFreshCls_defs igSwapCls_defs igAbsCongS_def", "lemmas iwlsFSwSTR_defs1 = iwlsFSwSTR_def\nigWlsAllDisj_def igWlsAbsIsInBar_def\nigConsIPresIGWlsSTR_def igSwapAllIPresIGWlsAllSTR_def\nigFreshClsSTR_def igSwapClsSTR_def igAbsCongSSTR_def", "lemmas iwlsFSwSTR_defs = iwlsFSwSTR_def\nigWlsAllDisj_defs igWlsAbsIsInBar_def\nigConsIPresIGWlsSTR_defs igSwapAllIPresIGWlsAllSTR_defs\nigFreshClsSTR_defs igSwapClsSTR_defs igAbsCongSSTR_def", "lemma iwlsFSwSTR_imp_iwlsFSw:\n\"iwlsFSwSTR MOD \\<Longrightarrow> iwlsFSw MOD\"", "lemmas iwlsFSb_defs1 = iwlsFSb_def\nigWlsAllDisj_def igWlsAbsIsInBar_def\nigConsIPresIGWls_def igSubstAllIPresIGWlsAll_def\nigFreshCls_def igSubstCls_def igAbsRen_def", "lemmas iwlsFSb_defs = iwlsFSb_def\nigWlsAllDisj_defs igWlsAbsIsInBar_def\nigConsIPresIGWls_defs igSubstAllIPresIGWlsAll_defs\nigFreshCls_defs igSubstCls_defs igAbsRen_def", "lemmas wlsFSbSwSTR_defs1 = iwlsFSbSwTR_def\nigWlsAllDisj_def igWlsAbsIsInBar_def\nigConsIPresIGWlsSTR_def igSwapAllIPresIGWlsAllSTR_def\nigFreshClsSTR_def igSwapClsSTR_def igAbsRenSTR_def", "lemmas iwlsFSbSwTR_defs = iwlsFSbSwTR_def\nigWlsAllDisj_defs igWlsAbsIsInBar_def\nigConsIPresIGWlsSTR_defs igSwapAllIPresIGWlsAllSTR_defs\nigFreshClsSTR_defs igSwapClsSTR_defs igAbsRenSTR_def", "lemma iwlsFSbSwTR_imp_iwlsFSb:\n\"iwlsFSbSwTR MOD \\<Longrightarrow> iwlsFSb MOD\"", "lemmas iwlsFSwSb_defs1 = iwlsFSwSb_def\niwlsFSw_def igSubstAllIPresIGWlsAll_def igSubstCls_def", "lemmas iwlsFSwSb_defs = iwlsFSwSb_def\niwlsFSw_def igSubstAllIPresIGWlsAll_defs igSubstCls_defs", "lemmas iwlsFSbSw_defs1 = iwlsFSbSw_def\niwlsFSw_def igSwapAllIPresIGWlsAll_def igSwapCls_def", "lemmas iwlsFSbSw_defs = iwlsFSbSw_def\niwlsFSw_def igSwapAllIPresIGWlsAll_defs igSwapCls_defs", "lemma imp_igSwapInpIPresIGWlsInp:\n\"igSwapIPresIGWls MOD \\<Longrightarrow> igSwapInpIPresIGWlsInp MOD\"", "lemma imp_igSwapInpIPresIGWlsInpSTR:\n\"igSwapIPresIGWlsSTR MOD \\<Longrightarrow> igSwapInpIPresIGWlsInpSTR MOD\"", "lemma imp_igSubstInpIPresIGWlsInp:\n\"igSubstIPresIGWls MOD \\<Longrightarrow> igSubstInpIPresIGWlsInp MOD\"", "lemma imp_igSubstInpIPresIGWlsInpSTR:\n\"igSubstIPresIGWlsSTR MOD \\<Longrightarrow> igSubstInpIPresIGWlsInpSTR MOD\"", "lemma imp_igSwapBinpIPresIGWlsBinp:\n\"igSwapAbsIPresIGWlsAbs MOD \\<Longrightarrow> igSwapBinpIPresIGWlsBinp MOD\"", "lemma imp_igSwapBinpIPresIGWlsBinpSTR:\n\"igSwapAbsIPresIGWlsAbsSTR MOD \\<Longrightarrow> igSwapBinpIPresIGWlsBinpSTR MOD\"", "lemma imp_igSubstBinpIPresIGWlsBinp:\n\"igSubstAbsIPresIGWlsAbs MOD \\<Longrightarrow> igSubstBinpIPresIGWlsBinp MOD\"", "lemma imp_igSubstBinpIPresIGWlsBinpSTR:\n\"igSubstAbsIPresIGWlsAbsSTR MOD \\<Longrightarrow> igSubstBinpIPresIGWlsBinpSTR MOD\"", "lemmas ipresIGWlsAll_defs = ipresIGWlsAll_def\nipresIGWls_def ipresIGWlsAbs_def", "lemmas ipresIGCons_defs = ipresIGCons_def\nipresIGVar_def\nipresIGAbs_def\nipresIGOp_def", "lemmas ipresIGFreshAll_defs = ipresIGFreshAll_def\nipresIGFresh_def ipresIGFreshAbs_def", "lemmas ipresIGSwapAll_defs = ipresIGSwapAll_def\nipresIGSwap_def ipresIGSwapAbs_def", "lemmas ipresIGSubstAll_defs = ipresIGSubstAll_def\nipresIGSubst_def ipresIGSubstAbs_def", "lemmas FSwImorph_defs1 = FSwImorph_def\nipresIGWlsAll_def ipresIGCons_def\nipresIGFreshAll_def ipresIGSwapAll_def", "lemmas FSwImorph_defs = FSwImorph_def\nipresIGWlsAll_defs ipresIGCons_defs\nipresIGFreshAll_defs ipresIGSwapAll_defs", "lemmas FSbImorph_defs1 = FSbImorph_def\nipresIGWlsAll_def ipresIGCons_def\nipresIGFreshAll_def ipresIGSubstAll_def", "lemmas FSbImorph_defs = FSbImorph_def\nipresIGWlsAll_defs ipresIGCons_defs\nipresIGFreshAll_defs ipresIGSubstAll_defs", "lemmas FSwSbImorph_defs1 = FSwSbImorph_def\nFSwImorph_def ipresIGSubstAll_def", "lemmas FSwSbImorph_defs = FSwSbImorph_def\nFSwImorph_defs ipresIGSubstAll_defs", "lemma FSwSbImorph_iff:\n\"FSwSbImorph h hA MOD MOD' =\n (FSbImorph h hA MOD MOD' \\<and> ipresIGSwapAll h hA MOD MOD')\"", "lemma igSwapInp_None[simp]:\n\"(igSwapInp MOD zs z1 z2 inp i = None) = (inp i = None)\"", "lemma igSubstInp_None[simp]:\n\"(igSubstInp MOD ys Y y inp i = None) = (inp i = None)\"", "lemma imp_igWlsInp:\n\"igWlsInp MOD delta inp \\<Longrightarrow> ipresIGWls h MOD MOD' \n \\<Longrightarrow> igWlsInp MOD' delta (lift h inp)\"", "lemma FSwSbImorph_igWlsInp:\nassumes \"igWlsInp MOD delta inp\" and \"FSwSbImorph h hA MOD MOD'\"\nshows \"igWlsInp MOD' delta (lift h inp)\"", "lemma igSwapBinp_None[simp]:\n\"(igSwapBinp MOD zs z1 z2 binp i = None) = (binp i = None)\"", "lemma igSubstBinp_None[simp]:\n\"(igSubstBinp MOD ys Y y binp i = None) = (binp i = None)\"", "lemma imp_igWlsBinp:\nassumes *: \"igWlsBinp MOD delta binp\"\nand **: \"ipresIGWlsAbs hA MOD MOD'\"\nshows \"igWlsBinp MOD' delta (lift hA binp)\"", "lemma FSwSbImorph_igWlsBinp:\nassumes \"igWlsBinp MOD delta binp\" and \"FSwSbImorph h hA MOD MOD'\"\nshows \"igWlsBinp MOD' delta (lift hA binp)\"", "lemmas input_igSwap_igSubst_None =\nigSwapInp_None igSubstInp_None\nigSwapBinp_None igSubstBinp_None", "lemma id_FSwImorph: \"FSwImorph id id MOD MOD\"", "lemma id_FSbImorph: \"FSbImorph id id MOD MOD\"", "lemma id_FSwSbImorph: \"FSwSbImorph id id MOD MOD\"", "lemma comp_ipresIGWls:\nassumes \"ipresIGWls h MOD MOD'\" and \"ipresIGWls h' MOD' MOD''\"\nshows \"ipresIGWls (h' o h) MOD MOD''\"", "lemma comp_ipresIGWlsAbs:\nassumes \"ipresIGWlsAbs hA MOD MOD'\" and \"ipresIGWlsAbs hA' MOD' MOD''\"\nshows \"ipresIGWlsAbs (hA' o hA) MOD MOD''\"", "lemma comp_ipresIGWlsAll:\nassumes \"ipresIGWlsAll h hA MOD MOD'\" and \"ipresIGWlsAll h' hA' MOD' MOD''\"\nshows \"ipresIGWlsAll (h' o h) (hA' o hA) MOD MOD''\"", "lemma comp_ipresIGVar:\nassumes \"ipresIGVar h MOD MOD'\" and \"ipresIGVar h' MOD' MOD''\"\nshows \"ipresIGVar (h' o h) MOD MOD''\"", "lemma comp_ipresIGAbs:\nassumes \"ipresIGWls h MOD MOD'\"\nand \"ipresIGAbs h hA MOD MOD'\" and \"ipresIGAbs h' hA' MOD' MOD''\"\nshows \"ipresIGAbs (h' o h) (hA' o hA) MOD MOD''\"", "lemma comp_ipresIGOp:\nassumes ipres: \"ipresIGWls h MOD MOD'\" and ipresAbs: \"ipresIGWlsAbs hA MOD MOD'\"\nand h: \"ipresIGOp h hA MOD MOD'\" and h': \"ipresIGOp h' hA' MOD' MOD''\"\nshows \"ipresIGOp (h' o h) (hA' o hA) MOD MOD''\"", "lemma comp_ipresIGCons:\nassumes \"ipresIGWlsAll h hA MOD MOD'\"\nand \"ipresIGCons h hA MOD MOD'\" and \"ipresIGCons h' hA' MOD' MOD''\"\nshows \"ipresIGCons (h' o h) (hA' o hA) MOD MOD''\"", "lemma comp_ipresIGFresh:\nassumes \"ipresIGWls h MOD MOD'\"\nand \"ipresIGFresh h MOD MOD'\" and \"ipresIGFresh h' MOD' MOD''\"\nshows \"ipresIGFresh (h' o h) MOD MOD''\"", "lemma comp_ipresIGFreshAbs:\nassumes \"ipresIGWlsAbs hA MOD MOD'\"\nand \"ipresIGFreshAbs hA MOD MOD'\" and \"ipresIGFreshAbs hA' MOD' MOD''\"\nshows \"ipresIGFreshAbs (hA' o hA) MOD MOD''\"", "lemma comp_ipresIGFreshAll:\nassumes \"ipresIGWlsAll h hA MOD MOD'\"\nand \"ipresIGFreshAll h hA MOD MOD'\" and \"ipresIGFreshAll h' hA'  MOD' MOD''\"\nshows \"ipresIGFreshAll (h' o h) (hA' o hA) MOD MOD''\"", "lemma comp_ipresIGSwap:\nassumes \"ipresIGWls h MOD MOD'\"\nand \"ipresIGSwap h MOD MOD'\" and \"ipresIGSwap h' MOD' MOD''\"\nshows \"ipresIGSwap (h' o h) MOD MOD''\"", "lemma comp_ipresIGSwapAbs:\nassumes \"ipresIGWlsAbs hA MOD MOD'\"\nand \"ipresIGSwapAbs hA MOD MOD'\" and \"ipresIGSwapAbs hA' MOD' MOD''\"\nshows \"ipresIGSwapAbs (hA' o hA) MOD MOD''\"", "lemma comp_ipresIGSwapAll:\nassumes \"ipresIGWlsAll h hA MOD MOD'\"\nand \"ipresIGSwapAll h hA MOD MOD'\" and \"ipresIGSwapAll h' hA'  MOD' MOD''\"\nshows \"ipresIGSwapAll (h' o h) (hA' o hA) MOD MOD''\"", "lemma comp_ipresIGSubst:\nassumes \"ipresIGWls h MOD MOD'\"\nand \"ipresIGSubst h MOD MOD'\" and \"ipresIGSubst h' MOD' MOD''\"\nshows \"ipresIGSubst (h' o h) MOD MOD''\"", "lemma comp_ipresIGSubstAbs:\nassumes *: \"igWlsAbsIsInBar MOD\"\nand h: \"ipresIGWls h MOD MOD'\" and hA: \"ipresIGWlsAbs hA MOD MOD'\"\nand hhA: \"ipresIGSubstAbs h hA MOD MOD'\" and h'hA': \"ipresIGSubstAbs h' hA' MOD' MOD''\"\nshows \"ipresIGSubstAbs (h' o h) (hA' o hA) MOD MOD''\"", "lemma comp_ipresIGSubstAll:\nassumes \"igWlsAbsIsInBar MOD\"\nand \"ipresIGWlsAll h hA MOD MOD'\"\nand \"ipresIGSubstAll h hA MOD MOD'\" and \"ipresIGSubstAll h' hA'  MOD' MOD''\"\nshows \"ipresIGSubstAll (h' o h) (hA' o hA) MOD MOD''\"", "lemma comp_FSwImorph:\nassumes *: \"FSwImorph h hA MOD MOD'\" and **: \"FSwImorph h' hA' MOD' MOD''\"\nshows \"FSwImorph (h' o h) (hA' o hA) MOD MOD''\"", "lemma comp_FSbImorph:\nassumes \"igWlsAbsIsInBar MOD\"\nand \"FSbImorph h hA MOD MOD'\" and \"FSbImorph h' hA' MOD' MOD''\"\nshows \"FSbImorph (h' o h) (hA' o hA) MOD MOD''\"", "lemma comp_FSwSbImorph:\nassumes \"igWlsAbsIsInBar MOD\"\nand \"FSwSbImorph h hA MOD MOD'\" and \"FSwSbImorph h' hA' MOD' MOD''\"\nshows \"FSwSbImorph (h' o h) (hA' o hA) MOD MOD''\"", "lemma igWls_termMOD[simp]: \"igWls termMOD = wls\"", "lemma igWlsAbs_termMOD[simp]: \"igWlsAbs termMOD = wlsAbs\"", "lemma igWlsInp_termMOD_wlsInp[simp]:\n\"igWlsInp termMOD delta inp = wlsInp delta inp\"", "lemma igWlsBinp_termMOD_wlsBinp[simp]:\n\"igWlsBinp termMOD delta binp = wlsBinp delta binp\"", "lemmas igWlsAll_termMOD_simps =\nigWls_termMOD igWlsAbs_termMOD\nigWlsInp_termMOD_wlsInp igWlsBinp_termMOD_wlsBinp", "lemma igVar_termMOD[simp]: \"igVar termMOD = Var\"", "lemma igAbs_termMOD[simp]: \"igAbs termMOD = Abs\"", "lemma igOp_termMOD[simp]: \"igOp termMOD = Op\"", "lemmas igCons_termMOD_simps =\nigVar_termMOD igAbs_termMOD igOp_termMOD", "lemma igFresh_termMOD[simp]: \"igFresh termMOD = fresh\"", "lemma igFreshAbs_termMOD[simp]: \"igFreshAbs termMOD = freshAbs\"", "lemma igFreshInp_termMOD[simp]: \"igFreshInp termMOD = freshInp\"", "lemma igFreshBinp_termMOD[simp]: \"igFreshBinp termMOD = freshBinp\"", "lemmas igFreshAll_termMOD_simps =\nigFresh_termMOD igFreshAbs_termMOD\nigFreshInp_termMOD igFreshBinp_termMOD", "lemma igSwap_termMOD[simp]: \"igSwap termMOD = swap\"", "lemma igSwapAbs_termMOD[simp]: \"igSwapAbs termMOD = swapAbs\"", "lemma igSwapInp_termMOD[simp]: \"igSwapInp termMOD = swapInp\"", "lemma igSwapBinp_termMOD[simp]: \"igSwapBinp termMOD = swapBinp\"", "lemmas igSwapAll_termMOD_simps =\nigSwap_termMOD igSwapAbs_termMOD\nigSwapInp_termMOD igSwapBinp_termMOD", "lemma igSubst_termMOD[simp]: \"igSubst termMOD = subst\"", "lemma igSubstAbs_termMOD[simp]: \"igSubstAbs termMOD = substAbs\"", "lemma igSubstInp_termMOD[simp]: \"igSubstInp termMOD = substInp\"", "lemma igSubstBinp_termMOD[simp]: \"igSubstBinp termMOD = substBinp\"", "lemmas igSubstAll_termMOD_simps =\nigSubst_termMOD igSubstAbs_termMOD\nigSubstInp_termMOD igSubstBinp_termMOD", "lemmas structure_termMOD_simps =\nigWlsAll_termMOD_simps\nigFreshAll_termMOD_simps\nigSwapAll_termMOD_simps\nigSubstAll_termMOD_simps", "lemma termMOD_igWlsDisj: \"igWlsDisj termMOD\"", "lemma termMOD_igWlsAbsDisj: \"igWlsAbsDisj termMOD\"", "lemma termMOD_igWlsAllDisj: \"igWlsAllDisj termMOD\"", "lemma termMOD_igWlsAbsIsInBar: \"igWlsAbsIsInBar termMOD\"", "lemma termMOD_igVarIPresIGWls: \"igVarIPresIGWls termMOD\"", "lemma termMOD_igAbsIPresIGWls: \"igAbsIPresIGWls termMOD\"", "lemma termMOD_igOpIPresIGWls: \"igOpIPresIGWls termMOD\"", "lemma termMOD_igConsIPresIGWls: \"igConsIPresIGWls termMOD\"", "lemma termMOD_igSwapIPresIGWls: \"igSwapIPresIGWls termMOD\"", "lemma termMOD_igSwapAbsIPresIGWlsAbs: \"igSwapAbsIPresIGWlsAbs termMOD\"", "lemma termMOD_igSwapAllIPresIGWlsAll: \"igSwapAllIPresIGWlsAll termMOD\"", "lemma termMOD_igSubstIPresIGWls: \"igSubstIPresIGWls termMOD\"", "lemma termMOD_igSubstAbsIPresIGWlsAbs: \"igSubstAbsIPresIGWlsAbs termMOD\"", "lemma termMOD_igSubstAllIPresIGWlsAll: \"igSubstAllIPresIGWlsAll termMOD\"", "lemma termMOD_igFreshIGVar: \"igFreshIGVar termMOD\"", "lemma termMOD_igFreshIGAbs1: \"igFreshIGAbs1 termMOD\"", "lemma termMOD_igFreshIGAbs2: \"igFreshIGAbs2 termMOD\"", "lemma termMOD_igFreshIGOp: \"igFreshIGOp termMOD\"", "lemma termMOD_igFreshCls: \"igFreshCls termMOD\"", "lemma termMOD_igSwapIGVar: \"igSwapIGVar termMOD\"", "lemma termMOD_igSwapIGAbs: \"igSwapIGAbs termMOD\"", "lemma termMOD_igSwapIGOp: \"igSwapIGOp termMOD\"", "lemma termMOD_igSwapCls: \"igSwapCls termMOD\"", "lemma termMOD_igSubstIGVar1: \"igSubstIGVar1 termMOD\"", "lemma termMOD_igSubstIGVar2: \"igSubstIGVar2 termMOD\"", "lemma termMOD_igSubstIGAbs: \"igSubstIGAbs termMOD\"", "lemma termMOD_igSubstIGOp: \"igSubstIGOp termMOD\"", "lemma termMOD_igSubstCls: \"igSubstCls termMOD\"", "lemma termMOD_igAbsCongS: \"igAbsCongS termMOD\"", "lemma termMOD_igAbsRen: \"igAbsRen termMOD\"", "lemma termMOD_iwlsFSw: \"iwlsFSw termMOD\"", "lemma termMOD_iwlsFSb: \"iwlsFSb termMOD\"", "lemma termMOD_iwlsFSwSb: \"iwlsFSwSb termMOD\"", "lemma termMOD_iwlsFSbSw: \"iwlsFSbSw termMOD\"", "lemma ipresIGWls_termMOD[simp]:\n\"ipresIGWls h termMOD MOD = ipresWls h MOD\"", "lemma ipresIGWlsAbs_termMOD[simp]:\n\"ipresIGWlsAbs hA termMOD MOD = ipresWlsAbs hA MOD\"", "lemmas ipresWlsAll_defs = ipresWlsAll_def\nipresWls_def ipresWlsAbs_def", "lemma ipresIGWlsAll_termMOD[simp]:\n\"ipresIGWlsAll h hA termMOD MOD = ipresWlsAll h hA MOD\"", "lemmas ipresIGWlsAll_termMOD_simps =\nipresIGWls_termMOD ipresIGWlsAbs_termMOD ipresIGWlsAll_termMOD", "lemma ipresIGVar_termMOD[simp]:\n\"ipresIGVar h termMOD MOD = ipresVar h MOD\"", "lemma ipresIGAbs_termMOD[simp]:\n\"ipresIGAbs h hA termMOD MOD = ipresAbs h hA MOD\"", "lemma ipresIGOp_termMOD[simp]:\n\"ipresIGOp h hA termMOD MOD = ipresOp h hA MOD\"", "lemmas ipresCons_defs = ipresCons_def\nipresVar_def\nipresAbs_def\nipresOp_def", "lemma ipresIGCons_termMOD[simp]:\n\"ipresIGCons h hA termMOD MOD = ipresCons h hA MOD\"", "lemmas ipresIGCons_termMOD_simps =\nipresIGVar_termMOD ipresIGAbs_termMOD ipresIGOp_termMOD\nipresIGCons_termMOD", "lemma ipresIGFresh_termMOD[simp]:\n\"ipresIGFresh h termMOD MOD = ipresFresh h MOD\"", "lemma ipresIGFreshAbs_termMOD[simp]:\n\"ipresIGFreshAbs hA termMOD MOD = ipresFreshAbs hA MOD\"", "lemmas ipresFreshAll_defs = ipresFreshAll_def\nipresFresh_def ipresFreshAbs_def", "lemma ipresIGFreshAll_termMOD[simp]:\n\"ipresIGFreshAll h hA termMOD MOD = ipresFreshAll h hA MOD\"", "lemmas ipresIGFreshAll_termMOD_simps =\nipresIGFresh_termMOD ipresIGFreshAbs_termMOD ipresIGFreshAll_termMOD", "lemma ipresIGSwap_termMOD[simp]:\n\"ipresIGSwap h termMOD MOD = ipresSwap h MOD\"", "lemma ipresIGSwapAbs_termMOD[simp]:\n\"ipresIGSwapAbs hA termMOD MOD = ipresSwapAbs hA MOD\"", "lemmas ipresSwapAll_defs = ipresSwapAll_def\nipresSwap_def ipresSwapAbs_def", "lemma ipresIGSwapAll_termMOD[simp]:\n\"ipresIGSwapAll h hA termMOD MOD = ipresSwapAll h hA MOD\"", "lemmas ipresIGSwapAll_termMOD_simps =\nipresIGSwap_termMOD ipresIGSwapAbs_termMOD ipresIGSwapAll_termMOD", "lemma ipresIGSubst_termMOD[simp]:\n\"ipresIGSubst h termMOD MOD = ipresSubst h MOD\"", "lemma ipresIGSubstAbs_termMOD[simp]:\n\"ipresIGSubstAbs h hA termMOD MOD = ipresSubstAbs h hA MOD\"", "lemmas ipresSubstAll_defs = ipresSubstAll_def\nipresSubst_def ipresSubstAbs_def", "lemma ipresIGSubstAll_termMOD[simp]:\n\"ipresIGSubstAll h hA termMOD MOD = ipresSubstAll h hA MOD\"", "lemmas ipresIGSubstAll_termMOD_simps =\nipresIGSubst_termMOD ipresIGSubstAbs_termMOD ipresIGSubstAll_termMOD", "lemmas termFSwImorph_defs1 = termFSwImorph_def\nipresWlsAll_def ipresCons_def\nipresFreshAll_def ipresSwapAll_def", "lemmas termFSwImorph_defs = termFSwImorph_def\nipresWlsAll_defs ipresCons_defs\nipresFreshAll_defs ipresSwapAll_defs", "lemma FSwImorph_termMOD[simp]:\n\"FSwImorph h hA termMOD MOD = termFSwImorph h hA MOD\"", "lemmas termFSbImorph_defs1 = termFSbImorph_def\nipresWlsAll_def ipresCons_def\nipresFreshAll_def ipresSubstAll_def", "lemmas termFSbImorph_defs = termFSbImorph_def\nipresWlsAll_defs ipresCons_defs\nipresFreshAll_defs ipresSubstAll_defs", "lemma FSbImorph_termMOD[simp]:\n\"FSbImorph h hA termMOD MOD = termFSbImorph h hA MOD\"", "lemmas termFSwSbImorph_defs1 = termFSwSbImorph_def\ntermFSwImorph_def ipresSubstAll_def", "lemmas termFSwSbImorph_defs = termFSwSbImorph_def\ntermFSwImorph_defs ipresSubstAll_defs", "lemma termFSwSbImorph_iff:\n\"termFSwSbImorph h hA MOD =\n (termFSbImorph h hA MOD \\<and> ipresSwapAll h hA MOD)\"", "lemma FSwSbImorph_termMOD[simp]:\n\"FSwSbImorph h hA termMOD MOD = termFSwSbImorph h hA MOD\"", "lemma ipresWls_wlsInp:\nassumes \"wlsInp delta inp\" and \"ipresWls h MOD\"\nshows \"igWlsInp MOD delta (lift h inp)\"", "lemma termFSwImorph_wlsInp:\nassumes \"wlsInp delta inp\" and \"termFSwImorph h hA MOD\"\nshows \"igWlsInp MOD delta (lift h inp)\"", "lemma termFSwSbImorph_wlsInp:\nassumes \"wlsInp delta inp\" and \"termFSwSbImorph h hA MOD\"\nshows \"igWlsInp MOD delta (lift h inp)\"", "lemma ipresWls_wlsBinp:\nassumes \"wlsBinp delta binp\" and \"ipresWlsAbs hA MOD\"\nshows \"igWlsBinp MOD delta (lift hA binp)\"", "lemma termFSwImorph_wlsBinp:\nassumes \"wlsBinp delta binp\" and \"termFSwImorph h hA MOD\"\nshows \"igWlsBinp MOD delta (lift hA binp)\"", "lemma termFSwSbImorph_wlsBinp:\nassumes \"wlsBinp delta binp\" and \"termFSwSbImorph h hA MOD\"\nshows \"igWlsBinp MOD delta (lift hA binp)\"", "lemma id_termFSwImorph: \"termFSwImorph id id termMOD\"", "lemma id_termFSbImorph: \"termFSbImorph id id termMOD\"", "lemma id_termFSwSbImorph: \"termFSwSbImorph id id termMOD\"", "lemma comp_termFSwImorph:\nassumes *: \"termFSwImorph h hA MOD\" and **: \"FSwImorph h' hA' MOD MOD'\"\nshows \"termFSwImorph (h' o h) (hA' o hA) MOD'\"", "lemma comp_termFSbImorph:\nassumes *: \"termFSbImorph h hA MOD\" and **: \"FSbImorph h' hA' MOD MOD'\"\nshows \"termFSbImorph (h' o h) (hA' o hA) MOD'\"", "lemma comp_termFSwSbImorph:\nassumes *: \"termFSwSbImorph h hA MOD\" and **: \"FSwSbImorph h' hA' MOD MOD'\"\nshows \"termFSwSbImorph (h' o h) (hA' o hA) MOD'\"", "lemmas mapFrom_termMOD_simps =\nipresIGWlsAll_termMOD_simps\nipresIGCons_termMOD_simps\nipresIGFreshAll_termMOD_simps\nipresIGSwapAll_termMOD_simps\nipresIGSubstAll_termMOD_simps\nFSwImorph_termMOD FSbImorph_termMOD FSwSbImorph_termMOD", "lemmas termMOD_simps =\nstructure_termMOD_simps mapFrom_termMOD_simps", "lemma ipresCons_imp_ipresWlsAll:\nassumes *: \"ipresCons h hA MOD\" and **: \"igConsIPresIGWls MOD\"\nshows \"ipresWlsAll h hA MOD\"", "lemma ipresCons_imp_ipresFreshAll:\nassumes *: \"ipresCons h hA MOD\" and **: \"igFreshCls MOD\"\nand \"igConsIPresIGWls MOD\"\nshows \"ipresFreshAll h hA MOD\"", "lemma ipresCons_imp_ipresSwapAll:\nassumes *: \"ipresCons h hA MOD\" and **: \"igSwapCls MOD\"\nand \"igConsIPresIGWls MOD\"\nshows \"ipresSwapAll h hA MOD\"", "lemma ipresCons_imp_ipresSubstAll_aux:\nassumes *: \"ipresCons h hA MOD\" and **: \"igSubstCls MOD\"\nand \"igConsIPresIGWls MOD\" and \"igFreshCls MOD\"\nassumes P: \"wlsPar P\"\nshows\n\"(wls s X \\<longrightarrow>\n  (\\<forall> ys y Y. y \\<in> varsOfS P ys \\<and> Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n             h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)))\n\\<and>\n (wlsAbs (us,s') A \\<longrightarrow>\n  (\\<forall> ys y Y. y \\<in> varsOfS P ys \\<and> Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n             hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A)))\"", "lemma ipresCons_imp_ipresSubst:\nassumes *: \"ipresCons h hA MOD\" and **: \"igSubstCls MOD\"\nand \"igConsIPresIGWls MOD\" and \"igFreshCls MOD\"\nshows \"ipresSubst h MOD\"", "lemma ipresCons_imp_ipresSubstAbs:\nassumes *: \"ipresCons h hA MOD\" and **: \"igSubstCls MOD\"\nand \"igConsIPresIGWls MOD\" and \"igFreshCls MOD\"\nshows \"ipresSubstAbs h hA MOD\"", "lemma ipresCons_imp_ipresSubstAll:\nassumes *: \"ipresCons h hA MOD\" and **: \"igSubstCls MOD\"\nand \"igConsIPresIGWls MOD\" and \"igFreshCls MOD\"\nshows \"ipresSubstAll h hA MOD\"", "lemma iwlsFSw_termFSwImorph_iff:\n\"iwlsFSw MOD \\<Longrightarrow> termFSwImorph h hA MOD = ipresCons h hA MOD\"", "lemma iwlsFSb_termFSbImorph_iff:\n\"iwlsFSb MOD \\<Longrightarrow> termFSbImorph h hA MOD = ipresCons h hA MOD\"", "lemma iwlsFSwSb_termFSwSbImorph_iff:\n\"iwlsFSwSb MOD \\<Longrightarrow> termFSwSbImorph h hA MOD = ipresCons h hA MOD\"", "lemma iwlsFSbSw_termFSwSbImorph_iff:\n\"iwlsFSbSw MOD \\<Longrightarrow> termFSwSbImorph h hA MOD = ipresCons h hA MOD\"", "lemma check_ex_unique:\n\"eX \\<noteq> ERR \\<Longrightarrow> (EX! X. eX = OK X)\"", "lemma check_OK[simp]:\n\"check (OK X) = X\"", "lemma OK_check[simp]:\n\"eX \\<noteq> ERR \\<Longrightarrow> OK (check eX) = eX\"", "lemma checkI_OKI[simp]:\n\"checkI (OKI inp) = inp\"", "lemma OKI_checkI[simp]:\nassumes \"liftAll (\\<lambda> X. X \\<noteq> ERR) einp\"\nshows \"OKI (checkI einp) = einp\"", "lemma OKI_inj[simp]:\nfixes inp inp' :: \"('index,'gTerm)input\"\nshows \"(OKI inp = OKI inp') = (inp = inp')\"", "lemmas OK_OKI_simps =\ncheck_OK OK_check checkI_OKI OKI_checkI OKI_inj", "lemma eWls_simp1[simp]:\n\"eWls MOD s (OK X) = igWls MOD s X\"", "lemma eWls_simp2[simp]:\n\"eWls MOD s ERR = False\"", "lemma eWlsAbs_simp1[simp]:\n\"eWlsAbs MOD (us,s) (OK A) = igWlsAbs MOD (us,s) A\"", "lemma eWlsAbs_simp2[simp]:\n\"eWlsAbs MOD (us,s) ERR = False\"", "lemma eWlsInp_simp1[simp]:\n\"eWlsInp MOD delta (OKI inp) = igWlsInp MOD delta inp\"", "lemma eWlsInp_simp2[simp]:\n\"\\<not> liftAll (\\<lambda> eX. eX \\<noteq> ERR) einp \\<Longrightarrow> \\<not> eWlsInp MOD delta einp\"", "lemma eWlsBinp_simp1[simp]:\n\"eWlsBinp MOD delta (OKI binp) = igWlsBinp MOD delta binp\"", "lemma eWlsBinp_simp2[simp]:\n\"\\<not> liftAll (\\<lambda> eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow> \\<not> eWlsBinp MOD delta ebinp\"", "lemmas eWlsAll_simps =\neWls_simp1 eWls_simp2\neWlsAbs_simp1 eWlsAbs_simp2\neWlsInp_simp1 eWlsInp_simp2 eWlsInp_simp3\neWlsBinp_simp1 eWlsBinp_simp2 eWlsBinp_simp3", "lemma eVar_simp[simp]:\n\"eVar MOD xs x = OK (igVar MOD xs x)\"", "lemma eAbs_simp1[simp]:\n\"\\<lbrakk>isInBar (xs,s); igWls MOD s X\\<rbrakk> \\<Longrightarrow> eAbs MOD xs x (OK X) = OK (igAbs MOD xs x X)\"", "lemma eAbs_simp2[simp]:\n\"\\<forall> s. \\<not> (isInBar (xs,s) \\<and> igWls MOD s X) \\<Longrightarrow> eAbs MOD xs x (OK X) = ERR\"", "lemma eAbs_simp3[simp]:\n\"eAbs MOD xs x ERR = ERR\"", "lemma eOp_simp1[simp]:\nassumes \"igWlsInp MOD delta inp\" and \"igWlsBinp MOD delta binp\"\nshows \"eOp MOD delta (OKI inp) (OKI binp) = OK (igOp MOD delta inp binp)\"", "lemma eOp_simp2[simp]:\nassumes \"\\<not> igWlsInp MOD delta inp\"\nshows \"eOp MOD delta (OKI inp) ebinp = ERR\"", "lemma eOp_simp3[simp]:\nassumes \"\\<not> igWlsBinp MOD delta binp\"\nshows \"eOp MOD delta einp (OKI binp) = ERR\"", "lemma eOp_simp4[simp]:\nassumes \"\\<not> liftAll (\\<lambda> eX. eX \\<noteq> ERR) einp\"\nshows \"eOp MOD delta einp ebinp = ERR\"", "lemma eOp_simp6[simp]:\nassumes \"\\<not> liftAll (\\<lambda> eA. eA \\<noteq> ERR) ebinp\"\nshows \"eOp MOD delta einp ebinp = ERR\"", "lemmas eCons_simps =\neVar_simp\neAbs_simp1 eAbs_simp2 eAbs_simp3\neOp_simp1 eOp_simp2 eOp_simp3 eOp_simp4 eOp_simp5 eOp_simp6 eOp_simp7", "lemma eFresh_simp1[simp]:\n\"igWls MOD s X \\<Longrightarrow> eFresh MOD ys y (OK X) = igFresh MOD ys y X\"", "lemma eFresh_simp2[simp]:\n\"\\<forall> s. \\<not> igWls MOD s X \\<Longrightarrow> eFresh MOD ys y (OK X)\"", "lemma eFresh_simp3[simp]:\n\"eFresh MOD ys y ERR\"", "lemma eFreshAbs_simp1[simp]:\n\"igWlsAbs MOD (us,s) A \\<Longrightarrow> eFreshAbs MOD ys y (OK A) = igFreshAbs MOD ys y A\"", "lemma eFreshAbs_simp2[simp]:\n\"\\<forall> us s. \\<not> igWlsAbs MOD (us,s) A \\<Longrightarrow> eFreshAbs MOD ys y (OK A)\"", "lemma eFreshAbs_simp3[simp]:\n\"eFreshAbs MOD ys y ERR\"", "lemma eFreshInp_simp[simp]:\n\"igWlsInp MOD delta inp\n \\<Longrightarrow> eFreshInp MOD ys y (OKI inp) = igFreshInp MOD ys y inp\"", "lemma eFreshBinp_simp[simp]:\n\"igWlsBinp MOD delta binp\n \\<Longrightarrow> eFreshBinp MOD ys y (OKI binp) = igFreshBinp MOD ys y binp\"", "lemmas eFreshAll_simps =\neFresh_simp1 eFresh_simp2 eFresh_simp3\neFreshAbs_simp1 eFreshAbs_simp2 eFreshAbs_simp3\neFreshInp_simp\neFreshBinp_simp", "lemma eSwap_simp1[simp]:\n\"igWls MOD s X\n \\<Longrightarrow> eSwap MOD zs z1 z2 (OK X) = OK (igSwap MOD zs z1 z2 X)\"", "lemma eSwap_simp2[simp]:\n\"\\<forall> s. \\<not> igWls MOD s X \\<Longrightarrow> eSwap MOD zs z1 z2 (OK X) = ERR\"", "lemma eSwap_simp3[simp]:\n\"eSwap MOD zs z1 z2 ERR = ERR\"", "lemma eSwapAbs_simp1[simp]:\n\"igWlsAbs MOD (us,s) A\n \\<Longrightarrow> eSwapAbs MOD zs z1 z2 (OK A) = OK (igSwapAbs MOD zs z1 z2 A)\"", "lemma eSwapAbs_simp2[simp]:\n\"\\<forall> us s. \\<not> igWlsAbs MOD (us,s) A \\<Longrightarrow> eSwapAbs MOD zs z1 z2 (OK A) = ERR\"", "lemma eSwapAbs_simp3[simp]:\n\"eSwapAbs MOD zs z1 z2 ERR = ERR\"", "lemma eSwapInp_simp1[simp]:\n\"igWlsInp MOD delta inp\n \\<Longrightarrow> eSwapInp MOD zs z1 z2 (OKI inp) = OKI (igSwapInp MOD zs z1 z2 inp)\"", "lemma eSwapInp_simp2[simp]:\nassumes \"\\<not> liftAll (\\<lambda> eX. eX \\<noteq> ERR) einp\"\nshows \"\\<not> liftAll (\\<lambda> eX. eX \\<noteq> ERR) (eSwapInp MOD zs z1 z2 einp)\"", "lemma eSwapBinp_simp1[simp]:\n\"igWlsBinp MOD delta binp\n \\<Longrightarrow> eSwapBinp MOD zs z1 z2 (OKI binp) = OKI (igSwapBinp MOD zs z1 z2 binp)\"", "lemma eSwapBinp_simp2[simp]:\nassumes \"\\<not> liftAll (\\<lambda> eA. eA \\<noteq> ERR) ebinp\"\nshows \"\\<not> liftAll (\\<lambda> eA. eA \\<noteq> ERR) (eSwapBinp MOD zs z1 z2 ebinp)\"", "lemmas eSwapAll_simps =\neSwap_simp1 eSwap_simp2 eSwap_simp3\neSwapAbs_simp1 eSwapAbs_simp2 eSwapAbs_simp3\neSwapInp_simp1 eSwapInp_simp2\neSwapBinp_simp1 eSwapBinp_simp2", "lemma eSubst_simp1[simp]:\n\"\\<lbrakk>igWls MOD (asSort ys) Y; igWls MOD s X\\<rbrakk>\n \\<Longrightarrow> eSubst MOD ys (OK Y) y (OK X) = OK (igSubst MOD ys Y y X)\"", "lemma eSubst_simp2[simp]:\n\"\\<not> igWls MOD (asSort ys) Y \\<Longrightarrow> eSubst MOD ys (OK Y) y eX = ERR\"", "lemma eSubst_simp3[simp]:\n\"\\<forall> s. \\<not> igWls MOD s X \\<Longrightarrow> eSubst MOD ys eY y (OK X) = ERR\"", "lemma eSubst_simp4[simp]:\n\"eSubst MOD ys eY y ERR = ERR\"", "lemma eSubst_simp5[simp]:\n\"eSubst MOD ys ERR y eX = ERR\"", "lemma eSubstAbs_simp1[simp]:\n\"\\<lbrakk>igWls MOD (asSort ys) Y; igWlsAbs MOD (us,s) A\\<rbrakk>\n \\<Longrightarrow> eSubstAbs MOD ys (OK Y) y (OK A) = OK (igSubstAbs MOD ys Y y A)\"", "lemma eSubstAbs_simp2[simp]:\n\"\\<not> igWls MOD (asSort ys) Y \\<Longrightarrow> eSubstAbs MOD ys (OK Y) y eA = ERR\"", "lemma eSubstAbs_simp3[simp]:\n\"\\<forall> us s. \\<not> igWlsAbs MOD (us,s) A \\<Longrightarrow> eSubstAbs MOD ys eY y (OK A) = ERR\"", "lemma eSubstAbs_simp4[simp]:\n\"eSubstAbs MOD ys eY y ERR = ERR\"", "lemma eSubstAbs_simp5[simp]:\n\"eSubstAbs MOD ys ERR y eA = ERR\"", "lemma eSubstInp_simp1[simp]:\n\"\\<lbrakk>igWls MOD (asSort ys) Y; igWlsInp MOD delta inp\\<rbrakk>\n \\<Longrightarrow> eSubstInp MOD ys (OK Y) y (OKI inp) = OKI (igSubstInp MOD ys Y y inp)\"", "lemma eSubstInp_simp2[simp]:\nassumes \"\\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp\"\nshows \"\\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR) (eSubstInp MOD ys eY y einp)\"", "lemma eSubstInp_simp3[simp]:\nassumes *: \"\\<not> igWls MOD (asSort ys) Y\" and **: \"\\<not> einp = (\\<lambda> i. None)\"\nshows \"\\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR) (eSubstInp MOD ys (OK Y) y einp)\"", "lemma eSubstInp_simp4[simp]:\nassumes \"\\<not> einp = (\\<lambda> i. None)\"\nshows \"\\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR) (eSubstInp MOD ys ERR y einp)\"", "lemma eSubstBinp_simp1[simp]:\n\"\\<lbrakk>igWls MOD (asSort ys) Y; igWlsBinp MOD delta binp\\<rbrakk>\n \\<Longrightarrow> eSubstBinp MOD ys (OK Y) y (OKI binp) = OKI (igSubstBinp MOD ys Y y binp)\"", "lemma eSubstBinp_simp2[simp]:\nassumes \"\\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\"\nshows \"\\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR) (eSubstBinp MOD ys eY y ebinp)\"", "lemma eSubstBinp_simp3[simp]:\nassumes *: \"\\<not> igWls MOD (asSort ys) Y\" and **: \"\\<not> ebinp = (\\<lambda> i. None)\"\nshows \"\\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR) (eSubstBinp MOD ys (OK Y) y ebinp)\"", "lemma eSubstBinp_simp4[simp]:\nassumes \"\\<not> ebinp = (\\<lambda> i. None)\"\nshows \"\\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR) (eSubstBinp MOD ys ERR y ebinp)\"", "lemmas eSubstAll_simps =\neSubst_simp1 eSubst_simp2 eSubst_simp3 eSubst_simp4 eSubst_simp5\neSubstAbs_simp1 eSubstAbs_simp2 eSubstAbs_simp3 eSubstAbs_simp4 eSubstAbs_simp5\neSubstInp_simp1 eSubstInp_simp2 eSubstInp_simp3 eSubstInp_simp4\neSubstBinp_simp1 eSubstBinp_simp2 eSubstBinp_simp3 eSubstBinp_simp4", "lemmas error_model_simps =\nOK_OKI_simps\neWlsAll_simps\neCons_simps\neFreshAll_simps\neSwapAll_simps\neSubstAll_simps", "lemma eWls_nchotomy:\n\"(\\<exists> X. eX = OK X \\<and> igWls MOD s X) \\<or> \\<not> eWls MOD s eX\"", "lemma eWlsAbs_nchotomy:\n\"(\\<exists> A. eA = OK A \\<and> igWlsAbs MOD (us,s) A) \\<or> \\<not> eWlsAbs MOD (us,s) eA\"", "lemma eAbs_nchotomy:\n\"((\\<exists> s X. eX = OK X \\<and> isInBar (xs,s) \\<and> igWls MOD s X)) \\<or> (eAbs MOD xs x eX = ERR)\"", "lemma eOp_nchotomy:\n\"(\\<exists> inp binp. einp = OKI inp \\<and> igWlsInp MOD delta inp \\<and>\n              ebinp = OKI binp \\<and> igWlsBinp MOD delta binp)\n  \\<or>\n (eOp MOD delta einp ebinp = ERR)\"", "lemma eFresh_nchotomy:\n\"(\\<exists> s X. eX = OK X \\<and> igWls MOD s X) \\<or> eFresh MOD ys y eX\"", "lemma eFreshAbs_nchotomy:\n\"(\\<exists> us s A. eA = OK A \\<and> igWlsAbs MOD (us,s) A)\n \\<or> eFreshAbs MOD ys y eA\"", "lemma eSwap_nchotomy:\n\"(\\<exists> s X. eX = OK X \\<and> igWls MOD s X) \\<or>\n (eSwap MOD zs z1 z2 eX = ERR)\"", "lemma eSwapAbs_nchotomy:\n\"(\\<exists> us s A. eA = OK A \\<and> igWlsAbs MOD (us,s) A) \\<or>\n (eSwapAbs MOD zs z1 z2 eA = ERR)\"", "lemma eSubst_nchotomy:\n\"(\\<exists> Y. eY = OK Y \\<and>\n  igWls MOD (asSort ys) Y) \\<and> (\\<exists> s X. eX = OK X \\<and> igWls MOD s X)\n \\<or>\n (eSubst MOD ys eY y eX = ERR)\"", "lemma eSubstAbs_nchotomy:\n\"(\\<exists> Y. eY = OK Y \\<and> igWls MOD (asSort ys) Y) \\<and>\n (\\<exists> us s A. eA = OK A \\<and> igWlsAbs MOD (us,s) A)\n \\<or>\n (eSubstAbs MOD ys eY y eA = ERR)\"", "lemma eWls_invert:\nassumes \"eWls MOD s eX\"\nshows \"\\<exists> X. eX = OK X \\<and> igWls MOD s X\"", "lemma eWlsAbs_invert:\nassumes \"eWlsAbs MOD (us,s) eA\"\nshows \"\\<exists> A. eA = OK A \\<and> igWlsAbs MOD (us,s) A\"", "lemma eWlsInp_invert:\nassumes \"eWlsInp MOD delta einp\"\nshows \"\\<exists> inp. igWlsInp MOD delta inp \\<and> einp = OKI inp\"", "lemma eWlsBinp_invert:\nassumes \"eWlsBinp MOD delta ebinp\"\nshows \"\\<exists> binp. igWlsBinp MOD delta binp \\<and> ebinp = OKI binp\"", "lemma eAbs_invert:\nassumes \"eAbs MOD xs x eX = OK A\"\nshows \"\\<exists> s X. eX = OK X \\<and> isInBar (xs,s) \\<and> A = igAbs MOD xs x X \\<and> igWls MOD s X\"", "lemma eOp_invert:\nassumes \"eOp MOD delta einp ebinp = OK X\"\nshows\n\"\\<exists> inp binp. einp = OKI inp \\<and> ebinp = OKI binp \\<and>\n             X = igOp MOD delta inp binp \\<and>\n             igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\"", "lemma eFresh_invert:\nassumes \"\\<not> eFresh MOD ys y eX\"\nshows \"\\<exists> s X. eX = OK X \\<and> \\<not> igFresh MOD ys y X \\<and> igWls MOD s X\"", "lemma eFreshAbs_invert:\nassumes \"\\<not> eFreshAbs MOD ys y eA\"\nshows \"\\<exists> us s A. eA = OK A \\<and> \\<not> igFreshAbs MOD ys y A \\<and> igWlsAbs MOD (us,s) A\"", "lemma eSwap_invert:\nassumes \"eSwap MOD zs z1 z2 eX = OK Y\"\nshows \"\\<exists> s X. eX = OK X \\<and> Y = igSwap MOD zs z1 z2 X \\<and> igWls MOD s X\"", "lemma eSwapAbs_invert:\nassumes \"eSwapAbs MOD zs z1 z2 eA = OK B\"\nshows \"\\<exists> us s A. eA = OK A \\<and> B = igSwapAbs MOD zs z1 z2 A \\<and> igWlsAbs MOD (us,s) A\"", "lemma eSubst_invert:\nassumes \"eSubst MOD ys eY y eX = OK Z\"\nshows\n\"\\<exists> s X Y. eY = OK Y \\<and> eX = OK X \\<and> igWls MOD s X \\<and> igWls MOD (asSort ys) Y \\<and>\n          Z = igSubst MOD ys Y y X\"", "lemma eSubstAbs_invert:\nassumes \"eSubstAbs MOD ys eY y eA = OK Z\"\nshows\n\"\\<exists> us s A Y. eY = OK Y \\<and> eA = OK A \\<and> igWlsAbs MOD (us,s) A \\<and> igWls MOD (asSort ys) Y \\<and>\n             Z = igSubstAbs MOD ys Y y A\"", "lemma errMOD_igWlsDisj:\nassumes \"igWlsDisj MOD\"\nshows \"igWlsDisj (errMOD MOD)\"", "lemma errMOD_igWlsAbsDisj:\nassumes \"igWlsAbsDisj MOD\"\nshows \"igWlsAbsDisj (errMOD MOD)\"", "lemma errMOD_igWlsAllDisj:\nassumes \"igWlsAllDisj MOD\"\nshows \"igWlsAllDisj (errMOD MOD)\"", "lemma errMOD_igWlsAbsIsInBar:\nassumes \"igWlsAbsIsInBar MOD\"\nshows \"igWlsAbsIsInBar (errMOD MOD)\"", "lemma errMOD_igVarIPresIGWlsSTR:\nassumes \"igVarIPresIGWls MOD\"\nshows \"igVarIPresIGWls (errMOD MOD)\"", "lemma errMOD_igAbsIPresIGWlsSTR:\nassumes *: \"igAbsIPresIGWls MOD\" and **: \"igWlsAbsDisj MOD\"\nand ***: \"igWlsAbsIsInBar MOD\"\nshows \"igAbsIPresIGWlsSTR (errMOD MOD)\"", "lemma errMOD_igOpIPresIGWlsSTR:\nfixes MOD :: \"('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs)model\"\nassumes \"igOpIPresIGWls MOD\"\nshows \"igOpIPresIGWlsSTR (errMOD MOD)\"", "lemma errMOD_igConsIPresIGWlsSTR:\nassumes \"igConsIPresIGWls MOD\" and \"igWlsAllDisj MOD\"\nand \"igWlsAbsIsInBar MOD\"\nshows \"igConsIPresIGWlsSTR (errMOD MOD)\"", "lemma errMOD_igSwapIPresIGWlsSTR:\nassumes \"igSwapIPresIGWls MOD\" and \"igWlsDisj MOD\"\nshows \"igSwapIPresIGWlsSTR (errMOD MOD)\"", "lemma errMOD_igSwapAbsIPresIGWlsAbsSTR:\nassumes *: \"igSwapAbsIPresIGWlsAbs MOD\" and **: \"igWlsAbsDisj MOD\"\nand ***: \"igWlsAbsIsInBar MOD\"\nshows \"igSwapAbsIPresIGWlsAbsSTR (errMOD MOD)\"", "lemma errMOD_igSwapAllIPresIGWlsAllSTR:\nassumes \"igSwapAllIPresIGWlsAll MOD\" and \"igWlsAllDisj MOD\"\nand \"igWlsAbsIsInBar MOD\"\nshows \"igSwapAllIPresIGWlsAllSTR (errMOD MOD)\"", "lemma errMOD_igSubstIPresIGWlsSTR:\nassumes \"igSubstIPresIGWls MOD\" and \"igWlsDisj MOD\"\nshows \"igSubstIPresIGWlsSTR (errMOD MOD)\"", "lemma errMOD_igSubstAbsIPresIGWlsAbsSTR:\nassumes *: \"igSubstAbsIPresIGWlsAbs MOD\" and **: \"igWlsAbsDisj MOD\"\nand ***: \"igWlsAbsIsInBar MOD\"\nshows \"igSubstAbsIPresIGWlsAbsSTR (errMOD MOD)\"", "lemma errMOD_igSubstAllIPresIGWlsAllSTR:\nassumes \"igSubstAllIPresIGWlsAll MOD\" and \"igWlsAllDisj MOD\"\nand \"igWlsAbsIsInBar MOD\"\nshows \"igSubstAllIPresIGWlsAllSTR (errMOD MOD)\"", "lemma errMOD_igFreshIGVarSTR:\nassumes \"igVarIPresIGWls MOD\" and \"igFreshIGVar MOD\"\nshows \"igFreshIGVar (errMOD MOD)\"", "lemma errMOD_igFreshIGAbs1STR:\nassumes *: \"igAbsIPresIGWls MOD\" and **: \"igFreshIGAbs1 MOD\"\nshows \"igFreshIGAbs1STR (errMOD MOD)\"", "lemma errMOD_igFreshIGAbs2STR:\nassumes \"igAbsIPresIGWls MOD\" and \"igFreshIGAbs2 MOD\"\nshows \"igFreshIGAbs2STR (errMOD MOD)\"", "lemma errMOD_igFreshIGOpSTR:\nfixes MOD :: \"('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs)model\"\nassumes \"igOpIPresIGWls MOD\" and \"igFreshIGOp MOD\"\nshows \"igFreshIGOpSTR (errMOD MOD)\"", "lemma errMOD_igFreshClsSTR:\nassumes \"igConsIPresIGWls MOD\" and \"igFreshCls MOD\"\nshows \"igFreshClsSTR (errMOD MOD)\"", "lemma errMOD_igSwapIGVarSTR:\nfixes MOD :: \"('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs)model\"\nassumes \"igVarIPresIGWls MOD\" and \"igSwapIGVar MOD\"\nshows \"igSwapIGVar (errMOD MOD)\"", "lemma errMOD_igSwapIGAbsSTR:\nassumes *: \"igAbsIPresIGWls MOD\" and **: \"igWlsDisj MOD\"\nand ***: \"igSwapIPresIGWls MOD\" and ****: \"igSwapIGAbs MOD\"\nshows \"igSwapIGAbsSTR (errMOD MOD)\"", "lemma errMOD_igSwapIGOpSTR:\nassumes \"igWlsAbsIsInBar MOD\" and \"igOpIPresIGWls MOD\"\nand \"igSwapIPresIGWls MOD\" and \"igSwapAbsIPresIGWlsAbs MOD\"\nand \"igWlsDisj MOD\" and \"igWlsAbsDisj MOD\"\nand \"igSwapIGOp MOD\"\nshows \"igSwapIGOpSTR (errMOD MOD)\"", "lemma errMOD_igSwapClsSTR:\nassumes \"igWlsAllDisj MOD\" and \"igWlsDisj MOD\"\nand \"igWlsAbsIsInBar MOD\" and \"igConsIPresIGWls MOD\"\nand \"igSwapAllIPresIGWlsAll MOD\" and \"igSwapCls MOD\"\nshows \"igSwapClsSTR (errMOD MOD)\"", "lemma errMOD_igSubstIGVar1STR:\nassumes \"igVarIPresIGWls MOD\" and \"igSubstIGVar1 MOD\"\nshows \"igSubstIGVar1STR (errMOD MOD)\"", "lemma errMOD_igSubstIGVar2STR:\nassumes \"igVarIPresIGWls MOD\" and \"igSubstIGVar2 MOD\"\nshows \"igSubstIGVar2STR (errMOD MOD)\"", "lemma errMOD_igSubstIGAbsSTR:\nfixes MOD :: \"('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs)model\"\nassumes *: \"igAbsIPresIGWls MOD\" and **: \"igWlsDisj MOD\"\nand ***: \"igSubstIPresIGWls MOD\" and ****: \"igSubstIGAbs MOD\"\nshows \"igSubstIGAbsSTR (errMOD MOD)\"", "lemma errMOD_igSubstIGOpSTR:\nassumes \"igWlsAbsIsInBar MOD\"\nand \"igVarIPresIGWls MOD\" and \"igOpIPresIGWls MOD\"\nand \"igSubstIPresIGWls MOD\" and \"igSubstAbsIPresIGWlsAbs MOD\"\nand \"igWlsDisj MOD\" and \"igWlsAbsDisj MOD\"\nand \"igSubstIGOp MOD\"\nshows \"igSubstIGOpSTR (errMOD MOD)\"", "lemma errMOD_igSubstClsSTR:\nassumes \"igWlsAllDisj MOD\" and \"igConsIPresIGWls MOD\"\nand \"igWlsAbsIsInBar MOD\"\nand \"igSubstAllIPresIGWlsAll MOD\" and \"igSubstCls MOD\"\nshows \"igSubstClsSTR (errMOD MOD)\"", "lemma errMOD_igAbsCongSSTR:\nassumes \"igSwapIPresIGWls MOD\" and \"igWlsDisj MOD\" and \"igAbsCongS MOD\"\nshows \"igAbsCongSSTR (errMOD MOD)\"", "lemma errMOD_igAbsRenSTR:\nassumes \"igVarIPresIGWls MOD\" and \"igSubstIPresIGWls MOD\"\nand \"igWlsDisj MOD\" and \"igAbsRen MOD\"\nshows \"igAbsRenSTR (errMOD MOD)\"", "lemma errMOD_iwlsFSwSTR:\nfixes MOD :: \"('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs) model\"\nassumes \"iwlsFSw MOD\"\nshows \"iwlsFSwSTR (errMOD MOD)\"", "lemma errMOD_iwlsFSbSwTR:\nfixes MOD :: \"('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs) model\"\nassumes \"iwlsFSb MOD\"\nshows \"iwlsFSbSwTR (errMOD MOD)\"", "lemma check_ipresIGWls:\n\"ipresIGWls check (errMOD MOD) MOD\"", "lemma check_ipresIGWlsAbs:\n\"ipresIGWlsAbs check (errMOD MOD) MOD\"", "lemma check_ipresIGWlsAll:\n\"ipresIGWlsAll check check (errMOD MOD) MOD\"", "lemma check_ipresIGVar:\n\"ipresIGVar check (errMOD MOD) MOD\"", "lemma check_ipresIGAbs:\n\"ipresIGAbs check check (errMOD MOD) MOD\"", "lemma check_ipresIGOp:\n\"ipresIGOp check check (errMOD MOD) MOD\"", "lemma check_ipresIGCons:\n\"ipresIGCons check check (errMOD MOD) MOD\"", "lemma check_ipresIGFresh:\n\"ipresIGFresh check (errMOD MOD) MOD\"", "lemma check_ipresIGFreshAbs:\n\"ipresIGFreshAbs check (errMOD MOD) MOD\"", "lemma check_ipresIGFreshAll:\n\"ipresIGFreshAll check check (errMOD MOD) MOD\"", "lemma check_ipresIGSwap:\n\"ipresIGSwap check (errMOD MOD) MOD\"", "lemma check_ipresIGSwapAbs:\n\"ipresIGSwapAbs check (errMOD MOD) MOD\"", "lemma check_ipresIGSwapAll:\n\"ipresIGSwapAll check check (errMOD MOD) MOD\"", "lemma check_ipresIGSubst:\n\"ipresIGSubst check (errMOD MOD) MOD\"", "lemma check_ipresIGSubstAbs:\n\"ipresIGSubstAbs check check (errMOD MOD) MOD\"", "lemma check_ipresIGSubstAll:\n\"ipresIGSubstAll check check (errMOD MOD) MOD\"", "lemma check_FSwImorph:\n\"FSwImorph check check (errMOD MOD) MOD\"", "lemma check_FSbImorph:\n\"FSbImorph check check (errMOD MOD) MOD\"", "lemma qTermLess_ingoreFirst_wf:\n\"wf (inv_image qTermLess aux_qInit_ignoreFirst)\"", "lemma qFreshAll_igFreshAll_qInitAll:\nassumes \"igFreshClsSTR MOD\"\nshows\n\"(qFresh ys y qX \\<longrightarrow> igFresh MOD ys y (qInit MOD qX)) \\<and>\n (qFreshAbs ys y qA \\<longrightarrow> igFreshAbs MOD ys y (qInitAbs MOD qA))\"", "lemma qSwapAll_igSwapAll_qInitAll:\nassumes \"igSwapClsSTR MOD\"\nshows\n\"qInit MOD (qX #[[ z1 \\<and> z2]]_zs) = igSwap MOD zs z1 z2 (qInit MOD qX) \\<and>\n qInitAbs MOD (qA $[[z1 \\<and> z2]]_zs) = igSwapAbs MOD zs z1 z2 (qInitAbs MOD qA)\"", "lemma qSwapAll_igSubstAll_qInitAll:\nfixes qX::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      qA::\"('index,'bindex,'varSort,'var,'opSym)qAbs\"\nassumes *: \"igSubstClsSTR MOD\"  and \"igFreshClsSTR MOD\"\nand \"igAbsRenSTR MOD\"\nshows\n\"(qGood qX \\<longrightarrow>\n  (\\<forall> ys y1 y.\n     qAFresh ys y1 qX \\<longrightarrow>\n     qInit MOD (qX #[[y1 \\<and> y]]_ys) = igSubst MOD ys (igVar MOD ys y1) y (qInit MOD qX)))\n \\<and>\n (qGoodAbs qA \\<longrightarrow>\n  (\\<forall> ys y1 y.\n     qAFreshAbs ys y1 qA \\<longrightarrow>\n     qInitAbs MOD (qA $[[y1 \\<and> y]]_ys) = igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD qA)))\"", "lemma iwlsFSbSwTR_qSwapAll_igSubstAll_qInitAll:\nassumes wls: \"iwlsFSbSwTR MOD\"\nshows\n\"(qGood qX \\<longrightarrow>\n  qAFresh ys y1 qX \\<longrightarrow>\n  qInit MOD (qX #[[y1 \\<and> y]]_ys) = igSubst MOD ys (igVar MOD ys y1) y (qInit MOD qX))\n \\<and>\n (qGoodAbs qA \\<longrightarrow>\n  qAFreshAbs ys y1 qA \\<longrightarrow>\n  qInitAbs MOD (qA $[[y1 \\<and> y]]_ys) = igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD qA))\"", "lemma iwlsFSwSTR_alphaAll_qInitAll:\nassumes \"iwlsFSwSTR MOD\"\nshows\n\"(\\<forall> qX'. qX #= qX' \\<longrightarrow> qInit MOD qX = qInit MOD qX') \\<and>\n (\\<forall> qA'. qA $= qA' \\<longrightarrow> qInitAbs MOD qA = qInitAbs MOD qA')\"", "lemma iwlsFSbSwTR_alphaAll_qInitAll:\nfixes qX::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      qA::\"('index,'bindex,'varSort,'var,'opSym)qAbs\"\nassumes \"iwlsFSbSwTR MOD\"\nshows\n\"(qGood qX \\<longrightarrow> (\\<forall> qX'. qX #= qX' \\<longrightarrow> qInit MOD qX = qInit MOD qX')) \\<and>\n (qGoodAbs qA \\<longrightarrow> (\\<forall> qA'. qA $= qA' \\<longrightarrow> qInitAbs MOD qA = qInitAbs MOD qA'))\"", "lemma iwlsFSwSTR_iterSTR_ipresVar:\nassumes \"iwlsFSwSTR MOD\"\nshows \"ipresVar (iterSTR MOD) MOD\"", "lemma iwlsFSbSwTR_iterSTR_ipresVar:\nassumes \"iwlsFSbSwTR MOD\"\nshows \"ipresVar (iterSTR MOD) MOD\"", "lemma iwlsFSwSTR_iterSTR_ipresAbs:\nassumes \"iwlsFSwSTR MOD\"\nshows \"ipresAbs (iterSTR MOD) (iterAbsSTR MOD) MOD\"", "lemma iwlsFSbSwTR_iterSTR_ipresAbs:\nassumes \"iwlsFSbSwTR MOD\"\nshows \"ipresAbs (iterSTR MOD) (iterAbsSTR MOD) MOD\"", "lemma iwlsFSwSTR_iterSTR_ipresOp:\nassumes \"iwlsFSwSTR MOD\"\nshows \"ipresOp (iterSTR MOD) (iterAbsSTR MOD) MOD\"", "lemma iwlsFSbSwTR_iterSTR_ipresOp:\nassumes \"iwlsFSbSwTR MOD\"\nshows \"ipresOp (iterSTR MOD) (iterAbsSTR MOD) MOD\"", "lemma iwlsFSwSTR_iterSTR_ipresCons:\nassumes \"iwlsFSwSTR MOD\"\nshows \"ipresCons (iterSTR MOD) (iterAbsSTR MOD) MOD\"", "lemma iwlsFSbSwTR_iterSTR_ipresCons:\nassumes \"iwlsFSbSwTR MOD\"\nshows \"ipresCons (iterSTR MOD) (iterAbsSTR MOD) MOD\"", "lemma iwlsFSwSTR_iterSTR_termFSwImorph:\nassumes \"iwlsFSwSTR MOD\"\nshows \"termFSwImorph (iterSTR MOD) (iterAbsSTR MOD) MOD\"", "lemma iwlsFSbSwTR_iterSTR_termFSbImorph:\nassumes \"iwlsFSbSwTR MOD\"\nshows \"termFSbImorph (iterSTR MOD) (iterAbsSTR MOD) MOD\"", "theorem iwlsFSw_iterAll_termFSwImorph:\n\"iwlsFSw MOD \\<Longrightarrow> termFSwImorph (iter MOD) (iterAbs MOD) MOD\"", "theorem iwlsFSb_iterAll_termFSbImorph:\n\"iwlsFSb MOD \\<Longrightarrow> termFSbImorph (iter MOD) (iterAbs MOD) MOD\"", "theorem iwlsFSwSb_iterAll_termFSwSbImorph:\n\"iwlsFSwSb MOD \\<Longrightarrow> termFSwSbImorph (iter MOD) (iterAbs MOD) MOD\"", "theorem iwlsFSbSw_iterAll_termFSwSbImorph:\n\"iwlsFSbSw MOD \\<Longrightarrow> termFSwSbImorph (iter MOD) (iterAbs MOD) MOD\"", "lemma ipresCons_unique:\nassumes \"ipresCons f fA MOD\" and \"ipresCons ig igA MOD\"\nshows\n\"(wls s X \\<longrightarrow> f X = ig X) \\<and>\n (wlsAbs (us,s') A \\<longrightarrow> fA A = igA A)\"", "theorem iwlsFSw_iterAll_unique_ipresCons:\nassumes \"iwlsFSw MOD\" and \"ipresCons h hA MOD\"\nshows\n\"(wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n (wlsAbs (us,s') A \\<longrightarrow> hA A = iterAbs MOD A)\"", "theorem iwlsFSb_iterAll_unique_ipresCons:\nassumes \"iwlsFSb MOD\" and \"ipresCons h hA MOD\"\nshows\n\"(wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n (wlsAbs (us,s') A \\<longrightarrow> hA A = iterAbs MOD A)\"", "theorem iwlsFSwSb_iterAll_unique_ipresCons:\nassumes \"iwlsFSwSb MOD\" and \"ipresCons h hA MOD\"\nshows\n\"(wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n (wlsAbs (us,s') A \\<longrightarrow> hA A = iterAbs MOD A)\"", "theorem iwlsFSbSw_iterAll_unique_ipresCons:\nassumes *: \"iwlsFSbSw MOD\" and **: \"ipresCons h hA MOD\"\nshows\n\"(wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n (wlsAbs (us,s') A \\<longrightarrow> hA A = iterAbs MOD A)\"", "lemmas iteration_simps =\ninput_igSwap_igSubst_None\ntermMOD_simps\nerror_model_simps"], "translations": [["", "lemmas igWlsInp_defs = igWlsInp_def sameDom_def liftAll2_def"], ["", "definition igWlsBinp where\n\"igWlsBinp MOD delta binp ==\n wlsOpS delta \\<and> sameDom (barOf delta) binp \\<and> liftAll2 (igWlsAbs MOD) (barOf delta) binp\""], ["", "lemmas igWlsBinp_defs = igWlsBinp_def sameDom_def liftAll2_def"], ["", "text\\<open>Domain disjointness:\\<close>"], ["", "definition igWlsDisj where\n\"igWlsDisj MOD == \\<forall> s s' X. igWls MOD s X \\<and> igWls MOD s' X \\<longrightarrow> s = s'\""], ["", "definition igWlsAbsDisj where\n\"igWlsAbsDisj MOD ==\n \\<forall> xs s xs' s' A.\n    isInBar (xs,s) \\<and> isInBar (xs',s') \\<and>\n    igWlsAbs MOD (xs,s) A \\<and> igWlsAbs MOD (xs',s') A\n    \\<longrightarrow> xs = xs' \\<and> s = s'\""], ["", "definition igWlsAllDisj where\n\"igWlsAllDisj MOD ==\n igWlsDisj MOD \\<and> igWlsAbsDisj MOD\""], ["", "lemmas igWlsAllDisj_defs =\nigWlsAllDisj_def\nigWlsDisj_def igWlsAbsDisj_def"], ["", "text \\<open>Abstration domains inhabited only within bound arities:\\<close>"], ["", "definition igWlsAbsIsInBar where\n\"igWlsAbsIsInBar MOD ==\n \\<forall> us s A. igWlsAbs MOD (us,s) A \\<longrightarrow> isInBar (us,s)\""], ["", "text\\<open>Domain preservation by the operators: weak (``if\") versions and strong (``iff\") versions\n(for the latter, we use the suffix ``STR\"):\\<close>"], ["", "text\\<open>The constructs preserve the domains:\\<close>"], ["", "definition igVarIPresIGWls where\n\"igVarIPresIGWls MOD ==\n \\<forall> xs x. igWls MOD (asSort xs) (igVar MOD xs x)\""], ["", "definition igAbsIPresIGWls where\n\"igAbsIPresIGWls MOD ==\n \\<forall> xs s x X. isInBar (xs,s) \\<and> igWls MOD s X \\<longrightarrow>\n             igWlsAbs MOD (xs,s) (igAbs MOD xs x X)\""], ["", "definition igAbsIPresIGWlsSTR where\n\"igAbsIPresIGWlsSTR MOD ==\n \\<forall> xs s x X. isInBar (xs,s) \\<longrightarrow>\n             igWlsAbs MOD (xs,s) (igAbs MOD xs x X) =\n             igWls MOD s X\""], ["", "lemma igAbsIPresIGWlsSTR_imp_igAbsIPresIGWls:\n\"igAbsIPresIGWlsSTR MOD \\<Longrightarrow> igAbsIPresIGWls MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbsIPresIGWlsSTR MOD \\<Longrightarrow> igAbsIPresIGWls MOD", "unfolding igAbsIPresIGWlsSTR_def igAbsIPresIGWls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs s x X.\n       isInBar (xs, s) \\<longrightarrow>\n       igWlsAbs MOD (xs, s) (igAbs MOD xs x X) =\n       igWls MOD s X \\<Longrightarrow>\n    \\<forall>xs s x X.\n       isInBar (xs, s) \\<and> igWls MOD s X \\<longrightarrow>\n       igWlsAbs MOD (xs, s) (igAbs MOD xs x X)", "by simp"], ["", "definition igOpIPresIGWls where\n\"igOpIPresIGWls MOD ==\n \\<forall> delta inp binp.\n   igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n   \\<longrightarrow> igWls MOD (stOf delta) (igOp MOD delta inp binp)\""], ["", "definition igOpIPresIGWlsSTR where\n\"igOpIPresIGWlsSTR MOD ==\n \\<forall> delta inp binp.\n    igWls MOD (stOf delta) (igOp MOD delta inp binp) =\n    (igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp)\""], ["", "lemma igOpIPresIGWlsSTR_imp_igOpIPresIGWls:\n\"igOpIPresIGWlsSTR MOD \\<Longrightarrow> igOpIPresIGWls MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igOpIPresIGWlsSTR MOD \\<Longrightarrow> igOpIPresIGWls MOD", "unfolding igOpIPresIGWlsSTR_def igOpIPresIGWls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>delta inp binp.\n       igWls MOD (stOf delta) (igOp MOD delta inp binp) =\n       (igWlsInp MOD delta inp \\<and>\n        igWlsBinp MOD delta binp) \\<Longrightarrow>\n    \\<forall>delta inp binp.\n       igWlsInp MOD delta inp \\<and>\n       igWlsBinp MOD delta binp \\<longrightarrow>\n       igWls MOD (stOf delta) (igOp MOD delta inp binp)", "by simp"], ["", "definition igConsIPresIGWls where\n\"igConsIPresIGWls MOD ==\n igVarIPresIGWls MOD \\<and>\n igAbsIPresIGWls MOD \\<and>\n igOpIPresIGWls MOD\""], ["", "lemmas igConsIPresIGWls_defs = igConsIPresIGWls_def\nigVarIPresIGWls_def\nigAbsIPresIGWls_def\nigOpIPresIGWls_def"], ["", "definition igConsIPresIGWlsSTR where\n\"igConsIPresIGWlsSTR MOD ==\n igVarIPresIGWls MOD \\<and>\n igAbsIPresIGWlsSTR MOD \\<and>\n igOpIPresIGWlsSTR MOD\""], ["", "lemmas igConsIPresIGWlsSTR_defs = igConsIPresIGWlsSTR_def\nigVarIPresIGWls_def\nigAbsIPresIGWlsSTR_def\nigOpIPresIGWlsSTR_def"], ["", "lemma igConsIPresIGWlsSTR_imp_igConsIPresIGWls:\n\"igConsIPresIGWlsSTR MOD \\<Longrightarrow> igConsIPresIGWls MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igConsIPresIGWlsSTR MOD \\<Longrightarrow> igConsIPresIGWls MOD", "unfolding igConsIPresIGWlsSTR_def igConsIPresIGWls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igVarIPresIGWls MOD \\<and>\n    igAbsIPresIGWlsSTR MOD \\<and> igOpIPresIGWlsSTR MOD \\<Longrightarrow>\n    igVarIPresIGWls MOD \\<and> igAbsIPresIGWls MOD \\<and> igOpIPresIGWls MOD", "using\nigAbsIPresIGWlsSTR_imp_igAbsIPresIGWls\nigOpIPresIGWlsSTR_imp_igOpIPresIGWls"], ["proof (prove)\nusing this:\n  igAbsIPresIGWlsSTR ?MOD \\<Longrightarrow> igAbsIPresIGWls ?MOD\n  igOpIPresIGWlsSTR ?MOD \\<Longrightarrow> igOpIPresIGWls ?MOD\n\ngoal (1 subgoal):\n 1. igVarIPresIGWls MOD \\<and>\n    igAbsIPresIGWlsSTR MOD \\<and> igOpIPresIGWlsSTR MOD \\<Longrightarrow>\n    igVarIPresIGWls MOD \\<and> igAbsIPresIGWls MOD \\<and> igOpIPresIGWls MOD", "by auto"], ["", "(* The notion of ``fresh\" preserving well-sorted-ness does not make sense, since\n``fresh\" is a relation. *)"], ["", "text\\<open>``swap\" preserves the domains:\\<close>"], ["", "definition igSwapIPresIGWls where\n\"igSwapIPresIGWls MOD ==\n \\<forall> zs z1 z2 s X. igWls MOD s X \\<longrightarrow>\n                 igWls MOD s (igSwap MOD zs z1 z2 X)\""], ["", "definition igSwapIPresIGWlsSTR where\n\"igSwapIPresIGWlsSTR MOD ==\n \\<forall> zs z1 z2 s X. igWls MOD s (igSwap MOD zs z1 z2 X) =\n                 igWls MOD s X\""], ["", "lemma igSwapIPresIGWlsSTR_imp_igSwapIPresIGWls:\n\"igSwapIPresIGWlsSTR MOD \\<Longrightarrow> igSwapIPresIGWls MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIPresIGWlsSTR MOD \\<Longrightarrow> igSwapIPresIGWls MOD", "unfolding igSwapIPresIGWlsSTR_def igSwapIPresIGWls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 s X.\n       igWls MOD s (igSwap MOD zs z1 z2 X) = igWls MOD s X \\<Longrightarrow>\n    \\<forall>zs z1 z2 s X.\n       igWls MOD s X \\<longrightarrow> igWls MOD s (igSwap MOD zs z1 z2 X)", "by simp"], ["", "definition igSwapAbsIPresIGWlsAbs where\n\"igSwapAbsIPresIGWlsAbs MOD ==\n \\<forall> zs z1 z2 us s A.\n   isInBar (us,s) \\<and> igWlsAbs MOD (us,s) A \\<longrightarrow>\n   igWlsAbs MOD (us,s) (igSwapAbs MOD zs z1 z2 A)\""], ["", "definition igSwapAbsIPresIGWlsAbsSTR where\n\"igSwapAbsIPresIGWlsAbsSTR MOD ==\n \\<forall> zs z1 z2 us s A.\n   igWlsAbs MOD (us,s) (igSwapAbs MOD zs z1 z2 A) =\n   igWlsAbs MOD (us,s) A\""], ["", "lemma igSwapAbsIPresIGWlsAbsSTR_imp_igSwapAbsIPresIGWlsAbs:\n\"igSwapAbsIPresIGWlsAbsSTR MOD \\<Longrightarrow> igSwapAbsIPresIGWlsAbs MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapAbsIPresIGWlsAbsSTR MOD \\<Longrightarrow>\n    igSwapAbsIPresIGWlsAbs MOD", "unfolding igSwapAbsIPresIGWlsAbsSTR_def igSwapAbsIPresIGWlsAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 us s A.\n       igWlsAbs MOD (us, s) (igSwapAbs MOD zs z1 z2 A) =\n       igWlsAbs MOD (us, s) A \\<Longrightarrow>\n    \\<forall>zs z1 z2 us s A.\n       isInBar (us, s) \\<and> igWlsAbs MOD (us, s) A \\<longrightarrow>\n       igWlsAbs MOD (us, s) (igSwapAbs MOD zs z1 z2 A)", "by simp"], ["", "definition igSwapAllIPresIGWlsAll where\n\"igSwapAllIPresIGWlsAll MOD ==\n igSwapIPresIGWls MOD \\<and> igSwapAbsIPresIGWlsAbs MOD\""], ["", "lemmas igSwapAllIPresIGWlsAll_defs = igSwapAllIPresIGWlsAll_def\nigSwapIPresIGWls_def igSwapAbsIPresIGWlsAbs_def"], ["", "definition igSwapAllIPresIGWlsAllSTR where\n\"igSwapAllIPresIGWlsAllSTR MOD ==\n igSwapIPresIGWlsSTR MOD \\<and> igSwapAbsIPresIGWlsAbsSTR MOD\""], ["", "lemmas igSwapAllIPresIGWlsAllSTR_defs = igSwapAllIPresIGWlsAllSTR_def\nigSwapIPresIGWlsSTR_def igSwapAbsIPresIGWlsAbsSTR_def"], ["", "lemma igSwapAllIPresIGWlsAllSTR_imp_igSwapAllIPresIGWlsAll:\n\"igSwapAllIPresIGWlsAllSTR MOD \\<Longrightarrow> igSwapAllIPresIGWlsAll MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapAllIPresIGWlsAllSTR MOD \\<Longrightarrow>\n    igSwapAllIPresIGWlsAll MOD", "unfolding igSwapAllIPresIGWlsAllSTR_def igSwapAllIPresIGWlsAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIPresIGWlsSTR MOD \\<and>\n    igSwapAbsIPresIGWlsAbsSTR MOD \\<Longrightarrow>\n    igSwapIPresIGWls MOD \\<and> igSwapAbsIPresIGWlsAbs MOD", "using\nigSwapIPresIGWlsSTR_imp_igSwapIPresIGWls\nigSwapAbsIPresIGWlsAbsSTR_imp_igSwapAbsIPresIGWlsAbs"], ["proof (prove)\nusing this:\n  igSwapIPresIGWlsSTR ?MOD \\<Longrightarrow> igSwapIPresIGWls ?MOD\n  igSwapAbsIPresIGWlsAbsSTR ?MOD \\<Longrightarrow>\n  igSwapAbsIPresIGWlsAbs ?MOD\n\ngoal (1 subgoal):\n 1. igSwapIPresIGWlsSTR MOD \\<and>\n    igSwapAbsIPresIGWlsAbsSTR MOD \\<Longrightarrow>\n    igSwapIPresIGWls MOD \\<and> igSwapAbsIPresIGWlsAbs MOD", "by auto"], ["", "text\\<open>``subst\" preserves the domains:\\<close>"], ["", "definition igSubstIPresIGWls where\n\"igSubstIPresIGWls MOD ==\n \\<forall> ys Y y s X. igWls MOD (asSort ys) Y \\<and> igWls MOD s X \\<longrightarrow>\n               igWls MOD s (igSubst MOD ys Y y X)\""], ["", "definition igSubstIPresIGWlsSTR where\n\"igSubstIPresIGWlsSTR MOD ==\n \\<forall> ys Y y s X.\n   igWls MOD s (igSubst MOD ys Y y X) =\n   (igWls MOD (asSort ys) Y \\<and> igWls MOD s X)\""], ["", "lemma igSubstIPresIGWlsSTR_imp_igSubstIPresIGWls:\n\"igSubstIPresIGWlsSTR MOD \\<Longrightarrow> igSubstIPresIGWls MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIPresIGWlsSTR MOD \\<Longrightarrow> igSubstIPresIGWls MOD", "unfolding igSubstIPresIGWlsSTR_def igSubstIPresIGWls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys Y y s X.\n       igWls MOD s (igSubst MOD ys Y y X) =\n       (igWls MOD (asSort ys) Y \\<and> igWls MOD s X) \\<Longrightarrow>\n    \\<forall>ys Y y s X.\n       igWls MOD (asSort ys) Y \\<and> igWls MOD s X \\<longrightarrow>\n       igWls MOD s (igSubst MOD ys Y y X)", "by simp"], ["", "definition igSubstAbsIPresIGWlsAbs where\n\"igSubstAbsIPresIGWlsAbs MOD ==\n \\<forall> ys Y y us s A.\n   isInBar (us,s) \\<and> igWls MOD (asSort ys) Y \\<and> igWlsAbs MOD (us,s) A \\<longrightarrow>\n   igWlsAbs MOD (us,s) (igSubstAbs MOD ys Y y A)\""], ["", "definition igSubstAbsIPresIGWlsAbsSTR where\n\"igSubstAbsIPresIGWlsAbsSTR MOD ==\n \\<forall> ys Y y us s A.\n   igWlsAbs MOD (us,s) (igSubstAbs MOD ys Y y A) =\n   (igWls MOD (asSort ys) Y \\<and> igWlsAbs MOD (us,s) A)\""], ["", "lemma igSubstAbsIPresIGWlsAbsSTR_imp_igSubstAbsIPresIGWlsAbs:\n\"igSubstAbsIPresIGWlsAbsSTR MOD \\<Longrightarrow> igSubstAbsIPresIGWlsAbs MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAbsIPresIGWlsAbsSTR MOD \\<Longrightarrow>\n    igSubstAbsIPresIGWlsAbs MOD", "unfolding igSubstAbsIPresIGWlsAbsSTR_def igSubstAbsIPresIGWlsAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys Y y us s A.\n       igWlsAbs MOD (us, s) (igSubstAbs MOD ys Y y A) =\n       (igWls MOD (asSort ys) Y \\<and>\n        igWlsAbs MOD (us, s) A) \\<Longrightarrow>\n    \\<forall>ys Y y us s A.\n       isInBar (us, s) \\<and>\n       igWls MOD (asSort ys) Y \\<and>\n       igWlsAbs MOD (us, s) A \\<longrightarrow>\n       igWlsAbs MOD (us, s) (igSubstAbs MOD ys Y y A)", "by simp"], ["", "definition igSubstAllIPresIGWlsAll where\n\"igSubstAllIPresIGWlsAll MOD ==\n igSubstIPresIGWls MOD \\<and> igSubstAbsIPresIGWlsAbs MOD\""], ["", "lemmas igSubstAllIPresIGWlsAll_defs = igSubstAllIPresIGWlsAll_def\nigSubstIPresIGWls_def igSubstAbsIPresIGWlsAbs_def"], ["", "definition igSubstAllIPresIGWlsAllSTR where\n\"igSubstAllIPresIGWlsAllSTR MOD ==\n igSubstIPresIGWlsSTR MOD \\<and> igSubstAbsIPresIGWlsAbsSTR MOD\""], ["", "lemmas igSubstAllIPresIGWlsAllSTR_defs = igSubstAllIPresIGWlsAllSTR_def\nigSubstIPresIGWlsSTR_def igSubstAbsIPresIGWlsAbsSTR_def"], ["", "lemma igSubstAllIPresIGWlsAllSTR_imp_igSubstAllIPresIGWlsAll:\n\"igSubstAllIPresIGWlsAllSTR MOD \\<Longrightarrow> igSubstAllIPresIGWlsAll MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAllIPresIGWlsAllSTR MOD \\<Longrightarrow>\n    igSubstAllIPresIGWlsAll MOD", "unfolding igSubstAllIPresIGWlsAllSTR_def igSubstAllIPresIGWlsAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIPresIGWlsSTR MOD \\<and>\n    igSubstAbsIPresIGWlsAbsSTR MOD \\<Longrightarrow>\n    igSubstIPresIGWls MOD \\<and> igSubstAbsIPresIGWlsAbs MOD", "using\nigSubstIPresIGWlsSTR_imp_igSubstIPresIGWls\nigSubstAbsIPresIGWlsAbsSTR_imp_igSubstAbsIPresIGWlsAbs"], ["proof (prove)\nusing this:\n  igSubstIPresIGWlsSTR ?MOD \\<Longrightarrow> igSubstIPresIGWls ?MOD\n  igSubstAbsIPresIGWlsAbsSTR ?MOD \\<Longrightarrow>\n  igSubstAbsIPresIGWlsAbs ?MOD\n\ngoal (1 subgoal):\n 1. igSubstIPresIGWlsSTR MOD \\<and>\n    igSubstAbsIPresIGWlsAbsSTR MOD \\<Longrightarrow>\n    igSubstIPresIGWls MOD \\<and> igSubstAbsIPresIGWlsAbs MOD", "by auto"], ["", "text\\<open>Clauses for fresh: fully conditional versions and less conditional,\nstronger versions (the latter having suffix ``STR\").\\<close>"], ["", "definition igFreshIGVar where\n\"igFreshIGVar MOD ==\n \\<forall> ys y xs x.\n   ys \\<noteq> xs \\<or> y \\<noteq> x \\<longrightarrow>\n   igFresh MOD ys y (igVar MOD xs x)\""], ["", "definition igFreshIGAbs1 where\n\"igFreshIGAbs1 MOD ==\n \\<forall> ys y s X.\n   isInBar (ys,s) \\<and> igWls MOD s X \\<longrightarrow>\n   igFreshAbs MOD ys y (igAbs MOD ys y X)\""], ["", "definition igFreshIGAbs1STR where\n\"igFreshIGAbs1STR MOD ==\n \\<forall> ys y X. igFreshAbs MOD ys y (igAbs MOD ys y X)\""], ["", "lemma igFreshIGAbs1STR_imp_igFreshIGAbs1:\n\"igFreshIGAbs1STR MOD \\<Longrightarrow> igFreshIGAbs1 MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshIGAbs1STR MOD \\<Longrightarrow> igFreshIGAbs1 MOD", "unfolding igFreshIGAbs1STR_def igFreshIGAbs1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y X.\n       igFreshAbs MOD ys y (igAbs MOD ys y X) \\<Longrightarrow>\n    \\<forall>ys y s X.\n       isInBar (ys, s) \\<and> igWls MOD s X \\<longrightarrow>\n       igFreshAbs MOD ys y (igAbs MOD ys y X)", "by simp"], ["", "definition igFreshIGAbs2 where\n\"igFreshIGAbs2 MOD ==\n \\<forall> ys y xs x s X.\n   isInBar (xs,s) \\<and> igWls MOD s X \\<longrightarrow>\n   igFresh MOD ys y X \\<longrightarrow> igFreshAbs MOD ys y (igAbs MOD xs x X)\""], ["", "definition igFreshIGAbs2STR where\n\"igFreshIGAbs2STR MOD ==\n \\<forall> ys y xs x X.\n   igFresh MOD ys y X \\<longrightarrow> igFreshAbs MOD ys y (igAbs MOD xs x X)\""], ["", "lemma igFreshIGAbs2STR_imp_igFreshIGAbs2:\n\"igFreshIGAbs2STR MOD \\<Longrightarrow> igFreshIGAbs2 MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshIGAbs2STR MOD \\<Longrightarrow> igFreshIGAbs2 MOD", "unfolding igFreshIGAbs2STR_def igFreshIGAbs2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y xs x X.\n       igFresh MOD ys y X \\<longrightarrow>\n       igFreshAbs MOD ys y (igAbs MOD xs x X) \\<Longrightarrow>\n    \\<forall>ys y xs x s X.\n       isInBar (xs, s) \\<and> igWls MOD s X \\<longrightarrow>\n       igFresh MOD ys y X \\<longrightarrow>\n       igFreshAbs MOD ys y (igAbs MOD xs x X)", "by simp"], ["", "definition igFreshIGOp where\n\"igFreshIGOp MOD ==\n \\<forall> ys y delta inp binp.\n   igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<longrightarrow>\n   (igFreshInp MOD ys y inp \\<and> igFreshBinp MOD ys y binp) \\<longrightarrow>\n   igFresh MOD ys y (igOp MOD delta inp binp)\""], ["", "definition igFreshIGOpSTR where\n\"igFreshIGOpSTR MOD ==\n \\<forall> ys y delta inp binp.\n   igFreshInp MOD ys y inp \\<and> igFreshBinp MOD ys y binp \\<longrightarrow>\n   igFresh MOD ys y (igOp MOD delta inp binp)\""], ["", "lemma igFreshIGOpSTR_imp_igFreshIGOp:\n\"igFreshIGOpSTR MOD \\<Longrightarrow> igFreshIGOp MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshIGOpSTR MOD \\<Longrightarrow> igFreshIGOp MOD", "unfolding igFreshIGOpSTR_def igFreshIGOp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y delta inp binp.\n       igFreshInp MOD ys y inp \\<and>\n       igFreshBinp MOD ys y binp \\<longrightarrow>\n       igFresh MOD ys y (igOp MOD delta inp binp) \\<Longrightarrow>\n    \\<forall>ys y delta inp binp.\n       igWlsInp MOD delta inp \\<and>\n       igWlsBinp MOD delta binp \\<longrightarrow>\n       igFreshInp MOD ys y inp \\<and>\n       igFreshBinp MOD ys y binp \\<longrightarrow>\n       igFresh MOD ys y (igOp MOD delta inp binp)", "by simp"], ["", "definition igFreshCls where\n\"igFreshCls MOD ==\nigFreshIGVar MOD \\<and>\nigFreshIGAbs1 MOD \\<and> igFreshIGAbs2 MOD \\<and>\nigFreshIGOp MOD\""], ["", "lemmas igFreshCls_defs = igFreshCls_def\nigFreshIGVar_def\nigFreshIGAbs1_def igFreshIGAbs2_def\nigFreshIGOp_def"], ["", "definition igFreshClsSTR where\n\"igFreshClsSTR MOD ==\nigFreshIGVar MOD \\<and>\nigFreshIGAbs1STR MOD \\<and> igFreshIGAbs2STR MOD \\<and>\nigFreshIGOpSTR MOD\""], ["", "lemmas igFreshClsSTR_defs = igFreshClsSTR_def\nigFreshIGVar_def\nigFreshIGAbs1STR_def igFreshIGAbs2STR_def\nigFreshIGOpSTR_def"], ["", "lemma igFreshClsSTR_imp_igFreshCls:\n\"igFreshClsSTR MOD \\<Longrightarrow> igFreshCls MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshClsSTR MOD \\<Longrightarrow> igFreshCls MOD", "unfolding igFreshClsSTR_def igFreshCls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshIGVar MOD \\<and>\n    igFreshIGAbs1STR MOD \\<and>\n    igFreshIGAbs2STR MOD \\<and> igFreshIGOpSTR MOD \\<Longrightarrow>\n    igFreshIGVar MOD \\<and>\n    igFreshIGAbs1 MOD \\<and> igFreshIGAbs2 MOD \\<and> igFreshIGOp MOD", "using\nigFreshIGAbs1STR_imp_igFreshIGAbs1 igFreshIGAbs2STR_imp_igFreshIGAbs2\nigFreshIGOpSTR_imp_igFreshIGOp"], ["proof (prove)\nusing this:\n  igFreshIGAbs1STR ?MOD \\<Longrightarrow> igFreshIGAbs1 ?MOD\n  igFreshIGAbs2STR ?MOD \\<Longrightarrow> igFreshIGAbs2 ?MOD\n  igFreshIGOpSTR ?MOD \\<Longrightarrow> igFreshIGOp ?MOD\n\ngoal (1 subgoal):\n 1. igFreshIGVar MOD \\<and>\n    igFreshIGAbs1STR MOD \\<and>\n    igFreshIGAbs2STR MOD \\<and> igFreshIGOpSTR MOD \\<Longrightarrow>\n    igFreshIGVar MOD \\<and>\n    igFreshIGAbs1 MOD \\<and> igFreshIGAbs2 MOD \\<and> igFreshIGOp MOD", "by auto"], ["", "(* Clauses for swap: fully-conditional versions and less-conditional,\nstronger versions (suffix ``STR\") *)"], ["", "definition igSwapIGVar where\n\"igSwapIGVar MOD ==\n \\<forall> zs z1 z2 xs x.\n   igSwap MOD zs z1 z2 (igVar MOD xs x) = igVar MOD xs (x @xs[z1 \\<and> z2]_zs)\""], ["", "definition igSwapIGAbs where\n\"igSwapIGAbs MOD ==\n \\<forall>  zs z1 z2 xs x s X.\n   isInBar (xs,s) \\<and> igWls MOD s X \\<longrightarrow>\n   igSwapAbs MOD zs z1 z2 (igAbs MOD xs x X) =\n   igAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (igSwap MOD zs z1 z2 X)\""], ["", "definition igSwapIGAbsSTR where\n\"igSwapIGAbsSTR MOD ==\n \\<forall>  zs z1 z2 xs x X.\n   igSwapAbs MOD zs z1 z2 (igAbs MOD xs x X) =\n   igAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (igSwap MOD zs z1 z2 X)\""], ["", "lemma igSwapIGAbsSTR_imp_igSwapIGAbs:\n\"igSwapIGAbsSTR MOD \\<Longrightarrow> igSwapIGAbs MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIGAbsSTR MOD \\<Longrightarrow> igSwapIGAbs MOD", "unfolding igSwapIGAbsSTR_def igSwapIGAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 xs x X.\n       igSwapAbs MOD zs z1 z2 (igAbs MOD xs x X) =\n       igAbs MOD xs (x @xs[z1 \\<and> z2]_zs)\n        (igSwap MOD zs z1 z2 X) \\<Longrightarrow>\n    \\<forall>zs z1 z2 xs x s X.\n       isInBar (xs, s) \\<and> igWls MOD s X \\<longrightarrow>\n       igSwapAbs MOD zs z1 z2 (igAbs MOD xs x X) =\n       igAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (igSwap MOD zs z1 z2 X)", "by simp"], ["", "definition igSwapIGOp where\n\"igSwapIGOp MOD ==\n \\<forall>  zs z1 z2 delta inp binp.\n   igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<longrightarrow>\n   igSwap MOD zs z1 z2 (igOp MOD delta inp binp) =\n   igOp MOD delta (igSwapInp MOD zs z1 z2 inp) (igSwapBinp MOD zs z1 z2 binp)\""], ["", "definition igSwapIGOpSTR where\n\"igSwapIGOpSTR MOD ==\n \\<forall>  zs z1 z2 delta inp binp.\n   igSwap MOD zs z1 z2 (igOp MOD delta inp binp) =\n   igOp MOD delta (igSwapInp MOD zs z1 z2 inp) (igSwapBinp MOD zs z1 z2 binp)\""], ["", "lemma igSwapIGOpSTR_imp_igSwapIGOp:\n\"igSwapIGOpSTR MOD \\<Longrightarrow> igSwapIGOp MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIGOpSTR MOD \\<Longrightarrow> igSwapIGOp MOD", "unfolding igSwapIGOpSTR_def igSwapIGOp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 delta inp binp.\n       igSwap MOD zs z1 z2 (igOp MOD delta inp binp) =\n       igOp MOD delta (igSwapInp MOD zs z1 z2 inp)\n        (igSwapBinp MOD zs z1 z2 binp) \\<Longrightarrow>\n    \\<forall>zs z1 z2 delta inp binp.\n       igWlsInp MOD delta inp \\<and>\n       igWlsBinp MOD delta binp \\<longrightarrow>\n       igSwap MOD zs z1 z2 (igOp MOD delta inp binp) =\n       igOp MOD delta (igSwapInp MOD zs z1 z2 inp)\n        (igSwapBinp MOD zs z1 z2 binp)", "by simp"], ["", "definition igSwapCls where\n\"igSwapCls MOD ==\nigSwapIGVar MOD \\<and>\nigSwapIGAbs MOD \\<and>\nigSwapIGOp MOD\""], ["", "lemmas igSwapCls_defs = igSwapCls_def\nigSwapIGVar_def\nigSwapIGAbs_def\nigSwapIGOp_def"], ["", "definition igSwapClsSTR where\n\"igSwapClsSTR MOD ==\nigSwapIGVar MOD \\<and>\nigSwapIGAbsSTR MOD \\<and>\nigSwapIGOpSTR MOD\""], ["", "lemmas igSwapClsSTR_defs = igSwapClsSTR_def\nigSwapIGVar_def\nigSwapIGAbsSTR_def\nigSwapIGOpSTR_def"], ["", "lemma igSwapClsSTR_imp_igSwapCls:\n\"igSwapClsSTR MOD \\<Longrightarrow> igSwapCls MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapClsSTR MOD \\<Longrightarrow> igSwapCls MOD", "unfolding igSwapClsSTR_def igSwapCls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIGVar MOD \\<and>\n    igSwapIGAbsSTR MOD \\<and> igSwapIGOpSTR MOD \\<Longrightarrow>\n    igSwapIGVar MOD \\<and> igSwapIGAbs MOD \\<and> igSwapIGOp MOD", "using\nigSwapIGAbsSTR_imp_igSwapIGAbs\nigSwapIGOpSTR_imp_igSwapIGOp"], ["proof (prove)\nusing this:\n  igSwapIGAbsSTR ?MOD \\<Longrightarrow> igSwapIGAbs ?MOD\n  igSwapIGOpSTR ?MOD \\<Longrightarrow> igSwapIGOp ?MOD\n\ngoal (1 subgoal):\n 1. igSwapIGVar MOD \\<and>\n    igSwapIGAbsSTR MOD \\<and> igSwapIGOpSTR MOD \\<Longrightarrow>\n    igSwapIGVar MOD \\<and> igSwapIGAbs MOD \\<and> igSwapIGOp MOD", "by auto"], ["", "(* Clauses for subst: fully-conditional versions and less-conditional,\nstronger versions (suffix ``STR\") *)"], ["", "definition igSubstIGVar1 where\n\"igSubstIGVar1 MOD ==\n \\<forall> ys y Y xs x.\n   igWls MOD (asSort ys) Y \\<longrightarrow>\n   (ys \\<noteq> xs \\<or> y \\<noteq> x) \\<longrightarrow>\n   igSubst MOD ys Y y (igVar MOD xs x) = igVar MOD xs x\""], ["", "definition igSubstIGVar1STR where\n\"igSubstIGVar1STR MOD ==\n (\\<forall> ys y y1 xs x.\n    (ys \\<noteq> xs \\<or> x \\<noteq> y) \\<longrightarrow>\n    igSubst MOD ys (igVar MOD ys y1) y (igVar MOD xs x) = igVar MOD xs x)\n \\<and>\n (\\<forall> ys y Y xs x.\n    igWls MOD (asSort ys) Y \\<longrightarrow>\n    (ys \\<noteq> xs \\<or> y \\<noteq> x) \\<longrightarrow>\n    igSubst MOD ys Y y (igVar MOD xs x) = igVar MOD xs x)\""], ["", "lemma igSubstIGVar1STR_imp_igSubstIGVar1:\n\"igSubstIGVar1STR MOD \\<Longrightarrow> igSubstIGVar1 MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGVar1STR MOD \\<Longrightarrow> igSubstIGVar1 MOD", "unfolding igSubstIGVar1STR_def igSubstIGVar1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>ys y y1 xs x.\n        ys \\<noteq> xs \\<or> x \\<noteq> y \\<longrightarrow>\n        igSubst MOD ys (igVar MOD ys y1) y (igVar MOD xs x) =\n        igVar MOD xs x) \\<and>\n    (\\<forall>ys y Y xs x.\n        igWls MOD (asSort ys) Y \\<longrightarrow>\n        ys \\<noteq> xs \\<or> y \\<noteq> x \\<longrightarrow>\n        igSubst MOD ys Y y (igVar MOD xs x) =\n        igVar MOD xs x) \\<Longrightarrow>\n    \\<forall>ys y Y xs x.\n       igWls MOD (asSort ys) Y \\<longrightarrow>\n       ys \\<noteq> xs \\<or> y \\<noteq> x \\<longrightarrow>\n       igSubst MOD ys Y y (igVar MOD xs x) = igVar MOD xs x", "by simp"], ["", "definition igSubstIGVar2 where\n\"igSubstIGVar2 MOD ==\n \\<forall> ys y Y.\n   igWls MOD (asSort ys) Y \\<longrightarrow>\n   igSubst MOD ys Y y (igVar MOD ys y) = Y\""], ["", "definition igSubstIGVar2STR where\n\"igSubstIGVar2STR MOD ==\n (\\<forall> ys y y1.\n    igSubst MOD ys (igVar MOD ys y1) y (igVar MOD ys y) = igVar MOD ys y1)\n \\<and>\n (\\<forall> ys y Y.\n    igWls MOD (asSort ys) Y \\<longrightarrow>\n    igSubst MOD ys Y y (igVar MOD ys y) = Y)\""], ["", "lemma igSubstIGVar2STR_imp_igSubstIGVar2:\n\"igSubstIGVar2STR MOD \\<Longrightarrow> igSubstIGVar2 MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGVar2STR MOD \\<Longrightarrow> igSubstIGVar2 MOD", "unfolding igSubstIGVar2STR_def igSubstIGVar2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>ys y y1.\n        igSubst MOD ys (igVar MOD ys y1) y (igVar MOD ys y) =\n        igVar MOD ys y1) \\<and>\n    (\\<forall>ys y Y.\n        igWls MOD (asSort ys) Y \\<longrightarrow>\n        igSubst MOD ys Y y (igVar MOD ys y) = Y) \\<Longrightarrow>\n    \\<forall>ys y Y.\n       igWls MOD (asSort ys) Y \\<longrightarrow>\n       igSubst MOD ys Y y (igVar MOD ys y) = Y", "by simp"], ["", "definition igSubstIGAbs where\n\"igSubstIGAbs MOD ==\n \\<forall> ys y Y xs x s X.\n   isInBar (xs,s) \\<and> igWls MOD (asSort ys) Y \\<and> igWls MOD s X \\<longrightarrow>\n   (xs \\<noteq> ys \\<or> x \\<noteq> y) \\<and> igFresh MOD xs x Y \\<longrightarrow>\n   igSubstAbs MOD ys Y y (igAbs MOD xs x X) =\n   igAbs MOD xs x (igSubst MOD ys Y y X)\""], ["", "definition igSubstIGAbsSTR where\n\"igSubstIGAbsSTR MOD ==\n \\<forall> ys y Y xs x X.\n   (xs \\<noteq> ys \\<or> x \\<noteq> y) \\<and> igFresh MOD xs x Y \\<longrightarrow>\n   igSubstAbs MOD ys Y y (igAbs MOD xs x X) =\n   igAbs MOD xs x (igSubst MOD ys Y y X)\""], ["", "lemma igSubstIGAbsSTR_imp_igSubstIGAbs:\n\"igSubstIGAbsSTR MOD \\<Longrightarrow> igSubstIGAbs MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGAbsSTR MOD \\<Longrightarrow> igSubstIGAbs MOD", "unfolding igSubstIGAbsSTR_def igSubstIGAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y Y xs x X.\n       (xs \\<noteq> ys \\<or> x \\<noteq> y) \\<and>\n       igFresh MOD xs x Y \\<longrightarrow>\n       igSubstAbs MOD ys Y y (igAbs MOD xs x X) =\n       igAbs MOD xs x (igSubst MOD ys Y y X) \\<Longrightarrow>\n    \\<forall>ys y Y xs x s X.\n       isInBar (xs, s) \\<and>\n       igWls MOD (asSort ys) Y \\<and> igWls MOD s X \\<longrightarrow>\n       (xs \\<noteq> ys \\<or> x \\<noteq> y) \\<and>\n       igFresh MOD xs x Y \\<longrightarrow>\n       igSubstAbs MOD ys Y y (igAbs MOD xs x X) =\n       igAbs MOD xs x (igSubst MOD ys Y y X)", "by simp"], ["", "definition igSubstIGOp where\n\"igSubstIGOp MOD ==\n \\<forall> ys y Y delta inp binp.\n   igWls MOD (asSort ys) Y \\<and>\n   igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<longrightarrow>\n   igSubst MOD ys Y y (igOp MOD delta inp binp) =\n   igOp MOD delta (igSubstInp MOD ys Y y inp) (igSubstBinp MOD ys Y y binp)\""], ["", "definition igSubstIGOpSTR where\n\"igSubstIGOpSTR MOD ==\n (\\<forall> ys y y1 delta inp binp.\n    igSubst MOD ys (igVar MOD ys y1) y (igOp MOD delta inp binp) =\n    igOp MOD delta (igSubstInp MOD ys (igVar MOD ys y1) y inp)\n                  (igSubstBinp MOD ys (igVar MOD ys y1) y binp))\n \\<and>\n (\\<forall> ys y Y delta inp binp.\n    igWls MOD (asSort ys) Y \\<longrightarrow>\n    igSubst MOD ys Y y (igOp MOD delta inp binp) =\n    igOp MOD delta (igSubstInp MOD ys Y y inp) (igSubstBinp MOD ys Y y binp))\""], ["", "lemma igSubstIGOpSTR_imp_igSubstIGOp:\n\"igSubstIGOpSTR MOD \\<Longrightarrow> igSubstIGOp MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGOpSTR MOD \\<Longrightarrow> igSubstIGOp MOD", "unfolding igSubstIGOpSTR_def igSubstIGOp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>ys y y1 delta inp binp.\n        igSubst MOD ys (igVar MOD ys y1) y (igOp MOD delta inp binp) =\n        igOp MOD delta (igSubstInp MOD ys (igVar MOD ys y1) y inp)\n         (igSubstBinp MOD ys (igVar MOD ys y1) y binp)) \\<and>\n    (\\<forall>ys y Y delta inp binp.\n        igWls MOD (asSort ys) Y \\<longrightarrow>\n        igSubst MOD ys Y y (igOp MOD delta inp binp) =\n        igOp MOD delta (igSubstInp MOD ys Y y inp)\n         (igSubstBinp MOD ys Y y binp)) \\<Longrightarrow>\n    \\<forall>ys y Y delta inp binp.\n       igWls MOD (asSort ys) Y \\<and>\n       igWlsInp MOD delta inp \\<and>\n       igWlsBinp MOD delta binp \\<longrightarrow>\n       igSubst MOD ys Y y (igOp MOD delta inp binp) =\n       igOp MOD delta (igSubstInp MOD ys Y y inp)\n        (igSubstBinp MOD ys Y y binp)", "by simp"], ["", "definition igSubstCls where\n\"igSubstCls MOD ==\n igSubstIGVar1 MOD \\<and> igSubstIGVar2 MOD \\<and>\n igSubstIGAbs MOD \\<and>\n igSubstIGOp MOD\""], ["", "lemmas igSubstCls_defs = igSubstCls_def\nigSubstIGVar1_def igSubstIGVar2_def\nigSubstIGAbs_def\nigSubstIGOp_def"], ["", "definition igSubstClsSTR where\n\"igSubstClsSTR MOD ==\n igSubstIGVar1STR MOD \\<and> igSubstIGVar2STR MOD \\<and>\n igSubstIGAbsSTR MOD \\<and>\n igSubstIGOpSTR MOD\""], ["", "lemmas igSubstClsSTR_defs = igSubstClsSTR_def\nigSubstIGVar1STR_def igSubstIGVar2STR_def\nigSubstIGAbsSTR_def\nigSubstIGOpSTR_def"], ["", "lemma igSubstClsSTR_imp_igSubstCls:\n\"igSubstClsSTR MOD \\<Longrightarrow> igSubstCls MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstClsSTR MOD \\<Longrightarrow> igSubstCls MOD", "unfolding igSubstClsSTR_def igSubstCls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGVar1STR MOD \\<and>\n    igSubstIGVar2STR MOD \\<and>\n    igSubstIGAbsSTR MOD \\<and> igSubstIGOpSTR MOD \\<Longrightarrow>\n    igSubstIGVar1 MOD \\<and>\n    igSubstIGVar2 MOD \\<and> igSubstIGAbs MOD \\<and> igSubstIGOp MOD", "using\nigSubstIGVar1STR_imp_igSubstIGVar1\nigSubstIGVar2STR_imp_igSubstIGVar2\nigSubstIGAbsSTR_imp_igSubstIGAbs\nigSubstIGOpSTR_imp_igSubstIGOp"], ["proof (prove)\nusing this:\n  igSubstIGVar1STR ?MOD \\<Longrightarrow> igSubstIGVar1 ?MOD\n  igSubstIGVar2STR ?MOD \\<Longrightarrow> igSubstIGVar2 ?MOD\n  igSubstIGAbsSTR ?MOD \\<Longrightarrow> igSubstIGAbs ?MOD\n  igSubstIGOpSTR ?MOD \\<Longrightarrow> igSubstIGOp ?MOD\n\ngoal (1 subgoal):\n 1. igSubstIGVar1STR MOD \\<and>\n    igSubstIGVar2STR MOD \\<and>\n    igSubstIGAbsSTR MOD \\<and> igSubstIGOpSTR MOD \\<Longrightarrow>\n    igSubstIGVar1 MOD \\<and>\n    igSubstIGVar2 MOD \\<and> igSubstIGAbs MOD \\<and> igSubstIGOp MOD", "by auto"], ["", "(* Freshness-based congruences for abstractions: *)\n\n(* ... employing swap: *)"], ["", "definition igAbsCongS where\n\"igAbsCongS MOD ==\n \\<forall> xs x x' y s X X'.\n   isInBar (xs,s) \\<and> igWls MOD s X \\<and> igWls MOD s X' \\<longrightarrow>\n   igFresh MOD xs y X \\<and> igFresh MOD xs y X' \\<and> igSwap MOD xs y x X = igSwap MOD xs y x' X' \\<longrightarrow>\n   igAbs MOD xs x X = igAbs MOD xs x' X'\""], ["", "definition igAbsCongSSTR where\n\"igAbsCongSSTR MOD ==\n \\<forall> xs x x' y X X'.\n   igFresh MOD xs y X \\<and> igFresh MOD xs y X' \\<and> igSwap MOD xs y x X = igSwap MOD xs y x' X' \\<longrightarrow>\n   igAbs MOD xs x X = igAbs MOD xs x' X'\""], ["", "lemma igAbsCongSSTR_imp_igAbsCongS:\n\"igAbsCongSSTR MOD \\<Longrightarrow> igAbsCongS MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbsCongSSTR MOD \\<Longrightarrow> igAbsCongS MOD", "unfolding igAbsCongSSTR_def igAbsCongS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs x x' y X X'.\n       igFresh MOD xs y X \\<and>\n       igFresh MOD xs y X' \\<and>\n       igSwap MOD xs y x X = igSwap MOD xs y x' X' \\<longrightarrow>\n       igAbs MOD xs x X = igAbs MOD xs x' X' \\<Longrightarrow>\n    \\<forall>xs x x' y s X X'.\n       isInBar (xs, s) \\<and>\n       igWls MOD s X \\<and> igWls MOD s X' \\<longrightarrow>\n       igFresh MOD xs y X \\<and>\n       igFresh MOD xs y X' \\<and>\n       igSwap MOD xs y x X = igSwap MOD xs y x' X' \\<longrightarrow>\n       igAbs MOD xs x X = igAbs MOD xs x' X'", "by auto"], ["", "(* ... employing subst: *)"], ["", "definition igAbsCongU where\n\"igAbsCongU MOD ==\n \\<forall> xs x x' y s X X'.\n   isInBar (xs,s) \\<and> igWls MOD s X \\<and> igWls MOD s X' \\<longrightarrow>\n   igFresh MOD xs y X \\<and> igFresh MOD xs y X' \\<and>\n   igSubst MOD xs (igVar MOD xs y) x X = igSubst MOD xs (igVar MOD xs y) x' X' \\<longrightarrow>\n   igAbs MOD xs x X = igAbs MOD xs x' X'\""], ["", "definition igAbsCongUSTR where\n\"igAbsCongUSTR MOD ==\n \\<forall> xs x x' y X X'.\n   igFresh MOD xs y X \\<and> igFresh MOD xs y X' \\<and>\n   igSubst MOD xs (igVar MOD xs y) x X = igSubst MOD xs (igVar MOD xs y) x' X' \\<longrightarrow>\n   igAbs MOD xs x X = igAbs MOD xs x' X'\""], ["", "lemma igAbsCongUSTR_imp_igAbsCongU:\n\"igAbsCongUSTR MOD \\<Longrightarrow> igAbsCongU MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbsCongUSTR MOD \\<Longrightarrow> igAbsCongU MOD", "unfolding igAbsCongUSTR_def igAbsCongU_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs x x' y X X'.\n       igFresh MOD xs y X \\<and>\n       igFresh MOD xs y X' \\<and>\n       igSubst MOD xs (igVar MOD xs y) x X =\n       igSubst MOD xs (igVar MOD xs y) x' X' \\<longrightarrow>\n       igAbs MOD xs x X = igAbs MOD xs x' X' \\<Longrightarrow>\n    \\<forall>xs x x' y s X X'.\n       isInBar (xs, s) \\<and>\n       igWls MOD s X \\<and> igWls MOD s X' \\<longrightarrow>\n       igFresh MOD xs y X \\<and>\n       igFresh MOD xs y X' \\<and>\n       igSubst MOD xs (igVar MOD xs y) x X =\n       igSubst MOD xs (igVar MOD xs y) x' X' \\<longrightarrow>\n       igAbs MOD xs x X = igAbs MOD xs x' X'", "by auto"], ["", "(* (Subst-based) renaming of the bound variable in abstractions (``abstraction renaming\", for short): *)"], ["", "definition igAbsRen where\n\"igAbsRen MOD ==\n \\<forall> xs y x s X.\n    isInBar (xs,s) \\<and> igWls MOD s X \\<longrightarrow>\n    igFresh MOD xs y X \\<longrightarrow>\n    igAbs MOD xs y (igSubst MOD xs (igVar MOD xs y) x X) = igAbs MOD xs x X\""], ["", "definition igAbsRenSTR where\n\"igAbsRenSTR MOD ==\n \\<forall> xs y x X.\n   igFresh MOD xs y X \\<longrightarrow>\n   igAbs MOD xs y (igSubst MOD xs (igVar MOD xs y) x X) = igAbs MOD xs x X\""], ["", "lemma igAbsRenSTR_imp_igAbsRen:\n\"igAbsRenSTR MOD \\<Longrightarrow> igAbsRen MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbsRenSTR MOD \\<Longrightarrow> igAbsRen MOD", "unfolding igAbsRenSTR_def igAbsRen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs y x X.\n       igFresh MOD xs y X \\<longrightarrow>\n       igAbs MOD xs y (igSubst MOD xs (igVar MOD xs y) x X) =\n       igAbs MOD xs x X \\<Longrightarrow>\n    \\<forall>xs y x s X.\n       isInBar (xs, s) \\<and> igWls MOD s X \\<longrightarrow>\n       igFresh MOD xs y X \\<longrightarrow>\n       igAbs MOD xs y (igSubst MOD xs (igVar MOD xs y) x X) =\n       igAbs MOD xs x X", "by simp"], ["", "(* igAbsRenSTR is stronger than igAbsCongUSTR: *)"], ["", "lemma igAbsRenSTR_imp_igAbsCongUSTR:\n\"igAbsRenSTR MOD \\<Longrightarrow> igAbsCongUSTR MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbsRenSTR MOD \\<Longrightarrow> igAbsCongUSTR MOD", "unfolding igAbsCongUSTR_def igAbsRenSTR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs y x X.\n       igFresh MOD xs y X \\<longrightarrow>\n       igAbs MOD xs y (igSubst MOD xs (igVar MOD xs y) x X) =\n       igAbs MOD xs x X \\<Longrightarrow>\n    \\<forall>xs x x' y X X'.\n       igFresh MOD xs y X \\<and>\n       igFresh MOD xs y X' \\<and>\n       igSubst MOD xs (igVar MOD xs y) x X =\n       igSubst MOD xs (igVar MOD xs y) x' X' \\<longrightarrow>\n       igAbs MOD xs x X = igAbs MOD xs x' X'", "by metis"], ["", "text \\<open>Well-sorted fresh-swap models:\\<close>"], ["", "definition iwlsFSw where\n\"iwlsFSw MOD ==\n igWlsAllDisj MOD \\<and> igWlsAbsIsInBar MOD \\<and>\n igConsIPresIGWls MOD \\<and> igSwapAllIPresIGWlsAll MOD \\<and>\n igFreshCls MOD \\<and> igSwapCls MOD \\<and> igAbsCongS MOD\""], ["", "lemmas iwlsFSw_defs1 = iwlsFSw_def\nigWlsAllDisj_def igWlsAbsIsInBar_def\nigConsIPresIGWls_def igSwapAllIPresIGWlsAll_def\nigFreshCls_def igSwapCls_def igAbsCongS_def"], ["", "lemmas iwlsFSw_defs = iwlsFSw_def\nigWlsAllDisj_defs igWlsAbsIsInBar_def\nigConsIPresIGWls_defs igSwapAllIPresIGWlsAll_defs\nigFreshCls_defs igSwapCls_defs igAbsCongS_def"], ["", "definition iwlsFSwSTR where\n\"iwlsFSwSTR MOD ==\n igWlsAllDisj MOD \\<and> igWlsAbsIsInBar MOD \\<and>\n igConsIPresIGWlsSTR MOD \\<and> igSwapAllIPresIGWlsAllSTR MOD \\<and>\n igFreshClsSTR MOD \\<and> igSwapClsSTR MOD \\<and> igAbsCongSSTR MOD\""], ["", "lemmas iwlsFSwSTR_defs1 = iwlsFSwSTR_def\nigWlsAllDisj_def igWlsAbsIsInBar_def\nigConsIPresIGWlsSTR_def igSwapAllIPresIGWlsAllSTR_def\nigFreshClsSTR_def igSwapClsSTR_def igAbsCongSSTR_def"], ["", "lemmas iwlsFSwSTR_defs = iwlsFSwSTR_def\nigWlsAllDisj_defs igWlsAbsIsInBar_def\nigConsIPresIGWlsSTR_defs igSwapAllIPresIGWlsAllSTR_defs\nigFreshClsSTR_defs igSwapClsSTR_defs igAbsCongSSTR_def"], ["", "lemma iwlsFSwSTR_imp_iwlsFSw:\n\"iwlsFSwSTR MOD \\<Longrightarrow> iwlsFSw MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSwSTR MOD \\<Longrightarrow> iwlsFSw MOD", "unfolding iwlsFSwSTR_def iwlsFSw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAllDisj MOD \\<and>\n    igWlsAbsIsInBar MOD \\<and>\n    igConsIPresIGWlsSTR MOD \\<and>\n    igSwapAllIPresIGWlsAllSTR MOD \\<and>\n    igFreshClsSTR MOD \\<and>\n    igSwapClsSTR MOD \\<and> igAbsCongSSTR MOD \\<Longrightarrow>\n    igWlsAllDisj MOD \\<and>\n    igWlsAbsIsInBar MOD \\<and>\n    igConsIPresIGWls MOD \\<and>\n    igSwapAllIPresIGWlsAll MOD \\<and>\n    igFreshCls MOD \\<and> igSwapCls MOD \\<and> igAbsCongS MOD", "using\nigConsIPresIGWlsSTR_imp_igConsIPresIGWls\nigSwapAllIPresIGWlsAllSTR_imp_igSwapAllIPresIGWlsAll\nigFreshClsSTR_imp_igFreshCls\nigSwapClsSTR_imp_igSwapCls\nigAbsCongSSTR_imp_igAbsCongS"], ["proof (prove)\nusing this:\n  igConsIPresIGWlsSTR ?MOD \\<Longrightarrow> igConsIPresIGWls ?MOD\n  igSwapAllIPresIGWlsAllSTR ?MOD \\<Longrightarrow>\n  igSwapAllIPresIGWlsAll ?MOD\n  igFreshClsSTR ?MOD \\<Longrightarrow> igFreshCls ?MOD\n  igSwapClsSTR ?MOD \\<Longrightarrow> igSwapCls ?MOD\n  igAbsCongSSTR ?MOD \\<Longrightarrow> igAbsCongS ?MOD\n\ngoal (1 subgoal):\n 1. igWlsAllDisj MOD \\<and>\n    igWlsAbsIsInBar MOD \\<and>\n    igConsIPresIGWlsSTR MOD \\<and>\n    igSwapAllIPresIGWlsAllSTR MOD \\<and>\n    igFreshClsSTR MOD \\<and>\n    igSwapClsSTR MOD \\<and> igAbsCongSSTR MOD \\<Longrightarrow>\n    igWlsAllDisj MOD \\<and>\n    igWlsAbsIsInBar MOD \\<and>\n    igConsIPresIGWls MOD \\<and>\n    igSwapAllIPresIGWlsAll MOD \\<and>\n    igFreshCls MOD \\<and> igSwapCls MOD \\<and> igAbsCongS MOD", "by auto"], ["", "text \\<open>Well-sorted fresh-subst models:\\<close>"], ["", "definition iwlsFSb where\n\"iwlsFSb MOD ==\n igWlsAllDisj MOD \\<and> igWlsAbsIsInBar MOD \\<and>\n igConsIPresIGWls MOD \\<and> igSubstAllIPresIGWlsAll MOD \\<and>\n igFreshCls MOD \\<and> igSubstCls MOD \\<and> igAbsRen MOD\""], ["", "lemmas iwlsFSb_defs1 = iwlsFSb_def\nigWlsAllDisj_def igWlsAbsIsInBar_def\nigConsIPresIGWls_def igSubstAllIPresIGWlsAll_def\nigFreshCls_def igSubstCls_def igAbsRen_def"], ["", "lemmas iwlsFSb_defs = iwlsFSb_def\nigWlsAllDisj_defs igWlsAbsIsInBar_def\nigConsIPresIGWls_defs igSubstAllIPresIGWlsAll_defs\nigFreshCls_defs igSubstCls_defs igAbsRen_def"], ["", "definition iwlsFSbSwTR where\n\"iwlsFSbSwTR MOD ==\n igWlsAllDisj MOD \\<and> igWlsAbsIsInBar MOD \\<and>\n igConsIPresIGWlsSTR MOD \\<and> igSubstAllIPresIGWlsAllSTR MOD \\<and>\n igFreshClsSTR MOD \\<and> igSubstClsSTR MOD \\<and> igAbsRenSTR MOD\""], ["", "lemmas wlsFSbSwSTR_defs1 = iwlsFSbSwTR_def\nigWlsAllDisj_def igWlsAbsIsInBar_def\nigConsIPresIGWlsSTR_def igSwapAllIPresIGWlsAllSTR_def\nigFreshClsSTR_def igSwapClsSTR_def igAbsRenSTR_def"], ["", "lemmas iwlsFSbSwTR_defs = iwlsFSbSwTR_def\nigWlsAllDisj_defs igWlsAbsIsInBar_def\nigConsIPresIGWlsSTR_defs igSwapAllIPresIGWlsAllSTR_defs\nigFreshClsSTR_defs igSwapClsSTR_defs igAbsRenSTR_def"], ["", "lemma iwlsFSbSwTR_imp_iwlsFSb:\n\"iwlsFSbSwTR MOD \\<Longrightarrow> iwlsFSb MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSbSwTR MOD \\<Longrightarrow> iwlsFSb MOD", "unfolding iwlsFSbSwTR_def iwlsFSb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAllDisj MOD \\<and>\n    igWlsAbsIsInBar MOD \\<and>\n    igConsIPresIGWlsSTR MOD \\<and>\n    igSubstAllIPresIGWlsAllSTR MOD \\<and>\n    igFreshClsSTR MOD \\<and>\n    igSubstClsSTR MOD \\<and> igAbsRenSTR MOD \\<Longrightarrow>\n    igWlsAllDisj MOD \\<and>\n    igWlsAbsIsInBar MOD \\<and>\n    igConsIPresIGWls MOD \\<and>\n    igSubstAllIPresIGWlsAll MOD \\<and>\n    igFreshCls MOD \\<and> igSubstCls MOD \\<and> igAbsRen MOD", "using\nigConsIPresIGWlsSTR_imp_igConsIPresIGWls\nigSubstAllIPresIGWlsAllSTR_imp_igSubstAllIPresIGWlsAll\nigFreshClsSTR_imp_igFreshCls\nigSubstClsSTR_imp_igSubstCls\nigAbsRenSTR_imp_igAbsRen"], ["proof (prove)\nusing this:\n  igConsIPresIGWlsSTR ?MOD \\<Longrightarrow> igConsIPresIGWls ?MOD\n  igSubstAllIPresIGWlsAllSTR ?MOD \\<Longrightarrow>\n  igSubstAllIPresIGWlsAll ?MOD\n  igFreshClsSTR ?MOD \\<Longrightarrow> igFreshCls ?MOD\n  igSubstClsSTR ?MOD \\<Longrightarrow> igSubstCls ?MOD\n  igAbsRenSTR ?MOD \\<Longrightarrow> igAbsRen ?MOD\n\ngoal (1 subgoal):\n 1. igWlsAllDisj MOD \\<and>\n    igWlsAbsIsInBar MOD \\<and>\n    igConsIPresIGWlsSTR MOD \\<and>\n    igSubstAllIPresIGWlsAllSTR MOD \\<and>\n    igFreshClsSTR MOD \\<and>\n    igSubstClsSTR MOD \\<and> igAbsRenSTR MOD \\<Longrightarrow>\n    igWlsAllDisj MOD \\<and>\n    igWlsAbsIsInBar MOD \\<and>\n    igConsIPresIGWls MOD \\<and>\n    igSubstAllIPresIGWlsAll MOD \\<and>\n    igFreshCls MOD \\<and> igSubstCls MOD \\<and> igAbsRen MOD", "by auto"], ["", "text \\<open>Well-sorted fresh-swap-subst-models\\<close>"], ["", "(* \"strong\" versions not required for this kind of models *)"], ["", "definition iwlsFSwSb where\n\"iwlsFSwSb MOD ==\n iwlsFSw MOD \\<and> igSubstAllIPresIGWlsAll MOD \\<and> igSubstCls MOD\""], ["", "lemmas iwlsFSwSb_defs1 = iwlsFSwSb_def\niwlsFSw_def igSubstAllIPresIGWlsAll_def igSubstCls_def"], ["", "lemmas iwlsFSwSb_defs = iwlsFSwSb_def\niwlsFSw_def igSubstAllIPresIGWlsAll_defs igSubstCls_defs"], ["", "text \\<open>Well-sorted fresh-subst-swap-models\\<close>"], ["", "(* \"strong\" versions not required for this kind of models *)"], ["", "definition iwlsFSbSw where\n\"iwlsFSbSw MOD ==\n iwlsFSb MOD \\<and> igSwapAllIPresIGWlsAll MOD \\<and> igSwapCls MOD\""], ["", "lemmas iwlsFSbSw_defs1 = iwlsFSbSw_def\niwlsFSw_def igSwapAllIPresIGWlsAll_def igSwapCls_def"], ["", "lemmas iwlsFSbSw_defs = iwlsFSbSw_def\niwlsFSw_def igSwapAllIPresIGWlsAll_defs igSwapCls_defs"], ["", "text\\<open>Extension of domain preservation (by swap and subst) to inputs:\\<close>"], ["", "text \\<open>First for free inputs:\\<close>"], ["", "definition igSwapInpIPresIGWlsInp where\n\"igSwapInpIPresIGWlsInp MOD ==\n \\<forall> zs z1 z2 delta inp.\n   igWlsInp MOD delta inp \\<longrightarrow>\n   igWlsInp MOD delta (igSwapInp MOD zs z1 z2 inp)\""], ["", "definition igSwapInpIPresIGWlsInpSTR where\n\"igSwapInpIPresIGWlsInpSTR MOD ==\n \\<forall> zs z1 z2 delta inp.\n   igWlsInp MOD delta (igSwapInp MOD zs z1 z2 inp) =\n   igWlsInp MOD delta inp\""], ["", "definition igSubstInpIPresIGWlsInp where\n\"igSubstInpIPresIGWlsInp MOD ==\n \\<forall> ys y Y delta inp.\n   igWls MOD (asSort ys) Y \\<and> igWlsInp MOD delta inp \\<longrightarrow>\n   igWlsInp MOD delta (igSubstInp MOD ys Y y inp)\""], ["", "definition igSubstInpIPresIGWlsInpSTR where\n\"igSubstInpIPresIGWlsInpSTR MOD ==\n \\<forall> ys y Y delta inp.\n   igWls MOD (asSort ys) Y \\<longrightarrow>\n   igWlsInp MOD delta (igSubstInp MOD ys Y y inp) =\n   igWlsInp MOD delta inp\""], ["", "lemma imp_igSwapInpIPresIGWlsInp:\n\"igSwapIPresIGWls MOD \\<Longrightarrow> igSwapInpIPresIGWlsInp MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIPresIGWls MOD \\<Longrightarrow> igSwapInpIPresIGWlsInp MOD", "by (simp add: \nigSwapInpIPresIGWlsInp_def igWlsInp_def liftAll2_def  \nigSwapIPresIGWls_def igSwapAbsIPresIGWlsAbs_def igSwapInp_def lift_def \nsameDom_def split: option.splits)"], ["", "lemma imp_igSwapInpIPresIGWlsInpSTR:\n\"igSwapIPresIGWlsSTR MOD \\<Longrightarrow> igSwapInpIPresIGWlsInpSTR MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIPresIGWlsSTR MOD \\<Longrightarrow> igSwapInpIPresIGWlsInpSTR MOD", "by (simp add: \nigSwapIPresIGWlsSTR_def igWlsInp_def liftAll2_def  \nigSwapIPresIGWls_def igSwapInpIPresIGWlsInpSTR_def igSwapInp_def lift_def \nsameDom_def split: option.splits)  \n(smt option.distinct(1) option.exhaust)"], ["", "lemma imp_igSubstInpIPresIGWlsInp:\n\"igSubstIPresIGWls MOD \\<Longrightarrow> igSubstInpIPresIGWlsInp MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIPresIGWls MOD \\<Longrightarrow> igSubstInpIPresIGWlsInp MOD", "by (simp add : igSubstInp_def\nigSubstIPresIGWls_def igSubstInpIPresIGWlsInp_def igWlsInp_def liftAll2_def \nlift_def sameDom_def split: option.splits)"], ["", "lemma imp_igSubstInpIPresIGWlsInpSTR:\n\"igSubstIPresIGWlsSTR MOD \\<Longrightarrow> igSubstInpIPresIGWlsInpSTR MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIPresIGWlsSTR MOD \\<Longrightarrow>\n    igSubstInpIPresIGWlsInpSTR MOD", "by(simp add: \nigSubstInpIPresIGWlsInpSTR_def igSubstIPresIGWlsSTR_def igSubstInp_def\nigWlsInp_def liftAll2_def lift_def sameDom_def \nsplit: option.splits) (smt option.distinct(1) option.exhaust)"], ["", "text \\<open>Then for bound inputs:\\<close>"], ["", "definition igSwapBinpIPresIGWlsBinp where\n\"igSwapBinpIPresIGWlsBinp MOD ==\n \\<forall> zs z1 z2 delta binp.\n   igWlsBinp MOD delta binp \\<longrightarrow>\n   igWlsBinp MOD delta (igSwapBinp MOD zs z1 z2 binp)\""], ["", "definition igSwapBinpIPresIGWlsBinpSTR where\n\"igSwapBinpIPresIGWlsBinpSTR MOD ==\n \\<forall> zs z1 z2 delta binp.\n   igWlsBinp MOD delta (igSwapBinp MOD zs z1 z2 binp) =\n   igWlsBinp MOD delta binp\""], ["", "definition igSubstBinpIPresIGWlsBinp where\n\"igSubstBinpIPresIGWlsBinp MOD ==\n \\<forall> ys y Y delta binp.\n   igWls MOD (asSort ys) Y \\<and> igWlsBinp MOD delta binp \\<longrightarrow>\n   igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp)\""], ["", "definition igSubstBinpIPresIGWlsBinpSTR where\n\"igSubstBinpIPresIGWlsBinpSTR MOD ==\n \\<forall> ys y Y delta binp.\n   igWls MOD (asSort ys) Y \\<longrightarrow>\n   igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp) =\n   igWlsBinp MOD delta binp\""], ["", "lemma imp_igSwapBinpIPresIGWlsBinp:\n\"igSwapAbsIPresIGWlsAbs MOD \\<Longrightarrow> igSwapBinpIPresIGWlsBinp MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapAbsIPresIGWlsAbs MOD \\<Longrightarrow>\n    igSwapBinpIPresIGWlsBinp MOD", "by(auto simp add: \nigSwapBinpIPresIGWlsBinp_def igSwapAbsIPresIGWlsAbs_def igSwapBinp_def\nigWlsBinp_def liftAll2_def lift_def sameDom_def \nsplit: option.splits)"], ["", "lemma imp_igSwapBinpIPresIGWlsBinpSTR:\n\"igSwapAbsIPresIGWlsAbsSTR MOD \\<Longrightarrow> igSwapBinpIPresIGWlsBinpSTR MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapAbsIPresIGWlsAbsSTR MOD \\<Longrightarrow>\n    igSwapBinpIPresIGWlsBinpSTR MOD", "by (simp add: \nigSwapBinpIPresIGWlsBinpSTR_def igSwapAbsIPresIGWlsAbsSTR_def igSwapBinp_def\nigWlsBinp_def liftAll2_def lift_def sameDom_def \nsplit: option.splits) (smt option.distinct(1) option.exhaust surj_pair)"], ["", "lemma imp_igSubstBinpIPresIGWlsBinp:\n\"igSubstAbsIPresIGWlsAbs MOD \\<Longrightarrow> igSubstBinpIPresIGWlsBinp MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAbsIPresIGWlsAbs MOD \\<Longrightarrow>\n    igSubstBinpIPresIGWlsBinp MOD", "by (auto simp add: \nigSubstBinpIPresIGWlsBinp_def igSubstAbsIPresIGWlsAbs_def igSubstBinp_def\nigWlsBinp_def liftAll2_def lift_def sameDom_def \nsplit: option.splits)"], ["", "lemma imp_igSubstBinpIPresIGWlsBinpSTR:\n\"igSubstAbsIPresIGWlsAbsSTR MOD \\<Longrightarrow> igSubstBinpIPresIGWlsBinpSTR MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAbsIPresIGWlsAbsSTR MOD \\<Longrightarrow>\n    igSubstBinpIPresIGWlsBinpSTR MOD", "by (simp add: \nigSubstAbsIPresIGWlsAbsSTR_def igSubstBinpIPresIGWlsBinpSTR_def igSubstBinp_def\nigWlsBinp_def liftAll2_def lift_def sameDom_def \nsplit: option.splits) (smt option.distinct(1) option.exhaust surj_pair)"], ["", "subsection \\<open>Morphisms of models\\<close>"], ["", "text\\<open>\nThe morphisms between models shall be the usual first-order-logic morphisms, i.e,, functions\ncommuting with the operations and preserving the (freshness) relations.  Because they involve the\nsame signature, the morphisms for fresh-swap-subst models (called fresh-swap-subst morphisms)\nwill be the same as those for fresh-subst-swap-models.\n\\<close>"], ["", "subsubsection \\<open>Preservation of the domains\\<close>"], ["", "definition ipresIGWls where\n\"ipresIGWls h MOD MOD' ==\n \\<forall> s X. igWls MOD s X \\<longrightarrow> igWls MOD' s (h X)\""], ["", "definition ipresIGWlsAbs where\n\"ipresIGWlsAbs hA MOD MOD' ==\n \\<forall> us s A. igWlsAbs MOD (us,s) A \\<longrightarrow> igWlsAbs MOD' (us,s) (hA A)\""], ["", "definition ipresIGWlsAll where\n\"ipresIGWlsAll h hA MOD MOD' ==\n ipresIGWls h MOD MOD' \\<and>  ipresIGWlsAbs hA MOD MOD'\""], ["", "lemmas ipresIGWlsAll_defs = ipresIGWlsAll_def\nipresIGWls_def ipresIGWlsAbs_def"], ["", "subsubsection \\<open>Preservation of the constructs\\<close>"], ["", "definition ipresIGVar where\n\"ipresIGVar h MOD MOD' ==\n \\<forall> xs x. h (igVar MOD xs x) = igVar MOD' xs x\""], ["", "definition ipresIGAbs where\n\"ipresIGAbs h hA MOD MOD' ==\n \\<forall> xs x s X. isInBar (xs,s) \\<and> igWls MOD s X \\<longrightarrow>\n             hA (igAbs MOD xs x X) = igAbs MOD' xs x (h X)\""], ["", "definition ipresIGOp\nwhere\n\"ipresIGOp h hA MOD MOD' ==\n \\<forall> delta inp binp.\n   igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<longrightarrow>\n   h (igOp MOD delta inp binp) = igOp MOD' delta (lift h inp) (lift hA binp)\""], ["", "definition ipresIGCons where\n\"ipresIGCons h hA MOD MOD' ==\n ipresIGVar h MOD MOD' \\<and>\n ipresIGAbs h hA MOD MOD' \\<and>\n ipresIGOp h hA MOD MOD'\""], ["", "lemmas ipresIGCons_defs = ipresIGCons_def\nipresIGVar_def\nipresIGAbs_def\nipresIGOp_def"], ["", "subsubsection \\<open>Preservation of freshness\\<close>"], ["", "definition ipresIGFresh where\n\"ipresIGFresh h MOD MOD' ==\n \\<forall> ys y s X.\n    igWls MOD s X \\<longrightarrow>\n    igFresh MOD ys y X \\<longrightarrow> igFresh MOD' ys y (h X)\""], ["", "definition ipresIGFreshAbs where\n\"ipresIGFreshAbs hA MOD MOD' ==\n \\<forall> ys y us s A.\n    igWlsAbs MOD (us,s) A \\<longrightarrow>\n    igFreshAbs MOD ys y A \\<longrightarrow> igFreshAbs MOD' ys y (hA A)\""], ["", "definition ipresIGFreshAll where\n\"ipresIGFreshAll h hA MOD MOD' ==\n ipresIGFresh h MOD MOD' \\<and> ipresIGFreshAbs hA MOD MOD'\""], ["", "lemmas ipresIGFreshAll_defs = ipresIGFreshAll_def\nipresIGFresh_def ipresIGFreshAbs_def"], ["", "subsubsection \\<open>Preservation of swapping\\<close>"], ["", "definition ipresIGSwap where\n\"ipresIGSwap h MOD MOD' ==\n \\<forall> zs z1 z2 s X.\n    igWls MOD s X \\<longrightarrow>\n    h (igSwap MOD zs z1 z2 X) = igSwap MOD' zs z1 z2 (h X)\""], ["", "definition ipresIGSwapAbs where\n\"ipresIGSwapAbs hA MOD MOD' ==\n \\<forall> zs z1 z2 us s A.\n    igWlsAbs MOD (us,s) A \\<longrightarrow>\n    hA (igSwapAbs MOD zs z1 z2 A) = igSwapAbs MOD' zs z1 z2 (hA A)\""], ["", "definition ipresIGSwapAll where\n\"ipresIGSwapAll h hA MOD MOD' ==\n ipresIGSwap h MOD MOD' \\<and> ipresIGSwapAbs hA MOD MOD'\""], ["", "lemmas ipresIGSwapAll_defs = ipresIGSwapAll_def\nipresIGSwap_def ipresIGSwapAbs_def"], ["", "subsubsection \\<open>Preservation of subst\\<close>"], ["", "definition ipresIGSubst where\n\"ipresIGSubst h MOD MOD' ==\n \\<forall> ys Y y s X.\n    igWls MOD (asSort ys) Y \\<and> igWls MOD s X \\<longrightarrow>\n    h (igSubst MOD ys Y y X) = igSubst MOD' ys (h Y) y (h X)\""], ["", "definition ipresIGSubstAbs where\n\"ipresIGSubstAbs h hA MOD MOD' ==\n \\<forall> ys Y y us s A.\n    igWls MOD (asSort ys) Y \\<and> igWlsAbs MOD (us,s) A \\<longrightarrow>\n    hA (igSubstAbs MOD ys Y y A) = igSubstAbs MOD' ys (h Y) y (hA A)\""], ["", "definition ipresIGSubstAll where\n\"ipresIGSubstAll h hA MOD MOD' ==\n ipresIGSubst h MOD MOD' \\<and>\n ipresIGSubstAbs h hA MOD MOD'\""], ["", "lemmas ipresIGSubstAll_defs = ipresIGSubstAll_def\nipresIGSubst_def ipresIGSubstAbs_def"], ["", "subsubsection \\<open>Fresh-swap morphisms\\<close>"], ["", "definition FSwImorph where\n\"FSwImorph h hA MOD MOD' ==\n ipresIGWlsAll h hA MOD MOD' \\<and> ipresIGCons h hA MOD MOD' \\<and>\n ipresIGFreshAll h hA MOD MOD' \\<and> ipresIGSwapAll h hA MOD MOD'\""], ["", "lemmas FSwImorph_defs1 = FSwImorph_def\nipresIGWlsAll_def ipresIGCons_def\nipresIGFreshAll_def ipresIGSwapAll_def"], ["", "lemmas FSwImorph_defs = FSwImorph_def\nipresIGWlsAll_defs ipresIGCons_defs\nipresIGFreshAll_defs ipresIGSwapAll_defs"], ["", "subsubsection \\<open>Fresh-subst morphisms\\<close>"], ["", "definition FSbImorph where\n\"FSbImorph h hA MOD MOD' ==\n ipresIGWlsAll h hA MOD MOD' \\<and> ipresIGCons h hA MOD MOD' \\<and>\n ipresIGFreshAll h hA MOD MOD' \\<and> ipresIGSubstAll h hA MOD MOD'\""], ["", "lemmas FSbImorph_defs1 = FSbImorph_def\nipresIGWlsAll_def ipresIGCons_def\nipresIGFreshAll_def ipresIGSubstAll_def"], ["", "lemmas FSbImorph_defs = FSbImorph_def\nipresIGWlsAll_defs ipresIGCons_defs\nipresIGFreshAll_defs ipresIGSubstAll_defs"], ["", "subsubsection \\<open>Fresh-swap-subst morphisms\\<close>"], ["", "(* Note that FSwSb-morphisms are also igood for FSbSw-models. *)"], ["", "definition FSwSbImorph where\n\"FSwSbImorph h hA MOD MOD' ==\n FSwImorph h hA MOD MOD' \\<and> ipresIGSubstAll h hA MOD MOD'\""], ["", "lemmas FSwSbImorph_defs1 = FSwSbImorph_def\nFSwImorph_def ipresIGSubstAll_def"], ["", "lemmas FSwSbImorph_defs = FSwSbImorph_def\nFSwImorph_defs ipresIGSubstAll_defs"], ["", "subsubsection \\<open>Basic facts\\<close>"], ["", "text \\<open>FSwSb morphisms are the same as FSbSw morphisms:\\<close>"], ["", "lemma FSwSbImorph_iff:\n\"FSwSbImorph h hA MOD MOD' =\n (FSbImorph h hA MOD MOD' \\<and> ipresIGSwapAll h hA MOD MOD')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FSwSbImorph h hA MOD MOD' =\n    (FSbImorph h hA MOD MOD' \\<and> ipresIGSwapAll h hA MOD MOD')", "unfolding FSwSbImorph_def FSbImorph_def FSwImorph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ipresIGWlsAll h hA MOD MOD' \\<and>\n      ipresIGCons h hA MOD MOD' \\<and>\n      ipresIGFreshAll h hA MOD MOD' \\<and>\n      ipresIGSwapAll h hA MOD MOD') \\<and>\n     ipresIGSubstAll h hA MOD MOD') =\n    ((ipresIGWlsAll h hA MOD MOD' \\<and>\n      ipresIGCons h hA MOD MOD' \\<and>\n      ipresIGFreshAll h hA MOD MOD' \\<and>\n      ipresIGSubstAll h hA MOD MOD') \\<and>\n     ipresIGSwapAll h hA MOD MOD')", "by auto"], ["", "text \\<open>Some facts for free inpus:\\<close>"], ["", "lemma igSwapInp_None[simp]:\n\"(igSwapInp MOD zs z1 z2 inp i = None) = (inp i = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (igSwapInp MOD zs z1 z2 inp i = None) = (inp i = None)", "unfolding igSwapInp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lift (igSwap MOD zs z1 z2) inp i = None) = (inp i = None)", "by(simp add: lift_None)"], ["", "lemma igSubstInp_None[simp]:\n\"(igSubstInp MOD ys Y y inp i = None) = (inp i = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (igSubstInp MOD ys Y y inp i = None) = (inp i = None)", "unfolding igSubstInp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lift (igSubst MOD ys Y y) inp i = None) = (inp i = None)", "by(simp add: lift_None)"], ["", "lemma imp_igWlsInp:\n\"igWlsInp MOD delta inp \\<Longrightarrow> ipresIGWls h MOD MOD' \n \\<Longrightarrow> igWlsInp MOD' delta (lift h inp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igWlsInp MOD delta inp; ipresIGWls h MOD MOD'\\<rbrakk>\n    \\<Longrightarrow> igWlsInp MOD' delta (lift h inp)", "by (simp add: igWlsInp_def ipresIGWls_def liftAll2_def lift_def \nsameDom_def split: option.splits)"], ["", "corollary FSwImorph_igWlsInp:\nassumes \"igWlsInp MOD delta inp\" and \"FSwImorph h hA MOD MOD'\"\nshows \"igWlsInp MOD' delta (lift h inp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD' delta (lift h inp)", "using assms"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp\n  FSwImorph h hA MOD MOD'\n\ngoal (1 subgoal):\n 1. igWlsInp MOD' delta (lift h inp)", "unfolding FSwImorph_def ipresIGWlsAll_def"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp\n  (ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD') \\<and>\n  ipresIGCons h hA MOD MOD' \\<and>\n  ipresIGFreshAll h hA MOD MOD' \\<and> ipresIGSwapAll h hA MOD MOD'\n\ngoal (1 subgoal):\n 1. igWlsInp MOD' delta (lift h inp)", "using imp_igWlsInp"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp\n  (ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD') \\<and>\n  ipresIGCons h hA MOD MOD' \\<and>\n  ipresIGFreshAll h hA MOD MOD' \\<and> ipresIGSwapAll h hA MOD MOD'\n  \\<lbrakk>igWlsInp ?MOD ?delta ?inp; ipresIGWls ?h ?MOD ?MOD'\\<rbrakk>\n  \\<Longrightarrow> igWlsInp ?MOD' ?delta (lift ?h ?inp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD' delta (lift h inp)", "by auto"], ["", "corollary FSbImorph_igWlsInp:\nassumes \"igWlsInp MOD delta inp\" and \"FSbImorph h hA MOD MOD'\"\nshows \"igWlsInp MOD' delta (lift h inp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD' delta (lift h inp)", "using assms"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp\n  FSbImorph h hA MOD MOD'\n\ngoal (1 subgoal):\n 1. igWlsInp MOD' delta (lift h inp)", "unfolding FSbImorph_def ipresIGWlsAll_def"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp\n  (ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD') \\<and>\n  ipresIGCons h hA MOD MOD' \\<and>\n  ipresIGFreshAll h hA MOD MOD' \\<and> ipresIGSubstAll h hA MOD MOD'\n\ngoal (1 subgoal):\n 1. igWlsInp MOD' delta (lift h inp)", "using imp_igWlsInp"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp\n  (ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD') \\<and>\n  ipresIGCons h hA MOD MOD' \\<and>\n  ipresIGFreshAll h hA MOD MOD' \\<and> ipresIGSubstAll h hA MOD MOD'\n  \\<lbrakk>igWlsInp ?MOD ?delta ?inp; ipresIGWls ?h ?MOD ?MOD'\\<rbrakk>\n  \\<Longrightarrow> igWlsInp ?MOD' ?delta (lift ?h ?inp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD' delta (lift h inp)", "by auto"], ["", "lemma FSwSbImorph_igWlsInp:\nassumes \"igWlsInp MOD delta inp\" and \"FSwSbImorph h hA MOD MOD'\"\nshows \"igWlsInp MOD' delta (lift h inp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD' delta (lift h inp)", "using assms"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp\n  FSwSbImorph h hA MOD MOD'\n\ngoal (1 subgoal):\n 1. igWlsInp MOD' delta (lift h inp)", "unfolding FSwSbImorph_def"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp\n  FSwImorph h hA MOD MOD' \\<and> ipresIGSubstAll h hA MOD MOD'\n\ngoal (1 subgoal):\n 1. igWlsInp MOD' delta (lift h inp)", "using FSwImorph_igWlsInp"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp\n  FSwImorph h hA MOD MOD' \\<and> ipresIGSubstAll h hA MOD MOD'\n  \\<lbrakk>igWlsInp ?MOD ?delta ?inp; FSwImorph ?h ?hA ?MOD ?MOD'\\<rbrakk>\n  \\<Longrightarrow> igWlsInp ?MOD' ?delta (lift ?h ?inp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD' delta (lift h inp)", "by auto"], ["", "text \\<open>Similar facts for bound inpus:\\<close>"], ["", "lemma igSwapBinp_None[simp]:\n\"(igSwapBinp MOD zs z1 z2 binp i = None) = (binp i = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (igSwapBinp MOD zs z1 z2 binp i = None) = (binp i = None)", "unfolding igSwapBinp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lift (igSwapAbs MOD zs z1 z2) binp i = None) = (binp i = None)", "by(simp add: lift_None)"], ["", "lemma igSubstBinp_None[simp]:\n\"(igSubstBinp MOD ys Y y binp i = None) = (binp i = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (igSubstBinp MOD ys Y y binp i = None) = (binp i = None)", "unfolding igSubstBinp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lift (igSubstAbs MOD ys Y y) binp i = None) = (binp i = None)", "by(simp add: lift_None)"], ["", "lemma imp_igWlsBinp:\nassumes *: \"igWlsBinp MOD delta binp\"\nand **: \"ipresIGWlsAbs hA MOD MOD'\"\nshows \"igWlsBinp MOD' delta (lift hA binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsBinp MOD' delta (lift hA binp)", "using assms"], ["proof (prove)\nusing this:\n  igWlsBinp MOD delta binp\n  ipresIGWlsAbs hA MOD MOD'\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD' delta (lift hA binp)", "by (simp add: igWlsBinp_def ipresIGWlsAbs_def liftAll2_def lift_def \nsameDom_def split: option.splits)"], ["", "corollary FSwImorph_igWlsBinp:\nassumes \"igWlsBinp MOD delta binp\" and \"FSwImorph h hA MOD MOD'\"\nshows \"igWlsBinp MOD' delta (lift hA binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsBinp MOD' delta (lift hA binp)", "using assms"], ["proof (prove)\nusing this:\n  igWlsBinp MOD delta binp\n  FSwImorph h hA MOD MOD'\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD' delta (lift hA binp)", "unfolding FSwImorph_def ipresIGWlsAll_def"], ["proof (prove)\nusing this:\n  igWlsBinp MOD delta binp\n  (ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD') \\<and>\n  ipresIGCons h hA MOD MOD' \\<and>\n  ipresIGFreshAll h hA MOD MOD' \\<and> ipresIGSwapAll h hA MOD MOD'\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD' delta (lift hA binp)", "using imp_igWlsBinp"], ["proof (prove)\nusing this:\n  igWlsBinp MOD delta binp\n  (ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD') \\<and>\n  ipresIGCons h hA MOD MOD' \\<and>\n  ipresIGFreshAll h hA MOD MOD' \\<and> ipresIGSwapAll h hA MOD MOD'\n  \\<lbrakk>igWlsBinp ?MOD ?delta ?binp;\n   ipresIGWlsAbs ?hA ?MOD ?MOD'\\<rbrakk>\n  \\<Longrightarrow> igWlsBinp ?MOD' ?delta (lift ?hA ?binp)\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD' delta (lift hA binp)", "by auto"], ["", "corollary FSbImorph_igWlsBinp:\nassumes \"igWlsBinp MOD delta binp\" and \"FSbImorph h hA MOD MOD'\"\nshows \"igWlsBinp MOD' delta (lift hA binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsBinp MOD' delta (lift hA binp)", "using assms"], ["proof (prove)\nusing this:\n  igWlsBinp MOD delta binp\n  FSbImorph h hA MOD MOD'\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD' delta (lift hA binp)", "unfolding FSbImorph_def ipresIGWlsAll_def"], ["proof (prove)\nusing this:\n  igWlsBinp MOD delta binp\n  (ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD') \\<and>\n  ipresIGCons h hA MOD MOD' \\<and>\n  ipresIGFreshAll h hA MOD MOD' \\<and> ipresIGSubstAll h hA MOD MOD'\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD' delta (lift hA binp)", "using imp_igWlsBinp"], ["proof (prove)\nusing this:\n  igWlsBinp MOD delta binp\n  (ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD') \\<and>\n  ipresIGCons h hA MOD MOD' \\<and>\n  ipresIGFreshAll h hA MOD MOD' \\<and> ipresIGSubstAll h hA MOD MOD'\n  \\<lbrakk>igWlsBinp ?MOD ?delta ?binp;\n   ipresIGWlsAbs ?hA ?MOD ?MOD'\\<rbrakk>\n  \\<Longrightarrow> igWlsBinp ?MOD' ?delta (lift ?hA ?binp)\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD' delta (lift hA binp)", "by auto"], ["", "lemma FSwSbImorph_igWlsBinp:\nassumes \"igWlsBinp MOD delta binp\" and \"FSwSbImorph h hA MOD MOD'\"\nshows \"igWlsBinp MOD' delta (lift hA binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsBinp MOD' delta (lift hA binp)", "using assms"], ["proof (prove)\nusing this:\n  igWlsBinp MOD delta binp\n  FSwSbImorph h hA MOD MOD'\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD' delta (lift hA binp)", "unfolding FSwSbImorph_def"], ["proof (prove)\nusing this:\n  igWlsBinp MOD delta binp\n  FSwImorph h hA MOD MOD' \\<and> ipresIGSubstAll h hA MOD MOD'\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD' delta (lift hA binp)", "using FSwImorph_igWlsBinp"], ["proof (prove)\nusing this:\n  igWlsBinp MOD delta binp\n  FSwImorph h hA MOD MOD' \\<and> ipresIGSubstAll h hA MOD MOD'\n  \\<lbrakk>igWlsBinp ?MOD ?delta ?binp; FSwImorph ?h ?hA ?MOD ?MOD'\\<rbrakk>\n  \\<Longrightarrow> igWlsBinp ?MOD' ?delta (lift ?hA ?binp)\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD' delta (lift hA binp)", "by auto"], ["", "lemmas input_igSwap_igSubst_None =\nigSwapInp_None igSubstInp_None\nigSwapBinp_None igSubstBinp_None"], ["", "subsubsection \\<open>Identity and composition\\<close>"], ["", "lemma id_FSwImorph: \"FSwImorph id id MOD MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FSwImorph id id MOD MOD", "unfolding FSwImorph_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>s X.\n         igWls MOD s X \\<longrightarrow> igWls MOD s (id X)) \\<and>\n     (\\<forall>us s A.\n         igWlsAbs MOD (us, s) A \\<longrightarrow>\n         igWlsAbs MOD (us, s) (id A))) \\<and>\n    ((\\<forall>xs x. id (igVar MOD xs x) = igVar MOD xs x) \\<and>\n     (\\<forall>xs x s X.\n         isInBar (xs, s) \\<and> igWls MOD s X \\<longrightarrow>\n         id (igAbs MOD xs x X) = igAbs MOD xs x (id X)) \\<and>\n     (\\<forall>delta inp binp.\n         igWlsInp MOD delta inp \\<and>\n         igWlsBinp MOD delta binp \\<longrightarrow>\n         id (igOp MOD delta inp binp) =\n         igOp MOD delta (lift id inp) (lift id binp))) \\<and>\n    ((\\<forall>ys y s X.\n         igWls MOD s X \\<longrightarrow>\n         igFresh MOD ys y X \\<longrightarrow>\n         igFresh MOD ys y (id X)) \\<and>\n     (\\<forall>ys y us s A.\n         igWlsAbs MOD (us, s) A \\<longrightarrow>\n         igFreshAbs MOD ys y A \\<longrightarrow>\n         igFreshAbs MOD ys y (id A))) \\<and>\n    (\\<forall>zs z1 z2 s X.\n        igWls MOD s X \\<longrightarrow>\n        id (igSwap MOD zs z1 z2 X) = igSwap MOD zs z1 z2 (id X)) \\<and>\n    (\\<forall>zs z1 z2 us s A.\n        igWlsAbs MOD (us, s) A \\<longrightarrow>\n        id (igSwapAbs MOD zs z1 z2 A) = igSwapAbs MOD zs z1 z2 (id A))", "by auto"], ["", "lemma id_FSbImorph: \"FSbImorph id id MOD MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FSbImorph id id MOD MOD", "unfolding FSbImorph_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>s X.\n         igWls MOD s X \\<longrightarrow> igWls MOD s (id X)) \\<and>\n     (\\<forall>us s A.\n         igWlsAbs MOD (us, s) A \\<longrightarrow>\n         igWlsAbs MOD (us, s) (id A))) \\<and>\n    ((\\<forall>xs x. id (igVar MOD xs x) = igVar MOD xs x) \\<and>\n     (\\<forall>xs x s X.\n         isInBar (xs, s) \\<and> igWls MOD s X \\<longrightarrow>\n         id (igAbs MOD xs x X) = igAbs MOD xs x (id X)) \\<and>\n     (\\<forall>delta inp binp.\n         igWlsInp MOD delta inp \\<and>\n         igWlsBinp MOD delta binp \\<longrightarrow>\n         id (igOp MOD delta inp binp) =\n         igOp MOD delta (lift id inp) (lift id binp))) \\<and>\n    ((\\<forall>ys y s X.\n         igWls MOD s X \\<longrightarrow>\n         igFresh MOD ys y X \\<longrightarrow>\n         igFresh MOD ys y (id X)) \\<and>\n     (\\<forall>ys y us s A.\n         igWlsAbs MOD (us, s) A \\<longrightarrow>\n         igFreshAbs MOD ys y A \\<longrightarrow>\n         igFreshAbs MOD ys y (id A))) \\<and>\n    (\\<forall>ys Y y s X.\n        igWls MOD (asSort ys) Y \\<and> igWls MOD s X \\<longrightarrow>\n        id (igSubst MOD ys Y y X) = igSubst MOD ys (id Y) y (id X)) \\<and>\n    (\\<forall>ys Y y us s A.\n        igWls MOD (asSort ys) Y \\<and>\n        igWlsAbs MOD (us, s) A \\<longrightarrow>\n        id (igSubstAbs MOD ys Y y A) = igSubstAbs MOD ys (id Y) y (id A))", "by auto"], ["", "lemma id_FSwSbImorph: \"FSwSbImorph id id MOD MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FSwSbImorph id id MOD MOD", "unfolding FSwSbImorph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FSwImorph id id MOD MOD \\<and> ipresIGSubstAll id id MOD MOD", "apply(auto simp add: id_FSwImorph)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSubstAll id id MOD MOD", "unfolding ipresIGSubstAll_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>ys Y y s X.\n        igWls MOD (asSort ys) Y \\<and> igWls MOD s X \\<longrightarrow>\n        id (igSubst MOD ys Y y X) = igSubst MOD ys (id Y) y (id X)) \\<and>\n    (\\<forall>ys Y y us s A.\n        igWls MOD (asSort ys) Y \\<and>\n        igWlsAbs MOD (us, s) A \\<longrightarrow>\n        id (igSubstAbs MOD ys Y y A) = igSubstAbs MOD ys (id Y) y (id A))", "by auto"], ["", "lemma comp_ipresIGWls:\nassumes \"ipresIGWls h MOD MOD'\" and \"ipresIGWls h' MOD' MOD''\"\nshows \"ipresIGWls (h' o h) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGWls (h' \\<circ> h) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  ipresIGWls h MOD MOD'\n  ipresIGWls h' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGWls (h' \\<circ> h) MOD MOD''", "unfolding ipresIGWls_def"], ["proof (prove)\nusing this:\n  \\<forall>s X. igWls MOD s X \\<longrightarrow> igWls MOD' s (h X)\n  \\<forall>s X. igWls MOD' s X \\<longrightarrow> igWls MOD'' s (h' X)\n\ngoal (1 subgoal):\n 1. \\<forall>s X.\n       igWls MOD s X \\<longrightarrow> igWls MOD'' s ((h' \\<circ> h) X)", "by auto"], ["", "lemma comp_ipresIGWlsAbs:\nassumes \"ipresIGWlsAbs hA MOD MOD'\" and \"ipresIGWlsAbs hA' MOD' MOD''\"\nshows \"ipresIGWlsAbs (hA' o hA) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGWlsAbs (hA' \\<circ> hA) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  ipresIGWlsAbs hA MOD MOD'\n  ipresIGWlsAbs hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGWlsAbs (hA' \\<circ> hA) MOD MOD''", "unfolding ipresIGWlsAbs_def"], ["proof (prove)\nusing this:\n  \\<forall>us s A.\n     igWlsAbs MOD (us, s) A \\<longrightarrow> igWlsAbs MOD' (us, s) (hA A)\n  \\<forall>us s A.\n     igWlsAbs MOD' (us, s) A \\<longrightarrow>\n     igWlsAbs MOD'' (us, s) (hA' A)\n\ngoal (1 subgoal):\n 1. \\<forall>us s A.\n       igWlsAbs MOD (us, s) A \\<longrightarrow>\n       igWlsAbs MOD'' (us, s) ((hA' \\<circ> hA) A)", "by auto"], ["", "lemma comp_ipresIGWlsAll:\nassumes \"ipresIGWlsAll h hA MOD MOD'\" and \"ipresIGWlsAll h' hA' MOD' MOD''\"\nshows \"ipresIGWlsAll (h' o h) (hA' o hA) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGWlsAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  ipresIGWlsAll h hA MOD MOD'\n  ipresIGWlsAll h' hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGWlsAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "unfolding ipresIGWlsAll_def"], ["proof (prove)\nusing this:\n  ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD'\n  ipresIGWls h' MOD' MOD'' \\<and> ipresIGWlsAbs hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGWls (h' \\<circ> h) MOD MOD'' \\<and>\n    ipresIGWlsAbs (hA' \\<circ> hA) MOD MOD''", "using comp_ipresIGWls comp_ipresIGWlsAbs"], ["proof (prove)\nusing this:\n  ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD'\n  ipresIGWls h' MOD' MOD'' \\<and> ipresIGWlsAbs hA' MOD' MOD''\n  \\<lbrakk>ipresIGWls ?h ?MOD ?MOD'; ipresIGWls ?h' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGWls (?h' \\<circ> ?h) ?MOD ?MOD''\n  \\<lbrakk>ipresIGWlsAbs ?hA ?MOD ?MOD';\n   ipresIGWlsAbs ?hA' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGWlsAbs (?hA' \\<circ> ?hA) ?MOD ?MOD''\n\ngoal (1 subgoal):\n 1. ipresIGWls (h' \\<circ> h) MOD MOD'' \\<and>\n    ipresIGWlsAbs (hA' \\<circ> hA) MOD MOD''", "by auto"], ["", "lemma comp_ipresIGVar:\nassumes \"ipresIGVar h MOD MOD'\" and \"ipresIGVar h' MOD' MOD''\"\nshows \"ipresIGVar (h' o h) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGVar (h' \\<circ> h) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  ipresIGVar h MOD MOD'\n  ipresIGVar h' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGVar (h' \\<circ> h) MOD MOD''", "unfolding ipresIGVar_def"], ["proof (prove)\nusing this:\n  \\<forall>xs x. h (igVar MOD xs x) = igVar MOD' xs x\n  \\<forall>xs x. h' (igVar MOD' xs x) = igVar MOD'' xs x\n\ngoal (1 subgoal):\n 1. \\<forall>xs x. (h' \\<circ> h) (igVar MOD xs x) = igVar MOD'' xs x", "by auto"], ["", "lemma comp_ipresIGAbs:\nassumes \"ipresIGWls h MOD MOD'\"\nand \"ipresIGAbs h hA MOD MOD'\" and \"ipresIGAbs h' hA' MOD' MOD''\"\nshows \"ipresIGAbs (h' o h) (hA' o hA) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGAbs (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  ipresIGWls h MOD MOD'\n  ipresIGAbs h hA MOD MOD'\n  ipresIGAbs h' hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGAbs (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "unfolding ipresIGWls_def ipresIGAbs_def"], ["proof (prove)\nusing this:\n  \\<forall>s X. igWls MOD s X \\<longrightarrow> igWls MOD' s (h X)\n  \\<forall>xs x s X.\n     isInBar (xs, s) \\<and> igWls MOD s X \\<longrightarrow>\n     hA (igAbs MOD xs x X) = igAbs MOD' xs x (h X)\n  \\<forall>xs x s X.\n     isInBar (xs, s) \\<and> igWls MOD' s X \\<longrightarrow>\n     hA' (igAbs MOD' xs x X) = igAbs MOD'' xs x (h' X)\n\ngoal (1 subgoal):\n 1. \\<forall>xs x s X.\n       isInBar (xs, s) \\<and> igWls MOD s X \\<longrightarrow>\n       (hA' \\<circ> hA) (igAbs MOD xs x X) =\n       igAbs MOD'' xs x ((h' \\<circ> h) X)", "by fastforce"], ["", "lemma comp_ipresIGOp:\nassumes ipres: \"ipresIGWls h MOD MOD'\" and ipresAbs: \"ipresIGWlsAbs hA MOD MOD'\"\nand h: \"ipresIGOp h hA MOD MOD'\" and h': \"ipresIGOp h' hA' MOD' MOD''\"\nshows \"ipresIGOp (h' o h) (hA' o hA) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGOp (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  ipresIGWls h MOD MOD'\n  ipresIGWlsAbs hA MOD MOD'\n  ipresIGOp h hA MOD MOD'\n  ipresIGOp h' hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGOp (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "by (auto simp: imp_igWlsInp imp_igWlsBinp ipresIGOp_def lift_comp)"], ["", "lemma comp_ipresIGCons:\nassumes \"ipresIGWlsAll h hA MOD MOD'\"\nand \"ipresIGCons h hA MOD MOD'\" and \"ipresIGCons h' hA' MOD' MOD''\"\nshows \"ipresIGCons (h' o h) (hA' o hA) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGCons (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  ipresIGWlsAll h hA MOD MOD'\n  ipresIGCons h hA MOD MOD'\n  ipresIGCons h' hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGCons (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "unfolding ipresIGWlsAll_def ipresIGCons_def"], ["proof (prove)\nusing this:\n  ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD'\n  ipresIGVar h MOD MOD' \\<and>\n  ipresIGAbs h hA MOD MOD' \\<and> ipresIGOp h hA MOD MOD'\n  ipresIGVar h' MOD' MOD'' \\<and>\n  ipresIGAbs h' hA' MOD' MOD'' \\<and> ipresIGOp h' hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGVar (h' \\<circ> h) MOD MOD'' \\<and>\n    ipresIGAbs (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD'' \\<and>\n    ipresIGOp (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "using comp_ipresIGVar comp_ipresIGAbs comp_ipresIGOp"], ["proof (prove)\nusing this:\n  ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD'\n  ipresIGVar h MOD MOD' \\<and>\n  ipresIGAbs h hA MOD MOD' \\<and> ipresIGOp h hA MOD MOD'\n  ipresIGVar h' MOD' MOD'' \\<and>\n  ipresIGAbs h' hA' MOD' MOD'' \\<and> ipresIGOp h' hA' MOD' MOD''\n  \\<lbrakk>ipresIGVar ?h ?MOD ?MOD'; ipresIGVar ?h' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGVar (?h' \\<circ> ?h) ?MOD ?MOD''\n  \\<lbrakk>ipresIGWls ?h ?MOD ?MOD'; ipresIGAbs ?h ?hA ?MOD ?MOD';\n   ipresIGAbs ?h' ?hA' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGAbs (?h' \\<circ> ?h) (?hA' \\<circ> ?hA) ?MOD\n                     ?MOD''\n  \\<lbrakk>ipresIGWls ?h ?MOD ?MOD'; ipresIGWlsAbs ?hA ?MOD ?MOD';\n   ipresIGOp ?h ?hA ?MOD ?MOD'; ipresIGOp ?h' ?hA' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGOp (?h' \\<circ> ?h) (?hA' \\<circ> ?hA) ?MOD\n                     ?MOD''\n\ngoal (1 subgoal):\n 1. ipresIGVar (h' \\<circ> h) MOD MOD'' \\<and>\n    ipresIGAbs (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD'' \\<and>\n    ipresIGOp (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "by auto"], ["", "lemma comp_ipresIGFresh:\nassumes \"ipresIGWls h MOD MOD'\"\nand \"ipresIGFresh h MOD MOD'\" and \"ipresIGFresh h' MOD' MOD''\"\nshows \"ipresIGFresh (h' o h) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGFresh (h' \\<circ> h) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  ipresIGWls h MOD MOD'\n  ipresIGFresh h MOD MOD'\n  ipresIGFresh h' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGFresh (h' \\<circ> h) MOD MOD''", "unfolding ipresIGWls_def ipresIGFresh_def"], ["proof (prove)\nusing this:\n  \\<forall>s X. igWls MOD s X \\<longrightarrow> igWls MOD' s (h X)\n  \\<forall>ys y s X.\n     igWls MOD s X \\<longrightarrow>\n     igFresh MOD ys y X \\<longrightarrow> igFresh MOD' ys y (h X)\n  \\<forall>ys y s X.\n     igWls MOD' s X \\<longrightarrow>\n     igFresh MOD' ys y X \\<longrightarrow> igFresh MOD'' ys y (h' X)\n\ngoal (1 subgoal):\n 1. \\<forall>ys y s X.\n       igWls MOD s X \\<longrightarrow>\n       igFresh MOD ys y X \\<longrightarrow>\n       igFresh MOD'' ys y ((h' \\<circ> h) X)", "by fastforce"], ["", "lemma comp_ipresIGFreshAbs:\nassumes \"ipresIGWlsAbs hA MOD MOD'\"\nand \"ipresIGFreshAbs hA MOD MOD'\" and \"ipresIGFreshAbs hA' MOD' MOD''\"\nshows \"ipresIGFreshAbs (hA' o hA) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGFreshAbs (hA' \\<circ> hA) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  ipresIGWlsAbs hA MOD MOD'\n  ipresIGFreshAbs hA MOD MOD'\n  ipresIGFreshAbs hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGFreshAbs (hA' \\<circ> hA) MOD MOD''", "unfolding ipresIGWlsAbs_def ipresIGFreshAbs_def"], ["proof (prove)\nusing this:\n  \\<forall>us s A.\n     igWlsAbs MOD (us, s) A \\<longrightarrow> igWlsAbs MOD' (us, s) (hA A)\n  \\<forall>ys y us s A.\n     igWlsAbs MOD (us, s) A \\<longrightarrow>\n     igFreshAbs MOD ys y A \\<longrightarrow> igFreshAbs MOD' ys y (hA A)\n  \\<forall>ys y us s A.\n     igWlsAbs MOD' (us, s) A \\<longrightarrow>\n     igFreshAbs MOD' ys y A \\<longrightarrow> igFreshAbs MOD'' ys y (hA' A)\n\ngoal (1 subgoal):\n 1. \\<forall>ys y us s A.\n       igWlsAbs MOD (us, s) A \\<longrightarrow>\n       igFreshAbs MOD ys y A \\<longrightarrow>\n       igFreshAbs MOD'' ys y ((hA' \\<circ> hA) A)", "by fastforce"], ["", "lemma comp_ipresIGFreshAll:\nassumes \"ipresIGWlsAll h hA MOD MOD'\"\nand \"ipresIGFreshAll h hA MOD MOD'\" and \"ipresIGFreshAll h' hA'  MOD' MOD''\"\nshows \"ipresIGFreshAll (h' o h) (hA' o hA) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGFreshAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  ipresIGWlsAll h hA MOD MOD'\n  ipresIGFreshAll h hA MOD MOD'\n  ipresIGFreshAll h' hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGFreshAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "unfolding ipresIGWlsAll_def ipresIGFreshAll_def"], ["proof (prove)\nusing this:\n  ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD'\n  ipresIGFresh h MOD MOD' \\<and> ipresIGFreshAbs hA MOD MOD'\n  ipresIGFresh h' MOD' MOD'' \\<and> ipresIGFreshAbs hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGFresh (h' \\<circ> h) MOD MOD'' \\<and>\n    ipresIGFreshAbs (hA' \\<circ> hA) MOD MOD''", "using comp_ipresIGFresh comp_ipresIGFreshAbs"], ["proof (prove)\nusing this:\n  ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD'\n  ipresIGFresh h MOD MOD' \\<and> ipresIGFreshAbs hA MOD MOD'\n  ipresIGFresh h' MOD' MOD'' \\<and> ipresIGFreshAbs hA' MOD' MOD''\n  \\<lbrakk>ipresIGWls ?h ?MOD ?MOD'; ipresIGFresh ?h ?MOD ?MOD';\n   ipresIGFresh ?h' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGFresh (?h' \\<circ> ?h) ?MOD ?MOD''\n  \\<lbrakk>ipresIGWlsAbs ?hA ?MOD ?MOD'; ipresIGFreshAbs ?hA ?MOD ?MOD';\n   ipresIGFreshAbs ?hA' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGFreshAbs (?hA' \\<circ> ?hA) ?MOD ?MOD''\n\ngoal (1 subgoal):\n 1. ipresIGFresh (h' \\<circ> h) MOD MOD'' \\<and>\n    ipresIGFreshAbs (hA' \\<circ> hA) MOD MOD''", "by auto"], ["", "lemma comp_ipresIGSwap:\nassumes \"ipresIGWls h MOD MOD'\"\nand \"ipresIGSwap h MOD MOD'\" and \"ipresIGSwap h' MOD' MOD''\"\nshows \"ipresIGSwap (h' o h) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSwap (h' \\<circ> h) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  ipresIGWls h MOD MOD'\n  ipresIGSwap h MOD MOD'\n  ipresIGSwap h' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGSwap (h' \\<circ> h) MOD MOD''", "unfolding ipresIGWls_def ipresIGSwap_def"], ["proof (prove)\nusing this:\n  \\<forall>s X. igWls MOD s X \\<longrightarrow> igWls MOD' s (h X)\n  \\<forall>zs z1 z2 s X.\n     igWls MOD s X \\<longrightarrow>\n     h (igSwap MOD zs z1 z2 X) = igSwap MOD' zs z1 z2 (h X)\n  \\<forall>zs z1 z2 s X.\n     igWls MOD' s X \\<longrightarrow>\n     h' (igSwap MOD' zs z1 z2 X) = igSwap MOD'' zs z1 z2 (h' X)\n\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 s X.\n       igWls MOD s X \\<longrightarrow>\n       (h' \\<circ> h) (igSwap MOD zs z1 z2 X) =\n       igSwap MOD'' zs z1 z2 ((h' \\<circ> h) X)", "by fastforce"], ["", "lemma comp_ipresIGSwapAbs:\nassumes \"ipresIGWlsAbs hA MOD MOD'\"\nand \"ipresIGSwapAbs hA MOD MOD'\" and \"ipresIGSwapAbs hA' MOD' MOD''\"\nshows \"ipresIGSwapAbs (hA' o hA) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSwapAbs (hA' \\<circ> hA) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  ipresIGWlsAbs hA MOD MOD'\n  ipresIGSwapAbs hA MOD MOD'\n  ipresIGSwapAbs hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGSwapAbs (hA' \\<circ> hA) MOD MOD''", "unfolding ipresIGWlsAbs_def ipresIGSwapAbs_def"], ["proof (prove)\nusing this:\n  \\<forall>us s A.\n     igWlsAbs MOD (us, s) A \\<longrightarrow> igWlsAbs MOD' (us, s) (hA A)\n  \\<forall>zs z1 z2 us s A.\n     igWlsAbs MOD (us, s) A \\<longrightarrow>\n     hA (igSwapAbs MOD zs z1 z2 A) = igSwapAbs MOD' zs z1 z2 (hA A)\n  \\<forall>zs z1 z2 us s A.\n     igWlsAbs MOD' (us, s) A \\<longrightarrow>\n     hA' (igSwapAbs MOD' zs z1 z2 A) = igSwapAbs MOD'' zs z1 z2 (hA' A)\n\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 us s A.\n       igWlsAbs MOD (us, s) A \\<longrightarrow>\n       (hA' \\<circ> hA) (igSwapAbs MOD zs z1 z2 A) =\n       igSwapAbs MOD'' zs z1 z2 ((hA' \\<circ> hA) A)", "by fastforce"], ["", "lemma comp_ipresIGSwapAll:\nassumes \"ipresIGWlsAll h hA MOD MOD'\"\nand \"ipresIGSwapAll h hA MOD MOD'\" and \"ipresIGSwapAll h' hA'  MOD' MOD''\"\nshows \"ipresIGSwapAll (h' o h) (hA' o hA) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSwapAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  ipresIGWlsAll h hA MOD MOD'\n  ipresIGSwapAll h hA MOD MOD'\n  ipresIGSwapAll h' hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGSwapAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "unfolding ipresIGWlsAll_def ipresIGSwapAll_def"], ["proof (prove)\nusing this:\n  ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD'\n  ipresIGSwap h MOD MOD' \\<and> ipresIGSwapAbs hA MOD MOD'\n  ipresIGSwap h' MOD' MOD'' \\<and> ipresIGSwapAbs hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGSwap (h' \\<circ> h) MOD MOD'' \\<and>\n    ipresIGSwapAbs (hA' \\<circ> hA) MOD MOD''", "using comp_ipresIGSwap comp_ipresIGSwapAbs"], ["proof (prove)\nusing this:\n  ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD'\n  ipresIGSwap h MOD MOD' \\<and> ipresIGSwapAbs hA MOD MOD'\n  ipresIGSwap h' MOD' MOD'' \\<and> ipresIGSwapAbs hA' MOD' MOD''\n  \\<lbrakk>ipresIGWls ?h ?MOD ?MOD'; ipresIGSwap ?h ?MOD ?MOD';\n   ipresIGSwap ?h' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGSwap (?h' \\<circ> ?h) ?MOD ?MOD''\n  \\<lbrakk>ipresIGWlsAbs ?hA ?MOD ?MOD'; ipresIGSwapAbs ?hA ?MOD ?MOD';\n   ipresIGSwapAbs ?hA' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGSwapAbs (?hA' \\<circ> ?hA) ?MOD ?MOD''\n\ngoal (1 subgoal):\n 1. ipresIGSwap (h' \\<circ> h) MOD MOD'' \\<and>\n    ipresIGSwapAbs (hA' \\<circ> hA) MOD MOD''", "by auto"], ["", "lemma comp_ipresIGSubst:\nassumes \"ipresIGWls h MOD MOD'\"\nand \"ipresIGSubst h MOD MOD'\" and \"ipresIGSubst h' MOD' MOD''\"\nshows \"ipresIGSubst (h' o h) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSubst (h' \\<circ> h) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  ipresIGWls h MOD MOD'\n  ipresIGSubst h MOD MOD'\n  ipresIGSubst h' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGSubst (h' \\<circ> h) MOD MOD''", "unfolding ipresIGWls_def ipresIGSubst_def"], ["proof (prove)\nusing this:\n  \\<forall>s X. igWls MOD s X \\<longrightarrow> igWls MOD' s (h X)\n  \\<forall>ys Y y s X.\n     igWls MOD (asSort ys) Y \\<and> igWls MOD s X \\<longrightarrow>\n     h (igSubst MOD ys Y y X) = igSubst MOD' ys (h Y) y (h X)\n  \\<forall>ys Y y s X.\n     igWls MOD' (asSort ys) Y \\<and> igWls MOD' s X \\<longrightarrow>\n     h' (igSubst MOD' ys Y y X) = igSubst MOD'' ys (h' Y) y (h' X)\n\ngoal (1 subgoal):\n 1. \\<forall>ys Y y s X.\n       igWls MOD (asSort ys) Y \\<and> igWls MOD s X \\<longrightarrow>\n       (h' \\<circ> h) (igSubst MOD ys Y y X) =\n       igSubst MOD'' ys ((h' \\<circ> h) Y) y ((h' \\<circ> h) X)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys Y y s X.\n       \\<lbrakk>\\<forall>s X.\n                   igWls MOD s X \\<longrightarrow> igWls MOD' s (h X);\n        \\<forall>ys Y y s X.\n           igWls MOD (asSort ys) Y \\<and> igWls MOD s X \\<longrightarrow>\n           h (igSubst MOD ys Y y X) = igSubst MOD' ys (h Y) y (h X);\n        \\<forall>ys Y y s X.\n           igWls MOD' (asSort ys) Y \\<and> igWls MOD' s X \\<longrightarrow>\n           h' (igSubst MOD' ys Y y X) = igSubst MOD'' ys (h' Y) y (h' X);\n        igWls MOD (asSort ys) Y; igWls MOD s X\\<rbrakk>\n       \\<Longrightarrow> h' (igSubst MOD' ys (h Y) y (h X)) =\n                         igSubst MOD'' ys (h' (h Y)) y (h' (h X))", "by blast"], ["", "lemma comp_ipresIGSubstAbs:\nassumes *: \"igWlsAbsIsInBar MOD\"\nand h: \"ipresIGWls h MOD MOD'\" and hA: \"ipresIGWlsAbs hA MOD MOD'\"\nand hhA: \"ipresIGSubstAbs h hA MOD MOD'\" and h'hA': \"ipresIGSubstAbs h' hA' MOD' MOD''\"\nshows \"ipresIGSubstAbs (h' o h) (hA' o hA) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSubstAbs (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  igWlsAbsIsInBar MOD\n  ipresIGWls h MOD MOD'\n  ipresIGWlsAbs hA MOD MOD'\n  ipresIGSubstAbs h hA MOD MOD'\n  ipresIGSubstAbs h' hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGSubstAbs (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "by(fastforce simp: igWlsAbsIsInBar_def \nipresIGSubstAbs_def ipresIGWls_def ipresIGWlsAbs_def)"], ["", "lemma comp_ipresIGSubstAll:\nassumes \"igWlsAbsIsInBar MOD\"\nand \"ipresIGWlsAll h hA MOD MOD'\"\nand \"ipresIGSubstAll h hA MOD MOD'\" and \"ipresIGSubstAll h' hA'  MOD' MOD''\"\nshows \"ipresIGSubstAll (h' o h) (hA' o hA) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSubstAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  igWlsAbsIsInBar MOD\n  ipresIGWlsAll h hA MOD MOD'\n  ipresIGSubstAll h hA MOD MOD'\n  ipresIGSubstAll h' hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGSubstAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "unfolding ipresIGWlsAll_def ipresIGSubstAll_def"], ["proof (prove)\nusing this:\n  igWlsAbsIsInBar MOD\n  ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD'\n  ipresIGSubst h MOD MOD' \\<and> ipresIGSubstAbs h hA MOD MOD'\n  ipresIGSubst h' MOD' MOD'' \\<and> ipresIGSubstAbs h' hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGSubst (h' \\<circ> h) MOD MOD'' \\<and>\n    ipresIGSubstAbs (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "using comp_ipresIGSubst comp_ipresIGSubstAbs"], ["proof (prove)\nusing this:\n  igWlsAbsIsInBar MOD\n  ipresIGWls h MOD MOD' \\<and> ipresIGWlsAbs hA MOD MOD'\n  ipresIGSubst h MOD MOD' \\<and> ipresIGSubstAbs h hA MOD MOD'\n  ipresIGSubst h' MOD' MOD'' \\<and> ipresIGSubstAbs h' hA' MOD' MOD''\n  \\<lbrakk>ipresIGWls ?h ?MOD ?MOD'; ipresIGSubst ?h ?MOD ?MOD';\n   ipresIGSubst ?h' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGSubst (?h' \\<circ> ?h) ?MOD ?MOD''\n  \\<lbrakk>igWlsAbsIsInBar ?MOD; ipresIGWls ?h ?MOD ?MOD';\n   ipresIGWlsAbs ?hA ?MOD ?MOD'; ipresIGSubstAbs ?h ?hA ?MOD ?MOD';\n   ipresIGSubstAbs ?h' ?hA' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGSubstAbs (?h' \\<circ> ?h) (?hA' \\<circ> ?hA) ?MOD\n                     ?MOD''\n\ngoal (1 subgoal):\n 1. ipresIGSubst (h' \\<circ> h) MOD MOD'' \\<and>\n    ipresIGSubstAbs (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "by auto"], ["", "lemma comp_FSwImorph:\nassumes *: \"FSwImorph h hA MOD MOD'\" and **: \"FSwImorph h' hA' MOD' MOD''\"\nshows \"FSwImorph (h' o h) (hA' o hA) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FSwImorph (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  FSwImorph h hA MOD MOD'\n  FSwImorph h' hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. FSwImorph (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "unfolding FSwImorph_def"], ["proof (prove)\nusing this:\n  ipresIGWlsAll h hA MOD MOD' \\<and>\n  ipresIGCons h hA MOD MOD' \\<and>\n  ipresIGFreshAll h hA MOD MOD' \\<and> ipresIGSwapAll h hA MOD MOD'\n  ipresIGWlsAll h' hA' MOD' MOD'' \\<and>\n  ipresIGCons h' hA' MOD' MOD'' \\<and>\n  ipresIGFreshAll h' hA' MOD' MOD'' \\<and> ipresIGSwapAll h' hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGWlsAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD'' \\<and>\n    ipresIGCons (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD'' \\<and>\n    ipresIGFreshAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD'' \\<and>\n    ipresIGSwapAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "using comp_ipresIGWlsAll comp_ipresIGCons\ncomp_ipresIGFreshAll comp_ipresIGSwapAll"], ["proof (prove)\nusing this:\n  ipresIGWlsAll h hA MOD MOD' \\<and>\n  ipresIGCons h hA MOD MOD' \\<and>\n  ipresIGFreshAll h hA MOD MOD' \\<and> ipresIGSwapAll h hA MOD MOD'\n  ipresIGWlsAll h' hA' MOD' MOD'' \\<and>\n  ipresIGCons h' hA' MOD' MOD'' \\<and>\n  ipresIGFreshAll h' hA' MOD' MOD'' \\<and> ipresIGSwapAll h' hA' MOD' MOD''\n  \\<lbrakk>ipresIGWlsAll ?h ?hA ?MOD ?MOD';\n   ipresIGWlsAll ?h' ?hA' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGWlsAll (?h' \\<circ> ?h) (?hA' \\<circ> ?hA) ?MOD\n                     ?MOD''\n  \\<lbrakk>ipresIGWlsAll ?h ?hA ?MOD ?MOD'; ipresIGCons ?h ?hA ?MOD ?MOD';\n   ipresIGCons ?h' ?hA' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGCons (?h' \\<circ> ?h) (?hA' \\<circ> ?hA) ?MOD\n                     ?MOD''\n  \\<lbrakk>ipresIGWlsAll ?h ?hA ?MOD ?MOD';\n   ipresIGFreshAll ?h ?hA ?MOD ?MOD';\n   ipresIGFreshAll ?h' ?hA' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGFreshAll (?h' \\<circ> ?h) (?hA' \\<circ> ?hA) ?MOD\n                     ?MOD''\n  \\<lbrakk>ipresIGWlsAll ?h ?hA ?MOD ?MOD';\n   ipresIGSwapAll ?h ?hA ?MOD ?MOD';\n   ipresIGSwapAll ?h' ?hA' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGSwapAll (?h' \\<circ> ?h) (?hA' \\<circ> ?hA) ?MOD\n                     ?MOD''\n\ngoal (1 subgoal):\n 1. ipresIGWlsAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD'' \\<and>\n    ipresIGCons (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD'' \\<and>\n    ipresIGFreshAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD'' \\<and>\n    ipresIGSwapAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "by auto"], ["", "lemma comp_FSbImorph:\nassumes \"igWlsAbsIsInBar MOD\"\nand \"FSbImorph h hA MOD MOD'\" and \"FSbImorph h' hA' MOD' MOD''\"\nshows \"FSbImorph (h' o h) (hA' o hA) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FSbImorph (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  igWlsAbsIsInBar MOD\n  FSbImorph h hA MOD MOD'\n  FSbImorph h' hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. FSbImorph (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "unfolding FSbImorph_def"], ["proof (prove)\nusing this:\n  igWlsAbsIsInBar MOD\n  ipresIGWlsAll h hA MOD MOD' \\<and>\n  ipresIGCons h hA MOD MOD' \\<and>\n  ipresIGFreshAll h hA MOD MOD' \\<and> ipresIGSubstAll h hA MOD MOD'\n  ipresIGWlsAll h' hA' MOD' MOD'' \\<and>\n  ipresIGCons h' hA' MOD' MOD'' \\<and>\n  ipresIGFreshAll h' hA' MOD' MOD'' \\<and> ipresIGSubstAll h' hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. ipresIGWlsAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD'' \\<and>\n    ipresIGCons (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD'' \\<and>\n    ipresIGFreshAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD'' \\<and>\n    ipresIGSubstAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "using comp_ipresIGWlsAll comp_ipresIGCons\ncomp_ipresIGFreshAll comp_ipresIGSubstAll"], ["proof (prove)\nusing this:\n  igWlsAbsIsInBar MOD\n  ipresIGWlsAll h hA MOD MOD' \\<and>\n  ipresIGCons h hA MOD MOD' \\<and>\n  ipresIGFreshAll h hA MOD MOD' \\<and> ipresIGSubstAll h hA MOD MOD'\n  ipresIGWlsAll h' hA' MOD' MOD'' \\<and>\n  ipresIGCons h' hA' MOD' MOD'' \\<and>\n  ipresIGFreshAll h' hA' MOD' MOD'' \\<and> ipresIGSubstAll h' hA' MOD' MOD''\n  \\<lbrakk>ipresIGWlsAll ?h ?hA ?MOD ?MOD';\n   ipresIGWlsAll ?h' ?hA' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGWlsAll (?h' \\<circ> ?h) (?hA' \\<circ> ?hA) ?MOD\n                     ?MOD''\n  \\<lbrakk>ipresIGWlsAll ?h ?hA ?MOD ?MOD'; ipresIGCons ?h ?hA ?MOD ?MOD';\n   ipresIGCons ?h' ?hA' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGCons (?h' \\<circ> ?h) (?hA' \\<circ> ?hA) ?MOD\n                     ?MOD''\n  \\<lbrakk>ipresIGWlsAll ?h ?hA ?MOD ?MOD';\n   ipresIGFreshAll ?h ?hA ?MOD ?MOD';\n   ipresIGFreshAll ?h' ?hA' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGFreshAll (?h' \\<circ> ?h) (?hA' \\<circ> ?hA) ?MOD\n                     ?MOD''\n  \\<lbrakk>igWlsAbsIsInBar ?MOD; ipresIGWlsAll ?h ?hA ?MOD ?MOD';\n   ipresIGSubstAll ?h ?hA ?MOD ?MOD';\n   ipresIGSubstAll ?h' ?hA' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGSubstAll (?h' \\<circ> ?h) (?hA' \\<circ> ?hA) ?MOD\n                     ?MOD''\n\ngoal (1 subgoal):\n 1. ipresIGWlsAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD'' \\<and>\n    ipresIGCons (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD'' \\<and>\n    ipresIGFreshAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD'' \\<and>\n    ipresIGSubstAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "by auto"], ["", "lemma comp_FSwSbImorph:\nassumes \"igWlsAbsIsInBar MOD\"\nand \"FSwSbImorph h hA MOD MOD'\" and \"FSwSbImorph h' hA' MOD' MOD''\"\nshows \"FSwSbImorph (h' o h) (hA' o hA) MOD MOD''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FSwSbImorph (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "using assms"], ["proof (prove)\nusing this:\n  igWlsAbsIsInBar MOD\n  FSwSbImorph h hA MOD MOD'\n  FSwSbImorph h' hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. FSwSbImorph (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "unfolding FSwSbImorph_def"], ["proof (prove)\nusing this:\n  igWlsAbsIsInBar MOD\n  FSwImorph h hA MOD MOD' \\<and> ipresIGSubstAll h hA MOD MOD'\n  FSwImorph h' hA' MOD' MOD'' \\<and> ipresIGSubstAll h' hA' MOD' MOD''\n\ngoal (1 subgoal):\n 1. FSwImorph (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD'' \\<and>\n    ipresIGSubstAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "using comp_FSwImorph FSwImorph_def comp_ipresIGSubstAll FixSyn_axioms"], ["proof (prove)\nusing this:\n  igWlsAbsIsInBar MOD\n  FSwImorph h hA MOD MOD' \\<and> ipresIGSubstAll h hA MOD MOD'\n  FSwImorph h' hA' MOD' MOD'' \\<and> ipresIGSubstAll h' hA' MOD' MOD''\n  \\<lbrakk>FSwImorph ?h ?hA ?MOD ?MOD';\n   FSwImorph ?h' ?hA' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> FSwImorph (?h' \\<circ> ?h) (?hA' \\<circ> ?hA) ?MOD\n                     ?MOD''\n  FSwImorph ?h ?hA ?MOD ?MOD' \\<equiv>\n  ipresIGWlsAll ?h ?hA ?MOD ?MOD' \\<and>\n  ipresIGCons ?h ?hA ?MOD ?MOD' \\<and>\n  ipresIGFreshAll ?h ?hA ?MOD ?MOD' \\<and> ipresIGSwapAll ?h ?hA ?MOD ?MOD'\n  \\<lbrakk>igWlsAbsIsInBar ?MOD; ipresIGWlsAll ?h ?hA ?MOD ?MOD';\n   ipresIGSubstAll ?h ?hA ?MOD ?MOD';\n   ipresIGSubstAll ?h' ?hA' ?MOD' ?MOD''\\<rbrakk>\n  \\<Longrightarrow> ipresIGSubstAll (?h' \\<circ> ?h) (?hA' \\<circ> ?hA) ?MOD\n                     ?MOD''\n  FixSyn TYPE('var) Delta\n\ngoal (1 subgoal):\n 1. FSwImorph (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD'' \\<and>\n    ipresIGSubstAll (h' \\<circ> h) (hA' \\<circ> hA) MOD MOD''", "by blast"], ["", "subsection \\<open>The term model\\<close>"], ["", "text \\<open>We show that terms form fresh-swap-subst and fresh-subst-swap models.\\<close>"], ["", "subsubsection \\<open>Definitions and simplification rules\\<close>"], ["", "definition termMOD where\n\"termMOD ==\n \\<lparr>igWls = wls, igWlsAbs = wlsAbs,\n  igVar = Var, igAbs = Abs, igOp = Op,\n  igFresh = fresh, igFreshAbs = freshAbs,\n  igSwap = swap, igSwapAbs = swapAbs,\n  igSubst = subst, igSubstAbs = substAbs\\<rparr>\""], ["", "lemma igWls_termMOD[simp]: \"igWls termMOD = wls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls termMOD = wls", "unfolding termMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls\n     \\<lparr>igWls = wls, igWlsAbs = wlsAbs, igVar = Var, igAbs = Abs,\n        igOp = Op, igFresh = fresh, igFreshAbs = freshAbs, igSwap = swap,\n        igSwapAbs = swapAbs, igSubst = subst,\n        igSubstAbs = substAbs\\<rparr> =\n    wls", "by simp"], ["", "lemma igWlsAbs_termMOD[simp]: \"igWlsAbs termMOD = wlsAbs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAbs termMOD = wlsAbs", "unfolding termMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAbs\n     \\<lparr>igWls = wls, igWlsAbs = wlsAbs, igVar = Var, igAbs = Abs,\n        igOp = Op, igFresh = fresh, igFreshAbs = freshAbs, igSwap = swap,\n        igSwapAbs = swapAbs, igSubst = subst,\n        igSubstAbs = substAbs\\<rparr> =\n    wlsAbs", "by simp"], ["", "lemma igWlsInp_termMOD_wlsInp[simp]:\n\"igWlsInp termMOD delta inp = wlsInp delta inp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp termMOD delta inp = wlsInp delta inp", "unfolding igWlsInp_def wlsInp_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (wlsOpS delta \\<and>\n     sameDom (arOf delta) inp \\<and>\n     liftAll2 (igWls termMOD) (arOf delta) inp) =\n    (wlsOpS delta \\<and>\n     sameDom (arOf delta) inp \\<and> liftAll2 wls (arOf delta) inp)", "by simp"], ["", "lemma igWlsBinp_termMOD_wlsBinp[simp]:\n\"igWlsBinp termMOD delta binp = wlsBinp delta binp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsBinp termMOD delta binp = wlsBinp delta binp", "unfolding igWlsBinp_def wlsBinp_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (wlsOpS delta \\<and>\n     sameDom (barOf delta) binp \\<and>\n     liftAll2 (igWlsAbs termMOD) (barOf delta) binp) =\n    (wlsOpS delta \\<and>\n     sameDom (barOf delta) binp \\<and> liftAll2 wlsAbs (barOf delta) binp)", "by simp"], ["", "lemmas igWlsAll_termMOD_simps =\nigWls_termMOD igWlsAbs_termMOD\nigWlsInp_termMOD_wlsInp igWlsBinp_termMOD_wlsBinp"], ["", "lemma igVar_termMOD[simp]: \"igVar termMOD = Var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igVar termMOD = Var", "unfolding termMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igVar\n     \\<lparr>igWls = wls, igWlsAbs = wlsAbs, igVar = Var, igAbs = Abs,\n        igOp = Op, igFresh = fresh, igFreshAbs = freshAbs, igSwap = swap,\n        igSwapAbs = swapAbs, igSubst = subst,\n        igSubstAbs = substAbs\\<rparr> =\n    Var", "by simp"], ["", "lemma igAbs_termMOD[simp]: \"igAbs termMOD = Abs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs termMOD = Abs", "unfolding termMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs\n     \\<lparr>igWls = wls, igWlsAbs = wlsAbs, igVar = Var, igAbs = Abs,\n        igOp = Op, igFresh = fresh, igFreshAbs = freshAbs, igSwap = swap,\n        igSwapAbs = swapAbs, igSubst = subst,\n        igSubstAbs = substAbs\\<rparr> =\n    Abs", "by simp"], ["", "lemma igOp_termMOD[simp]: \"igOp termMOD = Op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igOp termMOD = Op", "unfolding termMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igOp\n     \\<lparr>igWls = wls, igWlsAbs = wlsAbs, igVar = Var, igAbs = Abs,\n        igOp = Op, igFresh = fresh, igFreshAbs = freshAbs, igSwap = swap,\n        igSwapAbs = swapAbs, igSubst = subst,\n        igSubstAbs = substAbs\\<rparr> =\n    Op", "by simp"], ["", "lemmas igCons_termMOD_simps =\nigVar_termMOD igAbs_termMOD igOp_termMOD"], ["", "lemma igFresh_termMOD[simp]: \"igFresh termMOD = fresh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFresh termMOD = fresh", "unfolding termMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igFresh\n     \\<lparr>igWls = wls, igWlsAbs = wlsAbs, igVar = Var, igAbs = Abs,\n        igOp = Op, igFresh = fresh, igFreshAbs = freshAbs, igSwap = swap,\n        igSwapAbs = swapAbs, igSubst = subst,\n        igSubstAbs = substAbs\\<rparr> =\n    fresh", "by simp"], ["", "lemma igFreshAbs_termMOD[simp]: \"igFreshAbs termMOD = freshAbs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshAbs termMOD = freshAbs", "unfolding termMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshAbs\n     \\<lparr>igWls = wls, igWlsAbs = wlsAbs, igVar = Var, igAbs = Abs,\n        igOp = Op, igFresh = fresh, igFreshAbs = freshAbs, igSwap = swap,\n        igSwapAbs = swapAbs, igSubst = subst,\n        igSubstAbs = substAbs\\<rparr> =\n    freshAbs", "by simp"], ["", "lemma igFreshInp_termMOD[simp]: \"igFreshInp termMOD = freshInp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshInp termMOD = freshInp", "unfolding igFreshInp_def[abs_def] freshInp_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ys y. liftAll (igFresh termMOD ys y)) =\n    (\\<lambda>xs x. liftAll (fresh xs x))", "by simp"], ["", "lemma igFreshBinp_termMOD[simp]: \"igFreshBinp termMOD = freshBinp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshBinp termMOD = freshBinp", "unfolding igFreshBinp_def[abs_def] freshBinp_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ys y. liftAll (igFreshAbs termMOD ys y)) =\n    (\\<lambda>xs x. liftAll (freshAbs xs x))", "by simp"], ["", "lemmas igFreshAll_termMOD_simps =\nigFresh_termMOD igFreshAbs_termMOD\nigFreshInp_termMOD igFreshBinp_termMOD"], ["", "lemma igSwap_termMOD[simp]: \"igSwap termMOD = swap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwap termMOD = swap", "unfolding termMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwap\n     \\<lparr>igWls = wls, igWlsAbs = wlsAbs, igVar = Var, igAbs = Abs,\n        igOp = Op, igFresh = fresh, igFreshAbs = freshAbs, igSwap = swap,\n        igSwapAbs = swapAbs, igSubst = subst,\n        igSubstAbs = substAbs\\<rparr> =\n    swap", "by simp"], ["", "lemma igSwapAbs_termMOD[simp]: \"igSwapAbs termMOD = swapAbs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapAbs termMOD = swapAbs", "unfolding termMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapAbs\n     \\<lparr>igWls = wls, igWlsAbs = wlsAbs, igVar = Var, igAbs = Abs,\n        igOp = Op, igFresh = fresh, igFreshAbs = freshAbs, igSwap = swap,\n        igSwapAbs = swapAbs, igSubst = subst,\n        igSubstAbs = substAbs\\<rparr> =\n    swapAbs", "by simp"], ["", "lemma igSwapInp_termMOD[simp]: \"igSwapInp termMOD = swapInp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapInp termMOD = swapInp", "unfolding igSwapInp_def[abs_def] swapInp_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>zs z1 z2. lift (igSwap termMOD zs z1 z2)) =\n    (\\<lambda>xs x y. lift (swap xs x y))", "by simp"], ["", "lemma igSwapBinp_termMOD[simp]: \"igSwapBinp termMOD = swapBinp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapBinp termMOD = swapBinp", "unfolding igSwapBinp_def[abs_def] swapBinp_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>zs z1 z2. lift (igSwapAbs termMOD zs z1 z2)) =\n    (\\<lambda>xs x y. lift (swapAbs xs x y))", "by simp"], ["", "lemmas igSwapAll_termMOD_simps =\nigSwap_termMOD igSwapAbs_termMOD\nigSwapInp_termMOD igSwapBinp_termMOD"], ["", "lemma igSubst_termMOD[simp]: \"igSubst termMOD = subst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubst termMOD = subst", "unfolding termMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubst\n     \\<lparr>igWls = wls, igWlsAbs = wlsAbs, igVar = Var, igAbs = Abs,\n        igOp = Op, igFresh = fresh, igFreshAbs = freshAbs, igSwap = swap,\n        igSwapAbs = swapAbs, igSubst = subst,\n        igSubstAbs = substAbs\\<rparr> =\n    subst", "by simp"], ["", "lemma igSubstAbs_termMOD[simp]: \"igSubstAbs termMOD = substAbs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAbs termMOD = substAbs", "unfolding termMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAbs\n     \\<lparr>igWls = wls, igWlsAbs = wlsAbs, igVar = Var, igAbs = Abs,\n        igOp = Op, igFresh = fresh, igFreshAbs = freshAbs, igSwap = swap,\n        igSwapAbs = swapAbs, igSubst = subst,\n        igSubstAbs = substAbs\\<rparr> =\n    substAbs", "by simp"], ["", "lemma igSubstInp_termMOD[simp]: \"igSubstInp termMOD = substInp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstInp termMOD = substInp", "by (simp add: igSubstInp_def[abs_def] substInp_def[abs_def]  \npsubstInp_def[abs_def] subst_def)"], ["", "lemma igSubstBinp_termMOD[simp]: \"igSubstBinp termMOD = substBinp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstBinp termMOD = substBinp", "by (simp add: igSubstBinp_def[abs_def] substBinp_def[abs_def]  \npsubstBinp_def[abs_def] substAbs_def)"], ["", "lemmas igSubstAll_termMOD_simps =\nigSubst_termMOD igSubstAbs_termMOD\nigSubstInp_termMOD igSubstBinp_termMOD"], ["", "lemmas structure_termMOD_simps =\nigWlsAll_termMOD_simps\nigFreshAll_termMOD_simps\nigSwapAll_termMOD_simps\nigSubstAll_termMOD_simps"], ["", "subsubsection \\<open>Well-sortedness of the term model\\<close>"], ["", "text\\<open>Domains are disjoint:\\<close>"], ["", "lemma termMOD_igWlsDisj: \"igWlsDisj termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsDisj termMOD", "unfolding igWlsDisj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s s' X.\n       igWls termMOD s X \\<and> igWls termMOD s' X \\<longrightarrow> s = s'", "using wls_disjoint"], ["proof (prove)\nusing this:\n  \\<lbrakk>wls ?s ?X; wls ?s' ?X\\<rbrakk> \\<Longrightarrow> ?s = ?s'\n\ngoal (1 subgoal):\n 1. \\<forall>s s' X.\n       igWls termMOD s X \\<and> igWls termMOD s' X \\<longrightarrow> s = s'", "by auto"], ["", "lemma termMOD_igWlsAbsDisj: \"igWlsAbsDisj termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAbsDisj termMOD", "unfolding igWlsAbsDisj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs s xs' s' A.\n       isInBar (xs, s) \\<and>\n       isInBar (xs', s') \\<and>\n       igWlsAbs termMOD (xs, s) A \\<and>\n       igWlsAbs termMOD (xs', s') A \\<longrightarrow>\n       xs = xs' \\<and> s = s'", "using wlsAbs_disjoint"], ["proof (prove)\nusing this:\n  \\<lbrakk>wlsAbs (?xs, ?s) ?A; wlsAbs (?xs', ?s') ?A\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?xs' \\<and> ?s = ?s'\n\ngoal (1 subgoal):\n 1. \\<forall>xs s xs' s' A.\n       isInBar (xs, s) \\<and>\n       isInBar (xs', s') \\<and>\n       igWlsAbs termMOD (xs, s) A \\<and>\n       igWlsAbs termMOD (xs', s') A \\<longrightarrow>\n       xs = xs' \\<and> s = s'", "by auto"], ["", "lemma termMOD_igWlsAllDisj: \"igWlsAllDisj termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAllDisj termMOD", "unfolding igWlsAllDisj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsDisj termMOD \\<and> igWlsAbsDisj termMOD", "using termMOD_igWlsDisj termMOD_igWlsAbsDisj"], ["proof (prove)\nusing this:\n  igWlsDisj termMOD\n  igWlsAbsDisj termMOD\n\ngoal (1 subgoal):\n 1. igWlsDisj termMOD \\<and> igWlsAbsDisj termMOD", "by simp"], ["", "text \\<open>Abstraction domains inhabited only within bound arities:\\<close>"], ["", "lemma termMOD_igWlsAbsIsInBar: \"igWlsAbsIsInBar termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAbsIsInBar termMOD", "unfolding igWlsAbsIsInBar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>us s A.\n       igWlsAbs termMOD (us, s) A \\<longrightarrow> isInBar (us, s)", "using wlsAbs_nchotomy"], ["proof (prove)\nusing this:\n  wlsAbs (?xs, ?s) ?A \\<Longrightarrow>\n  isInBar (?xs, ?s) \\<and> (\\<exists>x X. wls ?s X \\<and> ?A = Abs ?xs x X)\n\ngoal (1 subgoal):\n 1. \\<forall>us s A.\n       igWlsAbs termMOD (us, s) A \\<longrightarrow> isInBar (us, s)", "by simp"], ["", "text\\<open>The syntactic constructs preserve the domains:\\<close>"], ["", "lemma termMOD_igVarIPresIGWls: \"igVarIPresIGWls termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igVarIPresIGWls termMOD", "unfolding igVarIPresIGWls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs x. igWls termMOD (asSort xs) (igVar termMOD xs x)", "by simp"], ["", "lemma termMOD_igAbsIPresIGWls: \"igAbsIPresIGWls termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbsIPresIGWls termMOD", "unfolding igAbsIPresIGWls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs s x X.\n       isInBar (xs, s) \\<and> igWls termMOD s X \\<longrightarrow>\n       igWlsAbs termMOD (xs, s) (igAbs termMOD xs x X)", "by simp"], ["", "lemma termMOD_igOpIPresIGWls: \"igOpIPresIGWls termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igOpIPresIGWls termMOD", "unfolding igOpIPresIGWls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>delta inp binp.\n       igWlsInp termMOD delta inp \\<and>\n       igWlsBinp termMOD delta binp \\<longrightarrow>\n       igWls termMOD (stOf delta) (igOp termMOD delta inp binp)", "by simp"], ["", "lemma termMOD_igConsIPresIGWls: \"igConsIPresIGWls termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igConsIPresIGWls termMOD", "unfolding igConsIPresIGWls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igVarIPresIGWls termMOD \\<and>\n    igAbsIPresIGWls termMOD \\<and> igOpIPresIGWls termMOD", "using termMOD_igVarIPresIGWls termMOD_igAbsIPresIGWls termMOD_igOpIPresIGWls"], ["proof (prove)\nusing this:\n  igVarIPresIGWls termMOD\n  igAbsIPresIGWls termMOD\n  igOpIPresIGWls termMOD\n\ngoal (1 subgoal):\n 1. igVarIPresIGWls termMOD \\<and>\n    igAbsIPresIGWls termMOD \\<and> igOpIPresIGWls termMOD", "by auto"], ["", "text\\<open>Swap preserves the domains:\\<close>"], ["", "lemma termMOD_igSwapIPresIGWls: \"igSwapIPresIGWls termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIPresIGWls termMOD", "unfolding igSwapIPresIGWls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 s X.\n       igWls termMOD s X \\<longrightarrow>\n       igWls termMOD s (igSwap termMOD zs z1 z2 X)", "by simp"], ["", "lemma termMOD_igSwapAbsIPresIGWlsAbs: \"igSwapAbsIPresIGWlsAbs termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapAbsIPresIGWlsAbs termMOD", "unfolding igSwapAbsIPresIGWlsAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 us s A.\n       isInBar (us, s) \\<and> igWlsAbs termMOD (us, s) A \\<longrightarrow>\n       igWlsAbs termMOD (us, s) (igSwapAbs termMOD zs z1 z2 A)", "by simp"], ["", "lemma termMOD_igSwapAllIPresIGWlsAll: \"igSwapAllIPresIGWlsAll termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapAllIPresIGWlsAll termMOD", "unfolding igSwapAllIPresIGWlsAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIPresIGWls termMOD \\<and> igSwapAbsIPresIGWlsAbs termMOD", "using termMOD_igSwapIPresIGWls termMOD_igSwapAbsIPresIGWlsAbs"], ["proof (prove)\nusing this:\n  igSwapIPresIGWls termMOD\n  igSwapAbsIPresIGWlsAbs termMOD\n\ngoal (1 subgoal):\n 1. igSwapIPresIGWls termMOD \\<and> igSwapAbsIPresIGWlsAbs termMOD", "by auto"], ["", "text\\<open>``Subst\" preserves the domains:\\<close>"], ["", "lemma termMOD_igSubstIPresIGWls: \"igSubstIPresIGWls termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIPresIGWls termMOD", "unfolding igSubstIPresIGWls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys Y y s X.\n       igWls termMOD (asSort ys) Y \\<and>\n       igWls termMOD s X \\<longrightarrow>\n       igWls termMOD s (igSubst termMOD ys Y y X)", "by simp"], ["", "lemma termMOD_igSubstAbsIPresIGWlsAbs: \"igSubstAbsIPresIGWlsAbs termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAbsIPresIGWlsAbs termMOD", "unfolding igSubstAbsIPresIGWlsAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys Y y us s A.\n       isInBar (us, s) \\<and>\n       igWls termMOD (asSort ys) Y \\<and>\n       igWlsAbs termMOD (us, s) A \\<longrightarrow>\n       igWlsAbs termMOD (us, s) (igSubstAbs termMOD ys Y y A)", "by simp"], ["", "lemma termMOD_igSubstAllIPresIGWlsAll: \"igSubstAllIPresIGWlsAll termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAllIPresIGWlsAll termMOD", "unfolding igSubstAllIPresIGWlsAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIPresIGWls termMOD \\<and> igSubstAbsIPresIGWlsAbs termMOD", "using termMOD_igSubstIPresIGWls termMOD_igSubstAbsIPresIGWlsAbs"], ["proof (prove)\nusing this:\n  igSubstIPresIGWls termMOD\n  igSubstAbsIPresIGWlsAbs termMOD\n\ngoal (1 subgoal):\n 1. igSubstIPresIGWls termMOD \\<and> igSubstAbsIPresIGWlsAbs termMOD", "by auto"], ["", "text\\<open>The ``fresh\" clauses hold:\\<close>"], ["", "lemma termMOD_igFreshIGVar: \"igFreshIGVar termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshIGVar termMOD", "unfolding igFreshIGVar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y xs x.\n       ys \\<noteq> xs \\<or> y \\<noteq> x \\<longrightarrow>\n       igFresh termMOD ys y (igVar termMOD xs x)", "by simp"], ["", "lemma termMOD_igFreshIGAbs1: \"igFreshIGAbs1 termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshIGAbs1 termMOD", "unfolding igFreshIGAbs1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y s X.\n       isInBar (ys, s) \\<and> igWls termMOD s X \\<longrightarrow>\n       igFreshAbs termMOD ys y (igAbs termMOD ys y X)", "by auto"], ["", "lemma termMOD_igFreshIGAbs2: \"igFreshIGAbs2 termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshIGAbs2 termMOD", "unfolding igFreshIGAbs2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y xs x s X.\n       isInBar (xs, s) \\<and> igWls termMOD s X \\<longrightarrow>\n       igFresh termMOD ys y X \\<longrightarrow>\n       igFreshAbs termMOD ys y (igAbs termMOD xs x X)", "by auto"], ["", "lemma termMOD_igFreshIGOp: \"igFreshIGOp termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshIGOp termMOD", "unfolding igFreshIGOp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y delta inp binp.\n       igWlsInp termMOD delta inp \\<and>\n       igWlsBinp termMOD delta binp \\<longrightarrow>\n       igFreshInp termMOD ys y inp \\<and>\n       igFreshBinp termMOD ys y binp \\<longrightarrow>\n       igFresh termMOD ys y (igOp termMOD delta inp binp)", "by simp"], ["", "lemma termMOD_igFreshCls: \"igFreshCls termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshCls termMOD", "unfolding igFreshCls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshIGVar termMOD \\<and>\n    igFreshIGAbs1 termMOD \\<and>\n    igFreshIGAbs2 termMOD \\<and> igFreshIGOp termMOD", "using termMOD_igFreshIGVar termMOD_igFreshIGAbs1 termMOD_igFreshIGAbs2 termMOD_igFreshIGOp"], ["proof (prove)\nusing this:\n  igFreshIGVar termMOD\n  igFreshIGAbs1 termMOD\n  igFreshIGAbs2 termMOD\n  igFreshIGOp termMOD\n\ngoal (1 subgoal):\n 1. igFreshIGVar termMOD \\<and>\n    igFreshIGAbs1 termMOD \\<and>\n    igFreshIGAbs2 termMOD \\<and> igFreshIGOp termMOD", "by simp"], ["", "text\\<open>The ``swap\" clauses hold:\\<close>"], ["", "lemma termMOD_igSwapIGVar: \"igSwapIGVar termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIGVar termMOD", "unfolding igSwapIGVar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 xs x.\n       igSwap termMOD zs z1 z2 (igVar termMOD xs x) =\n       igVar termMOD xs (x @xs[z1 \\<and> z2]_zs)", "by simp"], ["", "lemma termMOD_igSwapIGAbs: \"igSwapIGAbs termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIGAbs termMOD", "unfolding igSwapIGAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 xs x s X.\n       isInBar (xs, s) \\<and> igWls termMOD s X \\<longrightarrow>\n       igSwapAbs termMOD zs z1 z2 (igAbs termMOD xs x X) =\n       igAbs termMOD xs (x @xs[z1 \\<and> z2]_zs) (igSwap termMOD zs z1 z2 X)", "by auto"], ["", "lemma termMOD_igSwapIGOp: \"igSwapIGOp termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIGOp termMOD", "unfolding igSwapIGOp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 delta inp binp.\n       igWlsInp termMOD delta inp \\<and>\n       igWlsBinp termMOD delta binp \\<longrightarrow>\n       igSwap termMOD zs z1 z2 (igOp termMOD delta inp binp) =\n       igOp termMOD delta (igSwapInp termMOD zs z1 z2 inp)\n        (igSwapBinp termMOD zs z1 z2 binp)", "by simp"], ["", "lemma termMOD_igSwapCls: \"igSwapCls termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapCls termMOD", "unfolding igSwapCls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIGVar termMOD \\<and> igSwapIGAbs termMOD \\<and> igSwapIGOp termMOD", "using termMOD_igSwapIGVar termMOD_igSwapIGAbs termMOD_igSwapIGOp"], ["proof (prove)\nusing this:\n  igSwapIGVar termMOD\n  igSwapIGAbs termMOD\n  igSwapIGOp termMOD\n\ngoal (1 subgoal):\n 1. igSwapIGVar termMOD \\<and> igSwapIGAbs termMOD \\<and> igSwapIGOp termMOD", "by simp"], ["", "text\\<open>The ``subst\" clauses hold:\\<close>"], ["", "lemma termMOD_igSubstIGVar1: \"igSubstIGVar1 termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGVar1 termMOD", "unfolding igSubstIGVar1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y Y xs x.\n       igWls termMOD (asSort ys) Y \\<longrightarrow>\n       ys \\<noteq> xs \\<or> y \\<noteq> x \\<longrightarrow>\n       igSubst termMOD ys Y y (igVar termMOD xs x) = igVar termMOD xs x", "by auto"], ["", "lemma termMOD_igSubstIGVar2: \"igSubstIGVar2 termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGVar2 termMOD", "unfolding igSubstIGVar2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y Y.\n       igWls termMOD (asSort ys) Y \\<longrightarrow>\n       igSubst termMOD ys Y y (igVar termMOD ys y) = Y", "by auto"], ["", "lemma termMOD_igSubstIGAbs: \"igSubstIGAbs termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGAbs termMOD", "unfolding igSubstIGAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y Y xs x s X.\n       isInBar (xs, s) \\<and>\n       igWls termMOD (asSort ys) Y \\<and>\n       igWls termMOD s X \\<longrightarrow>\n       (xs \\<noteq> ys \\<or> x \\<noteq> y) \\<and>\n       igFresh termMOD xs x Y \\<longrightarrow>\n       igSubstAbs termMOD ys Y y (igAbs termMOD xs x X) =\n       igAbs termMOD xs x (igSubst termMOD ys Y y X)", "by auto"], ["", "lemma termMOD_igSubstIGOp: \"igSubstIGOp termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGOp termMOD", "unfolding igSubstIGOp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y Y delta inp binp.\n       igWls termMOD (asSort ys) Y \\<and>\n       igWlsInp termMOD delta inp \\<and>\n       igWlsBinp termMOD delta binp \\<longrightarrow>\n       igSubst termMOD ys Y y (igOp termMOD delta inp binp) =\n       igOp termMOD delta (igSubstInp termMOD ys Y y inp)\n        (igSubstBinp termMOD ys Y y binp)", "by simp"], ["", "lemma termMOD_igSubstCls: \"igSubstCls termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstCls termMOD", "unfolding igSubstCls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGVar1 termMOD \\<and>\n    igSubstIGVar2 termMOD \\<and>\n    igSubstIGAbs termMOD \\<and> igSubstIGOp termMOD", "using termMOD_igSubstIGVar1 termMOD_igSubstIGVar2\ntermMOD_igSubstIGAbs termMOD_igSubstIGOp"], ["proof (prove)\nusing this:\n  igSubstIGVar1 termMOD\n  igSubstIGVar2 termMOD\n  igSubstIGAbs termMOD\n  igSubstIGOp termMOD\n\ngoal (1 subgoal):\n 1. igSubstIGVar1 termMOD \\<and>\n    igSubstIGVar2 termMOD \\<and>\n    igSubstIGAbs termMOD \\<and> igSubstIGOp termMOD", "by simp"], ["", "text\\<open>The swap-congruence clause for abstractions holds:\\<close>"], ["", "lemma termMOD_igAbsCongS: \"igAbsCongS termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbsCongS termMOD", "unfolding igAbsCongS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs x x' y s X X'.\n       isInBar (xs, s) \\<and>\n       igWls termMOD s X \\<and> igWls termMOD s X' \\<longrightarrow>\n       igFresh termMOD xs y X \\<and>\n       igFresh termMOD xs y X' \\<and>\n       igSwap termMOD xs y x X = igSwap termMOD xs y x' X' \\<longrightarrow>\n       igAbs termMOD xs x X = igAbs termMOD xs x' X'", "using wls_Abs_swap_cong"], ["proof (prove)\nusing this:\n  \\<lbrakk>wls ?s ?X; wls ?s ?X'; fresh ?xs ?y ?X; fresh ?xs ?y ?X';\n   ?X #[?y \\<and> ?x]_?xs = ?X' #[?y \\<and> ?x']_?xs\\<rbrakk>\n  \\<Longrightarrow> Abs ?xs ?x ?X = Abs ?xs ?x' ?X'\n\ngoal (1 subgoal):\n 1. \\<forall>xs x x' y s X X'.\n       isInBar (xs, s) \\<and>\n       igWls termMOD s X \\<and> igWls termMOD s X' \\<longrightarrow>\n       igFresh termMOD xs y X \\<and>\n       igFresh termMOD xs y X' \\<and>\n       igSwap termMOD xs y x X = igSwap termMOD xs y x' X' \\<longrightarrow>\n       igAbs termMOD xs x X = igAbs termMOD xs x' X'", "by (metis igAbs_termMOD igFresh_termMOD igSwap_termMOD igWls_termMOD)"], ["", "text\\<open>The subst-renaming clause for abstractions holds:\\<close>"], ["", "lemma termMOD_igAbsRen: \"igAbsRen termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbsRen termMOD", "unfolding igAbsRen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs y x s X.\n       isInBar (xs, s) \\<and> igWls termMOD s X \\<longrightarrow>\n       igFresh termMOD xs y X \\<longrightarrow>\n       igAbs termMOD xs y (igSubst termMOD xs (igVar termMOD xs y) x X) =\n       igAbs termMOD xs x X", "by auto"], ["", "lemma termMOD_iwlsFSw: \"iwlsFSw termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSw termMOD", "unfolding iwlsFSw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAllDisj termMOD \\<and>\n    igWlsAbsIsInBar termMOD \\<and>\n    igConsIPresIGWls termMOD \\<and>\n    igSwapAllIPresIGWlsAll termMOD \\<and>\n    igFreshCls termMOD \\<and> igSwapCls termMOD \\<and> igAbsCongS termMOD", "using\ntermMOD_igWlsAllDisj termMOD_igWlsAbsIsInBar\ntermMOD_igConsIPresIGWls termMOD_igSwapAllIPresIGWlsAll\ntermMOD_igFreshCls termMOD_igSwapCls termMOD_igAbsCongS"], ["proof (prove)\nusing this:\n  igWlsAllDisj termMOD\n  igWlsAbsIsInBar termMOD\n  igConsIPresIGWls termMOD\n  igSwapAllIPresIGWlsAll termMOD\n  igFreshCls termMOD\n  igSwapCls termMOD\n  igAbsCongS termMOD\n\ngoal (1 subgoal):\n 1. igWlsAllDisj termMOD \\<and>\n    igWlsAbsIsInBar termMOD \\<and>\n    igConsIPresIGWls termMOD \\<and>\n    igSwapAllIPresIGWlsAll termMOD \\<and>\n    igFreshCls termMOD \\<and> igSwapCls termMOD \\<and> igAbsCongS termMOD", "by auto"], ["", "lemma termMOD_iwlsFSb: \"iwlsFSb termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSb termMOD", "unfolding iwlsFSb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAllDisj termMOD \\<and>\n    igWlsAbsIsInBar termMOD \\<and>\n    igConsIPresIGWls termMOD \\<and>\n    igSubstAllIPresIGWlsAll termMOD \\<and>\n    igFreshCls termMOD \\<and> igSubstCls termMOD \\<and> igAbsRen termMOD", "using\ntermMOD_igWlsAllDisj termMOD_igWlsAbsIsInBar\ntermMOD_igConsIPresIGWls termMOD_igSubstAllIPresIGWlsAll\ntermMOD_igFreshCls termMOD_igSubstCls termMOD_igAbsRen"], ["proof (prove)\nusing this:\n  igWlsAllDisj termMOD\n  igWlsAbsIsInBar termMOD\n  igConsIPresIGWls termMOD\n  igSubstAllIPresIGWlsAll termMOD\n  igFreshCls termMOD\n  igSubstCls termMOD\n  igAbsRen termMOD\n\ngoal (1 subgoal):\n 1. igWlsAllDisj termMOD \\<and>\n    igWlsAbsIsInBar termMOD \\<and>\n    igConsIPresIGWls termMOD \\<and>\n    igSubstAllIPresIGWlsAll termMOD \\<and>\n    igFreshCls termMOD \\<and> igSubstCls termMOD \\<and> igAbsRen termMOD", "by auto"], ["", "lemma termMOD_iwlsFSwSb: \"iwlsFSwSb termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSwSb termMOD", "unfolding iwlsFSwSb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSw termMOD \\<and>\n    igSubstAllIPresIGWlsAll termMOD \\<and> igSubstCls termMOD", "using termMOD_iwlsFSw termMOD_igSubstAllIPresIGWlsAll termMOD_igSubstCls"], ["proof (prove)\nusing this:\n  iwlsFSw termMOD\n  igSubstAllIPresIGWlsAll termMOD\n  igSubstCls termMOD\n\ngoal (1 subgoal):\n 1. iwlsFSw termMOD \\<and>\n    igSubstAllIPresIGWlsAll termMOD \\<and> igSubstCls termMOD", "by simp"], ["", "lemma termMOD_iwlsFSbSw: \"iwlsFSbSw termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSbSw termMOD", "unfolding iwlsFSbSw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSb termMOD \\<and>\n    igSwapAllIPresIGWlsAll termMOD \\<and> igSwapCls termMOD", "using termMOD_iwlsFSb termMOD_igSwapAllIPresIGWlsAll termMOD_igSwapCls"], ["proof (prove)\nusing this:\n  iwlsFSb termMOD\n  igSwapAllIPresIGWlsAll termMOD\n  igSwapCls termMOD\n\ngoal (1 subgoal):\n 1. iwlsFSb termMOD \\<and>\n    igSwapAllIPresIGWlsAll termMOD \\<and> igSwapCls termMOD", "by simp"], ["", "subsubsection \\<open>Direct description of morphisms from the term models\\<close>"], ["", "(* We merely employ predicates referring directly to terms rather than\nmediating through the model structure of terms. *)"], ["", "definition ipresWls where\n\"ipresWls h MOD ==\n \\<forall> s X. wls s X \\<longrightarrow> igWls MOD s (h X)\""], ["", "lemma ipresIGWls_termMOD[simp]:\n\"ipresIGWls h termMOD MOD = ipresWls h MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGWls h termMOD MOD = ipresWls h MOD", "unfolding ipresIGWls_def ipresWls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>s X. igWls termMOD s X \\<longrightarrow> igWls MOD s (h X)) =\n    (\\<forall>s X. wls s X \\<longrightarrow> igWls MOD s (h X))", "by simp"], ["", "definition ipresWlsAbs where\n\"ipresWlsAbs hA MOD ==\n \\<forall> us s A. wlsAbs (us,s) A \\<longrightarrow> igWlsAbs MOD (us,s) (hA A)\""], ["", "lemma ipresIGWlsAbs_termMOD[simp]:\n\"ipresIGWlsAbs hA termMOD MOD = ipresWlsAbs hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGWlsAbs hA termMOD MOD = ipresWlsAbs hA MOD", "unfolding ipresIGWlsAbs_def ipresWlsAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>us s A.\n        igWlsAbs termMOD (us, s) A \\<longrightarrow>\n        igWlsAbs MOD (us, s) (hA A)) =\n    (\\<forall>us s A.\n        wlsAbs (us, s) A \\<longrightarrow> igWlsAbs MOD (us, s) (hA A))", "by simp"], ["", "definition ipresWlsAll where\n\"ipresWlsAll h hA MOD ==\n ipresWls h MOD \\<and> ipresWlsAbs hA MOD\""], ["", "lemmas ipresWlsAll_defs = ipresWlsAll_def\nipresWls_def ipresWlsAbs_def"], ["", "lemma ipresIGWlsAll_termMOD[simp]:\n\"ipresIGWlsAll h hA termMOD MOD = ipresWlsAll h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGWlsAll h hA termMOD MOD = ipresWlsAll h hA MOD", "unfolding ipresIGWlsAll_def ipresWlsAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipresIGWls h termMOD MOD \\<and> ipresIGWlsAbs hA termMOD MOD) =\n    (ipresWls h MOD \\<and> ipresWlsAbs hA MOD)", "by simp"], ["", "lemmas ipresIGWlsAll_termMOD_simps =\nipresIGWls_termMOD ipresIGWlsAbs_termMOD ipresIGWlsAll_termMOD"], ["", "definition ipresVar where\n\"ipresVar h MOD ==\n \\<forall> xs x. h (Var xs x) = igVar MOD xs x\""], ["", "lemma ipresIGVar_termMOD[simp]:\n\"ipresIGVar h termMOD MOD = ipresVar h MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGVar h termMOD MOD = ipresVar h MOD", "unfolding ipresIGVar_def ipresVar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>xs x. h (igVar termMOD xs x) = igVar MOD xs x) =\n    (\\<forall>xs x. h (Var xs x) = igVar MOD xs x)", "by simp"], ["", "definition ipresAbs where\n\"ipresAbs h hA MOD ==\n \\<forall> xs x s X. isInBar (xs,s) \\<and> wls s X \\<longrightarrow> hA (Abs xs x X) = igAbs MOD xs x (h X)\""], ["", "lemma ipresIGAbs_termMOD[simp]:\n\"ipresIGAbs h hA termMOD MOD = ipresAbs h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGAbs h hA termMOD MOD = ipresAbs h hA MOD", "unfolding ipresIGAbs_def ipresAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>xs x s X.\n        isInBar (xs, s) \\<and> igWls termMOD s X \\<longrightarrow>\n        hA (igAbs termMOD xs x X) = igAbs MOD xs x (h X)) =\n    (\\<forall>xs x s X.\n        isInBar (xs, s) \\<and> wls s X \\<longrightarrow>\n        hA (Abs xs x X) = igAbs MOD xs x (h X))", "by simp"], ["", "definition ipresOp where\n\"ipresOp h hA MOD ==\n \\<forall> delta inp binp.\n    wlsInp delta inp \\<and> wlsBinp delta binp \\<longrightarrow>\n    h (Op delta inp binp) =\n    igOp MOD delta (lift h inp) (lift hA binp)\""], ["", "lemma ipresIGOp_termMOD[simp]:\n\"ipresIGOp h hA termMOD MOD = ipresOp h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGOp h hA termMOD MOD = ipresOp h hA MOD", "unfolding ipresIGOp_def ipresOp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>delta inp binp.\n        igWlsInp termMOD delta inp \\<and>\n        igWlsBinp termMOD delta binp \\<longrightarrow>\n        h (igOp termMOD delta inp binp) =\n        igOp MOD delta (lift h inp) (lift hA binp)) =\n    (\\<forall>delta inp binp.\n        wlsInp delta inp \\<and> wlsBinp delta binp \\<longrightarrow>\n        h (Op delta inp binp) = igOp MOD delta (lift h inp) (lift hA binp))", "by simp"], ["", "definition ipresCons where\n\"ipresCons h hA MOD ==\n ipresVar h MOD \\<and>\n ipresAbs h hA MOD \\<and>\n ipresOp h hA MOD\""], ["", "lemmas ipresCons_defs = ipresCons_def\nipresVar_def\nipresAbs_def\nipresOp_def"], ["", "lemma ipresIGCons_termMOD[simp]:\n\"ipresIGCons h hA termMOD MOD = ipresCons h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGCons h hA termMOD MOD = ipresCons h hA MOD", "unfolding ipresIGCons_def ipresCons_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipresIGVar h termMOD MOD \\<and>\n     ipresIGAbs h hA termMOD MOD \\<and> ipresIGOp h hA termMOD MOD) =\n    (ipresVar h MOD \\<and> ipresAbs h hA MOD \\<and> ipresOp h hA MOD)", "by simp"], ["", "lemmas ipresIGCons_termMOD_simps =\nipresIGVar_termMOD ipresIGAbs_termMOD ipresIGOp_termMOD\nipresIGCons_termMOD"], ["", "definition ipresFresh where\n\"ipresFresh h MOD ==\n \\<forall> ys y s X.\n    wls s X \\<longrightarrow>\n    fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)\""], ["", "lemma ipresIGFresh_termMOD[simp]:\n\"ipresIGFresh h termMOD MOD = ipresFresh h MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGFresh h termMOD MOD = ipresFresh h MOD", "unfolding ipresIGFresh_def ipresFresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>ys y s X.\n        igWls termMOD s X \\<longrightarrow>\n        igFresh termMOD ys y X \\<longrightarrow> igFresh MOD ys y (h X)) =\n    (\\<forall>ys y s X.\n        wls s X \\<longrightarrow>\n        fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X))", "by simp"], ["", "definition ipresFreshAbs where\n\"ipresFreshAbs hA MOD ==\n \\<forall> ys y us s A.\n    wlsAbs (us,s) A \\<longrightarrow>\n    freshAbs ys y A \\<longrightarrow> igFreshAbs MOD ys y (hA A)\""], ["", "lemma ipresIGFreshAbs_termMOD[simp]:\n\"ipresIGFreshAbs hA termMOD MOD = ipresFreshAbs hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGFreshAbs hA termMOD MOD = ipresFreshAbs hA MOD", "unfolding ipresIGFreshAbs_def ipresFreshAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>ys y us s A.\n        igWlsAbs termMOD (us, s) A \\<longrightarrow>\n        igFreshAbs termMOD ys y A \\<longrightarrow>\n        igFreshAbs MOD ys y (hA A)) =\n    (\\<forall>ys y us s A.\n        wlsAbs (us, s) A \\<longrightarrow>\n        freshAbs ys y A \\<longrightarrow> igFreshAbs MOD ys y (hA A))", "by simp"], ["", "definition ipresFreshAll where\n\"ipresFreshAll h hA MOD ==\n ipresFresh h MOD \\<and> ipresFreshAbs hA MOD\""], ["", "lemmas ipresFreshAll_defs = ipresFreshAll_def\nipresFresh_def ipresFreshAbs_def"], ["", "lemma ipresIGFreshAll_termMOD[simp]:\n\"ipresIGFreshAll h hA termMOD MOD = ipresFreshAll h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGFreshAll h hA termMOD MOD = ipresFreshAll h hA MOD", "unfolding ipresIGFreshAll_def ipresFreshAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipresIGFresh h termMOD MOD \\<and> ipresIGFreshAbs hA termMOD MOD) =\n    (ipresFresh h MOD \\<and> ipresFreshAbs hA MOD)", "by simp"], ["", "lemmas ipresIGFreshAll_termMOD_simps =\nipresIGFresh_termMOD ipresIGFreshAbs_termMOD ipresIGFreshAll_termMOD"], ["", "definition ipresSwap where\n\"ipresSwap h MOD ==\n \\<forall> zs z1 z2 s X.\n    wls s X \\<longrightarrow>\n    h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\""], ["", "lemma ipresIGSwap_termMOD[simp]:\n\"ipresIGSwap h termMOD MOD = ipresSwap h MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSwap h termMOD MOD = ipresSwap h MOD", "unfolding ipresIGSwap_def ipresSwap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>zs z1 z2 s X.\n        igWls termMOD s X \\<longrightarrow>\n        h (igSwap termMOD zs z1 z2 X) = igSwap MOD zs z1 z2 (h X)) =\n    (\\<forall>zs z1 z2 s X.\n        wls s X \\<longrightarrow>\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X))", "by simp"], ["", "definition ipresSwapAbs where\n\"ipresSwapAbs hA MOD ==\n \\<forall> zs z1 z2 us s A.\n    wlsAbs (us,s) A \\<longrightarrow>\n    hA (A $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA A)\""], ["", "lemma ipresIGSwapAbs_termMOD[simp]:\n\"ipresIGSwapAbs hA termMOD MOD = ipresSwapAbs hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSwapAbs hA termMOD MOD = ipresSwapAbs hA MOD", "unfolding ipresIGSwapAbs_def ipresSwapAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>zs z1 z2 us s A.\n        igWlsAbs termMOD (us, s) A \\<longrightarrow>\n        hA (igSwapAbs termMOD zs z1 z2 A) = igSwapAbs MOD zs z1 z2 (hA A)) =\n    (\\<forall>zs z1 z2 us s A.\n        wlsAbs (us, s) A \\<longrightarrow>\n        hA (A $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA A))", "by simp"], ["", "definition ipresSwapAll where\n\"ipresSwapAll h hA MOD ==\n ipresSwap h MOD \\<and> ipresSwapAbs hA MOD\""], ["", "lemmas ipresSwapAll_defs = ipresSwapAll_def\nipresSwap_def ipresSwapAbs_def"], ["", "lemma ipresIGSwapAll_termMOD[simp]:\n\"ipresIGSwapAll h hA termMOD MOD = ipresSwapAll h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSwapAll h hA termMOD MOD = ipresSwapAll h hA MOD", "unfolding ipresIGSwapAll_def ipresSwapAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipresIGSwap h termMOD MOD \\<and> ipresIGSwapAbs hA termMOD MOD) =\n    (ipresSwap h MOD \\<and> ipresSwapAbs hA MOD)", "by simp"], ["", "lemmas ipresIGSwapAll_termMOD_simps =\nipresIGSwap_termMOD ipresIGSwapAbs_termMOD ipresIGSwapAll_termMOD"], ["", "definition ipresSubst where\n\"ipresSubst h MOD ==\n \\<forall> ys Y y s X.\n    wls (asSort ys) Y \\<and> wls s X \\<longrightarrow>\n    h (subst ys Y y X) = igSubst MOD ys (h Y) y (h X)\""], ["", "lemma ipresIGSubst_termMOD[simp]:\n\"ipresIGSubst h termMOD MOD = ipresSubst h MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSubst h termMOD MOD = ipresSubst h MOD", "unfolding ipresIGSubst_def ipresSubst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>ys Y y s X.\n        igWls termMOD (asSort ys) Y \\<and>\n        igWls termMOD s X \\<longrightarrow>\n        h (igSubst termMOD ys Y y X) = igSubst MOD ys (h Y) y (h X)) =\n    (\\<forall>ys Y y s X.\n        wls (asSort ys) Y \\<and> wls s X \\<longrightarrow>\n        h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))", "by simp"], ["", "definition ipresSubstAbs where\n\"ipresSubstAbs h hA MOD ==\n \\<forall> ys Y y us s A.\n    wls (asSort ys) Y \\<and> wlsAbs (us,s) A \\<longrightarrow>\n    hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A)\""], ["", "lemma ipresIGSubstAbs_termMOD[simp]:\n\"ipresIGSubstAbs h hA termMOD MOD = ipresSubstAbs h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSubstAbs h hA termMOD MOD = ipresSubstAbs h hA MOD", "unfolding ipresIGSubstAbs_def ipresSubstAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>ys Y y us s A.\n        igWls termMOD (asSort ys) Y \\<and>\n        igWlsAbs termMOD (us, s) A \\<longrightarrow>\n        hA (igSubstAbs termMOD ys Y y A) =\n        igSubstAbs MOD ys (h Y) y (hA A)) =\n    (\\<forall>ys Y y us s A.\n        wls (asSort ys) Y \\<and> wlsAbs (us, s) A \\<longrightarrow>\n        hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A))", "by simp"], ["", "definition ipresSubstAll where\n\"ipresSubstAll h hA MOD ==\n ipresSubst h MOD \\<and> ipresSubstAbs h hA MOD\""], ["", "lemmas ipresSubstAll_defs = ipresSubstAll_def\nipresSubst_def ipresSubstAbs_def"], ["", "lemma ipresIGSubstAll_termMOD[simp]:\n\"ipresIGSubstAll h hA termMOD MOD = ipresSubstAll h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSubstAll h hA termMOD MOD = ipresSubstAll h hA MOD", "unfolding ipresIGSubstAll_def ipresSubstAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipresIGSubst h termMOD MOD \\<and> ipresIGSubstAbs h hA termMOD MOD) =\n    (ipresSubst h MOD \\<and> ipresSubstAbs h hA MOD)", "by simp"], ["", "lemmas ipresIGSubstAll_termMOD_simps =\nipresIGSubst_termMOD ipresIGSubstAbs_termMOD ipresIGSubstAll_termMOD"], ["", "definition termFSwImorph where\n\"termFSwImorph h hA MOD ==\n ipresWlsAll h hA MOD \\<and> ipresCons h hA MOD \\<and>\n ipresFreshAll h hA MOD \\<and> ipresSwapAll h hA MOD\""], ["", "lemmas termFSwImorph_defs1 = termFSwImorph_def\nipresWlsAll_def ipresCons_def\nipresFreshAll_def ipresSwapAll_def"], ["", "lemmas termFSwImorph_defs = termFSwImorph_def\nipresWlsAll_defs ipresCons_defs\nipresFreshAll_defs ipresSwapAll_defs"], ["", "lemma FSwImorph_termMOD[simp]:\n\"FSwImorph h hA termMOD MOD = termFSwImorph h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FSwImorph h hA termMOD MOD = termFSwImorph h hA MOD", "unfolding FSwImorph_def termFSwImorph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipresIGWlsAll h hA termMOD MOD \\<and>\n     ipresIGCons h hA termMOD MOD \\<and>\n     ipresIGFreshAll h hA termMOD MOD \\<and>\n     ipresIGSwapAll h hA termMOD MOD) =\n    (ipresWlsAll h hA MOD \\<and>\n     ipresCons h hA MOD \\<and>\n     ipresFreshAll h hA MOD \\<and> ipresSwapAll h hA MOD)", "by simp"], ["", "definition termFSbImorph where\n\"termFSbImorph h hA MOD ==\n ipresWlsAll h hA MOD \\<and> ipresCons h hA MOD \\<and>\n ipresFreshAll h hA MOD \\<and> ipresSubstAll h hA MOD\""], ["", "lemmas termFSbImorph_defs1 = termFSbImorph_def\nipresWlsAll_def ipresCons_def\nipresFreshAll_def ipresSubstAll_def"], ["", "lemmas termFSbImorph_defs = termFSbImorph_def\nipresWlsAll_defs ipresCons_defs\nipresFreshAll_defs ipresSubstAll_defs"], ["", "lemma FSbImorph_termMOD[simp]:\n\"FSbImorph h hA termMOD MOD = termFSbImorph h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FSbImorph h hA termMOD MOD = termFSbImorph h hA MOD", "unfolding FSbImorph_def termFSbImorph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipresIGWlsAll h hA termMOD MOD \\<and>\n     ipresIGCons h hA termMOD MOD \\<and>\n     ipresIGFreshAll h hA termMOD MOD \\<and>\n     ipresIGSubstAll h hA termMOD MOD) =\n    (ipresWlsAll h hA MOD \\<and>\n     ipresCons h hA MOD \\<and>\n     ipresFreshAll h hA MOD \\<and> ipresSubstAll h hA MOD)", "by simp"], ["", "definition termFSwSbImorph where\n\"termFSwSbImorph h hA MOD ==\n termFSwImorph h hA MOD \\<and> ipresSubstAll h hA MOD\""], ["", "lemmas termFSwSbImorph_defs1 = termFSwSbImorph_def\ntermFSwImorph_def ipresSubstAll_def"], ["", "lemmas termFSwSbImorph_defs = termFSwSbImorph_def\ntermFSwImorph_defs ipresSubstAll_defs"], ["", "text \\<open>Term FSwSb morphisms are the same as FSbSw morphisms:\\<close>"], ["", "lemma termFSwSbImorph_iff:\n\"termFSwSbImorph h hA MOD =\n (termFSbImorph h hA MOD \\<and> ipresSwapAll h hA MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. termFSwSbImorph h hA MOD =\n    (termFSbImorph h hA MOD \\<and> ipresSwapAll h hA MOD)", "unfolding termFSwSbImorph_def termFSwImorph_def termFSbImorph_def ipresSubstAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ipresWlsAll h hA MOD \\<and>\n      ipresCons h hA MOD \\<and>\n      ipresFreshAll h hA MOD \\<and> ipresSwapAll h hA MOD) \\<and>\n     ipresSubst h MOD \\<and> ipresSubstAbs h hA MOD) =\n    ((ipresWlsAll h hA MOD \\<and>\n      ipresCons h hA MOD \\<and>\n      ipresFreshAll h hA MOD \\<and>\n      ipresSubst h MOD \\<and> ipresSubstAbs h hA MOD) \\<and>\n     ipresSwapAll h hA MOD)", "unfolding FSwSbImorph_def FSbImorph_def FSwImorph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ipresWlsAll h hA MOD \\<and>\n      ipresCons h hA MOD \\<and>\n      ipresFreshAll h hA MOD \\<and> ipresSwapAll h hA MOD) \\<and>\n     ipresSubst h MOD \\<and> ipresSubstAbs h hA MOD) =\n    ((ipresWlsAll h hA MOD \\<and>\n      ipresCons h hA MOD \\<and>\n      ipresFreshAll h hA MOD \\<and>\n      ipresSubst h MOD \\<and> ipresSubstAbs h hA MOD) \\<and>\n     ipresSwapAll h hA MOD)", "by auto"], ["", "lemma FSwSbImorph_termMOD[simp]:\n\"FSwSbImorph h hA termMOD MOD = termFSwSbImorph h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FSwSbImorph h hA termMOD MOD = termFSwSbImorph h hA MOD", "unfolding FSwSbImorph_def termFSwSbImorph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (FSwImorph h hA termMOD MOD \\<and> ipresIGSubstAll h hA termMOD MOD) =\n    (termFSwImorph h hA MOD \\<and> ipresSubstAll h hA MOD)", "by simp"], ["", "lemma ipresWls_wlsInp:\nassumes \"wlsInp delta inp\" and \"ipresWls h MOD\"\nshows \"igWlsInp MOD delta (lift h inp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (lift h inp)", "using assms imp_igWlsInp[of termMOD delta inp h MOD]"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  ipresWls h MOD\n  \\<lbrakk>igWlsInp termMOD delta inp; ipresIGWls h termMOD MOD\\<rbrakk>\n  \\<Longrightarrow> igWlsInp MOD delta (lift h inp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (lift h inp)", "by auto"], ["", "lemma termFSwImorph_wlsInp:\nassumes \"wlsInp delta inp\" and \"termFSwImorph h hA MOD\"\nshows \"igWlsInp MOD delta (lift h inp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (lift h inp)", "using assms FSwImorph_igWlsInp[of termMOD delta inp h hA MOD]"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  termFSwImorph h hA MOD\n  \\<lbrakk>igWlsInp termMOD delta inp; FSwImorph h hA termMOD MOD\\<rbrakk>\n  \\<Longrightarrow> igWlsInp MOD delta (lift h inp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (lift h inp)", "by auto"], ["", "lemma termFSwSbImorph_wlsInp:\nassumes \"wlsInp delta inp\" and \"termFSwSbImorph h hA MOD\"\nshows \"igWlsInp MOD delta (lift h inp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (lift h inp)", "using assms FSwSbImorph_igWlsInp[of termMOD delta inp h hA MOD]"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  termFSwSbImorph h hA MOD\n  \\<lbrakk>igWlsInp termMOD delta inp; FSwSbImorph h hA termMOD MOD\\<rbrakk>\n  \\<Longrightarrow> igWlsInp MOD delta (lift h inp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (lift h inp)", "by auto"], ["", "lemma ipresWls_wlsBinp:\nassumes \"wlsBinp delta binp\" and \"ipresWlsAbs hA MOD\"\nshows \"igWlsBinp MOD delta (lift hA binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta (lift hA binp)", "using assms imp_igWlsBinp[of termMOD delta binp hA MOD]"], ["proof (prove)\nusing this:\n  wlsBinp delta binp\n  ipresWlsAbs hA MOD\n  \\<lbrakk>igWlsBinp termMOD delta binp;\n   ipresIGWlsAbs hA termMOD MOD\\<rbrakk>\n  \\<Longrightarrow> igWlsBinp MOD delta (lift hA binp)\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta (lift hA binp)", "by auto"], ["", "lemma termFSwImorph_wlsBinp:\nassumes \"wlsBinp delta binp\" and \"termFSwImorph h hA MOD\"\nshows \"igWlsBinp MOD delta (lift hA binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta (lift hA binp)", "using assms FSwImorph_igWlsBinp[of termMOD delta binp h hA MOD]"], ["proof (prove)\nusing this:\n  wlsBinp delta binp\n  termFSwImorph h hA MOD\n  \\<lbrakk>igWlsBinp termMOD delta binp; FSwImorph h hA termMOD MOD\\<rbrakk>\n  \\<Longrightarrow> igWlsBinp MOD delta (lift hA binp)\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta (lift hA binp)", "by auto"], ["", "lemma termFSwSbImorph_wlsBinp:\nassumes \"wlsBinp delta binp\" and \"termFSwSbImorph h hA MOD\"\nshows \"igWlsBinp MOD delta (lift hA binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta (lift hA binp)", "using assms FSwSbImorph_igWlsBinp[of termMOD delta binp h hA MOD]"], ["proof (prove)\nusing this:\n  wlsBinp delta binp\n  termFSwSbImorph h hA MOD\n  \\<lbrakk>igWlsBinp termMOD delta binp;\n   FSwSbImorph h hA termMOD MOD\\<rbrakk>\n  \\<Longrightarrow> igWlsBinp MOD delta (lift hA binp)\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta (lift hA binp)", "by auto"], ["", "lemma id_termFSwImorph: \"termFSwImorph id id termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. termFSwImorph id id termMOD", "using id_FSwImorph[of termMOD]"], ["proof (prove)\nusing this:\n  FSwImorph id id termMOD termMOD\n\ngoal (1 subgoal):\n 1. termFSwImorph id id termMOD", "by simp"], ["", "lemma id_termFSbImorph: \"termFSbImorph id id termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. termFSbImorph id id termMOD", "using id_FSbImorph[of termMOD]"], ["proof (prove)\nusing this:\n  FSbImorph id id termMOD termMOD\n\ngoal (1 subgoal):\n 1. termFSbImorph id id termMOD", "by simp"], ["", "lemma id_termFSwSbImorph: \"termFSwSbImorph id id termMOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. termFSwSbImorph id id termMOD", "using id_FSwSbImorph[of termMOD]"], ["proof (prove)\nusing this:\n  FSwSbImorph id id termMOD termMOD\n\ngoal (1 subgoal):\n 1. termFSwSbImorph id id termMOD", "by simp"], ["", "lemma comp_termFSwImorph:\nassumes *: \"termFSwImorph h hA MOD\" and **: \"FSwImorph h' hA' MOD MOD'\"\nshows \"termFSwImorph (h' o h) (hA' o hA) MOD'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. termFSwImorph (h' \\<circ> h) (hA' \\<circ> hA) MOD'", "using assms comp_FSwImorph[of h hA termMOD MOD h' hA' MOD']"], ["proof (prove)\nusing this:\n  termFSwImorph h hA MOD\n  FSwImorph h' hA' MOD MOD'\n  \\<lbrakk>FSwImorph h hA termMOD MOD; FSwImorph h' hA' MOD MOD'\\<rbrakk>\n  \\<Longrightarrow> FSwImorph (h' \\<circ> h) (hA' \\<circ> hA) termMOD MOD'\n\ngoal (1 subgoal):\n 1. termFSwImorph (h' \\<circ> h) (hA' \\<circ> hA) MOD'", "by auto"], ["", "lemma comp_termFSbImorph:\nassumes *: \"termFSbImorph h hA MOD\" and **: \"FSbImorph h' hA' MOD MOD'\"\nshows \"termFSbImorph (h' o h) (hA' o hA) MOD'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. termFSbImorph (h' \\<circ> h) (hA' \\<circ> hA) MOD'", "using assms comp_FSbImorph[of termMOD h hA MOD h' hA' MOD']\n      termMOD_igWlsAbsIsInBar"], ["proof (prove)\nusing this:\n  termFSbImorph h hA MOD\n  FSbImorph h' hA' MOD MOD'\n  \\<lbrakk>igWlsAbsIsInBar termMOD; FSbImorph h hA termMOD MOD;\n   FSbImorph h' hA' MOD MOD'\\<rbrakk>\n  \\<Longrightarrow> FSbImorph (h' \\<circ> h) (hA' \\<circ> hA) termMOD MOD'\n  igWlsAbsIsInBar termMOD\n\ngoal (1 subgoal):\n 1. termFSbImorph (h' \\<circ> h) (hA' \\<circ> hA) MOD'", "by auto"], ["", "lemma comp_termFSwSbImorph:\nassumes *: \"termFSwSbImorph h hA MOD\" and **: \"FSwSbImorph h' hA' MOD MOD'\"\nshows \"termFSwSbImorph (h' o h) (hA' o hA) MOD'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. termFSwSbImorph (h' \\<circ> h) (hA' \\<circ> hA) MOD'", "using assms comp_FSwSbImorph[of termMOD h hA MOD h' hA' MOD']\n      termMOD_igWlsAbsIsInBar"], ["proof (prove)\nusing this:\n  termFSwSbImorph h hA MOD\n  FSwSbImorph h' hA' MOD MOD'\n  \\<lbrakk>igWlsAbsIsInBar termMOD; FSwSbImorph h hA termMOD MOD;\n   FSwSbImorph h' hA' MOD MOD'\\<rbrakk>\n  \\<Longrightarrow> FSwSbImorph (h' \\<circ> h) (hA' \\<circ> hA) termMOD MOD'\n  igWlsAbsIsInBar termMOD\n\ngoal (1 subgoal):\n 1. termFSwSbImorph (h' \\<circ> h) (hA' \\<circ> hA) MOD'", "by auto"], ["", "lemmas mapFrom_termMOD_simps =\nipresIGWlsAll_termMOD_simps\nipresIGCons_termMOD_simps\nipresIGFreshAll_termMOD_simps\nipresIGSwapAll_termMOD_simps\nipresIGSubstAll_termMOD_simps\nFSwImorph_termMOD FSbImorph_termMOD FSwSbImorph_termMOD"], ["", "lemmas termMOD_simps =\nstructure_termMOD_simps mapFrom_termMOD_simps"], ["", "subsubsection\n\\<open>Sufficient criteria for being a morphism\n   to a well-sorted model (of various kinds)\\<close>"], ["", "text\\<open>In a nutshell: in these cases, we only need to check preservation of the\n  syntactic constructs, ``ipresCons\".\\<close>"], ["", "lemma ipresCons_imp_ipresWlsAll:\nassumes *: \"ipresCons h hA MOD\" and **: \"igConsIPresIGWls MOD\"\nshows \"ipresWlsAll h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresWlsAll h hA MOD", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ipresWlsAll h hA MOD", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ipresWlsAll h hA MOD", "fix s X us s' A"], ["proof (state)\ngoal (1 subgoal):\n 1. ipresWlsAll h hA MOD", "have \"(wls s X \\<longrightarrow> igWls MOD s (h X)) \\<and>\n         (wlsAbs (us,s') A \\<longrightarrow> igWlsAbs MOD (us,s') (hA A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow> igWls MOD s (h X)) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow> igWlsAbs MOD (us, s') (hA A))", "proof(induction rule: wls_rawInduct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs x. igWls MOD (asSort xs) (h (Var xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2 (\\<lambda>a b. igWls MOD a (h b)) (arOf delta) inp;\n        liftAll2 (\\<lambda>a b. igWlsAbs MOD a (hA b)) (barOf delta)\n         binp\\<rbrakk>\n       \\<Longrightarrow> igWls MOD (stOf delta) (h (Op delta inp binp))\n 3. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; igWls MOD s (h X)\\<rbrakk>\n       \\<Longrightarrow> igWlsAbs MOD (xs, s) (hA (Abs xs x X))", "case (Var xs x)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>xs x. igWls MOD (asSort xs) (h (Var xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2 (\\<lambda>a b. igWls MOD a (h b)) (arOf delta) inp;\n        liftAll2 (\\<lambda>a b. igWlsAbs MOD a (hA b)) (barOf delta)\n         binp\\<rbrakk>\n       \\<Longrightarrow> igWls MOD (stOf delta) (h (Op delta inp binp))\n 3. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; igWls MOD s (h X)\\<rbrakk>\n       \\<Longrightarrow> igWlsAbs MOD (xs, s) (hA (Abs xs x X))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls MOD (asSort xs) (h (Var xs x))", "by (metis assms igConsIPresIGWls_def igVarIPresIGWls_def ipresCons_def ipresVar_def)"], ["proof (state)\nthis:\n  igWls MOD (asSort xs) (h (Var xs x))\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2 (\\<lambda>a b. igWls MOD a (h b)) (arOf delta) inp;\n        liftAll2 (\\<lambda>a b. igWlsAbs MOD a (hA b)) (barOf delta)\n         binp\\<rbrakk>\n       \\<Longrightarrow> igWls MOD (stOf delta) (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; igWls MOD s (h X)\\<rbrakk>\n       \\<Longrightarrow> igWlsAbs MOD (xs, s) (hA (Abs xs x X))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2 (\\<lambda>a b. igWls MOD a (h b)) (arOf delta) inp;\n        liftAll2 (\\<lambda>a b. igWlsAbs MOD a (hA b)) (barOf delta)\n         binp\\<rbrakk>\n       \\<Longrightarrow> igWls MOD (stOf delta) (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; igWls MOD s (h X)\\<rbrakk>\n       \\<Longrightarrow> igWlsAbs MOD (xs, s) (hA (Abs xs x X))", "case (Op delta inp binp)"], ["proof (state)\nthis:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2 (\\<lambda>a b. igWls MOD a (h b)) (arOf delta) inp\n  liftAll2 (\\<lambda>a b. igWlsAbs MOD a (hA b)) (barOf delta) binp\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2 (\\<lambda>a b. igWls MOD a (h b)) (arOf delta) inp;\n        liftAll2 (\\<lambda>a b. igWlsAbs MOD a (hA b)) (barOf delta)\n         binp\\<rbrakk>\n       \\<Longrightarrow> igWls MOD (stOf delta) (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; igWls MOD s (h X)\\<rbrakk>\n       \\<Longrightarrow> igWlsAbs MOD (xs, s) (hA (Abs xs x X))", "have \"igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (lift h inp) \\<and>\n    igWlsBinp MOD delta (lift hA binp)", "using Op"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2 (\\<lambda>a b. igWls MOD a (h b)) (arOf delta) inp\n  liftAll2 (\\<lambda>a b. igWlsAbs MOD a (hA b)) (barOf delta) binp\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (lift h inp) \\<and>\n    igWlsBinp MOD delta (lift hA binp)", "unfolding igWlsInp_def igWlsBinp_def wlsInp_iff wlsBinp_iff"], ["proof (prove)\nusing this:\n  wlsOpS delta \\<and>\n  sameDom (arOf delta) inp \\<and> liftAll2 wls (arOf delta) inp\n  wlsOpS delta \\<and>\n  sameDom (barOf delta) binp \\<and> liftAll2 wlsAbs (barOf delta) binp\n  liftAll2 (\\<lambda>a b. igWls MOD a (h b)) (arOf delta) inp\n  liftAll2 (\\<lambda>a b. igWlsAbs MOD a (hA b)) (barOf delta) binp\n\ngoal (1 subgoal):\n 1. (wlsOpS delta \\<and>\n     sameDom (arOf delta) (lift h inp) \\<and>\n     liftAll2 (igWls MOD) (arOf delta) (lift h inp)) \\<and>\n    wlsOpS delta \\<and>\n    sameDom (barOf delta) (lift hA binp) \\<and>\n    liftAll2 (igWlsAbs MOD) (barOf delta) (lift hA binp)", "by simp (simp add: liftAll2_def lift_def split: option.splits)"], ["proof (state)\nthis:\n  igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2 (\\<lambda>a b. igWls MOD a (h b)) (arOf delta) inp;\n        liftAll2 (\\<lambda>a b. igWlsAbs MOD a (hA b)) (barOf delta)\n         binp\\<rbrakk>\n       \\<Longrightarrow> igWls MOD (stOf delta) (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; igWls MOD s (h X)\\<rbrakk>\n       \\<Longrightarrow> igWlsAbs MOD (xs, s) (hA (Abs xs x X))", "hence \"igWls MOD (stOf delta) (igOp MOD delta (lift h inp) (lift hA binp))\""], ["proof (prove)\nusing this:\n  igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\n\ngoal (1 subgoal):\n 1. igWls MOD (stOf delta) (igOp MOD delta (lift h inp) (lift hA binp))", "using **"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\n  igConsIPresIGWls MOD\n\ngoal (1 subgoal):\n 1. igWls MOD (stOf delta) (igOp MOD delta (lift h inp) (lift hA binp))", "unfolding igConsIPresIGWls_def igOpIPresIGWls_def"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\n  igVarIPresIGWls MOD \\<and>\n  igAbsIPresIGWls MOD \\<and>\n  (\\<forall>delta inp binp.\n      igWlsInp MOD delta inp \\<and>\n      igWlsBinp MOD delta binp \\<longrightarrow>\n      igWls MOD (stOf delta) (igOp MOD delta inp binp))\n\ngoal (1 subgoal):\n 1. igWls MOD (stOf delta) (igOp MOD delta (lift h inp) (lift hA binp))", "by simp"], ["proof (state)\nthis:\n  igWls MOD (stOf delta) (igOp MOD delta (lift h inp) (lift hA binp))\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2 (\\<lambda>a b. igWls MOD a (h b)) (arOf delta) inp;\n        liftAll2 (\\<lambda>a b. igWlsAbs MOD a (hA b)) (barOf delta)\n         binp\\<rbrakk>\n       \\<Longrightarrow> igWls MOD (stOf delta) (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; igWls MOD s (h X)\\<rbrakk>\n       \\<Longrightarrow> igWlsAbs MOD (xs, s) (hA (Abs xs x X))", "thus ?case"], ["proof (prove)\nusing this:\n  igWls MOD (stOf delta) (igOp MOD delta (lift h inp) (lift hA binp))\n\ngoal (1 subgoal):\n 1. igWls MOD (stOf delta) (h (Op delta inp binp))", "using Op *"], ["proof (prove)\nusing this:\n  igWls MOD (stOf delta) (igOp MOD delta (lift h inp) (lift hA binp))\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2 (\\<lambda>a b. igWls MOD a (h b)) (arOf delta) inp\n  liftAll2 (\\<lambda>a b. igWlsAbs MOD a (hA b)) (barOf delta) binp\n  ipresCons h hA MOD\n\ngoal (1 subgoal):\n 1. igWls MOD (stOf delta) (h (Op delta inp binp))", "unfolding ipresCons_def ipresOp_def"], ["proof (prove)\nusing this:\n  igWls MOD (stOf delta) (igOp MOD delta (lift h inp) (lift hA binp))\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2 (\\<lambda>a b. igWls MOD a (h b)) (arOf delta) inp\n  liftAll2 (\\<lambda>a b. igWlsAbs MOD a (hA b)) (barOf delta) binp\n  ipresVar h MOD \\<and>\n  ipresAbs h hA MOD \\<and>\n  (\\<forall>delta inp binp.\n      wlsInp delta inp \\<and> wlsBinp delta binp \\<longrightarrow>\n      h (Op delta inp binp) = igOp MOD delta (lift h inp) (lift hA binp))\n\ngoal (1 subgoal):\n 1. igWls MOD (stOf delta) (h (Op delta inp binp))", "by simp"], ["proof (state)\nthis:\n  igWls MOD (stOf delta) (h (Op delta inp binp))\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; igWls MOD s (h X)\\<rbrakk>\n       \\<Longrightarrow> igWlsAbs MOD (xs, s) (hA (Abs xs x X))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; igWls MOD s (h X)\\<rbrakk>\n       \\<Longrightarrow> igWlsAbs MOD (xs, s) (hA (Abs xs x X))", "case (Abs s xs x X)"], ["proof (state)\nthis:\n  isInBar (xs, s)\n  wls s X\n  igWls MOD s (h X)\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; igWls MOD s (h X)\\<rbrakk>\n       \\<Longrightarrow> igWlsAbs MOD (xs, s) (hA (Abs xs x X))", "then"], ["proof (chain)\npicking this:\n  isInBar (xs, s)\n  wls s X\n  igWls MOD s (h X)", "show ?case"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  igWls MOD s (h X)\n\ngoal (1 subgoal):\n 1. igWlsAbs MOD (xs, s) (hA (Abs xs x X))", "by (metis assms igAbsIPresIGWls_def igConsIPresIGWls_def ipresAbs_def ipresCons_def)"], ["proof (state)\nthis:\n  igWlsAbs MOD (xs, s) (hA (Abs xs x X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (wls s X \\<longrightarrow> igWls MOD s (h X)) \\<and>\n  (wlsAbs (us, s') A \\<longrightarrow> igWlsAbs MOD (us, s') (hA A))\n\ngoal (1 subgoal):\n 1. ipresWlsAll h hA MOD", "}"], ["proof (state)\nthis:\n  (wls ?s89 ?X89 \\<longrightarrow> igWls MOD ?s89 (h ?X89)) \\<and>\n  (wlsAbs (?us89, ?s'89) ?A89 \\<longrightarrow>\n   igWlsAbs MOD (?us89, ?s'89) (hA ?A89))\n\ngoal (1 subgoal):\n 1. ipresWlsAll h hA MOD", "thus ?thesis"], ["proof (prove)\nusing this:\n  (wls ?s89 ?X89 \\<longrightarrow> igWls MOD ?s89 (h ?X89)) \\<and>\n  (wlsAbs (?us89, ?s'89) ?A89 \\<longrightarrow>\n   igWlsAbs MOD (?us89, ?s'89) (hA ?A89))\n\ngoal (1 subgoal):\n 1. ipresWlsAll h hA MOD", "unfolding ipresWlsAll_defs"], ["proof (prove)\nusing this:\n  (wls ?s89 ?X89 \\<longrightarrow> igWls MOD ?s89 (h ?X89)) \\<and>\n  (wlsAbs (?us89, ?s'89) ?A89 \\<longrightarrow>\n   igWlsAbs MOD (?us89, ?s'89) (hA ?A89))\n\ngoal (1 subgoal):\n 1. (\\<forall>s X. wls s X \\<longrightarrow> igWls MOD s (h X)) \\<and>\n    (\\<forall>us s A.\n        wlsAbs (us, s) A \\<longrightarrow> igWlsAbs MOD (us, s) (hA A))", "by simp"], ["proof (state)\nthis:\n  ipresWlsAll h hA MOD\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipresCons_imp_ipresFreshAll:\nassumes *: \"ipresCons h hA MOD\" and **: \"igFreshCls MOD\"\nand \"igConsIPresIGWls MOD\"\nshows \"ipresFreshAll h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresFreshAll h hA MOD", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ipresFreshAll h hA MOD", "have ***: \"ipresWlsAll h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresWlsAll h hA MOD", "using assms ipresCons_imp_ipresWlsAll"], ["proof (prove)\nusing this:\n  ipresCons h hA MOD\n  igFreshCls MOD\n  igConsIPresIGWls MOD\n  \\<lbrakk>ipresCons ?h ?hA ?MOD; igConsIPresIGWls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresWlsAll ?h ?hA ?MOD\n\ngoal (1 subgoal):\n 1. ipresWlsAll h hA MOD", "by auto"], ["proof (state)\nthis:\n  ipresWlsAll h hA MOD\n\ngoal (1 subgoal):\n 1. ipresFreshAll h hA MOD", "hence ****:\n  \"\\<And> delta inp. wlsInp delta inp \\<Longrightarrow> igWlsInp MOD delta (lift h inp)\"\n  \"\\<And> delta binp. wlsBinp delta binp \\<Longrightarrow> igWlsBinp MOD delta (lift hA binp)\""], ["proof (prove)\nusing this:\n  ipresWlsAll h hA MOD\n\ngoal (1 subgoal):\n 1. (\\<And>delta inp.\n        wlsInp delta inp \\<Longrightarrow>\n        igWlsInp MOD delta (lift h inp)) &&&\n    (\\<And>delta binp.\n        wlsBinp delta binp \\<Longrightarrow>\n        igWlsBinp MOD delta (lift hA binp))", "unfolding ipresWlsAll_def"], ["proof (prove)\nusing this:\n  ipresWls h MOD \\<and> ipresWlsAbs hA MOD\n\ngoal (1 subgoal):\n 1. (\\<And>delta inp.\n        wlsInp delta inp \\<Longrightarrow>\n        igWlsInp MOD delta (lift h inp)) &&&\n    (\\<And>delta binp.\n        wlsBinp delta binp \\<Longrightarrow>\n        igWlsBinp MOD delta (lift hA binp))", "using ipresWls_wlsInp ipresWls_wlsBinp"], ["proof (prove)\nusing this:\n  ipresWls h MOD \\<and> ipresWlsAbs hA MOD\n  \\<lbrakk>wlsInp ?delta ?inp; ipresWls ?h ?MOD\\<rbrakk>\n  \\<Longrightarrow> igWlsInp ?MOD ?delta (lift ?h ?inp)\n  \\<lbrakk>wlsBinp ?delta ?binp; ipresWlsAbs ?hA ?MOD\\<rbrakk>\n  \\<Longrightarrow> igWlsBinp ?MOD ?delta (lift ?hA ?binp)\n\ngoal (1 subgoal):\n 1. (\\<And>delta inp.\n        wlsInp delta inp \\<Longrightarrow>\n        igWlsInp MOD delta (lift h inp)) &&&\n    (\\<And>delta binp.\n        wlsBinp delta binp \\<Longrightarrow>\n        igWlsBinp MOD delta (lift hA binp))", "by auto"], ["proof (state)\nthis:\n  wlsInp ?delta87 ?inp87 \\<Longrightarrow>\n  igWlsInp MOD ?delta87 (lift h ?inp87)\n  wlsBinp ?delta87 ?binp87 \\<Longrightarrow>\n  igWlsBinp MOD ?delta87 (lift hA ?binp87)\n\ngoal (1 subgoal):\n 1. ipresFreshAll h hA MOD", "(*  *)"], ["proof (state)\nthis:\n  wlsInp ?delta87 ?inp87 \\<Longrightarrow>\n  igWlsInp MOD ?delta87 (lift h ?inp87)\n  wlsBinp ?delta87 ?binp87 \\<Longrightarrow>\n  igWlsBinp MOD ?delta87 (lift hA ?binp87)\n\ngoal (1 subgoal):\n 1. ipresFreshAll h hA MOD", "{"], ["proof (state)\nthis:\n  wlsInp ?delta87 ?inp87 \\<Longrightarrow>\n  igWlsInp MOD ?delta87 (lift h ?inp87)\n  wlsBinp ?delta87 ?binp87 \\<Longrightarrow>\n  igWlsBinp MOD ?delta87 (lift hA ?binp87)\n\ngoal (1 subgoal):\n 1. ipresFreshAll h hA MOD", "fix s X us s' A ys y"], ["proof (state)\ngoal (1 subgoal):\n 1. ipresFreshAll h hA MOD", "have \"(wls s X \\<longrightarrow> fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)) \\<and>\n         (wlsAbs (us,s') A \\<longrightarrow> freshAbs ys y A \\<longrightarrow> igFreshAbs MOD ys y (hA A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow>\n     fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow>\n     freshAbs ys y A \\<longrightarrow> igFreshAbs MOD ys y (hA A))", "proof(induction rule: wls_rawInduct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       fresh ys y (Var xs x) \\<longrightarrow>\n       igFresh MOD ys y (h (Var xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             fresh ys y b \\<longrightarrow> igFresh MOD ys y (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             freshAbs ys y b \\<longrightarrow> igFreshAbs MOD ys y (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> fresh ys y (Op delta inp binp) \\<longrightarrow>\n                         igFresh MOD ys y (h (Op delta inp binp))\n 3. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)\\<rbrakk>\n       \\<Longrightarrow> freshAbs ys y (Abs xs x X) \\<longrightarrow>\n                         igFreshAbs MOD ys y (hA (Abs xs x X))", "case (Var xs x)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       fresh ys y (Var xs x) \\<longrightarrow>\n       igFresh MOD ys y (h (Var xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             fresh ys y b \\<longrightarrow> igFresh MOD ys y (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             freshAbs ys y b \\<longrightarrow> igFreshAbs MOD ys y (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> fresh ys y (Op delta inp binp) \\<longrightarrow>\n                         igFresh MOD ys y (h (Op delta inp binp))\n 3. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)\\<rbrakk>\n       \\<Longrightarrow> freshAbs ys y (Abs xs x X) \\<longrightarrow>\n                         igFreshAbs MOD ys y (hA (Abs xs x X))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh ys y (Var xs x) \\<longrightarrow> igFresh MOD ys y (h (Var xs x))", "by (metis * ** fresh_Var_simp igFreshCls_def igFreshIGVar_def ipresCons_def ipresVar_def)"], ["proof (state)\nthis:\n  fresh ys y (Var xs x) \\<longrightarrow> igFresh MOD ys y (h (Var xs x))\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             fresh ys y b \\<longrightarrow> igFresh MOD ys y (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             freshAbs ys y b \\<longrightarrow> igFreshAbs MOD ys y (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> fresh ys y (Op delta inp binp) \\<longrightarrow>\n                         igFresh MOD ys y (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)\\<rbrakk>\n       \\<Longrightarrow> freshAbs ys y (Abs xs x X) \\<longrightarrow>\n                         igFreshAbs MOD ys y (hA (Abs xs x X))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             fresh ys y b \\<longrightarrow> igFresh MOD ys y (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             freshAbs ys y b \\<longrightarrow> igFreshAbs MOD ys y (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> fresh ys y (Op delta inp binp) \\<longrightarrow>\n                         igFresh MOD ys y (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)\\<rbrakk>\n       \\<Longrightarrow> freshAbs ys y (Abs xs x X) \\<longrightarrow>\n                         igFreshAbs MOD ys y (hA (Abs xs x X))", "case (Op delta inp binp)"], ["proof (state)\nthis:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>a b. fresh ys y b \\<longrightarrow> igFresh MOD ys y (h b))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>a b.\n       freshAbs ys y b \\<longrightarrow> igFreshAbs MOD ys y (hA b))\n   (barOf delta) binp\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             fresh ys y b \\<longrightarrow> igFresh MOD ys y (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             freshAbs ys y b \\<longrightarrow> igFreshAbs MOD ys y (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> fresh ys y (Op delta inp binp) \\<longrightarrow>\n                         igFresh MOD ys y (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)\\<rbrakk>\n       \\<Longrightarrow> freshAbs ys y (Abs xs x X) \\<longrightarrow>\n                         igFreshAbs MOD ys y (hA (Abs xs x X))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "assume y_fresh: \"fresh ys y (Op delta inp binp)\""], ["proof (state)\nthis:\n  fresh ys y (Op delta inp binp)\n\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "{"], ["proof (state)\nthis:\n  fresh ys y (Op delta inp binp)\n\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "fix i X"], ["proof (state)\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "assume inp: \"inp i = Some X\""], ["proof (state)\nthis:\n  inp i = Some X\n\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "then"], ["proof (chain)\npicking this:\n  inp i = Some X", "obtain s where \"arOf delta i = Some s\""], ["proof (prove)\nusing this:\n  inp i = Some X\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        arOf delta i = Some s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Op"], ["proof (prove)\nusing this:\n  inp i = Some X\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>a b. fresh ys y b \\<longrightarrow> igFresh MOD ys y (h b))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>a b.\n       freshAbs ys y b \\<longrightarrow> igFreshAbs MOD ys y (hA b))\n   (barOf delta) binp\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        arOf delta i = Some s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wlsInp_iff sameDom_def"], ["proof (prove)\nusing this:\n  inp i = Some X\n  wlsOpS delta \\<and>\n  (\\<forall>i. (arOf delta i = None) = (inp i = None)) \\<and>\n  liftAll2 wls (arOf delta) inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>a b. fresh ys y b \\<longrightarrow> igFresh MOD ys y (h b))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>a b.\n       freshAbs ys y b \\<longrightarrow> igFreshAbs MOD ys y (hA b))\n   (barOf delta) binp\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        arOf delta i = Some s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  arOf delta i = Some s\n\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "hence \"igFresh MOD ys y (h X)\""], ["proof (prove)\nusing this:\n  arOf delta i = Some s\n\ngoal (1 subgoal):\n 1. igFresh MOD ys y (h X)", "using Op.IH y_fresh inp"], ["proof (prove)\nusing this:\n  arOf delta i = Some s\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>a b. fresh ys y b \\<longrightarrow> igFresh MOD ys y (h b))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>a b.\n       freshAbs ys y b \\<longrightarrow> igFreshAbs MOD ys y (hA b))\n   (barOf delta) binp\n  fresh ys y (Op delta inp binp)\n  inp i = Some X\n\ngoal (1 subgoal):\n 1. igFresh MOD ys y (h X)", "unfolding freshInp_def liftAll_def liftAll2_def"], ["proof (prove)\nusing this:\n  arOf delta i = Some s\n  wlsInp delta inp\n  wlsBinp delta binp\n  \\<forall>i v1 v2.\n     arOf delta i = Some v1 \\<and> inp i = Some v2 \\<longrightarrow>\n     fresh ys y v2 \\<longrightarrow> igFresh MOD ys y (h v2)\n  \\<forall>i v1 v2.\n     barOf delta i = Some v1 \\<and> binp i = Some v2 \\<longrightarrow>\n     freshAbs ys y v2 \\<longrightarrow> igFreshAbs MOD ys y (hA v2)\n  fresh ys y (Op delta inp binp)\n  inp i = Some X\n\ngoal (1 subgoal):\n 1. igFresh MOD ys y (h X)", "by (metis freshInp_def liftAll_def wls_fresh_Op_simp)"], ["proof (state)\nthis:\n  igFresh MOD ys y (h X)\n\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "}"], ["proof (state)\nthis:\n  inp ?i89 = Some ?Xa89 \\<Longrightarrow> igFresh MOD ys y (h ?Xa89)\n\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "moreover"], ["proof (state)\nthis:\n  inp ?i89 = Some ?Xa89 \\<Longrightarrow> igFresh MOD ys y (h ?Xa89)\n\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "{"], ["proof (state)\nthis:\n  inp ?i89 = Some ?Xa89 \\<Longrightarrow> igFresh MOD ys y (h ?Xa89)\n\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "fix i A"], ["proof (state)\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "assume binp: \"binp i = Some A\""], ["proof (state)\nthis:\n  binp i = Some A\n\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "then"], ["proof (chain)\npicking this:\n  binp i = Some A", "obtain us_s where \"barOf delta i = Some us_s\""], ["proof (prove)\nusing this:\n  binp i = Some A\n\ngoal (1 subgoal):\n 1. (\\<And>us_s.\n        barOf delta i = Some us_s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Op"], ["proof (prove)\nusing this:\n  binp i = Some A\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>a b. fresh ys y b \\<longrightarrow> igFresh MOD ys y (h b))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>a b.\n       freshAbs ys y b \\<longrightarrow> igFreshAbs MOD ys y (hA b))\n   (barOf delta) binp\n\ngoal (1 subgoal):\n 1. (\\<And>us_s.\n        barOf delta i = Some us_s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding wlsBinp_iff sameDom_def"], ["proof (prove)\nusing this:\n  binp i = Some A\n  wlsInp delta inp\n  wlsOpS delta \\<and>\n  (\\<forall>i. (barOf delta i = None) = (binp i = None)) \\<and>\n  liftAll2 wlsAbs (barOf delta) binp\n  liftAll2\n   (\\<lambda>a b. fresh ys y b \\<longrightarrow> igFresh MOD ys y (h b))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>a b.\n       freshAbs ys y b \\<longrightarrow> igFreshAbs MOD ys y (hA b))\n   (barOf delta) binp\n\ngoal (1 subgoal):\n 1. (\\<And>us_s.\n        barOf delta i = Some us_s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  barOf delta i = Some us_s\n\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "hence \"igFreshAbs MOD ys y (hA A)\""], ["proof (prove)\nusing this:\n  barOf delta i = Some us_s\n\ngoal (1 subgoal):\n 1. igFreshAbs MOD ys y (hA A)", "using Op.IH y_fresh binp"], ["proof (prove)\nusing this:\n  barOf delta i = Some us_s\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>a b. fresh ys y b \\<longrightarrow> igFresh MOD ys y (h b))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>a b.\n       freshAbs ys y b \\<longrightarrow> igFreshAbs MOD ys y (hA b))\n   (barOf delta) binp\n  fresh ys y (Op delta inp binp)\n  binp i = Some A\n\ngoal (1 subgoal):\n 1. igFreshAbs MOD ys y (hA A)", "unfolding freshBinp_def liftAll_def liftAll2_def"], ["proof (prove)\nusing this:\n  barOf delta i = Some us_s\n  wlsInp delta inp\n  wlsBinp delta binp\n  \\<forall>i v1 v2.\n     arOf delta i = Some v1 \\<and> inp i = Some v2 \\<longrightarrow>\n     fresh ys y v2 \\<longrightarrow> igFresh MOD ys y (h v2)\n  \\<forall>i v1 v2.\n     barOf delta i = Some v1 \\<and> binp i = Some v2 \\<longrightarrow>\n     freshAbs ys y v2 \\<longrightarrow> igFreshAbs MOD ys y (hA v2)\n  fresh ys y (Op delta inp binp)\n  binp i = Some A\n\ngoal (1 subgoal):\n 1. igFreshAbs MOD ys y (hA A)", "by simp (metis (no_types, hide_lams) freshBinp_def liftAll_def old.prod.exhaust)"], ["proof (state)\nthis:\n  igFreshAbs MOD ys y (hA A)\n\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "}"], ["proof (state)\nthis:\n  binp ?i89 = Some ?Aa89 \\<Longrightarrow> igFreshAbs MOD ys y (hA ?Aa89)\n\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "ultimately"], ["proof (chain)\npicking this:\n  inp ?i89 = Some ?Xa89 \\<Longrightarrow> igFresh MOD ys y (h ?Xa89)\n  binp ?i89 = Some ?Aa89 \\<Longrightarrow> igFreshAbs MOD ys y (hA ?Aa89)", "have \"igFreshInp MOD ys y (lift h inp) \\<and> igFreshBinp MOD ys y (lift hA binp)\""], ["proof (prove)\nusing this:\n  inp ?i89 = Some ?Xa89 \\<Longrightarrow> igFresh MOD ys y (h ?Xa89)\n  binp ?i89 = Some ?Aa89 \\<Longrightarrow> igFreshAbs MOD ys y (hA ?Aa89)\n\ngoal (1 subgoal):\n 1. igFreshInp MOD ys y (lift h inp) \\<and>\n    igFreshBinp MOD ys y (lift hA binp)", "unfolding igFreshInp_def igFreshBinp_def liftAll_lift_comp"], ["proof (prove)\nusing this:\n  inp ?i89 = Some ?Xa89 \\<Longrightarrow> igFresh MOD ys y (h ?Xa89)\n  binp ?i89 = Some ?Aa89 \\<Longrightarrow> igFreshAbs MOD ys y (hA ?Aa89)\n\ngoal (1 subgoal):\n 1. liftAll (igFresh MOD ys y \\<circ> h) inp \\<and>\n    liftAll (igFreshAbs MOD ys y \\<circ> hA) binp", "unfolding liftAll_def"], ["proof (prove)\nusing this:\n  inp ?i89 = Some ?Xa89 \\<Longrightarrow> igFresh MOD ys y (h ?Xa89)\n  binp ?i89 = Some ?Aa89 \\<Longrightarrow> igFreshAbs MOD ys y (hA ?Aa89)\n\ngoal (1 subgoal):\n 1. (\\<forall>i v.\n        inp i = Some v \\<longrightarrow>\n        (igFresh MOD ys y \\<circ> h) v) \\<and>\n    (\\<forall>i v.\n        binp i = Some v \\<longrightarrow>\n        (igFreshAbs MOD ys y \\<circ> hA) v)", "by auto"], ["proof (state)\nthis:\n  igFreshInp MOD ys y (lift h inp) \\<and>\n  igFreshBinp MOD ys y (lift hA binp)\n\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "moreover"], ["proof (state)\nthis:\n  igFreshInp MOD ys y (lift h inp) \\<and>\n  igFreshBinp MOD ys y (lift hA binp)\n\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "have \"igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (lift h inp) \\<and>\n    igWlsBinp MOD delta (lift hA binp)", "using Op ****"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>a b. fresh ys y b \\<longrightarrow> igFresh MOD ys y (h b))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>a b.\n       freshAbs ys y b \\<longrightarrow> igFreshAbs MOD ys y (hA b))\n   (barOf delta) binp\n  wlsInp ?delta87 ?inp87 \\<Longrightarrow>\n  igWlsInp MOD ?delta87 (lift h ?inp87)\n  wlsBinp ?delta87 ?binp87 \\<Longrightarrow>\n  igWlsBinp MOD ?delta87 (lift hA ?binp87)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (lift h inp) \\<and>\n    igWlsBinp MOD delta (lift hA binp)", "by simp"], ["proof (state)\nthis:\n  igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\n\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "ultimately"], ["proof (chain)\npicking this:\n  igFreshInp MOD ys y (lift h inp) \\<and>\n  igFreshBinp MOD ys y (lift hA binp)\n  igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)", "have \"igFresh MOD ys y (igOp MOD delta (lift h inp) (lift hA binp))\""], ["proof (prove)\nusing this:\n  igFreshInp MOD ys y (lift h inp) \\<and>\n  igFreshBinp MOD ys y (lift hA binp)\n  igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\n\ngoal (1 subgoal):\n 1. igFresh MOD ys y (igOp MOD delta (lift h inp) (lift hA binp))", "using **"], ["proof (prove)\nusing this:\n  igFreshInp MOD ys y (lift h inp) \\<and>\n  igFreshBinp MOD ys y (lift hA binp)\n  igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\n  igFreshCls MOD\n\ngoal (1 subgoal):\n 1. igFresh MOD ys y (igOp MOD delta (lift h inp) (lift hA binp))", "unfolding igFreshCls_def igFreshIGOp_def"], ["proof (prove)\nusing this:\n  igFreshInp MOD ys y (lift h inp) \\<and>\n  igFreshBinp MOD ys y (lift hA binp)\n  igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\n  igFreshIGVar MOD \\<and>\n  igFreshIGAbs1 MOD \\<and>\n  igFreshIGAbs2 MOD \\<and>\n  (\\<forall>ys y delta inp binp.\n      igWlsInp MOD delta inp \\<and>\n      igWlsBinp MOD delta binp \\<longrightarrow>\n      igFreshInp MOD ys y inp \\<and>\n      igFreshBinp MOD ys y binp \\<longrightarrow>\n      igFresh MOD ys y (igOp MOD delta inp binp))\n\ngoal (1 subgoal):\n 1. igFresh MOD ys y (igOp MOD delta (lift h inp) (lift hA binp))", "by simp"], ["proof (state)\nthis:\n  igFresh MOD ys y (igOp MOD delta (lift h inp) (lift hA binp))\n\ngoal (1 subgoal):\n 1. fresh ys y (Op delta inp binp) \\<Longrightarrow>\n    igFresh MOD ys y (h (Op delta inp binp))", "thus \"igFresh MOD ys y (h (Op delta inp binp))\""], ["proof (prove)\nusing this:\n  igFresh MOD ys y (igOp MOD delta (lift h inp) (lift hA binp))\n\ngoal (1 subgoal):\n 1. igFresh MOD ys y (h (Op delta inp binp))", "using Op *"], ["proof (prove)\nusing this:\n  igFresh MOD ys y (igOp MOD delta (lift h inp) (lift hA binp))\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>a b. fresh ys y b \\<longrightarrow> igFresh MOD ys y (h b))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>a b.\n       freshAbs ys y b \\<longrightarrow> igFreshAbs MOD ys y (hA b))\n   (barOf delta) binp\n  ipresCons h hA MOD\n\ngoal (1 subgoal):\n 1. igFresh MOD ys y (h (Op delta inp binp))", "unfolding ipresCons_def ipresOp_def"], ["proof (prove)\nusing this:\n  igFresh MOD ys y (igOp MOD delta (lift h inp) (lift hA binp))\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>a b. fresh ys y b \\<longrightarrow> igFresh MOD ys y (h b))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>a b.\n       freshAbs ys y b \\<longrightarrow> igFreshAbs MOD ys y (hA b))\n   (barOf delta) binp\n  ipresVar h MOD \\<and>\n  ipresAbs h hA MOD \\<and>\n  (\\<forall>delta inp binp.\n      wlsInp delta inp \\<and> wlsBinp delta binp \\<longrightarrow>\n      h (Op delta inp binp) = igOp MOD delta (lift h inp) (lift hA binp))\n\ngoal (1 subgoal):\n 1. igFresh MOD ys y (h (Op delta inp binp))", "by simp"], ["proof (state)\nthis:\n  igFresh MOD ys y (h (Op delta inp binp))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fresh ys y (Op delta inp binp) \\<longrightarrow>\n  igFresh MOD ys y (h (Op delta inp binp))\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)\\<rbrakk>\n       \\<Longrightarrow> freshAbs ys y (Abs xs x X) \\<longrightarrow>\n                         igFreshAbs MOD ys y (hA (Abs xs x X))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)\\<rbrakk>\n       \\<Longrightarrow> freshAbs ys y (Abs xs x X) \\<longrightarrow>\n                         igFreshAbs MOD ys y (hA (Abs xs x X))", "case (Abs s xs x X)"], ["proof (state)\nthis:\n  isInBar (xs, s)\n  wls s X\n  fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)\\<rbrakk>\n       \\<Longrightarrow> freshAbs ys y (Abs xs x X) \\<longrightarrow>\n                         igFreshAbs MOD ys y (hA (Abs xs x X))", "hence hX_wls: \"igWls MOD s (h X)\""], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)\n\ngoal (1 subgoal):\n 1. igWls MOD s (h X)", "using ***"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)\n  ipresWlsAll h hA MOD\n\ngoal (1 subgoal):\n 1. igWls MOD s (h X)", "unfolding ipresWlsAll_def ipresWls_def"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)\n  (\\<forall>s X. wls s X \\<longrightarrow> igWls MOD s (h X)) \\<and>\n  ipresWlsAbs hA MOD\n\ngoal (1 subgoal):\n 1. igWls MOD s (h X)", "by simp"], ["proof (state)\nthis:\n  igWls MOD s (h X)\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)\\<rbrakk>\n       \\<Longrightarrow> freshAbs ys y (Abs xs x X) \\<longrightarrow>\n                         igFreshAbs MOD ys y (hA (Abs xs x X))", "thus ?case"], ["proof (prove)\nusing this:\n  igWls MOD s (h X)\n\ngoal (1 subgoal):\n 1. freshAbs ys y (Abs xs x X) \\<longrightarrow>\n    igFreshAbs MOD ys y (hA (Abs xs x X))", "using Abs assms"], ["proof (prove)\nusing this:\n  igWls MOD s (h X)\n  isInBar (xs, s)\n  wls s X\n  fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)\n  ipresCons h hA MOD\n  igFreshCls MOD\n  igConsIPresIGWls MOD\n\ngoal (1 subgoal):\n 1. freshAbs ys y (Abs xs x X) \\<longrightarrow>\n    igFreshAbs MOD ys y (hA (Abs xs x X))", "by (cases \"ys = xs \\<and> y = x\")\n     (simp_all add: igFreshCls_def igFreshIGAbs1_def igFreshIGAbs2_def ipresAbs_def ipresCons_def)"], ["proof (state)\nthis:\n  freshAbs ys y (Abs xs x X) \\<longrightarrow>\n  igFreshAbs MOD ys y (hA (Abs xs x X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (wls s X \\<longrightarrow>\n   fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)) \\<and>\n  (wlsAbs (us, s') A \\<longrightarrow>\n   freshAbs ys y A \\<longrightarrow> igFreshAbs MOD ys y (hA A))\n\ngoal (1 subgoal):\n 1. ipresFreshAll h hA MOD", "}"], ["proof (state)\nthis:\n  (wls ?s89 ?X89 \\<longrightarrow>\n   fresh ?ys89 ?y89 ?X89 \\<longrightarrow>\n   igFresh MOD ?ys89 ?y89 (h ?X89)) \\<and>\n  (wlsAbs (?us89, ?s'89) ?A89 \\<longrightarrow>\n   freshAbs ?ys89 ?y89 ?A89 \\<longrightarrow>\n   igFreshAbs MOD ?ys89 ?y89 (hA ?A89))\n\ngoal (1 subgoal):\n 1. ipresFreshAll h hA MOD", "thus ?thesis"], ["proof (prove)\nusing this:\n  (wls ?s89 ?X89 \\<longrightarrow>\n   fresh ?ys89 ?y89 ?X89 \\<longrightarrow>\n   igFresh MOD ?ys89 ?y89 (h ?X89)) \\<and>\n  (wlsAbs (?us89, ?s'89) ?A89 \\<longrightarrow>\n   freshAbs ?ys89 ?y89 ?A89 \\<longrightarrow>\n   igFreshAbs MOD ?ys89 ?y89 (hA ?A89))\n\ngoal (1 subgoal):\n 1. ipresFreshAll h hA MOD", "unfolding ipresFreshAll_defs"], ["proof (prove)\nusing this:\n  (wls ?s89 ?X89 \\<longrightarrow>\n   fresh ?ys89 ?y89 ?X89 \\<longrightarrow>\n   igFresh MOD ?ys89 ?y89 (h ?X89)) \\<and>\n  (wlsAbs (?us89, ?s'89) ?A89 \\<longrightarrow>\n   freshAbs ?ys89 ?y89 ?A89 \\<longrightarrow>\n   igFreshAbs MOD ?ys89 ?y89 (hA ?A89))\n\ngoal (1 subgoal):\n 1. (\\<forall>ys y s X.\n        wls s X \\<longrightarrow>\n        fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)) \\<and>\n    (\\<forall>ys y us s A.\n        wlsAbs (us, s) A \\<longrightarrow>\n        freshAbs ys y A \\<longrightarrow> igFreshAbs MOD ys y (hA A))", "by auto"], ["proof (state)\nthis:\n  ipresFreshAll h hA MOD\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipresCons_imp_ipresSwapAll:\nassumes *: \"ipresCons h hA MOD\" and **: \"igSwapCls MOD\"\nand \"igConsIPresIGWls MOD\"\nshows \"ipresSwapAll h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresSwapAll h hA MOD", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ipresSwapAll h hA MOD", "have ***: \"ipresWlsAll h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresWlsAll h hA MOD", "using assms ipresCons_imp_ipresWlsAll"], ["proof (prove)\nusing this:\n  ipresCons h hA MOD\n  igSwapCls MOD\n  igConsIPresIGWls MOD\n  \\<lbrakk>ipresCons ?h ?hA ?MOD; igConsIPresIGWls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresWlsAll ?h ?hA ?MOD\n\ngoal (1 subgoal):\n 1. ipresWlsAll h hA MOD", "by auto"], ["proof (state)\nthis:\n  ipresWlsAll h hA MOD\n\ngoal (1 subgoal):\n 1. ipresSwapAll h hA MOD", "hence ****:\n  \"\\<And> delta inp. wlsInp delta inp \\<Longrightarrow> igWlsInp MOD delta (lift h inp)\"\n  \"\\<And> delta binp. wlsBinp delta binp \\<Longrightarrow> igWlsBinp MOD delta (lift hA binp)\""], ["proof (prove)\nusing this:\n  ipresWlsAll h hA MOD\n\ngoal (1 subgoal):\n 1. (\\<And>delta inp.\n        wlsInp delta inp \\<Longrightarrow>\n        igWlsInp MOD delta (lift h inp)) &&&\n    (\\<And>delta binp.\n        wlsBinp delta binp \\<Longrightarrow>\n        igWlsBinp MOD delta (lift hA binp))", "unfolding ipresWlsAll_def"], ["proof (prove)\nusing this:\n  ipresWls h MOD \\<and> ipresWlsAbs hA MOD\n\ngoal (1 subgoal):\n 1. (\\<And>delta inp.\n        wlsInp delta inp \\<Longrightarrow>\n        igWlsInp MOD delta (lift h inp)) &&&\n    (\\<And>delta binp.\n        wlsBinp delta binp \\<Longrightarrow>\n        igWlsBinp MOD delta (lift hA binp))", "using ipresWls_wlsInp ipresWls_wlsBinp"], ["proof (prove)\nusing this:\n  ipresWls h MOD \\<and> ipresWlsAbs hA MOD\n  \\<lbrakk>wlsInp ?delta ?inp; ipresWls ?h ?MOD\\<rbrakk>\n  \\<Longrightarrow> igWlsInp ?MOD ?delta (lift ?h ?inp)\n  \\<lbrakk>wlsBinp ?delta ?binp; ipresWlsAbs ?hA ?MOD\\<rbrakk>\n  \\<Longrightarrow> igWlsBinp ?MOD ?delta (lift ?hA ?binp)\n\ngoal (1 subgoal):\n 1. (\\<And>delta inp.\n        wlsInp delta inp \\<Longrightarrow>\n        igWlsInp MOD delta (lift h inp)) &&&\n    (\\<And>delta binp.\n        wlsBinp delta binp \\<Longrightarrow>\n        igWlsBinp MOD delta (lift hA binp))", "by auto"], ["proof (state)\nthis:\n  wlsInp ?delta87 ?inp87 \\<Longrightarrow>\n  igWlsInp MOD ?delta87 (lift h ?inp87)\n  wlsBinp ?delta87 ?binp87 \\<Longrightarrow>\n  igWlsBinp MOD ?delta87 (lift hA ?binp87)\n\ngoal (1 subgoal):\n 1. ipresSwapAll h hA MOD", "(*  *)"], ["proof (state)\nthis:\n  wlsInp ?delta87 ?inp87 \\<Longrightarrow>\n  igWlsInp MOD ?delta87 (lift h ?inp87)\n  wlsBinp ?delta87 ?binp87 \\<Longrightarrow>\n  igWlsBinp MOD ?delta87 (lift hA ?binp87)\n\ngoal (1 subgoal):\n 1. ipresSwapAll h hA MOD", "{"], ["proof (state)\nthis:\n  wlsInp ?delta87 ?inp87 \\<Longrightarrow>\n  igWlsInp MOD ?delta87 (lift h ?inp87)\n  wlsBinp ?delta87 ?binp87 \\<Longrightarrow>\n  igWlsBinp MOD ?delta87 (lift hA ?binp87)\n\ngoal (1 subgoal):\n 1. ipresSwapAll h hA MOD", "fix s X us s' A zs z1 z2"], ["proof (state)\ngoal (1 subgoal):\n 1. ipresSwapAll h hA MOD", "have \"(wls s X \\<longrightarrow> h (swap zs z1 z2 X) = igSwap MOD zs z1 z2 (h X)) \\<and>\n         (wlsAbs (us,s') A \\<longrightarrow> hA (swapAbs zs z1 z2 A) = igSwapAbs MOD zs z1 z2 (hA A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow>\n     h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow>\n     hA (A $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA A))", "proof(induction rule: wls_rawInduct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       h (Var xs x #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h (Var xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 3. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "case (Var xs x)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       h (Var xs x #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h (Var xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 3. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. h (Var xs x #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h (Var xs x))", "by (metis \"*\" \"**\" igSwapCls_def igSwapIGVar_def ipresCons_def ipresVar_def swap_Var_simp)"], ["proof (state)\nthis:\n  h (Var xs x #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h (Var xs x))\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "case (Op delta inp binp)"], ["proof (state)\nthis:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>a b. h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>a b. hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n   (barOf delta) binp\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "let ?inpsw = \"swapInp zs z1 z2 inp\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "let ?binpsw = \"swapBinp zs z1 z2 binp\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "let ?Left = \"h (Op delta ?inpsw ?binpsw)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "let ?Right = \"igSwap MOD zs z1 z2 (h (Op delta inp binp))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "have wlsLiftInp:\n     \"igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (lift h inp) \\<and>\n    igWlsBinp MOD delta (lift hA binp)", "using Op ****"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>a b. h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>a b. hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n   (barOf delta) binp\n  wlsInp ?delta87 ?inp87 \\<Longrightarrow>\n  igWlsInp MOD ?delta87 (lift h ?inp87)\n  wlsBinp ?delta87 ?binp87 \\<Longrightarrow>\n  igWlsBinp MOD ?delta87 (lift hA ?binp87)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (lift h inp) \\<and>\n    igWlsBinp MOD delta (lift hA binp)", "by simp"], ["proof (state)\nthis:\n  igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "have \"wlsInp delta ?inpsw \\<and> wlsBinp delta ?binpsw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsInp delta (inp %[z1 \\<and> z2]_zs) \\<and>\n    wlsBinp delta (binp %%[z1 \\<and> z2]_zs)", "using Op"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>a b. h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>a b. hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n   (barOf delta) binp\n\ngoal (1 subgoal):\n 1. wlsInp delta (inp %[z1 \\<and> z2]_zs) \\<and>\n    wlsBinp delta (binp %%[z1 \\<and> z2]_zs)", "by simp"], ["proof (state)\nthis:\n  wlsInp delta (inp %[z1 \\<and> z2]_zs) \\<and>\n  wlsBinp delta (binp %%[z1 \\<and> z2]_zs)\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "hence \"?Left = igOp MOD delta (lift h ?inpsw) (lift hA ?binpsw)\""], ["proof (prove)\nusing this:\n  wlsInp delta (inp %[z1 \\<and> z2]_zs) \\<and>\n  wlsBinp delta (binp %%[z1 \\<and> z2]_zs)\n\ngoal (1 subgoal):\n 1. h (Op delta (inp %[z1 \\<and> z2]_zs) (binp %%[z1 \\<and> z2]_zs)) =\n    igOp MOD delta (lift h (inp %[z1 \\<and> z2]_zs))\n     (lift hA (binp %%[z1 \\<and> z2]_zs))", "using *"], ["proof (prove)\nusing this:\n  wlsInp delta (inp %[z1 \\<and> z2]_zs) \\<and>\n  wlsBinp delta (binp %%[z1 \\<and> z2]_zs)\n  ipresCons h hA MOD\n\ngoal (1 subgoal):\n 1. h (Op delta (inp %[z1 \\<and> z2]_zs) (binp %%[z1 \\<and> z2]_zs)) =\n    igOp MOD delta (lift h (inp %[z1 \\<and> z2]_zs))\n     (lift hA (binp %%[z1 \\<and> z2]_zs))", "unfolding ipresCons_def ipresOp_def"], ["proof (prove)\nusing this:\n  wlsInp delta (inp %[z1 \\<and> z2]_zs) \\<and>\n  wlsBinp delta (binp %%[z1 \\<and> z2]_zs)\n  ipresVar h MOD \\<and>\n  ipresAbs h hA MOD \\<and>\n  (\\<forall>delta inp binp.\n      wlsInp delta inp \\<and> wlsBinp delta binp \\<longrightarrow>\n      h (Op delta inp binp) = igOp MOD delta (lift h inp) (lift hA binp))\n\ngoal (1 subgoal):\n 1. h (Op delta (inp %[z1 \\<and> z2]_zs) (binp %%[z1 \\<and> z2]_zs)) =\n    igOp MOD delta (lift h (inp %[z1 \\<and> z2]_zs))\n     (lift hA (binp %%[z1 \\<and> z2]_zs))", "by simp"], ["proof (state)\nthis:\n  h (Op delta (inp %[z1 \\<and> z2]_zs) (binp %%[z1 \\<and> z2]_zs)) =\n  igOp MOD delta (lift h (inp %[z1 \\<and> z2]_zs))\n   (lift hA (binp %%[z1 \\<and> z2]_zs))\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "moreover"], ["proof (state)\nthis:\n  h (Op delta (inp %[z1 \\<and> z2]_zs) (binp %%[z1 \\<and> z2]_zs)) =\n  igOp MOD delta (lift h (inp %[z1 \\<and> z2]_zs))\n   (lift hA (binp %%[z1 \\<and> z2]_zs))\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "have \"lift h ?inpsw = igSwapInp MOD zs z1 z2 (lift h inp) \\<and>\n           lift hA ?binpsw = igSwapBinp MOD zs z1 z2 (lift hA binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift h (inp %[z1 \\<and> z2]_zs) =\n    igSwapInp MOD zs z1 z2 (lift h inp) \\<and>\n    lift hA (binp %%[z1 \\<and> z2]_zs) =\n    igSwapBinp MOD zs z1 z2 (lift hA binp)", "using Op * not_None_eq"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>a b. h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>a b. hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n   (barOf delta) binp\n  ipresCons h hA MOD\n  (?x \\<noteq> None) = (\\<exists>y. ?x = Some y)\n\ngoal (1 subgoal):\n 1. lift h (inp %[z1 \\<and> z2]_zs) =\n    igSwapInp MOD zs z1 z2 (lift h inp) \\<and>\n    lift hA (binp %%[z1 \\<and> z2]_zs) =\n    igSwapBinp MOD zs z1 z2 (lift hA binp)", "by (simp add:  igSwapCls_def igSwapIGOp_def wlsInp_iff wlsBinp_iff\n     swapInp_def swapBinp_def igSwapInp_def igSwapBinp_def \n     lift_comp fun_eq_iff liftAll2_def lift_def sameDom_def split: option.splits)\n     (metis not_None_eq old.prod.exhaust)"], ["proof (state)\nthis:\n  lift h (inp %[z1 \\<and> z2]_zs) =\n  igSwapInp MOD zs z1 z2 (lift h inp) \\<and>\n  lift hA (binp %%[z1 \\<and> z2]_zs) =\n  igSwapBinp MOD zs z1 z2 (lift hA binp)\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "moreover"], ["proof (state)\nthis:\n  lift h (inp %[z1 \\<and> z2]_zs) =\n  igSwapInp MOD zs z1 z2 (lift h inp) \\<and>\n  lift hA (binp %%[z1 \\<and> z2]_zs) =\n  igSwapBinp MOD zs z1 z2 (lift hA binp)\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "have \"igOp MOD delta (igSwapInp MOD zs z1 z2 (lift h inp))\n                         (igSwapBinp MOD zs z1 z2 (lift hA binp)) =\n           igSwap MOD zs z1 z2 (igOp MOD delta (lift h inp) (lift hA binp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igOp MOD delta (igSwapInp MOD zs z1 z2 (lift h inp))\n     (igSwapBinp MOD zs z1 z2 (lift hA binp)) =\n    igSwap MOD zs z1 z2 (igOp MOD delta (lift h inp) (lift hA binp))", "using wlsLiftInp **"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\n  igSwapCls MOD\n\ngoal (1 subgoal):\n 1. igOp MOD delta (igSwapInp MOD zs z1 z2 (lift h inp))\n     (igSwapBinp MOD zs z1 z2 (lift hA binp)) =\n    igSwap MOD zs z1 z2 (igOp MOD delta (lift h inp) (lift hA binp))", "unfolding igSwapCls_def igSwapIGOp_def"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\n  igSwapIGVar MOD \\<and>\n  igSwapIGAbs MOD \\<and>\n  (\\<forall>zs z1 z2 delta inp binp.\n      igWlsInp MOD delta inp \\<and>\n      igWlsBinp MOD delta binp \\<longrightarrow>\n      igSwap MOD zs z1 z2 (igOp MOD delta inp binp) =\n      igOp MOD delta (igSwapInp MOD zs z1 z2 inp)\n       (igSwapBinp MOD zs z1 z2 binp))\n\ngoal (1 subgoal):\n 1. igOp MOD delta (igSwapInp MOD zs z1 z2 (lift h inp))\n     (igSwapBinp MOD zs z1 z2 (lift hA binp)) =\n    igSwap MOD zs z1 z2 (igOp MOD delta (lift h inp) (lift hA binp))", "by simp"], ["proof (state)\nthis:\n  igOp MOD delta (igSwapInp MOD zs z1 z2 (lift h inp))\n   (igSwapBinp MOD zs z1 z2 (lift hA binp)) =\n  igSwap MOD zs z1 z2 (igOp MOD delta (lift h inp) (lift hA binp))\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "moreover"], ["proof (state)\nthis:\n  igOp MOD delta (igSwapInp MOD zs z1 z2 (lift h inp))\n   (igSwapBinp MOD zs z1 z2 (lift hA binp)) =\n  igSwap MOD zs z1 z2 (igOp MOD delta (lift h inp) (lift hA binp))\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "have \"igSwap MOD zs z1 z2 (igOp MOD delta (lift h inp) (lift hA binp)) = ?Right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwap MOD zs z1 z2 (igOp MOD delta (lift h inp) (lift hA binp)) =\n    igSwap MOD zs z1 z2 (h (Op delta inp binp))", "using Op *"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>a b. h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>a b. hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n   (barOf delta) binp\n  ipresCons h hA MOD\n\ngoal (1 subgoal):\n 1. igSwap MOD zs z1 z2 (igOp MOD delta (lift h inp) (lift hA binp)) =\n    igSwap MOD zs z1 z2 (h (Op delta inp binp))", "unfolding ipresCons_def ipresOp_def"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>a b. h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>a b. hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n   (barOf delta) binp\n  ipresVar h MOD \\<and>\n  ipresAbs h hA MOD \\<and>\n  (\\<forall>delta inp binp.\n      wlsInp delta inp \\<and> wlsBinp delta binp \\<longrightarrow>\n      h (Op delta inp binp) = igOp MOD delta (lift h inp) (lift hA binp))\n\ngoal (1 subgoal):\n 1. igSwap MOD zs z1 z2 (igOp MOD delta (lift h inp) (lift hA binp)) =\n    igSwap MOD zs z1 z2 (h (Op delta inp binp))", "by simp"], ["proof (state)\nthis:\n  igSwap MOD zs z1 z2 (igOp MOD delta (lift h inp) (lift hA binp)) =\n  igSwap MOD zs z1 z2 (h (Op delta inp binp))\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "ultimately"], ["proof (chain)\npicking this:\n  h (Op delta (inp %[z1 \\<and> z2]_zs) (binp %%[z1 \\<and> z2]_zs)) =\n  igOp MOD delta (lift h (inp %[z1 \\<and> z2]_zs))\n   (lift hA (binp %%[z1 \\<and> z2]_zs))\n  lift h (inp %[z1 \\<and> z2]_zs) =\n  igSwapInp MOD zs z1 z2 (lift h inp) \\<and>\n  lift hA (binp %%[z1 \\<and> z2]_zs) =\n  igSwapBinp MOD zs z1 z2 (lift hA binp)\n  igOp MOD delta (igSwapInp MOD zs z1 z2 (lift h inp))\n   (igSwapBinp MOD zs z1 z2 (lift hA binp)) =\n  igSwap MOD zs z1 z2 (igOp MOD delta (lift h inp) (lift hA binp))\n  igSwap MOD zs z1 z2 (igOp MOD delta (lift h inp) (lift hA binp)) =\n  igSwap MOD zs z1 z2 (h (Op delta inp binp))", "have \"?Left = ?Right\""], ["proof (prove)\nusing this:\n  h (Op delta (inp %[z1 \\<and> z2]_zs) (binp %%[z1 \\<and> z2]_zs)) =\n  igOp MOD delta (lift h (inp %[z1 \\<and> z2]_zs))\n   (lift hA (binp %%[z1 \\<and> z2]_zs))\n  lift h (inp %[z1 \\<and> z2]_zs) =\n  igSwapInp MOD zs z1 z2 (lift h inp) \\<and>\n  lift hA (binp %%[z1 \\<and> z2]_zs) =\n  igSwapBinp MOD zs z1 z2 (lift hA binp)\n  igOp MOD delta (igSwapInp MOD zs z1 z2 (lift h inp))\n   (igSwapBinp MOD zs z1 z2 (lift hA binp)) =\n  igSwap MOD zs z1 z2 (igOp MOD delta (lift h inp) (lift hA binp))\n  igSwap MOD zs z1 z2 (igOp MOD delta (lift h inp) (lift hA binp)) =\n  igSwap MOD zs z1 z2 (h (Op delta inp binp))\n\ngoal (1 subgoal):\n 1. h (Op delta (inp %[z1 \\<and> z2]_zs) (binp %%[z1 \\<and> z2]_zs)) =\n    igSwap MOD zs z1 z2 (h (Op delta inp binp))", "by simp"], ["proof (state)\nthis:\n  h (Op delta (inp %[z1 \\<and> z2]_zs) (binp %%[z1 \\<and> z2]_zs)) =\n  igSwap MOD zs z1 z2 (h (Op delta inp binp))\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>a b.\n             h (b #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h b))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>a b.\n             hA (b $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA b))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n                         igSwap MOD zs z1 z2 (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "then"], ["proof (chain)\npicking this:\n  h (Op delta (inp %[z1 \\<and> z2]_zs) (binp %%[z1 \\<and> z2]_zs)) =\n  igSwap MOD zs z1 z2 (h (Op delta inp binp))", "show ?case"], ["proof (prove)\nusing this:\n  h (Op delta (inp %[z1 \\<and> z2]_zs) (binp %%[z1 \\<and> z2]_zs)) =\n  igSwap MOD zs z1 z2 (h (Op delta inp binp))\n\ngoal (1 subgoal):\n 1. h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n    igSwap MOD zs z1 z2 (h (Op delta inp binp))", "by (simp add: Op)"], ["proof (state)\nthis:\n  h (Op delta inp binp #[z1 \\<and> z2]_zs) =\n  igSwap MOD zs z1 z2 (h (Op delta inp binp))\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "case (Abs s xs x X)"], ["proof (state)\nthis:\n  isInBar (xs, s)\n  wls s X\n  h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "let ?Xsw = \"swap zs z1 z2 X\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "let ?xsw = \"x @xs[z1 \\<and> z2]_zs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "have hX: \"igWls MOD s (h X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls MOD s (h X)", "using Abs.IH ***"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\n  ipresWlsAll h hA MOD\n\ngoal (1 subgoal):\n 1. igWls MOD s (h X)", "unfolding ipresWlsAll_def ipresWls_def"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\n  (\\<forall>s X. wls s X \\<longrightarrow> igWls MOD s (h X)) \\<and>\n  ipresWlsAbs hA MOD\n\ngoal (1 subgoal):\n 1. igWls MOD s (h X)", "by simp"], ["proof (state)\nthis:\n  igWls MOD s (h X)\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "let ?Left = \"hA (Abs xs ?xsw ?Xsw)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "let ?Right = \"igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "have \"wls s (swap zs z1 z2 X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wls s (X #[z1 \\<and> z2]_zs)", "using Abs"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\n\ngoal (1 subgoal):\n 1. wls s (X #[z1 \\<and> z2]_zs)", "by simp"], ["proof (state)\nthis:\n  wls s (X #[z1 \\<and> z2]_zs)\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "hence \"?Left = igAbs MOD xs ?xsw (h ?Xsw)\""], ["proof (prove)\nusing this:\n  wls s (X #[z1 \\<and> z2]_zs)\n\ngoal (1 subgoal):\n 1. hA (Abs xs (x @xs[z1 \\<and> z2]_zs) (X #[z1 \\<and> z2]_zs)) =\n    igAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (h (X #[z1 \\<and> z2]_zs))", "using Abs *"], ["proof (prove)\nusing this:\n  wls s (X #[z1 \\<and> z2]_zs)\n  isInBar (xs, s)\n  wls s X\n  h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\n  ipresCons h hA MOD\n\ngoal (1 subgoal):\n 1. hA (Abs xs (x @xs[z1 \\<and> z2]_zs) (X #[z1 \\<and> z2]_zs)) =\n    igAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (h (X #[z1 \\<and> z2]_zs))", "unfolding ipresCons_def ipresAbs_def"], ["proof (prove)\nusing this:\n  wls s (X #[z1 \\<and> z2]_zs)\n  isInBar (xs, s)\n  wls s X\n  h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\n  ipresVar h MOD \\<and>\n  (\\<forall>xs x s X.\n      isInBar (xs, s) \\<and> wls s X \\<longrightarrow>\n      hA (Abs xs x X) = igAbs MOD xs x (h X)) \\<and>\n  ipresOp h hA MOD\n\ngoal (1 subgoal):\n 1. hA (Abs xs (x @xs[z1 \\<and> z2]_zs) (X #[z1 \\<and> z2]_zs)) =\n    igAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (h (X #[z1 \\<and> z2]_zs))", "by blast"], ["proof (state)\nthis:\n  hA (Abs xs (x @xs[z1 \\<and> z2]_zs) (X #[z1 \\<and> z2]_zs)) =\n  igAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (h (X #[z1 \\<and> z2]_zs))\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "also"], ["proof (state)\nthis:\n  hA (Abs xs (x @xs[z1 \\<and> z2]_zs) (X #[z1 \\<and> z2]_zs)) =\n  igAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (h (X #[z1 \\<and> z2]_zs))\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "note Abs(3)"], ["proof (state)\nthis:\n  h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "also"], ["proof (state)\nthis:\n  h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "have \"igAbs MOD xs ?xsw (igSwap MOD zs z1 z2 (h X)) =\n                igSwapAbs MOD zs z1 z2 (igAbs MOD xs x (h X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (igSwap MOD zs z1 z2 (h X)) =\n    igSwapAbs MOD zs z1 z2 (igAbs MOD xs x (h X))", "using Abs hX **"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\n  igWls MOD s (h X)\n  igSwapCls MOD\n\ngoal (1 subgoal):\n 1. igAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (igSwap MOD zs z1 z2 (h X)) =\n    igSwapAbs MOD zs z1 z2 (igAbs MOD xs x (h X))", "by (auto simp: igSwapCls_def igSwapIGAbs_def)"], ["proof (state)\nthis:\n  igAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (igSwap MOD zs z1 z2 (h X)) =\n  igSwapAbs MOD zs z1 z2 (igAbs MOD xs x (h X))\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "also"], ["proof (state)\nthis:\n  igAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (igSwap MOD zs z1 z2 (h X)) =\n  igSwapAbs MOD zs z1 z2 (igAbs MOD xs x (h X))\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "have \"\\<dots> = ?Right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapAbs MOD zs z1 z2 (igAbs MOD xs x (h X)) =\n    igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "using Abs *"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\n  ipresCons h hA MOD\n\ngoal (1 subgoal):\n 1. igSwapAbs MOD zs z1 z2 (igAbs MOD xs x (h X)) =\n    igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "by (auto simp: ipresCons_def ipresAbs_def)"], ["proof (state)\nthis:\n  igSwapAbs MOD zs z1 z2 (igAbs MOD xs x (h X)) =\n  igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "finally"], ["proof (chain)\npicking this:\n  hA (Abs xs (x @xs[z1 \\<and> z2]_zs) (X #[z1 \\<and> z2]_zs)) =\n  igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "have \"?Left = ?Right\""], ["proof (prove)\nusing this:\n  hA (Abs xs (x @xs[z1 \\<and> z2]_zs) (X #[z1 \\<and> z2]_zs)) =\n  igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))\n\ngoal (1 subgoal):\n 1. hA (Abs xs (x @xs[z1 \\<and> z2]_zs) (X #[z1 \\<and> z2]_zs)) =\n    igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "."], ["proof (state)\nthis:\n  hA (Abs xs (x @xs[z1 \\<and> z2]_zs) (X #[z1 \\<and> z2]_zs)) =\n  igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X;\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n                         igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "then"], ["proof (chain)\npicking this:\n  hA (Abs xs (x @xs[z1 \\<and> z2]_zs) (X #[z1 \\<and> z2]_zs)) =\n  igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "show ?case"], ["proof (prove)\nusing this:\n  hA (Abs xs (x @xs[z1 \\<and> z2]_zs) (X #[z1 \\<and> z2]_zs)) =\n  igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))\n\ngoal (1 subgoal):\n 1. hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n    igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "using Abs(2)"], ["proof (prove)\nusing this:\n  hA (Abs xs (x @xs[z1 \\<and> z2]_zs) (X #[z1 \\<and> z2]_zs)) =\n  igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))\n  wls s X\n\ngoal (1 subgoal):\n 1. hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n    igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))", "by auto"], ["proof (state)\nthis:\n  hA (Abs xs x X $[z1 \\<and> z2]_zs) =\n  igSwapAbs MOD zs z1 z2 (hA (Abs xs x X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (wls s X \\<longrightarrow>\n   h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)) \\<and>\n  (wlsAbs (us, s') A \\<longrightarrow>\n   hA (A $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA A))\n\ngoal (1 subgoal):\n 1. ipresSwapAll h hA MOD", "}"], ["proof (state)\nthis:\n  (wls ?s89 ?X89 \\<longrightarrow>\n   h (?X89 #[?z1.89 \\<and> ?z2.89]_?zs89) =\n   igSwap MOD ?zs89 ?z1.89 ?z2.89 (h ?X89)) \\<and>\n  (wlsAbs (?us89, ?s'89) ?A89 \\<longrightarrow>\n   hA (?A89 $[?z1.89 \\<and> ?z2.89]_?zs89) =\n   igSwapAbs MOD ?zs89 ?z1.89 ?z2.89 (hA ?A89))\n\ngoal (1 subgoal):\n 1. ipresSwapAll h hA MOD", "thus ?thesis"], ["proof (prove)\nusing this:\n  (wls ?s89 ?X89 \\<longrightarrow>\n   h (?X89 #[?z1.89 \\<and> ?z2.89]_?zs89) =\n   igSwap MOD ?zs89 ?z1.89 ?z2.89 (h ?X89)) \\<and>\n  (wlsAbs (?us89, ?s'89) ?A89 \\<longrightarrow>\n   hA (?A89 $[?z1.89 \\<and> ?z2.89]_?zs89) =\n   igSwapAbs MOD ?zs89 ?z1.89 ?z2.89 (hA ?A89))\n\ngoal (1 subgoal):\n 1. ipresSwapAll h hA MOD", "unfolding ipresSwapAll_defs"], ["proof (prove)\nusing this:\n  (wls ?s89 ?X89 \\<longrightarrow>\n   h (?X89 #[?z1.89 \\<and> ?z2.89]_?zs89) =\n   igSwap MOD ?zs89 ?z1.89 ?z2.89 (h ?X89)) \\<and>\n  (wlsAbs (?us89, ?s'89) ?A89 \\<longrightarrow>\n   hA (?A89 $[?z1.89 \\<and> ?z2.89]_?zs89) =\n   igSwapAbs MOD ?zs89 ?z1.89 ?z2.89 (hA ?A89))\n\ngoal (1 subgoal):\n 1. (\\<forall>zs z1 z2 s X.\n        wls s X \\<longrightarrow>\n        h (X #[z1 \\<and> z2]_zs) = igSwap MOD zs z1 z2 (h X)) \\<and>\n    (\\<forall>zs z1 z2 us s A.\n        wlsAbs (us, s) A \\<longrightarrow>\n        hA (A $[z1 \\<and> z2]_zs) = igSwapAbs MOD zs z1 z2 (hA A))", "by auto"], ["proof (state)\nthis:\n  ipresSwapAll h hA MOD\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipresCons_imp_ipresSubstAll_aux:\nassumes *: \"ipresCons h hA MOD\" and **: \"igSubstCls MOD\"\nand \"igConsIPresIGWls MOD\" and \"igFreshCls MOD\"\nassumes P: \"wlsPar P\"\nshows\n\"(wls s X \\<longrightarrow>\n  (\\<forall> ys y Y. y \\<in> varsOfS P ys \\<and> Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n             h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)))\n\\<and>\n (wlsAbs (us,s') A \\<longrightarrow>\n  (\\<forall> ys y Y. y \\<in> varsOfS P ys \\<and> Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n             hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow>\n     (\\<forall>ys y Y.\n         y \\<in> varsOfS P ys \\<and>\n         Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n         h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow>\n     (\\<forall>ys y Y.\n         y \\<in> varsOfS P ys \\<and>\n         Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n         hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow>\n     (\\<forall>ys y Y.\n         y \\<in> varsOfS P ys \\<and>\n         Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n         h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow>\n     (\\<forall>ys y Y.\n         y \\<in> varsOfS P ys \\<and>\n         Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n         hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A)))", "have ***: \"ipresWlsAll h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresWlsAll h hA MOD", "using assms ipresCons_imp_ipresWlsAll"], ["proof (prove)\nusing this:\n  ipresCons h hA MOD\n  igSubstCls MOD\n  igConsIPresIGWls MOD\n  igFreshCls MOD\n  wlsPar P\n  \\<lbrakk>ipresCons ?h ?hA ?MOD; igConsIPresIGWls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresWlsAll ?h ?hA ?MOD\n\ngoal (1 subgoal):\n 1. ipresWlsAll h hA MOD", "by auto"], ["proof (state)\nthis:\n  ipresWlsAll h hA MOD\n\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow>\n     (\\<forall>ys y Y.\n         y \\<in> varsOfS P ys \\<and>\n         Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n         h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow>\n     (\\<forall>ys y Y.\n         y \\<in> varsOfS P ys \\<and>\n         Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n         hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A)))", "hence ****:\n  \"\\<And> delta inp. wlsInp delta inp \\<Longrightarrow> igWlsInp MOD delta (lift h inp)\"\n  \"\\<And> delta binp. wlsBinp delta binp \\<Longrightarrow> igWlsBinp MOD delta (lift hA binp)\""], ["proof (prove)\nusing this:\n  ipresWlsAll h hA MOD\n\ngoal (1 subgoal):\n 1. (\\<And>delta inp.\n        wlsInp delta inp \\<Longrightarrow>\n        igWlsInp MOD delta (lift h inp)) &&&\n    (\\<And>delta binp.\n        wlsBinp delta binp \\<Longrightarrow>\n        igWlsBinp MOD delta (lift hA binp))", "unfolding ipresWlsAll_def"], ["proof (prove)\nusing this:\n  ipresWls h MOD \\<and> ipresWlsAbs hA MOD\n\ngoal (1 subgoal):\n 1. (\\<And>delta inp.\n        wlsInp delta inp \\<Longrightarrow>\n        igWlsInp MOD delta (lift h inp)) &&&\n    (\\<And>delta binp.\n        wlsBinp delta binp \\<Longrightarrow>\n        igWlsBinp MOD delta (lift hA binp))", "using ipresWls_wlsInp ipresWls_wlsBinp"], ["proof (prove)\nusing this:\n  ipresWls h MOD \\<and> ipresWlsAbs hA MOD\n  \\<lbrakk>wlsInp ?delta ?inp; ipresWls ?h ?MOD\\<rbrakk>\n  \\<Longrightarrow> igWlsInp ?MOD ?delta (lift ?h ?inp)\n  \\<lbrakk>wlsBinp ?delta ?binp; ipresWlsAbs ?hA ?MOD\\<rbrakk>\n  \\<Longrightarrow> igWlsBinp ?MOD ?delta (lift ?hA ?binp)\n\ngoal (1 subgoal):\n 1. (\\<And>delta inp.\n        wlsInp delta inp \\<Longrightarrow>\n        igWlsInp MOD delta (lift h inp)) &&&\n    (\\<And>delta binp.\n        wlsBinp delta binp \\<Longrightarrow>\n        igWlsBinp MOD delta (lift hA binp))", "by auto"], ["proof (state)\nthis:\n  wlsInp ?delta87 ?inp87 \\<Longrightarrow>\n  igWlsInp MOD ?delta87 (lift h ?inp87)\n  wlsBinp ?delta87 ?binp87 \\<Longrightarrow>\n  igWlsBinp MOD ?delta87 (lift hA ?binp87)\n\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow>\n     (\\<forall>ys y Y.\n         y \\<in> varsOfS P ys \\<and>\n         Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n         h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow>\n     (\\<forall>ys y Y.\n         y \\<in> varsOfS P ys \\<and>\n         Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n         hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A)))", "have *****: \"ipresFreshAll h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresFreshAll h hA MOD", "using assms ipresCons_imp_ipresFreshAll"], ["proof (prove)\nusing this:\n  ipresCons h hA MOD\n  igSubstCls MOD\n  igConsIPresIGWls MOD\n  igFreshCls MOD\n  wlsPar P\n  \\<lbrakk>ipresCons ?h ?hA ?MOD; igFreshCls ?MOD;\n   igConsIPresIGWls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresFreshAll ?h ?hA ?MOD\n\ngoal (1 subgoal):\n 1. ipresFreshAll h hA MOD", "by auto"], ["proof (state)\nthis:\n  ipresFreshAll h hA MOD\n\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow>\n     (\\<forall>ys y Y.\n         y \\<in> varsOfS P ys \\<and>\n         Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n         h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow>\n     (\\<forall>ys y Y.\n         y \\<in> varsOfS P ys \\<and>\n         Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n         hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A)))", "(*  *)"], ["proof (state)\nthis:\n  ipresFreshAll h hA MOD\n\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow>\n     (\\<forall>ys y Y.\n         y \\<in> varsOfS P ys \\<and>\n         Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n         h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow>\n     (\\<forall>ys y Y.\n         y \\<in> varsOfS P ys \\<and>\n         Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n         hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow>\n     (\\<forall>ys y Y.\n         y \\<in> varsOfS P ys \\<and>\n         Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n         h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow>\n     (\\<forall>ys y Y.\n         y \\<in> varsOfS P ys \\<and>\n         Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n         hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A)))", "proof(induction rule: wls_induct_fresh[of P])"], ["proof (state)\ngoal (4 subgoals):\n 1. wlsPar P\n 2. \\<And>xs x.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          h (Var xs x #[Y / y]_ys) = igSubst MOD ys (h Y) y (h (Var xs x))\n 3. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>s X.\n             \\<forall>ys y Y.\n                y \\<in> varsOfS P ys \\<and>\n                Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>(us, s) A.\n             \\<forall>ys y Y.\n                y \\<in> varsOfS P ys \\<and>\n                Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            h (Op delta inp binp #[Y / y]_ys) =\n                            igSubst MOD ys (h Y) y (h (Op delta inp binp))\n 4. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; x \\<notin> varsOfS P xs;\n        \\<And>s' Y. Y \\<in> termsOfS P s' \\<Longrightarrow> fresh xs x Y;\n        \\<And>us s' A.\n           A \\<in> absOfS P (us, s') \\<Longrightarrow> freshAbs xs x A;\n        \\<And>rho. rho \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x rho;\n        \\<forall>ys y Y.\n           y \\<in> varsOfS P ys \\<and>\n           Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n           h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            hA (Abs xs x X $[Y / y]_ys) =\n                            igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "case Par"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. wlsPar P\n 2. \\<And>xs x.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          h (Var xs x #[Y / y]_ys) = igSubst MOD ys (h Y) y (h (Var xs x))\n 3. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>s X.\n             \\<forall>ys y Y.\n                y \\<in> varsOfS P ys \\<and>\n                Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>(us, s) A.\n             \\<forall>ys y Y.\n                y \\<in> varsOfS P ys \\<and>\n                Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            h (Op delta inp binp #[Y / y]_ys) =\n                            igSubst MOD ys (h Y) y (h (Op delta inp binp))\n 4. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; x \\<notin> varsOfS P xs;\n        \\<And>s' Y. Y \\<in> termsOfS P s' \\<Longrightarrow> fresh xs x Y;\n        \\<And>us s' A.\n           A \\<in> absOfS P (us, s') \\<Longrightarrow> freshAbs xs x A;\n        \\<And>rho. rho \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x rho;\n        \\<forall>ys y Y.\n           y \\<in> varsOfS P ys \\<and>\n           Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n           h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            hA (Abs xs x X $[Y / y]_ys) =\n                            igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsPar P", "using P"], ["proof (prove)\nusing this:\n  wlsPar P\n\ngoal (1 subgoal):\n 1. wlsPar P", "by auto"], ["proof (state)\nthis:\n  wlsPar P\n\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          h (Var xs x #[Y / y]_ys) = igSubst MOD ys (h Y) y (h (Var xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>s X.\n             \\<forall>ys y Y.\n                y \\<in> varsOfS P ys \\<and>\n                Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>(us, s) A.\n             \\<forall>ys y Y.\n                y \\<in> varsOfS P ys \\<and>\n                Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            h (Op delta inp binp #[Y / y]_ys) =\n                            igSubst MOD ys (h Y) y (h (Op delta inp binp))\n 3. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; x \\<notin> varsOfS P xs;\n        \\<And>s' Y. Y \\<in> termsOfS P s' \\<Longrightarrow> fresh xs x Y;\n        \\<And>us s' A.\n           A \\<in> absOfS P (us, s') \\<Longrightarrow> freshAbs xs x A;\n        \\<And>rho. rho \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x rho;\n        \\<forall>ys y Y.\n           y \\<in> varsOfS P ys \\<and>\n           Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n           h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            hA (Abs xs x X $[Y / y]_ys) =\n                            igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          h (Var xs x #[Y / y]_ys) = igSubst MOD ys (h Y) y (h (Var xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>s X.\n             \\<forall>ys y Y.\n                y \\<in> varsOfS P ys \\<and>\n                Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>(us, s) A.\n             \\<forall>ys y Y.\n                y \\<in> varsOfS P ys \\<and>\n                Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            h (Op delta inp binp #[Y / y]_ys) =\n                            igSubst MOD ys (h Y) y (h (Op delta inp binp))\n 3. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; x \\<notin> varsOfS P xs;\n        \\<And>s' Y. Y \\<in> termsOfS P s' \\<Longrightarrow> fresh xs x Y;\n        \\<And>us s' A.\n           A \\<in> absOfS P (us, s') \\<Longrightarrow> freshAbs xs x A;\n        \\<And>rho. rho \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x rho;\n        \\<forall>ys y Y.\n           y \\<in> varsOfS P ys \\<and>\n           Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n           h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            hA (Abs xs x X $[Y / y]_ys) =\n                            igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "case (Var xs x)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          h (Var xs x #[Y / y]_ys) = igSubst MOD ys (h Y) y (h (Var xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>s X.\n             \\<forall>ys y Y.\n                y \\<in> varsOfS P ys \\<and>\n                Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>(us, s) A.\n             \\<forall>ys y Y.\n                y \\<in> varsOfS P ys \\<and>\n                Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            h (Op delta inp binp #[Y / y]_ys) =\n                            igSubst MOD ys (h Y) y (h (Op delta inp binp))\n 3. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; x \\<notin> varsOfS P xs;\n        \\<And>s' Y. Y \\<in> termsOfS P s' \\<Longrightarrow> fresh xs x Y;\n        \\<And>us s' A.\n           A \\<in> absOfS P (us, s') \\<Longrightarrow> freshAbs xs x A;\n        \\<And>rho. rho \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x rho;\n        \\<forall>ys y Y.\n           y \\<in> varsOfS P ys \\<and>\n           Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n           h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            hA (Abs xs x X $[Y / y]_ys) =\n                            igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y Y.\n       y \\<in> varsOfS P ys \\<and>\n       Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n       h (Var xs x #[Y / y]_ys) = igSubst MOD ys (h Y) y (h (Var xs x))", "using assms"], ["proof (prove)\nusing this:\n  ipresCons h hA MOD\n  igSubstCls MOD\n  igConsIPresIGWls MOD\n  igFreshCls MOD\n  wlsPar P\n\ngoal (1 subgoal):\n 1. \\<forall>ys y Y.\n       y \\<in> varsOfS P ys \\<and>\n       Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n       h (Var xs x #[Y / y]_ys) = igSubst MOD ys (h Y) y (h (Var xs x))", "by (simp add: ipresWlsAll_def ipresWls_def igSubstCls_def igSubstIGVar2_def \n       ipresCons_def ipresVar_def)  \n    (metis \"***\" FixSyn.ipresWlsAll_defs(1) FixSyn.ipresWlsAll_defs(2) FixSyn_axioms \n      igSubstIGVar1_def wlsPar_def wls_subst_Var_simp1 wls_subst_Var_simp2)"], ["proof (state)\nthis:\n  \\<forall>ys y Y.\n     y \\<in> varsOfS P ys \\<and>\n     Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n     h (Var xs x #[Y / y]_ys) = igSubst MOD ys (h Y) y (h (Var xs x))\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>s X.\n             \\<forall>ys y Y.\n                y \\<in> varsOfS P ys \\<and>\n                Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>(us, s) A.\n             \\<forall>ys y Y.\n                y \\<in> varsOfS P ys \\<and>\n                Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            h (Op delta inp binp #[Y / y]_ys) =\n                            igSubst MOD ys (h Y) y (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; x \\<notin> varsOfS P xs;\n        \\<And>s' Y. Y \\<in> termsOfS P s' \\<Longrightarrow> fresh xs x Y;\n        \\<And>us s' A.\n           A \\<in> absOfS P (us, s') \\<Longrightarrow> freshAbs xs x A;\n        \\<And>rho. rho \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x rho;\n        \\<forall>ys y Y.\n           y \\<in> varsOfS P ys \\<and>\n           Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n           h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            hA (Abs xs x X $[Y / y]_ys) =\n                            igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>s X.\n             \\<forall>ys y Y.\n                y \\<in> varsOfS P ys \\<and>\n                Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>(us, s) A.\n             \\<forall>ys y Y.\n                y \\<in> varsOfS P ys \\<and>\n                Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            h (Op delta inp binp #[Y / y]_ys) =\n                            igSubst MOD ys (h Y) y (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; x \\<notin> varsOfS P xs;\n        \\<And>s' Y. Y \\<in> termsOfS P s' \\<Longrightarrow> fresh xs x Y;\n        \\<And>us s' A.\n           A \\<in> absOfS P (us, s') \\<Longrightarrow> freshAbs xs x A;\n        \\<And>rho. rho \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x rho;\n        \\<forall>ys y Y.\n           y \\<in> varsOfS P ys \\<and>\n           Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n           h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            hA (Abs xs x X $[Y / y]_ys) =\n                            igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "case (Op delta inp binp)"], ["proof (state)\nthis:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>s X.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>(us, s) A.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A))\n   (barOf delta) binp\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2\n         (\\<lambda>s X.\n             \\<forall>ys y Y.\n                y \\<in> varsOfS P ys \\<and>\n                Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))\n         (arOf delta) inp;\n        liftAll2\n         (\\<lambda>(us, s) A.\n             \\<forall>ys y Y.\n                y \\<in> varsOfS P ys \\<and>\n                Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A))\n         (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            h (Op delta inp binp #[Y / y]_ys) =\n                            igSubst MOD ys (h Y) y (h (Op delta inp binp))\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; x \\<notin> varsOfS P xs;\n        \\<And>s' Y. Y \\<in> termsOfS P s' \\<Longrightarrow> fresh xs x Y;\n        \\<And>us s' A.\n           A \\<in> absOfS P (us, s') \\<Longrightarrow> freshAbs xs x A;\n        \\<And>rho. rho \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x rho;\n        \\<forall>ys y Y.\n           y \\<in> varsOfS P ys \\<and>\n           Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n           h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            hA (Abs xs x X $[Y / y]_ys) =\n                            igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y Y.\n       y \\<in> varsOfS P ys \\<and>\n       Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n       h (Op delta inp binp #[Y / y]_ys) =\n       igSubst MOD ys (h Y) y (h (Op delta inp binp))", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[Y / y]_ys) =\n                         igSubst MOD ys (h Y) y (h (Op delta inp binp))", "fix ys y Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[Y / y]_ys) =\n                         igSubst MOD ys (h Y) y (h (Op delta inp binp))", "assume yP: \"y \\<in> varsOfS P ys\" and YP: \"Y \\<in> termsOfS P (asSort ys)\""], ["proof (state)\nthis:\n  y \\<in> varsOfS P ys\n  Y \\<in> termsOfS P (asSort ys)\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[Y / y]_ys) =\n                         igSubst MOD ys (h Y) y (h (Op delta inp binp))", "hence Y: \"wls (asSort ys) Y\""], ["proof (prove)\nusing this:\n  y \\<in> varsOfS P ys\n  Y \\<in> termsOfS P (asSort ys)\n\ngoal (1 subgoal):\n 1. wls (asSort ys) Y", "using P"], ["proof (prove)\nusing this:\n  y \\<in> varsOfS P ys\n  Y \\<in> termsOfS P (asSort ys)\n  wlsPar P\n\ngoal (1 subgoal):\n 1. wls (asSort ys) Y", "by auto"], ["proof (state)\nthis:\n  wls (asSort ys) Y\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[Y / y]_ys) =\n                         igSubst MOD ys (h Y) y (h (Op delta inp binp))", "hence hY: \"igWls MOD (asSort ys) (h Y)\""], ["proof (prove)\nusing this:\n  wls (asSort ys) Y\n\ngoal (1 subgoal):\n 1. igWls MOD (asSort ys) (h Y)", "using ***"], ["proof (prove)\nusing this:\n  wls (asSort ys) Y\n  ipresWlsAll h hA MOD\n\ngoal (1 subgoal):\n 1. igWls MOD (asSort ys) (h Y)", "unfolding ipresWlsAll_def ipresWls_def"], ["proof (prove)\nusing this:\n  wls (asSort ys) Y\n  (\\<forall>s X. wls s X \\<longrightarrow> igWls MOD s (h X)) \\<and>\n  ipresWlsAbs hA MOD\n\ngoal (1 subgoal):\n 1. igWls MOD (asSort ys) (h Y)", "by simp"], ["proof (state)\nthis:\n  igWls MOD (asSort ys) (h Y)\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[Y / y]_ys) =\n                         igSubst MOD ys (h Y) y (h (Op delta inp binp))", "have sinp: \"wlsInp delta (substInp ys Y y inp) \\<and>\n                wlsBinp delta (substBinp ys Y y binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsInp delta (inp %[Y / y]_ys) \\<and> wlsBinp delta (binp %%[Y / y]_ys)", "using Y Op"], ["proof (prove)\nusing this:\n  wls (asSort ys) Y\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>s X.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>(us, s) A.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A))\n   (barOf delta) binp\n\ngoal (1 subgoal):\n 1. wlsInp delta (inp %[Y / y]_ys) \\<and> wlsBinp delta (binp %%[Y / y]_ys)", "by simp"], ["proof (state)\nthis:\n  wlsInp delta (inp %[Y / y]_ys) \\<and> wlsBinp delta (binp %%[Y / y]_ys)\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[Y / y]_ys) =\n                         igSubst MOD ys (h Y) y (h (Op delta inp binp))", "have liftInp: \"igWlsInp MOD delta (lift h inp) \\<and>\n                     igWlsBinp MOD delta (lift hA binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (lift h inp) \\<and>\n    igWlsBinp MOD delta (lift hA binp)", "using Op ****"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>s X.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>(us, s) A.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A))\n   (barOf delta) binp\n  wlsInp ?delta87 ?inp87 \\<Longrightarrow>\n  igWlsInp MOD ?delta87 (lift h ?inp87)\n  wlsBinp ?delta87 ?binp87 \\<Longrightarrow>\n  igWlsBinp MOD ?delta87 (lift hA ?binp87)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (lift h inp) \\<and>\n    igWlsBinp MOD delta (lift hA binp)", "by simp"], ["proof (state)\nthis:\n  igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[Y / y]_ys) =\n                         igSubst MOD ys (h Y) y (h (Op delta inp binp))", "let ?Left = \"h ((Op delta inp binp) #[Y / y]_ys)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[Y / y]_ys) =\n                         igSubst MOD ys (h Y) y (h (Op delta inp binp))", "let ?Right = \"igSubst MOD ys (h Y) y (h (Op delta inp binp))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[Y / y]_ys) =\n                         igSubst MOD ys (h Y) y (h (Op delta inp binp))", "have \"?Left = igOp MOD delta (lift h (substInp ys Y y inp))\n                                   (lift hA (substBinp ys Y y binp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h (Op delta inp binp #[Y / y]_ys) =\n    igOp MOD delta (lift h (inp %[Y / y]_ys)) (lift hA (binp %%[Y / y]_ys))", "using sinp *"], ["proof (prove)\nusing this:\n  wlsInp delta (inp %[Y / y]_ys) \\<and> wlsBinp delta (binp %%[Y / y]_ys)\n  ipresCons h hA MOD\n\ngoal (1 subgoal):\n 1. h (Op delta inp binp #[Y / y]_ys) =\n    igOp MOD delta (lift h (inp %[Y / y]_ys)) (lift hA (binp %%[Y / y]_ys))", "unfolding ipresCons_def ipresOp_def"], ["proof (prove)\nusing this:\n  wlsInp delta (inp %[Y / y]_ys) \\<and> wlsBinp delta (binp %%[Y / y]_ys)\n  ipresVar h MOD \\<and>\n  ipresAbs h hA MOD \\<and>\n  (\\<forall>delta inp binp.\n      wlsInp delta inp \\<and> wlsBinp delta binp \\<longrightarrow>\n      h (Op delta inp binp) = igOp MOD delta (lift h inp) (lift hA binp))\n\ngoal (1 subgoal):\n 1. h (Op delta inp binp #[Y / y]_ys) =\n    igOp MOD delta (lift h (inp %[Y / y]_ys)) (lift hA (binp %%[Y / y]_ys))", "by (simp add: Op.IH(1) Op.IH(2) Y)"], ["proof (state)\nthis:\n  h (Op delta inp binp #[Y / y]_ys) =\n  igOp MOD delta (lift h (inp %[Y / y]_ys)) (lift hA (binp %%[Y / y]_ys))\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[Y / y]_ys) =\n                         igSubst MOD ys (h Y) y (h (Op delta inp binp))", "moreover"], ["proof (state)\nthis:\n  h (Op delta inp binp #[Y / y]_ys) =\n  igOp MOD delta (lift h (inp %[Y / y]_ys)) (lift hA (binp %%[Y / y]_ys))\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[Y / y]_ys) =\n                         igSubst MOD ys (h Y) y (h (Op delta inp binp))", "have \"lift h (substInp ys Y y inp) = igSubstInp MOD ys (h Y) y (lift h inp) \\<and>\n            lift hA (substBinp ys Y y binp) = igSubstBinp MOD ys (h Y) y (lift hA binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift h (inp %[Y / y]_ys) = igSubstInp MOD ys (h Y) y (lift h inp) \\<and>\n    lift hA (binp %%[Y / y]_ys) = igSubstBinp MOD ys (h Y) y (lift hA binp)", "using Op YP yP"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>s X.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>(us, s) A.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A))\n   (barOf delta) binp\n  Y \\<in> termsOfS P (asSort ys)\n  y \\<in> varsOfS P ys\n\ngoal (1 subgoal):\n 1. lift h (inp %[Y / y]_ys) = igSubstInp MOD ys (h Y) y (lift h inp) \\<and>\n    lift hA (binp %%[Y / y]_ys) = igSubstBinp MOD ys (h Y) y (lift hA binp)", "by (simp add: substInp_def2 igSubstInp_def substBinp_def2 igSubstBinp_def lift_comp \n      lift_def liftAll2_def fun_eq_iff wlsInp_iff wlsBinp_iff sameDom_def split: option.splits) \n      (metis (no_types, hide_lams) not_Some_eq option.distinct(1) sinp wlsBinp.simps)"], ["proof (state)\nthis:\n  lift h (inp %[Y / y]_ys) = igSubstInp MOD ys (h Y) y (lift h inp) \\<and>\n  lift hA (binp %%[Y / y]_ys) = igSubstBinp MOD ys (h Y) y (lift hA binp)\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[Y / y]_ys) =\n                         igSubst MOD ys (h Y) y (h (Op delta inp binp))", "moreover"], ["proof (state)\nthis:\n  lift h (inp %[Y / y]_ys) = igSubstInp MOD ys (h Y) y (lift h inp) \\<and>\n  lift hA (binp %%[Y / y]_ys) = igSubstBinp MOD ys (h Y) y (lift hA binp)\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[Y / y]_ys) =\n                         igSubst MOD ys (h Y) y (h (Op delta inp binp))", "have \"igOp MOD delta (igSubstInp MOD ys (h Y) y (lift h inp))\n                        (igSubstBinp MOD ys (h Y) y (lift hA binp)) =\n            igSubst MOD ys (h Y) y (igOp MOD delta (lift h inp) (lift hA binp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igOp MOD delta (igSubstInp MOD ys (h Y) y (lift h inp))\n     (igSubstBinp MOD ys (h Y) y (lift hA binp)) =\n    igSubst MOD ys (h Y) y (igOp MOD delta (lift h inp) (lift hA binp))", "using hY liftInp **"], ["proof (prove)\nusing this:\n  igWls MOD (asSort ys) (h Y)\n  igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\n  igSubstCls MOD\n\ngoal (1 subgoal):\n 1. igOp MOD delta (igSubstInp MOD ys (h Y) y (lift h inp))\n     (igSubstBinp MOD ys (h Y) y (lift hA binp)) =\n    igSubst MOD ys (h Y) y (igOp MOD delta (lift h inp) (lift hA binp))", "unfolding igSubstCls_def igSubstIGOp_def"], ["proof (prove)\nusing this:\n  igWls MOD (asSort ys) (h Y)\n  igWlsInp MOD delta (lift h inp) \\<and> igWlsBinp MOD delta (lift hA binp)\n  igSubstIGVar1 MOD \\<and>\n  igSubstIGVar2 MOD \\<and>\n  igSubstIGAbs MOD \\<and>\n  (\\<forall>ys y Y delta inp binp.\n      igWls MOD (asSort ys) Y \\<and>\n      igWlsInp MOD delta inp \\<and>\n      igWlsBinp MOD delta binp \\<longrightarrow>\n      igSubst MOD ys Y y (igOp MOD delta inp binp) =\n      igOp MOD delta (igSubstInp MOD ys Y y inp)\n       (igSubstBinp MOD ys Y y binp))\n\ngoal (1 subgoal):\n 1. igOp MOD delta (igSubstInp MOD ys (h Y) y (lift h inp))\n     (igSubstBinp MOD ys (h Y) y (lift hA binp)) =\n    igSubst MOD ys (h Y) y (igOp MOD delta (lift h inp) (lift hA binp))", "by simp"], ["proof (state)\nthis:\n  igOp MOD delta (igSubstInp MOD ys (h Y) y (lift h inp))\n   (igSubstBinp MOD ys (h Y) y (lift hA binp)) =\n  igSubst MOD ys (h Y) y (igOp MOD delta (lift h inp) (lift hA binp))\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[Y / y]_ys) =\n                         igSubst MOD ys (h Y) y (h (Op delta inp binp))", "moreover"], ["proof (state)\nthis:\n  igOp MOD delta (igSubstInp MOD ys (h Y) y (lift h inp))\n   (igSubstBinp MOD ys (h Y) y (lift hA binp)) =\n  igSubst MOD ys (h Y) y (igOp MOD delta (lift h inp) (lift hA binp))\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[Y / y]_ys) =\n                         igSubst MOD ys (h Y) y (h (Op delta inp binp))", "have \"\\<dots> = ?Right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubst MOD ys (h Y) y (igOp MOD delta (lift h inp) (lift hA binp)) =\n    igSubst MOD ys (h Y) y (h (Op delta inp binp))", "using Op *"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>s X.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>(us, s) A.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A))\n   (barOf delta) binp\n  ipresCons h hA MOD\n\ngoal (1 subgoal):\n 1. igSubst MOD ys (h Y) y (igOp MOD delta (lift h inp) (lift hA binp)) =\n    igSubst MOD ys (h Y) y (h (Op delta inp binp))", "unfolding ipresCons_def ipresOp_def"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2\n   (\\<lambda>s X.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))\n   (arOf delta) inp\n  liftAll2\n   (\\<lambda>(us, s) A.\n       \\<forall>ys y Y.\n          y \\<in> varsOfS P ys \\<and>\n          Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n          hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A))\n   (barOf delta) binp\n  ipresVar h MOD \\<and>\n  ipresAbs h hA MOD \\<and>\n  (\\<forall>delta inp binp.\n      wlsInp delta inp \\<and> wlsBinp delta binp \\<longrightarrow>\n      h (Op delta inp binp) = igOp MOD delta (lift h inp) (lift hA binp))\n\ngoal (1 subgoal):\n 1. igSubst MOD ys (h Y) y (igOp MOD delta (lift h inp) (lift hA binp)) =\n    igSubst MOD ys (h Y) y (h (Op delta inp binp))", "by simp"], ["proof (state)\nthis:\n  igSubst MOD ys (h Y) y (igOp MOD delta (lift h inp) (lift hA binp)) =\n  igSubst MOD ys (h Y) y (h (Op delta inp binp))\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> h (Op delta inp binp #[Y / y]_ys) =\n                         igSubst MOD ys (h Y) y (h (Op delta inp binp))", "ultimately"], ["proof (chain)\npicking this:\n  h (Op delta inp binp #[Y / y]_ys) =\n  igOp MOD delta (lift h (inp %[Y / y]_ys)) (lift hA (binp %%[Y / y]_ys))\n  lift h (inp %[Y / y]_ys) = igSubstInp MOD ys (h Y) y (lift h inp) \\<and>\n  lift hA (binp %%[Y / y]_ys) = igSubstBinp MOD ys (h Y) y (lift hA binp)\n  igOp MOD delta (igSubstInp MOD ys (h Y) y (lift h inp))\n   (igSubstBinp MOD ys (h Y) y (lift hA binp)) =\n  igSubst MOD ys (h Y) y (igOp MOD delta (lift h inp) (lift hA binp))\n  igSubst MOD ys (h Y) y (igOp MOD delta (lift h inp) (lift hA binp)) =\n  igSubst MOD ys (h Y) y (h (Op delta inp binp))", "show \"?Left = ?Right\""], ["proof (prove)\nusing this:\n  h (Op delta inp binp #[Y / y]_ys) =\n  igOp MOD delta (lift h (inp %[Y / y]_ys)) (lift hA (binp %%[Y / y]_ys))\n  lift h (inp %[Y / y]_ys) = igSubstInp MOD ys (h Y) y (lift h inp) \\<and>\n  lift hA (binp %%[Y / y]_ys) = igSubstBinp MOD ys (h Y) y (lift hA binp)\n  igOp MOD delta (igSubstInp MOD ys (h Y) y (lift h inp))\n   (igSubstBinp MOD ys (h Y) y (lift hA binp)) =\n  igSubst MOD ys (h Y) y (igOp MOD delta (lift h inp) (lift hA binp))\n  igSubst MOD ys (h Y) y (igOp MOD delta (lift h inp) (lift hA binp)) =\n  igSubst MOD ys (h Y) y (h (Op delta inp binp))\n\ngoal (1 subgoal):\n 1. h (Op delta inp binp #[Y / y]_ys) =\n    igSubst MOD ys (h Y) y (h (Op delta inp binp))", "by simp"], ["proof (state)\nthis:\n  h (Op delta inp binp #[Y / y]_ys) =\n  igSubst MOD ys (h Y) y (h (Op delta inp binp))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>ys y Y.\n     y \\<in> varsOfS P ys \\<and>\n     Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n     h (Op delta inp binp #[Y / y]_ys) =\n     igSubst MOD ys (h Y) y (h (Op delta inp binp))\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; x \\<notin> varsOfS P xs;\n        \\<And>s' Y. Y \\<in> termsOfS P s' \\<Longrightarrow> fresh xs x Y;\n        \\<And>us s' A.\n           A \\<in> absOfS P (us, s') \\<Longrightarrow> freshAbs xs x A;\n        \\<And>rho. rho \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x rho;\n        \\<forall>ys y Y.\n           y \\<in> varsOfS P ys \\<and>\n           Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n           h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            hA (Abs xs x X $[Y / y]_ys) =\n                            igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; x \\<notin> varsOfS P xs;\n        \\<And>s' Y. Y \\<in> termsOfS P s' \\<Longrightarrow> fresh xs x Y;\n        \\<And>us s' A.\n           A \\<in> absOfS P (us, s') \\<Longrightarrow> freshAbs xs x A;\n        \\<And>rho. rho \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x rho;\n        \\<forall>ys y Y.\n           y \\<in> varsOfS P ys \\<and>\n           Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n           h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            hA (Abs xs x X $[Y / y]_ys) =\n                            igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "case (Abs s xs x X)"], ["proof (state)\nthis:\n  isInBar (xs, s)\n  wls s X\n  \\<forall>ys y Y.\n     y \\<in> varsOfS P ys \\<and>\n     Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n     h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\n  x \\<notin> varsOfS P xs\n  ?Y87 \\<in> termsOfS P ?s'87 \\<Longrightarrow> fresh xs x ?Y87\n  ?A87 \\<in> absOfS P (?us87, ?s'87) \\<Longrightarrow> freshAbs xs x ?A87\n  ?rho87 \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x ?rho87\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; x \\<notin> varsOfS P xs;\n        \\<And>s' Y. Y \\<in> termsOfS P s' \\<Longrightarrow> fresh xs x Y;\n        \\<And>us s' A.\n           A \\<in> absOfS P (us, s') \\<Longrightarrow> freshAbs xs x A;\n        \\<And>rho. rho \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x rho;\n        \\<forall>ys y Y.\n           y \\<in> varsOfS P ys \\<and>\n           Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n           h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y Y.\n                            y \\<in> varsOfS P ys \\<and>\n                            Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n                            hA (Abs xs x X $[Y / y]_ys) =\n                            igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y Y.\n       y \\<in> varsOfS P ys \\<and>\n       Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n       hA (Abs xs x X $[Y / y]_ys) =\n       igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "fix ys y Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "assume yP: \"y \\<in> varsOfS P ys\" and YP: \"Y \\<in>  termsOfS P (asSort ys)\""], ["proof (state)\nthis:\n  y \\<in> varsOfS P ys\n  Y \\<in> termsOfS P (asSort ys)\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "hence x_diff: \"ys \\<noteq> xs \\<or> y \\<noteq> x\"\n      and Y: \"wls (asSort ys) Y\" and x_fresh: \"fresh xs x Y\""], ["proof (prove)\nusing this:\n  y \\<in> varsOfS P ys\n  Y \\<in> termsOfS P (asSort ys)\n\ngoal (1 subgoal):\n 1. ys \\<noteq> xs \\<or> y \\<noteq> x &&& wls (asSort ys) Y &&& fresh xs x Y", "using P Abs"], ["proof (prove)\nusing this:\n  y \\<in> varsOfS P ys\n  Y \\<in> termsOfS P (asSort ys)\n  wlsPar P\n  isInBar (xs, s)\n  wls s X\n  \\<forall>ys y Y.\n     y \\<in> varsOfS P ys \\<and>\n     Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n     h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\n  x \\<notin> varsOfS P xs\n  ?Y87 \\<in> termsOfS P ?s'87 \\<Longrightarrow> fresh xs x ?Y87\n  ?A87 \\<in> absOfS P (?us87, ?s'87) \\<Longrightarrow> freshAbs xs x ?A87\n  ?rho87 \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x ?rho87\n\ngoal (1 subgoal):\n 1. ys \\<noteq> xs \\<or> y \\<noteq> x &&& wls (asSort ys) Y &&& fresh xs x Y", "by auto"], ["proof (state)\nthis:\n  ys \\<noteq> xs \\<or> y \\<noteq> x\n  wls (asSort ys) Y\n  fresh xs x Y\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "hence hY: \"igWls MOD (asSort ys) (h Y)\""], ["proof (prove)\nusing this:\n  ys \\<noteq> xs \\<or> y \\<noteq> x\n  wls (asSort ys) Y\n  fresh xs x Y\n\ngoal (1 subgoal):\n 1. igWls MOD (asSort ys) (h Y)", "using ***"], ["proof (prove)\nusing this:\n  ys \\<noteq> xs \\<or> y \\<noteq> x\n  wls (asSort ys) Y\n  fresh xs x Y\n  ipresWlsAll h hA MOD\n\ngoal (1 subgoal):\n 1. igWls MOD (asSort ys) (h Y)", "unfolding ipresWlsAll_def ipresWls_def"], ["proof (prove)\nusing this:\n  ys \\<noteq> xs \\<or> y \\<noteq> x\n  wls (asSort ys) Y\n  fresh xs x Y\n  (\\<forall>s X. wls s X \\<longrightarrow> igWls MOD s (h X)) \\<and>\n  ipresWlsAbs hA MOD\n\ngoal (1 subgoal):\n 1. igWls MOD (asSort ys) (h Y)", "by simp"], ["proof (state)\nthis:\n  igWls MOD (asSort ys) (h Y)\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "have hX: \"igWls MOD s (h X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls MOD s (h X)", "using Abs ***"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  \\<forall>ys y Y.\n     y \\<in> varsOfS P ys \\<and>\n     Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n     h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\n  x \\<notin> varsOfS P xs\n  ?Y87 \\<in> termsOfS P ?s'87 \\<Longrightarrow> fresh xs x ?Y87\n  ?A87 \\<in> absOfS P (?us87, ?s'87) \\<Longrightarrow> freshAbs xs x ?A87\n  ?rho87 \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x ?rho87\n  ipresWlsAll h hA MOD\n\ngoal (1 subgoal):\n 1. igWls MOD s (h X)", "unfolding ipresWlsAll_def ipresWls_def"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  \\<forall>ys y Y.\n     y \\<in> varsOfS P ys \\<and>\n     Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n     h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\n  x \\<notin> varsOfS P xs\n  ?Y87 \\<in> termsOfS P ?s'87 \\<Longrightarrow> fresh xs x ?Y87\n  ?A87 \\<in> absOfS P (?us87, ?s'87) \\<Longrightarrow> freshAbs xs x ?A87\n  ?rho87 \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x ?rho87\n  (\\<forall>s X. wls s X \\<longrightarrow> igWls MOD s (h X)) \\<and>\n  ipresWlsAbs hA MOD\n\ngoal (1 subgoal):\n 1. igWls MOD s (h X)", "by simp"], ["proof (state)\nthis:\n  igWls MOD s (h X)\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "let ?Xsb = \"subst ys Y y X\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "have Xsb: \"wls s ?Xsb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wls s (X #[Y / y]_ys)", "using Y Abs"], ["proof (prove)\nusing this:\n  wls (asSort ys) Y\n  isInBar (xs, s)\n  wls s X\n  \\<forall>ys y Y.\n     y \\<in> varsOfS P ys \\<and>\n     Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n     h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\n  x \\<notin> varsOfS P xs\n  ?Y87 \\<in> termsOfS P ?s'87 \\<Longrightarrow> fresh xs x ?Y87\n  ?A87 \\<in> absOfS P (?us87, ?s'87) \\<Longrightarrow> freshAbs xs x ?A87\n  ?rho87 \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x ?rho87\n\ngoal (1 subgoal):\n 1. wls s (X #[Y / y]_ys)", "by simp"], ["proof (state)\nthis:\n  wls s (X #[Y / y]_ys)\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "have x_igFresh: \"igFresh MOD xs x (h Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFresh MOD xs x (h Y)", "using Y x_fresh *****"], ["proof (prove)\nusing this:\n  wls (asSort ys) Y\n  fresh xs x Y\n  ipresFreshAll h hA MOD\n\ngoal (1 subgoal):\n 1. igFresh MOD xs x (h Y)", "unfolding ipresFreshAll_def ipresFresh_def"], ["proof (prove)\nusing this:\n  wls (asSort ys) Y\n  fresh xs x Y\n  (\\<forall>ys y s X.\n      wls s X \\<longrightarrow>\n      fresh ys y X \\<longrightarrow> igFresh MOD ys y (h X)) \\<and>\n  ipresFreshAbs hA MOD\n\ngoal (1 subgoal):\n 1. igFresh MOD xs x (h Y)", "by simp"], ["proof (state)\nthis:\n  igFresh MOD xs x (h Y)\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "let ?Left = \"hA (Abs xs x X $[Y / y]_ys)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "let ?Right = \"igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "have \"?Left = hA (Abs xs x ?Xsb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hA (Abs xs x X $[Y / y]_ys) = hA (Abs xs x (X #[Y / y]_ys))", "using Y Abs x_diff x_fresh"], ["proof (prove)\nusing this:\n  wls (asSort ys) Y\n  isInBar (xs, s)\n  wls s X\n  \\<forall>ys y Y.\n     y \\<in> varsOfS P ys \\<and>\n     Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n     h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\n  x \\<notin> varsOfS P xs\n  ?Y87 \\<in> termsOfS P ?s'87 \\<Longrightarrow> fresh xs x ?Y87\n  ?A87 \\<in> absOfS P (?us87, ?s'87) \\<Longrightarrow> freshAbs xs x ?A87\n  ?rho87 \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x ?rho87\n  ys \\<noteq> xs \\<or> y \\<noteq> x\n  fresh xs x Y\n\ngoal (1 subgoal):\n 1. hA (Abs xs x X $[Y / y]_ys) = hA (Abs xs x (X #[Y / y]_ys))", "by auto"], ["proof (state)\nthis:\n  hA (Abs xs x X $[Y / y]_ys) = hA (Abs xs x (X #[Y / y]_ys))\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "also"], ["proof (state)\nthis:\n  hA (Abs xs x X $[Y / y]_ys) = hA (Abs xs x (X #[Y / y]_ys))\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "have \"\\<dots> = igAbs MOD xs x (h ?Xsb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hA (Abs xs x (X #[Y / y]_ys)) = igAbs MOD xs x (h (X #[Y / y]_ys))", "using Abs Xsb *"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  \\<forall>ys y Y.\n     y \\<in> varsOfS P ys \\<and>\n     Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n     h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\n  x \\<notin> varsOfS P xs\n  ?Y87 \\<in> termsOfS P ?s'87 \\<Longrightarrow> fresh xs x ?Y87\n  ?A87 \\<in> absOfS P (?us87, ?s'87) \\<Longrightarrow> freshAbs xs x ?A87\n  ?rho87 \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x ?rho87\n  wls s (X #[Y / y]_ys)\n  ipresCons h hA MOD\n\ngoal (1 subgoal):\n 1. hA (Abs xs x (X #[Y / y]_ys)) = igAbs MOD xs x (h (X #[Y / y]_ys))", "unfolding ipresCons_def ipresAbs_def"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  \\<forall>ys y Y.\n     y \\<in> varsOfS P ys \\<and>\n     Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n     h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\n  x \\<notin> varsOfS P xs\n  ?Y87 \\<in> termsOfS P ?s'87 \\<Longrightarrow> fresh xs x ?Y87\n  ?A87 \\<in> absOfS P (?us87, ?s'87) \\<Longrightarrow> freshAbs xs x ?A87\n  ?rho87 \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x ?rho87\n  wls s (X #[Y / y]_ys)\n  ipresVar h MOD \\<and>\n  (\\<forall>xs x s X.\n      isInBar (xs, s) \\<and> wls s X \\<longrightarrow>\n      hA (Abs xs x X) = igAbs MOD xs x (h X)) \\<and>\n  ipresOp h hA MOD\n\ngoal (1 subgoal):\n 1. hA (Abs xs x (X #[Y / y]_ys)) = igAbs MOD xs x (h (X #[Y / y]_ys))", "by fastforce"], ["proof (state)\nthis:\n  hA (Abs xs x (X #[Y / y]_ys)) = igAbs MOD xs x (h (X #[Y / y]_ys))\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "also"], ["proof (state)\nthis:\n  hA (Abs xs x (X #[Y / y]_ys)) = igAbs MOD xs x (h (X #[Y / y]_ys))\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "have \"\\<dots> = igAbs MOD xs x (igSubst MOD ys (h Y) y (h X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs MOD xs x (h (X #[Y / y]_ys)) =\n    igAbs MOD xs x (igSubst MOD ys (h Y) y (h X))", "using yP YP Abs.IH"], ["proof (prove)\nusing this:\n  y \\<in> varsOfS P ys\n  Y \\<in> termsOfS P (asSort ys)\n  isInBar (xs, s)\n  wls s X\n  \\<forall>ys y Y.\n     y \\<in> varsOfS P ys \\<and>\n     Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n     h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\n\ngoal (1 subgoal):\n 1. igAbs MOD xs x (h (X #[Y / y]_ys)) =\n    igAbs MOD xs x (igSubst MOD ys (h Y) y (h X))", "by simp"], ["proof (state)\nthis:\n  igAbs MOD xs x (h (X #[Y / y]_ys)) =\n  igAbs MOD xs x (igSubst MOD ys (h Y) y (h X))\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "also"], ["proof (state)\nthis:\n  igAbs MOD xs x (h (X #[Y / y]_ys)) =\n  igAbs MOD xs x (igSubst MOD ys (h Y) y (h X))\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "have \"\\<dots> = igSubstAbs MOD ys (h Y) y (igAbs MOD xs x (h X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs MOD xs x (igSubst MOD ys (h Y) y (h X)) =\n    igSubstAbs MOD ys (h Y) y (igAbs MOD xs x (h X))", "using Abs hY hX x_diff x_igFresh **"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  \\<forall>ys y Y.\n     y \\<in> varsOfS P ys \\<and>\n     Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n     h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\n  x \\<notin> varsOfS P xs\n  ?Y87 \\<in> termsOfS P ?s'87 \\<Longrightarrow> fresh xs x ?Y87\n  ?A87 \\<in> absOfS P (?us87, ?s'87) \\<Longrightarrow> freshAbs xs x ?A87\n  ?rho87 \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x ?rho87\n  igWls MOD (asSort ys) (h Y)\n  igWls MOD s (h X)\n  ys \\<noteq> xs \\<or> y \\<noteq> x\n  igFresh MOD xs x (h Y)\n  igSubstCls MOD\n\ngoal (1 subgoal):\n 1. igAbs MOD xs x (igSubst MOD ys (h Y) y (h X)) =\n    igSubstAbs MOD ys (h Y) y (igAbs MOD xs x (h X))", "by (auto simp: igSubstCls_def igSubstIGAbs_def)"], ["proof (state)\nthis:\n  igAbs MOD xs x (igSubst MOD ys (h Y) y (h X)) =\n  igSubstAbs MOD ys (h Y) y (igAbs MOD xs x (h X))\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "also"], ["proof (state)\nthis:\n  igAbs MOD xs x (igSubst MOD ys (h Y) y (h X)) =\n  igSubstAbs MOD ys (h Y) y (igAbs MOD xs x (h X))\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "have \"\\<dots> = ?Right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAbs MOD ys (h Y) y (igAbs MOD xs x (h X)) =\n    igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "using Abs *"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  \\<forall>ys y Y.\n     y \\<in> varsOfS P ys \\<and>\n     Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n     h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)\n  x \\<notin> varsOfS P xs\n  ?Y87 \\<in> termsOfS P ?s'87 \\<Longrightarrow> fresh xs x ?Y87\n  ?A87 \\<in> absOfS P (?us87, ?s'87) \\<Longrightarrow> freshAbs xs x ?A87\n  ?rho87 \\<in> envsOfS P \\<Longrightarrow> freshEnv xs x ?rho87\n  ipresCons h hA MOD\n\ngoal (1 subgoal):\n 1. igSubstAbs MOD ys (h Y) y (igAbs MOD xs x (h X)) =\n    igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "by (auto simp: ipresCons_def ipresAbs_def)"], ["proof (state)\nthis:\n  igSubstAbs MOD ys (h Y) y (igAbs MOD xs x (h X)) =\n  igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y.\n       \\<lbrakk>y \\<in> varsOfS P ys;\n        Y \\<in> termsOfS P (asSort ys)\\<rbrakk>\n       \\<Longrightarrow> hA (Abs xs x X $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "finally"], ["proof (chain)\npicking this:\n  hA (Abs xs x X $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "show \"?Left = ?Right\""], ["proof (prove)\nusing this:\n  hA (Abs xs x X $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))\n\ngoal (1 subgoal):\n 1. hA (Abs xs x X $[Y / y]_ys) =\n    igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))", "."], ["proof (state)\nthis:\n  hA (Abs xs x X $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>ys y Y.\n     y \\<in> varsOfS P ys \\<and>\n     Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n     hA (Abs xs x X $[Y / y]_ys) =\n     igSubstAbs MOD ys (h Y) y (hA (Abs xs x X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (wls s X \\<longrightarrow>\n   (\\<forall>ys y Y.\n       y \\<in> varsOfS P ys \\<and>\n       Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n       h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X))) \\<and>\n  (wlsAbs (us, s') A \\<longrightarrow>\n   (\\<forall>ys y Y.\n       y \\<in> varsOfS P ys \\<and>\n       Y \\<in> termsOfS P (asSort ys) \\<longrightarrow>\n       hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipresCons_imp_ipresSubst:\nassumes *: \"ipresCons h hA MOD\" and **: \"igSubstCls MOD\"\nand \"igConsIPresIGWls MOD\" and \"igFreshCls MOD\"\nshows \"ipresSubst h MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresSubst h MOD", "unfolding ipresSubst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys Y y s X.\n       wls (asSort ys) Y \\<and> wls s X \\<longrightarrow>\n       h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys Y y s X.\n       \\<lbrakk>wls (asSort ys) Y; wls s X\\<rbrakk>\n       \\<Longrightarrow> h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)", "subgoal for ys Y y s X"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wls (asSort ys) Y; wls s X\\<rbrakk>\n    \\<Longrightarrow> h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)", "using assms ipresCons_imp_ipresSubstAll_aux\n  [of h hA MOD\n      \"ParS (\\<lambda>zs. if zs = ys then [y] else [])\n            (\\<lambda>s'. if s' = asSort ys then [Y] else [])\n            (\\<lambda>_. [])\n            []\"]"], ["proof (prove)\nusing this:\n  ipresCons h hA MOD\n  igSubstCls MOD\n  igConsIPresIGWls MOD\n  igFreshCls MOD\n  \\<lbrakk>ipresCons h hA MOD; igSubstCls MOD; igConsIPresIGWls MOD;\n   igFreshCls MOD;\n   wlsPar\n    (ParS (\\<lambda>zs. if zs = ys then [y] else [])\n      (\\<lambda>s'. if s' = asSort ys then [Y] else []) (\\<lambda>_. [])\n      [])\\<rbrakk>\n  \\<Longrightarrow> (wls ?s ?X \\<longrightarrow>\n                     (\\<forall>ysa ya Ya.\n                         ya \\<in> varsOfS\n                                   (ParS\n                                     (\\<lambda>zs.\n   if zs = ys then [y] else [])\n                                     (\\<lambda>s'.\n   if s' = asSort ys then [Y] else [])\n                                     (\\<lambda>_. []) [])\n                                   ysa \\<and>\n                         Ya \\<in> termsOfS\n                                   (ParS\n                                     (\\<lambda>zs.\n   if zs = ys then [y] else [])\n                                     (\\<lambda>s'.\n   if s' = asSort ys then [Y] else [])\n                                     (\\<lambda>_. []) [])\n                                   (asSort ysa) \\<longrightarrow>\n                         h (?X #[Ya / ya]_ysa) =\n                         igSubst MOD ysa (h Ya) ya (h ?X))) \\<and>\n                    (wlsAbs (?us, ?s') ?A \\<longrightarrow>\n                     (\\<forall>ysa ya Ya.\n                         ya \\<in> varsOfS\n                                   (ParS\n                                     (\\<lambda>zs.\n   if zs = ys then [y] else [])\n                                     (\\<lambda>s'.\n   if s' = asSort ys then [Y] else [])\n                                     (\\<lambda>_. []) [])\n                                   ysa \\<and>\n                         Ya \\<in> termsOfS\n                                   (ParS\n                                     (\\<lambda>zs.\n   if zs = ys then [y] else [])\n                                     (\\<lambda>s'.\n   if s' = asSort ys then [Y] else [])\n                                     (\\<lambda>_. []) [])\n                                   (asSort ysa) \\<longrightarrow>\n                         hA (?A $[Ya / ya]_ysa) =\n                         igSubstAbs MOD ysa (h Ya) ya (hA ?A)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wls (asSort ys) Y; wls s X\\<rbrakk>\n    \\<Longrightarrow> h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)", "unfolding wlsPar_def"], ["proof (prove)\nusing this:\n  ipresCons h hA MOD\n  igSubstCls MOD\n  igConsIPresIGWls MOD\n  igFreshCls MOD\n  \\<lbrakk>ipresCons h hA MOD; igSubstCls MOD; igConsIPresIGWls MOD;\n   igFreshCls MOD;\n   (\\<forall>s.\n       \\<forall>X\\<in>termsOfS\n                       (ParS (\\<lambda>zs. if zs = ys then [y] else [])\n                         (\\<lambda>s'. if s' = asSort ys then [Y] else [])\n                         (\\<lambda>_. []) [])\n                       s.\n          wls s X) \\<and>\n   (\\<forall>xs s.\n       \\<forall>A\\<in>absOfS\n                       (ParS (\\<lambda>zs. if zs = ys then [y] else [])\n                         (\\<lambda>s'. if s' = asSort ys then [Y] else [])\n                         (\\<lambda>_. []) [])\n                       (xs, s).\n          wlsAbs (xs, s) A) \\<and>\n   Ball\n    (envsOfS\n      (ParS (\\<lambda>zs. if zs = ys then [y] else [])\n        (\\<lambda>s'. if s' = asSort ys then [Y] else []) (\\<lambda>_. [])\n        []))\n    wlsEnv\\<rbrakk>\n  \\<Longrightarrow> (wls ?s ?X \\<longrightarrow>\n                     (\\<forall>ysa ya Ya.\n                         ya \\<in> varsOfS\n                                   (ParS\n                                     (\\<lambda>zs.\n   if zs = ys then [y] else [])\n                                     (\\<lambda>s'.\n   if s' = asSort ys then [Y] else [])\n                                     (\\<lambda>_. []) [])\n                                   ysa \\<and>\n                         Ya \\<in> termsOfS\n                                   (ParS\n                                     (\\<lambda>zs.\n   if zs = ys then [y] else [])\n                                     (\\<lambda>s'.\n   if s' = asSort ys then [Y] else [])\n                                     (\\<lambda>_. []) [])\n                                   (asSort ysa) \\<longrightarrow>\n                         h (?X #[Ya / ya]_ysa) =\n                         igSubst MOD ysa (h Ya) ya (h ?X))) \\<and>\n                    (wlsAbs (?us, ?s') ?A \\<longrightarrow>\n                     (\\<forall>ysa ya Ya.\n                         ya \\<in> varsOfS\n                                   (ParS\n                                     (\\<lambda>zs.\n   if zs = ys then [y] else [])\n                                     (\\<lambda>s'.\n   if s' = asSort ys then [Y] else [])\n                                     (\\<lambda>_. []) [])\n                                   ysa \\<and>\n                         Ya \\<in> termsOfS\n                                   (ParS\n                                     (\\<lambda>zs.\n   if zs = ys then [y] else [])\n                                     (\\<lambda>s'.\n   if s' = asSort ys then [Y] else [])\n                                     (\\<lambda>_. []) [])\n                                   (asSort ysa) \\<longrightarrow>\n                         hA (?A $[Ya / ya]_ysa) =\n                         igSubstAbs MOD ysa (h Ya) ya (hA ?A)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wls (asSort ys) Y; wls s X\\<rbrakk>\n    \\<Longrightarrow> h (X #[Y / y]_ys) = igSubst MOD ys (h Y) y (h X)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma ipresCons_imp_ipresSubstAbs:\nassumes *: \"ipresCons h hA MOD\" and **: \"igSubstCls MOD\"\nand \"igConsIPresIGWls MOD\" and \"igFreshCls MOD\"\nshows \"ipresSubstAbs h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresSubstAbs h hA MOD", "unfolding ipresSubstAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys Y y us s A.\n       wls (asSort ys) Y \\<and> wlsAbs (us, s) A \\<longrightarrow>\n       hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys Y y us s A.\n       \\<lbrakk>wls (asSort ys) Y; wlsAbs (us, s) A\\<rbrakk>\n       \\<Longrightarrow> hA (A $[Y / y]_ys) =\n                         igSubstAbs MOD ys (h Y) y (hA A)", "subgoal for ys Y y us s A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wls (asSort ys) Y; wlsAbs (us, s) A\\<rbrakk>\n    \\<Longrightarrow> hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A)", "using assms ipresCons_imp_ipresSubstAll_aux\n  [of h hA MOD\n      \"ParS (\\<lambda>zs. if zs = ys then [y] else [])\n            (\\<lambda>s'. if s' = asSort ys then [Y] else [])\n            (\\<lambda>_. [])\n            []\"]"], ["proof (prove)\nusing this:\n  ipresCons h hA MOD\n  igSubstCls MOD\n  igConsIPresIGWls MOD\n  igFreshCls MOD\n  \\<lbrakk>ipresCons h hA MOD; igSubstCls MOD; igConsIPresIGWls MOD;\n   igFreshCls MOD;\n   wlsPar\n    (ParS (\\<lambda>zs. if zs = ys then [y] else [])\n      (\\<lambda>s'. if s' = asSort ys then [Y] else []) (\\<lambda>_. [])\n      [])\\<rbrakk>\n  \\<Longrightarrow> (wls ?s ?X \\<longrightarrow>\n                     (\\<forall>ysa ya Ya.\n                         ya \\<in> varsOfS\n                                   (ParS\n                                     (\\<lambda>zs.\n   if zs = ys then [y] else [])\n                                     (\\<lambda>s'.\n   if s' = asSort ys then [Y] else [])\n                                     (\\<lambda>_. []) [])\n                                   ysa \\<and>\n                         Ya \\<in> termsOfS\n                                   (ParS\n                                     (\\<lambda>zs.\n   if zs = ys then [y] else [])\n                                     (\\<lambda>s'.\n   if s' = asSort ys then [Y] else [])\n                                     (\\<lambda>_. []) [])\n                                   (asSort ysa) \\<longrightarrow>\n                         h (?X #[Ya / ya]_ysa) =\n                         igSubst MOD ysa (h Ya) ya (h ?X))) \\<and>\n                    (wlsAbs (?us, ?s') ?A \\<longrightarrow>\n                     (\\<forall>ysa ya Ya.\n                         ya \\<in> varsOfS\n                                   (ParS\n                                     (\\<lambda>zs.\n   if zs = ys then [y] else [])\n                                     (\\<lambda>s'.\n   if s' = asSort ys then [Y] else [])\n                                     (\\<lambda>_. []) [])\n                                   ysa \\<and>\n                         Ya \\<in> termsOfS\n                                   (ParS\n                                     (\\<lambda>zs.\n   if zs = ys then [y] else [])\n                                     (\\<lambda>s'.\n   if s' = asSort ys then [Y] else [])\n                                     (\\<lambda>_. []) [])\n                                   (asSort ysa) \\<longrightarrow>\n                         hA (?A $[Ya / ya]_ysa) =\n                         igSubstAbs MOD ysa (h Ya) ya (hA ?A)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wls (asSort ys) Y; wlsAbs (us, s) A\\<rbrakk>\n    \\<Longrightarrow> hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A)", "unfolding wlsPar_def"], ["proof (prove)\nusing this:\n  ipresCons h hA MOD\n  igSubstCls MOD\n  igConsIPresIGWls MOD\n  igFreshCls MOD\n  \\<lbrakk>ipresCons h hA MOD; igSubstCls MOD; igConsIPresIGWls MOD;\n   igFreshCls MOD;\n   (\\<forall>s.\n       \\<forall>X\\<in>termsOfS\n                       (ParS (\\<lambda>zs. if zs = ys then [y] else [])\n                         (\\<lambda>s'. if s' = asSort ys then [Y] else [])\n                         (\\<lambda>_. []) [])\n                       s.\n          wls s X) \\<and>\n   (\\<forall>xs s.\n       \\<forall>A\\<in>absOfS\n                       (ParS (\\<lambda>zs. if zs = ys then [y] else [])\n                         (\\<lambda>s'. if s' = asSort ys then [Y] else [])\n                         (\\<lambda>_. []) [])\n                       (xs, s).\n          wlsAbs (xs, s) A) \\<and>\n   Ball\n    (envsOfS\n      (ParS (\\<lambda>zs. if zs = ys then [y] else [])\n        (\\<lambda>s'. if s' = asSort ys then [Y] else []) (\\<lambda>_. [])\n        []))\n    wlsEnv\\<rbrakk>\n  \\<Longrightarrow> (wls ?s ?X \\<longrightarrow>\n                     (\\<forall>ysa ya Ya.\n                         ya \\<in> varsOfS\n                                   (ParS\n                                     (\\<lambda>zs.\n   if zs = ys then [y] else [])\n                                     (\\<lambda>s'.\n   if s' = asSort ys then [Y] else [])\n                                     (\\<lambda>_. []) [])\n                                   ysa \\<and>\n                         Ya \\<in> termsOfS\n                                   (ParS\n                                     (\\<lambda>zs.\n   if zs = ys then [y] else [])\n                                     (\\<lambda>s'.\n   if s' = asSort ys then [Y] else [])\n                                     (\\<lambda>_. []) [])\n                                   (asSort ysa) \\<longrightarrow>\n                         h (?X #[Ya / ya]_ysa) =\n                         igSubst MOD ysa (h Ya) ya (h ?X))) \\<and>\n                    (wlsAbs (?us, ?s') ?A \\<longrightarrow>\n                     (\\<forall>ysa ya Ya.\n                         ya \\<in> varsOfS\n                                   (ParS\n                                     (\\<lambda>zs.\n   if zs = ys then [y] else [])\n                                     (\\<lambda>s'.\n   if s' = asSort ys then [Y] else [])\n                                     (\\<lambda>_. []) [])\n                                   ysa \\<and>\n                         Ya \\<in> termsOfS\n                                   (ParS\n                                     (\\<lambda>zs.\n   if zs = ys then [y] else [])\n                                     (\\<lambda>s'.\n   if s' = asSort ys then [Y] else [])\n                                     (\\<lambda>_. []) [])\n                                   (asSort ysa) \\<longrightarrow>\n                         hA (?A $[Ya / ya]_ysa) =\n                         igSubstAbs MOD ysa (h Ya) ya (hA ?A)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wls (asSort ys) Y; wlsAbs (us, s) A\\<rbrakk>\n    \\<Longrightarrow> hA (A $[Y / y]_ys) = igSubstAbs MOD ys (h Y) y (hA A)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma ipresCons_imp_ipresSubstAll:\nassumes *: \"ipresCons h hA MOD\" and **: \"igSubstCls MOD\"\nand \"igConsIPresIGWls MOD\" and \"igFreshCls MOD\"\nshows \"ipresSubstAll h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresSubstAll h hA MOD", "unfolding ipresSubstAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresSubst h MOD \\<and> ipresSubstAbs h hA MOD", "using assms\nipresCons_imp_ipresSubst ipresCons_imp_ipresSubstAbs"], ["proof (prove)\nusing this:\n  ipresCons h hA MOD\n  igSubstCls MOD\n  igConsIPresIGWls MOD\n  igFreshCls MOD\n  \\<lbrakk>ipresCons ?h ?hA ?MOD; igSubstCls ?MOD; igConsIPresIGWls ?MOD;\n   igFreshCls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresSubst ?h ?MOD\n  \\<lbrakk>ipresCons ?h ?hA ?MOD; igSubstCls ?MOD; igConsIPresIGWls ?MOD;\n   igFreshCls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresSubstAbs ?h ?hA ?MOD\n\ngoal (1 subgoal):\n 1. ipresSubst h MOD \\<and> ipresSubstAbs h hA MOD", "by auto"], ["", "lemma iwlsFSw_termFSwImorph_iff:\n\"iwlsFSw MOD \\<Longrightarrow> termFSwImorph h hA MOD = ipresCons h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSw MOD \\<Longrightarrow>\n    termFSwImorph h hA MOD = ipresCons h hA MOD", "unfolding iwlsFSw_def termFSwImorph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAllDisj MOD \\<and>\n    igWlsAbsIsInBar MOD \\<and>\n    igConsIPresIGWls MOD \\<and>\n    igSwapAllIPresIGWlsAll MOD \\<and>\n    igFreshCls MOD \\<and>\n    igSwapCls MOD \\<and> igAbsCongS MOD \\<Longrightarrow>\n    (ipresWlsAll h hA MOD \\<and>\n     ipresCons h hA MOD \\<and>\n     ipresFreshAll h hA MOD \\<and> ipresSwapAll h hA MOD) =\n    ipresCons h hA MOD", "using ipresCons_imp_ipresWlsAll\nipresCons_imp_ipresFreshAll ipresCons_imp_ipresSwapAll"], ["proof (prove)\nusing this:\n  \\<lbrakk>ipresCons ?h ?hA ?MOD; igConsIPresIGWls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresWlsAll ?h ?hA ?MOD\n  \\<lbrakk>ipresCons ?h ?hA ?MOD; igFreshCls ?MOD;\n   igConsIPresIGWls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresFreshAll ?h ?hA ?MOD\n  \\<lbrakk>ipresCons ?h ?hA ?MOD; igSwapCls ?MOD;\n   igConsIPresIGWls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresSwapAll ?h ?hA ?MOD\n\ngoal (1 subgoal):\n 1. igWlsAllDisj MOD \\<and>\n    igWlsAbsIsInBar MOD \\<and>\n    igConsIPresIGWls MOD \\<and>\n    igSwapAllIPresIGWlsAll MOD \\<and>\n    igFreshCls MOD \\<and>\n    igSwapCls MOD \\<and> igAbsCongS MOD \\<Longrightarrow>\n    (ipresWlsAll h hA MOD \\<and>\n     ipresCons h hA MOD \\<and>\n     ipresFreshAll h hA MOD \\<and> ipresSwapAll h hA MOD) =\n    ipresCons h hA MOD", "by auto"], ["", "corollary iwlsFSwSTR_termFSwImorph_iff:\n\"iwlsFSwSTR MOD \\<Longrightarrow> termFSwImorph h hA MOD = ipresCons h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSwSTR MOD \\<Longrightarrow>\n    termFSwImorph h hA MOD = ipresCons h hA MOD", "using iwlsFSwSTR_imp_iwlsFSw iwlsFSw_termFSwImorph_iff"], ["proof (prove)\nusing this:\n  iwlsFSwSTR ?MOD \\<Longrightarrow> iwlsFSw ?MOD\n  iwlsFSw ?MOD \\<Longrightarrow>\n  termFSwImorph ?h ?hA ?MOD = ipresCons ?h ?hA ?MOD\n\ngoal (1 subgoal):\n 1. iwlsFSwSTR MOD \\<Longrightarrow>\n    termFSwImorph h hA MOD = ipresCons h hA MOD", "by fastforce"], ["", "lemma iwlsFSb_termFSbImorph_iff:\n\"iwlsFSb MOD \\<Longrightarrow> termFSbImorph h hA MOD = ipresCons h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSb MOD \\<Longrightarrow>\n    termFSbImorph h hA MOD = ipresCons h hA MOD", "unfolding iwlsFSb_def termFSbImorph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAllDisj MOD \\<and>\n    igWlsAbsIsInBar MOD \\<and>\n    igConsIPresIGWls MOD \\<and>\n    igSubstAllIPresIGWlsAll MOD \\<and>\n    igFreshCls MOD \\<and>\n    igSubstCls MOD \\<and> igAbsRen MOD \\<Longrightarrow>\n    (ipresWlsAll h hA MOD \\<and>\n     ipresCons h hA MOD \\<and>\n     ipresFreshAll h hA MOD \\<and> ipresSubstAll h hA MOD) =\n    ipresCons h hA MOD", "using ipresCons_imp_ipresWlsAll\nipresCons_imp_ipresFreshAll ipresCons_imp_ipresSubstAll"], ["proof (prove)\nusing this:\n  \\<lbrakk>ipresCons ?h ?hA ?MOD; igConsIPresIGWls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresWlsAll ?h ?hA ?MOD\n  \\<lbrakk>ipresCons ?h ?hA ?MOD; igFreshCls ?MOD;\n   igConsIPresIGWls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresFreshAll ?h ?hA ?MOD\n  \\<lbrakk>ipresCons ?h ?hA ?MOD; igSubstCls ?MOD; igConsIPresIGWls ?MOD;\n   igFreshCls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresSubstAll ?h ?hA ?MOD\n\ngoal (1 subgoal):\n 1. igWlsAllDisj MOD \\<and>\n    igWlsAbsIsInBar MOD \\<and>\n    igConsIPresIGWls MOD \\<and>\n    igSubstAllIPresIGWlsAll MOD \\<and>\n    igFreshCls MOD \\<and>\n    igSubstCls MOD \\<and> igAbsRen MOD \\<Longrightarrow>\n    (ipresWlsAll h hA MOD \\<and>\n     ipresCons h hA MOD \\<and>\n     ipresFreshAll h hA MOD \\<and> ipresSubstAll h hA MOD) =\n    ipresCons h hA MOD", "unfolding igSubstCls_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>ipresCons ?h ?hA ?MOD; igConsIPresIGWls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresWlsAll ?h ?hA ?MOD\n  \\<lbrakk>ipresCons ?h ?hA ?MOD; igFreshCls ?MOD;\n   igConsIPresIGWls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresFreshAll ?h ?hA ?MOD\n  \\<lbrakk>ipresCons ?h ?hA ?MOD;\n   igSubstIGVar1 ?MOD \\<and>\n   igSubstIGVar2 ?MOD \\<and> igSubstIGAbs ?MOD \\<and> igSubstIGOp ?MOD;\n   igConsIPresIGWls ?MOD; igFreshCls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresSubstAll ?h ?hA ?MOD\n\ngoal (1 subgoal):\n 1. igWlsAllDisj MOD \\<and>\n    igWlsAbsIsInBar MOD \\<and>\n    igConsIPresIGWls MOD \\<and>\n    igSubstAllIPresIGWlsAll MOD \\<and>\n    igFreshCls MOD \\<and>\n    (igSubstIGVar1 MOD \\<and>\n     igSubstIGVar2 MOD \\<and>\n     igSubstIGAbs MOD \\<and> igSubstIGOp MOD) \\<and>\n    igAbsRen MOD \\<Longrightarrow>\n    (ipresWlsAll h hA MOD \\<and>\n     ipresCons h hA MOD \\<and>\n     ipresFreshAll h hA MOD \\<and> ipresSubstAll h hA MOD) =\n    ipresCons h hA MOD", "by fastforce+"], ["", "corollary iwlsFSbSwTR_termFSbImorph_iff:\n\"iwlsFSbSwTR MOD \\<Longrightarrow> termFSbImorph h hA MOD = ipresCons h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSbSwTR MOD \\<Longrightarrow>\n    termFSbImorph h hA MOD = ipresCons h hA MOD", "using iwlsFSbSwTR_imp_iwlsFSb iwlsFSb_termFSbImorph_iff"], ["proof (prove)\nusing this:\n  iwlsFSbSwTR ?MOD \\<Longrightarrow> iwlsFSb ?MOD\n  iwlsFSb ?MOD \\<Longrightarrow>\n  termFSbImorph ?h ?hA ?MOD = ipresCons ?h ?hA ?MOD\n\ngoal (1 subgoal):\n 1. iwlsFSbSwTR MOD \\<Longrightarrow>\n    termFSbImorph h hA MOD = ipresCons h hA MOD", "by fastforce"], ["", "lemma iwlsFSwSb_termFSwSbImorph_iff:\n\"iwlsFSwSb MOD \\<Longrightarrow> termFSwSbImorph h hA MOD = ipresCons h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSwSb MOD \\<Longrightarrow>\n    termFSwSbImorph h hA MOD = ipresCons h hA MOD", "unfolding termFSwSbImorph_def iwlsFSwSb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSw MOD \\<and>\n    igSubstAllIPresIGWlsAll MOD \\<and> igSubstCls MOD \\<Longrightarrow>\n    (termFSwImorph h hA MOD \\<and> ipresSubstAll h hA MOD) =\n    ipresCons h hA MOD", "apply(simp add: iwlsFSw_termFSwImorph_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSw MOD \\<and>\n    igSubstAllIPresIGWlsAll MOD \\<and> igSubstCls MOD \\<Longrightarrow>\n    (ipresCons h hA MOD \\<and> ipresSubstAll h hA MOD) = ipresCons h hA MOD", "unfolding iwlsFSw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (igWlsAllDisj MOD \\<and>\n     igWlsAbsIsInBar MOD \\<and>\n     igConsIPresIGWls MOD \\<and>\n     igSwapAllIPresIGWlsAll MOD \\<and>\n     igFreshCls MOD \\<and> igSwapCls MOD \\<and> igAbsCongS MOD) \\<and>\n    igSubstAllIPresIGWlsAll MOD \\<and> igSubstCls MOD \\<Longrightarrow>\n    (ipresCons h hA MOD \\<and> ipresSubstAll h hA MOD) = ipresCons h hA MOD", "using ipresCons_imp_ipresSubstAll"], ["proof (prove)\nusing this:\n  \\<lbrakk>ipresCons ?h ?hA ?MOD; igSubstCls ?MOD; igConsIPresIGWls ?MOD;\n   igFreshCls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresSubstAll ?h ?hA ?MOD\n\ngoal (1 subgoal):\n 1. (igWlsAllDisj MOD \\<and>\n     igWlsAbsIsInBar MOD \\<and>\n     igConsIPresIGWls MOD \\<and>\n     igSwapAllIPresIGWlsAll MOD \\<and>\n     igFreshCls MOD \\<and> igSwapCls MOD \\<and> igAbsCongS MOD) \\<and>\n    igSubstAllIPresIGWlsAll MOD \\<and> igSubstCls MOD \\<Longrightarrow>\n    (ipresCons h hA MOD \\<and> ipresSubstAll h hA MOD) = ipresCons h hA MOD", "by auto"], ["", "lemma iwlsFSbSw_termFSwSbImorph_iff:\n\"iwlsFSbSw MOD \\<Longrightarrow> termFSwSbImorph h hA MOD = ipresCons h hA MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSbSw MOD \\<Longrightarrow>\n    termFSwSbImorph h hA MOD = ipresCons h hA MOD", "unfolding termFSwSbImorph_iff iwlsFSbSw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSb MOD \\<and>\n    igSwapAllIPresIGWlsAll MOD \\<and> igSwapCls MOD \\<Longrightarrow>\n    (termFSbImorph h hA MOD \\<and> ipresSwapAll h hA MOD) =\n    ipresCons h hA MOD", "apply(simp add: iwlsFSb_termFSbImorph_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSb MOD \\<and>\n    igSwapAllIPresIGWlsAll MOD \\<and> igSwapCls MOD \\<Longrightarrow>\n    (ipresCons h hA MOD \\<and> ipresSwapAll h hA MOD) = ipresCons h hA MOD", "unfolding iwlsFSb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (igWlsAllDisj MOD \\<and>\n     igWlsAbsIsInBar MOD \\<and>\n     igConsIPresIGWls MOD \\<and>\n     igSubstAllIPresIGWlsAll MOD \\<and>\n     igFreshCls MOD \\<and> igSubstCls MOD \\<and> igAbsRen MOD) \\<and>\n    igSwapAllIPresIGWlsAll MOD \\<and> igSwapCls MOD \\<Longrightarrow>\n    (ipresCons h hA MOD \\<and> ipresSwapAll h hA MOD) = ipresCons h hA MOD", "using ipresCons_imp_ipresSwapAll"], ["proof (prove)\nusing this:\n  \\<lbrakk>ipresCons ?h ?hA ?MOD; igSwapCls ?MOD;\n   igConsIPresIGWls ?MOD\\<rbrakk>\n  \\<Longrightarrow> ipresSwapAll ?h ?hA ?MOD\n\ngoal (1 subgoal):\n 1. (igWlsAllDisj MOD \\<and>\n     igWlsAbsIsInBar MOD \\<and>\n     igConsIPresIGWls MOD \\<and>\n     igSubstAllIPresIGWlsAll MOD \\<and>\n     igFreshCls MOD \\<and> igSubstCls MOD \\<and> igAbsRen MOD) \\<and>\n    igSwapAllIPresIGWlsAll MOD \\<and> igSwapCls MOD \\<Longrightarrow>\n    (ipresCons h hA MOD \\<and> ipresSwapAll h hA MOD) = ipresCons h hA MOD", "by auto"], ["", "end"], ["", "(* context FixSyn *)"], ["", "subsection\\<open>The ``error\" model of associated to a model\\<close>"], ["", "text\\<open>The error model will have the operators act like the original ones\non well-formed terms, except that will return ``ERR\" (error) or ``True\" (in the case of fresh)\nwhenever one of the inputs (variables, terms or abstractions) is ``ERR\" or\nis not well-formed.\n\nThe error model is more convenient than the original one, since\none can define more easily a map from the model of terms to the former. This map shall be defined\nby the universal property of quotients, via a map from quasi-terms whose kernel\nincludes the alpha-equivalence relation. The latter property (of including\nthe alpha-equivalence would not be achievable with the original model as tariget, since\nalpha is defined unsortedly and the model clauses hold sortedly.\n\nWe shall only need error models associated to fresh-swap and to fresh-subst models.\\<close>"], ["", "subsubsection \\<open>Preliminaries\\<close>"], ["", "(* I prefer defining a new type to using the option type, since\nI already use options for inputs: *)"], ["", "datatype 'a withERR = ERR | OK 'a"], ["", "(* *************************************************** *)"], ["", "context FixSyn   (* scope all throuighout the file *)\nbegin"], ["", "definition OKI where\n\"OKI inp = lift OK inp\""], ["", "definition check where\n\"check eX == THE X. eX = OK X\""], ["", "definition checkI where\n\"checkI einp == lift check einp\""], ["", "lemma check_ex_unique:\n\"eX \\<noteq> ERR \\<Longrightarrow> (EX! X. eX = OK X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eX \\<noteq> ERR \\<Longrightarrow> \\<exists>!X. eX = OK X", "by(cases eX, auto)"], ["", "lemma check_OK[simp]:\n\"check (OK X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check (OK X) = X", "unfolding check_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE Xa. OK X = OK Xa) = X", "using check_ex_unique theI'"], ["proof (prove)\nusing this:\n  ?eX \\<noteq> ERR \\<Longrightarrow> \\<exists>!X. ?eX = OK X\n  \\<exists>!x. ?P x \\<Longrightarrow> ?P (THE x. ?P x)\n\ngoal (1 subgoal):\n 1. (THE Xa. OK X = OK Xa) = X", "by auto"], ["", "lemma OK_check[simp]:\n\"eX \\<noteq> ERR \\<Longrightarrow> OK (check eX) = eX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eX \\<noteq> ERR \\<Longrightarrow> OK (check eX) = eX", "unfolding check_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eX \\<noteq> ERR \\<Longrightarrow> OK (THE X. eX = OK X) = eX", "using check_ex_unique theI'"], ["proof (prove)\nusing this:\n  ?eX \\<noteq> ERR \\<Longrightarrow> \\<exists>!X. ?eX = OK X\n  \\<exists>!x. ?P x \\<Longrightarrow> ?P (THE x. ?P x)\n\ngoal (1 subgoal):\n 1. eX \\<noteq> ERR \\<Longrightarrow> OK (THE X. eX = OK X) = eX", "by auto"], ["", "lemma checkI_OKI[simp]:\n\"checkI (OKI inp) = inp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checkI (OKI inp) = inp", "unfolding OKI_def checkI_def lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        case case inp i of None \\<Rightarrow> None\n             | Some v \\<Rightarrow> Some (OK v) of\n        None \\<Rightarrow> None | Some v \\<Rightarrow> Some (check v)) =\n    inp", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (case case inp i of None \\<Rightarrow> None\n             | Some v \\<Rightarrow> Some (OK v) of\n        None \\<Rightarrow> None | Some v \\<Rightarrow> Some (check v)) =\n       inp i", "by(case_tac \"inp i\", auto)"], ["", "lemma OKI_checkI[simp]:\nassumes \"liftAll (\\<lambda> X. X \\<noteq> ERR) einp\"\nshows \"OKI (checkI einp) = einp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OKI (checkI einp) = einp", "unfolding OKI_def checkI_def lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        case case einp i of None \\<Rightarrow> None\n             | Some v \\<Rightarrow> Some (check v) of\n        None \\<Rightarrow> None | Some v \\<Rightarrow> Some (OK v)) =\n    einp", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (case case einp i of None \\<Rightarrow> None\n             | Some v \\<Rightarrow> Some (check v) of\n        None \\<Rightarrow> None | Some v \\<Rightarrow> Some (OK v)) =\n       einp i", "using assms"], ["proof (prove)\nusing this:\n  liftAll (\\<lambda>X. X \\<noteq> ERR) einp\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (case case einp i of None \\<Rightarrow> None\n             | Some v \\<Rightarrow> Some (check v) of\n        None \\<Rightarrow> None | Some v \\<Rightarrow> Some (OK v)) =\n       einp i", "unfolding liftAll_def"], ["proof (prove)\nusing this:\n  \\<forall>i v. einp i = Some v \\<longrightarrow> v \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (case case einp i of None \\<Rightarrow> None\n             | Some v \\<Rightarrow> Some (check v) of\n        None \\<Rightarrow> None | Some v \\<Rightarrow> Some (OK v)) =\n       einp i", "by (case_tac \"einp i\", auto)"], ["", "lemma OKI_inj[simp]:\nfixes inp inp' :: \"('index,'gTerm)input\"\nshows \"(OKI inp = OKI inp') = (inp = inp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (OKI inp = OKI inp') = (inp = inp')", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. OKI inp = OKI inp' \\<Longrightarrow> inp = inp'", "unfolding OKI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift OK inp = lift OK inp' \\<Longrightarrow> inp = inp'", "using lift_preserves_inj[of OK]"], ["proof (prove)\nusing this:\n  inj OK \\<Longrightarrow> inj (lift OK)\n\ngoal (1 subgoal):\n 1. lift OK inp = lift OK inp' \\<Longrightarrow> inp = inp'", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV.\n        OK x = OK y \\<longrightarrow> x = y \\<Longrightarrow>\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV. lift OK x = lift OK y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. lift OK inp = lift OK inp' \\<Longrightarrow> inp = inp'", "by auto"], ["", "lemmas OK_OKI_simps =\ncheck_OK OK_check checkI_OKI OKI_checkI OKI_inj"], ["", "subsubsection \\<open>Definitions and notations\\<close>"], ["", "definition errMOD ::\n\"('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs)model \\<Rightarrow>\n ('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm withERR,'gAbs withERR)model\"\nwhere\n\"errMOD MOD ==\n \\<lparr>igWls = \\<lambda> s eX. case eX of ERR \\<Rightarrow> False | OK X \\<Rightarrow> igWls MOD s X,\n  igWlsAbs = \\<lambda> (us,s) eA. case eA of ERR \\<Rightarrow> False | OK A \\<Rightarrow> igWlsAbs MOD (us,s) A,\n\n  igVar = \\<lambda> xs x. OK (igVar MOD xs x),\n  igAbs = \\<lambda>xs x eX.\n           if (eX \\<noteq> ERR \\<and> (\\<exists> s. isInBar (xs,s) \\<and> igWls MOD s (check eX)))\n             then OK (igAbs MOD xs x (check eX))\n             else ERR,\n  igOp = \\<lambda>delta einp ebinp.\n          if liftAll (\\<lambda> X. X \\<noteq> ERR) einp \\<and> liftAll (\\<lambda> A. A \\<noteq> ERR) ebinp\n             \\<and> igWlsInp MOD delta (checkI einp) \\<and> igWlsBinp MOD delta (checkI ebinp)\n            then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n            else ERR,\n  igFresh = \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists> s. igWls MOD s (check eX))\n               then igFresh MOD ys y (check eX)\n               else True,\n  igFreshAbs = \\<lambda>ys y eA.\n                if eA \\<noteq> ERR \\<and> (\\<exists> us s. igWlsAbs MOD (us,s) (check eA))\n                  then igFreshAbs MOD ys y (check eA)\n                  else True,\n  igSwap = \\<lambda>zs z1 z2 eX.\n            if eX \\<noteq> ERR \\<and> (\\<exists> s. igWls MOD s (check eX))\n              then OK (igSwap MOD zs z1 z2 (check eX))\n              else ERR,\n  igSwapAbs = \\<lambda>zs z1 z2 eA.\n               if eA \\<noteq> ERR \\<and> (\\<exists> us s. igWlsAbs MOD (us,s) (check eA))\n                 then OK (igSwapAbs MOD zs z1 z2 (check eA))\n                 else ERR,\n  igSubst = \\<lambda>ys eY y eX.\n              if eY \\<noteq> ERR \\<and> igWls MOD (asSort ys) (check eY)\n                 \\<and> eX \\<noteq> ERR \\<and> (\\<exists> s. igWls MOD s (check eX))\n                then OK (igSubst MOD ys (check eY) y (check eX))\n                else ERR,\n  igSubstAbs = \\<lambda>ys eY y eA.\n                 if eY \\<noteq> ERR \\<and> igWls MOD (asSort ys) (check eY)\n                    \\<and> eA \\<noteq> ERR \\<and> (\\<exists> us s. igWlsAbs MOD (us,s) (check eA))\n                   then OK (igSubstAbs MOD ys (check eY) y (check eA))\n                   else ERR\n \\<rparr>\""], ["", "abbreviation eWls where \"eWls MOD == igWls (errMOD MOD)\""], ["", "abbreviation eWlsAbs where \"eWlsAbs MOD == igWlsAbs (errMOD MOD)\""], ["", "abbreviation eWlsInp where \"eWlsInp MOD == igWlsInp (errMOD MOD)\""], ["", "abbreviation eWlsBinp where \"eWlsBinp MOD == igWlsBinp (errMOD MOD)\""], ["", "abbreviation eVar where \"eVar MOD == igVar (errMOD MOD)\""], ["", "abbreviation eAbs where \"eAbs MOD == igAbs (errMOD MOD)\""], ["", "abbreviation eOp where \"eOp MOD == igOp (errMOD MOD)\""], ["", "abbreviation eFresh where \"eFresh MOD == igFresh (errMOD MOD)\""], ["", "abbreviation eFreshAbs where \"eFreshAbs MOD == igFreshAbs (errMOD MOD)\""], ["", "abbreviation eFreshInp where \"eFreshInp MOD == igFreshInp (errMOD MOD)\""], ["", "abbreviation eFreshBinp where \"eFreshBinp MOD == igFreshBinp (errMOD MOD)\""], ["", "abbreviation eSwap where \"eSwap MOD == igSwap (errMOD MOD)\""], ["", "abbreviation eSwapAbs where \"eSwapAbs MOD == igSwapAbs (errMOD MOD)\""], ["", "abbreviation eSwapInp where \"eSwapInp MOD == igSwapInp (errMOD MOD)\""], ["", "abbreviation eSwapBinp where \"eSwapBinp MOD == igSwapBinp (errMOD MOD)\""], ["", "abbreviation eSubst where \"eSubst MOD == igSubst (errMOD MOD)\""], ["", "abbreviation eSubstAbs where \"eSubstAbs MOD == igSubstAbs (errMOD MOD)\""], ["", "abbreviation eSubstInp where \"eSubstInp MOD == igSubstInp (errMOD MOD)\""], ["", "abbreviation eSubstBinp where \"eSubstBinp MOD == igSubstBinp (errMOD MOD)\""], ["", "subsubsection \\<open>Simplification rules\\<close>"], ["", "lemma eWls_simp1[simp]:\n\"eWls MOD s (OK X) = igWls MOD s X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eWls MOD s (OK X) = igWls MOD s X", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     s (OK X) =\n    igWls MOD s X", "by simp"], ["", "lemma eWls_simp2[simp]:\n\"eWls MOD s ERR = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eWls MOD s ERR = False", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     s ERR =\n    False", "by simp"], ["", "lemma eWlsAbs_simp1[simp]:\n\"eWlsAbs MOD (us,s) (OK A) = igWlsAbs MOD (us,s) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eWlsAbs MOD (us, s) (OK A) = igWlsAbs MOD (us, s) A", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     (us, s) (OK A) =\n    igWlsAbs MOD (us, s) A", "by simp"], ["", "lemma eWlsAbs_simp2[simp]:\n\"eWlsAbs MOD (us,s) ERR = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eWlsAbs MOD (us, s) ERR = False", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     (us, s) ERR =\n    False", "by simp"], ["", "lemma eWlsInp_simp1[simp]:\n\"eWlsInp MOD delta (OKI inp) = igWlsInp MOD delta inp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eWlsInp MOD delta (OKI inp) = igWlsInp MOD delta inp", "by (fastforce simp: OKI_def sameDom_def liftAll2_def lift_def igWlsInp_def \n  split: option.splits)"], ["", "lemma eWlsInp_simp2[simp]:\n\"\\<not> liftAll (\\<lambda> eX. eX \\<noteq> ERR) einp \\<Longrightarrow> \\<not> eWlsInp MOD delta einp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<Longrightarrow>\n    \\<not> eWlsInp MOD delta einp", "by (force simp: sameDom_def liftAll_def liftAll2_def lift_def igWlsInp_def)"], ["", "corollary eWlsInp_simp3[simp]:\n\"\\<not> eWlsInp MOD delta (\\<lambda>i. Some ERR)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> eWlsInp MOD delta (\\<lambda>i. Some ERR)", "by (auto simp: liftAll_def)"], ["", "lemma eWlsBinp_simp1[simp]:\n\"eWlsBinp MOD delta (OKI binp) = igWlsBinp MOD delta binp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eWlsBinp MOD delta (OKI binp) = igWlsBinp MOD delta binp", "by (fastforce simp: OKI_def sameDom_def liftAll2_def lift_def igWlsBinp_def \n  split: option.splits)"], ["", "lemma eWlsBinp_simp2[simp]:\n\"\\<not> liftAll (\\<lambda> eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow> \\<not> eWlsBinp MOD delta ebinp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    \\<not> eWlsBinp MOD delta ebinp", "by (force simp: sameDom_def liftAll_def liftAll2_def lift_def igWlsBinp_def)"], ["", "corollary eWlsBinp_simp3[simp]:\n\"\\<not> eWlsBinp MOD delta (\\<lambda>i. Some ERR)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> eWlsBinp MOD delta (\\<lambda>i. Some ERR)", "by (auto simp: liftAll_def)"], ["", "lemmas eWlsAll_simps =\neWls_simp1 eWls_simp2\neWlsAbs_simp1 eWlsAbs_simp2\neWlsInp_simp1 eWlsInp_simp2 eWlsInp_simp3\neWlsBinp_simp1 eWlsBinp_simp2 eWlsBinp_simp3"], ["", "lemma eVar_simp[simp]:\n\"eVar MOD xs x = OK (igVar MOD xs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eVar MOD xs x = OK (igVar MOD xs x)", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igVar\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     xs x =\n    OK (igVar MOD xs x)", "by simp"], ["", "lemma eAbs_simp1[simp]:\n\"\\<lbrakk>isInBar (xs,s); igWls MOD s X\\<rbrakk> \\<Longrightarrow> eAbs MOD xs x (OK X) = OK (igAbs MOD xs x X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isInBar (xs, s); igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> eAbs MOD xs x (OK X) = OK (igAbs MOD xs x X)", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isInBar (xs, s); igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> igAbs\n                       \\<lparr>igWls =\n                                 \\<lambda>s eX.\n                                    case eX of ERR \\<Rightarrow> False\n                                    | OK X \\<Rightarrow> igWls MOD s X,\n                          igWlsAbs =\n                            \\<lambda>(us, s) eA.\n                               case eA of ERR \\<Rightarrow> False\n                               | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n                          igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n                          igAbs =\n                            \\<lambda>xs x eX.\n                               if eX \\<noteq> ERR \\<and>\n                                  (\\<exists>s.\nisInBar (xs, s) \\<and> igWls MOD s (check eX))\n                               then OK (igAbs MOD xs x (check eX)) else ERR,\n                          igOp =\n                            \\<lambda>delta einp ebinp.\n                               if liftAll (\\<lambda>X. X \\<noteq> ERR)\n                                   einp \\<and>\n                                  liftAll (\\<lambda>A. A \\<noteq> ERR)\n                                   ebinp \\<and>\n                                  igWlsInp MOD delta (checkI einp) \\<and>\n                                  igWlsBinp MOD delta (checkI ebinp)\n                               then OK (igOp MOD delta (checkI einp)\n   (checkI ebinp))\n                               else ERR,\n                          igFresh =\n                            \\<lambda>ys y eX.\n                               if eX \\<noteq> ERR \\<and>\n                                  (\\<exists>s. igWls MOD s (check eX))\n                               then igFresh MOD ys y (check eX) else True,\n                          igFreshAbs =\n                            \\<lambda>ys y eA.\n                               if eA \\<noteq> ERR \\<and>\n                                  (\\<exists>us s.\nigWlsAbs MOD (us, s) (check eA))\n                               then igFreshAbs MOD ys y (check eA)\n                               else True,\n                          igSwap =\n                            \\<lambda>zs z1 z2 eX.\n                               if eX \\<noteq> ERR \\<and>\n                                  (\\<exists>s. igWls MOD s (check eX))\n                               then OK (igSwap MOD zs z1 z2 (check eX))\n                               else ERR,\n                          igSwapAbs =\n                            \\<lambda>zs z1 z2 eA.\n                               if eA \\<noteq> ERR \\<and>\n                                  (\\<exists>us s.\nigWlsAbs MOD (us, s) (check eA))\n                               then OK (igSwapAbs MOD zs z1 z2 (check eA))\n                               else ERR,\n                          igSubst =\n                            \\<lambda>ys eY y eX.\n                               if eY \\<noteq> ERR \\<and>\n                                  igWls MOD (asSort ys) (check eY) \\<and>\n                                  eX \\<noteq> ERR \\<and>\n                                  (\\<exists>s. igWls MOD s (check eX))\n                               then OK (igSubst MOD ys (check eY) y\n   (check eX))\n                               else ERR,\n                          igSubstAbs =\n                            \\<lambda>ys eY y eA.\n                               if eY \\<noteq> ERR \\<and>\n                                  igWls MOD (asSort ys) (check eY) \\<and>\n                                  eA \\<noteq> ERR \\<and>\n                                  (\\<exists>us s.\nigWlsAbs MOD (us, s) (check eA))\n                               then OK (igSubstAbs MOD ys (check eY) y\n   (check eA))\n                               else ERR\\<rparr>\n                       xs x (OK X) =\n                      OK (igAbs MOD xs x X)", "by auto"], ["", "lemma eAbs_simp2[simp]:\n\"\\<forall> s. \\<not> (isInBar (xs,s) \\<and> igWls MOD s X) \\<Longrightarrow> eAbs MOD xs x (OK X) = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       \\<not> (isInBar (xs, s) \\<and> igWls MOD s X) \\<Longrightarrow>\n    eAbs MOD xs x (OK X) = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       \\<not> (isInBar (xs, s) \\<and> igWls MOD s X) \\<Longrightarrow>\n    igAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     xs x (OK X) =\n    ERR", "by auto"], ["", "lemma eAbs_simp3[simp]:\n\"eAbs MOD xs x ERR = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eAbs MOD xs x ERR = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     xs x ERR =\n    ERR", "by auto"], ["", "lemma eOp_simp1[simp]:\nassumes \"igWlsInp MOD delta inp\" and \"igWlsBinp MOD delta binp\"\nshows \"eOp MOD delta (OKI inp) (OKI binp) = OK (igOp MOD delta inp binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eOp MOD delta (OKI inp) (OKI binp) = OK (igOp MOD delta inp binp)", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igOp\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     delta (OKI inp) (OKI binp) =\n    OK (igOp MOD delta inp binp)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and>\n    liftAll (\\<lambda>A. A \\<noteq> ERR) (OKI binp) \\<and>\n    liftAll (\\<lambda>X. X \\<noteq> ERR) (OKI inp) \\<and>\n    igWlsBinp MOD delta binp", "unfolding liftAll_def OKI_def lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and>\n    (\\<forall>i v.\n        (case binp i of None \\<Rightarrow> None\n         | Some v \\<Rightarrow> Some (OK v)) =\n        Some v \\<longrightarrow>\n        v \\<noteq> ERR) \\<and>\n    (\\<forall>i v.\n        (case inp i of None \\<Rightarrow> None\n         | Some v \\<Rightarrow> Some (OK v)) =\n        Some v \\<longrightarrow>\n        v \\<noteq> ERR) \\<and>\n    igWlsBinp MOD delta binp", "using assms"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp\n  igWlsBinp MOD delta binp\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and>\n    (\\<forall>i v.\n        (case binp i of None \\<Rightarrow> None\n         | Some v \\<Rightarrow> Some (OK v)) =\n        Some v \\<longrightarrow>\n        v \\<noteq> ERR) \\<and>\n    (\\<forall>i v.\n        (case inp i of None \\<Rightarrow> None\n         | Some v \\<Rightarrow> Some (OK v)) =\n        Some v \\<longrightarrow>\n        v \\<noteq> ERR) \\<and>\n    igWlsBinp MOD delta binp", "by (auto split: option.splits)"], ["", "lemma eOp_simp2[simp]:\nassumes \"\\<not> igWlsInp MOD delta inp\"\nshows \"eOp MOD delta (OKI inp) ebinp = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eOp MOD delta (OKI inp) ebinp = ERR", "using assms"], ["proof (prove)\nusing this:\n  \\<not> igWlsInp MOD delta inp\n\ngoal (1 subgoal):\n 1. eOp MOD delta (OKI inp) ebinp = ERR", "unfolding errMOD_def"], ["proof (prove)\nusing this:\n  \\<not> igWlsInp MOD delta inp\n\ngoal (1 subgoal):\n 1. igOp\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     delta (OKI inp) ebinp =\n    ERR", "by auto"], ["", "lemma eOp_simp3[simp]:\nassumes \"\\<not> igWlsBinp MOD delta binp\"\nshows \"eOp MOD delta einp (OKI binp) = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eOp MOD delta einp (OKI binp) = ERR", "using assms"], ["proof (prove)\nusing this:\n  \\<not> igWlsBinp MOD delta binp\n\ngoal (1 subgoal):\n 1. eOp MOD delta einp (OKI binp) = ERR", "unfolding errMOD_def"], ["proof (prove)\nusing this:\n  \\<not> igWlsBinp MOD delta binp\n\ngoal (1 subgoal):\n 1. igOp\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     delta einp (OKI binp) =\n    ERR", "by auto"], ["", "lemma eOp_simp4[simp]:\nassumes \"\\<not> liftAll (\\<lambda> eX. eX \\<noteq> ERR) einp\"\nshows \"eOp MOD delta einp ebinp = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eOp MOD delta einp ebinp = ERR", "using assms"], ["proof (prove)\nusing this:\n  \\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp\n\ngoal (1 subgoal):\n 1. eOp MOD delta einp ebinp = ERR", "unfolding errMOD_def"], ["proof (prove)\nusing this:\n  \\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp\n\ngoal (1 subgoal):\n 1. igOp\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     delta einp ebinp =\n    ERR", "by auto"], ["", "corollary eOp_simp5[simp]:\n\"eOp MOD delta (\\<lambda>i. Some ERR) ebinp = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eOp MOD delta (\\<lambda>i. Some ERR) ebinp = ERR", "by (auto simp: liftAll_def)"], ["", "lemma eOp_simp6[simp]:\nassumes \"\\<not> liftAll (\\<lambda> eA. eA \\<noteq> ERR) ebinp\"\nshows \"eOp MOD delta einp ebinp = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eOp MOD delta einp ebinp = ERR", "using assms"], ["proof (prove)\nusing this:\n  \\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n\ngoal (1 subgoal):\n 1. eOp MOD delta einp ebinp = ERR", "unfolding errMOD_def"], ["proof (prove)\nusing this:\n  \\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n\ngoal (1 subgoal):\n 1. igOp\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     delta einp ebinp =\n    ERR", "by auto"], ["", "corollary eOp_simp7[simp]:\n\"eOp MOD delta einp (\\<lambda>i. Some ERR) = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eOp MOD delta einp (\\<lambda>i. Some ERR) = ERR", "by (auto simp: liftAll_def)"], ["", "lemmas eCons_simps =\neVar_simp\neAbs_simp1 eAbs_simp2 eAbs_simp3\neOp_simp1 eOp_simp2 eOp_simp3 eOp_simp4 eOp_simp5 eOp_simp6 eOp_simp7"], ["", "lemma eFresh_simp1[simp]:\n\"igWls MOD s X \\<Longrightarrow> eFresh MOD ys y (OK X) = igFresh MOD ys y X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls MOD s X \\<Longrightarrow>\n    eFresh MOD ys y (OK X) = igFresh MOD ys y X", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls MOD s X \\<Longrightarrow>\n    igFresh\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys y (OK X) =\n    igFresh MOD ys y X", "by auto"], ["", "lemma eFresh_simp2[simp]:\n\"\\<forall> s. \\<not> igWls MOD s X \\<Longrightarrow> eFresh MOD ys y (OK X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. \\<not> igWls MOD s X \\<Longrightarrow>\n    eFresh MOD ys y (OK X)", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. \\<not> igWls MOD s X \\<Longrightarrow>\n    igFresh\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys y (OK X)", "by auto"], ["", "lemma eFresh_simp3[simp]:\n\"eFresh MOD ys y ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eFresh MOD ys y ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igFresh\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys y ERR", "by auto"], ["", "lemma eFreshAbs_simp1[simp]:\n\"igWlsAbs MOD (us,s) A \\<Longrightarrow> eFreshAbs MOD ys y (OK A) = igFreshAbs MOD ys y A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAbs MOD (us, s) A \\<Longrightarrow>\n    eFreshAbs MOD ys y (OK A) = igFreshAbs MOD ys y A", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAbs MOD (us, s) A \\<Longrightarrow>\n    igFreshAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys y (OK A) =\n    igFreshAbs MOD ys y A", "by auto"], ["", "lemma eFreshAbs_simp2[simp]:\n\"\\<forall> us s. \\<not> igWlsAbs MOD (us,s) A \\<Longrightarrow> eFreshAbs MOD ys y (OK A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>us s. \\<not> igWlsAbs MOD (us, s) A \\<Longrightarrow>\n    eFreshAbs MOD ys y (OK A)", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>us s. \\<not> igWlsAbs MOD (us, s) A \\<Longrightarrow>\n    igFreshAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys y (OK A)", "by auto"], ["", "lemma eFreshAbs_simp3[simp]:\n\"eFreshAbs MOD ys y ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eFreshAbs MOD ys y ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys y ERR", "by auto"], ["", "lemma eFreshInp_simp[simp]:\n\"igWlsInp MOD delta inp\n \\<Longrightarrow> eFreshInp MOD ys y (OKI inp) = igFreshInp MOD ys y inp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<Longrightarrow>\n    eFreshInp MOD ys y (OKI inp) = igFreshInp MOD ys y inp", "by (force simp: igFreshInp_def OKI_def liftAll_lift_comp igWlsInp_defs intro!: liftAll_cong)"], ["", "lemma eFreshBinp_simp[simp]:\n\"igWlsBinp MOD delta binp\n \\<Longrightarrow> eFreshBinp MOD ys y (OKI binp) = igFreshBinp MOD ys y binp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta binp \\<Longrightarrow>\n    eFreshBinp MOD ys y (OKI binp) = igFreshBinp MOD ys y binp", "by (force simp: igFreshBinp_def OKI_def liftAll_lift_comp igWlsBinp_defs intro!: liftAll_cong)"], ["", "lemmas eFreshAll_simps =\neFresh_simp1 eFresh_simp2 eFresh_simp3\neFreshAbs_simp1 eFreshAbs_simp2 eFreshAbs_simp3\neFreshInp_simp\neFreshBinp_simp"], ["", "lemma eSwap_simp1[simp]:\n\"igWls MOD s X\n \\<Longrightarrow> eSwap MOD zs z1 z2 (OK X) = OK (igSwap MOD zs z1 z2 X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls MOD s X \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (OK X) = OK (igSwap MOD zs z1 z2 X)", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls MOD s X \\<Longrightarrow>\n    igSwap\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     zs z1 z2 (OK X) =\n    OK (igSwap MOD zs z1 z2 X)", "by auto"], ["", "lemma eSwap_simp2[simp]:\n\"\\<forall> s. \\<not> igWls MOD s X \\<Longrightarrow> eSwap MOD zs z1 z2 (OK X) = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. \\<not> igWls MOD s X \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (OK X) = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. \\<not> igWls MOD s X \\<Longrightarrow>\n    igSwap\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     zs z1 z2 (OK X) =\n    ERR", "by auto"], ["", "lemma eSwap_simp3[simp]:\n\"eSwap MOD zs z1 z2 ERR = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSwap MOD zs z1 z2 ERR = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwap\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     zs z1 z2 ERR =\n    ERR", "by auto"], ["", "lemma eSwapAbs_simp1[simp]:\n\"igWlsAbs MOD (us,s) A\n \\<Longrightarrow> eSwapAbs MOD zs z1 z2 (OK A) = OK (igSwapAbs MOD zs z1 z2 A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAbs MOD (us, s) A \\<Longrightarrow>\n    eSwapAbs MOD zs z1 z2 (OK A) = OK (igSwapAbs MOD zs z1 z2 A)", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAbs MOD (us, s) A \\<Longrightarrow>\n    igSwapAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     zs z1 z2 (OK A) =\n    OK (igSwapAbs MOD zs z1 z2 A)", "by auto"], ["", "lemma eSwapAbs_simp2[simp]:\n\"\\<forall> us s. \\<not> igWlsAbs MOD (us,s) A \\<Longrightarrow> eSwapAbs MOD zs z1 z2 (OK A) = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>us s. \\<not> igWlsAbs MOD (us, s) A \\<Longrightarrow>\n    eSwapAbs MOD zs z1 z2 (OK A) = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>us s. \\<not> igWlsAbs MOD (us, s) A \\<Longrightarrow>\n    igSwapAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     zs z1 z2 (OK A) =\n    ERR", "by auto"], ["", "lemma eSwapAbs_simp3[simp]:\n\"eSwapAbs MOD zs z1 z2 ERR = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSwapAbs MOD zs z1 z2 ERR = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     zs z1 z2 ERR =\n    ERR", "by auto"], ["", "lemma eSwapInp_simp1[simp]:\n\"igWlsInp MOD delta inp\n \\<Longrightarrow> eSwapInp MOD zs z1 z2 (OKI inp) = OKI (igSwapInp MOD zs z1 z2 inp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<Longrightarrow>\n    eSwapInp MOD zs z1 z2 (OKI inp) = OKI (igSwapInp MOD zs z1 z2 inp)", "by (force simp: igSwapInp_def OKI_def lift_comp igWlsInp_defs intro!: lift_cong)"], ["", "lemma eSwapInp_simp2[simp]:\nassumes \"\\<not> liftAll (\\<lambda> eX. eX \\<noteq> ERR) einp\"\nshows \"\\<not> liftAll (\\<lambda> eX. eX \\<noteq> ERR) (eSwapInp MOD zs z1 z2 einp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR)\n            (eSwapInp MOD zs z1 z2 einp)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp\n\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR)\n            (eSwapInp MOD zs z1 z2 einp)", "unfolding liftAll_def igSwapInp_def lift_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i v. einp i = Some v \\<longrightarrow> v \\<noteq> ERR)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i v.\n               (case einp i of None \\<Rightarrow> None\n                | Some v \\<Rightarrow> Some (eSwap MOD zs z1 z2 v)) =\n               Some v \\<longrightarrow>\n               v \\<noteq> ERR)", "by (auto split: option.splits)"], ["", "lemma eSwapBinp_simp1[simp]:\n\"igWlsBinp MOD delta binp\n \\<Longrightarrow> eSwapBinp MOD zs z1 z2 (OKI binp) = OKI (igSwapBinp MOD zs z1 z2 binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwapBinp MOD zs z1 z2 (OKI binp) = OKI (igSwapBinp MOD zs z1 z2 binp)", "by (force simp: igSwapBinp_def OKI_def lift_comp igWlsBinp_defs intro!: lift_cong)"], ["", "lemma eSwapBinp_simp2[simp]:\nassumes \"\\<not> liftAll (\\<lambda> eA. eA \\<noteq> ERR) ebinp\"\nshows \"\\<not> liftAll (\\<lambda> eA. eA \\<noteq> ERR) (eSwapBinp MOD zs z1 z2 ebinp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR)\n            (eSwapBinp MOD zs z1 z2 ebinp)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR)\n            (eSwapBinp MOD zs z1 z2 ebinp)", "unfolding liftAll_def igSwapBinp_def lift_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i v. ebinp i = Some v \\<longrightarrow> v \\<noteq> ERR)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i v.\n               (case ebinp i of None \\<Rightarrow> None\n                | Some v \\<Rightarrow> Some (eSwapAbs MOD zs z1 z2 v)) =\n               Some v \\<longrightarrow>\n               v \\<noteq> ERR)", "by (auto split: option.splits)"], ["", "lemmas eSwapAll_simps =\neSwap_simp1 eSwap_simp2 eSwap_simp3\neSwapAbs_simp1 eSwapAbs_simp2 eSwapAbs_simp3\neSwapInp_simp1 eSwapInp_simp2\neSwapBinp_simp1 eSwapBinp_simp2"], ["", "lemma eSubst_simp1[simp]:\n\"\\<lbrakk>igWls MOD (asSort ys) Y; igWls MOD s X\\<rbrakk>\n \\<Longrightarrow> eSubst MOD ys (OK Y) y (OK X) = OK (igSubst MOD ys Y y X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igWls MOD (asSort ys) Y; igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> eSubst MOD ys (OK Y) y (OK X) =\n                      OK (igSubst MOD ys Y y X)", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igWls MOD (asSort ys) Y; igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> igSubst\n                       \\<lparr>igWls =\n                                 \\<lambda>s eX.\n                                    case eX of ERR \\<Rightarrow> False\n                                    | OK X \\<Rightarrow> igWls MOD s X,\n                          igWlsAbs =\n                            \\<lambda>(us, s) eA.\n                               case eA of ERR \\<Rightarrow> False\n                               | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n                          igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n                          igAbs =\n                            \\<lambda>xs x eX.\n                               if eX \\<noteq> ERR \\<and>\n                                  (\\<exists>s.\nisInBar (xs, s) \\<and> igWls MOD s (check eX))\n                               then OK (igAbs MOD xs x (check eX)) else ERR,\n                          igOp =\n                            \\<lambda>delta einp ebinp.\n                               if liftAll (\\<lambda>X. X \\<noteq> ERR)\n                                   einp \\<and>\n                                  liftAll (\\<lambda>A. A \\<noteq> ERR)\n                                   ebinp \\<and>\n                                  igWlsInp MOD delta (checkI einp) \\<and>\n                                  igWlsBinp MOD delta (checkI ebinp)\n                               then OK (igOp MOD delta (checkI einp)\n   (checkI ebinp))\n                               else ERR,\n                          igFresh =\n                            \\<lambda>ys y eX.\n                               if eX \\<noteq> ERR \\<and>\n                                  (\\<exists>s. igWls MOD s (check eX))\n                               then igFresh MOD ys y (check eX) else True,\n                          igFreshAbs =\n                            \\<lambda>ys y eA.\n                               if eA \\<noteq> ERR \\<and>\n                                  (\\<exists>us s.\nigWlsAbs MOD (us, s) (check eA))\n                               then igFreshAbs MOD ys y (check eA)\n                               else True,\n                          igSwap =\n                            \\<lambda>zs z1 z2 eX.\n                               if eX \\<noteq> ERR \\<and>\n                                  (\\<exists>s. igWls MOD s (check eX))\n                               then OK (igSwap MOD zs z1 z2 (check eX))\n                               else ERR,\n                          igSwapAbs =\n                            \\<lambda>zs z1 z2 eA.\n                               if eA \\<noteq> ERR \\<and>\n                                  (\\<exists>us s.\nigWlsAbs MOD (us, s) (check eA))\n                               then OK (igSwapAbs MOD zs z1 z2 (check eA))\n                               else ERR,\n                          igSubst =\n                            \\<lambda>ys eY y eX.\n                               if eY \\<noteq> ERR \\<and>\n                                  igWls MOD (asSort ys) (check eY) \\<and>\n                                  eX \\<noteq> ERR \\<and>\n                                  (\\<exists>s. igWls MOD s (check eX))\n                               then OK (igSubst MOD ys (check eY) y\n   (check eX))\n                               else ERR,\n                          igSubstAbs =\n                            \\<lambda>ys eY y eA.\n                               if eY \\<noteq> ERR \\<and>\n                                  igWls MOD (asSort ys) (check eY) \\<and>\n                                  eA \\<noteq> ERR \\<and>\n                                  (\\<exists>us s.\nigWlsAbs MOD (us, s) (check eA))\n                               then OK (igSubstAbs MOD ys (check eY) y\n   (check eA))\n                               else ERR\\<rparr>\n                       ys (OK Y) y (OK X) =\n                      OK (igSubst MOD ys Y y X)", "by auto"], ["", "lemma eSubst_simp2[simp]:\n\"\\<not> igWls MOD (asSort ys) Y \\<Longrightarrow> eSubst MOD ys (OK Y) y eX = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubst MOD ys (OK Y) y eX = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> igWls MOD (asSort ys) Y \\<Longrightarrow>\n    igSubst\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys (OK Y) y eX =\n    ERR", "by auto"], ["", "lemma eSubst_simp3[simp]:\n\"\\<forall> s. \\<not> igWls MOD s X \\<Longrightarrow> eSubst MOD ys eY y (OK X) = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. \\<not> igWls MOD s X \\<Longrightarrow>\n    eSubst MOD ys eY y (OK X) = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. \\<not> igWls MOD s X \\<Longrightarrow>\n    igSubst\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys eY y (OK X) =\n    ERR", "by auto"], ["", "lemma eSubst_simp4[simp]:\n\"eSubst MOD ys eY y ERR = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSubst MOD ys eY y ERR = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubst\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys eY y ERR =\n    ERR", "by auto"], ["", "lemma eSubst_simp5[simp]:\n\"eSubst MOD ys ERR y eX = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSubst MOD ys ERR y eX = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubst\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys ERR y eX =\n    ERR", "by auto"], ["", "lemma eSubstAbs_simp1[simp]:\n\"\\<lbrakk>igWls MOD (asSort ys) Y; igWlsAbs MOD (us,s) A\\<rbrakk>\n \\<Longrightarrow> eSubstAbs MOD ys (OK Y) y (OK A) = OK (igSubstAbs MOD ys Y y A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igWls MOD (asSort ys) Y; igWlsAbs MOD (us, s) A\\<rbrakk>\n    \\<Longrightarrow> eSubstAbs MOD ys (OK Y) y (OK A) =\n                      OK (igSubstAbs MOD ys Y y A)", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igWls MOD (asSort ys) Y; igWlsAbs MOD (us, s) A\\<rbrakk>\n    \\<Longrightarrow> igSubstAbs\n                       \\<lparr>igWls =\n                                 \\<lambda>s eX.\n                                    case eX of ERR \\<Rightarrow> False\n                                    | OK X \\<Rightarrow> igWls MOD s X,\n                          igWlsAbs =\n                            \\<lambda>(us, s) eA.\n                               case eA of ERR \\<Rightarrow> False\n                               | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n                          igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n                          igAbs =\n                            \\<lambda>xs x eX.\n                               if eX \\<noteq> ERR \\<and>\n                                  (\\<exists>s.\nisInBar (xs, s) \\<and> igWls MOD s (check eX))\n                               then OK (igAbs MOD xs x (check eX)) else ERR,\n                          igOp =\n                            \\<lambda>delta einp ebinp.\n                               if liftAll (\\<lambda>X. X \\<noteq> ERR)\n                                   einp \\<and>\n                                  liftAll (\\<lambda>A. A \\<noteq> ERR)\n                                   ebinp \\<and>\n                                  igWlsInp MOD delta (checkI einp) \\<and>\n                                  igWlsBinp MOD delta (checkI ebinp)\n                               then OK (igOp MOD delta (checkI einp)\n   (checkI ebinp))\n                               else ERR,\n                          igFresh =\n                            \\<lambda>ys y eX.\n                               if eX \\<noteq> ERR \\<and>\n                                  (\\<exists>s. igWls MOD s (check eX))\n                               then igFresh MOD ys y (check eX) else True,\n                          igFreshAbs =\n                            \\<lambda>ys y eA.\n                               if eA \\<noteq> ERR \\<and>\n                                  (\\<exists>us s.\nigWlsAbs MOD (us, s) (check eA))\n                               then igFreshAbs MOD ys y (check eA)\n                               else True,\n                          igSwap =\n                            \\<lambda>zs z1 z2 eX.\n                               if eX \\<noteq> ERR \\<and>\n                                  (\\<exists>s. igWls MOD s (check eX))\n                               then OK (igSwap MOD zs z1 z2 (check eX))\n                               else ERR,\n                          igSwapAbs =\n                            \\<lambda>zs z1 z2 eA.\n                               if eA \\<noteq> ERR \\<and>\n                                  (\\<exists>us s.\nigWlsAbs MOD (us, s) (check eA))\n                               then OK (igSwapAbs MOD zs z1 z2 (check eA))\n                               else ERR,\n                          igSubst =\n                            \\<lambda>ys eY y eX.\n                               if eY \\<noteq> ERR \\<and>\n                                  igWls MOD (asSort ys) (check eY) \\<and>\n                                  eX \\<noteq> ERR \\<and>\n                                  (\\<exists>s. igWls MOD s (check eX))\n                               then OK (igSubst MOD ys (check eY) y\n   (check eX))\n                               else ERR,\n                          igSubstAbs =\n                            \\<lambda>ys eY y eA.\n                               if eY \\<noteq> ERR \\<and>\n                                  igWls MOD (asSort ys) (check eY) \\<and>\n                                  eA \\<noteq> ERR \\<and>\n                                  (\\<exists>us s.\nigWlsAbs MOD (us, s) (check eA))\n                               then OK (igSubstAbs MOD ys (check eY) y\n   (check eA))\n                               else ERR\\<rparr>\n                       ys (OK Y) y (OK A) =\n                      OK (igSubstAbs MOD ys Y y A)", "by auto"], ["", "lemma eSubstAbs_simp2[simp]:\n\"\\<not> igWls MOD (asSort ys) Y \\<Longrightarrow> eSubstAbs MOD ys (OK Y) y eA = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys (OK Y) y eA = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> igWls MOD (asSort ys) Y \\<Longrightarrow>\n    igSubstAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys (OK Y) y eA =\n    ERR", "by auto"], ["", "lemma eSubstAbs_simp3[simp]:\n\"\\<forall> us s. \\<not> igWlsAbs MOD (us,s) A \\<Longrightarrow> eSubstAbs MOD ys eY y (OK A) = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>us s. \\<not> igWlsAbs MOD (us, s) A \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (OK A) = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>us s. \\<not> igWlsAbs MOD (us, s) A \\<Longrightarrow>\n    igSubstAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys eY y (OK A) =\n    ERR", "by auto"], ["", "lemma eSubstAbs_simp4[simp]:\n\"eSubstAbs MOD ys eY y ERR = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSubstAbs MOD ys eY y ERR = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys eY y ERR =\n    ERR", "by auto"], ["", "lemma eSubstAbs_simp5[simp]:\n\"eSubstAbs MOD ys ERR y eA = ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSubstAbs MOD ys ERR y eA = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys ERR y eA =\n    ERR", "by auto"], ["", "lemma eSubstInp_simp1[simp]:\n\"\\<lbrakk>igWls MOD (asSort ys) Y; igWlsInp MOD delta inp\\<rbrakk>\n \\<Longrightarrow> eSubstInp MOD ys (OK Y) y (OKI inp) = OKI (igSubstInp MOD ys Y y inp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igWls MOD (asSort ys) Y; igWlsInp MOD delta inp\\<rbrakk>\n    \\<Longrightarrow> eSubstInp MOD ys (OK Y) y (OKI inp) =\n                      OKI (igSubstInp MOD ys Y y inp)", "by (force simp: igSubstInp_def OKI_def lift_comp igWlsInp_defs intro!: lift_cong)"], ["", "lemma eSubstInp_simp2[simp]:\nassumes \"\\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp\"\nshows \"\\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR) (eSubstInp MOD ys eY y einp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR)\n            (eSubstInp MOD ys eY y einp)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp\n\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR)\n            (eSubstInp MOD ys eY y einp)", "unfolding lift_def igSubstInp_def liftAll_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i v. einp i = Some v \\<longrightarrow> v \\<noteq> ERR)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i v.\n               (case einp i of None \\<Rightarrow> None\n                | Some v \\<Rightarrow> Some (eSubst MOD ys eY y v)) =\n               Some v \\<longrightarrow>\n               v \\<noteq> ERR)", "by (auto split: option.splits)"], ["", "lemma eSubstInp_simp3[simp]:\nassumes *: \"\\<not> igWls MOD (asSort ys) Y\" and **: \"\\<not> einp = (\\<lambda> i. None)\"\nshows \"\\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR) (eSubstInp MOD ys (OK Y) y einp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR)\n            (eSubstInp MOD ys (OK Y) y einp)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> igWls MOD (asSort ys) Y\n  einp \\<noteq> Map.empty\n\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR)\n            (eSubstInp MOD ys (OK Y) y einp)", "by (auto simp: igSubstInp_def liftAll_lift_comp lift_def liftAll_def \nsplit: option.splits)"], ["", "lemma eSubstInp_simp4[simp]:\nassumes \"\\<not> einp = (\\<lambda> i. None)\"\nshows \"\\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR) (eSubstInp MOD ys ERR y einp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR)\n            (eSubstInp MOD ys ERR y einp)", "using assms"], ["proof (prove)\nusing this:\n  einp \\<noteq> Map.empty\n\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR)\n            (eSubstInp MOD ys ERR y einp)", "by (auto simp: igSubstInp_def liftAll_lift_comp lift_def liftAll_def \nsplit: option.splits)"], ["", "lemma eSubstBinp_simp1[simp]:\n\"\\<lbrakk>igWls MOD (asSort ys) Y; igWlsBinp MOD delta binp\\<rbrakk>\n \\<Longrightarrow> eSubstBinp MOD ys (OK Y) y (OKI binp) = OKI (igSubstBinp MOD ys Y y binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igWls MOD (asSort ys) Y; igWlsBinp MOD delta binp\\<rbrakk>\n    \\<Longrightarrow> eSubstBinp MOD ys (OK Y) y (OKI binp) =\n                      OKI (igSubstBinp MOD ys Y y binp)", "by (force simp: igSubstBinp_def OKI_def lift_comp igWlsBinp_defs intro!: lift_cong)"], ["", "lemma eSubstBinp_simp2[simp]:\nassumes \"\\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\"\nshows \"\\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR) (eSubstBinp MOD ys eY y ebinp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR)\n            (eSubstBinp MOD ys eY y ebinp)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR)\n            (eSubstBinp MOD ys eY y ebinp)", "by (auto simp: igSubstBinp_def liftAll_lift_comp lift_def liftAll_def \nsplit: option.splits)"], ["", "lemma eSubstBinp_simp3[simp]:\nassumes *: \"\\<not> igWls MOD (asSort ys) Y\" and **: \"\\<not> ebinp = (\\<lambda> i. None)\"\nshows \"\\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR) (eSubstBinp MOD ys (OK Y) y ebinp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR)\n            (eSubstBinp MOD ys (OK Y) y ebinp)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> igWls MOD (asSort ys) Y\n  ebinp \\<noteq> Map.empty\n\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR)\n            (eSubstBinp MOD ys (OK Y) y ebinp)", "by (auto simp: igSubstBinp_def liftAll_lift_comp lift_def liftAll_def \nsplit: option.splits)"], ["", "lemma eSubstBinp_simp4[simp]:\nassumes \"\\<not> ebinp = (\\<lambda> i. None)\"\nshows \"\\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR) (eSubstBinp MOD ys ERR y ebinp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR)\n            (eSubstBinp MOD ys ERR y ebinp)", "using assms"], ["proof (prove)\nusing this:\n  ebinp \\<noteq> Map.empty\n\ngoal (1 subgoal):\n 1. \\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR)\n            (eSubstBinp MOD ys ERR y ebinp)", "by (auto simp: igSubstBinp_def liftAll_lift_comp lift_def liftAll_def \nsplit: option.splits)"], ["", "lemmas eSubstAll_simps =\neSubst_simp1 eSubst_simp2 eSubst_simp3 eSubst_simp4 eSubst_simp5\neSubstAbs_simp1 eSubstAbs_simp2 eSubstAbs_simp3 eSubstAbs_simp4 eSubstAbs_simp5\neSubstInp_simp1 eSubstInp_simp2 eSubstInp_simp3 eSubstInp_simp4\neSubstBinp_simp1 eSubstBinp_simp2 eSubstBinp_simp3 eSubstBinp_simp4"], ["", "lemmas error_model_simps =\nOK_OKI_simps\neWlsAll_simps\neCons_simps\neFreshAll_simps\neSwapAll_simps\neSubstAll_simps"], ["", "subsubsection \\<open>Nchotomies\\<close>"], ["", "lemma eWls_nchotomy:\n\"(\\<exists> X. eX = OK X \\<and> igWls MOD s X) \\<or> \\<not> eWls MOD s eX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>X. eX = OK X \\<and> igWls MOD s X) \\<or> \\<not> eWls MOD s eX", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>X. eX = OK X \\<and> igWls MOD s X) \\<or>\n    \\<not> igWls\n            \\<lparr>igWls =\n                      \\<lambda>s eX.\n                         case eX of ERR \\<Rightarrow> False\n                         | OK X \\<Rightarrow> igWls MOD s X,\n               igWlsAbs =\n                 \\<lambda>(us, s) eA.\n                    case eA of ERR \\<Rightarrow> False\n                    | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n               igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n               igAbs =\n                 \\<lambda>xs x eX.\n                    if eX \\<noteq> ERR \\<and>\n                       (\\<exists>s.\n                           isInBar (xs, s) \\<and> igWls MOD s (check eX))\n                    then OK (igAbs MOD xs x (check eX)) else ERR,\n               igOp =\n                 \\<lambda>delta einp ebinp.\n                    if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                       liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                       igWlsInp MOD delta (checkI einp) \\<and>\n                       igWlsBinp MOD delta (checkI ebinp)\n                    then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n                    else ERR,\n               igFresh =\n                 \\<lambda>ys y eX.\n                    if eX \\<noteq> ERR \\<and>\n                       (\\<exists>s. igWls MOD s (check eX))\n                    then igFresh MOD ys y (check eX) else True,\n               igFreshAbs =\n                 \\<lambda>ys y eA.\n                    if eA \\<noteq> ERR \\<and>\n                       (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                    then igFreshAbs MOD ys y (check eA) else True,\n               igSwap =\n                 \\<lambda>zs z1 z2 eX.\n                    if eX \\<noteq> ERR \\<and>\n                       (\\<exists>s. igWls MOD s (check eX))\n                    then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n               igSwapAbs =\n                 \\<lambda>zs z1 z2 eA.\n                    if eA \\<noteq> ERR \\<and>\n                       (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                    then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n               igSubst =\n                 \\<lambda>ys eY y eX.\n                    if eY \\<noteq> ERR \\<and>\n                       igWls MOD (asSort ys) (check eY) \\<and>\n                       eX \\<noteq> ERR \\<and>\n                       (\\<exists>s. igWls MOD s (check eX))\n                    then OK (igSubst MOD ys (check eY) y (check eX))\n                    else ERR,\n               igSubstAbs =\n                 \\<lambda>ys eY y eA.\n                    if eY \\<noteq> ERR \\<and>\n                       igWls MOD (asSort ys) (check eY) \\<and>\n                       eA \\<noteq> ERR \\<and>\n                       (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                    then OK (igSubstAbs MOD ys (check eY) y (check eA))\n                    else ERR\\<rparr>\n            s eX", "by(cases eX) auto"], ["", "lemma eWlsAbs_nchotomy:\n\"(\\<exists> A. eA = OK A \\<and> igWlsAbs MOD (us,s) A) \\<or> \\<not> eWlsAbs MOD (us,s) eA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>A. eA = OK A \\<and> igWlsAbs MOD (us, s) A) \\<or>\n    \\<not> eWlsAbs MOD (us, s) eA", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>A. eA = OK A \\<and> igWlsAbs MOD (us, s) A) \\<or>\n    \\<not> igWlsAbs\n            \\<lparr>igWls =\n                      \\<lambda>s eX.\n                         case eX of ERR \\<Rightarrow> False\n                         | OK X \\<Rightarrow> igWls MOD s X,\n               igWlsAbs =\n                 \\<lambda>(us, s) eA.\n                    case eA of ERR \\<Rightarrow> False\n                    | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n               igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n               igAbs =\n                 \\<lambda>xs x eX.\n                    if eX \\<noteq> ERR \\<and>\n                       (\\<exists>s.\n                           isInBar (xs, s) \\<and> igWls MOD s (check eX))\n                    then OK (igAbs MOD xs x (check eX)) else ERR,\n               igOp =\n                 \\<lambda>delta einp ebinp.\n                    if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                       liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                       igWlsInp MOD delta (checkI einp) \\<and>\n                       igWlsBinp MOD delta (checkI ebinp)\n                    then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n                    else ERR,\n               igFresh =\n                 \\<lambda>ys y eX.\n                    if eX \\<noteq> ERR \\<and>\n                       (\\<exists>s. igWls MOD s (check eX))\n                    then igFresh MOD ys y (check eX) else True,\n               igFreshAbs =\n                 \\<lambda>ys y eA.\n                    if eA \\<noteq> ERR \\<and>\n                       (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                    then igFreshAbs MOD ys y (check eA) else True,\n               igSwap =\n                 \\<lambda>zs z1 z2 eX.\n                    if eX \\<noteq> ERR \\<and>\n                       (\\<exists>s. igWls MOD s (check eX))\n                    then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n               igSwapAbs =\n                 \\<lambda>zs z1 z2 eA.\n                    if eA \\<noteq> ERR \\<and>\n                       (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                    then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n               igSubst =\n                 \\<lambda>ys eY y eX.\n                    if eY \\<noteq> ERR \\<and>\n                       igWls MOD (asSort ys) (check eY) \\<and>\n                       eX \\<noteq> ERR \\<and>\n                       (\\<exists>s. igWls MOD s (check eX))\n                    then OK (igSubst MOD ys (check eY) y (check eX))\n                    else ERR,\n               igSubstAbs =\n                 \\<lambda>ys eY y eA.\n                    if eY \\<noteq> ERR \\<and>\n                       igWls MOD (asSort ys) (check eY) \\<and>\n                       eA \\<noteq> ERR \\<and>\n                       (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                    then OK (igSubstAbs MOD ys (check eY) y (check eA))\n                    else ERR\\<rparr>\n            (us, s) eA", "by(cases eA) auto"], ["", "lemma eAbs_nchotomy:\n\"((\\<exists> s X. eX = OK X \\<and> isInBar (xs,s) \\<and> igWls MOD s X)) \\<or> (eAbs MOD xs x eX = ERR)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>s X.\n        eX = OK X \\<and> isInBar (xs, s) \\<and> igWls MOD s X) \\<or>\n    eAbs MOD xs x eX = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>s X.\n        eX = OK X \\<and> isInBar (xs, s) \\<and> igWls MOD s X) \\<or>\n    igAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     xs x eX =\n    ERR", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eX \\<noteq> ERR \\<and>\n    (\\<exists>s.\n        isInBar (xs, s) \\<and> igWls MOD s (check eX)) \\<longrightarrow>\n    (\\<exists>s X. eX = OK X \\<and> isInBar (xs, s) \\<and> igWls MOD s X)", "using OK_check"], ["proof (prove)\nusing this:\n  ?eX \\<noteq> ERR \\<Longrightarrow> OK (check ?eX) = ?eX\n\ngoal (1 subgoal):\n 1. eX \\<noteq> ERR \\<and>\n    (\\<exists>s.\n        isInBar (xs, s) \\<and> igWls MOD s (check eX)) \\<longrightarrow>\n    (\\<exists>s X. eX = OK X \\<and> isInBar (xs, s) \\<and> igWls MOD s X)", "by fastforce"], ["", "lemma eOp_nchotomy:\n\"(\\<exists> inp binp. einp = OKI inp \\<and> igWlsInp MOD delta inp \\<and>\n              ebinp = OKI binp \\<and> igWlsBinp MOD delta binp)\n  \\<or>\n (eOp MOD delta einp ebinp = ERR)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>inp binp.\n        einp = OKI inp \\<and>\n        igWlsInp MOD delta inp \\<and>\n        ebinp = OKI binp \\<and> igWlsBinp MOD delta binp) \\<or>\n    eOp MOD delta einp ebinp = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>inp binp.\n        einp = OKI inp \\<and>\n        igWlsInp MOD delta inp \\<and>\n        ebinp = OKI binp \\<and> igWlsBinp MOD delta binp) \\<or>\n    igOp\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     delta einp ebinp =\n    ERR", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n    igWlsInp MOD delta (checkI einp) \\<and>\n    igWlsBinp MOD delta (checkI ebinp) \\<longrightarrow>\n    (\\<exists>inp.\n        einp = OKI inp \\<and>\n        igWlsInp MOD delta inp \\<and>\n        (\\<exists>binp. ebinp = OKI binp \\<and> igWlsBinp MOD delta binp))", "using OKI_checkI"], ["proof (prove)\nusing this:\n  liftAll (\\<lambda>X. X \\<noteq> ERR) ?einp \\<Longrightarrow>\n  OKI (checkI ?einp) = ?einp\n\ngoal (1 subgoal):\n 1. liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n    igWlsInp MOD delta (checkI einp) \\<and>\n    igWlsBinp MOD delta (checkI ebinp) \\<longrightarrow>\n    (\\<exists>inp.\n        einp = OKI inp \\<and>\n        igWlsInp MOD delta inp \\<and>\n        (\\<exists>binp. ebinp = OKI binp \\<and> igWlsBinp MOD delta binp))", "by force"], ["", "lemma eFresh_nchotomy:\n\"(\\<exists> s X. eX = OK X \\<and> igWls MOD s X) \\<or> eFresh MOD ys y eX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>s X. eX = OK X \\<and> igWls MOD s X) \\<or> eFresh MOD ys y eX", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>s X. eX = OK X \\<and> igWls MOD s X) \\<or>\n    igFresh\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys y eX", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eX \\<noteq> ERR \\<and>\n    (\\<exists>s. igWls MOD s (check eX)) \\<longrightarrow>\n    (\\<exists>s X. eX = OK X \\<and> igWls MOD s X) \\<or>\n    igFresh MOD ys y (check eX)", "using OK_check"], ["proof (prove)\nusing this:\n  ?eX \\<noteq> ERR \\<Longrightarrow> OK (check ?eX) = ?eX\n\ngoal (1 subgoal):\n 1. eX \\<noteq> ERR \\<and>\n    (\\<exists>s. igWls MOD s (check eX)) \\<longrightarrow>\n    (\\<exists>s X. eX = OK X \\<and> igWls MOD s X) \\<or>\n    igFresh MOD ys y (check eX)", "by fastforce"], ["", "lemma eFreshAbs_nchotomy:\n\"(\\<exists> us s A. eA = OK A \\<and> igWlsAbs MOD (us,s) A)\n \\<or> eFreshAbs MOD ys y eA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>us s A. eA = OK A \\<and> igWlsAbs MOD (us, s) A) \\<or>\n    eFreshAbs MOD ys y eA", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>us s A. eA = OK A \\<and> igWlsAbs MOD (us, s) A) \\<or>\n    igFreshAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys y eA", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eA \\<noteq> ERR \\<and>\n    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA)) \\<longrightarrow>\n    (\\<exists>us s A. eA = OK A \\<and> igWlsAbs MOD (us, s) A) \\<or>\n    igFreshAbs MOD ys y (check eA)", "using OK_check"], ["proof (prove)\nusing this:\n  ?eX \\<noteq> ERR \\<Longrightarrow> OK (check ?eX) = ?eX\n\ngoal (1 subgoal):\n 1. eA \\<noteq> ERR \\<and>\n    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA)) \\<longrightarrow>\n    (\\<exists>us s A. eA = OK A \\<and> igWlsAbs MOD (us, s) A) \\<or>\n    igFreshAbs MOD ys y (check eA)", "by fastforce"], ["", "lemma eSwap_nchotomy:\n\"(\\<exists> s X. eX = OK X \\<and> igWls MOD s X) \\<or>\n (eSwap MOD zs z1 z2 eX = ERR)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>s X. eX = OK X \\<and> igWls MOD s X) \\<or>\n    eSwap MOD zs z1 z2 eX = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>s X. eX = OK X \\<and> igWls MOD s X) \\<or>\n    igSwap\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     zs z1 z2 eX =\n    ERR", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eX \\<noteq> ERR \\<and>\n    (\\<exists>s. igWls MOD s (check eX)) \\<longrightarrow>\n    (\\<exists>s X. eX = OK X \\<and> igWls MOD s X)", "using OK_check"], ["proof (prove)\nusing this:\n  ?eX \\<noteq> ERR \\<Longrightarrow> OK (check ?eX) = ?eX\n\ngoal (1 subgoal):\n 1. eX \\<noteq> ERR \\<and>\n    (\\<exists>s. igWls MOD s (check eX)) \\<longrightarrow>\n    (\\<exists>s X. eX = OK X \\<and> igWls MOD s X)", "by fastforce"], ["", "lemma eSwapAbs_nchotomy:\n\"(\\<exists> us s A. eA = OK A \\<and> igWlsAbs MOD (us,s) A) \\<or>\n (eSwapAbs MOD zs z1 z2 eA = ERR)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>us s A. eA = OK A \\<and> igWlsAbs MOD (us, s) A) \\<or>\n    eSwapAbs MOD zs z1 z2 eA = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>us s A. eA = OK A \\<and> igWlsAbs MOD (us, s) A) \\<or>\n    igSwapAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     zs z1 z2 eA =\n    ERR", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eA \\<noteq> ERR \\<and>\n    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA)) \\<longrightarrow>\n    (\\<exists>us s A. eA = OK A \\<and> igWlsAbs MOD (us, s) A)", "using OK_check"], ["proof (prove)\nusing this:\n  ?eX \\<noteq> ERR \\<Longrightarrow> OK (check ?eX) = ?eX\n\ngoal (1 subgoal):\n 1. eA \\<noteq> ERR \\<and>\n    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA)) \\<longrightarrow>\n    (\\<exists>us s A. eA = OK A \\<and> igWlsAbs MOD (us, s) A)", "by fastforce"], ["", "lemma eSubst_nchotomy:\n\"(\\<exists> Y. eY = OK Y \\<and>\n  igWls MOD (asSort ys) Y) \\<and> (\\<exists> s X. eX = OK X \\<and> igWls MOD s X)\n \\<or>\n (eSubst MOD ys eY y eX = ERR)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>Y. eY = OK Y \\<and> igWls MOD (asSort ys) Y) \\<and>\n    (\\<exists>s X. eX = OK X \\<and> igWls MOD s X) \\<or>\n    eSubst MOD ys eY y eX = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>Y. eY = OK Y \\<and> igWls MOD (asSort ys) Y) \\<and>\n    (\\<exists>s X. eX = OK X \\<and> igWls MOD s X) \\<or>\n    igSubst\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys eY y eX =\n    ERR", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eY \\<noteq> ERR \\<and>\n    igWls MOD (asSort ys) (check eY) \\<and>\n    eX \\<noteq> ERR \\<and>\n    (\\<exists>s. igWls MOD s (check eX)) \\<longrightarrow>\n    (\\<exists>Y. eY = OK Y \\<and> igWls MOD (asSort ys) Y) \\<and>\n    (\\<exists>s X. eX = OK X \\<and> igWls MOD s X)", "using OK_check"], ["proof (prove)\nusing this:\n  ?eX \\<noteq> ERR \\<Longrightarrow> OK (check ?eX) = ?eX\n\ngoal (1 subgoal):\n 1. eY \\<noteq> ERR \\<and>\n    igWls MOD (asSort ys) (check eY) \\<and>\n    eX \\<noteq> ERR \\<and>\n    (\\<exists>s. igWls MOD s (check eX)) \\<longrightarrow>\n    (\\<exists>Y. eY = OK Y \\<and> igWls MOD (asSort ys) Y) \\<and>\n    (\\<exists>s X. eX = OK X \\<and> igWls MOD s X)", "by fastforce"], ["", "lemma eSubstAbs_nchotomy:\n\"(\\<exists> Y. eY = OK Y \\<and> igWls MOD (asSort ys) Y) \\<and>\n (\\<exists> us s A. eA = OK A \\<and> igWlsAbs MOD (us,s) A)\n \\<or>\n (eSubstAbs MOD ys eY y eA = ERR)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>Y. eY = OK Y \\<and> igWls MOD (asSort ys) Y) \\<and>\n    (\\<exists>us s A. eA = OK A \\<and> igWlsAbs MOD (us, s) A) \\<or>\n    eSubstAbs MOD ys eY y eA = ERR", "unfolding errMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>Y. eY = OK Y \\<and> igWls MOD (asSort ys) Y) \\<and>\n    (\\<exists>us s A. eA = OK A \\<and> igWlsAbs MOD (us, s) A) \\<or>\n    igSubstAbs\n     \\<lparr>igWls =\n               \\<lambda>s eX.\n                  case eX of ERR \\<Rightarrow> False\n                  | OK X \\<Rightarrow> igWls MOD s X,\n        igWlsAbs =\n          \\<lambda>(us, s) eA.\n             case eA of ERR \\<Rightarrow> False\n             | OK A \\<Rightarrow> igWlsAbs MOD (us, s) A,\n        igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n        igAbs =\n          \\<lambda>xs x eX.\n             if eX \\<noteq> ERR \\<and>\n                (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n             then OK (igAbs MOD xs x (check eX)) else ERR,\n        igOp =\n          \\<lambda>delta einp ebinp.\n             if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                igWlsInp MOD delta (checkI einp) \\<and>\n                igWlsBinp MOD delta (checkI ebinp)\n             then OK (igOp MOD delta (checkI einp) (checkI ebinp)) else ERR,\n        igFresh =\n          \\<lambda>ys y eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then igFresh MOD ys y (check eX) else True,\n        igFreshAbs =\n          \\<lambda>ys y eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then igFreshAbs MOD ys y (check eA) else True,\n        igSwap =\n          \\<lambda>zs z1 z2 eX.\n             if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 eA.\n             if eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n        igSubst =\n          \\<lambda>ys eY y eX.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n             then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n        igSubstAbs =\n          \\<lambda>ys eY y eA.\n             if eY \\<noteq> ERR \\<and>\n                igWls MOD (asSort ys) (check eY) \\<and>\n                eA \\<noteq> ERR \\<and>\n                (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n             then OK (igSubstAbs MOD ys (check eY) y (check eA))\n             else ERR\\<rparr>\n     ys eY y eA =\n    ERR", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eY \\<noteq> ERR \\<and>\n    igWls MOD (asSort ys) (check eY) \\<and>\n    eA \\<noteq> ERR \\<and>\n    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA)) \\<longrightarrow>\n    (\\<exists>Y. eY = OK Y \\<and> igWls MOD (asSort ys) Y) \\<and>\n    (\\<exists>us s A. eA = OK A \\<and> igWlsAbs MOD (us, s) A)", "using OK_check"], ["proof (prove)\nusing this:\n  ?eX \\<noteq> ERR \\<Longrightarrow> OK (check ?eX) = ?eX\n\ngoal (1 subgoal):\n 1. eY \\<noteq> ERR \\<and>\n    igWls MOD (asSort ys) (check eY) \\<and>\n    eA \\<noteq> ERR \\<and>\n    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA)) \\<longrightarrow>\n    (\\<exists>Y. eY = OK Y \\<and> igWls MOD (asSort ys) Y) \\<and>\n    (\\<exists>us s A. eA = OK A \\<and> igWlsAbs MOD (us, s) A)", "by fastforce"], ["", "subsubsection \\<open>Inversion rules\\<close>"], ["", "lemma eWls_invert:\nassumes \"eWls MOD s eX\"\nshows \"\\<exists> X. eX = OK X \\<and> igWls MOD s X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X. eX = OK X \\<and> igWls MOD s X", "using assms eWls_nchotomy"], ["proof (prove)\nusing this:\n  eWls MOD s eX\n  (\\<exists>X. ?eX = OK X \\<and> igWls ?MOD ?s X) \\<or>\n  \\<not> eWls ?MOD ?s ?eX\n\ngoal (1 subgoal):\n 1. \\<exists>X. eX = OK X \\<and> igWls MOD s X", "by blast"], ["", "lemma eWlsAbs_invert:\nassumes \"eWlsAbs MOD (us,s) eA\"\nshows \"\\<exists> A. eA = OK A \\<and> igWlsAbs MOD (us,s) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A. eA = OK A \\<and> igWlsAbs MOD (us, s) A", "using assms eWlsAbs_nchotomy"], ["proof (prove)\nusing this:\n  eWlsAbs MOD (us, s) eA\n  (\\<exists>A. ?eA = OK A \\<and> igWlsAbs ?MOD (?us, ?s) A) \\<or>\n  \\<not> eWlsAbs ?MOD (?us, ?s) ?eA\n\ngoal (1 subgoal):\n 1. \\<exists>A. eA = OK A \\<and> igWlsAbs MOD (us, s) A", "by blast"], ["", "lemma eWlsInp_invert:\nassumes \"eWlsInp MOD delta einp\"\nshows \"\\<exists> inp. igWlsInp MOD delta inp \\<and> einp = OKI inp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>inp. igWlsInp MOD delta inp \\<and> einp = OKI inp", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta ?inp \\<and> einp = OKI ?inp", "let ?inp = \"checkI einp\""], ["proof (state)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta ?inp \\<and> einp = OKI ?inp", "have \"wlsOpS delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsOpS delta", "using assms"], ["proof (prove)\nusing this:\n  eWlsInp MOD delta einp\n\ngoal (1 subgoal):\n 1. wlsOpS delta", "unfolding igWlsInp_def"], ["proof (prove)\nusing this:\n  wlsOpS delta \\<and>\n  sameDom (arOf delta) einp \\<and> liftAll2 (eWls MOD) (arOf delta) einp\n\ngoal (1 subgoal):\n 1. wlsOpS delta", "by simp"], ["proof (state)\nthis:\n  wlsOpS delta\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta ?inp \\<and> einp = OKI ?inp", "moreover"], ["proof (state)\nthis:\n  wlsOpS delta\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta ?inp \\<and> einp = OKI ?inp", "have \"sameDom (arOf delta) ?inp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sameDom (arOf delta) (checkI einp)", "using assms"], ["proof (prove)\nusing this:\n  eWlsInp MOD delta einp\n\ngoal (1 subgoal):\n 1. sameDom (arOf delta) (checkI einp)", "unfolding igWlsInp_def  checkI_def"], ["proof (prove)\nusing this:\n  wlsOpS delta \\<and>\n  sameDom (arOf delta) einp \\<and> liftAll2 (eWls MOD) (arOf delta) einp\n\ngoal (1 subgoal):\n 1. sameDom (arOf delta) (lift check einp)", "by simp"], ["proof (state)\nthis:\n  sameDom (arOf delta) (checkI einp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta ?inp \\<and> einp = OKI ?inp", "moreover"], ["proof (state)\nthis:\n  sameDom (arOf delta) (checkI einp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta ?inp \\<and> einp = OKI ?inp", "have \"liftAll2 (igWls MOD) (arOf delta) ?inp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftAll2 (igWls MOD) (arOf delta) (checkI einp)", "using assms eWls_invert"], ["proof (prove)\nusing this:\n  eWlsInp MOD delta einp\n  eWls ?MOD ?s ?eX \\<Longrightarrow>\n  \\<exists>X. ?eX = OK X \\<and> igWls ?MOD ?s X\n\ngoal (1 subgoal):\n 1. liftAll2 (igWls MOD) (arOf delta) (checkI einp)", "by (fastforce simp: igWlsInp_def checkI_def liftAll2_def lift_def sameDom_def \n  split: option.splits)"], ["proof (state)\nthis:\n  liftAll2 (igWls MOD) (arOf delta) (checkI einp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta ?inp \\<and> einp = OKI ?inp", "ultimately"], ["proof (chain)\npicking this:\n  wlsOpS delta\n  sameDom (arOf delta) (checkI einp)\n  liftAll2 (igWls MOD) (arOf delta) (checkI einp)", "have \"igWlsInp MOD delta ?inp\""], ["proof (prove)\nusing this:\n  wlsOpS delta\n  sameDom (arOf delta) (checkI einp)\n  liftAll2 (igWls MOD) (arOf delta) (checkI einp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (checkI einp)", "unfolding igWlsInp_def"], ["proof (prove)\nusing this:\n  wlsOpS delta\n  sameDom (arOf delta) (checkI einp)\n  liftAll2 (igWls MOD) (arOf delta) (checkI einp)\n\ngoal (1 subgoal):\n 1. wlsOpS delta \\<and>\n    sameDom (arOf delta) (checkI einp) \\<and>\n    liftAll2 (igWls MOD) (arOf delta) (checkI einp)", "by simp"], ["proof (state)\nthis:\n  igWlsInp MOD delta (checkI einp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta ?inp \\<and> einp = OKI ?inp", "moreover"], ["proof (state)\nthis:\n  igWlsInp MOD delta (checkI einp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta ?inp \\<and> einp = OKI ?inp", "{"], ["proof (state)\nthis:\n  igWlsInp MOD delta (checkI einp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta ?inp \\<and> einp = OKI ?inp", "have \"liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp", "using assms"], ["proof (prove)\nusing this:\n  eWlsInp MOD delta einp\n\ngoal (1 subgoal):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp", "using eWlsInp_simp2"], ["proof (prove)\nusing this:\n  eWlsInp MOD delta einp\n  \\<not> liftAll (\\<lambda>eX. eX \\<noteq> ERR) ?einp \\<Longrightarrow>\n  \\<not> eWlsInp ?MOD ?delta ?einp\n\ngoal (1 subgoal):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp", "by blast"], ["proof (state)\nthis:\n  liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta ?inp \\<and> einp = OKI ?inp", "hence \"einp = OKI ?inp\""], ["proof (prove)\nusing this:\n  liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp\n\ngoal (1 subgoal):\n 1. einp = OKI (checkI einp)", "by simp"], ["proof (state)\nthis:\n  einp = OKI (checkI einp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta ?inp \\<and> einp = OKI ?inp", "}"], ["proof (state)\nthis:\n  einp = OKI (checkI einp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta ?inp \\<and> einp = OKI ?inp", "ultimately"], ["proof (chain)\npicking this:\n  igWlsInp MOD delta (checkI einp)\n  einp = OKI (checkI einp)", "show \"igWlsInp MOD delta ?inp \\<and> einp = OKI ?inp\""], ["proof (prove)\nusing this:\n  igWlsInp MOD delta (checkI einp)\n  einp = OKI (checkI einp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (checkI einp) \\<and> einp = OKI (checkI einp)", "by simp"], ["proof (state)\nthis:\n  igWlsInp MOD delta (checkI einp) \\<and> einp = OKI (checkI einp)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eWlsBinp_invert:\nassumes \"eWlsBinp MOD delta ebinp\"\nshows \"\\<exists> binp. igWlsBinp MOD delta binp \\<and> ebinp = OKI binp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>binp. igWlsBinp MOD delta binp \\<and> ebinp = OKI binp", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta ?binp \\<and> ebinp = OKI ?binp", "let ?binp = \"checkI ebinp\""], ["proof (state)\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta ?binp \\<and> ebinp = OKI ?binp", "have \"wlsOpS delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsOpS delta", "using assms"], ["proof (prove)\nusing this:\n  eWlsBinp MOD delta ebinp\n\ngoal (1 subgoal):\n 1. wlsOpS delta", "unfolding igWlsBinp_def"], ["proof (prove)\nusing this:\n  wlsOpS delta \\<and>\n  sameDom (barOf delta) ebinp \\<and>\n  liftAll2 (eWlsAbs MOD) (barOf delta) ebinp\n\ngoal (1 subgoal):\n 1. wlsOpS delta", "by simp"], ["proof (state)\nthis:\n  wlsOpS delta\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta ?binp \\<and> ebinp = OKI ?binp", "moreover"], ["proof (state)\nthis:\n  wlsOpS delta\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta ?binp \\<and> ebinp = OKI ?binp", "have \"sameDom (barOf delta) ?binp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sameDom (barOf delta) (checkI ebinp)", "using assms"], ["proof (prove)\nusing this:\n  eWlsBinp MOD delta ebinp\n\ngoal (1 subgoal):\n 1. sameDom (barOf delta) (checkI ebinp)", "unfolding igWlsBinp_def  checkI_def"], ["proof (prove)\nusing this:\n  wlsOpS delta \\<and>\n  sameDom (barOf delta) ebinp \\<and>\n  liftAll2 (eWlsAbs MOD) (barOf delta) ebinp\n\ngoal (1 subgoal):\n 1. sameDom (barOf delta) (lift check ebinp)", "by simp"], ["proof (state)\nthis:\n  sameDom (barOf delta) (checkI ebinp)\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta ?binp \\<and> ebinp = OKI ?binp", "moreover"], ["proof (state)\nthis:\n  sameDom (barOf delta) (checkI ebinp)\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta ?binp \\<and> ebinp = OKI ?binp", "have \"liftAll2 (igWlsAbs MOD) (barOf delta) ?binp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftAll2 (igWlsAbs MOD) (barOf delta) (checkI ebinp)", "using assms eWlsAbs_invert"], ["proof (prove)\nusing this:\n  eWlsBinp MOD delta ebinp\n  eWlsAbs ?MOD (?us, ?s) ?eA \\<Longrightarrow>\n  \\<exists>A. ?eA = OK A \\<and> igWlsAbs ?MOD (?us, ?s) A\n\ngoal (1 subgoal):\n 1. liftAll2 (igWlsAbs MOD) (barOf delta) (checkI ebinp)", "by (fastforce simp: igWlsBinp_def checkI_def liftAll2_def lift_def sameDom_def \n  split: option.splits)"], ["proof (state)\nthis:\n  liftAll2 (igWlsAbs MOD) (barOf delta) (checkI ebinp)\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta ?binp \\<and> ebinp = OKI ?binp", "ultimately"], ["proof (chain)\npicking this:\n  wlsOpS delta\n  sameDom (barOf delta) (checkI ebinp)\n  liftAll2 (igWlsAbs MOD) (barOf delta) (checkI ebinp)", "have \"igWlsBinp MOD delta ?binp\""], ["proof (prove)\nusing this:\n  wlsOpS delta\n  sameDom (barOf delta) (checkI ebinp)\n  liftAll2 (igWlsAbs MOD) (barOf delta) (checkI ebinp)\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta (checkI ebinp)", "unfolding igWlsBinp_def"], ["proof (prove)\nusing this:\n  wlsOpS delta\n  sameDom (barOf delta) (checkI ebinp)\n  liftAll2 (igWlsAbs MOD) (barOf delta) (checkI ebinp)\n\ngoal (1 subgoal):\n 1. wlsOpS delta \\<and>\n    sameDom (barOf delta) (checkI ebinp) \\<and>\n    liftAll2 (igWlsAbs MOD) (barOf delta) (checkI ebinp)", "by simp"], ["proof (state)\nthis:\n  igWlsBinp MOD delta (checkI ebinp)\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta ?binp \\<and> ebinp = OKI ?binp", "moreover"], ["proof (state)\nthis:\n  igWlsBinp MOD delta (checkI ebinp)\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta ?binp \\<and> ebinp = OKI ?binp", "{"], ["proof (state)\nthis:\n  igWlsBinp MOD delta (checkI ebinp)\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta ?binp \\<and> ebinp = OKI ?binp", "have \"liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp", "using assms"], ["proof (prove)\nusing this:\n  eWlsBinp MOD delta ebinp\n\ngoal (1 subgoal):\n 1. liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp", "using eWlsBinp_simp2"], ["proof (prove)\nusing this:\n  eWlsBinp MOD delta ebinp\n  \\<not> liftAll (\\<lambda>eA. eA \\<noteq> ERR) ?ebinp \\<Longrightarrow>\n  \\<not> eWlsBinp ?MOD ?delta ?ebinp\n\ngoal (1 subgoal):\n 1. liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp", "by blast"], ["proof (state)\nthis:\n  liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta ?binp \\<and> ebinp = OKI ?binp", "hence \"ebinp = OKI ?binp\""], ["proof (prove)\nusing this:\n  liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n\ngoal (1 subgoal):\n 1. ebinp = OKI (checkI ebinp)", "by simp"], ["proof (state)\nthis:\n  ebinp = OKI (checkI ebinp)\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta ?binp \\<and> ebinp = OKI ?binp", "}"], ["proof (state)\nthis:\n  ebinp = OKI (checkI ebinp)\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta ?binp \\<and> ebinp = OKI ?binp", "ultimately"], ["proof (chain)\npicking this:\n  igWlsBinp MOD delta (checkI ebinp)\n  ebinp = OKI (checkI ebinp)", "show \"igWlsBinp MOD delta ?binp \\<and> ebinp = OKI ?binp\""], ["proof (prove)\nusing this:\n  igWlsBinp MOD delta (checkI ebinp)\n  ebinp = OKI (checkI ebinp)\n\ngoal (1 subgoal):\n 1. igWlsBinp MOD delta (checkI ebinp) \\<and> ebinp = OKI (checkI ebinp)", "by simp"], ["proof (state)\nthis:\n  igWlsBinp MOD delta (checkI ebinp) \\<and> ebinp = OKI (checkI ebinp)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eAbs_invert:\nassumes \"eAbs MOD xs x eX = OK A\"\nshows \"\\<exists> s X. eX = OK X \\<and> isInBar (xs,s) \\<and> A = igAbs MOD xs x X \\<and> igWls MOD s X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and>\n       isInBar (xs, s) \\<and> A = igAbs MOD xs x X \\<and> igWls MOD s X", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and>\n       isInBar (xs, s) \\<and> A = igAbs MOD xs x X \\<and> igWls MOD s X", "have 1: \"eAbs MOD xs x eX \\<noteq> ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eAbs MOD xs x eX \\<noteq> ERR", "using assms"], ["proof (prove)\nusing this:\n  eAbs MOD xs x eX = OK A\n\ngoal (1 subgoal):\n 1. eAbs MOD xs x eX \\<noteq> ERR", "by auto"], ["proof (state)\nthis:\n  eAbs MOD xs x eX \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and>\n       isInBar (xs, s) \\<and> A = igAbs MOD xs x X \\<and> igWls MOD s X", "then"], ["proof (chain)\npicking this:\n  eAbs MOD xs x eX \\<noteq> ERR", "obtain s X where *: \"eX = OK X\"\n  and **: \"isInBar (xs,s)\" and ***: \"igWls MOD s X\""], ["proof (prove)\nusing this:\n  eAbs MOD xs x eX \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. (\\<And>X s.\n        \\<lbrakk>eX = OK X; isInBar (xs, s); igWls MOD s X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eAbs_nchotomy[of eX]"], ["proof (prove)\nusing this:\n  eAbs MOD xs x eX \\<noteq> ERR\n  (\\<exists>s X.\n      eX = OK X \\<and> isInBar (?xs, s) \\<and> igWls ?MOD s X) \\<or>\n  eAbs ?MOD ?xs ?x eX = ERR\n\ngoal (1 subgoal):\n 1. (\\<And>X s.\n        \\<lbrakk>eX = OK X; isInBar (xs, s); igWls MOD s X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  eX = OK X\n  isInBar (xs, s)\n  igWls MOD s X\n\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and>\n       isInBar (xs, s) \\<and> A = igAbs MOD xs x X \\<and> igWls MOD s X", "hence \"eAbs MOD xs x eX = OK (igAbs MOD xs x X)\""], ["proof (prove)\nusing this:\n  eX = OK X\n  isInBar (xs, s)\n  igWls MOD s X\n\ngoal (1 subgoal):\n 1. eAbs MOD xs x eX = OK (igAbs MOD xs x X)", "by simp"], ["proof (state)\nthis:\n  eAbs MOD xs x eX = OK (igAbs MOD xs x X)\n\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and>\n       isInBar (xs, s) \\<and> A = igAbs MOD xs x X \\<and> igWls MOD s X", "thus ?thesis"], ["proof (prove)\nusing this:\n  eAbs MOD xs x eX = OK (igAbs MOD xs x X)\n\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and>\n       isInBar (xs, s) \\<and> A = igAbs MOD xs x X \\<and> igWls MOD s X", "using assms * ** ***"], ["proof (prove)\nusing this:\n  eAbs MOD xs x eX = OK (igAbs MOD xs x X)\n  eAbs MOD xs x eX = OK A\n  eX = OK X\n  isInBar (xs, s)\n  igWls MOD s X\n\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and>\n       isInBar (xs, s) \\<and> A = igAbs MOD xs x X \\<and> igWls MOD s X", "by auto"], ["proof (state)\nthis:\n  \\<exists>s X.\n     eX = OK X \\<and>\n     isInBar (xs, s) \\<and> A = igAbs MOD xs x X \\<and> igWls MOD s X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eOp_invert:\nassumes \"eOp MOD delta einp ebinp = OK X\"\nshows\n\"\\<exists> inp binp. einp = OKI inp \\<and> ebinp = OKI binp \\<and>\n             X = igOp MOD delta inp binp \\<and>\n             igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>inp binp.\n       einp = OKI inp \\<and>\n       ebinp = OKI binp \\<and>\n       X = igOp MOD delta inp binp \\<and>\n       igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>inp binp.\n       einp = OKI inp \\<and>\n       ebinp = OKI binp \\<and>\n       X = igOp MOD delta inp binp \\<and>\n       igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp", "have \"eOp MOD delta einp ebinp \\<noteq> ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eOp MOD delta einp ebinp \\<noteq> ERR", "using assms"], ["proof (prove)\nusing this:\n  eOp MOD delta einp ebinp = OK X\n\ngoal (1 subgoal):\n 1. eOp MOD delta einp ebinp \\<noteq> ERR", "by auto"], ["proof (state)\nthis:\n  eOp MOD delta einp ebinp \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. \\<exists>inp binp.\n       einp = OKI inp \\<and>\n       ebinp = OKI binp \\<and>\n       X = igOp MOD delta inp binp \\<and>\n       igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp", "then"], ["proof (chain)\npicking this:\n  eOp MOD delta einp ebinp \\<noteq> ERR", "obtain inp binp where *: \"einp = OKI inp\"   \"ebinp = OKI binp\"\n  \"igWlsInp MOD delta inp\"   \"igWlsBinp MOD delta binp\""], ["proof (prove)\nusing this:\n  eOp MOD delta einp ebinp \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. (\\<And>inp binp.\n        \\<lbrakk>einp = OKI inp; ebinp = OKI binp; igWlsInp MOD delta inp;\n         igWlsBinp MOD delta binp\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eOp_nchotomy"], ["proof (prove)\nusing this:\n  eOp MOD delta einp ebinp \\<noteq> ERR\n  (\\<exists>inp binp.\n      ?einp = OKI inp \\<and>\n      igWlsInp ?MOD ?delta inp \\<and>\n      ?ebinp = OKI binp \\<and> igWlsBinp ?MOD ?delta binp) \\<or>\n  eOp ?MOD ?delta ?einp ?ebinp = ERR\n\ngoal (1 subgoal):\n 1. (\\<And>inp binp.\n        \\<lbrakk>einp = OKI inp; ebinp = OKI binp; igWlsInp MOD delta inp;\n         igWlsBinp MOD delta binp\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  einp = OKI inp\n  ebinp = OKI binp\n  igWlsInp MOD delta inp\n  igWlsBinp MOD delta binp\n\ngoal (1 subgoal):\n 1. \\<exists>inp binp.\n       einp = OKI inp \\<and>\n       ebinp = OKI binp \\<and>\n       X = igOp MOD delta inp binp \\<and>\n       igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp", "hence \"eOp MOD delta einp ebinp = OK (igOp MOD delta inp binp)\""], ["proof (prove)\nusing this:\n  einp = OKI inp\n  ebinp = OKI binp\n  igWlsInp MOD delta inp\n  igWlsBinp MOD delta binp\n\ngoal (1 subgoal):\n 1. eOp MOD delta einp ebinp = OK (igOp MOD delta inp binp)", "by simp"], ["proof (state)\nthis:\n  eOp MOD delta einp ebinp = OK (igOp MOD delta inp binp)\n\ngoal (1 subgoal):\n 1. \\<exists>inp binp.\n       einp = OKI inp \\<and>\n       ebinp = OKI binp \\<and>\n       X = igOp MOD delta inp binp \\<and>\n       igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp", "thus ?thesis"], ["proof (prove)\nusing this:\n  eOp MOD delta einp ebinp = OK (igOp MOD delta inp binp)\n\ngoal (1 subgoal):\n 1. \\<exists>inp binp.\n       einp = OKI inp \\<and>\n       ebinp = OKI binp \\<and>\n       X = igOp MOD delta inp binp \\<and>\n       igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp", "using assms *"], ["proof (prove)\nusing this:\n  eOp MOD delta einp ebinp = OK (igOp MOD delta inp binp)\n  eOp MOD delta einp ebinp = OK X\n  einp = OKI inp\n  ebinp = OKI binp\n  igWlsInp MOD delta inp\n  igWlsBinp MOD delta binp\n\ngoal (1 subgoal):\n 1. \\<exists>inp binp.\n       einp = OKI inp \\<and>\n       ebinp = OKI binp \\<and>\n       X = igOp MOD delta inp binp \\<and>\n       igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp", "by auto"], ["proof (state)\nthis:\n  \\<exists>inp binp.\n     einp = OKI inp \\<and>\n     ebinp = OKI binp \\<and>\n     X = igOp MOD delta inp binp \\<and>\n     igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eFresh_invert:\nassumes \"\\<not> eFresh MOD ys y eX\"\nshows \"\\<exists> s X. eX = OK X \\<and> \\<not> igFresh MOD ys y X \\<and> igWls MOD s X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and> \\<not> igFresh MOD ys y X \\<and> igWls MOD s X", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and> \\<not> igFresh MOD ys y X \\<and> igWls MOD s X", "obtain s X where *: \"eX = OK X\" and **: \"igWls MOD s X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X s.\n        \\<lbrakk>eX = OK X; igWls MOD s X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms eFresh_nchotomy[of eX]"], ["proof (prove)\nusing this:\n  \\<not> eFresh MOD ys y eX\n  (\\<exists>s X. eX = OK X \\<and> igWls ?MOD s X) \\<or>\n  eFresh ?MOD ?ys ?y eX\n\ngoal (1 subgoal):\n 1. (\\<And>X s.\n        \\<lbrakk>eX = OK X; igWls MOD s X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  eX = OK X\n  igWls MOD s X\n\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and> \\<not> igFresh MOD ys y X \\<and> igWls MOD s X", "hence \"eFresh MOD ys y eX = igFresh MOD ys y X\""], ["proof (prove)\nusing this:\n  eX = OK X\n  igWls MOD s X\n\ngoal (1 subgoal):\n 1. eFresh MOD ys y eX = igFresh MOD ys y X", "by simp"], ["proof (state)\nthis:\n  eFresh MOD ys y eX = igFresh MOD ys y X\n\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and> \\<not> igFresh MOD ys y X \\<and> igWls MOD s X", "thus ?thesis"], ["proof (prove)\nusing this:\n  eFresh MOD ys y eX = igFresh MOD ys y X\n\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and> \\<not> igFresh MOD ys y X \\<and> igWls MOD s X", "using assms * **"], ["proof (prove)\nusing this:\n  eFresh MOD ys y eX = igFresh MOD ys y X\n  \\<not> eFresh MOD ys y eX\n  eX = OK X\n  igWls MOD s X\n\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and> \\<not> igFresh MOD ys y X \\<and> igWls MOD s X", "by auto"], ["proof (state)\nthis:\n  \\<exists>s X.\n     eX = OK X \\<and> \\<not> igFresh MOD ys y X \\<and> igWls MOD s X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eFreshAbs_invert:\nassumes \"\\<not> eFreshAbs MOD ys y eA\"\nshows \"\\<exists> us s A. eA = OK A \\<and> \\<not> igFreshAbs MOD ys y A \\<and> igWlsAbs MOD (us,s) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>us s A.\n       eA = OK A \\<and>\n       \\<not> igFreshAbs MOD ys y A \\<and> igWlsAbs MOD (us, s) A", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>us s A.\n       eA = OK A \\<and>\n       \\<not> igFreshAbs MOD ys y A \\<and> igWlsAbs MOD (us, s) A", "obtain us s A where *: \"eA = OK A\" and **: \"igWlsAbs MOD (us,s) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A us s.\n        \\<lbrakk>eA = OK A; igWlsAbs MOD (us, s) A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms eFreshAbs_nchotomy[of eA]"], ["proof (prove)\nusing this:\n  \\<not> eFreshAbs MOD ys y eA\n  (\\<exists>us s A. eA = OK A \\<and> igWlsAbs ?MOD (us, s) A) \\<or>\n  eFreshAbs ?MOD ?ys ?y eA\n\ngoal (1 subgoal):\n 1. (\\<And>A us s.\n        \\<lbrakk>eA = OK A; igWlsAbs MOD (us, s) A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  eA = OK A\n  igWlsAbs MOD (us, s) A\n\ngoal (1 subgoal):\n 1. \\<exists>us s A.\n       eA = OK A \\<and>\n       \\<not> igFreshAbs MOD ys y A \\<and> igWlsAbs MOD (us, s) A", "hence \"eFreshAbs MOD ys y eA = igFreshAbs MOD ys y A\""], ["proof (prove)\nusing this:\n  eA = OK A\n  igWlsAbs MOD (us, s) A\n\ngoal (1 subgoal):\n 1. eFreshAbs MOD ys y eA = igFreshAbs MOD ys y A", "by simp"], ["proof (state)\nthis:\n  eFreshAbs MOD ys y eA = igFreshAbs MOD ys y A\n\ngoal (1 subgoal):\n 1. \\<exists>us s A.\n       eA = OK A \\<and>\n       \\<not> igFreshAbs MOD ys y A \\<and> igWlsAbs MOD (us, s) A", "thus ?thesis"], ["proof (prove)\nusing this:\n  eFreshAbs MOD ys y eA = igFreshAbs MOD ys y A\n\ngoal (1 subgoal):\n 1. \\<exists>us s A.\n       eA = OK A \\<and>\n       \\<not> igFreshAbs MOD ys y A \\<and> igWlsAbs MOD (us, s) A", "using assms * **"], ["proof (prove)\nusing this:\n  eFreshAbs MOD ys y eA = igFreshAbs MOD ys y A\n  \\<not> eFreshAbs MOD ys y eA\n  eA = OK A\n  igWlsAbs MOD (us, s) A\n\ngoal (1 subgoal):\n 1. \\<exists>us s A.\n       eA = OK A \\<and>\n       \\<not> igFreshAbs MOD ys y A \\<and> igWlsAbs MOD (us, s) A", "by auto"], ["proof (state)\nthis:\n  \\<exists>us s A.\n     eA = OK A \\<and>\n     \\<not> igFreshAbs MOD ys y A \\<and> igWlsAbs MOD (us, s) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eSwap_invert:\nassumes \"eSwap MOD zs z1 z2 eX = OK Y\"\nshows \"\\<exists> s X. eX = OK X \\<and> Y = igSwap MOD zs z1 z2 X \\<and> igWls MOD s X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and> Y = igSwap MOD zs z1 z2 X \\<and> igWls MOD s X", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and> Y = igSwap MOD zs z1 z2 X \\<and> igWls MOD s X", "have 1: \"eSwap MOD zs z1 z2 eX \\<noteq> ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSwap MOD zs z1 z2 eX \\<noteq> ERR", "using assms"], ["proof (prove)\nusing this:\n  eSwap MOD zs z1 z2 eX = OK Y\n\ngoal (1 subgoal):\n 1. eSwap MOD zs z1 z2 eX \\<noteq> ERR", "by auto"], ["proof (state)\nthis:\n  eSwap MOD zs z1 z2 eX \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and> Y = igSwap MOD zs z1 z2 X \\<and> igWls MOD s X", "then"], ["proof (chain)\npicking this:\n  eSwap MOD zs z1 z2 eX \\<noteq> ERR", "obtain s X where *: \"eX = OK X\" and **: \"igWls MOD s X\""], ["proof (prove)\nusing this:\n  eSwap MOD zs z1 z2 eX \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. (\\<And>X s.\n        \\<lbrakk>eX = OK X; igWls MOD s X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eSwap_nchotomy[of eX]"], ["proof (prove)\nusing this:\n  eSwap MOD zs z1 z2 eX \\<noteq> ERR\n  (\\<exists>s X. eX = OK X \\<and> igWls ?MOD s X) \\<or>\n  eSwap ?MOD ?zs ?z1.0 ?z2.0 eX = ERR\n\ngoal (1 subgoal):\n 1. (\\<And>X s.\n        \\<lbrakk>eX = OK X; igWls MOD s X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  eX = OK X\n  igWls MOD s X\n\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and> Y = igSwap MOD zs z1 z2 X \\<and> igWls MOD s X", "hence \"eSwap MOD zs z1 z2 eX = OK (igSwap MOD zs z1 z2 X)\""], ["proof (prove)\nusing this:\n  eX = OK X\n  igWls MOD s X\n\ngoal (1 subgoal):\n 1. eSwap MOD zs z1 z2 eX = OK (igSwap MOD zs z1 z2 X)", "by simp"], ["proof (state)\nthis:\n  eSwap MOD zs z1 z2 eX = OK (igSwap MOD zs z1 z2 X)\n\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and> Y = igSwap MOD zs z1 z2 X \\<and> igWls MOD s X", "thus ?thesis"], ["proof (prove)\nusing this:\n  eSwap MOD zs z1 z2 eX = OK (igSwap MOD zs z1 z2 X)\n\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and> Y = igSwap MOD zs z1 z2 X \\<and> igWls MOD s X", "using assms * **"], ["proof (prove)\nusing this:\n  eSwap MOD zs z1 z2 eX = OK (igSwap MOD zs z1 z2 X)\n  eSwap MOD zs z1 z2 eX = OK Y\n  eX = OK X\n  igWls MOD s X\n\ngoal (1 subgoal):\n 1. \\<exists>s X.\n       eX = OK X \\<and> Y = igSwap MOD zs z1 z2 X \\<and> igWls MOD s X", "by auto"], ["proof (state)\nthis:\n  \\<exists>s X.\n     eX = OK X \\<and> Y = igSwap MOD zs z1 z2 X \\<and> igWls MOD s X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eSwapAbs_invert:\nassumes \"eSwapAbs MOD zs z1 z2 eA = OK B\"\nshows \"\\<exists> us s A. eA = OK A \\<and> B = igSwapAbs MOD zs z1 z2 A \\<and> igWlsAbs MOD (us,s) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>us s A.\n       eA = OK A \\<and>\n       B = igSwapAbs MOD zs z1 z2 A \\<and> igWlsAbs MOD (us, s) A", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>us s A.\n       eA = OK A \\<and>\n       B = igSwapAbs MOD zs z1 z2 A \\<and> igWlsAbs MOD (us, s) A", "have 1: \"eSwapAbs MOD zs z1 z2 eA \\<noteq> ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSwapAbs MOD zs z1 z2 eA \\<noteq> ERR", "using assms"], ["proof (prove)\nusing this:\n  eSwapAbs MOD zs z1 z2 eA = OK B\n\ngoal (1 subgoal):\n 1. eSwapAbs MOD zs z1 z2 eA \\<noteq> ERR", "by auto"], ["proof (state)\nthis:\n  eSwapAbs MOD zs z1 z2 eA \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. \\<exists>us s A.\n       eA = OK A \\<and>\n       B = igSwapAbs MOD zs z1 z2 A \\<and> igWlsAbs MOD (us, s) A", "then"], ["proof (chain)\npicking this:\n  eSwapAbs MOD zs z1 z2 eA \\<noteq> ERR", "obtain us s A where *: \"eA = OK A\" and **: \"igWlsAbs MOD (us,s) A\""], ["proof (prove)\nusing this:\n  eSwapAbs MOD zs z1 z2 eA \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. (\\<And>A us s.\n        \\<lbrakk>eA = OK A; igWlsAbs MOD (us, s) A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eSwapAbs_nchotomy[of eA]"], ["proof (prove)\nusing this:\n  eSwapAbs MOD zs z1 z2 eA \\<noteq> ERR\n  (\\<exists>us s A. eA = OK A \\<and> igWlsAbs ?MOD (us, s) A) \\<or>\n  eSwapAbs ?MOD ?zs ?z1.0 ?z2.0 eA = ERR\n\ngoal (1 subgoal):\n 1. (\\<And>A us s.\n        \\<lbrakk>eA = OK A; igWlsAbs MOD (us, s) A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  eA = OK A\n  igWlsAbs MOD (us, s) A\n\ngoal (1 subgoal):\n 1. \\<exists>us s A.\n       eA = OK A \\<and>\n       B = igSwapAbs MOD zs z1 z2 A \\<and> igWlsAbs MOD (us, s) A", "hence \"eSwapAbs MOD zs z1 z2 eA = OK (igSwapAbs MOD zs z1 z2 A)\""], ["proof (prove)\nusing this:\n  eA = OK A\n  igWlsAbs MOD (us, s) A\n\ngoal (1 subgoal):\n 1. eSwapAbs MOD zs z1 z2 eA = OK (igSwapAbs MOD zs z1 z2 A)", "by simp"], ["proof (state)\nthis:\n  eSwapAbs MOD zs z1 z2 eA = OK (igSwapAbs MOD zs z1 z2 A)\n\ngoal (1 subgoal):\n 1. \\<exists>us s A.\n       eA = OK A \\<and>\n       B = igSwapAbs MOD zs z1 z2 A \\<and> igWlsAbs MOD (us, s) A", "thus ?thesis"], ["proof (prove)\nusing this:\n  eSwapAbs MOD zs z1 z2 eA = OK (igSwapAbs MOD zs z1 z2 A)\n\ngoal (1 subgoal):\n 1. \\<exists>us s A.\n       eA = OK A \\<and>\n       B = igSwapAbs MOD zs z1 z2 A \\<and> igWlsAbs MOD (us, s) A", "using assms * **"], ["proof (prove)\nusing this:\n  eSwapAbs MOD zs z1 z2 eA = OK (igSwapAbs MOD zs z1 z2 A)\n  eSwapAbs MOD zs z1 z2 eA = OK B\n  eA = OK A\n  igWlsAbs MOD (us, s) A\n\ngoal (1 subgoal):\n 1. \\<exists>us s A.\n       eA = OK A \\<and>\n       B = igSwapAbs MOD zs z1 z2 A \\<and> igWlsAbs MOD (us, s) A", "by auto"], ["proof (state)\nthis:\n  \\<exists>us s A.\n     eA = OK A \\<and>\n     B = igSwapAbs MOD zs z1 z2 A \\<and> igWlsAbs MOD (us, s) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eSubst_invert:\nassumes \"eSubst MOD ys eY y eX = OK Z\"\nshows\n\"\\<exists> s X Y. eY = OK Y \\<and> eX = OK X \\<and> igWls MOD s X \\<and> igWls MOD (asSort ys) Y \\<and>\n          Z = igSubst MOD ys Y y X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s X Y.\n       eY = OK Y \\<and>\n       eX = OK X \\<and>\n       igWls MOD s X \\<and>\n       igWls MOD (asSort ys) Y \\<and> Z = igSubst MOD ys Y y X", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s X Y.\n       eY = OK Y \\<and>\n       eX = OK X \\<and>\n       igWls MOD s X \\<and>\n       igWls MOD (asSort ys) Y \\<and> Z = igSubst MOD ys Y y X", "have 1: \"eSubst MOD ys eY y eX \\<noteq> ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSubst MOD ys eY y eX \\<noteq> ERR", "using assms"], ["proof (prove)\nusing this:\n  eSubst MOD ys eY y eX = OK Z\n\ngoal (1 subgoal):\n 1. eSubst MOD ys eY y eX \\<noteq> ERR", "by auto"], ["proof (state)\nthis:\n  eSubst MOD ys eY y eX \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. \\<exists>s X Y.\n       eY = OK Y \\<and>\n       eX = OK X \\<and>\n       igWls MOD s X \\<and>\n       igWls MOD (asSort ys) Y \\<and> Z = igSubst MOD ys Y y X", "then"], ["proof (chain)\npicking this:\n  eSubst MOD ys eY y eX \\<noteq> ERR", "obtain s X Y where *: \"eX = OK X\"   \"eY = OK Y\"\n  \"igWls MOD s X\"  \"igWls MOD (asSort ys) Y\""], ["proof (prove)\nusing this:\n  eSubst MOD ys eY y eX \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. (\\<And>X Y s.\n        \\<lbrakk>eX = OK X; eY = OK Y; igWls MOD s X;\n         igWls MOD (asSort ys) Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eSubst_nchotomy[of eY _ _ eX]"], ["proof (prove)\nusing this:\n  eSubst MOD ys eY y eX \\<noteq> ERR\n  (\\<exists>Y. eY = OK Y \\<and> igWls ?MOD (asSort ?ys) Y) \\<and>\n  (\\<exists>s X. eX = OK X \\<and> igWls ?MOD s X) \\<or>\n  eSubst ?MOD ?ys eY ?y eX = ERR\n\ngoal (1 subgoal):\n 1. (\\<And>X Y s.\n        \\<lbrakk>eX = OK X; eY = OK Y; igWls MOD s X;\n         igWls MOD (asSort ys) Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  eX = OK X\n  eY = OK Y\n  igWls MOD s X\n  igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. \\<exists>s X Y.\n       eY = OK Y \\<and>\n       eX = OK X \\<and>\n       igWls MOD s X \\<and>\n       igWls MOD (asSort ys) Y \\<and> Z = igSubst MOD ys Y y X", "hence \"eSubst MOD ys eY y eX = OK (igSubst MOD ys Y y X)\""], ["proof (prove)\nusing this:\n  eX = OK X\n  eY = OK Y\n  igWls MOD s X\n  igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. eSubst MOD ys eY y eX = OK (igSubst MOD ys Y y X)", "by simp"], ["proof (state)\nthis:\n  eSubst MOD ys eY y eX = OK (igSubst MOD ys Y y X)\n\ngoal (1 subgoal):\n 1. \\<exists>s X Y.\n       eY = OK Y \\<and>\n       eX = OK X \\<and>\n       igWls MOD s X \\<and>\n       igWls MOD (asSort ys) Y \\<and> Z = igSubst MOD ys Y y X", "thus ?thesis"], ["proof (prove)\nusing this:\n  eSubst MOD ys eY y eX = OK (igSubst MOD ys Y y X)\n\ngoal (1 subgoal):\n 1. \\<exists>s X Y.\n       eY = OK Y \\<and>\n       eX = OK X \\<and>\n       igWls MOD s X \\<and>\n       igWls MOD (asSort ys) Y \\<and> Z = igSubst MOD ys Y y X", "using assms *"], ["proof (prove)\nusing this:\n  eSubst MOD ys eY y eX = OK (igSubst MOD ys Y y X)\n  eSubst MOD ys eY y eX = OK Z\n  eX = OK X\n  eY = OK Y\n  igWls MOD s X\n  igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. \\<exists>s X Y.\n       eY = OK Y \\<and>\n       eX = OK X \\<and>\n       igWls MOD s X \\<and>\n       igWls MOD (asSort ys) Y \\<and> Z = igSubst MOD ys Y y X", "by auto"], ["proof (state)\nthis:\n  \\<exists>s X Y.\n     eY = OK Y \\<and>\n     eX = OK X \\<and>\n     igWls MOD s X \\<and>\n     igWls MOD (asSort ys) Y \\<and> Z = igSubst MOD ys Y y X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eSubstAbs_invert:\nassumes \"eSubstAbs MOD ys eY y eA = OK Z\"\nshows\n\"\\<exists> us s A Y. eY = OK Y \\<and> eA = OK A \\<and> igWlsAbs MOD (us,s) A \\<and> igWls MOD (asSort ys) Y \\<and>\n             Z = igSubstAbs MOD ys Y y A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>us s A Y.\n       eY = OK Y \\<and>\n       eA = OK A \\<and>\n       igWlsAbs MOD (us, s) A \\<and>\n       igWls MOD (asSort ys) Y \\<and> Z = igSubstAbs MOD ys Y y A", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>us s A Y.\n       eY = OK Y \\<and>\n       eA = OK A \\<and>\n       igWlsAbs MOD (us, s) A \\<and>\n       igWls MOD (asSort ys) Y \\<and> Z = igSubstAbs MOD ys Y y A", "have 1: \"eSubstAbs MOD ys eY y eA \\<noteq> ERR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSubstAbs MOD ys eY y eA \\<noteq> ERR", "using assms"], ["proof (prove)\nusing this:\n  eSubstAbs MOD ys eY y eA = OK Z\n\ngoal (1 subgoal):\n 1. eSubstAbs MOD ys eY y eA \\<noteq> ERR", "by auto"], ["proof (state)\nthis:\n  eSubstAbs MOD ys eY y eA \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. \\<exists>us s A Y.\n       eY = OK Y \\<and>\n       eA = OK A \\<and>\n       igWlsAbs MOD (us, s) A \\<and>\n       igWls MOD (asSort ys) Y \\<and> Z = igSubstAbs MOD ys Y y A", "then"], ["proof (chain)\npicking this:\n  eSubstAbs MOD ys eY y eA \\<noteq> ERR", "obtain us s A Y where *: \"eA = OK A\"   \"eY = OK Y\"\n  \"igWlsAbs MOD (us,s) A\"  \"igWls MOD (asSort ys) Y\""], ["proof (prove)\nusing this:\n  eSubstAbs MOD ys eY y eA \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. (\\<And>A Y us s.\n        \\<lbrakk>eA = OK A; eY = OK Y; igWlsAbs MOD (us, s) A;\n         igWls MOD (asSort ys) Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eSubstAbs_nchotomy[of eY _ _ eA]"], ["proof (prove)\nusing this:\n  eSubstAbs MOD ys eY y eA \\<noteq> ERR\n  (\\<exists>Y. eY = OK Y \\<and> igWls ?MOD (asSort ?ys) Y) \\<and>\n  (\\<exists>us s A. eA = OK A \\<and> igWlsAbs ?MOD (us, s) A) \\<or>\n  eSubstAbs ?MOD ?ys eY ?y eA = ERR\n\ngoal (1 subgoal):\n 1. (\\<And>A Y us s.\n        \\<lbrakk>eA = OK A; eY = OK Y; igWlsAbs MOD (us, s) A;\n         igWls MOD (asSort ys) Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  eA = OK A\n  eY = OK Y\n  igWlsAbs MOD (us, s) A\n  igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. \\<exists>us s A Y.\n       eY = OK Y \\<and>\n       eA = OK A \\<and>\n       igWlsAbs MOD (us, s) A \\<and>\n       igWls MOD (asSort ys) Y \\<and> Z = igSubstAbs MOD ys Y y A", "hence \"eSubstAbs MOD ys eY y eA = OK (igSubstAbs MOD ys Y y A)\""], ["proof (prove)\nusing this:\n  eA = OK A\n  eY = OK Y\n  igWlsAbs MOD (us, s) A\n  igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. eSubstAbs MOD ys eY y eA = OK (igSubstAbs MOD ys Y y A)", "by simp"], ["proof (state)\nthis:\n  eSubstAbs MOD ys eY y eA = OK (igSubstAbs MOD ys Y y A)\n\ngoal (1 subgoal):\n 1. \\<exists>us s A Y.\n       eY = OK Y \\<and>\n       eA = OK A \\<and>\n       igWlsAbs MOD (us, s) A \\<and>\n       igWls MOD (asSort ys) Y \\<and> Z = igSubstAbs MOD ys Y y A", "thus ?thesis"], ["proof (prove)\nusing this:\n  eSubstAbs MOD ys eY y eA = OK (igSubstAbs MOD ys Y y A)\n\ngoal (1 subgoal):\n 1. \\<exists>us s A Y.\n       eY = OK Y \\<and>\n       eA = OK A \\<and>\n       igWlsAbs MOD (us, s) A \\<and>\n       igWls MOD (asSort ys) Y \\<and> Z = igSubstAbs MOD ys Y y A", "using assms *"], ["proof (prove)\nusing this:\n  eSubstAbs MOD ys eY y eA = OK (igSubstAbs MOD ys Y y A)\n  eSubstAbs MOD ys eY y eA = OK Z\n  eA = OK A\n  eY = OK Y\n  igWlsAbs MOD (us, s) A\n  igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. \\<exists>us s A Y.\n       eY = OK Y \\<and>\n       eA = OK A \\<and>\n       igWlsAbs MOD (us, s) A \\<and>\n       igWls MOD (asSort ys) Y \\<and> Z = igSubstAbs MOD ys Y y A", "by auto"], ["proof (state)\nthis:\n  \\<exists>us s A Y.\n     eY = OK Y \\<and>\n     eA = OK A \\<and>\n     igWlsAbs MOD (us, s) A \\<and>\n     igWls MOD (asSort ys) Y \\<and> Z = igSubstAbs MOD ys Y y A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>The error model is strongly well-sorted\nas a fresh-swap-subst and as a fresh-subst-swap model\\<close>"], ["", "text\\<open>That is, provided the original model is a well-sorted fresh-swap model.\\<close>"], ["", "text\\<open>The domains are disjoint:\\<close>"], ["", "lemma errMOD_igWlsDisj:\nassumes \"igWlsDisj MOD\"\nshows \"igWlsDisj (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsDisj (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igWlsDisj MOD\n\ngoal (1 subgoal):\n 1. igWlsDisj (errMOD MOD)", "unfolding errMOD_def igWlsDisj_def"], ["proof (prove)\nusing this:\n  \\<forall>s s' X.\n     igWls MOD s X \\<and> igWls MOD s' X \\<longrightarrow> s = s'\n\ngoal (1 subgoal):\n 1. \\<forall>s s' X.\n       igWls\n        \\<lparr>igWls = \\<lambda>s. case_withERR False (igWls MOD s),\n           igWlsAbs =\n             \\<lambda>(us, s). case_withERR False (igWlsAbs MOD (us, s)),\n           igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n           igAbs =\n             \\<lambda>xs x eX.\n                if eX \\<noteq> ERR \\<and>\n                   (\\<exists>s.\n                       isInBar (xs, s) \\<and> igWls MOD s (check eX))\n                then OK (igAbs MOD xs x (check eX)) else ERR,\n           igOp =\n             \\<lambda>delta einp ebinp.\n                if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                   liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                   igWlsInp MOD delta (checkI einp) \\<and>\n                   igWlsBinp MOD delta (checkI ebinp)\n                then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n                else ERR,\n           igFresh =\n             \\<lambda>ys y eX.\n                if eX \\<noteq> ERR \\<and>\n                   (\\<exists>s. igWls MOD s (check eX))\n                then igFresh MOD ys y (check eX) else True,\n           igFreshAbs =\n             \\<lambda>ys y eA.\n                if eA \\<noteq> ERR \\<and>\n                   (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                then igFreshAbs MOD ys y (check eA) else True,\n           igSwap =\n             \\<lambda>zs z1 z2 eX.\n                if eX \\<noteq> ERR \\<and>\n                   (\\<exists>s. igWls MOD s (check eX))\n                then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n           igSwapAbs =\n             \\<lambda>zs z1 z2 eA.\n                if eA \\<noteq> ERR \\<and>\n                   (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n           igSubst =\n             \\<lambda>ys eY y eX.\n                if eY \\<noteq> ERR \\<and>\n                   igWls MOD (asSort ys) (check eY) \\<and>\n                   eX \\<noteq> ERR \\<and>\n                   (\\<exists>s. igWls MOD s (check eX))\n                then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n           igSubstAbs =\n             \\<lambda>ys eY y eA.\n                if eY \\<noteq> ERR \\<and>\n                   igWls MOD (asSort ys) (check eY) \\<and>\n                   eA \\<noteq> ERR \\<and>\n                   (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                then OK (igSubstAbs MOD ys (check eY) y (check eA))\n                else ERR\\<rparr>\n        s X \\<and>\n       igWls\n        \\<lparr>igWls = \\<lambda>s. case_withERR False (igWls MOD s),\n           igWlsAbs =\n             \\<lambda>(us, s). case_withERR False (igWlsAbs MOD (us, s)),\n           igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n           igAbs =\n             \\<lambda>xs x eX.\n                if eX \\<noteq> ERR \\<and>\n                   (\\<exists>s.\n                       isInBar (xs, s) \\<and> igWls MOD s (check eX))\n                then OK (igAbs MOD xs x (check eX)) else ERR,\n           igOp =\n             \\<lambda>delta einp ebinp.\n                if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                   liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                   igWlsInp MOD delta (checkI einp) \\<and>\n                   igWlsBinp MOD delta (checkI ebinp)\n                then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n                else ERR,\n           igFresh =\n             \\<lambda>ys y eX.\n                if eX \\<noteq> ERR \\<and>\n                   (\\<exists>s. igWls MOD s (check eX))\n                then igFresh MOD ys y (check eX) else True,\n           igFreshAbs =\n             \\<lambda>ys y eA.\n                if eA \\<noteq> ERR \\<and>\n                   (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                then igFreshAbs MOD ys y (check eA) else True,\n           igSwap =\n             \\<lambda>zs z1 z2 eX.\n                if eX \\<noteq> ERR \\<and>\n                   (\\<exists>s. igWls MOD s (check eX))\n                then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n           igSwapAbs =\n             \\<lambda>zs z1 z2 eA.\n                if eA \\<noteq> ERR \\<and>\n                   (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n           igSubst =\n             \\<lambda>ys eY y eX.\n                if eY \\<noteq> ERR \\<and>\n                   igWls MOD (asSort ys) (check eY) \\<and>\n                   eX \\<noteq> ERR \\<and>\n                   (\\<exists>s. igWls MOD s (check eX))\n                then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n           igSubstAbs =\n             \\<lambda>ys eY y eA.\n                if eY \\<noteq> ERR \\<and>\n                   igWls MOD (asSort ys) (check eY) \\<and>\n                   eA \\<noteq> ERR \\<and>\n                   (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                then OK (igSubstAbs MOD ys (check eY) y (check eA))\n                else ERR\\<rparr>\n        s' X \\<longrightarrow>\n       s = s'", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' X.\n       \\<lbrakk>\\<forall>s s' X.\n                   igWls MOD s X \\<and> igWls MOD s' X \\<longrightarrow>\n                   s = s';\n        igWls\n         \\<lparr>igWls = \\<lambda>s. case_withERR False (igWls MOD s),\n            igWlsAbs =\n              \\<lambda>(us, s). case_withERR False (igWlsAbs MOD (us, s)),\n            igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n            igAbs =\n              \\<lambda>xs x eX.\n                 if eX \\<noteq> ERR \\<and>\n                    (\\<exists>s.\n                        isInBar (xs, s) \\<and> igWls MOD s (check eX))\n                 then OK (igAbs MOD xs x (check eX)) else ERR,\n            igOp =\n              \\<lambda>delta einp ebinp.\n                 if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                    liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                    igWlsInp MOD delta (checkI einp) \\<and>\n                    igWlsBinp MOD delta (checkI ebinp)\n                 then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n                 else ERR,\n            igFresh =\n              \\<lambda>ys y eX.\n                 if eX \\<noteq> ERR \\<and>\n                    (\\<exists>s. igWls MOD s (check eX))\n                 then igFresh MOD ys y (check eX) else True,\n            igFreshAbs =\n              \\<lambda>ys y eA.\n                 if eA \\<noteq> ERR \\<and>\n                    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                 then igFreshAbs MOD ys y (check eA) else True,\n            igSwap =\n              \\<lambda>zs z1 z2 eX.\n                 if eX \\<noteq> ERR \\<and>\n                    (\\<exists>s. igWls MOD s (check eX))\n                 then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n            igSwapAbs =\n              \\<lambda>zs z1 z2 eA.\n                 if eA \\<noteq> ERR \\<and>\n                    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                 then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n            igSubst =\n              \\<lambda>ys eY y eX.\n                 if eY \\<noteq> ERR \\<and>\n                    igWls MOD (asSort ys) (check eY) \\<and>\n                    eX \\<noteq> ERR \\<and>\n                    (\\<exists>s. igWls MOD s (check eX))\n                 then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n            igSubstAbs =\n              \\<lambda>ys eY y eA.\n                 if eY \\<noteq> ERR \\<and>\n                    igWls MOD (asSort ys) (check eY) \\<and>\n                    eA \\<noteq> ERR \\<and>\n                    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                 then OK (igSubstAbs MOD ys (check eY) y (check eA))\n                 else ERR\\<rparr>\n         s X;\n        igWls\n         \\<lparr>igWls = \\<lambda>s. case_withERR False (igWls MOD s),\n            igWlsAbs =\n              \\<lambda>(us, s). case_withERR False (igWlsAbs MOD (us, s)),\n            igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n            igAbs =\n              \\<lambda>xs x eX.\n                 if eX \\<noteq> ERR \\<and>\n                    (\\<exists>s.\n                        isInBar (xs, s) \\<and> igWls MOD s (check eX))\n                 then OK (igAbs MOD xs x (check eX)) else ERR,\n            igOp =\n              \\<lambda>delta einp ebinp.\n                 if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                    liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                    igWlsInp MOD delta (checkI einp) \\<and>\n                    igWlsBinp MOD delta (checkI ebinp)\n                 then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n                 else ERR,\n            igFresh =\n              \\<lambda>ys y eX.\n                 if eX \\<noteq> ERR \\<and>\n                    (\\<exists>s. igWls MOD s (check eX))\n                 then igFresh MOD ys y (check eX) else True,\n            igFreshAbs =\n              \\<lambda>ys y eA.\n                 if eA \\<noteq> ERR \\<and>\n                    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                 then igFreshAbs MOD ys y (check eA) else True,\n            igSwap =\n              \\<lambda>zs z1 z2 eX.\n                 if eX \\<noteq> ERR \\<and>\n                    (\\<exists>s. igWls MOD s (check eX))\n                 then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n            igSwapAbs =\n              \\<lambda>zs z1 z2 eA.\n                 if eA \\<noteq> ERR \\<and>\n                    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                 then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n            igSubst =\n              \\<lambda>ys eY y eX.\n                 if eY \\<noteq> ERR \\<and>\n                    igWls MOD (asSort ys) (check eY) \\<and>\n                    eX \\<noteq> ERR \\<and>\n                    (\\<exists>s. igWls MOD s (check eX))\n                 then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n            igSubstAbs =\n              \\<lambda>ys eY y eA.\n                 if eY \\<noteq> ERR \\<and>\n                    igWls MOD (asSort ys) (check eY) \\<and>\n                    eA \\<noteq> ERR \\<and>\n                    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                 then OK (igSubstAbs MOD ys (check eY) y (check eA))\n                 else ERR\\<rparr>\n         s' X\\<rbrakk>\n       \\<Longrightarrow> s = s'", "subgoal for _ _ X"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s s' X.\n                igWls MOD s X \\<and> igWls MOD s' X \\<longrightarrow>\n                s = s';\n     igWls\n      \\<lparr>igWls = \\<lambda>s. case_withERR False (igWls MOD s),\n         igWlsAbs =\n           \\<lambda>(us, s). case_withERR False (igWlsAbs MOD (us, s)),\n         igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n         igAbs =\n           \\<lambda>xs x eX.\n              if eX \\<noteq> ERR \\<and>\n                 (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n              then OK (igAbs MOD xs x (check eX)) else ERR,\n         igOp =\n           \\<lambda>delta einp ebinp.\n              if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                 liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                 igWlsInp MOD delta (checkI einp) \\<and>\n                 igWlsBinp MOD delta (checkI ebinp)\n              then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n              else ERR,\n         igFresh =\n           \\<lambda>ys y eX.\n              if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n              then igFresh MOD ys y (check eX) else True,\n         igFreshAbs =\n           \\<lambda>ys y eA.\n              if eA \\<noteq> ERR \\<and>\n                 (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n              then igFreshAbs MOD ys y (check eA) else True,\n         igSwap =\n           \\<lambda>zs z1 z2 eX.\n              if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n              then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n         igSwapAbs =\n           \\<lambda>zs z1 z2 eA.\n              if eA \\<noteq> ERR \\<and>\n                 (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n              then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n         igSubst =\n           \\<lambda>ys eY y eX.\n              if eY \\<noteq> ERR \\<and>\n                 igWls MOD (asSort ys) (check eY) \\<and>\n                 eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n              then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n         igSubstAbs =\n           \\<lambda>ys eY y eA.\n              if eY \\<noteq> ERR \\<and>\n                 igWls MOD (asSort ys) (check eY) \\<and>\n                 eA \\<noteq> ERR \\<and>\n                 (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n              then OK (igSubstAbs MOD ys (check eY) y (check eA))\n              else ERR\\<rparr>\n      s_ X;\n     igWls\n      \\<lparr>igWls = \\<lambda>s. case_withERR False (igWls MOD s),\n         igWlsAbs =\n           \\<lambda>(us, s). case_withERR False (igWlsAbs MOD (us, s)),\n         igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n         igAbs =\n           \\<lambda>xs x eX.\n              if eX \\<noteq> ERR \\<and>\n                 (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n              then OK (igAbs MOD xs x (check eX)) else ERR,\n         igOp =\n           \\<lambda>delta einp ebinp.\n              if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                 liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                 igWlsInp MOD delta (checkI einp) \\<and>\n                 igWlsBinp MOD delta (checkI ebinp)\n              then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n              else ERR,\n         igFresh =\n           \\<lambda>ys y eX.\n              if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n              then igFresh MOD ys y (check eX) else True,\n         igFreshAbs =\n           \\<lambda>ys y eA.\n              if eA \\<noteq> ERR \\<and>\n                 (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n              then igFreshAbs MOD ys y (check eA) else True,\n         igSwap =\n           \\<lambda>zs z1 z2 eX.\n              if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n              then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n         igSwapAbs =\n           \\<lambda>zs z1 z2 eA.\n              if eA \\<noteq> ERR \\<and>\n                 (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n              then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n         igSubst =\n           \\<lambda>ys eY y eX.\n              if eY \\<noteq> ERR \\<and>\n                 igWls MOD (asSort ys) (check eY) \\<and>\n                 eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n              then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n         igSubstAbs =\n           \\<lambda>ys eY y eA.\n              if eY \\<noteq> ERR \\<and>\n                 igWls MOD (asSort ys) (check eY) \\<and>\n                 eA \\<noteq> ERR \\<and>\n                 (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n              then OK (igSubstAbs MOD ys (check eY) y (check eA))\n              else ERR\\<rparr>\n      s'_ X\\<rbrakk>\n    \\<Longrightarrow> s_ = s'_", "by(cases X) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma errMOD_igWlsAbsDisj:\nassumes \"igWlsAbsDisj MOD\"\nshows \"igWlsAbsDisj (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAbsDisj (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igWlsAbsDisj MOD\n\ngoal (1 subgoal):\n 1. igWlsAbsDisj (errMOD MOD)", "unfolding errMOD_def igWlsAbsDisj_def"], ["proof (prove)\nusing this:\n  \\<forall>xs s xs' s' A.\n     isInBar (xs, s) \\<and>\n     isInBar (xs', s') \\<and>\n     igWlsAbs MOD (xs, s) A \\<and>\n     igWlsAbs MOD (xs', s') A \\<longrightarrow>\n     xs = xs' \\<and> s = s'\n\ngoal (1 subgoal):\n 1. \\<forall>xs s xs' s' A.\n       isInBar (xs, s) \\<and>\n       isInBar (xs', s') \\<and>\n       igWlsAbs\n        \\<lparr>igWls = \\<lambda>s. case_withERR False (igWls MOD s),\n           igWlsAbs =\n             \\<lambda>(us, s). case_withERR False (igWlsAbs MOD (us, s)),\n           igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n           igAbs =\n             \\<lambda>xs x eX.\n                if eX \\<noteq> ERR \\<and>\n                   (\\<exists>s.\n                       isInBar (xs, s) \\<and> igWls MOD s (check eX))\n                then OK (igAbs MOD xs x (check eX)) else ERR,\n           igOp =\n             \\<lambda>delta einp ebinp.\n                if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                   liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                   igWlsInp MOD delta (checkI einp) \\<and>\n                   igWlsBinp MOD delta (checkI ebinp)\n                then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n                else ERR,\n           igFresh =\n             \\<lambda>ys y eX.\n                if eX \\<noteq> ERR \\<and>\n                   (\\<exists>s. igWls MOD s (check eX))\n                then igFresh MOD ys y (check eX) else True,\n           igFreshAbs =\n             \\<lambda>ys y eA.\n                if eA \\<noteq> ERR \\<and>\n                   (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                then igFreshAbs MOD ys y (check eA) else True,\n           igSwap =\n             \\<lambda>zs z1 z2 eX.\n                if eX \\<noteq> ERR \\<and>\n                   (\\<exists>s. igWls MOD s (check eX))\n                then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n           igSwapAbs =\n             \\<lambda>zs z1 z2 eA.\n                if eA \\<noteq> ERR \\<and>\n                   (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n           igSubst =\n             \\<lambda>ys eY y eX.\n                if eY \\<noteq> ERR \\<and>\n                   igWls MOD (asSort ys) (check eY) \\<and>\n                   eX \\<noteq> ERR \\<and>\n                   (\\<exists>s. igWls MOD s (check eX))\n                then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n           igSubstAbs =\n             \\<lambda>ys eY y eA.\n                if eY \\<noteq> ERR \\<and>\n                   igWls MOD (asSort ys) (check eY) \\<and>\n                   eA \\<noteq> ERR \\<and>\n                   (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                then OK (igSubstAbs MOD ys (check eY) y (check eA))\n                else ERR\\<rparr>\n        (xs, s) A \\<and>\n       igWlsAbs\n        \\<lparr>igWls = \\<lambda>s. case_withERR False (igWls MOD s),\n           igWlsAbs =\n             \\<lambda>(us, s). case_withERR False (igWlsAbs MOD (us, s)),\n           igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n           igAbs =\n             \\<lambda>xs x eX.\n                if eX \\<noteq> ERR \\<and>\n                   (\\<exists>s.\n                       isInBar (xs, s) \\<and> igWls MOD s (check eX))\n                then OK (igAbs MOD xs x (check eX)) else ERR,\n           igOp =\n             \\<lambda>delta einp ebinp.\n                if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                   liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                   igWlsInp MOD delta (checkI einp) \\<and>\n                   igWlsBinp MOD delta (checkI ebinp)\n                then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n                else ERR,\n           igFresh =\n             \\<lambda>ys y eX.\n                if eX \\<noteq> ERR \\<and>\n                   (\\<exists>s. igWls MOD s (check eX))\n                then igFresh MOD ys y (check eX) else True,\n           igFreshAbs =\n             \\<lambda>ys y eA.\n                if eA \\<noteq> ERR \\<and>\n                   (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                then igFreshAbs MOD ys y (check eA) else True,\n           igSwap =\n             \\<lambda>zs z1 z2 eX.\n                if eX \\<noteq> ERR \\<and>\n                   (\\<exists>s. igWls MOD s (check eX))\n                then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n           igSwapAbs =\n             \\<lambda>zs z1 z2 eA.\n                if eA \\<noteq> ERR \\<and>\n                   (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n           igSubst =\n             \\<lambda>ys eY y eX.\n                if eY \\<noteq> ERR \\<and>\n                   igWls MOD (asSort ys) (check eY) \\<and>\n                   eX \\<noteq> ERR \\<and>\n                   (\\<exists>s. igWls MOD s (check eX))\n                then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n           igSubstAbs =\n             \\<lambda>ys eY y eA.\n                if eY \\<noteq> ERR \\<and>\n                   igWls MOD (asSort ys) (check eY) \\<and>\n                   eA \\<noteq> ERR \\<and>\n                   (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                then OK (igSubstAbs MOD ys (check eY) y (check eA))\n                else ERR\\<rparr>\n        (xs', s') A \\<longrightarrow>\n       xs = xs' \\<and> s = s'", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs s xs' s' A.\n       \\<lbrakk>\\<forall>xs s xs' s' A.\n                   isInBar (xs, s) \\<and>\n                   isInBar (xs', s') \\<and>\n                   igWlsAbs MOD (xs, s) A \\<and>\n                   igWlsAbs MOD (xs', s') A \\<longrightarrow>\n                   xs = xs' \\<and> s = s';\n        isInBar (xs, s); isInBar (xs', s');\n        igWlsAbs\n         \\<lparr>igWls = \\<lambda>s. case_withERR False (igWls MOD s),\n            igWlsAbs =\n              \\<lambda>(us, s). case_withERR False (igWlsAbs MOD (us, s)),\n            igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n            igAbs =\n              \\<lambda>xs x eX.\n                 if eX \\<noteq> ERR \\<and>\n                    (\\<exists>s.\n                        isInBar (xs, s) \\<and> igWls MOD s (check eX))\n                 then OK (igAbs MOD xs x (check eX)) else ERR,\n            igOp =\n              \\<lambda>delta einp ebinp.\n                 if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                    liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                    igWlsInp MOD delta (checkI einp) \\<and>\n                    igWlsBinp MOD delta (checkI ebinp)\n                 then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n                 else ERR,\n            igFresh =\n              \\<lambda>ys y eX.\n                 if eX \\<noteq> ERR \\<and>\n                    (\\<exists>s. igWls MOD s (check eX))\n                 then igFresh MOD ys y (check eX) else True,\n            igFreshAbs =\n              \\<lambda>ys y eA.\n                 if eA \\<noteq> ERR \\<and>\n                    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                 then igFreshAbs MOD ys y (check eA) else True,\n            igSwap =\n              \\<lambda>zs z1 z2 eX.\n                 if eX \\<noteq> ERR \\<and>\n                    (\\<exists>s. igWls MOD s (check eX))\n                 then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n            igSwapAbs =\n              \\<lambda>zs z1 z2 eA.\n                 if eA \\<noteq> ERR \\<and>\n                    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                 then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n            igSubst =\n              \\<lambda>ys eY y eX.\n                 if eY \\<noteq> ERR \\<and>\n                    igWls MOD (asSort ys) (check eY) \\<and>\n                    eX \\<noteq> ERR \\<and>\n                    (\\<exists>s. igWls MOD s (check eX))\n                 then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n            igSubstAbs =\n              \\<lambda>ys eY y eA.\n                 if eY \\<noteq> ERR \\<and>\n                    igWls MOD (asSort ys) (check eY) \\<and>\n                    eA \\<noteq> ERR \\<and>\n                    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                 then OK (igSubstAbs MOD ys (check eY) y (check eA))\n                 else ERR\\<rparr>\n         (xs, s) A;\n        igWlsAbs\n         \\<lparr>igWls = \\<lambda>s. case_withERR False (igWls MOD s),\n            igWlsAbs =\n              \\<lambda>(us, s). case_withERR False (igWlsAbs MOD (us, s)),\n            igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n            igAbs =\n              \\<lambda>xs x eX.\n                 if eX \\<noteq> ERR \\<and>\n                    (\\<exists>s.\n                        isInBar (xs, s) \\<and> igWls MOD s (check eX))\n                 then OK (igAbs MOD xs x (check eX)) else ERR,\n            igOp =\n              \\<lambda>delta einp ebinp.\n                 if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                    liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                    igWlsInp MOD delta (checkI einp) \\<and>\n                    igWlsBinp MOD delta (checkI ebinp)\n                 then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n                 else ERR,\n            igFresh =\n              \\<lambda>ys y eX.\n                 if eX \\<noteq> ERR \\<and>\n                    (\\<exists>s. igWls MOD s (check eX))\n                 then igFresh MOD ys y (check eX) else True,\n            igFreshAbs =\n              \\<lambda>ys y eA.\n                 if eA \\<noteq> ERR \\<and>\n                    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                 then igFreshAbs MOD ys y (check eA) else True,\n            igSwap =\n              \\<lambda>zs z1 z2 eX.\n                 if eX \\<noteq> ERR \\<and>\n                    (\\<exists>s. igWls MOD s (check eX))\n                 then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n            igSwapAbs =\n              \\<lambda>zs z1 z2 eA.\n                 if eA \\<noteq> ERR \\<and>\n                    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                 then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n            igSubst =\n              \\<lambda>ys eY y eX.\n                 if eY \\<noteq> ERR \\<and>\n                    igWls MOD (asSort ys) (check eY) \\<and>\n                    eX \\<noteq> ERR \\<and>\n                    (\\<exists>s. igWls MOD s (check eX))\n                 then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n            igSubstAbs =\n              \\<lambda>ys eY y eA.\n                 if eY \\<noteq> ERR \\<and>\n                    igWls MOD (asSort ys) (check eY) \\<and>\n                    eA \\<noteq> ERR \\<and>\n                    (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                 then OK (igSubstAbs MOD ys (check eY) y (check eA))\n                 else ERR\\<rparr>\n         (xs', s') A\\<rbrakk>\n       \\<Longrightarrow> xs = xs' \\<and> s = s'", "subgoal for _ _ _ _ A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>xs s xs' s' A.\n                isInBar (xs, s) \\<and>\n                isInBar (xs', s') \\<and>\n                igWlsAbs MOD (xs, s) A \\<and>\n                igWlsAbs MOD (xs', s') A \\<longrightarrow>\n                xs = xs' \\<and> s = s';\n     isInBar (xs_, s_); isInBar (xs'_, s'_);\n     igWlsAbs\n      \\<lparr>igWls = \\<lambda>s. case_withERR False (igWls MOD s),\n         igWlsAbs =\n           \\<lambda>(us, s). case_withERR False (igWlsAbs MOD (us, s)),\n         igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n         igAbs =\n           \\<lambda>xs x eX.\n              if eX \\<noteq> ERR \\<and>\n                 (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n              then OK (igAbs MOD xs x (check eX)) else ERR,\n         igOp =\n           \\<lambda>delta einp ebinp.\n              if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                 liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                 igWlsInp MOD delta (checkI einp) \\<and>\n                 igWlsBinp MOD delta (checkI ebinp)\n              then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n              else ERR,\n         igFresh =\n           \\<lambda>ys y eX.\n              if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n              then igFresh MOD ys y (check eX) else True,\n         igFreshAbs =\n           \\<lambda>ys y eA.\n              if eA \\<noteq> ERR \\<and>\n                 (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n              then igFreshAbs MOD ys y (check eA) else True,\n         igSwap =\n           \\<lambda>zs z1 z2 eX.\n              if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n              then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n         igSwapAbs =\n           \\<lambda>zs z1 z2 eA.\n              if eA \\<noteq> ERR \\<and>\n                 (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n              then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n         igSubst =\n           \\<lambda>ys eY y eX.\n              if eY \\<noteq> ERR \\<and>\n                 igWls MOD (asSort ys) (check eY) \\<and>\n                 eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n              then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n         igSubstAbs =\n           \\<lambda>ys eY y eA.\n              if eY \\<noteq> ERR \\<and>\n                 igWls MOD (asSort ys) (check eY) \\<and>\n                 eA \\<noteq> ERR \\<and>\n                 (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n              then OK (igSubstAbs MOD ys (check eY) y (check eA))\n              else ERR\\<rparr>\n      (xs_, s_) A;\n     igWlsAbs\n      \\<lparr>igWls = \\<lambda>s. case_withERR False (igWls MOD s),\n         igWlsAbs =\n           \\<lambda>(us, s). case_withERR False (igWlsAbs MOD (us, s)),\n         igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n         igAbs =\n           \\<lambda>xs x eX.\n              if eX \\<noteq> ERR \\<and>\n                 (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s (check eX))\n              then OK (igAbs MOD xs x (check eX)) else ERR,\n         igOp =\n           \\<lambda>delta einp ebinp.\n              if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                 liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                 igWlsInp MOD delta (checkI einp) \\<and>\n                 igWlsBinp MOD delta (checkI ebinp)\n              then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n              else ERR,\n         igFresh =\n           \\<lambda>ys y eX.\n              if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n              then igFresh MOD ys y (check eX) else True,\n         igFreshAbs =\n           \\<lambda>ys y eA.\n              if eA \\<noteq> ERR \\<and>\n                 (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n              then igFreshAbs MOD ys y (check eA) else True,\n         igSwap =\n           \\<lambda>zs z1 z2 eX.\n              if eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n              then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n         igSwapAbs =\n           \\<lambda>zs z1 z2 eA.\n              if eA \\<noteq> ERR \\<and>\n                 (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n              then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n         igSubst =\n           \\<lambda>ys eY y eX.\n              if eY \\<noteq> ERR \\<and>\n                 igWls MOD (asSort ys) (check eY) \\<and>\n                 eX \\<noteq> ERR \\<and> (\\<exists>s. igWls MOD s (check eX))\n              then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n         igSubstAbs =\n           \\<lambda>ys eY y eA.\n              if eY \\<noteq> ERR \\<and>\n                 igWls MOD (asSort ys) (check eY) \\<and>\n                 eA \\<noteq> ERR \\<and>\n                 (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n              then OK (igSubstAbs MOD ys (check eY) y (check eA))\n              else ERR\\<rparr>\n      (xs'_, s'_) A\\<rbrakk>\n    \\<Longrightarrow> xs_ = xs'_ \\<and> s_ = s'_", "by(cases A) fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma errMOD_igWlsAllDisj:\nassumes \"igWlsAllDisj MOD\"\nshows \"igWlsAllDisj (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAllDisj (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igWlsAllDisj MOD\n\ngoal (1 subgoal):\n 1. igWlsAllDisj (errMOD MOD)", "unfolding igWlsAllDisj_def"], ["proof (prove)\nusing this:\n  igWlsDisj MOD \\<and> igWlsAbsDisj MOD\n\ngoal (1 subgoal):\n 1. igWlsDisj (errMOD MOD) \\<and> igWlsAbsDisj (errMOD MOD)", "using errMOD_igWlsDisj errMOD_igWlsAbsDisj"], ["proof (prove)\nusing this:\n  igWlsDisj MOD \\<and> igWlsAbsDisj MOD\n  igWlsDisj ?MOD \\<Longrightarrow> igWlsDisj (errMOD ?MOD)\n  igWlsAbsDisj ?MOD \\<Longrightarrow> igWlsAbsDisj (errMOD ?MOD)\n\ngoal (1 subgoal):\n 1. igWlsDisj (errMOD MOD) \\<and> igWlsAbsDisj (errMOD MOD)", "by auto"], ["", "text\\<open>Only ``bound arity\" abstraction domains are inhabited:\\<close>"], ["", "lemma errMOD_igWlsAbsIsInBar:\nassumes \"igWlsAbsIsInBar MOD\"\nshows \"igWlsAbsIsInBar (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAbsIsInBar (errMOD MOD)", "using assms eWlsAbs_invert"], ["proof (prove)\nusing this:\n  igWlsAbsIsInBar MOD\n  eWlsAbs ?MOD (?us, ?s) ?eA \\<Longrightarrow>\n  \\<exists>A. ?eA = OK A \\<and> igWlsAbs ?MOD (?us, ?s) A\n\ngoal (1 subgoal):\n 1. igWlsAbsIsInBar (errMOD MOD)", "unfolding igWlsAbsIsInBar_def"], ["proof (prove)\nusing this:\n  \\<forall>us s A. igWlsAbs MOD (us, s) A \\<longrightarrow> isInBar (us, s)\n  eWlsAbs ?MOD (?us, ?s) ?eA \\<Longrightarrow>\n  \\<exists>A. ?eA = OK A \\<and> igWlsAbs ?MOD (?us, ?s) A\n\ngoal (1 subgoal):\n 1. \\<forall>us s A. eWlsAbs MOD (us, s) A \\<longrightarrow> isInBar (us, s)", "by blast"], ["", "text\\<open>The operators preserve the domains strongly:\\<close>"], ["", "lemma errMOD_igVarIPresIGWlsSTR:\nassumes \"igVarIPresIGWls MOD\"\nshows \"igVarIPresIGWls (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igVarIPresIGWls (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igVarIPresIGWls MOD\n\ngoal (1 subgoal):\n 1. igVarIPresIGWls (errMOD MOD)", "unfolding errMOD_def igVarIPresIGWls_def"], ["proof (prove)\nusing this:\n  \\<forall>xs x. igWls MOD (asSort xs) (igVar MOD xs x)\n\ngoal (1 subgoal):\n 1. \\<forall>xs x.\n       igWls\n        \\<lparr>igWls = \\<lambda>s. case_withERR False (igWls MOD s),\n           igWlsAbs =\n             \\<lambda>(us, s). case_withERR False (igWlsAbs MOD (us, s)),\n           igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n           igAbs =\n             \\<lambda>xs x eX.\n                if eX \\<noteq> ERR \\<and>\n                   (\\<exists>s.\n                       isInBar (xs, s) \\<and> igWls MOD s (check eX))\n                then OK (igAbs MOD xs x (check eX)) else ERR,\n           igOp =\n             \\<lambda>delta einp ebinp.\n                if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                   liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                   igWlsInp MOD delta (checkI einp) \\<and>\n                   igWlsBinp MOD delta (checkI ebinp)\n                then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n                else ERR,\n           igFresh =\n             \\<lambda>ys y eX.\n                if eX \\<noteq> ERR \\<and>\n                   (\\<exists>s. igWls MOD s (check eX))\n                then igFresh MOD ys y (check eX) else True,\n           igFreshAbs =\n             \\<lambda>ys y eA.\n                if eA \\<noteq> ERR \\<and>\n                   (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                then igFreshAbs MOD ys y (check eA) else True,\n           igSwap =\n             \\<lambda>zs z1 z2 eX.\n                if eX \\<noteq> ERR \\<and>\n                   (\\<exists>s. igWls MOD s (check eX))\n                then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n           igSwapAbs =\n             \\<lambda>zs z1 z2 eA.\n                if eA \\<noteq> ERR \\<and>\n                   (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n           igSubst =\n             \\<lambda>ys eY y eX.\n                if eY \\<noteq> ERR \\<and>\n                   igWls MOD (asSort ys) (check eY) \\<and>\n                   eX \\<noteq> ERR \\<and>\n                   (\\<exists>s. igWls MOD s (check eX))\n                then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n           igSubstAbs =\n             \\<lambda>ys eY y eA.\n                if eY \\<noteq> ERR \\<and>\n                   igWls MOD (asSort ys) (check eY) \\<and>\n                   eA \\<noteq> ERR \\<and>\n                   (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                then OK (igSubstAbs MOD ys (check eY) y (check eA))\n                else ERR\\<rparr>\n        (asSort xs)\n        (igVar\n          \\<lparr>igWls = \\<lambda>s. case_withERR False (igWls MOD s),\n             igWlsAbs =\n               \\<lambda>(us, s). case_withERR False (igWlsAbs MOD (us, s)),\n             igVar = \\<lambda>xs x. OK (igVar MOD xs x),\n             igAbs =\n               \\<lambda>xs x eX.\n                  if eX \\<noteq> ERR \\<and>\n                     (\\<exists>s.\n                         isInBar (xs, s) \\<and> igWls MOD s (check eX))\n                  then OK (igAbs MOD xs x (check eX)) else ERR,\n             igOp =\n               \\<lambda>delta einp ebinp.\n                  if liftAll (\\<lambda>X. X \\<noteq> ERR) einp \\<and>\n                     liftAll (\\<lambda>A. A \\<noteq> ERR) ebinp \\<and>\n                     igWlsInp MOD delta (checkI einp) \\<and>\n                     igWlsBinp MOD delta (checkI ebinp)\n                  then OK (igOp MOD delta (checkI einp) (checkI ebinp))\n                  else ERR,\n             igFresh =\n               \\<lambda>ys y eX.\n                  if eX \\<noteq> ERR \\<and>\n                     (\\<exists>s. igWls MOD s (check eX))\n                  then igFresh MOD ys y (check eX) else True,\n             igFreshAbs =\n               \\<lambda>ys y eA.\n                  if eA \\<noteq> ERR \\<and>\n                     (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                  then igFreshAbs MOD ys y (check eA) else True,\n             igSwap =\n               \\<lambda>zs z1 z2 eX.\n                  if eX \\<noteq> ERR \\<and>\n                     (\\<exists>s. igWls MOD s (check eX))\n                  then OK (igSwap MOD zs z1 z2 (check eX)) else ERR,\n             igSwapAbs =\n               \\<lambda>zs z1 z2 eA.\n                  if eA \\<noteq> ERR \\<and>\n                     (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                  then OK (igSwapAbs MOD zs z1 z2 (check eA)) else ERR,\n             igSubst =\n               \\<lambda>ys eY y eX.\n                  if eY \\<noteq> ERR \\<and>\n                     igWls MOD (asSort ys) (check eY) \\<and>\n                     eX \\<noteq> ERR \\<and>\n                     (\\<exists>s. igWls MOD s (check eX))\n                  then OK (igSubst MOD ys (check eY) y (check eX)) else ERR,\n             igSubstAbs =\n               \\<lambda>ys eY y eA.\n                  if eY \\<noteq> ERR \\<and>\n                     igWls MOD (asSort ys) (check eY) \\<and>\n                     eA \\<noteq> ERR \\<and>\n                     (\\<exists>us s. igWlsAbs MOD (us, s) (check eA))\n                  then OK (igSubstAbs MOD ys (check eY) y (check eA))\n                  else ERR\\<rparr>\n          xs x)", "by simp"], ["", "lemma errMOD_igAbsIPresIGWlsSTR:\nassumes *: \"igAbsIPresIGWls MOD\" and **: \"igWlsAbsDisj MOD\"\nand ***: \"igWlsAbsIsInBar MOD\"\nshows \"igAbsIPresIGWlsSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbsIPresIGWlsSTR (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igAbsIPresIGWls MOD\n  igWlsAbsDisj MOD\n  igWlsAbsIsInBar MOD\n\ngoal (1 subgoal):\n 1. igAbsIPresIGWlsSTR (errMOD MOD)", "by (fastforce simp: errMOD_def igAbsIPresIGWls_def igAbsIPresIGWlsSTR_def \nigWlsAbsIsInBar_def igWlsAbsDisj_def split: withERR.splits)"], ["", "lemma errMOD_igOpIPresIGWlsSTR:\nfixes MOD :: \"('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs)model\"\nassumes \"igOpIPresIGWls MOD\"\nshows \"igOpIPresIGWlsSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igOpIPresIGWlsSTR (errMOD MOD)", "by (simp add: igOpIPresIGWlsSTR_def igOpIPresIGWls_def) \n  (smt assms eOp_nchotomy eOp_simp1 eWlsBinp_invert \neWlsBinp_simp1 eWlsInp_invert eWlsInp_simp1 eWls_simp1 eWls_simp2 igOpIPresIGWls_def)"], ["", "lemma errMOD_igConsIPresIGWlsSTR:\nassumes \"igConsIPresIGWls MOD\" and \"igWlsAllDisj MOD\"\nand \"igWlsAbsIsInBar MOD\"\nshows \"igConsIPresIGWlsSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igConsIPresIGWlsSTR (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igConsIPresIGWls MOD\n  igWlsAllDisj MOD\n  igWlsAbsIsInBar MOD\n\ngoal (1 subgoal):\n 1. igConsIPresIGWlsSTR (errMOD MOD)", "unfolding igConsIPresIGWls_def igConsIPresIGWlsSTR_def igWlsAllDisj_def"], ["proof (prove)\nusing this:\n  igVarIPresIGWls MOD \\<and> igAbsIPresIGWls MOD \\<and> igOpIPresIGWls MOD\n  igWlsDisj MOD \\<and> igWlsAbsDisj MOD\n  igWlsAbsIsInBar MOD\n\ngoal (1 subgoal):\n 1. igVarIPresIGWls (errMOD MOD) \\<and>\n    igAbsIPresIGWlsSTR (errMOD MOD) \\<and> igOpIPresIGWlsSTR (errMOD MOD)", "using\nerrMOD_igVarIPresIGWlsSTR[of MOD]\nerrMOD_igAbsIPresIGWlsSTR[of MOD]\nerrMOD_igOpIPresIGWlsSTR[of MOD]"], ["proof (prove)\nusing this:\n  igVarIPresIGWls MOD \\<and> igAbsIPresIGWls MOD \\<and> igOpIPresIGWls MOD\n  igWlsDisj MOD \\<and> igWlsAbsDisj MOD\n  igWlsAbsIsInBar MOD\n  igVarIPresIGWls MOD \\<Longrightarrow> igVarIPresIGWls (errMOD MOD)\n  \\<lbrakk>igAbsIPresIGWls MOD; igWlsAbsDisj MOD;\n   igWlsAbsIsInBar MOD\\<rbrakk>\n  \\<Longrightarrow> igAbsIPresIGWlsSTR (errMOD MOD)\n  igOpIPresIGWls MOD \\<Longrightarrow> igOpIPresIGWlsSTR (errMOD MOD)\n\ngoal (1 subgoal):\n 1. igVarIPresIGWls (errMOD MOD) \\<and>\n    igAbsIPresIGWlsSTR (errMOD MOD) \\<and> igOpIPresIGWlsSTR (errMOD MOD)", "by auto"], ["", "lemma errMOD_igSwapIPresIGWlsSTR:\nassumes \"igSwapIPresIGWls MOD\" and \"igWlsDisj MOD\"\nshows \"igSwapIPresIGWlsSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIPresIGWlsSTR (errMOD MOD)", "using \\<open>igSwapIPresIGWls MOD\\<close>"], ["proof (prove)\nusing this:\n  igSwapIPresIGWls MOD\n\ngoal (1 subgoal):\n 1. igSwapIPresIGWlsSTR (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igSwapIPresIGWls MOD\n  igSwapIPresIGWls MOD\n  igWlsDisj MOD\n\ngoal (1 subgoal):\n 1. igSwapIPresIGWlsSTR (errMOD MOD)", "by (fastforce simp: errMOD_def igSwapIPresIGWls_def igSwapIPresIGWlsSTR_def \nigWlsDisj_def split: withERR.splits)"], ["", "lemma errMOD_igSwapAbsIPresIGWlsAbsSTR:\nassumes *: \"igSwapAbsIPresIGWlsAbs MOD\" and **: \"igWlsAbsDisj MOD\"\nand ***: \"igWlsAbsIsInBar MOD\"\nshows \"igSwapAbsIPresIGWlsAbsSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapAbsIPresIGWlsAbsSTR (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igSwapAbsIPresIGWlsAbs MOD\n  igWlsAbsDisj MOD\n  igWlsAbsIsInBar MOD\n\ngoal (1 subgoal):\n 1. igSwapAbsIPresIGWlsAbsSTR (errMOD MOD)", "by (simp add: errMOD_def igSwapAbsIPresIGWlsAbs_def igSwapAbsIPresIGWlsAbsSTR_def \nigWlsAbsIsInBar_def igWlsAbsDisj_def split: withERR.splits) blast"], ["", "lemma errMOD_igSwapAllIPresIGWlsAllSTR:\nassumes \"igSwapAllIPresIGWlsAll MOD\" and \"igWlsAllDisj MOD\"\nand \"igWlsAbsIsInBar MOD\"\nshows \"igSwapAllIPresIGWlsAllSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapAllIPresIGWlsAllSTR (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igSwapAllIPresIGWlsAll MOD\n  igWlsAllDisj MOD\n  igWlsAbsIsInBar MOD\n\ngoal (1 subgoal):\n 1. igSwapAllIPresIGWlsAllSTR (errMOD MOD)", "unfolding igSwapAllIPresIGWlsAll_def igSwapAllIPresIGWlsAllSTR_def igWlsAllDisj_def"], ["proof (prove)\nusing this:\n  igSwapIPresIGWls MOD \\<and> igSwapAbsIPresIGWlsAbs MOD\n  igWlsDisj MOD \\<and> igWlsAbsDisj MOD\n  igWlsAbsIsInBar MOD\n\ngoal (1 subgoal):\n 1. igSwapIPresIGWlsSTR (errMOD MOD) \\<and>\n    igSwapAbsIPresIGWlsAbsSTR (errMOD MOD)", "using errMOD_igSwapIPresIGWlsSTR[of MOD] errMOD_igSwapIPresIGWlsSTR[of MOD]\nerrMOD_igSwapAbsIPresIGWlsAbsSTR[of MOD]"], ["proof (prove)\nusing this:\n  igSwapIPresIGWls MOD \\<and> igSwapAbsIPresIGWlsAbs MOD\n  igWlsDisj MOD \\<and> igWlsAbsDisj MOD\n  igWlsAbsIsInBar MOD\n  \\<lbrakk>igSwapIPresIGWls MOD; igWlsDisj MOD\\<rbrakk>\n  \\<Longrightarrow> igSwapIPresIGWlsSTR (errMOD MOD)\n  \\<lbrakk>igSwapIPresIGWls MOD; igWlsDisj MOD\\<rbrakk>\n  \\<Longrightarrow> igSwapIPresIGWlsSTR (errMOD MOD)\n  \\<lbrakk>igSwapAbsIPresIGWlsAbs MOD; igWlsAbsDisj MOD;\n   igWlsAbsIsInBar MOD\\<rbrakk>\n  \\<Longrightarrow> igSwapAbsIPresIGWlsAbsSTR (errMOD MOD)\n\ngoal (1 subgoal):\n 1. igSwapIPresIGWlsSTR (errMOD MOD) \\<and>\n    igSwapAbsIPresIGWlsAbsSTR (errMOD MOD)", "by auto"], ["", "lemma errMOD_igSubstIPresIGWlsSTR:\nassumes \"igSubstIPresIGWls MOD\" and \"igWlsDisj MOD\"\nshows \"igSubstIPresIGWlsSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIPresIGWlsSTR (errMOD MOD)", "using \\<open>igSubstIPresIGWls MOD\\<close>"], ["proof (prove)\nusing this:\n  igSubstIPresIGWls MOD\n\ngoal (1 subgoal):\n 1. igSubstIPresIGWlsSTR (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igSubstIPresIGWls MOD\n  igSubstIPresIGWls MOD\n  igWlsDisj MOD\n\ngoal (1 subgoal):\n 1. igSubstIPresIGWlsSTR (errMOD MOD)", "by (fastforce simp: errMOD_def igSubstIPresIGWls_def igSubstIPresIGWlsSTR_def \nigWlsDisj_def split: withERR.splits)"], ["", "lemma errMOD_igSubstAbsIPresIGWlsAbsSTR:\nassumes *: \"igSubstAbsIPresIGWlsAbs MOD\" and **: \"igWlsAbsDisj MOD\"\nand ***: \"igWlsAbsIsInBar MOD\"\nshows \"igSubstAbsIPresIGWlsAbsSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAbsIPresIGWlsAbsSTR (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igSubstAbsIPresIGWlsAbs MOD\n  igWlsAbsDisj MOD\n  igWlsAbsIsInBar MOD\n\ngoal (1 subgoal):\n 1. igSubstAbsIPresIGWlsAbsSTR (errMOD MOD)", "by (simp add: errMOD_def igSubstAbsIPresIGWlsAbs_def igSubstAbsIPresIGWlsAbsSTR_def \nigWlsAbsIsInBar_def igWlsAbsDisj_def split: withERR.splits) blast"], ["", "lemma errMOD_igSubstAllIPresIGWlsAllSTR:\nassumes \"igSubstAllIPresIGWlsAll MOD\" and \"igWlsAllDisj MOD\"\nand \"igWlsAbsIsInBar MOD\"\nshows \"igSubstAllIPresIGWlsAllSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAllIPresIGWlsAllSTR (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igSubstAllIPresIGWlsAll MOD\n  igWlsAllDisj MOD\n  igWlsAbsIsInBar MOD\n\ngoal (1 subgoal):\n 1. igSubstAllIPresIGWlsAllSTR (errMOD MOD)", "unfolding igSubstAllIPresIGWlsAll_def igSubstAllIPresIGWlsAllSTR_def igWlsAllDisj_def"], ["proof (prove)\nusing this:\n  igSubstIPresIGWls MOD \\<and> igSubstAbsIPresIGWlsAbs MOD\n  igWlsDisj MOD \\<and> igWlsAbsDisj MOD\n  igWlsAbsIsInBar MOD\n\ngoal (1 subgoal):\n 1. igSubstIPresIGWlsSTR (errMOD MOD) \\<and>\n    igSubstAbsIPresIGWlsAbsSTR (errMOD MOD)", "using errMOD_igSubstIPresIGWlsSTR[of MOD] errMOD_igSubstIPresIGWlsSTR[of MOD]\nerrMOD_igSubstAbsIPresIGWlsAbsSTR[of MOD]"], ["proof (prove)\nusing this:\n  igSubstIPresIGWls MOD \\<and> igSubstAbsIPresIGWlsAbs MOD\n  igWlsDisj MOD \\<and> igWlsAbsDisj MOD\n  igWlsAbsIsInBar MOD\n  \\<lbrakk>igSubstIPresIGWls MOD; igWlsDisj MOD\\<rbrakk>\n  \\<Longrightarrow> igSubstIPresIGWlsSTR (errMOD MOD)\n  \\<lbrakk>igSubstIPresIGWls MOD; igWlsDisj MOD\\<rbrakk>\n  \\<Longrightarrow> igSubstIPresIGWlsSTR (errMOD MOD)\n  \\<lbrakk>igSubstAbsIPresIGWlsAbs MOD; igWlsAbsDisj MOD;\n   igWlsAbsIsInBar MOD\\<rbrakk>\n  \\<Longrightarrow> igSubstAbsIPresIGWlsAbsSTR (errMOD MOD)\n\ngoal (1 subgoal):\n 1. igSubstIPresIGWlsSTR (errMOD MOD) \\<and>\n    igSubstAbsIPresIGWlsAbsSTR (errMOD MOD)", "by auto"], ["", "text\\<open>The strong ``fresh\" clauses are satisfied:\\<close>"], ["", "lemma errMOD_igFreshIGVarSTR:\nassumes \"igVarIPresIGWls MOD\" and \"igFreshIGVar MOD\"\nshows \"igFreshIGVar (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshIGVar (errMOD MOD)", "using assms eFresh_simp1"], ["proof (prove)\nusing this:\n  igVarIPresIGWls MOD\n  igFreshIGVar MOD\n  igWls ?MOD ?s ?X \\<Longrightarrow>\n  eFresh ?MOD ?ys ?y (OK ?X) = igFresh ?MOD ?ys ?y ?X\n\ngoal (1 subgoal):\n 1. igFreshIGVar (errMOD MOD)", "by(fastforce simp: igVarIPresIGWls_def igFreshIGVar_def)"], ["", "lemma errMOD_igFreshIGAbs1STR:\nassumes *: \"igAbsIPresIGWls MOD\" and **: \"igFreshIGAbs1 MOD\"\nshows \"igFreshIGAbs1STR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshIGAbs1STR (errMOD MOD)", "unfolding igFreshIGAbs1STR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y X. eFreshAbs MOD ys y (eAbs MOD ys y X)", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y X. eFreshAbs MOD ys y (eAbs MOD ys y X)", "fix ys y eX"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y X. eFreshAbs MOD ys y (eAbs MOD ys y X)", "show \"eFreshAbs MOD ys y (eAbs MOD ys y eX)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eFreshAbs MOD ys y (eAbs MOD ys y eX)", "proof(cases \"eX \\<noteq> ERR\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eX \\<noteq> ERR \\<Longrightarrow> eFreshAbs MOD ys y (eAbs MOD ys y eX)\n 2. \\<not> eX \\<noteq> ERR \\<Longrightarrow>\n    eFreshAbs MOD ys y (eAbs MOD ys y eX)", "define X where \"X \\<equiv> check eX\""], ["proof (state)\nthis:\n  X \\<equiv> check eX\n\ngoal (2 subgoals):\n 1. eX \\<noteq> ERR \\<Longrightarrow> eFreshAbs MOD ys y (eAbs MOD ys y eX)\n 2. \\<not> eX \\<noteq> ERR \\<Longrightarrow>\n    eFreshAbs MOD ys y (eAbs MOD ys y eX)", "case True"], ["proof (state)\nthis:\n  eX \\<noteq> ERR\n\ngoal (2 subgoals):\n 1. eX \\<noteq> ERR \\<Longrightarrow> eFreshAbs MOD ys y (eAbs MOD ys y eX)\n 2. \\<not> eX \\<noteq> ERR \\<Longrightarrow>\n    eFreshAbs MOD ys y (eAbs MOD ys y eX)", "hence eX: \"eX = OK X\""], ["proof (prove)\nusing this:\n  eX \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. eX = OK X", "unfolding X_def"], ["proof (prove)\nusing this:\n  eX \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. eX = OK (check eX)", "using OK_check"], ["proof (prove)\nusing this:\n  eX \\<noteq> ERR\n  ?eX \\<noteq> ERR \\<Longrightarrow> OK (check ?eX) = ?eX\n\ngoal (1 subgoal):\n 1. eX = OK (check eX)", "by auto"], ["proof (state)\nthis:\n  eX = OK X\n\ngoal (2 subgoals):\n 1. eX \\<noteq> ERR \\<Longrightarrow> eFreshAbs MOD ys y (eAbs MOD ys y eX)\n 2. \\<not> eX \\<noteq> ERR \\<Longrightarrow>\n    eFreshAbs MOD ys y (eAbs MOD ys y eX)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eFreshAbs MOD ys y (eAbs MOD ys y eX)", "using assms eFreshAbs_simp1"], ["proof (prove)\nusing this:\n  igAbsIPresIGWls MOD\n  igFreshIGAbs1 MOD\n  igWlsAbs ?MOD (?us, ?s) ?A \\<Longrightarrow>\n  eFreshAbs ?MOD ?ys ?y (OK ?A) = igFreshAbs ?MOD ?ys ?y ?A\n\ngoal (1 subgoal):\n 1. eFreshAbs MOD ys y (eAbs MOD ys y eX)", "unfolding eX"], ["proof (prove)\nusing this:\n  igAbsIPresIGWls MOD\n  igFreshIGAbs1 MOD\n  igWlsAbs ?MOD (?us, ?s) ?A \\<Longrightarrow>\n  eFreshAbs ?MOD ?ys ?y (OK ?A) = igFreshAbs ?MOD ?ys ?y ?A\n\ngoal (1 subgoal):\n 1. eFreshAbs MOD ys y (eAbs MOD ys y (OK X))", "by (cases \"\\<exists> s. isInBar (ys,s) \\<and> igWls MOD s X\")\n    (fastforce simp: igAbsIPresIGWls_def igFreshIGAbs1_def)+"], ["proof (state)\nthis:\n  eFreshAbs MOD ys y (eAbs MOD ys y eX)\n\ngoal (1 subgoal):\n 1. \\<not> eX \\<noteq> ERR \\<Longrightarrow>\n    eFreshAbs MOD ys y (eAbs MOD ys y eX)", "qed auto"], ["proof (state)\nthis:\n  eFreshAbs MOD ys y (eAbs MOD ys y eX)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma errMOD_igFreshIGAbs2STR:\nassumes \"igAbsIPresIGWls MOD\" and \"igFreshIGAbs2 MOD\"\nshows \"igFreshIGAbs2STR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshIGAbs2STR (errMOD MOD)", "unfolding igFreshIGAbs2STR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y xs x X.\n       eFresh MOD ys y X \\<longrightarrow>\n       eFreshAbs MOD ys y (eAbs MOD xs x X)", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y xs x X.\n       eFresh MOD ys y X \\<Longrightarrow>\n       eFreshAbs MOD ys y (eAbs MOD xs x X)", "fix ys y xs x eX"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y xs x X.\n       eFresh MOD ys y X \\<Longrightarrow>\n       eFreshAbs MOD ys y (eAbs MOD xs x X)", "assume *: \"eFresh MOD ys y eX\""], ["proof (state)\nthis:\n  eFresh MOD ys y eX\n\ngoal (1 subgoal):\n 1. \\<And>ys y xs x X.\n       eFresh MOD ys y X \\<Longrightarrow>\n       eFreshAbs MOD ys y (eAbs MOD xs x X)", "define X where \"X \\<equiv> check eX\""], ["proof (state)\nthis:\n  X \\<equiv> check eX\n\ngoal (1 subgoal):\n 1. \\<And>ys y xs x X.\n       eFresh MOD ys y X \\<Longrightarrow>\n       eFreshAbs MOD ys y (eAbs MOD xs x X)", "show \"eFreshAbs MOD ys y (eAbs MOD xs x eX)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eFreshAbs MOD ys y (eAbs MOD xs x eX)", "proof(cases \"eX \\<noteq> ERR\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eX \\<noteq> ERR \\<Longrightarrow> eFreshAbs MOD ys y (eAbs MOD xs x eX)\n 2. \\<not> eX \\<noteq> ERR \\<Longrightarrow>\n    eFreshAbs MOD ys y (eAbs MOD xs x eX)", "case True"], ["proof (state)\nthis:\n  eX \\<noteq> ERR\n\ngoal (2 subgoals):\n 1. eX \\<noteq> ERR \\<Longrightarrow> eFreshAbs MOD ys y (eAbs MOD xs x eX)\n 2. \\<not> eX \\<noteq> ERR \\<Longrightarrow>\n    eFreshAbs MOD ys y (eAbs MOD xs x eX)", "hence eX: \"eX = OK X\""], ["proof (prove)\nusing this:\n  eX \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. eX = OK X", "unfolding X_def"], ["proof (prove)\nusing this:\n  eX \\<noteq> ERR\n\ngoal (1 subgoal):\n 1. eX = OK (check eX)", "using OK_check"], ["proof (prove)\nusing this:\n  eX \\<noteq> ERR\n  ?eX \\<noteq> ERR \\<Longrightarrow> OK (check ?eX) = ?eX\n\ngoal (1 subgoal):\n 1. eX = OK (check eX)", "by auto"], ["proof (state)\nthis:\n  eX = OK X\n\ngoal (2 subgoals):\n 1. eX \\<noteq> ERR \\<Longrightarrow> eFreshAbs MOD ys y (eAbs MOD xs x eX)\n 2. \\<not> eX \\<noteq> ERR \\<Longrightarrow>\n    eFreshAbs MOD ys y (eAbs MOD xs x eX)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eFreshAbs MOD ys y (eAbs MOD xs x eX)", "unfolding eX"], ["proof (prove)\ngoal (1 subgoal):\n 1. eFreshAbs MOD ys y (eAbs MOD xs x (OK X))", "using assms * eFreshAbs_invert eX"], ["proof (prove)\nusing this:\n  igAbsIPresIGWls MOD\n  igFreshIGAbs2 MOD\n  eFresh MOD ys y eX\n  \\<not> eFreshAbs ?MOD ?ys ?y ?eA \\<Longrightarrow>\n  \\<exists>us s A.\n     ?eA = OK A \\<and>\n     \\<not> igFreshAbs ?MOD ?ys ?y A \\<and> igWlsAbs ?MOD (us, s) A\n  eX = OK X\n\ngoal (1 subgoal):\n 1. eFreshAbs MOD ys y (eAbs MOD xs x (OK X))", "by (cases \"\\<exists> s. isInBar (xs,s) \\<and> igWls MOD s X\")\n    (fastforce simp: igAbsIPresIGWls_def igFreshIGAbs2_def)+"], ["proof (state)\nthis:\n  eFreshAbs MOD ys y (eAbs MOD xs x eX)\n\ngoal (1 subgoal):\n 1. \\<not> eX \\<noteq> ERR \\<Longrightarrow>\n    eFreshAbs MOD ys y (eAbs MOD xs x eX)", "qed auto"], ["proof (state)\nthis:\n  eFreshAbs MOD ys y (eAbs MOD xs x eX)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* HERE *)"], ["", "lemma errMOD_igFreshIGOpSTR:\nfixes MOD :: \"('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs)model\"\nassumes \"igOpIPresIGWls MOD\" and \"igFreshIGOp MOD\"\nshows \"igFreshIGOpSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshIGOpSTR (errMOD MOD)", "unfolding igFreshIGOpSTR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y delta inp binp.\n       eFreshInp MOD ys y inp \\<and>\n       eFreshBinp MOD ys y binp \\<longrightarrow>\n       eFresh MOD ys y (eOp MOD delta inp binp)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y delta inp binp.\n       \\<lbrakk>eFreshInp MOD ys y inp; eFreshBinp MOD ys y binp\\<rbrakk>\n       \\<Longrightarrow> eFresh MOD ys y (eOp MOD delta inp binp)", "subgoal for ys y delta einp ebinp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eFreshInp MOD ys y einp; eFreshBinp MOD ys y ebinp\\<rbrakk>\n    \\<Longrightarrow> eFresh MOD ys y (eOp MOD delta einp ebinp)", "apply(cases \"liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n               liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>eFreshInp MOD ys y einp; eFreshBinp MOD ys y ebinp;\n     liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n     liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\\<rbrakk>\n    \\<Longrightarrow> eFresh MOD ys y (eOp MOD delta einp ebinp)\n 2. \\<lbrakk>eFreshInp MOD ys y einp; eFreshBinp MOD ys y ebinp;\n     \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n             liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp)\\<rbrakk>\n    \\<Longrightarrow> eFresh MOD ys y (eOp MOD delta einp ebinp)", "using assms"], ["proof (prove)\nusing this:\n  igOpIPresIGWls MOD\n  igFreshIGOp MOD\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eFreshInp MOD ys y einp; eFreshBinp MOD ys y ebinp;\n     liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n     liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\\<rbrakk>\n    \\<Longrightarrow> eFresh MOD ys y (eOp MOD delta einp ebinp)\n 2. \\<lbrakk>eFreshInp MOD ys y einp; eFreshBinp MOD ys y ebinp;\n     \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n             liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp)\\<rbrakk>\n    \\<Longrightarrow> eFresh MOD ys y (eOp MOD delta einp ebinp)", "by (simp_all add: igOpIPresIGWls_def  igFreshIGOp_def)\n(metis eFreshBinp_simp eFreshInp_simp eFresh_invert eOp_invert)+"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma errMOD_igFreshClsSTR:\nassumes \"igConsIPresIGWls MOD\" and \"igFreshCls MOD\"\nshows \"igFreshClsSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshClsSTR (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igConsIPresIGWls MOD\n  igFreshCls MOD\n\ngoal (1 subgoal):\n 1. igFreshClsSTR (errMOD MOD)", "unfolding igConsIPresIGWls_def igFreshCls_def igFreshClsSTR_def"], ["proof (prove)\nusing this:\n  igVarIPresIGWls MOD \\<and> igAbsIPresIGWls MOD \\<and> igOpIPresIGWls MOD\n  igFreshIGVar MOD \\<and>\n  igFreshIGAbs1 MOD \\<and> igFreshIGAbs2 MOD \\<and> igFreshIGOp MOD\n\ngoal (1 subgoal):\n 1. igFreshIGVar (errMOD MOD) \\<and>\n    igFreshIGAbs1STR (errMOD MOD) \\<and>\n    igFreshIGAbs2STR (errMOD MOD) \\<and> igFreshIGOpSTR (errMOD MOD)", "using\nerrMOD_igFreshIGVarSTR\nerrMOD_igFreshIGAbs1STR errMOD_igFreshIGAbs2STR\nerrMOD_igFreshIGOpSTR"], ["proof (prove)\nusing this:\n  igVarIPresIGWls MOD \\<and> igAbsIPresIGWls MOD \\<and> igOpIPresIGWls MOD\n  igFreshIGVar MOD \\<and>\n  igFreshIGAbs1 MOD \\<and> igFreshIGAbs2 MOD \\<and> igFreshIGOp MOD\n  \\<lbrakk>igVarIPresIGWls ?MOD; igFreshIGVar ?MOD\\<rbrakk>\n  \\<Longrightarrow> igFreshIGVar (errMOD ?MOD)\n  \\<lbrakk>igAbsIPresIGWls ?MOD; igFreshIGAbs1 ?MOD\\<rbrakk>\n  \\<Longrightarrow> igFreshIGAbs1STR (errMOD ?MOD)\n  \\<lbrakk>igAbsIPresIGWls ?MOD; igFreshIGAbs2 ?MOD\\<rbrakk>\n  \\<Longrightarrow> igFreshIGAbs2STR (errMOD ?MOD)\n  \\<lbrakk>igOpIPresIGWls ?MOD; igFreshIGOp ?MOD\\<rbrakk>\n  \\<Longrightarrow> igFreshIGOpSTR (errMOD ?MOD)\n\ngoal (1 subgoal):\n 1. igFreshIGVar (errMOD MOD) \\<and>\n    igFreshIGAbs1STR (errMOD MOD) \\<and>\n    igFreshIGAbs2STR (errMOD MOD) \\<and> igFreshIGOpSTR (errMOD MOD)", "by auto"], ["", "text\\<open>The strong ``swap\" clauses are satisfied:\\<close>"], ["", "lemma errMOD_igSwapIGVarSTR:\nfixes MOD :: \"('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs)model\"\nassumes \"igVarIPresIGWls MOD\" and \"igSwapIGVar MOD\"\nshows \"igSwapIGVar (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIGVar (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igVarIPresIGWls MOD\n  igSwapIGVar MOD\n\ngoal (1 subgoal):\n 1. igSwapIGVar (errMOD MOD)", "by (simp add: igVarIPresIGWls_def igSwapIGVar_def) (metis eSwap_simp1)"], ["", "lemma errMOD_igSwapIGAbsSTR:\nassumes *: \"igAbsIPresIGWls MOD\" and **: \"igWlsDisj MOD\"\nand ***: \"igSwapIPresIGWls MOD\" and ****: \"igSwapIGAbs MOD\"\nshows \"igSwapIGAbsSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIGAbsSTR (errMOD MOD)", "unfolding igSwapIGAbsSTR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 xs x X.\n       eSwapAbs MOD zs z1 z2 (eAbs MOD xs x X) =\n       eAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (eSwap MOD zs z1 z2 X)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 xs x X.\n       eSwapAbs MOD zs z1 z2 (eAbs MOD xs x X) =\n       eAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (eSwap MOD zs z1 z2 X)", "subgoal for zs z1 z2 xs x eX"], ["proof (prove)\ngoal (1 subgoal):\n 1. eSwapAbs MOD zs z1 z2 (eAbs MOD xs x eX) =\n    eAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (eSwap MOD zs z1 z2 eX)", "apply (cases eX)"], ["proof (prove)\ngoal (2 subgoals):\n 1. eX = ERR \\<Longrightarrow>\n    eSwapAbs MOD zs z1 z2 (eAbs MOD xs x eX) =\n    eAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (eSwap MOD zs z1 z2 eX)\n 2. \\<And>x2.\n       eX = OK x2 \\<Longrightarrow>\n       eSwapAbs MOD zs z1 z2 (eAbs MOD xs x eX) =\n       eAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (eSwap MOD zs z1 z2 eX)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. eX = ERR \\<Longrightarrow>\n    eSwapAbs MOD zs z1 z2 (eAbs MOD xs x eX) =\n    eAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (eSwap MOD zs z1 z2 eX)", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       eX = OK x2 \\<Longrightarrow>\n       eSwapAbs MOD zs z1 z2 (eAbs MOD xs x eX) =\n       eAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (eSwap MOD zs z1 z2 eX)", "subgoal for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. eX = OK X \\<Longrightarrow>\n    eSwapAbs MOD zs z1 z2 (eAbs MOD xs x eX) =\n    eAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (eSwap MOD zs z1 z2 eX)", "apply(cases \"\\<exists> s. isInBar (xs,s) \\<and> igWls MOD s X\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>eX = OK X;\n     \\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> eSwapAbs MOD zs z1 z2 (eAbs MOD xs x eX) =\n                      eAbs MOD xs (x @xs[z1 \\<and> z2]_zs)\n                       (eSwap MOD zs z1 z2 eX)\n 2. \\<lbrakk>eX = OK X;\n     \\<nexists>s. isInBar (xs, s) \\<and> igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> eSwapAbs MOD zs z1 z2 (eAbs MOD xs x eX) =\n                      eAbs MOD xs (x @xs[z1 \\<and> z2]_zs)\n                       (eSwap MOD zs z1 z2 eX)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eX = OK X;\n     \\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> eSwapAbs MOD zs z1 z2 (eAbs MOD xs x eX) =\n                      eAbs MOD xs (x @xs[z1 \\<and> z2]_zs)\n                       (eSwap MOD zs z1 z2 eX)", "using assms"], ["proof (prove)\nusing this:\n  igAbsIPresIGWls MOD\n  igWlsDisj MOD\n  igSwapIPresIGWls MOD\n  igSwapIGAbs MOD\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eX = OK X;\n     \\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> eSwapAbs MOD zs z1 z2 (eAbs MOD xs x eX) =\n                      eAbs MOD xs (x @xs[z1 \\<and> z2]_zs)\n                       (eSwap MOD zs z1 z2 eX)", "using assms OK_check"], ["proof (prove)\nusing this:\n  igAbsIPresIGWls MOD\n  igWlsDisj MOD\n  igSwapIPresIGWls MOD\n  igSwapIGAbs MOD\n  igAbsIPresIGWls MOD\n  igWlsDisj MOD\n  igSwapIPresIGWls MOD\n  igSwapIGAbs MOD\n  ?eX \\<noteq> ERR \\<Longrightarrow> OK (check ?eX) = ?eX\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eX = OK X;\n     \\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> eSwapAbs MOD zs z1 z2 (eAbs MOD xs x eX) =\n                      eAbs MOD xs (x @xs[z1 \\<and> z2]_zs)\n                       (eSwap MOD zs z1 z2 eX)", "by (simp_all add: igAbsIPresIGWls_def igSwapIPresIGWls_def igSwapIGAbs_def igWlsDisj_def)  \n     (smt eAbs_simp1 eSwapAbs_simp1 eSwap_simp1 withERR.inject)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eX = OK X;\n     \\<nexists>s. isInBar (xs, s) \\<and> igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> eSwapAbs MOD zs z1 z2 (eAbs MOD xs x eX) =\n                      eAbs MOD xs (x @xs[z1 \\<and> z2]_zs)\n                       (eSwap MOD zs z1 z2 eX)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eX = OK X;\n     \\<nexists>s. isInBar (xs, s) \\<and> igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> eSwapAbs MOD zs z1 z2 (eAbs MOD xs x eX) =\n                      eAbs MOD xs (x @xs[z1 \\<and> z2]_zs)\n                       (eSwap MOD zs z1 z2 eX)", "using assms"], ["proof (prove)\nusing this:\n  igAbsIPresIGWls MOD\n  igWlsDisj MOD\n  igSwapIPresIGWls MOD\n  igSwapIGAbs MOD\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eX = OK X;\n     \\<nexists>s. isInBar (xs, s) \\<and> igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> eSwapAbs MOD zs z1 z2 (eAbs MOD xs x eX) =\n                      eAbs MOD xs (x @xs[z1 \\<and> z2]_zs)\n                       (eSwap MOD zs z1 z2 eX)", "by(simp_all add: igAbsIPresIGWls_def igSwapIPresIGWls_def igSwapIGAbs_def igWlsDisj_def)  \n    (metis check_OK eAbs_nchotomy eSwap_invert)"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma errMOD_igSwapIGOpSTR:\nassumes \"igWlsAbsIsInBar MOD\" and \"igOpIPresIGWls MOD\"\nand \"igSwapIPresIGWls MOD\" and \"igSwapAbsIPresIGWlsAbs MOD\"\nand \"igWlsDisj MOD\" and \"igWlsAbsDisj MOD\"\nand \"igSwapIGOp MOD\"\nshows \"igSwapIGOpSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIGOpSTR (errMOD MOD)", "unfolding igSwapIGOpSTR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 delta inp binp.\n       eSwap MOD zs z1 z2 (eOp MOD delta inp binp) =\n       eOp MOD delta (eSwapInp MOD zs z1 z2 inp)\n        (eSwapBinp MOD zs z1 z2 binp)", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 delta inp binp.\n       eSwap MOD zs z1 z2 (eOp MOD delta inp binp) =\n       eOp MOD delta (eSwapInp MOD zs z1 z2 inp)\n        (eSwapBinp MOD zs z1 z2 binp)", "have 0: \"igSwapInpIPresIGWlsInp MOD \\<and> igSwapBinpIPresIGWlsBinp MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapInpIPresIGWlsInp MOD \\<and> igSwapBinpIPresIGWlsBinp MOD", "using \\<open>igSwapIPresIGWls MOD\\<close>  \\<open>igSwapAbsIPresIGWlsAbs MOD\\<close>\n  imp_igSwapInpIPresIGWlsInp imp_igSwapBinpIPresIGWlsBinp"], ["proof (prove)\nusing this:\n  igSwapIPresIGWls MOD\n  igSwapAbsIPresIGWlsAbs MOD\n  igSwapIPresIGWls ?MOD \\<Longrightarrow> igSwapInpIPresIGWlsInp ?MOD\n  igSwapAbsIPresIGWlsAbs ?MOD \\<Longrightarrow>\n  igSwapBinpIPresIGWlsBinp ?MOD\n\ngoal (1 subgoal):\n 1. igSwapInpIPresIGWlsInp MOD \\<and> igSwapBinpIPresIGWlsBinp MOD", "by auto"], ["proof (state)\nthis:\n  igSwapInpIPresIGWlsInp MOD \\<and> igSwapBinpIPresIGWlsBinp MOD\n\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 delta inp binp.\n       eSwap MOD zs z1 z2 (eOp MOD delta inp binp) =\n       eOp MOD delta (eSwapInp MOD zs z1 z2 inp)\n        (eSwapBinp MOD zs z1 z2 binp)", "have \"igSwapIPresIGWlsSTR (errMOD MOD) \\<and>\n        igSwapAbsIPresIGWlsAbsSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIPresIGWlsSTR (errMOD MOD) \\<and>\n    igSwapAbsIPresIGWlsAbsSTR (errMOD MOD)", "using assms errMOD_igSwapIPresIGWlsSTR\n        errMOD_igSwapAbsIPresIGWlsAbsSTR"], ["proof (prove)\nusing this:\n  igWlsAbsIsInBar MOD\n  igOpIPresIGWls MOD\n  igSwapIPresIGWls MOD\n  igSwapAbsIPresIGWlsAbs MOD\n  igWlsDisj MOD\n  igWlsAbsDisj MOD\n  igSwapIGOp MOD\n  \\<lbrakk>igSwapIPresIGWls ?MOD; igWlsDisj ?MOD\\<rbrakk>\n  \\<Longrightarrow> igSwapIPresIGWlsSTR (errMOD ?MOD)\n  \\<lbrakk>igSwapAbsIPresIGWlsAbs ?MOD; igWlsAbsDisj ?MOD;\n   igWlsAbsIsInBar ?MOD\\<rbrakk>\n  \\<Longrightarrow> igSwapAbsIPresIGWlsAbsSTR (errMOD ?MOD)\n\ngoal (1 subgoal):\n 1. igSwapIPresIGWlsSTR (errMOD MOD) \\<and>\n    igSwapAbsIPresIGWlsAbsSTR (errMOD MOD)", "by auto"], ["proof (state)\nthis:\n  igSwapIPresIGWlsSTR (errMOD MOD) \\<and>\n  igSwapAbsIPresIGWlsAbsSTR (errMOD MOD)\n\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 delta inp binp.\n       eSwap MOD zs z1 z2 (eOp MOD delta inp binp) =\n       eOp MOD delta (eSwapInp MOD zs z1 z2 inp)\n        (eSwapBinp MOD zs z1 z2 binp)", "hence 1: \"igSwapInpIPresIGWlsInpSTR (errMOD MOD) \\<and>\n            igSwapBinpIPresIGWlsBinpSTR (errMOD MOD)\""], ["proof (prove)\nusing this:\n  igSwapIPresIGWlsSTR (errMOD MOD) \\<and>\n  igSwapAbsIPresIGWlsAbsSTR (errMOD MOD)\n\ngoal (1 subgoal):\n 1. igSwapInpIPresIGWlsInpSTR (errMOD MOD) \\<and>\n    igSwapBinpIPresIGWlsBinpSTR (errMOD MOD)", "using imp_igSwapInpIPresIGWlsInpSTR\n        imp_igSwapBinpIPresIGWlsBinpSTR"], ["proof (prove)\nusing this:\n  igSwapIPresIGWlsSTR (errMOD MOD) \\<and>\n  igSwapAbsIPresIGWlsAbsSTR (errMOD MOD)\n  igSwapIPresIGWlsSTR ?MOD \\<Longrightarrow> igSwapInpIPresIGWlsInpSTR ?MOD\n  igSwapAbsIPresIGWlsAbsSTR ?MOD \\<Longrightarrow>\n  igSwapBinpIPresIGWlsBinpSTR ?MOD\n\ngoal (1 subgoal):\n 1. igSwapInpIPresIGWlsInpSTR (errMOD MOD) \\<and>\n    igSwapBinpIPresIGWlsBinpSTR (errMOD MOD)", "by auto"], ["proof (state)\nthis:\n  igSwapInpIPresIGWlsInpSTR (errMOD MOD) \\<and>\n  igSwapBinpIPresIGWlsBinpSTR (errMOD MOD)\n\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 delta inp binp.\n       eSwap MOD zs z1 z2 (eOp MOD delta inp binp) =\n       eOp MOD delta (eSwapInp MOD zs z1 z2 inp)\n        (eSwapBinp MOD zs z1 z2 binp)", "fix zs::'varSort and z1 z2 ::'var and delta einp ebinp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 delta inp binp.\n       eSwap MOD zs z1 z2 (eOp MOD delta inp binp) =\n       eOp MOD delta (eSwapInp MOD zs z1 z2 inp)\n        (eSwapBinp MOD zs z1 z2 binp)", "let ?Left = \"eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 delta inp binp.\n       eSwap MOD zs z1 z2 (eOp MOD delta inp binp) =\n       eOp MOD delta (eSwapInp MOD zs z1 z2 inp)\n        (eSwapBinp MOD zs z1 z2 binp)", "let ?einpsw = \"eSwapInp MOD zs z1 z2 einp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 delta inp binp.\n       eSwap MOD zs z1 z2 (eOp MOD delta inp binp) =\n       eOp MOD delta (eSwapInp MOD zs z1 z2 inp)\n        (eSwapBinp MOD zs z1 z2 binp)", "let ?ebinpsw = \"eSwapBinp MOD zs z1 z2 ebinp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 delta inp binp.\n       eSwap MOD zs z1 z2 (eOp MOD delta inp binp) =\n       eOp MOD delta (eSwapInp MOD zs z1 z2 inp)\n        (eSwapBinp MOD zs z1 z2 binp)", "let ?Right = \"eOp MOD delta ?einpsw ?ebinpsw\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 delta inp binp.\n       eSwap MOD zs z1 z2 (eOp MOD delta inp binp) =\n       eOp MOD delta (eSwapInp MOD zs z1 z2 inp)\n        (eSwapBinp MOD zs z1 z2 binp)", "show \"?Left = ?Right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "proof(cases \"liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n               liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\")"], ["proof (state)\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "case True"], ["proof (state)\nthis:\n  liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n  liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "note t = True"], ["proof (state)\nthis:\n  liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n  liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "moreover"], ["proof (state)\nthis:\n  liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n  liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "obtain inp and binp where\n    \"inp = checkI einp\" and  \"binp = checkI ebinp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>inp binp.\n        \\<lbrakk>inp = checkI einp; binp = checkI ebinp\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  inp = checkI einp\n  binp = checkI ebinp\n\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "ultimately"], ["proof (chain)\npicking this:\n  liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n  liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n  inp = checkI einp\n  binp = checkI ebinp", "have einp: \"einp = OKI inp\"   \"ebinp = OKI binp\""], ["proof (prove)\nusing this:\n  liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n  liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n  inp = checkI einp\n  binp = checkI ebinp\n\ngoal (1 subgoal):\n 1. einp = OKI inp &&& ebinp = OKI binp", "by auto"], ["proof (state)\nthis:\n  einp = OKI inp\n  ebinp = OKI binp\n\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "proof(cases \"igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\")"], ["proof (state)\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "case False"], ["proof (state)\nthis:\n  \\<not> (igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp)\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "hence \"?Left = ERR\""], ["proof (prove)\nusing this:\n  \\<not> (igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp)\n\ngoal (1 subgoal):\n 1. eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) = ERR", "unfolding einp"], ["proof (prove)\nusing this:\n  \\<not> (igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp)\n\ngoal (1 subgoal):\n 1. eSwap MOD zs z1 z2 (eOp MOD delta (OKI inp) (OKI binp)) = ERR", "by auto"], ["proof (state)\nthis:\n  eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) = ERR\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "have \"\\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)", "unfolding einp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta (OKI inp) \\<and>\n            eWlsBinp MOD delta (OKI binp))", "using False"], ["proof (prove)\nusing this:\n  \\<not> (igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp)\n\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta (OKI inp) \\<and>\n            eWlsBinp MOD delta (OKI binp))", "by auto"], ["proof (state)\nthis:\n  \\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "hence 2: \"\\<not> (eWlsInp MOD delta ?einpsw \\<and> eWlsBinp MOD delta ?ebinpsw)\""], ["proof (prove)\nusing this:\n  \\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)\n\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta (eSwapInp MOD zs z1 z2 einp) \\<and>\n            eWlsBinp MOD delta (eSwapBinp MOD zs z1 z2 ebinp))", "using 1"], ["proof (prove)\nusing this:\n  \\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)\n  igSwapInpIPresIGWlsInpSTR (errMOD MOD) \\<and>\n  igSwapBinpIPresIGWlsBinpSTR (errMOD MOD)\n\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta (eSwapInp MOD zs z1 z2 einp) \\<and>\n            eWlsBinp MOD delta (eSwapBinp MOD zs z1 z2 ebinp))", "unfolding igSwapInpIPresIGWlsInpSTR_def\n                             igSwapBinpIPresIGWlsBinpSTR_def"], ["proof (prove)\nusing this:\n  \\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)\n  (\\<forall>zs z1 z2 delta inp.\n      eWlsInp MOD delta (eSwapInp MOD zs z1 z2 inp) =\n      eWlsInp MOD delta inp) \\<and>\n  (\\<forall>zs z1 z2 delta binp.\n      eWlsBinp MOD delta (eSwapBinp MOD zs z1 z2 binp) =\n      eWlsBinp MOD delta binp)\n\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta (eSwapInp MOD zs z1 z2 einp) \\<and>\n            eWlsBinp MOD delta (eSwapBinp MOD zs z1 z2 ebinp))", "by auto"], ["proof (state)\nthis:\n  \\<not> (eWlsInp MOD delta (eSwapInp MOD zs z1 z2 einp) \\<and>\n          eWlsBinp MOD delta (eSwapBinp MOD zs z1 z2 ebinp))\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "{"], ["proof (state)\nthis:\n  \\<not> (eWlsInp MOD delta (eSwapInp MOD zs z1 z2 einp) \\<and>\n          eWlsBinp MOD delta (eSwapBinp MOD zs z1 z2 ebinp))\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "fix X"], ["proof (state)\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "assume \"?Right = OK X\""], ["proof (state)\nthis:\n  eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n   (eSwapBinp MOD zs z1 z2 ebinp) =\n  OK X\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "then"], ["proof (chain)\npicking this:\n  eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n   (eSwapBinp MOD zs z1 z2 ebinp) =\n  OK X", "obtain inpsw and binpsw\n       where \"?einpsw = OKI inpsw\" and \"?ebinpsw = OKI binpsw\"\n       and \"igWlsInp MOD delta inpsw\" and \"igWlsBinp MOD delta binpsw\"\n       and \"X = igOp MOD delta inpsw binpsw\""], ["proof (prove)\nusing this:\n  eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n   (eSwapBinp MOD zs z1 z2 ebinp) =\n  OK X\n\ngoal (1 subgoal):\n 1. (\\<And>inpsw binpsw.\n        \\<lbrakk>eSwapInp MOD zs z1 z2 einp = OKI inpsw;\n         eSwapBinp MOD zs z1 z2 ebinp = OKI binpsw;\n         igWlsInp MOD delta inpsw; igWlsBinp MOD delta binpsw;\n         X = igOp MOD delta inpsw binpsw\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eOp_invert[of MOD delta ?einpsw ?ebinpsw X]"], ["proof (prove)\nusing this:\n  eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n   (eSwapBinp MOD zs z1 z2 ebinp) =\n  OK X\n  eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n   (eSwapBinp MOD zs z1 z2 ebinp) =\n  OK X \\<Longrightarrow>\n  \\<exists>inp binp.\n     eSwapInp MOD zs z1 z2 einp = OKI inp \\<and>\n     eSwapBinp MOD zs z1 z2 ebinp = OKI binp \\<and>\n     X = igOp MOD delta inp binp \\<and>\n     igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n\ngoal (1 subgoal):\n 1. (\\<And>inpsw binpsw.\n        \\<lbrakk>eSwapInp MOD zs z1 z2 einp = OKI inpsw;\n         eSwapBinp MOD zs z1 z2 ebinp = OKI binpsw;\n         igWlsInp MOD delta inpsw; igWlsBinp MOD delta binpsw;\n         X = igOp MOD delta inpsw binpsw\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eSwapInp MOD zs z1 z2 einp = OKI inpsw\n  eSwapBinp MOD zs z1 z2 ebinp = OKI binpsw\n  igWlsInp MOD delta inpsw\n  igWlsBinp MOD delta binpsw\n  X = igOp MOD delta inpsw binpsw\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "hence False"], ["proof (prove)\nusing this:\n  eSwapInp MOD zs z1 z2 einp = OKI inpsw\n  eSwapBinp MOD zs z1 z2 ebinp = OKI binpsw\n  igWlsInp MOD delta inpsw\n  igWlsBinp MOD delta binpsw\n  X = igOp MOD delta inpsw binpsw\n\ngoal (1 subgoal):\n 1. False", "using 2"], ["proof (prove)\nusing this:\n  eSwapInp MOD zs z1 z2 einp = OKI inpsw\n  eSwapBinp MOD zs z1 z2 ebinp = OKI binpsw\n  igWlsInp MOD delta inpsw\n  igWlsBinp MOD delta binpsw\n  X = igOp MOD delta inpsw binpsw\n  \\<not> (eWlsInp MOD delta (eSwapInp MOD zs z1 z2 einp) \\<and>\n          eWlsBinp MOD delta (eSwapBinp MOD zs z1 z2 ebinp))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "}"], ["proof (state)\nthis:\n  eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n   (eSwapBinp MOD zs z1 z2 ebinp) =\n  OK ?X109 \\<Longrightarrow>\n  False\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "with \\<open>?Left = ERR\\<close>"], ["proof (chain)\npicking this:\n  eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) = ERR\n  eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n   (eSwapBinp MOD zs z1 z2 ebinp) =\n  OK ?X109 \\<Longrightarrow>\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) = ERR\n  eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n   (eSwapBinp MOD zs z1 z2 ebinp) =\n  OK ?X109 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "by (cases ?Right) auto"], ["proof (state)\nthis:\n  eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n  eOp MOD delta (eSwapInp MOD zs z1 z2 einp) (eSwapBinp MOD zs z1 z2 ebinp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "case True"], ["proof (state)\nthis:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "moreover"], ["proof (state)\nthis:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "have \"igWls MOD (stOf delta) (igOp MOD delta inp binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls MOD (stOf delta) (igOp MOD delta inp binp)", "using True \\<open>igOpIPresIGWls MOD\\<close>"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igOpIPresIGWls MOD\n\ngoal (1 subgoal):\n 1. igWls MOD (stOf delta) (igOp MOD delta inp binp)", "unfolding igOpIPresIGWls_def"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  \\<forall>delta inp binp.\n     igWlsInp MOD delta inp \\<and>\n     igWlsBinp MOD delta binp \\<longrightarrow>\n     igWls MOD (stOf delta) (igOp MOD delta inp binp)\n\ngoal (1 subgoal):\n 1. igWls MOD (stOf delta) (igOp MOD delta inp binp)", "by simp"], ["proof (state)\nthis:\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "moreover"], ["proof (state)\nthis:\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "have \"igWlsInp MOD delta (igSwapInp MOD zs z1 z2 inp) \\<and>\n                     igWlsBinp MOD delta (igSwapBinp MOD zs z1 z2 binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (igSwapInp MOD zs z1 z2 inp) \\<and>\n    igWlsBinp MOD delta (igSwapBinp MOD zs z1 z2 binp)", "using 0"], ["proof (prove)\nusing this:\n  igSwapInpIPresIGWlsInp MOD \\<and> igSwapBinpIPresIGWlsBinp MOD\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (igSwapInp MOD zs z1 z2 inp) \\<and>\n    igWlsBinp MOD delta (igSwapBinp MOD zs z1 z2 binp)", "unfolding igSwapInpIPresIGWlsInp_def igSwapBinpIPresIGWlsBinp_def"], ["proof (prove)\nusing this:\n  (\\<forall>zs z1 z2 delta inp.\n      igWlsInp MOD delta inp \\<longrightarrow>\n      igWlsInp MOD delta (igSwapInp MOD zs z1 z2 inp)) \\<and>\n  (\\<forall>zs z1 z2 delta binp.\n      igWlsBinp MOD delta binp \\<longrightarrow>\n      igWlsBinp MOD delta (igSwapBinp MOD zs z1 z2 binp))\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (igSwapInp MOD zs z1 z2 inp) \\<and>\n    igWlsBinp MOD delta (igSwapBinp MOD zs z1 z2 binp)", "using True"], ["proof (prove)\nusing this:\n  (\\<forall>zs z1 z2 delta inp.\n      igWlsInp MOD delta inp \\<longrightarrow>\n      igWlsInp MOD delta (igSwapInp MOD zs z1 z2 inp)) \\<and>\n  (\\<forall>zs z1 z2 delta binp.\n      igWlsBinp MOD delta binp \\<longrightarrow>\n      igWlsBinp MOD delta (igSwapBinp MOD zs z1 z2 binp))\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (igSwapInp MOD zs z1 z2 inp) \\<and>\n    igWlsBinp MOD delta (igSwapBinp MOD zs z1 z2 binp)", "by simp"], ["proof (state)\nthis:\n  igWlsInp MOD delta (igSwapInp MOD zs z1 z2 inp) \\<and>\n  igWlsBinp MOD delta (igSwapBinp MOD zs z1 z2 binp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "ultimately"], ["proof (chain)\npicking this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n  igWlsInp MOD delta (igSwapInp MOD zs z1 z2 inp) \\<and>\n  igWlsBinp MOD delta (igSwapBinp MOD zs z1 z2 binp)", "show ?thesis"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n  igWlsInp MOD delta (igSwapInp MOD zs z1 z2 inp) \\<and>\n  igWlsBinp MOD delta (igSwapBinp MOD zs z1 z2 binp)\n\ngoal (1 subgoal):\n 1. eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "using \\<open>igSwapIGOp MOD\\<close>"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n  igWlsInp MOD delta (igSwapInp MOD zs z1 z2 inp) \\<and>\n  igWlsBinp MOD delta (igSwapBinp MOD zs z1 z2 binp)\n  igSwapIGOp MOD\n\ngoal (1 subgoal):\n 1. eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "unfolding einp igSwapIGOp_def"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n  igWlsInp MOD delta (igSwapInp MOD zs z1 z2 inp) \\<and>\n  igWlsBinp MOD delta (igSwapBinp MOD zs z1 z2 binp)\n  \\<forall>zs z1 z2 delta inp binp.\n     igWlsInp MOD delta inp \\<and>\n     igWlsBinp MOD delta binp \\<longrightarrow>\n     igSwap MOD zs z1 z2 (igOp MOD delta inp binp) =\n     igOp MOD delta (igSwapInp MOD zs z1 z2 inp)\n      (igSwapBinp MOD zs z1 z2 binp)\n\ngoal (1 subgoal):\n 1. eSwap MOD zs z1 z2 (eOp MOD delta (OKI inp) (OKI binp)) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 (OKI inp))\n     (eSwapBinp MOD zs z1 z2 (OKI binp))", "by auto"], ["proof (state)\nthis:\n  eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n  eOp MOD delta (eSwapInp MOD zs z1 z2 einp) (eSwapBinp MOD zs z1 z2 ebinp)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n  eOp MOD delta (eSwapInp MOD zs z1 z2 einp) (eSwapBinp MOD zs z1 z2 ebinp)\n\ngoal (1 subgoal):\n 1. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSwapInp MOD zs z1 z2 einp)\n     (eSwapBinp MOD zs z1 z2 ebinp)", "qed auto"], ["proof (state)\nthis:\n  eSwap MOD zs z1 z2 (eOp MOD delta einp ebinp) =\n  eOp MOD delta (eSwapInp MOD zs z1 z2 einp) (eSwapBinp MOD zs z1 z2 ebinp)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma errMOD_igSwapClsSTR:\nassumes \"igWlsAllDisj MOD\" and \"igWlsDisj MOD\"\nand \"igWlsAbsIsInBar MOD\" and \"igConsIPresIGWls MOD\"\nand \"igSwapAllIPresIGWlsAll MOD\" and \"igSwapCls MOD\"\nshows \"igSwapClsSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapClsSTR (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igWlsAllDisj MOD\n  igWlsDisj MOD\n  igWlsAbsIsInBar MOD\n  igConsIPresIGWls MOD\n  igSwapAllIPresIGWlsAll MOD\n  igSwapCls MOD\n\ngoal (1 subgoal):\n 1. igSwapClsSTR (errMOD MOD)", "unfolding igWlsAllDisj_def igConsIPresIGWls_def igSwapCls_def\nigSwapAllIPresIGWlsAll_def igSwapClsSTR_def"], ["proof (prove)\nusing this:\n  igWlsDisj MOD \\<and> igWlsAbsDisj MOD\n  igWlsDisj MOD\n  igWlsAbsIsInBar MOD\n  igVarIPresIGWls MOD \\<and> igAbsIPresIGWls MOD \\<and> igOpIPresIGWls MOD\n  igSwapIPresIGWls MOD \\<and> igSwapAbsIPresIGWlsAbs MOD\n  igSwapIGVar MOD \\<and> igSwapIGAbs MOD \\<and> igSwapIGOp MOD\n\ngoal (1 subgoal):\n 1. igSwapIGVar (errMOD MOD) \\<and>\n    igSwapIGAbsSTR (errMOD MOD) \\<and> igSwapIGOpSTR (errMOD MOD)", "using\nerrMOD_igSwapIGVarSTR[of MOD]\nerrMOD_igSwapIGAbsSTR[of MOD]\nerrMOD_igSwapIGOpSTR[of MOD]"], ["proof (prove)\nusing this:\n  igWlsDisj MOD \\<and> igWlsAbsDisj MOD\n  igWlsDisj MOD\n  igWlsAbsIsInBar MOD\n  igVarIPresIGWls MOD \\<and> igAbsIPresIGWls MOD \\<and> igOpIPresIGWls MOD\n  igSwapIPresIGWls MOD \\<and> igSwapAbsIPresIGWlsAbs MOD\n  igSwapIGVar MOD \\<and> igSwapIGAbs MOD \\<and> igSwapIGOp MOD\n  \\<lbrakk>igVarIPresIGWls MOD; igSwapIGVar MOD\\<rbrakk>\n  \\<Longrightarrow> igSwapIGVar (errMOD MOD)\n  \\<lbrakk>igAbsIPresIGWls MOD; igWlsDisj MOD; igSwapIPresIGWls MOD;\n   igSwapIGAbs MOD\\<rbrakk>\n  \\<Longrightarrow> igSwapIGAbsSTR (errMOD MOD)\n  \\<lbrakk>igWlsAbsIsInBar MOD; igOpIPresIGWls MOD; igSwapIPresIGWls MOD;\n   igSwapAbsIPresIGWlsAbs MOD; igWlsDisj MOD; igWlsAbsDisj MOD;\n   igSwapIGOp MOD\\<rbrakk>\n  \\<Longrightarrow> igSwapIGOpSTR (errMOD MOD)\n\ngoal (1 subgoal):\n 1. igSwapIGVar (errMOD MOD) \\<and>\n    igSwapIGAbsSTR (errMOD MOD) \\<and> igSwapIGOpSTR (errMOD MOD)", "by simp"], ["", "text\\<open>The strong ``subst\" clauses are satisfied:\\<close>"], ["", "lemma errMOD_igSubstIGVar1STR:\nassumes \"igVarIPresIGWls MOD\" and \"igSubstIGVar1 MOD\"\nshows \"igSubstIGVar1STR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGVar1STR (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igVarIPresIGWls MOD\n  igSubstIGVar1 MOD\n\ngoal (1 subgoal):\n 1. igSubstIGVar1STR (errMOD MOD)", "by (simp add: igSubstIGVar1STR_def igVarIPresIGWls_def igSubstIGVar1_def)\n   (metis eSubst_simp1 eWls_invert)"], ["", "lemma errMOD_igSubstIGVar2STR:\nassumes \"igVarIPresIGWls MOD\" and \"igSubstIGVar2 MOD\"\nshows \"igSubstIGVar2STR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGVar2STR (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igVarIPresIGWls MOD\n  igSubstIGVar2 MOD\n\ngoal (1 subgoal):\n 1. igSubstIGVar2STR (errMOD MOD)", "by (simp add: igSubstIGVar2STR_def igVarIPresIGWls_def igSubstIGVar2_def) \n   (metis eSubst_simp1 eWls_invert)"], ["", "lemma errMOD_igSubstIGAbsSTR:\nfixes MOD :: \"('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs)model\"\nassumes *: \"igAbsIPresIGWls MOD\" and **: \"igWlsDisj MOD\"\nand ***: \"igSubstIPresIGWls MOD\" and ****: \"igSubstIGAbs MOD\"\nshows \"igSubstIGAbsSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGAbsSTR (errMOD MOD)", "unfolding igSubstIGAbsSTR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y Y xs x X.\n       (xs \\<noteq> ys \\<or> x \\<noteq> y) \\<and>\n       eFresh MOD xs x Y \\<longrightarrow>\n       eSubstAbs MOD ys Y y (eAbs MOD xs x X) =\n       eAbs MOD xs x (eSubst MOD ys Y y X)", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y xs x X.\n       \\<lbrakk>xs \\<noteq> ys \\<or> x \\<noteq> y;\n        eFresh MOD xs x Y\\<rbrakk>\n       \\<Longrightarrow> eSubstAbs MOD ys Y y (eAbs MOD xs x X) =\n                         eAbs MOD xs x (eSubst MOD ys Y y X)", "fix ys xs ::'varSort and y x ::'var and eX eY"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y xs x X.\n       \\<lbrakk>xs \\<noteq> ys \\<or> x \\<noteq> y;\n        eFresh MOD xs x Y\\<rbrakk>\n       \\<Longrightarrow> eSubstAbs MOD ys Y y (eAbs MOD xs x X) =\n                         eAbs MOD xs x (eSubst MOD ys Y y X)", "assume diff: \"xs \\<noteq> ys \\<or> x \\<noteq> y\"\n  and x_fresh_Y: \"eFresh MOD xs x eY\""], ["proof (state)\nthis:\n  xs \\<noteq> ys \\<or> x \\<noteq> y\n  eFresh MOD xs x eY\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y xs x X.\n       \\<lbrakk>xs \\<noteq> ys \\<or> x \\<noteq> y;\n        eFresh MOD xs x Y\\<rbrakk>\n       \\<Longrightarrow> eSubstAbs MOD ys Y y (eAbs MOD xs x X) =\n                         eAbs MOD xs x (eSubst MOD ys Y y X)", "show \"eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n        eAbs MOD xs x (eSubst MOD ys eY y eX)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "proof(cases \"eX \\<noteq> ERR \\<and> eY \\<noteq> ERR\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eX \\<noteq> ERR \\<and> eY \\<noteq> ERR \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> (eX \\<noteq> ERR \\<and> eY \\<noteq> ERR) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "case True"], ["proof (state)\nthis:\n  eX \\<noteq> ERR \\<and> eY \\<noteq> ERR\n\ngoal (2 subgoals):\n 1. eX \\<noteq> ERR \\<and> eY \\<noteq> ERR \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> (eX \\<noteq> ERR \\<and> eY \\<noteq> ERR) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "define X and Y where \"X \\<equiv> check eX\" and \"Y \\<equiv> check eY\""], ["proof (state)\nthis:\n  X \\<equiv> check eX\n  Y \\<equiv> check eY\n\ngoal (2 subgoals):\n 1. eX \\<noteq> ERR \\<and> eY \\<noteq> ERR \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> (eX \\<noteq> ERR \\<and> eY \\<noteq> ERR) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "hence eX: \"eX = OK X\" and eY: \"eY = OK Y\""], ["proof (prove)\nusing this:\n  X \\<equiv> check eX\n  Y \\<equiv> check eY\n\ngoal (1 subgoal):\n 1. eX = OK X &&& eY = OK Y", "unfolding X_def Y_def"], ["proof (prove)\nusing this:\n  check eX \\<equiv> check eX\n  check eY \\<equiv> check eY\n\ngoal (1 subgoal):\n 1. eX = OK (check eX) &&& eY = OK (check eY)", "using True OK_check"], ["proof (prove)\nusing this:\n  check eX \\<equiv> check eX\n  check eY \\<equiv> check eY\n  eX \\<noteq> ERR \\<and> eY \\<noteq> ERR\n  ?eX \\<noteq> ERR \\<Longrightarrow> OK (check ?eX) = ?eX\n\ngoal (1 subgoal):\n 1. eX = OK (check eX) &&& eY = OK (check eY)", "by auto"], ["proof (state)\nthis:\n  eX = OK X\n  eY = OK Y\n\ngoal (2 subgoals):\n 1. eX \\<noteq> ERR \\<and> eY \\<noteq> ERR \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> (eX \\<noteq> ERR \\<and> eY \\<noteq> ERR) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "proof(cases \"(\\<exists> s. isInBar (xs,s) \\<and> igWls MOD s X) \\<and> igWls MOD (asSort ys) Y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "case True"], ["proof (state)\nthis:\n  (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n  igWls MOD (asSort ys) Y\n\ngoal (2 subgoals):\n 1. (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "then"], ["proof (chain)\npicking this:\n  (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n  igWls MOD (asSort ys) Y", "obtain s where xs_s: \"isInBar (xs, s)\" and X: \"igWls MOD s X\" \n      and Y: \"igWls MOD (asSort ys) Y\""], ["proof (prove)\nusing this:\n  (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n  igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>isInBar (xs, s); igWls MOD s X;\n         igWls MOD (asSort ys) Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  isInBar (xs, s)\n  igWls MOD s X\n  igWls MOD (asSort ys) Y\n\ngoal (2 subgoals):\n 1. (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "hence \"igWlsAbs MOD (xs,s) (igAbs MOD xs x X)\""], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  igWls MOD s X\n  igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. igWlsAbs MOD (xs, s) (igAbs MOD xs x X)", "using *"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  igWls MOD s X\n  igWls MOD (asSort ys) Y\n  igAbsIPresIGWls MOD\n\ngoal (1 subgoal):\n 1. igWlsAbs MOD (xs, s) (igAbs MOD xs x X)", "unfolding igAbsIPresIGWls_def"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  igWls MOD s X\n  igWls MOD (asSort ys) Y\n  \\<forall>xs s x X.\n     isInBar (xs, s) \\<and> igWls MOD s X \\<longrightarrow>\n     igWlsAbs MOD (xs, s) (igAbs MOD xs x X)\n\ngoal (1 subgoal):\n 1. igWlsAbs MOD (xs, s) (igAbs MOD xs x X)", "by simp"], ["proof (state)\nthis:\n  igWlsAbs MOD (xs, s) (igAbs MOD xs x X)\n\ngoal (2 subgoals):\n 1. (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "moreover"], ["proof (state)\nthis:\n  igWlsAbs MOD (xs, s) (igAbs MOD xs x X)\n\ngoal (2 subgoals):\n 1. (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "have \"igWls MOD s (igSubst MOD ys Y y X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls MOD s (igSubst MOD ys Y y X)", "using X Y ***"], ["proof (prove)\nusing this:\n  igWls MOD s X\n  igWls MOD (asSort ys) Y\n  igSubstIPresIGWls MOD\n\ngoal (1 subgoal):\n 1. igWls MOD s (igSubst MOD ys Y y X)", "unfolding igSubstIPresIGWls_def"], ["proof (prove)\nusing this:\n  igWls MOD s X\n  igWls MOD (asSort ys) Y\n  \\<forall>ys Y y s X.\n     igWls MOD (asSort ys) Y \\<and> igWls MOD s X \\<longrightarrow>\n     igWls MOD s (igSubst MOD ys Y y X)\n\ngoal (1 subgoal):\n 1. igWls MOD s (igSubst MOD ys Y y X)", "by simp"], ["proof (state)\nthis:\n  igWls MOD s (igSubst MOD ys Y y X)\n\ngoal (2 subgoals):\n 1. (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "moreover"], ["proof (state)\nthis:\n  igWls MOD s (igSubst MOD ys Y y X)\n\ngoal (2 subgoals):\n 1. (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "have \"igFresh MOD xs x Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFresh MOD xs x Y", "using x_fresh_Y Y"], ["proof (prove)\nusing this:\n  eFresh MOD xs x eY\n  igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. igFresh MOD xs x Y", "unfolding eY"], ["proof (prove)\nusing this:\n  eFresh MOD xs x (OK Y)\n  igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. igFresh MOD xs x Y", "by simp"], ["proof (state)\nthis:\n  igFresh MOD xs x Y\n\ngoal (2 subgoals):\n 1. (\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "ultimately"], ["proof (chain)\npicking this:\n  igWlsAbs MOD (xs, s) (igAbs MOD xs x X)\n  igWls MOD s (igSubst MOD ys Y y X)\n  igFresh MOD xs x Y", "show ?thesis"], ["proof (prove)\nusing this:\n  igWlsAbs MOD (xs, s) (igAbs MOD xs x X)\n  igWls MOD s (igSubst MOD ys Y y X)\n  igFresh MOD xs x Y\n\ngoal (1 subgoal):\n 1. eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "unfolding eX eY"], ["proof (prove)\nusing this:\n  igWlsAbs MOD (xs, s) (igAbs MOD xs x X)\n  igWls MOD s (igSubst MOD ys Y y X)\n  igFresh MOD xs x Y\n\ngoal (1 subgoal):\n 1. eSubstAbs MOD ys (OK Y) y (eAbs MOD xs x (OK X)) =\n    eAbs MOD xs x (eSubst MOD ys (OK Y) y (OK X))", "using xs_s X Y"], ["proof (prove)\nusing this:\n  igWlsAbs MOD (xs, s) (igAbs MOD xs x X)\n  igWls MOD s (igSubst MOD ys Y y X)\n  igFresh MOD xs x Y\n  isInBar (xs, s)\n  igWls MOD s X\n  igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. eSubstAbs MOD ys (OK Y) y (eAbs MOD xs x (OK X)) =\n    eAbs MOD xs x (eSubst MOD ys (OK Y) y (OK X))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igWlsAbs MOD (xs, s) (igAbs MOD xs x X);\n     igWls MOD s (igSubst MOD ys Y y X); igFresh MOD xs x Y;\n     isInBar (xs, s); igWls MOD s X; igWls MOD (asSort ys) Y\\<rbrakk>\n    \\<Longrightarrow> igSubstAbs MOD ys Y y (igAbs MOD xs x X) =\n                      igAbs MOD xs x (igSubst MOD ys Y y X)", "using x_fresh_Y diff ****"], ["proof (prove)\nusing this:\n  eFresh MOD xs x eY\n  xs \\<noteq> ys \\<or> x \\<noteq> y\n  igSubstIGAbs MOD\n\ngoal (1 subgoal):\n 1. \\<lbrakk>igWlsAbs MOD (xs, s) (igAbs MOD xs x X);\n     igWls MOD s (igSubst MOD ys Y y X); igFresh MOD xs x Y;\n     isInBar (xs, s); igWls MOD s X; igWls MOD (asSort ys) Y\\<rbrakk>\n    \\<Longrightarrow> igSubstAbs MOD ys Y y (igAbs MOD xs x X) =\n                      igAbs MOD xs x (igSubst MOD ys Y y X)", "unfolding igSubstIGAbs_def"], ["proof (prove)\nusing this:\n  eFresh MOD xs x eY\n  xs \\<noteq> ys \\<or> x \\<noteq> y\n  \\<forall>ys y Y xs x s X.\n     isInBar (xs, s) \\<and>\n     igWls MOD (asSort ys) Y \\<and> igWls MOD s X \\<longrightarrow>\n     (xs \\<noteq> ys \\<or> x \\<noteq> y) \\<and>\n     igFresh MOD xs x Y \\<longrightarrow>\n     igSubstAbs MOD ys Y y (igAbs MOD xs x X) =\n     igAbs MOD xs x (igSubst MOD ys Y y X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>igWlsAbs MOD (xs, s) (igAbs MOD xs x X);\n     igWls MOD s (igSubst MOD ys Y y X); igFresh MOD xs x Y;\n     isInBar (xs, s); igWls MOD s X; igWls MOD (asSort ys) Y\\<rbrakk>\n    \\<Longrightarrow> igSubstAbs MOD ys Y y (igAbs MOD xs x X) =\n                      igAbs MOD xs x (igSubst MOD ys Y y X)", "by fastforce"], ["proof (state)\nthis:\n  eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n  eAbs MOD xs x (eSubst MOD ys eY y eX)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "case False"], ["proof (state)\nthis:\n  \\<not> ((\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n          igWls MOD (asSort ys) Y)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "proof(cases \"(EX s. igWls MOD s X) \\<and> igWls MOD (asSort ys) Y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<exists>s. igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "case True"], ["proof (state)\nthis:\n  (\\<exists>s. igWls MOD s X) \\<and> igWls MOD (asSort ys) Y\n\ngoal (2 subgoals):\n 1. (\\<exists>s. igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "then"], ["proof (chain)\npicking this:\n  (\\<exists>s. igWls MOD s X) \\<and> igWls MOD (asSort ys) Y", "obtain s where X: \"igWls MOD s X\" and Y: \"igWls MOD (asSort ys) Y\""], ["proof (prove)\nusing this:\n  (\\<exists>s. igWls MOD s X) \\<and> igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>igWls MOD s X; igWls MOD (asSort ys) Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  igWls MOD s X\n  igWls MOD (asSort ys) Y\n\ngoal (2 subgoals):\n 1. (\\<exists>s. igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "hence 2: \"~ isInBar (xs,s)\""], ["proof (prove)\nusing this:\n  igWls MOD s X\n  igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s)", "using False"], ["proof (prove)\nusing this:\n  igWls MOD s X\n  igWls MOD (asSort ys) Y\n  \\<not> ((\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n          igWls MOD (asSort ys) Y)\n\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s)", "by (auto simp: eX eY)"], ["proof (state)\nthis:\n  \\<not> isInBar (xs, s)\n\ngoal (2 subgoals):\n 1. (\\<exists>s. igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "let ?Xsb = \"igSubst MOD ys Y y X\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<exists>s. igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "have Xsb: \"igWls MOD s ?Xsb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls MOD s (igSubst MOD ys Y y X)", "using Y X ***"], ["proof (prove)\nusing this:\n  igWls MOD (asSort ys) Y\n  igWls MOD s X\n  igSubstIPresIGWls MOD\n\ngoal (1 subgoal):\n 1. igWls MOD s (igSubst MOD ys Y y X)", "unfolding igSubstIPresIGWls_def"], ["proof (prove)\nusing this:\n  igWls MOD (asSort ys) Y\n  igWls MOD s X\n  \\<forall>ys Y y s X.\n     igWls MOD (asSort ys) Y \\<and> igWls MOD s X \\<longrightarrow>\n     igWls MOD s (igSubst MOD ys Y y X)\n\ngoal (1 subgoal):\n 1. igWls MOD s (igSubst MOD ys Y y X)", "by auto"], ["proof (state)\nthis:\n  igWls MOD s (igSubst MOD ys Y y X)\n\ngoal (2 subgoals):\n 1. (\\<exists>s. igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "{"], ["proof (state)\nthis:\n  igWls MOD s (igSubst MOD ys Y y X)\n\ngoal (2 subgoals):\n 1. (\\<exists>s. igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "fix s'"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<exists>s. igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "assume 3: \"isInBar (xs,s')\" and \"igWls MOD s' ?Xsb\""], ["proof (state)\nthis:\n  isInBar (xs, s')\n  igWls MOD s' (igSubst MOD ys Y y X)\n\ngoal (2 subgoals):\n 1. (\\<exists>s. igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "hence \"s = s'\""], ["proof (prove)\nusing this:\n  isInBar (xs, s')\n  igWls MOD s' (igSubst MOD ys Y y X)\n\ngoal (1 subgoal):\n 1. s = s'", "using Xsb **"], ["proof (prove)\nusing this:\n  isInBar (xs, s')\n  igWls MOD s' (igSubst MOD ys Y y X)\n  igWls MOD s (igSubst MOD ys Y y X)\n  igWlsDisj MOD\n\ngoal (1 subgoal):\n 1. s = s'", "unfolding igWlsDisj_def"], ["proof (prove)\nusing this:\n  isInBar (xs, s')\n  igWls MOD s' (igSubst MOD ys Y y X)\n  igWls MOD s (igSubst MOD ys Y y X)\n  \\<forall>s s' X.\n     igWls MOD s X \\<and> igWls MOD s' X \\<longrightarrow> s = s'\n\ngoal (1 subgoal):\n 1. s = s'", "by auto"], ["proof (state)\nthis:\n  s = s'\n\ngoal (2 subgoals):\n 1. (\\<exists>s. igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "hence False"], ["proof (prove)\nusing this:\n  s = s'\n\ngoal (1 subgoal):\n 1. False", "using 2 3"], ["proof (prove)\nusing this:\n  s = s'\n  \\<not> isInBar (xs, s)\n  isInBar (xs, s')\n\ngoal (1 subgoal):\n 1. False", "by (simp add: eX eY)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. (\\<exists>s. igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>isInBar (xs, ?s'109);\n   igWls MOD ?s'109 (igSubst MOD ys Y y X)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. (\\<exists>s. igWls MOD s X) \\<and>\n    igWls MOD (asSort ys) Y \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)\n 2. \\<not> ((\\<exists>s. igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>isInBar (xs, ?s'109);\n   igWls MOD ?s'109 (igSubst MOD ys Y y X)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "using False Y eAbs_simp2 X eX eY"], ["proof (prove)\nusing this:\n  \\<lbrakk>isInBar (xs, ?s'109);\n   igWls MOD ?s'109 (igSubst MOD ys Y y X)\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<not> ((\\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X) \\<and>\n          igWls MOD (asSort ys) Y)\n  igWls MOD (asSort ys) Y\n  \\<forall>s.\n     \\<not> (isInBar (?xs, s) \\<and> igWls ?MOD s ?X) \\<Longrightarrow>\n  eAbs ?MOD ?xs ?x (OK ?X) = ERR\n  igWls MOD s X\n  eX = OK X\n  eY = OK Y\n\ngoal (1 subgoal):\n 1. eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "by fastforce"], ["proof (state)\nthis:\n  eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n  eAbs MOD xs x (eSubst MOD ys eY y eX)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>s. igWls MOD s X) \\<and>\n            igWls MOD (asSort ys) Y) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "qed(auto simp add: eX eY)"], ["proof (state)\nthis:\n  eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n  eAbs MOD xs x (eSubst MOD ys eY y eX)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n  eAbs MOD xs x (eSubst MOD ys eY y eX)\n\ngoal (1 subgoal):\n 1. \\<not> (eX \\<noteq> ERR \\<and> eY \\<noteq> ERR) \\<Longrightarrow>\n    eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n    eAbs MOD xs x (eSubst MOD ys eY y eX)", "qed auto"], ["proof (state)\nthis:\n  eSubstAbs MOD ys eY y (eAbs MOD xs x eX) =\n  eAbs MOD xs x (eSubst MOD ys eY y eX)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma errMOD_igSubstIGOpSTR:\nassumes \"igWlsAbsIsInBar MOD\"\nand \"igVarIPresIGWls MOD\" and \"igOpIPresIGWls MOD\"\nand \"igSubstIPresIGWls MOD\" and \"igSubstAbsIPresIGWlsAbs MOD\"\nand \"igWlsDisj MOD\" and \"igWlsAbsDisj MOD\"\nand \"igSubstIGOp MOD\"\nshows \"igSubstIGOpSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGOpSTR (errMOD MOD)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. igSubstIGOpSTR (errMOD MOD)", "have 0: \"igSubstInpIPresIGWlsInp MOD \\<and> igSubstBinpIPresIGWlsBinp MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstInpIPresIGWlsInp MOD \\<and> igSubstBinpIPresIGWlsBinp MOD", "using \\<open>igSubstIPresIGWls MOD\\<close> \\<open>igSubstAbsIPresIGWlsAbs MOD\\<close>\n  imp_igSubstInpIPresIGWlsInp imp_igSubstBinpIPresIGWlsBinp"], ["proof (prove)\nusing this:\n  igSubstIPresIGWls MOD\n  igSubstAbsIPresIGWlsAbs MOD\n  igSubstIPresIGWls ?MOD \\<Longrightarrow> igSubstInpIPresIGWlsInp ?MOD\n  igSubstAbsIPresIGWlsAbs ?MOD \\<Longrightarrow>\n  igSubstBinpIPresIGWlsBinp ?MOD\n\ngoal (1 subgoal):\n 1. igSubstInpIPresIGWlsInp MOD \\<and> igSubstBinpIPresIGWlsBinp MOD", "by auto"], ["proof (state)\nthis:\n  igSubstInpIPresIGWlsInp MOD \\<and> igSubstBinpIPresIGWlsBinp MOD\n\ngoal (1 subgoal):\n 1. igSubstIGOpSTR (errMOD MOD)", "have \"igSubstIPresIGWlsSTR (errMOD MOD) \\<and> igSubstAbsIPresIGWlsAbsSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIPresIGWlsSTR (errMOD MOD) \\<and>\n    igSubstAbsIPresIGWlsAbsSTR (errMOD MOD)", "using assms errMOD_igSubstIPresIGWlsSTR errMOD_igSubstAbsIPresIGWlsAbsSTR"], ["proof (prove)\nusing this:\n  igWlsAbsIsInBar MOD\n  igVarIPresIGWls MOD\n  igOpIPresIGWls MOD\n  igSubstIPresIGWls MOD\n  igSubstAbsIPresIGWlsAbs MOD\n  igWlsDisj MOD\n  igWlsAbsDisj MOD\n  igSubstIGOp MOD\n  \\<lbrakk>igSubstIPresIGWls ?MOD; igWlsDisj ?MOD\\<rbrakk>\n  \\<Longrightarrow> igSubstIPresIGWlsSTR (errMOD ?MOD)\n  \\<lbrakk>igSubstAbsIPresIGWlsAbs ?MOD; igWlsAbsDisj ?MOD;\n   igWlsAbsIsInBar ?MOD\\<rbrakk>\n  \\<Longrightarrow> igSubstAbsIPresIGWlsAbsSTR (errMOD ?MOD)\n\ngoal (1 subgoal):\n 1. igSubstIPresIGWlsSTR (errMOD MOD) \\<and>\n    igSubstAbsIPresIGWlsAbsSTR (errMOD MOD)", "by auto"], ["proof (state)\nthis:\n  igSubstIPresIGWlsSTR (errMOD MOD) \\<and>\n  igSubstAbsIPresIGWlsAbsSTR (errMOD MOD)\n\ngoal (1 subgoal):\n 1. igSubstIGOpSTR (errMOD MOD)", "hence 1: \"igSubstInpIPresIGWlsInpSTR (errMOD MOD) \\<and>\n            igSubstBinpIPresIGWlsBinpSTR (errMOD MOD)\""], ["proof (prove)\nusing this:\n  igSubstIPresIGWlsSTR (errMOD MOD) \\<and>\n  igSubstAbsIPresIGWlsAbsSTR (errMOD MOD)\n\ngoal (1 subgoal):\n 1. igSubstInpIPresIGWlsInpSTR (errMOD MOD) \\<and>\n    igSubstBinpIPresIGWlsBinpSTR (errMOD MOD)", "using imp_igSubstInpIPresIGWlsInpSTR imp_igSubstBinpIPresIGWlsBinpSTR"], ["proof (prove)\nusing this:\n  igSubstIPresIGWlsSTR (errMOD MOD) \\<and>\n  igSubstAbsIPresIGWlsAbsSTR (errMOD MOD)\n  igSubstIPresIGWlsSTR ?MOD \\<Longrightarrow>\n  igSubstInpIPresIGWlsInpSTR ?MOD\n  igSubstAbsIPresIGWlsAbsSTR ?MOD \\<Longrightarrow>\n  igSubstBinpIPresIGWlsBinpSTR ?MOD\n\ngoal (1 subgoal):\n 1. igSubstInpIPresIGWlsInpSTR (errMOD MOD) \\<and>\n    igSubstBinpIPresIGWlsBinpSTR (errMOD MOD)", "by auto"], ["proof (state)\nthis:\n  igSubstInpIPresIGWlsInpSTR (errMOD MOD) \\<and>\n  igSubstBinpIPresIGWlsBinpSTR (errMOD MOD)\n\ngoal (1 subgoal):\n 1. igSubstIGOpSTR (errMOD MOD)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGOpSTR (errMOD MOD)", "unfolding igSubstIGOpSTR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>ys y y1 delta inp binp.\n        eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta inp binp) =\n        eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y inp)\n         (eSubstBinp MOD ys (eVar MOD ys y1) y binp)) \\<and>\n    (\\<forall>ys y Y delta inp binp.\n        eWls MOD (asSort ys) Y \\<longrightarrow>\n        eSubst MOD ys Y y (eOp MOD delta inp binp) =\n        eOp MOD delta (eSubstInp MOD ys Y y inp)\n         (eSubstBinp MOD ys Y y binp))", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys y y1 delta inp binp.\n       eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y inp)\n        (eSubstBinp MOD ys (eVar MOD ys y1) y binp)\n 2. \\<And>ys y Y delta inp binp.\n       eWls MOD (asSort ys) Y \\<Longrightarrow>\n       eSubst MOD ys Y y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys Y y inp) (eSubstBinp MOD ys Y y binp)", "fix ys::'varSort and y y1 ::'var and delta einp ebinp"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys y y1 delta inp binp.\n       eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y inp)\n        (eSubstBinp MOD ys (eVar MOD ys y1) y binp)\n 2. \\<And>ys y Y delta inp binp.\n       eWls MOD (asSort ys) Y \\<Longrightarrow>\n       eSubst MOD ys Y y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys Y y inp) (eSubstBinp MOD ys Y y binp)", "let ?Left = \"eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys y y1 delta inp binp.\n       eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y inp)\n        (eSubstBinp MOD ys (eVar MOD ys y1) y binp)\n 2. \\<And>ys y Y delta inp binp.\n       eWls MOD (asSort ys) Y \\<Longrightarrow>\n       eSubst MOD ys Y y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys Y y inp) (eSubstBinp MOD ys Y y binp)", "let ?einpsb = \"eSubstInp MOD ys (eVar MOD ys y1) y einp\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys y y1 delta inp binp.\n       eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y inp)\n        (eSubstBinp MOD ys (eVar MOD ys y1) y binp)\n 2. \\<And>ys y Y delta inp binp.\n       eWls MOD (asSort ys) Y \\<Longrightarrow>\n       eSubst MOD ys Y y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys Y y inp) (eSubstBinp MOD ys Y y binp)", "let ?ebinpsb = \"eSubstBinp MOD ys (eVar MOD ys y1) y ebinp\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys y y1 delta inp binp.\n       eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y inp)\n        (eSubstBinp MOD ys (eVar MOD ys y1) y binp)\n 2. \\<And>ys y Y delta inp binp.\n       eWls MOD (asSort ys) Y \\<Longrightarrow>\n       eSubst MOD ys Y y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys Y y inp) (eSubstBinp MOD ys Y y binp)", "let ?Right = \"eOp MOD delta ?einpsb ?ebinpsb\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys y y1 delta inp binp.\n       eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y inp)\n        (eSubstBinp MOD ys (eVar MOD ys y1) y binp)\n 2. \\<And>ys y Y delta inp binp.\n       eWls MOD (asSort ys) Y \\<Longrightarrow>\n       eSubst MOD ys Y y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys Y y inp) (eSubstBinp MOD ys Y y binp)", "show \"?Left = ?Right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "proof(cases \"liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and> liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\")"], ["proof (state)\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "case True"], ["proof (state)\nthis:\n  liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n  liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "moreover"], ["proof (state)\nthis:\n  liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n  liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "obtain inp binp where\n      \"inp = checkI einp\" and \"binp = checkI ebinp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>inp binp.\n        \\<lbrakk>inp = checkI einp; binp = checkI ebinp\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  inp = checkI einp\n  binp = checkI ebinp\n\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "ultimately"], ["proof (chain)\npicking this:\n  liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n  liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n  inp = checkI einp\n  binp = checkI ebinp", "have einp: \"einp = OKI inp\"  \"ebinp = OKI binp\""], ["proof (prove)\nusing this:\n  liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n  liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n  inp = checkI einp\n  binp = checkI ebinp\n\ngoal (1 subgoal):\n 1. einp = OKI inp &&& ebinp = OKI binp", "by auto"], ["proof (state)\nthis:\n  einp = OKI inp\n  ebinp = OKI binp\n\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "have igWls_y1: \"igWls MOD (asSort ys) (igVar MOD ys y1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls MOD (asSort ys) (igVar MOD ys y1)", "using \\<open>igVarIPresIGWls MOD\\<close>"], ["proof (prove)\nusing this:\n  igVarIPresIGWls MOD\n\ngoal (1 subgoal):\n 1. igWls MOD (asSort ys) (igVar MOD ys y1)", "unfolding igVarIPresIGWls_def"], ["proof (prove)\nusing this:\n  \\<forall>xs x. igWls MOD (asSort xs) (igVar MOD xs x)\n\ngoal (1 subgoal):\n 1. igWls MOD (asSort ys) (igVar MOD ys y1)", "by simp"], ["proof (state)\nthis:\n  igWls MOD (asSort ys) (igVar MOD ys y1)\n\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "proof(cases \"igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\")"], ["proof (state)\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "case False"], ["proof (state)\nthis:\n  \\<not> (igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp)\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "hence \"?Left = ERR\""], ["proof (prove)\nusing this:\n  \\<not> (igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp)\n\ngoal (1 subgoal):\n 1. eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) = ERR", "unfolding einp"], ["proof (prove)\nusing this:\n  \\<not> (igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp)\n\ngoal (1 subgoal):\n 1. eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta (OKI inp) (OKI binp)) =\n    ERR", "by auto"], ["proof (state)\nthis:\n  eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) = ERR\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "have \"\\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)", "unfolding einp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta (OKI inp) \\<and>\n            eWlsBinp MOD delta (OKI binp))", "using False"], ["proof (prove)\nusing this:\n  \\<not> (igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp)\n\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta (OKI inp) \\<and>\n            eWlsBinp MOD delta (OKI binp))", "by simp"], ["proof (state)\nthis:\n  \\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "hence 2: \"\\<not> (eWlsInp MOD delta ?einpsb \\<and> eWlsBinp MOD delta ?ebinpsb)\""], ["proof (prove)\nusing this:\n  \\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)\n\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta\n             (eSubstInp MOD ys (eVar MOD ys y1) y einp) \\<and>\n            eWlsBinp MOD delta (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp))", "using igWls_y1 1"], ["proof (prove)\nusing this:\n  \\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)\n  igWls MOD (asSort ys) (igVar MOD ys y1)\n  igSubstInpIPresIGWlsInpSTR (errMOD MOD) \\<and>\n  igSubstBinpIPresIGWlsBinpSTR (errMOD MOD)\n\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta\n             (eSubstInp MOD ys (eVar MOD ys y1) y einp) \\<and>\n            eWlsBinp MOD delta (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp))", "unfolding igSubstInpIPresIGWlsInpSTR_def igSubstBinpIPresIGWlsBinpSTR_def"], ["proof (prove)\nusing this:\n  \\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)\n  igWls MOD (asSort ys) (igVar MOD ys y1)\n  (\\<forall>ys y Y delta inp.\n      eWls MOD (asSort ys) Y \\<longrightarrow>\n      eWlsInp MOD delta (eSubstInp MOD ys Y y inp) =\n      eWlsInp MOD delta inp) \\<and>\n  (\\<forall>ys y Y delta binp.\n      eWls MOD (asSort ys) Y \\<longrightarrow>\n      eWlsBinp MOD delta (eSubstBinp MOD ys Y y binp) =\n      eWlsBinp MOD delta binp)\n\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta\n             (eSubstInp MOD ys (eVar MOD ys y1) y einp) \\<and>\n            eWlsBinp MOD delta (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp))", "by simp"], ["proof (state)\nthis:\n  \\<not> (eWlsInp MOD delta\n           (eSubstInp MOD ys (eVar MOD ys y1) y einp) \\<and>\n          eWlsBinp MOD delta (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp))\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "{"], ["proof (state)\nthis:\n  \\<not> (eWlsInp MOD delta\n           (eSubstInp MOD ys (eVar MOD ys y1) y einp) \\<and>\n          eWlsBinp MOD delta (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp))\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "fix X"], ["proof (state)\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "assume \"?Right = OK X\""], ["proof (state)\nthis:\n  eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n   (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp) =\n  OK X\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "then"], ["proof (chain)\npicking this:\n  eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n   (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp) =\n  OK X", "obtain inpsb binpsb where\n         \"?einpsb = OKI inpsb\" and \"?ebinpsb = OKI binpsb\"\n         and \"igWlsInp MOD delta inpsb\" and \"igWlsBinp MOD delta binpsb\"\n         and \"X = igOp MOD delta inpsb binpsb\""], ["proof (prove)\nusing this:\n  eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n   (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp) =\n  OK X\n\ngoal (1 subgoal):\n 1. (\\<And>inpsb binpsb.\n        \\<lbrakk>eSubstInp MOD ys (eVar MOD ys y1) y einp = OKI inpsb;\n         eSubstBinp MOD ys (eVar MOD ys y1) y ebinp = OKI binpsb;\n         igWlsInp MOD delta inpsb; igWlsBinp MOD delta binpsb;\n         X = igOp MOD delta inpsb binpsb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eOp_invert[of MOD delta ?einpsb ?ebinpsb X]"], ["proof (prove)\nusing this:\n  eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n   (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp) =\n  OK X\n  eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n   (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp) =\n  OK X \\<Longrightarrow>\n  \\<exists>inp binp.\n     eSubstInp MOD ys (eVar MOD ys y1) y einp = OKI inp \\<and>\n     eSubstBinp MOD ys (eVar MOD ys y1) y ebinp = OKI binp \\<and>\n     X = igOp MOD delta inp binp \\<and>\n     igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n\ngoal (1 subgoal):\n 1. (\\<And>inpsb binpsb.\n        \\<lbrakk>eSubstInp MOD ys (eVar MOD ys y1) y einp = OKI inpsb;\n         eSubstBinp MOD ys (eVar MOD ys y1) y ebinp = OKI binpsb;\n         igWlsInp MOD delta inpsb; igWlsBinp MOD delta binpsb;\n         X = igOp MOD delta inpsb binpsb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eSubstInp MOD ys (eVar MOD ys y1) y einp = OKI inpsb\n  eSubstBinp MOD ys (eVar MOD ys y1) y ebinp = OKI binpsb\n  igWlsInp MOD delta inpsb\n  igWlsBinp MOD delta binpsb\n  X = igOp MOD delta inpsb binpsb\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "hence False"], ["proof (prove)\nusing this:\n  eSubstInp MOD ys (eVar MOD ys y1) y einp = OKI inpsb\n  eSubstBinp MOD ys (eVar MOD ys y1) y ebinp = OKI binpsb\n  igWlsInp MOD delta inpsb\n  igWlsBinp MOD delta binpsb\n  X = igOp MOD delta inpsb binpsb\n\ngoal (1 subgoal):\n 1. False", "using 2"], ["proof (prove)\nusing this:\n  eSubstInp MOD ys (eVar MOD ys y1) y einp = OKI inpsb\n  eSubstBinp MOD ys (eVar MOD ys y1) y ebinp = OKI binpsb\n  igWlsInp MOD delta inpsb\n  igWlsBinp MOD delta binpsb\n  X = igOp MOD delta inpsb binpsb\n  \\<not> (eWlsInp MOD delta\n           (eSubstInp MOD ys (eVar MOD ys y1) y einp) \\<and>\n          eWlsBinp MOD delta (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "}"], ["proof (state)\nthis:\n  eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n   (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp) =\n  OK ?X109 \\<Longrightarrow>\n  False\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "hence \"?Right = ERR\""], ["proof (prove)\nusing this:\n  eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n   (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp) =\n  OK ?X109 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp) =\n    ERR", "by (cases ?Right, auto)"], ["proof (state)\nthis:\n  eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n   (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp) =\n  ERR\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "with \\<open>?Left = ERR\\<close>"], ["proof (chain)\npicking this:\n  eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) = ERR\n  eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n   (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp) =\n  ERR", "show ?thesis"], ["proof (prove)\nusing this:\n  eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) = ERR\n  eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n   (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp) =\n  ERR\n\ngoal (1 subgoal):\n 1. eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "by simp"], ["proof (state)\nthis:\n  eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n  eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n   (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "case True"], ["proof (state)\nthis:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "moreover"], ["proof (state)\nthis:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "have \"igWls MOD (stOf delta) (igOp MOD delta inp binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls MOD (stOf delta) (igOp MOD delta inp binp)", "using True \\<open>igOpIPresIGWls MOD\\<close>"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igOpIPresIGWls MOD\n\ngoal (1 subgoal):\n 1. igWls MOD (stOf delta) (igOp MOD delta inp binp)", "unfolding igOpIPresIGWls_def"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  \\<forall>delta inp binp.\n     igWlsInp MOD delta inp \\<and>\n     igWlsBinp MOD delta binp \\<longrightarrow>\n     igWls MOD (stOf delta) (igOp MOD delta inp binp)\n\ngoal (1 subgoal):\n 1. igWls MOD (stOf delta) (igOp MOD delta inp binp)", "by simp"], ["proof (state)\nthis:\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "moreover"], ["proof (state)\nthis:\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "have \"igWlsInp MOD delta (igSubstInp MOD ys (igVar MOD ys y1) y inp) \\<and>\n              igWlsBinp MOD delta (igSubstBinp MOD ys (igVar MOD ys y1) y binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (igSubstInp MOD ys (igVar MOD ys y1) y inp) \\<and>\n    igWlsBinp MOD delta (igSubstBinp MOD ys (igVar MOD ys y1) y binp)", "using 0"], ["proof (prove)\nusing this:\n  igSubstInpIPresIGWlsInp MOD \\<and> igSubstBinpIPresIGWlsBinp MOD\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (igSubstInp MOD ys (igVar MOD ys y1) y inp) \\<and>\n    igWlsBinp MOD delta (igSubstBinp MOD ys (igVar MOD ys y1) y binp)", "unfolding igSubstInpIPresIGWlsInp_def igSubstBinpIPresIGWlsBinp_def"], ["proof (prove)\nusing this:\n  (\\<forall>ys y Y delta inp.\n      igWls MOD (asSort ys) Y \\<and>\n      igWlsInp MOD delta inp \\<longrightarrow>\n      igWlsInp MOD delta (igSubstInp MOD ys Y y inp)) \\<and>\n  (\\<forall>ys y Y delta binp.\n      igWls MOD (asSort ys) Y \\<and>\n      igWlsBinp MOD delta binp \\<longrightarrow>\n      igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp))\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (igSubstInp MOD ys (igVar MOD ys y1) y inp) \\<and>\n    igWlsBinp MOD delta (igSubstBinp MOD ys (igVar MOD ys y1) y binp)", "using True igWls_y1"], ["proof (prove)\nusing this:\n  (\\<forall>ys y Y delta inp.\n      igWls MOD (asSort ys) Y \\<and>\n      igWlsInp MOD delta inp \\<longrightarrow>\n      igWlsInp MOD delta (igSubstInp MOD ys Y y inp)) \\<and>\n  (\\<forall>ys y Y delta binp.\n      igWls MOD (asSort ys) Y \\<and>\n      igWlsBinp MOD delta binp \\<longrightarrow>\n      igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp))\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igWls MOD (asSort ys) (igVar MOD ys y1)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (igSubstInp MOD ys (igVar MOD ys y1) y inp) \\<and>\n    igWlsBinp MOD delta (igSubstBinp MOD ys (igVar MOD ys y1) y binp)", "by simp"], ["proof (state)\nthis:\n  igWlsInp MOD delta (igSubstInp MOD ys (igVar MOD ys y1) y inp) \\<and>\n  igWlsBinp MOD delta (igSubstBinp MOD ys (igVar MOD ys y1) y binp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "ultimately"], ["proof (chain)\npicking this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n  igWlsInp MOD delta (igSubstInp MOD ys (igVar MOD ys y1) y inp) \\<and>\n  igWlsBinp MOD delta (igSubstBinp MOD ys (igVar MOD ys y1) y binp)", "show ?thesis"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n  igWlsInp MOD delta (igSubstInp MOD ys (igVar MOD ys y1) y inp) \\<and>\n  igWlsBinp MOD delta (igSubstBinp MOD ys (igVar MOD ys y1) y binp)\n\ngoal (1 subgoal):\n 1. eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "using \\<open>igSubstIGOp MOD\\<close> igWls_y1"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n  igWlsInp MOD delta (igSubstInp MOD ys (igVar MOD ys y1) y inp) \\<and>\n  igWlsBinp MOD delta (igSubstBinp MOD ys (igVar MOD ys y1) y binp)\n  igSubstIGOp MOD\n  igWls MOD (asSort ys) (igVar MOD ys y1)\n\ngoal (1 subgoal):\n 1. eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "unfolding einp igSubstIGOp_def"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n  igWlsInp MOD delta (igSubstInp MOD ys (igVar MOD ys y1) y inp) \\<and>\n  igWlsBinp MOD delta (igSubstBinp MOD ys (igVar MOD ys y1) y binp)\n  \\<forall>ys y Y delta inp binp.\n     igWls MOD (asSort ys) Y \\<and>\n     igWlsInp MOD delta inp \\<and>\n     igWlsBinp MOD delta binp \\<longrightarrow>\n     igSubst MOD ys Y y (igOp MOD delta inp binp) =\n     igOp MOD delta (igSubstInp MOD ys Y y inp)\n      (igSubstBinp MOD ys Y y binp)\n  igWls MOD (asSort ys) (igVar MOD ys y1)\n\ngoal (1 subgoal):\n 1. eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta (OKI inp) (OKI binp)) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y (OKI inp))\n     (eSubstBinp MOD ys (eVar MOD ys y1) y (OKI binp))", "by auto"], ["proof (state)\nthis:\n  eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n  eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n   (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n  eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n   (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n\ngoal (1 subgoal):\n 1. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n     (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)", "qed auto"], ["proof (state)\nthis:\n  eSubst MOD ys (eVar MOD ys y1) y (eOp MOD delta einp ebinp) =\n  eOp MOD delta (eSubstInp MOD ys (eVar MOD ys y1) y einp)\n   (eSubstBinp MOD ys (eVar MOD ys y1) y ebinp)\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y delta inp binp.\n       eWls MOD (asSort ys) Y \\<Longrightarrow>\n       eSubst MOD ys Y y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys Y y inp) (eSubstBinp MOD ys Y y binp)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y delta inp binp.\n       eWls MOD (asSort ys) Y \\<Longrightarrow>\n       eSubst MOD ys Y y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys Y y inp) (eSubstBinp MOD ys Y y binp)", "fix ys::'varSort and y ::'var and eY delta einp ebinp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y delta inp binp.\n       eWls MOD (asSort ys) Y \\<Longrightarrow>\n       eSubst MOD ys Y y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys Y y inp) (eSubstBinp MOD ys Y y binp)", "assume eY: \"eWls MOD (asSort ys) eY\""], ["proof (state)\nthis:\n  eWls MOD (asSort ys) eY\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y delta inp binp.\n       eWls MOD (asSort ys) Y \\<Longrightarrow>\n       eSubst MOD ys Y y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys Y y inp) (eSubstBinp MOD ys Y y binp)", "let ?Left = \"eSubst MOD ys eY y (eOp MOD delta einp ebinp)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y delta inp binp.\n       eWls MOD (asSort ys) Y \\<Longrightarrow>\n       eSubst MOD ys Y y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys Y y inp) (eSubstBinp MOD ys Y y binp)", "let ?einpsb = \"eSubstInp MOD ys eY y einp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y delta inp binp.\n       eWls MOD (asSort ys) Y \\<Longrightarrow>\n       eSubst MOD ys Y y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys Y y inp) (eSubstBinp MOD ys Y y binp)", "let ?ebinpsb = \"eSubstBinp MOD ys eY y ebinp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y delta inp binp.\n       eWls MOD (asSort ys) Y \\<Longrightarrow>\n       eSubst MOD ys Y y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys Y y inp) (eSubstBinp MOD ys Y y binp)", "let ?Right = \"eOp MOD delta ?einpsb ?ebinpsb\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y delta inp binp.\n       eWls MOD (asSort ys) Y \\<Longrightarrow>\n       eSubst MOD ys Y y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys Y y inp) (eSubstBinp MOD ys Y y binp)", "from eY"], ["proof (chain)\npicking this:\n  eWls MOD (asSort ys) eY", "obtain Y where eY_def: \"eY = OK Y\"\n    and Y: \"igWls MOD (asSort ys) Y\""], ["proof (prove)\nusing this:\n  eWls MOD (asSort ys) eY\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>eY = OK Y; igWls MOD (asSort ys) Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eWls_invert[of MOD \"asSort ys\" eY]"], ["proof (prove)\nusing this:\n  eWls MOD (asSort ys) eY\n  eWls MOD (asSort ys) eY \\<Longrightarrow>\n  \\<exists>X. eY = OK X \\<and> igWls MOD (asSort ys) X\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>eY = OK Y; igWls MOD (asSort ys) Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eY = OK Y\n  igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y delta inp binp.\n       eWls MOD (asSort ys) Y \\<Longrightarrow>\n       eSubst MOD ys Y y (eOp MOD delta inp binp) =\n       eOp MOD delta (eSubstInp MOD ys Y y inp) (eSubstBinp MOD ys Y y binp)", "show \"?Left = ?Right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "proof(cases \"liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and> liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\")"], ["proof (state)\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "case True"], ["proof (state)\nthis:\n  liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n  liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "moreover"], ["proof (state)\nthis:\n  liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n  liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "obtain inp binp where\n      \"inp = checkI einp\" and \"binp = checkI ebinp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>inp binp.\n        \\<lbrakk>inp = checkI einp; binp = checkI ebinp\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  inp = checkI einp\n  binp = checkI ebinp\n\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "ultimately"], ["proof (chain)\npicking this:\n  liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n  liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n  inp = checkI einp\n  binp = checkI ebinp", "have einp: \"einp = OKI inp\"  \"ebinp = OKI binp\""], ["proof (prove)\nusing this:\n  liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n  liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp\n  inp = checkI einp\n  binp = checkI ebinp\n\ngoal (1 subgoal):\n 1. einp = OKI inp &&& ebinp = OKI binp", "by auto"], ["proof (state)\nthis:\n  einp = OKI inp\n  ebinp = OKI binp\n\ngoal (2 subgoals):\n 1. liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n    liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "proof(cases \"igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\")"], ["proof (state)\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "case False"], ["proof (state)\nthis:\n  \\<not> (igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp)\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "hence \"?Left = ERR\""], ["proof (prove)\nusing this:\n  \\<not> (igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp)\n\ngoal (1 subgoal):\n 1. eSubst MOD ys eY y (eOp MOD delta einp ebinp) = ERR", "unfolding einp"], ["proof (prove)\nusing this:\n  \\<not> (igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp)\n\ngoal (1 subgoal):\n 1. eSubst MOD ys eY y (eOp MOD delta (OKI inp) (OKI binp)) = ERR", "by auto"], ["proof (state)\nthis:\n  eSubst MOD ys eY y (eOp MOD delta einp ebinp) = ERR\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "have \"\\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)", "unfolding einp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta (OKI inp) \\<and>\n            eWlsBinp MOD delta (OKI binp))", "using False"], ["proof (prove)\nusing this:\n  \\<not> (igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp)\n\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta (OKI inp) \\<and>\n            eWlsBinp MOD delta (OKI binp))", "by simp"], ["proof (state)\nthis:\n  \\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "hence 2: \"\\<not> (eWlsInp MOD delta ?einpsb \\<and> eWlsBinp MOD delta ?ebinpsb)\""], ["proof (prove)\nusing this:\n  \\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)\n\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta (eSubstInp MOD ys eY y einp) \\<and>\n            eWlsBinp MOD delta (eSubstBinp MOD ys eY y ebinp))", "unfolding eY_def"], ["proof (prove)\nusing this:\n  \\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)\n\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta (eSubstInp MOD ys (OK Y) y einp) \\<and>\n            eWlsBinp MOD delta (eSubstBinp MOD ys (OK Y) y ebinp))", "using Y 1"], ["proof (prove)\nusing this:\n  \\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)\n  igWls MOD (asSort ys) Y\n  igSubstInpIPresIGWlsInpSTR (errMOD MOD) \\<and>\n  igSubstBinpIPresIGWlsBinpSTR (errMOD MOD)\n\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta (eSubstInp MOD ys (OK Y) y einp) \\<and>\n            eWlsBinp MOD delta (eSubstBinp MOD ys (OK Y) y ebinp))", "unfolding igSubstInpIPresIGWlsInpSTR_def igSubstBinpIPresIGWlsBinpSTR_def"], ["proof (prove)\nusing this:\n  \\<not> (eWlsInp MOD delta einp \\<and> eWlsBinp MOD delta ebinp)\n  igWls MOD (asSort ys) Y\n  (\\<forall>ys y Y delta inp.\n      eWls MOD (asSort ys) Y \\<longrightarrow>\n      eWlsInp MOD delta (eSubstInp MOD ys Y y inp) =\n      eWlsInp MOD delta inp) \\<and>\n  (\\<forall>ys y Y delta binp.\n      eWls MOD (asSort ys) Y \\<longrightarrow>\n      eWlsBinp MOD delta (eSubstBinp MOD ys Y y binp) =\n      eWlsBinp MOD delta binp)\n\ngoal (1 subgoal):\n 1. \\<not> (eWlsInp MOD delta (eSubstInp MOD ys (OK Y) y einp) \\<and>\n            eWlsBinp MOD delta (eSubstBinp MOD ys (OK Y) y ebinp))", "by simp"], ["proof (state)\nthis:\n  \\<not> (eWlsInp MOD delta (eSubstInp MOD ys eY y einp) \\<and>\n          eWlsBinp MOD delta (eSubstBinp MOD ys eY y ebinp))\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "{"], ["proof (state)\nthis:\n  \\<not> (eWlsInp MOD delta (eSubstInp MOD ys eY y einp) \\<and>\n          eWlsBinp MOD delta (eSubstBinp MOD ys eY y ebinp))\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "fix X"], ["proof (state)\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "assume \"?Right = OK X\""], ["proof (state)\nthis:\n  eOp MOD delta (eSubstInp MOD ys eY y einp)\n   (eSubstBinp MOD ys eY y ebinp) =\n  OK X\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "then"], ["proof (chain)\npicking this:\n  eOp MOD delta (eSubstInp MOD ys eY y einp)\n   (eSubstBinp MOD ys eY y ebinp) =\n  OK X", "obtain inpsb binpsb\n         where \"?einpsb = OKI inpsb\" and \"?ebinpsb = OKI binpsb\"\n         and \"igWlsInp MOD delta inpsb\" and \"igWlsBinp MOD delta binpsb\"\n         and \"X = igOp MOD delta inpsb binpsb\""], ["proof (prove)\nusing this:\n  eOp MOD delta (eSubstInp MOD ys eY y einp)\n   (eSubstBinp MOD ys eY y ebinp) =\n  OK X\n\ngoal (1 subgoal):\n 1. (\\<And>inpsb binpsb.\n        \\<lbrakk>eSubstInp MOD ys eY y einp = OKI inpsb;\n         eSubstBinp MOD ys eY y ebinp = OKI binpsb;\n         igWlsInp MOD delta inpsb; igWlsBinp MOD delta binpsb;\n         X = igOp MOD delta inpsb binpsb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eOp_invert[of MOD delta ?einpsb ?ebinpsb X]"], ["proof (prove)\nusing this:\n  eOp MOD delta (eSubstInp MOD ys eY y einp)\n   (eSubstBinp MOD ys eY y ebinp) =\n  OK X\n  eOp MOD delta (eSubstInp MOD ys eY y einp)\n   (eSubstBinp MOD ys eY y ebinp) =\n  OK X \\<Longrightarrow>\n  \\<exists>inp binp.\n     eSubstInp MOD ys eY y einp = OKI inp \\<and>\n     eSubstBinp MOD ys eY y ebinp = OKI binp \\<and>\n     X = igOp MOD delta inp binp \\<and>\n     igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n\ngoal (1 subgoal):\n 1. (\\<And>inpsb binpsb.\n        \\<lbrakk>eSubstInp MOD ys eY y einp = OKI inpsb;\n         eSubstBinp MOD ys eY y ebinp = OKI binpsb;\n         igWlsInp MOD delta inpsb; igWlsBinp MOD delta binpsb;\n         X = igOp MOD delta inpsb binpsb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eSubstInp MOD ys eY y einp = OKI inpsb\n  eSubstBinp MOD ys eY y ebinp = OKI binpsb\n  igWlsInp MOD delta inpsb\n  igWlsBinp MOD delta binpsb\n  X = igOp MOD delta inpsb binpsb\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "hence False"], ["proof (prove)\nusing this:\n  eSubstInp MOD ys eY y einp = OKI inpsb\n  eSubstBinp MOD ys eY y ebinp = OKI binpsb\n  igWlsInp MOD delta inpsb\n  igWlsBinp MOD delta binpsb\n  X = igOp MOD delta inpsb binpsb\n\ngoal (1 subgoal):\n 1. False", "using 2"], ["proof (prove)\nusing this:\n  eSubstInp MOD ys eY y einp = OKI inpsb\n  eSubstBinp MOD ys eY y ebinp = OKI binpsb\n  igWlsInp MOD delta inpsb\n  igWlsBinp MOD delta binpsb\n  X = igOp MOD delta inpsb binpsb\n  \\<not> (eWlsInp MOD delta (eSubstInp MOD ys eY y einp) \\<and>\n          eWlsBinp MOD delta (eSubstBinp MOD ys eY y ebinp))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "}"], ["proof (state)\nthis:\n  eOp MOD delta (eSubstInp MOD ys eY y einp)\n   (eSubstBinp MOD ys eY y ebinp) =\n  OK ?X109 \\<Longrightarrow>\n  False\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "hence \"?Right = ERR\""], ["proof (prove)\nusing this:\n  eOp MOD delta (eSubstInp MOD ys eY y einp)\n   (eSubstBinp MOD ys eY y ebinp) =\n  OK ?X109 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp) =\n    ERR", "by (cases ?Right, auto)"], ["proof (state)\nthis:\n  eOp MOD delta (eSubstInp MOD ys eY y einp)\n   (eSubstBinp MOD ys eY y ebinp) =\n  ERR\n\ngoal (2 subgoals):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)\n 2. \\<not> (igWlsInp MOD delta inp \\<and>\n            igWlsBinp MOD delta binp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "with \\<open>?Left = ERR\\<close>"], ["proof (chain)\npicking this:\n  eSubst MOD ys eY y (eOp MOD delta einp ebinp) = ERR\n  eOp MOD delta (eSubstInp MOD ys eY y einp)\n   (eSubstBinp MOD ys eY y ebinp) =\n  ERR", "show ?thesis"], ["proof (prove)\nusing this:\n  eSubst MOD ys eY y (eOp MOD delta einp ebinp) = ERR\n  eOp MOD delta (eSubstInp MOD ys eY y einp)\n   (eSubstBinp MOD ys eY y ebinp) =\n  ERR\n\ngoal (1 subgoal):\n 1. eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "by simp"], ["proof (state)\nthis:\n  eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n  eOp MOD delta (eSubstInp MOD ys eY y einp) (eSubstBinp MOD ys eY y ebinp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "case True"], ["proof (state)\nthis:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "moreover"], ["proof (state)\nthis:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "have \"igWls MOD (stOf delta) (igOp MOD delta inp binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls MOD (stOf delta) (igOp MOD delta inp binp)", "using True \\<open>igOpIPresIGWls MOD\\<close>"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igOpIPresIGWls MOD\n\ngoal (1 subgoal):\n 1. igWls MOD (stOf delta) (igOp MOD delta inp binp)", "unfolding igOpIPresIGWls_def"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  \\<forall>delta inp binp.\n     igWlsInp MOD delta inp \\<and>\n     igWlsBinp MOD delta binp \\<longrightarrow>\n     igWls MOD (stOf delta) (igOp MOD delta inp binp)\n\ngoal (1 subgoal):\n 1. igWls MOD (stOf delta) (igOp MOD delta inp binp)", "by simp"], ["proof (state)\nthis:\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "moreover"], ["proof (state)\nthis:\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "have \"igWlsInp MOD delta (igSubstInp MOD ys Y y inp) \\<and>\n              igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (igSubstInp MOD ys Y y inp) \\<and>\n    igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp)", "using 0"], ["proof (prove)\nusing this:\n  igSubstInpIPresIGWlsInp MOD \\<and> igSubstBinpIPresIGWlsBinp MOD\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (igSubstInp MOD ys Y y inp) \\<and>\n    igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp)", "unfolding igSubstInpIPresIGWlsInp_def igSubstBinpIPresIGWlsBinp_def"], ["proof (prove)\nusing this:\n  (\\<forall>ys y Y delta inp.\n      igWls MOD (asSort ys) Y \\<and>\n      igWlsInp MOD delta inp \\<longrightarrow>\n      igWlsInp MOD delta (igSubstInp MOD ys Y y inp)) \\<and>\n  (\\<forall>ys y Y delta binp.\n      igWls MOD (asSort ys) Y \\<and>\n      igWlsBinp MOD delta binp \\<longrightarrow>\n      igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp))\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (igSubstInp MOD ys Y y inp) \\<and>\n    igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp)", "using True Y"], ["proof (prove)\nusing this:\n  (\\<forall>ys y Y delta inp.\n      igWls MOD (asSort ys) Y \\<and>\n      igWlsInp MOD delta inp \\<longrightarrow>\n      igWlsInp MOD delta (igSubstInp MOD ys Y y inp)) \\<and>\n  (\\<forall>ys y Y delta binp.\n      igWls MOD (asSort ys) Y \\<and>\n      igWlsBinp MOD delta binp \\<longrightarrow>\n      igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp))\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta (igSubstInp MOD ys Y y inp) \\<and>\n    igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp)", "by simp"], ["proof (state)\nthis:\n  igWlsInp MOD delta (igSubstInp MOD ys Y y inp) \\<and>\n  igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp)\n\ngoal (1 subgoal):\n 1. igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "ultimately"], ["proof (chain)\npicking this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n  igWlsInp MOD delta (igSubstInp MOD ys Y y inp) \\<and>\n  igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp)", "show ?thesis"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n  igWlsInp MOD delta (igSubstInp MOD ys Y y inp) \\<and>\n  igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp)\n\ngoal (1 subgoal):\n 1. eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "unfolding einp eY_def"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n  igWlsInp MOD delta (igSubstInp MOD ys Y y inp) \\<and>\n  igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp)\n\ngoal (1 subgoal):\n 1. eSubst MOD ys (OK Y) y (eOp MOD delta (OKI inp) (OKI binp)) =\n    eOp MOD delta (eSubstInp MOD ys (OK Y) y (OKI inp))\n     (eSubstBinp MOD ys (OK Y) y (OKI binp))", "using \\<open>igSubstIGOp MOD\\<close> Y"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n  igWlsInp MOD delta (igSubstInp MOD ys Y y inp) \\<and>\n  igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp)\n  igSubstIGOp MOD\n  igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. eSubst MOD ys (OK Y) y (eOp MOD delta (OKI inp) (OKI binp)) =\n    eOp MOD delta (eSubstInp MOD ys (OK Y) y (OKI inp))\n     (eSubstBinp MOD ys (OK Y) y (OKI binp))", "unfolding igSubstIGOp_def"], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp \\<and> igWlsBinp MOD delta binp\n  igWls MOD (stOf delta) (igOp MOD delta inp binp)\n  igWlsInp MOD delta (igSubstInp MOD ys Y y inp) \\<and>\n  igWlsBinp MOD delta (igSubstBinp MOD ys Y y binp)\n  \\<forall>ys y Y delta inp binp.\n     igWls MOD (asSort ys) Y \\<and>\n     igWlsInp MOD delta inp \\<and>\n     igWlsBinp MOD delta binp \\<longrightarrow>\n     igSubst MOD ys Y y (igOp MOD delta inp binp) =\n     igOp MOD delta (igSubstInp MOD ys Y y inp)\n      (igSubstBinp MOD ys Y y binp)\n  igWls MOD (asSort ys) Y\n\ngoal (1 subgoal):\n 1. eSubst MOD ys (OK Y) y (eOp MOD delta (OKI inp) (OKI binp)) =\n    eOp MOD delta (eSubstInp MOD ys (OK Y) y (OKI inp))\n     (eSubstBinp MOD ys (OK Y) y (OKI binp))", "by auto"], ["proof (state)\nthis:\n  eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n  eOp MOD delta (eSubstInp MOD ys eY y einp) (eSubstBinp MOD ys eY y ebinp)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n  eOp MOD delta (eSubstInp MOD ys eY y einp) (eSubstBinp MOD ys eY y ebinp)\n\ngoal (1 subgoal):\n 1. \\<not> (liftAll (\\<lambda>eX. eX \\<noteq> ERR) einp \\<and>\n            liftAll (\\<lambda>eA. eA \\<noteq> ERR) ebinp) \\<Longrightarrow>\n    eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n    eOp MOD delta (eSubstInp MOD ys eY y einp)\n     (eSubstBinp MOD ys eY y ebinp)", "qed auto"], ["proof (state)\nthis:\n  eSubst MOD ys eY y (eOp MOD delta einp ebinp) =\n  eOp MOD delta (eSubstInp MOD ys eY y einp) (eSubstBinp MOD ys eY y ebinp)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  igSubstIGOpSTR (errMOD MOD)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma errMOD_igSubstClsSTR:\nassumes \"igWlsAllDisj MOD\" and \"igConsIPresIGWls MOD\"\nand \"igWlsAbsIsInBar MOD\"\nand \"igSubstAllIPresIGWlsAll MOD\" and \"igSubstCls MOD\"\nshows \"igSubstClsSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstClsSTR (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igWlsAllDisj MOD\n  igConsIPresIGWls MOD\n  igWlsAbsIsInBar MOD\n  igSubstAllIPresIGWlsAll MOD\n  igSubstCls MOD\n\ngoal (1 subgoal):\n 1. igSubstClsSTR (errMOD MOD)", "unfolding igWlsAllDisj_def igConsIPresIGWls_def igSubstCls_def\nigSubstAllIPresIGWlsAll_def igSubstClsSTR_def"], ["proof (prove)\nusing this:\n  igWlsDisj MOD \\<and> igWlsAbsDisj MOD\n  igVarIPresIGWls MOD \\<and> igAbsIPresIGWls MOD \\<and> igOpIPresIGWls MOD\n  igWlsAbsIsInBar MOD\n  igSubstIPresIGWls MOD \\<and> igSubstAbsIPresIGWlsAbs MOD\n  igSubstIGVar1 MOD \\<and>\n  igSubstIGVar2 MOD \\<and> igSubstIGAbs MOD \\<and> igSubstIGOp MOD\n\ngoal (1 subgoal):\n 1. igSubstIGVar1STR (errMOD MOD) \\<and>\n    igSubstIGVar2STR (errMOD MOD) \\<and>\n    igSubstIGAbsSTR (errMOD MOD) \\<and> igSubstIGOpSTR (errMOD MOD)", "using\nerrMOD_igSubstIGVar1STR[of MOD] errMOD_igSubstIGVar2STR[of MOD]\nerrMOD_igSubstIGAbsSTR[of MOD]\nerrMOD_igSubstIGOpSTR[of MOD]"], ["proof (prove)\nusing this:\n  igWlsDisj MOD \\<and> igWlsAbsDisj MOD\n  igVarIPresIGWls MOD \\<and> igAbsIPresIGWls MOD \\<and> igOpIPresIGWls MOD\n  igWlsAbsIsInBar MOD\n  igSubstIPresIGWls MOD \\<and> igSubstAbsIPresIGWlsAbs MOD\n  igSubstIGVar1 MOD \\<and>\n  igSubstIGVar2 MOD \\<and> igSubstIGAbs MOD \\<and> igSubstIGOp MOD\n  \\<lbrakk>igVarIPresIGWls MOD; igSubstIGVar1 MOD\\<rbrakk>\n  \\<Longrightarrow> igSubstIGVar1STR (errMOD MOD)\n  \\<lbrakk>igVarIPresIGWls MOD; igSubstIGVar2 MOD\\<rbrakk>\n  \\<Longrightarrow> igSubstIGVar2STR (errMOD MOD)\n  \\<lbrakk>igAbsIPresIGWls MOD; igWlsDisj MOD; igSubstIPresIGWls MOD;\n   igSubstIGAbs MOD\\<rbrakk>\n  \\<Longrightarrow> igSubstIGAbsSTR (errMOD MOD)\n  \\<lbrakk>igWlsAbsIsInBar MOD; igVarIPresIGWls MOD; igOpIPresIGWls MOD;\n   igSubstIPresIGWls MOD; igSubstAbsIPresIGWlsAbs MOD; igWlsDisj MOD;\n   igWlsAbsDisj MOD; igSubstIGOp MOD\\<rbrakk>\n  \\<Longrightarrow> igSubstIGOpSTR (errMOD MOD)\n\ngoal (1 subgoal):\n 1. igSubstIGVar1STR (errMOD MOD) \\<and>\n    igSubstIGVar2STR (errMOD MOD) \\<and>\n    igSubstIGAbsSTR (errMOD MOD) \\<and> igSubstIGOpSTR (errMOD MOD)", "by simp"], ["", "text\\<open>Strong swap-based congruence for abstractions holds:\\<close>"], ["", "lemma errMOD_igAbsCongSSTR:\nassumes \"igSwapIPresIGWls MOD\" and \"igWlsDisj MOD\" and \"igAbsCongS MOD\"\nshows \"igAbsCongSSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbsCongSSTR (errMOD MOD)", "unfolding igAbsCongSSTR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs x x' y X X'.\n       eFresh MOD xs y X \\<and>\n       eFresh MOD xs y X' \\<and>\n       eSwap MOD xs y x X = eSwap MOD xs y x' X' \\<longrightarrow>\n       eAbs MOD xs x X = eAbs MOD xs x' X'", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x x' y X X'.\n       \\<lbrakk>eFresh MOD xs y X; eFresh MOD xs y X';\n        eSwap MOD xs y x X = eSwap MOD xs y x' X'\\<rbrakk>\n       \\<Longrightarrow> eAbs MOD xs x X = eAbs MOD xs x' X'", "fix xs ::'varSort and x x' y ::'var and eX eX'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x x' y X X'.\n       \\<lbrakk>eFresh MOD xs y X; eFresh MOD xs y X';\n        eSwap MOD xs y x X = eSwap MOD xs y x' X'\\<rbrakk>\n       \\<Longrightarrow> eAbs MOD xs x X = eAbs MOD xs x' X'", "assume *: \"eFresh MOD xs y eX\" and **: \"eFresh MOD xs y eX'\"\n  and ***: \"eSwap MOD xs y x eX = eSwap MOD xs y x' eX'\""], ["proof (state)\nthis:\n  eFresh MOD xs y eX\n  eFresh MOD xs y eX'\n  eSwap MOD xs y x eX = eSwap MOD xs y x' eX'\n\ngoal (1 subgoal):\n 1. \\<And>xs x x' y X X'.\n       \\<lbrakk>eFresh MOD xs y X; eFresh MOD xs y X';\n        eSwap MOD xs y x X = eSwap MOD xs y x' X'\\<rbrakk>\n       \\<Longrightarrow> eAbs MOD xs x X = eAbs MOD xs x' X'", "let ?phi = \"\\<lambda>eX. eX = ERR \\<or> (\\<exists> X. eX = OK X \\<and> (\\<forall> s. \\<not> igWls MOD s X))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x x' y X X'.\n       \\<lbrakk>eFresh MOD xs y X; eFresh MOD xs y X';\n        eSwap MOD xs y x X = eSwap MOD xs y x' X'\\<rbrakk>\n       \\<Longrightarrow> eAbs MOD xs x X = eAbs MOD xs x' X'", "have 1: \"?phi eX = ?phi eX'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eX = ERR \\<or>\n     (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))) =\n    (eX' = ERR \\<or>\n     (\\<exists>X. eX' = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. eX = ERR \\<or>\n    (\\<exists>X.\n        eX = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX' = ERR \\<or>\n    (\\<exists>X. eX' = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n 2. eX' = ERR \\<or>\n    (\\<exists>X.\n        eX' = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX = ERR \\<or>\n    (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "assume \"?phi eX\""], ["proof (state)\nthis:\n  eX = ERR \\<or>\n  (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n\ngoal (2 subgoals):\n 1. eX = ERR \\<or>\n    (\\<exists>X.\n        eX = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX' = ERR \\<or>\n    (\\<exists>X. eX' = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n 2. eX' = ERR \\<or>\n    (\\<exists>X.\n        eX' = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX = ERR \\<or>\n    (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "{"], ["proof (state)\nthis:\n  eX = ERR \\<or>\n  (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n\ngoal (2 subgoals):\n 1. eX = ERR \\<or>\n    (\\<exists>X.\n        eX = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX' = ERR \\<or>\n    (\\<exists>X. eX' = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n 2. eX' = ERR \\<or>\n    (\\<exists>X.\n        eX' = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX = ERR \\<or>\n    (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "fix X' s'"], ["proof (state)\ngoal (2 subgoals):\n 1. eX = ERR \\<or>\n    (\\<exists>X.\n        eX = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX' = ERR \\<or>\n    (\\<exists>X. eX' = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n 2. eX' = ERR \\<or>\n    (\\<exists>X.\n        eX' = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX = ERR \\<or>\n    (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "assume \"eX' = OK X' \\<and> (\\<exists> s. igWls MOD s X')\""], ["proof (state)\nthis:\n  eX' = OK X' \\<and> (\\<exists>s. igWls MOD s X')\n\ngoal (2 subgoals):\n 1. eX = ERR \\<or>\n    (\\<exists>X.\n        eX = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX' = ERR \\<or>\n    (\\<exists>X. eX' = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n 2. eX' = ERR \\<or>\n    (\\<exists>X.\n        eX' = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX = ERR \\<or>\n    (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "hence \"ERR = OK (igSwap MOD xs y x' X')\""], ["proof (prove)\nusing this:\n  eX' = OK X' \\<and> (\\<exists>s. igWls MOD s X')\n\ngoal (1 subgoal):\n 1. ERR = OK (igSwap MOD xs y x' X')", "using \\<open>?phi eX\\<close> ***"], ["proof (prove)\nusing this:\n  eX' = OK X' \\<and> (\\<exists>s. igWls MOD s X')\n  eX = ERR \\<or>\n  (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n  eSwap MOD xs y x eX = eSwap MOD xs y x' eX'\n\ngoal (1 subgoal):\n 1. ERR = OK (igSwap MOD xs y x' X')", "by auto"], ["proof (state)\nthis:\n  ERR = OK (igSwap MOD xs y x' X')\n\ngoal (2 subgoals):\n 1. eX = ERR \\<or>\n    (\\<exists>X.\n        eX = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX' = ERR \\<or>\n    (\\<exists>X. eX' = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n 2. eX' = ERR \\<or>\n    (\\<exists>X.\n        eX' = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX = ERR \\<or>\n    (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "}"], ["proof (state)\nthis:\n  eX' = OK ?X'109 \\<and> (\\<exists>s. igWls MOD s ?X'109) \\<Longrightarrow>\n  ERR = OK (igSwap MOD xs y x' ?X'109)\n\ngoal (2 subgoals):\n 1. eX = ERR \\<or>\n    (\\<exists>X.\n        eX = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX' = ERR \\<or>\n    (\\<exists>X. eX' = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n 2. eX' = ERR \\<or>\n    (\\<exists>X.\n        eX' = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX = ERR \\<or>\n    (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "thus \"?phi eX'\""], ["proof (prove)\nusing this:\n  eX' = OK ?X'109 \\<and> (\\<exists>s. igWls MOD s ?X'109) \\<Longrightarrow>\n  ERR = OK (igSwap MOD xs y x' ?X'109)\n\ngoal (1 subgoal):\n 1. eX' = ERR \\<or>\n    (\\<exists>X. eX' = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "by(cases eX', auto)"], ["proof (state)\nthis:\n  eX' = ERR \\<or>\n  (\\<exists>X. eX' = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n\ngoal (1 subgoal):\n 1. eX' = ERR \\<or>\n    (\\<exists>X.\n        eX' = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX = ERR \\<or>\n    (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eX' = ERR \\<or>\n    (\\<exists>X.\n        eX' = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX = ERR \\<or>\n    (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "assume \"?phi eX'\""], ["proof (state)\nthis:\n  eX' = ERR \\<or>\n  (\\<exists>X. eX' = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n\ngoal (1 subgoal):\n 1. eX' = ERR \\<or>\n    (\\<exists>X.\n        eX' = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX = ERR \\<or>\n    (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "{"], ["proof (state)\nthis:\n  eX' = ERR \\<or>\n  (\\<exists>X. eX' = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n\ngoal (1 subgoal):\n 1. eX' = ERR \\<or>\n    (\\<exists>X.\n        eX' = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX = ERR \\<or>\n    (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "fix X"], ["proof (state)\ngoal (1 subgoal):\n 1. eX' = ERR \\<or>\n    (\\<exists>X.\n        eX' = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX = ERR \\<or>\n    (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "assume \"eX = OK X \\<and> (\\<exists> s. igWls MOD s X)\""], ["proof (state)\nthis:\n  eX = OK X \\<and> (\\<exists>s. igWls MOD s X)\n\ngoal (1 subgoal):\n 1. eX' = ERR \\<or>\n    (\\<exists>X.\n        eX' = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX = ERR \\<or>\n    (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "hence \"ERR = OK (igSwap MOD xs y x X)\""], ["proof (prove)\nusing this:\n  eX = OK X \\<and> (\\<exists>s. igWls MOD s X)\n\ngoal (1 subgoal):\n 1. ERR = OK (igSwap MOD xs y x X)", "using \\<open>?phi eX'\\<close> ***"], ["proof (prove)\nusing this:\n  eX = OK X \\<and> (\\<exists>s. igWls MOD s X)\n  eX' = ERR \\<or>\n  (\\<exists>X. eX' = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n  eSwap MOD xs y x eX = eSwap MOD xs y x' eX'\n\ngoal (1 subgoal):\n 1. ERR = OK (igSwap MOD xs y x X)", "by auto"], ["proof (state)\nthis:\n  ERR = OK (igSwap MOD xs y x X)\n\ngoal (1 subgoal):\n 1. eX' = ERR \\<or>\n    (\\<exists>X.\n        eX' = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX = ERR \\<or>\n    (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "}"], ["proof (state)\nthis:\n  eX = OK ?X109 \\<and> (\\<exists>s. igWls MOD s ?X109) \\<Longrightarrow>\n  ERR = OK (igSwap MOD xs y x ?X109)\n\ngoal (1 subgoal):\n 1. eX' = ERR \\<or>\n    (\\<exists>X.\n        eX' = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eX = ERR \\<or>\n    (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "thus \"?phi eX\""], ["proof (prove)\nusing this:\n  eX = OK ?X109 \\<and> (\\<exists>s. igWls MOD s ?X109) \\<Longrightarrow>\n  ERR = OK (igSwap MOD xs y x ?X109)\n\ngoal (1 subgoal):\n 1. eX = ERR \\<or>\n    (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))", "by(cases eX, auto)"], ["proof (state)\nthis:\n  eX = ERR \\<or>\n  (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (eX = ERR \\<or>\n   (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))) =\n  (eX' = ERR \\<or>\n   (\\<exists>X. eX' = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X)))\n\ngoal (1 subgoal):\n 1. \\<And>xs x x' y X X'.\n       \\<lbrakk>eFresh MOD xs y X; eFresh MOD xs y X';\n        eSwap MOD xs y x X = eSwap MOD xs y x' X'\\<rbrakk>\n       \\<Longrightarrow> eAbs MOD xs x X = eAbs MOD xs x' X'", "show \"eAbs MOD xs x eX = eAbs MOD xs x' eX'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eAbs MOD xs x eX = eAbs MOD xs x' eX'", "proof(cases \"?phi eX\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eX = ERR \\<or>\n    (\\<exists>X.\n        eX = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'\n 2. \\<not> (eX = ERR \\<or>\n            (\\<exists>X.\n                eX = OK X \\<and>\n                (\\<forall>s. \\<not> igWls MOD s X))) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "case True"], ["proof (state)\nthis:\n  eX = ERR \\<or>\n  (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n\ngoal (2 subgoals):\n 1. eX = ERR \\<or>\n    (\\<exists>X.\n        eX = OK X \\<and>\n        (\\<forall>s. \\<not> igWls MOD s X)) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'\n 2. \\<not> (eX = ERR \\<or>\n            (\\<exists>X.\n                eX = OK X \\<and>\n                (\\<forall>s. \\<not> igWls MOD s X))) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "thus ?thesis"], ["proof (prove)\nusing this:\n  eX = ERR \\<or>\n  (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n\ngoal (1 subgoal):\n 1. eAbs MOD xs x eX = eAbs MOD xs x' eX'", "using 1"], ["proof (prove)\nusing this:\n  eX = ERR \\<or>\n  (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))\n  (eX = ERR \\<or>\n   (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))) =\n  (eX' = ERR \\<or>\n   (\\<exists>X. eX' = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X)))\n\ngoal (1 subgoal):\n 1. eAbs MOD xs x eX = eAbs MOD xs x' eX'", "by auto"], ["proof (state)\nthis:\n  eAbs MOD xs x eX = eAbs MOD xs x' eX'\n\ngoal (1 subgoal):\n 1. \\<not> (eX = ERR \\<or>\n            (\\<exists>X.\n                eX = OK X \\<and>\n                (\\<forall>s. \\<not> igWls MOD s X))) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (eX = ERR \\<or>\n            (\\<exists>X.\n                eX = OK X \\<and>\n                (\\<forall>s. \\<not> igWls MOD s X))) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "case False"], ["proof (state)\nthis:\n  \\<not> (eX = ERR \\<or>\n          (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X)))\n\ngoal (1 subgoal):\n 1. \\<not> (eX = ERR \\<or>\n            (\\<exists>X.\n                eX = OK X \\<and>\n                (\\<forall>s. \\<not> igWls MOD s X))) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "then"], ["proof (chain)\npicking this:\n  \\<not> (eX = ERR \\<or>\n          (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X)))", "obtain s X where eX: \"eX = OK X\" and X_wls: \"igWls MOD s X\""], ["proof (prove)\nusing this:\n  \\<not> (eX = ERR \\<or>\n          (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X)))\n\ngoal (1 subgoal):\n 1. (\\<And>X s.\n        \\<lbrakk>eX = OK X; igWls MOD s X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases eX, auto)"], ["proof (state)\nthis:\n  eX = OK X\n  igWls MOD s X\n\ngoal (1 subgoal):\n 1. \\<not> (eX = ERR \\<or>\n            (\\<exists>X.\n                eX = OK X \\<and>\n                (\\<forall>s. \\<not> igWls MOD s X))) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "obtain s' X' where eX': \"eX' = OK X'\" and X'_wls: \"igWls MOD s' X'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X' s'.\n        \\<lbrakk>eX' = OK X'; igWls MOD s' X'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>\\<not> ?phi eX\\<close> 1"], ["proof (prove)\nusing this:\n  \\<not> (eX = ERR \\<or>\n          (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X)))\n  (eX = ERR \\<or>\n   (\\<exists>X. eX = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X))) =\n  (eX' = ERR \\<or>\n   (\\<exists>X. eX' = OK X \\<and> (\\<forall>s. \\<not> igWls MOD s X)))\n\ngoal (1 subgoal):\n 1. (\\<And>X' s'.\n        \\<lbrakk>eX' = OK X'; igWls MOD s' X'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases eX') auto"], ["proof (state)\nthis:\n  eX' = OK X'\n  igWls MOD s' X'\n\ngoal (1 subgoal):\n 1. \\<not> (eX = ERR \\<or>\n            (\\<exists>X.\n                eX = OK X \\<and>\n                (\\<forall>s. \\<not> igWls MOD s X))) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "hence \"igSwap MOD xs y x X = igSwap MOD xs y x' X'\""], ["proof (prove)\nusing this:\n  eX' = OK X'\n  igWls MOD s' X'\n\ngoal (1 subgoal):\n 1. igSwap MOD xs y x X = igSwap MOD xs y x' X'", "using eX X_wls ***"], ["proof (prove)\nusing this:\n  eX' = OK X'\n  igWls MOD s' X'\n  eX = OK X\n  igWls MOD s X\n  eSwap MOD xs y x eX = eSwap MOD xs y x' eX'\n\ngoal (1 subgoal):\n 1. igSwap MOD xs y x X = igSwap MOD xs y x' X'", "by auto"], ["proof (state)\nthis:\n  igSwap MOD xs y x X = igSwap MOD xs y x' X'\n\ngoal (1 subgoal):\n 1. \\<not> (eX = ERR \\<or>\n            (\\<exists>X.\n                eX = OK X \\<and>\n                (\\<forall>s. \\<not> igWls MOD s X))) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "moreover"], ["proof (state)\nthis:\n  igSwap MOD xs y x X = igSwap MOD xs y x' X'\n\ngoal (1 subgoal):\n 1. \\<not> (eX = ERR \\<or>\n            (\\<exists>X.\n                eX = OK X \\<and>\n                (\\<forall>s. \\<not> igWls MOD s X))) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "have \"igWls MOD s (igSwap MOD xs y x X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls MOD s (igSwap MOD xs y x X)", "using X_wls \\<open>igSwapIPresIGWls MOD\\<close>"], ["proof (prove)\nusing this:\n  igWls MOD s X\n  igSwapIPresIGWls MOD\n\ngoal (1 subgoal):\n 1. igWls MOD s (igSwap MOD xs y x X)", "unfolding igSwapIPresIGWls_def"], ["proof (prove)\nusing this:\n  igWls MOD s X\n  \\<forall>zs z1 z2 s X.\n     igWls MOD s X \\<longrightarrow> igWls MOD s (igSwap MOD zs z1 z2 X)\n\ngoal (1 subgoal):\n 1. igWls MOD s (igSwap MOD xs y x X)", "by simp"], ["proof (state)\nthis:\n  igWls MOD s (igSwap MOD xs y x X)\n\ngoal (1 subgoal):\n 1. \\<not> (eX = ERR \\<or>\n            (\\<exists>X.\n                eX = OK X \\<and>\n                (\\<forall>s. \\<not> igWls MOD s X))) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "moreover"], ["proof (state)\nthis:\n  igWls MOD s (igSwap MOD xs y x X)\n\ngoal (1 subgoal):\n 1. \\<not> (eX = ERR \\<or>\n            (\\<exists>X.\n                eX = OK X \\<and>\n                (\\<forall>s. \\<not> igWls MOD s X))) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "have \"igWls MOD s' (igSwap MOD xs y x' X')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls MOD s' (igSwap MOD xs y x' X')", "using X'_wls \\<open>igSwapIPresIGWls MOD\\<close>"], ["proof (prove)\nusing this:\n  igWls MOD s' X'\n  igSwapIPresIGWls MOD\n\ngoal (1 subgoal):\n 1. igWls MOD s' (igSwap MOD xs y x' X')", "unfolding igSwapIPresIGWls_def"], ["proof (prove)\nusing this:\n  igWls MOD s' X'\n  \\<forall>zs z1 z2 s X.\n     igWls MOD s X \\<longrightarrow> igWls MOD s (igSwap MOD zs z1 z2 X)\n\ngoal (1 subgoal):\n 1. igWls MOD s' (igSwap MOD xs y x' X')", "by simp"], ["proof (state)\nthis:\n  igWls MOD s' (igSwap MOD xs y x' X')\n\ngoal (1 subgoal):\n 1. \\<not> (eX = ERR \\<or>\n            (\\<exists>X.\n                eX = OK X \\<and>\n                (\\<forall>s. \\<not> igWls MOD s X))) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "ultimately"], ["proof (chain)\npicking this:\n  igSwap MOD xs y x X = igSwap MOD xs y x' X'\n  igWls MOD s (igSwap MOD xs y x X)\n  igWls MOD s' (igSwap MOD xs y x' X')", "have \"s' = s\""], ["proof (prove)\nusing this:\n  igSwap MOD xs y x X = igSwap MOD xs y x' X'\n  igWls MOD s (igSwap MOD xs y x X)\n  igWls MOD s' (igSwap MOD xs y x' X')\n\ngoal (1 subgoal):\n 1. s' = s", "using \\<open>igWlsDisj MOD\\<close>"], ["proof (prove)\nusing this:\n  igSwap MOD xs y x X = igSwap MOD xs y x' X'\n  igWls MOD s (igSwap MOD xs y x X)\n  igWls MOD s' (igSwap MOD xs y x' X')\n  igWlsDisj MOD\n\ngoal (1 subgoal):\n 1. s' = s", "unfolding igWlsDisj_def"], ["proof (prove)\nusing this:\n  igSwap MOD xs y x X = igSwap MOD xs y x' X'\n  igWls MOD s (igSwap MOD xs y x X)\n  igWls MOD s' (igSwap MOD xs y x' X')\n  \\<forall>s s' X.\n     igWls MOD s X \\<and> igWls MOD s' X \\<longrightarrow> s = s'\n\ngoal (1 subgoal):\n 1. s' = s", "by auto"], ["proof (state)\nthis:\n  s' = s\n\ngoal (1 subgoal):\n 1. \\<not> (eX = ERR \\<or>\n            (\\<exists>X.\n                eX = OK X \\<and>\n                (\\<forall>s. \\<not> igWls MOD s X))) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eAbs MOD xs x eX = eAbs MOD xs x' eX'", "proof (cases \"isInBar (xs,s)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. isInBar (xs, s) \\<Longrightarrow> eAbs MOD xs x eX = eAbs MOD xs x' eX'\n 2. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "case True"], ["proof (state)\nthis:\n  isInBar (xs, s)\n\ngoal (2 subgoals):\n 1. isInBar (xs, s) \\<Longrightarrow> eAbs MOD xs x eX = eAbs MOD xs x' eX'\n 2. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "have \"igFresh MOD xs y X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFresh MOD xs y X", "using * X_wls"], ["proof (prove)\nusing this:\n  eFresh MOD xs y eX\n  igWls MOD s X\n\ngoal (1 subgoal):\n 1. igFresh MOD xs y X", "unfolding eX"], ["proof (prove)\nusing this:\n  eFresh MOD xs y (OK X)\n  igWls MOD s X\n\ngoal (1 subgoal):\n 1. igFresh MOD xs y X", "by simp"], ["proof (state)\nthis:\n  igFresh MOD xs y X\n\ngoal (2 subgoals):\n 1. isInBar (xs, s) \\<Longrightarrow> eAbs MOD xs x eX = eAbs MOD xs x' eX'\n 2. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "moreover"], ["proof (state)\nthis:\n  igFresh MOD xs y X\n\ngoal (2 subgoals):\n 1. isInBar (xs, s) \\<Longrightarrow> eAbs MOD xs x eX = eAbs MOD xs x' eX'\n 2. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "have \"igFresh MOD xs y X'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFresh MOD xs y X'", "using ** X'_wls"], ["proof (prove)\nusing this:\n  eFresh MOD xs y eX'\n  igWls MOD s' X'\n\ngoal (1 subgoal):\n 1. igFresh MOD xs y X'", "unfolding eX'"], ["proof (prove)\nusing this:\n  eFresh MOD xs y (OK X')\n  igWls MOD s' X'\n\ngoal (1 subgoal):\n 1. igFresh MOD xs y X'", "by simp"], ["proof (state)\nthis:\n  igFresh MOD xs y X'\n\ngoal (2 subgoals):\n 1. isInBar (xs, s) \\<Longrightarrow> eAbs MOD xs x eX = eAbs MOD xs x' eX'\n 2. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "moreover"], ["proof (state)\nthis:\n  igFresh MOD xs y X'\n\ngoal (2 subgoals):\n 1. isInBar (xs, s) \\<Longrightarrow> eAbs MOD xs x eX = eAbs MOD xs x' eX'\n 2. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "have \"igSwap MOD xs y x X = igSwap MOD xs y x' X'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwap MOD xs y x X = igSwap MOD xs y x' X'", "using *** X_wls X'_wls"], ["proof (prove)\nusing this:\n  eSwap MOD xs y x eX = eSwap MOD xs y x' eX'\n  igWls MOD s X\n  igWls MOD s' X'\n\ngoal (1 subgoal):\n 1. igSwap MOD xs y x X = igSwap MOD xs y x' X'", "unfolding eX eX'"], ["proof (prove)\nusing this:\n  eSwap MOD xs y x (OK X) = eSwap MOD xs y x' (OK X')\n  igWls MOD s X\n  igWls MOD s' X'\n\ngoal (1 subgoal):\n 1. igSwap MOD xs y x X = igSwap MOD xs y x' X'", "by simp"], ["proof (state)\nthis:\n  igSwap MOD xs y x X = igSwap MOD xs y x' X'\n\ngoal (2 subgoals):\n 1. isInBar (xs, s) \\<Longrightarrow> eAbs MOD xs x eX = eAbs MOD xs x' eX'\n 2. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "ultimately"], ["proof (chain)\npicking this:\n  igFresh MOD xs y X\n  igFresh MOD xs y X'\n  igSwap MOD xs y x X = igSwap MOD xs y x' X'", "show ?thesis"], ["proof (prove)\nusing this:\n  igFresh MOD xs y X\n  igFresh MOD xs y X'\n  igSwap MOD xs y x X = igSwap MOD xs y x' X'\n\ngoal (1 subgoal):\n 1. eAbs MOD xs x eX = eAbs MOD xs x' eX'", "unfolding eX eX'"], ["proof (prove)\nusing this:\n  igFresh MOD xs y X\n  igFresh MOD xs y X'\n  igSwap MOD xs y x X = igSwap MOD xs y x' X'\n\ngoal (1 subgoal):\n 1. eAbs MOD xs x (OK X) = eAbs MOD xs x' (OK X')", "using X_wls X'_wls"], ["proof (prove)\nusing this:\n  igFresh MOD xs y X\n  igFresh MOD xs y X'\n  igSwap MOD xs y x X = igSwap MOD xs y x' X'\n  igWls MOD s X\n  igWls MOD s' X'\n\ngoal (1 subgoal):\n 1. eAbs MOD xs x (OK X) = eAbs MOD xs x' (OK X')", "unfolding \\<open>s' = s\\<close>"], ["proof (prove)\nusing this:\n  igFresh MOD xs y X\n  igFresh MOD xs y X'\n  igSwap MOD xs y x X = igSwap MOD xs y x' X'\n  igWls MOD s X\n  igWls MOD s X'\n\ngoal (1 subgoal):\n 1. eAbs MOD xs x (OK X) = eAbs MOD xs x' (OK X')", "using \\<open>igAbsCongS MOD\\<close> True"], ["proof (prove)\nusing this:\n  igFresh MOD xs y X\n  igFresh MOD xs y X'\n  igSwap MOD xs y x X = igSwap MOD xs y x' X'\n  igWls MOD s X\n  igWls MOD s X'\n  igAbsCongS MOD\n  isInBar (xs, s)\n\ngoal (1 subgoal):\n 1. eAbs MOD xs x (OK X) = eAbs MOD xs x' (OK X')", "unfolding igAbsCongS_def"], ["proof (prove)\nusing this:\n  igFresh MOD xs y X\n  igFresh MOD xs y X'\n  igSwap MOD xs y x X = igSwap MOD xs y x' X'\n  igWls MOD s X\n  igWls MOD s X'\n  \\<forall>xs x x' y s X X'.\n     isInBar (xs, s) \\<and>\n     igWls MOD s X \\<and> igWls MOD s X' \\<longrightarrow>\n     igFresh MOD xs y X \\<and>\n     igFresh MOD xs y X' \\<and>\n     igSwap MOD xs y x X = igSwap MOD xs y x' X' \\<longrightarrow>\n     igAbs MOD xs x X = igAbs MOD xs x' X'\n  isInBar (xs, s)\n\ngoal (1 subgoal):\n 1. eAbs MOD xs x (OK X) = eAbs MOD xs x' (OK X')", "by (metis FixSyn.eCons_simps(2) FixSyn_axioms)"], ["proof (state)\nthis:\n  eAbs MOD xs x eX = eAbs MOD xs x' eX'\n\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "case False"], ["proof (state)\nthis:\n  \\<not> isInBar (xs, s)\n\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "{"], ["proof (state)\nthis:\n  \\<not> isInBar (xs, s)\n\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "fix s''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "assume xs_s'': \"isInBar (xs,s'')\" and \"igWls MOD s'' X\""], ["proof (state)\nthis:\n  isInBar (xs, s'')\n  igWls MOD s'' X\n\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "hence \"s = s''\""], ["proof (prove)\nusing this:\n  isInBar (xs, s'')\n  igWls MOD s'' X\n\ngoal (1 subgoal):\n 1. s = s''", "using X_wls \\<open>igWlsDisj MOD\\<close>"], ["proof (prove)\nusing this:\n  isInBar (xs, s'')\n  igWls MOD s'' X\n  igWls MOD s X\n  igWlsDisj MOD\n\ngoal (1 subgoal):\n 1. s = s''", "unfolding igWlsDisj_def"], ["proof (prove)\nusing this:\n  isInBar (xs, s'')\n  igWls MOD s'' X\n  igWls MOD s X\n  \\<forall>s s' X.\n     igWls MOD s X \\<and> igWls MOD s' X \\<longrightarrow> s = s'\n\ngoal (1 subgoal):\n 1. s = s''", "by auto"], ["proof (state)\nthis:\n  s = s''\n\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "hence False"], ["proof (prove)\nusing this:\n  s = s''\n\ngoal (1 subgoal):\n 1. False", "using False xs_s''"], ["proof (prove)\nusing this:\n  s = s''\n  \\<not> isInBar (xs, s)\n  isInBar (xs, s'')\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>isInBar (xs, ?s''109); igWls MOD ?s''109 X\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>isInBar (xs, ?s''109); igWls MOD ?s''109 X\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "{"], ["proof (state)\nthis:\n  \\<lbrakk>isInBar (xs, ?s''109); igWls MOD ?s''109 X\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "fix s''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "assume xs_s'': \"isInBar (xs,s'')\" and \"igWls MOD s'' X'\""], ["proof (state)\nthis:\n  isInBar (xs, s'')\n  igWls MOD s'' X'\n\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "hence \"s = s''\""], ["proof (prove)\nusing this:\n  isInBar (xs, s'')\n  igWls MOD s'' X'\n\ngoal (1 subgoal):\n 1. s = s''", "using X'_wls \\<open>igWlsDisj MOD\\<close>"], ["proof (prove)\nusing this:\n  isInBar (xs, s'')\n  igWls MOD s'' X'\n  igWls MOD s' X'\n  igWlsDisj MOD\n\ngoal (1 subgoal):\n 1. s = s''", "unfolding igWlsDisj_def \\<open>s' = s\\<close>"], ["proof (prove)\nusing this:\n  isInBar (xs, s'')\n  igWls MOD s'' X'\n  igWls MOD s X'\n  \\<forall>s s' X.\n     igWls MOD s X \\<and> igWls MOD s' X \\<longrightarrow> s = s'\n\ngoal (1 subgoal):\n 1. s = s''", "by auto"], ["proof (state)\nthis:\n  s = s''\n\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "hence False"], ["proof (prove)\nusing this:\n  s = s''\n\ngoal (1 subgoal):\n 1. False", "using False xs_s''"], ["proof (prove)\nusing this:\n  s = s''\n  \\<not> isInBar (xs, s)\n  isInBar (xs, s'')\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>isInBar (xs, ?s''109); igWls MOD ?s''109 X'\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> isInBar (xs, s) \\<Longrightarrow>\n    eAbs MOD xs x eX = eAbs MOD xs x' eX'", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>isInBar (xs, ?s''109); igWls MOD ?s''109 X\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>isInBar (xs, ?s''109); igWls MOD ?s''109 X'\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>isInBar (xs, ?s''109); igWls MOD ?s''109 X\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>isInBar (xs, ?s''109); igWls MOD ?s''109 X'\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. eAbs MOD xs x eX = eAbs MOD xs x' eX'", "using eX eX' X_wls X'_wls"], ["proof (prove)\nusing this:\n  \\<lbrakk>isInBar (xs, ?s''109); igWls MOD ?s''109 X\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>isInBar (xs, ?s''109); igWls MOD ?s''109 X'\\<rbrakk>\n  \\<Longrightarrow> False\n  eX = OK X\n  eX' = OK X'\n  igWls MOD s X\n  igWls MOD s' X'\n\ngoal (1 subgoal):\n 1. eAbs MOD xs x eX = eAbs MOD xs x' eX'", "unfolding \\<open>s' = s\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>isInBar (xs, ?s''109); igWls MOD ?s''109 X\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>isInBar (xs, ?s''109); igWls MOD ?s''109 X'\\<rbrakk>\n  \\<Longrightarrow> False\n  eX = OK X\n  eX' = OK X'\n  igWls MOD s X\n  igWls MOD s X'\n\ngoal (1 subgoal):\n 1. eAbs MOD xs x eX = eAbs MOD xs x' eX'", "by fastforce"], ["proof (state)\nthis:\n  eAbs MOD xs x eX = eAbs MOD xs x' eX'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eAbs MOD xs x eX = eAbs MOD xs x' eX'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eAbs MOD xs x eX = eAbs MOD xs x' eX'\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The renaming clause for abstractions holds:\\<close>"], ["", "lemma errMOD_igAbsRenSTR:\nassumes \"igVarIPresIGWls MOD\" and \"igSubstIPresIGWls MOD\"\nand \"igWlsDisj MOD\" and \"igAbsRen MOD\"\nshows \"igAbsRenSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbsRenSTR (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  igVarIPresIGWls MOD\n  igSubstIPresIGWls MOD\n  igWlsDisj MOD\n  igAbsRen MOD\n\ngoal (1 subgoal):\n 1. igAbsRenSTR (errMOD MOD)", "unfolding igAbsRenSTR_def"], ["proof (prove)\nusing this:\n  igVarIPresIGWls MOD\n  igSubstIPresIGWls MOD\n  igWlsDisj MOD\n  igAbsRen MOD\n\ngoal (1 subgoal):\n 1. \\<forall>xs y x X.\n       eFresh MOD xs y X \\<longrightarrow>\n       eAbs MOD xs y (eSubst MOD xs (eVar MOD xs y) x X) = eAbs MOD xs x X", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs y x X.\n       \\<lbrakk>igVarIPresIGWls MOD; igSubstIPresIGWls MOD; igWlsDisj MOD;\n        igAbsRen MOD; eFresh MOD xs y X\\<rbrakk>\n       \\<Longrightarrow> eAbs MOD xs y (eSubst MOD xs (eVar MOD xs y) x X) =\n                         eAbs MOD xs x X", "subgoal for xs y x eX"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igVarIPresIGWls MOD; igSubstIPresIGWls MOD; igWlsDisj MOD;\n     igAbsRen MOD; eFresh MOD xs y eX\\<rbrakk>\n    \\<Longrightarrow> eAbs MOD xs y (eSubst MOD xs (eVar MOD xs y) x eX) =\n                      eAbs MOD xs x eX", "apply(cases eX)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>igVarIPresIGWls MOD; igSubstIPresIGWls MOD; igWlsDisj MOD;\n     igAbsRen MOD; eFresh MOD xs y eX; eX = ERR\\<rbrakk>\n    \\<Longrightarrow> eAbs MOD xs y (eSubst MOD xs (eVar MOD xs y) x eX) =\n                      eAbs MOD xs x eX\n 2. \\<And>x2.\n       \\<lbrakk>igVarIPresIGWls MOD; igSubstIPresIGWls MOD; igWlsDisj MOD;\n        igAbsRen MOD; eFresh MOD xs y eX; eX = OK x2\\<rbrakk>\n       \\<Longrightarrow> eAbs MOD xs y\n                          (eSubst MOD xs (eVar MOD xs y) x eX) =\n                         eAbs MOD xs x eX", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igVarIPresIGWls MOD; igSubstIPresIGWls MOD; igWlsDisj MOD;\n     igAbsRen MOD; eFresh MOD xs y eX; eX = ERR\\<rbrakk>\n    \\<Longrightarrow> eAbs MOD xs y (eSubst MOD xs (eVar MOD xs y) x eX) =\n                      eAbs MOD xs x eX", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>igVarIPresIGWls MOD; igSubstIPresIGWls MOD; igWlsDisj MOD;\n        igAbsRen MOD; eFresh MOD xs y eX; eX = OK x2\\<rbrakk>\n       \\<Longrightarrow> eAbs MOD xs y\n                          (eSubst MOD xs (eVar MOD xs y) x eX) =\n                         eAbs MOD xs x eX", "subgoal for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igVarIPresIGWls MOD; igSubstIPresIGWls MOD; igWlsDisj MOD;\n     igAbsRen MOD; eFresh MOD xs y eX; eX = OK X\\<rbrakk>\n    \\<Longrightarrow> eAbs MOD xs y (eSubst MOD xs (eVar MOD xs y) x eX) =\n                      eAbs MOD xs x eX", "apply(cases \"EX s. isInBar (xs,s) \\<and> igWls MOD s X\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>igVarIPresIGWls MOD; igSubstIPresIGWls MOD; igWlsDisj MOD;\n     igAbsRen MOD; eFresh MOD xs y eX; eX = OK X;\n     \\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> eAbs MOD xs y (eSubst MOD xs (eVar MOD xs y) x eX) =\n                      eAbs MOD xs x eX\n 2. \\<lbrakk>igVarIPresIGWls MOD; igSubstIPresIGWls MOD; igWlsDisj MOD;\n     igAbsRen MOD; eFresh MOD xs y eX; eX = OK X;\n     \\<nexists>s. isInBar (xs, s) \\<and> igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> eAbs MOD xs y (eSubst MOD xs (eVar MOD xs y) x eX) =\n                      eAbs MOD xs x eX", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igVarIPresIGWls MOD; igSubstIPresIGWls MOD; igWlsDisj MOD;\n     igAbsRen MOD; eFresh MOD xs y eX; eX = OK X;\n     \\<exists>s. isInBar (xs, s) \\<and> igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> eAbs MOD xs y (eSubst MOD xs (eVar MOD xs y) x eX) =\n                      eAbs MOD xs x eX", "by (auto simp: igVarIPresIGWls_def igSubstIPresIGWls_def igAbsRen_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igVarIPresIGWls MOD; igSubstIPresIGWls MOD; igWlsDisj MOD;\n     igAbsRen MOD; eFresh MOD xs y eX; eX = OK X;\n     \\<nexists>s. isInBar (xs, s) \\<and> igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> eAbs MOD xs y (eSubst MOD xs (eVar MOD xs y) x eX) =\n                      eAbs MOD xs x eX", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igVarIPresIGWls MOD; igSubstIPresIGWls MOD; igWlsDisj MOD;\n     igAbsRen MOD; eFresh MOD xs y eX; eX = OK X;\n     \\<nexists>s. isInBar (xs, s) \\<and> igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> eAbs MOD xs y (eSubst MOD xs (eVar MOD xs y) x eX) =\n                      eAbs MOD xs x eX", "using assms"], ["proof (prove)\nusing this:\n  igVarIPresIGWls MOD\n  igSubstIPresIGWls MOD\n  igWlsDisj MOD\n  igAbsRen MOD\n\ngoal (1 subgoal):\n 1. \\<lbrakk>igVarIPresIGWls MOD; igSubstIPresIGWls MOD; igWlsDisj MOD;\n     igAbsRen MOD; eFresh MOD xs y eX; eX = OK X;\n     \\<nexists>s. isInBar (xs, s) \\<and> igWls MOD s X\\<rbrakk>\n    \\<Longrightarrow> eAbs MOD xs y (eSubst MOD xs (eVar MOD xs y) x eX) =\n                      eAbs MOD xs x eX", "by (simp add: igVarIPresIGWls_def igSubstIPresIGWls_def igAbsRen_def igWlsDisj_def)   \n     (metis eAbs_simp2 eAbs_simp3  eSubst_simp1 eSubst_simp3)"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text\\<open>Strong subst-based congruence for abstractions holds:\\<close>"], ["", "corollary errMOD_igAbsCongUSTR:\nassumes \"igVarIPresIGWls MOD\" and \"igSubstIPresIGWls MOD\"\nand \"igWlsDisj MOD\" and \"igAbsRen MOD\"\nshows \"igAbsCongUSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbsCongUSTR (errMOD MOD)", "using assms errMOD_igAbsRenSTR igAbsRenSTR_imp_igAbsCongUSTR"], ["proof (prove)\nusing this:\n  igVarIPresIGWls MOD\n  igSubstIPresIGWls MOD\n  igWlsDisj MOD\n  igAbsRen MOD\n  \\<lbrakk>igVarIPresIGWls ?MOD; igSubstIPresIGWls ?MOD; igWlsDisj ?MOD;\n   igAbsRen ?MOD\\<rbrakk>\n  \\<Longrightarrow> igAbsRenSTR (errMOD ?MOD)\n  igAbsRenSTR ?MOD \\<Longrightarrow> igAbsCongUSTR ?MOD\n\ngoal (1 subgoal):\n 1. igAbsCongUSTR (errMOD MOD)", "by auto"], ["", "text\\<open>The error model is a strongly well-sorted fresh-swap model:\\<close>"], ["", "lemma errMOD_iwlsFSwSTR:\nfixes MOD :: \"('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs) model\"\nassumes \"iwlsFSw MOD\"\nshows \"iwlsFSwSTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSwSTR (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  iwlsFSw MOD\n\ngoal (1 subgoal):\n 1. iwlsFSwSTR (errMOD MOD)", "unfolding iwlsFSw_def iwlsFSwSTR_def"], ["proof (prove)\nusing this:\n  igWlsAllDisj MOD \\<and>\n  igWlsAbsIsInBar MOD \\<and>\n  igConsIPresIGWls MOD \\<and>\n  igSwapAllIPresIGWlsAll MOD \\<and>\n  igFreshCls MOD \\<and> igSwapCls MOD \\<and> igAbsCongS MOD\n\ngoal (1 subgoal):\n 1. igWlsAllDisj (errMOD MOD) \\<and>\n    igWlsAbsIsInBar (errMOD MOD) \\<and>\n    igConsIPresIGWlsSTR (errMOD MOD) \\<and>\n    igSwapAllIPresIGWlsAllSTR (errMOD MOD) \\<and>\n    igFreshClsSTR (errMOD MOD) \\<and>\n    igSwapClsSTR (errMOD MOD) \\<and> igAbsCongSSTR (errMOD MOD)", "using errMOD_igWlsAllDisj[of MOD]\nerrMOD_igWlsAbsIsInBar[of MOD]\nerrMOD_igConsIPresIGWlsSTR[of MOD]\nerrMOD_igSwapAllIPresIGWlsAllSTR[of MOD]\nerrMOD_igFreshClsSTR[of MOD] errMOD_igSwapClsSTR[of MOD]\nerrMOD_igAbsCongSSTR[of MOD]"], ["proof (prove)\nusing this:\n  igWlsAllDisj MOD \\<and>\n  igWlsAbsIsInBar MOD \\<and>\n  igConsIPresIGWls MOD \\<and>\n  igSwapAllIPresIGWlsAll MOD \\<and>\n  igFreshCls MOD \\<and> igSwapCls MOD \\<and> igAbsCongS MOD\n  igWlsAllDisj MOD \\<Longrightarrow> igWlsAllDisj (errMOD MOD)\n  igWlsAbsIsInBar MOD \\<Longrightarrow> igWlsAbsIsInBar (errMOD MOD)\n  \\<lbrakk>igConsIPresIGWls MOD; igWlsAllDisj MOD;\n   igWlsAbsIsInBar MOD\\<rbrakk>\n  \\<Longrightarrow> igConsIPresIGWlsSTR (errMOD MOD)\n  \\<lbrakk>igSwapAllIPresIGWlsAll MOD; igWlsAllDisj MOD;\n   igWlsAbsIsInBar MOD\\<rbrakk>\n  \\<Longrightarrow> igSwapAllIPresIGWlsAllSTR (errMOD MOD)\n  \\<lbrakk>igConsIPresIGWls MOD; igFreshCls MOD\\<rbrakk>\n  \\<Longrightarrow> igFreshClsSTR (errMOD MOD)\n  \\<lbrakk>igWlsAllDisj MOD; igWlsDisj MOD; igWlsAbsIsInBar MOD;\n   igConsIPresIGWls MOD; igSwapAllIPresIGWlsAll MOD; igSwapCls MOD\\<rbrakk>\n  \\<Longrightarrow> igSwapClsSTR (errMOD MOD)\n  \\<lbrakk>igSwapIPresIGWls MOD; igWlsDisj MOD; igAbsCongS MOD\\<rbrakk>\n  \\<Longrightarrow> igAbsCongSSTR (errMOD MOD)\n\ngoal (1 subgoal):\n 1. igWlsAllDisj (errMOD MOD) \\<and>\n    igWlsAbsIsInBar (errMOD MOD) \\<and>\n    igConsIPresIGWlsSTR (errMOD MOD) \\<and>\n    igSwapAllIPresIGWlsAllSTR (errMOD MOD) \\<and>\n    igFreshClsSTR (errMOD MOD) \\<and>\n    igSwapClsSTR (errMOD MOD) \\<and> igAbsCongSSTR (errMOD MOD)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igWlsAllDisj MOD \\<and>\n             igWlsAbsIsInBar MOD \\<and>\n             igConsIPresIGWls MOD \\<and>\n             igSwapAllIPresIGWlsAll MOD \\<and>\n             igFreshCls MOD \\<and> igSwapCls MOD \\<and> igAbsCongS MOD;\n     igWlsAllDisj (errMOD MOD); igWlsAbsIsInBar (errMOD MOD);\n     igConsIPresIGWlsSTR (errMOD MOD);\n     igSwapAllIPresIGWlsAllSTR (errMOD MOD); igFreshClsSTR (errMOD MOD);\n     igWlsDisj MOD \\<Longrightarrow> igSwapClsSTR (errMOD MOD);\n     \\<lbrakk>igSwapIPresIGWls MOD; igWlsDisj MOD\\<rbrakk>\n     \\<Longrightarrow> igAbsCongSSTR (errMOD MOD)\\<rbrakk>\n    \\<Longrightarrow> igSwapClsSTR (errMOD MOD) \\<and>\n                      igAbsCongSSTR (errMOD MOD)", "unfolding igSwapAllIPresIGWlsAll_def igWlsAllDisj_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<forall>s s' X.\n                  igWls MOD s X \\<and> igWls MOD s' X \\<longrightarrow>\n                  s = s') \\<and>\n              (\\<forall>xs s xs' s' A.\n                  isInBar (xs, s) \\<and>\n                  isInBar (xs', s') \\<and>\n                  igWlsAbs MOD (xs, s) A \\<and>\n                  igWlsAbs MOD (xs', s') A \\<longrightarrow>\n                  xs = xs' \\<and> s = s')) \\<and>\n             igWlsAbsIsInBar MOD \\<and>\n             igConsIPresIGWls MOD \\<and>\n             (igSwapIPresIGWls MOD \\<and> igSwapAbsIPresIGWlsAbs MOD) \\<and>\n             igFreshCls MOD \\<and> igSwapCls MOD \\<and> igAbsCongS MOD;\n     (\\<forall>s s' X.\n         eWls MOD s X \\<and> eWls MOD s' X \\<longrightarrow> s = s') \\<and>\n     (\\<forall>xs s xs' s' A.\n         isInBar (xs, s) \\<and>\n         isInBar (xs', s') \\<and>\n         eWlsAbs MOD (xs, s) A \\<and>\n         eWlsAbs MOD (xs', s') A \\<longrightarrow>\n         xs = xs' \\<and> s = s');\n     igWlsAbsIsInBar (errMOD MOD); igConsIPresIGWlsSTR (errMOD MOD);\n     igSwapAllIPresIGWlsAllSTR (errMOD MOD); igFreshClsSTR (errMOD MOD);\n     \\<forall>s s' X.\n        igWls MOD s X \\<and> igWls MOD s' X \\<longrightarrow>\n        s = s' \\<Longrightarrow>\n     igSwapClsSTR (errMOD MOD);\n     \\<lbrakk>igSwapIPresIGWls MOD;\n      \\<forall>s s' X.\n         igWls MOD s X \\<and> igWls MOD s' X \\<longrightarrow>\n         s = s'\\<rbrakk>\n     \\<Longrightarrow> igAbsCongSSTR (errMOD MOD)\\<rbrakk>\n    \\<Longrightarrow> igSwapClsSTR (errMOD MOD) \\<and>\n                      igAbsCongSSTR (errMOD MOD)", "by simp"], ["", "text\\<open>The error model is a strongly well-sorted fresh-subst model:\\<close>"], ["", "lemma errMOD_iwlsFSbSwTR:\nfixes MOD :: \"('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs) model\"\nassumes \"iwlsFSb MOD\"\nshows \"iwlsFSbSwTR (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSbSwTR (errMOD MOD)", "using assms"], ["proof (prove)\nusing this:\n  iwlsFSb MOD\n\ngoal (1 subgoal):\n 1. iwlsFSbSwTR (errMOD MOD)", "unfolding iwlsFSb_def iwlsFSbSwTR_def"], ["proof (prove)\nusing this:\n  igWlsAllDisj MOD \\<and>\n  igWlsAbsIsInBar MOD \\<and>\n  igConsIPresIGWls MOD \\<and>\n  igSubstAllIPresIGWlsAll MOD \\<and>\n  igFreshCls MOD \\<and> igSubstCls MOD \\<and> igAbsRen MOD\n\ngoal (1 subgoal):\n 1. igWlsAllDisj (errMOD MOD) \\<and>\n    igWlsAbsIsInBar (errMOD MOD) \\<and>\n    igConsIPresIGWlsSTR (errMOD MOD) \\<and>\n    igSubstAllIPresIGWlsAllSTR (errMOD MOD) \\<and>\n    igFreshClsSTR (errMOD MOD) \\<and>\n    igSubstClsSTR (errMOD MOD) \\<and> igAbsRenSTR (errMOD MOD)", "using errMOD_igWlsAllDisj[of MOD]\nerrMOD_igWlsAbsIsInBar[of MOD]\nerrMOD_igConsIPresIGWlsSTR[of MOD]\nerrMOD_igSubstAllIPresIGWlsAllSTR[of MOD]\nerrMOD_igFreshClsSTR[of MOD] errMOD_igSubstClsSTR[of MOD]\nerrMOD_igAbsRenSTR[of MOD]"], ["proof (prove)\nusing this:\n  igWlsAllDisj MOD \\<and>\n  igWlsAbsIsInBar MOD \\<and>\n  igConsIPresIGWls MOD \\<and>\n  igSubstAllIPresIGWlsAll MOD \\<and>\n  igFreshCls MOD \\<and> igSubstCls MOD \\<and> igAbsRen MOD\n  igWlsAllDisj MOD \\<Longrightarrow> igWlsAllDisj (errMOD MOD)\n  igWlsAbsIsInBar MOD \\<Longrightarrow> igWlsAbsIsInBar (errMOD MOD)\n  \\<lbrakk>igConsIPresIGWls MOD; igWlsAllDisj MOD;\n   igWlsAbsIsInBar MOD\\<rbrakk>\n  \\<Longrightarrow> igConsIPresIGWlsSTR (errMOD MOD)\n  \\<lbrakk>igSubstAllIPresIGWlsAll MOD; igWlsAllDisj MOD;\n   igWlsAbsIsInBar MOD\\<rbrakk>\n  \\<Longrightarrow> igSubstAllIPresIGWlsAllSTR (errMOD MOD)\n  \\<lbrakk>igConsIPresIGWls MOD; igFreshCls MOD\\<rbrakk>\n  \\<Longrightarrow> igFreshClsSTR (errMOD MOD)\n  \\<lbrakk>igWlsAllDisj MOD; igConsIPresIGWls MOD; igWlsAbsIsInBar MOD;\n   igSubstAllIPresIGWlsAll MOD; igSubstCls MOD\\<rbrakk>\n  \\<Longrightarrow> igSubstClsSTR (errMOD MOD)\n  \\<lbrakk>igVarIPresIGWls MOD; igSubstIPresIGWls MOD; igWlsDisj MOD;\n   igAbsRen MOD\\<rbrakk>\n  \\<Longrightarrow> igAbsRenSTR (errMOD MOD)\n\ngoal (1 subgoal):\n 1. igWlsAllDisj (errMOD MOD) \\<and>\n    igWlsAbsIsInBar (errMOD MOD) \\<and>\n    igConsIPresIGWlsSTR (errMOD MOD) \\<and>\n    igSubstAllIPresIGWlsAllSTR (errMOD MOD) \\<and>\n    igFreshClsSTR (errMOD MOD) \\<and>\n    igSubstClsSTR (errMOD MOD) \\<and> igAbsRenSTR (errMOD MOD)", "by (simp add: igConsIPresIGWls_def igSubstAllIPresIGWlsAll_def igWlsAllDisj_defs)"], ["", "subsubsection \\<open>The natural morhpism from an error model to its original model\\<close>"], ["", "text\\<open>This morphism is igiven by the ``check\" functions.\\<close>"], ["", "text\\<open>Preservation of the domains:\\<close>"], ["", "lemma check_ipresIGWls:\n\"ipresIGWls check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGWls check (errMOD MOD) MOD", "unfolding ipresIGWls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s X. eWls MOD s X \\<longrightarrow> igWls MOD s (check X)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s X. eWls MOD s X \\<Longrightarrow> igWls MOD s (check X)", "subgoal for _ X"], ["proof (prove)\ngoal (1 subgoal):\n 1. eWls MOD s_ X \\<Longrightarrow> igWls MOD s_ (check X)", "by(cases X) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma check_ipresIGWlsAbs:\n\"ipresIGWlsAbs check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGWlsAbs check (errMOD MOD) MOD", "unfolding ipresIGWlsAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>us s A.\n       eWlsAbs MOD (us, s) A \\<longrightarrow>\n       igWlsAbs MOD (us, s) (check A)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>us s A.\n       eWlsAbs MOD (us, s) A \\<Longrightarrow>\n       igWlsAbs MOD (us, s) (check A)", "subgoal for _ _ A"], ["proof (prove)\ngoal (1 subgoal):\n 1. eWlsAbs MOD (us_, s_) A \\<Longrightarrow>\n    igWlsAbs MOD (us_, s_) (check A)", "by(cases A) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma check_ipresIGWlsAll:\n\"ipresIGWlsAll check check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGWlsAll check check (errMOD MOD) MOD", "unfolding ipresIGWlsAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGWls check (errMOD MOD) MOD \\<and>\n    ipresIGWlsAbs check (errMOD MOD) MOD", "using check_ipresIGWls check_ipresIGWlsAbs"], ["proof (prove)\nusing this:\n  ipresIGWls check (errMOD ?MOD) ?MOD\n  ipresIGWlsAbs check (errMOD ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. ipresIGWls check (errMOD MOD) MOD \\<and>\n    ipresIGWlsAbs check (errMOD MOD) MOD", "by auto"], ["", "text\\<open>Preservation of the operations:\\<close>"], ["", "lemma check_ipresIGVar:\n\"ipresIGVar check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGVar check (errMOD MOD) MOD", "unfolding ipresIGVar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs x. check (eVar MOD xs x) = igVar MOD xs x", "by simp"], ["", "lemma check_ipresIGAbs:\n\"ipresIGAbs check check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGAbs check check (errMOD MOD) MOD", "unfolding ipresIGAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs x s X.\n       isInBar (xs, s) \\<and> eWls MOD s X \\<longrightarrow>\n       check (eAbs MOD xs x X) = igAbs MOD xs x (check X)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); eWls MOD s X\\<rbrakk>\n       \\<Longrightarrow> check (eAbs MOD xs x X) = igAbs MOD xs x (check X)", "subgoal for _ _ _ X"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isInBar (xs_, s_); eWls MOD s_ X\\<rbrakk>\n    \\<Longrightarrow> check (eAbs MOD xs_ x_ X) = igAbs MOD xs_ x_ (check X)", "by(cases X) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma check_ipresIGOp:\n\"ipresIGOp check check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGOp check check (errMOD MOD) MOD", "unfolding ipresIGOp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>delta inp binp.\n       eWlsInp MOD delta inp \\<and>\n       eWlsBinp MOD delta binp \\<longrightarrow>\n       check (eOp MOD delta inp binp) =\n       igOp MOD delta (lift check inp) (lift check binp)", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>eWlsInp MOD delta inp; eWlsBinp MOD delta binp\\<rbrakk>\n       \\<Longrightarrow> check (eOp MOD delta inp binp) =\n                         igOp MOD delta (lift check inp) (lift check binp)", "fix delta einp ebinp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>eWlsInp MOD delta inp; eWlsBinp MOD delta binp\\<rbrakk>\n       \\<Longrightarrow> check (eOp MOD delta inp binp) =\n                         igOp MOD delta (lift check inp) (lift check binp)", "assume \"eWlsInp MOD delta einp\" and \"eWlsBinp MOD delta ebinp\""], ["proof (state)\nthis:\n  eWlsInp MOD delta einp\n  eWlsBinp MOD delta ebinp\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>eWlsInp MOD delta inp; eWlsBinp MOD delta binp\\<rbrakk>\n       \\<Longrightarrow> check (eOp MOD delta inp binp) =\n                         igOp MOD delta (lift check inp) (lift check binp)", "then"], ["proof (chain)\npicking this:\n  eWlsInp MOD delta einp\n  eWlsBinp MOD delta ebinp", "obtain inp binp where\n  \"igWlsInp MOD delta inp\" and \"igWlsBinp MOD delta binp\"\n  and \"einp = OKI inp\" and \"ebinp = OKI binp\""], ["proof (prove)\nusing this:\n  eWlsInp MOD delta einp\n  eWlsBinp MOD delta ebinp\n\ngoal (1 subgoal):\n 1. (\\<And>inp binp.\n        \\<lbrakk>igWlsInp MOD delta inp; igWlsBinp MOD delta binp;\n         einp = OKI inp; ebinp = OKI binp\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eWlsInp_invert eWlsBinp_invert"], ["proof (prove)\nusing this:\n  eWlsInp MOD delta einp\n  eWlsBinp MOD delta ebinp\n  eWlsInp ?MOD ?delta ?einp \\<Longrightarrow>\n  \\<exists>inp. igWlsInp ?MOD ?delta inp \\<and> ?einp = OKI inp\n  eWlsBinp ?MOD ?delta ?ebinp \\<Longrightarrow>\n  \\<exists>binp. igWlsBinp ?MOD ?delta binp \\<and> ?ebinp = OKI binp\n\ngoal (1 subgoal):\n 1. (\\<And>inp binp.\n        \\<lbrakk>igWlsInp MOD delta inp; igWlsBinp MOD delta binp;\n         einp = OKI inp; ebinp = OKI binp\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  igWlsInp MOD delta inp\n  igWlsBinp MOD delta binp\n  einp = OKI inp\n  ebinp = OKI binp\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>eWlsInp MOD delta inp; eWlsBinp MOD delta binp\\<rbrakk>\n       \\<Longrightarrow> check (eOp MOD delta inp binp) =\n                         igOp MOD delta (lift check inp) (lift check binp)", "hence \"check (eOp MOD delta einp ebinp) =\n         igOp MOD delta (checkI einp) (checkI ebinp)\""], ["proof (prove)\nusing this:\n  igWlsInp MOD delta inp\n  igWlsBinp MOD delta binp\n  einp = OKI inp\n  ebinp = OKI binp\n\ngoal (1 subgoal):\n 1. check (eOp MOD delta einp ebinp) =\n    igOp MOD delta (checkI einp) (checkI ebinp)", "by simp"], ["proof (state)\nthis:\n  check (eOp MOD delta einp ebinp) =\n  igOp MOD delta (checkI einp) (checkI ebinp)\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>eWlsInp MOD delta inp; eWlsBinp MOD delta binp\\<rbrakk>\n       \\<Longrightarrow> check (eOp MOD delta inp binp) =\n                         igOp MOD delta (lift check inp) (lift check binp)", "thus \"check (eOp MOD delta einp ebinp) =\n        igOp MOD delta (lift check einp) (lift check ebinp)\""], ["proof (prove)\nusing this:\n  check (eOp MOD delta einp ebinp) =\n  igOp MOD delta (checkI einp) (checkI ebinp)\n\ngoal (1 subgoal):\n 1. check (eOp MOD delta einp ebinp) =\n    igOp MOD delta (lift check einp) (lift check ebinp)", "unfolding checkI_def"], ["proof (prove)\nusing this:\n  check (eOp MOD delta einp ebinp) =\n  igOp MOD delta (lift check einp) (lift check ebinp)\n\ngoal (1 subgoal):\n 1. check (eOp MOD delta einp ebinp) =\n    igOp MOD delta (lift check einp) (lift check ebinp)", "."], ["proof (state)\nthis:\n  check (eOp MOD delta einp ebinp) =\n  igOp MOD delta (lift check einp) (lift check ebinp)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_ipresIGCons:\n\"ipresIGCons check check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGCons check check (errMOD MOD) MOD", "unfolding ipresIGCons_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGVar check (errMOD MOD) MOD \\<and>\n    ipresIGAbs check check (errMOD MOD) MOD \\<and>\n    ipresIGOp check check (errMOD MOD) MOD", "using\ncheck_ipresIGVar\ncheck_ipresIGAbs\ncheck_ipresIGOp"], ["proof (prove)\nusing this:\n  ipresIGVar check (errMOD ?MOD) ?MOD\n  ipresIGAbs check check (errMOD ?MOD) ?MOD\n  ipresIGOp check check (errMOD ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. ipresIGVar check (errMOD MOD) MOD \\<and>\n    ipresIGAbs check check (errMOD MOD) MOD \\<and>\n    ipresIGOp check check (errMOD MOD) MOD", "by auto"], ["", "lemma check_ipresIGFresh:\n\"ipresIGFresh check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGFresh check (errMOD MOD) MOD", "unfolding ipresIGFresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y s X.\n       eWls MOD s X \\<longrightarrow>\n       eFresh MOD ys y X \\<longrightarrow> igFresh MOD ys y (check X)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y s X.\n       \\<lbrakk>eWls MOD s X; eFresh MOD ys y X\\<rbrakk>\n       \\<Longrightarrow> igFresh MOD ys y (check X)", "subgoal for _ _ _ X"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eWls MOD s_ X; eFresh MOD ys_ y_ X\\<rbrakk>\n    \\<Longrightarrow> igFresh MOD ys_ y_ (check X)", "by(cases X) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma check_ipresIGFreshAbs:\n\"ipresIGFreshAbs check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGFreshAbs check (errMOD MOD) MOD", "unfolding ipresIGFreshAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y us s A.\n       eWlsAbs MOD (us, s) A \\<longrightarrow>\n       eFreshAbs MOD ys y A \\<longrightarrow> igFreshAbs MOD ys y (check A)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y us s A.\n       \\<lbrakk>eWlsAbs MOD (us, s) A; eFreshAbs MOD ys y A\\<rbrakk>\n       \\<Longrightarrow> igFreshAbs MOD ys y (check A)", "subgoal for _ _ _ _ A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eWlsAbs MOD (us_, s_) A; eFreshAbs MOD ys_ y_ A\\<rbrakk>\n    \\<Longrightarrow> igFreshAbs MOD ys_ y_ (check A)", "by(cases A) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma check_ipresIGFreshAll:\n\"ipresIGFreshAll check check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGFreshAll check check (errMOD MOD) MOD", "unfolding ipresIGFreshAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGFresh check (errMOD MOD) MOD \\<and>\n    ipresIGFreshAbs check (errMOD MOD) MOD", "using check_ipresIGFresh check_ipresIGFreshAbs"], ["proof (prove)\nusing this:\n  ipresIGFresh check (errMOD ?MOD) ?MOD\n  ipresIGFreshAbs check (errMOD ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. ipresIGFresh check (errMOD MOD) MOD \\<and>\n    ipresIGFreshAbs check (errMOD MOD) MOD", "by auto"], ["", "lemma check_ipresIGSwap:\n\"ipresIGSwap check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSwap check (errMOD MOD) MOD", "unfolding ipresIGSwap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 s X.\n       eWls MOD s X \\<longrightarrow>\n       check (eSwap MOD zs z1 z2 X) = igSwap MOD zs z1 z2 (check X)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 s X.\n       eWls MOD s X \\<Longrightarrow>\n       check (eSwap MOD zs z1 z2 X) = igSwap MOD zs z1 z2 (check X)", "subgoal for _ _ _ _ X"], ["proof (prove)\ngoal (1 subgoal):\n 1. eWls MOD s_ X \\<Longrightarrow>\n    check (eSwap MOD zs_ z1_ z2_ X) = igSwap MOD zs_ z1_ z2_ (check X)", "by(cases X) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma check_ipresIGSwapAbs:\n\"ipresIGSwapAbs check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSwapAbs check (errMOD MOD) MOD", "unfolding ipresIGSwapAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 us s A.\n       eWlsAbs MOD (us, s) A \\<longrightarrow>\n       check (eSwapAbs MOD zs z1 z2 A) = igSwapAbs MOD zs z1 z2 (check A)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 us s A.\n       eWlsAbs MOD (us, s) A \\<Longrightarrow>\n       check (eSwapAbs MOD zs z1 z2 A) = igSwapAbs MOD zs z1 z2 (check A)", "subgoal for _ _ _ _ _ A"], ["proof (prove)\ngoal (1 subgoal):\n 1. eWlsAbs MOD (us_, s_) A \\<Longrightarrow>\n    check (eSwapAbs MOD zs_ z1_ z2_ A) = igSwapAbs MOD zs_ z1_ z2_ (check A)", "by(cases A) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma check_ipresIGSwapAll:\n\"ipresIGSwapAll check check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSwapAll check check (errMOD MOD) MOD", "unfolding ipresIGSwapAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSwap check (errMOD MOD) MOD \\<and>\n    ipresIGSwapAbs check (errMOD MOD) MOD", "using check_ipresIGSwap check_ipresIGSwapAbs"], ["proof (prove)\nusing this:\n  ipresIGSwap check (errMOD ?MOD) ?MOD\n  ipresIGSwapAbs check (errMOD ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. ipresIGSwap check (errMOD MOD) MOD \\<and>\n    ipresIGSwapAbs check (errMOD MOD) MOD", "by auto"], ["", "lemma check_ipresIGSubst:\n\"ipresIGSubst check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSubst check (errMOD MOD) MOD", "unfolding ipresIGSubst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys Y y s X.\n       eWls MOD (asSort ys) Y \\<and> eWls MOD s X \\<longrightarrow>\n       check (eSubst MOD ys Y y X) = igSubst MOD ys (check Y) y (check X)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys Y y s X.\n       \\<lbrakk>eWls MOD (asSort ys) Y; eWls MOD s X\\<rbrakk>\n       \\<Longrightarrow> check (eSubst MOD ys Y y X) =\n                         igSubst MOD ys (check Y) y (check X)", "subgoal for _ Y _ _  X"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eWls MOD (asSort ys_) Y; eWls MOD s_ X\\<rbrakk>\n    \\<Longrightarrow> check (eSubst MOD ys_ Y y_ X) =\n                      igSubst MOD ys_ (check Y) y_ (check X)", "by (cases X, simp, cases Y) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma check_ipresIGSubstAbs:\n\"ipresIGSubstAbs check check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSubstAbs check check (errMOD MOD) MOD", "unfolding ipresIGSubstAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys Y y us s A.\n       eWls MOD (asSort ys) Y \\<and> eWlsAbs MOD (us, s) A \\<longrightarrow>\n       check (eSubstAbs MOD ys Y y A) =\n       igSubstAbs MOD ys (check Y) y (check A)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys Y y us s A.\n       \\<lbrakk>eWls MOD (asSort ys) Y; eWlsAbs MOD (us, s) A\\<rbrakk>\n       \\<Longrightarrow> check (eSubstAbs MOD ys Y y A) =\n                         igSubstAbs MOD ys (check Y) y (check A)", "subgoal for _ Y _ _ _ A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eWls MOD (asSort ys_) Y; eWlsAbs MOD (us_, s_) A\\<rbrakk>\n    \\<Longrightarrow> check (eSubstAbs MOD ys_ Y y_ A) =\n                      igSubstAbs MOD ys_ (check Y) y_ (check A)", "by (cases A, simp, cases Y) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma check_ipresIGSubstAll:\n\"ipresIGSubstAll check check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSubstAll check check (errMOD MOD) MOD", "unfolding ipresIGSubstAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGSubst check (errMOD MOD) MOD \\<and>\n    ipresIGSubstAbs check check (errMOD MOD) MOD", "using check_ipresIGSubst check_ipresIGSubstAbs"], ["proof (prove)\nusing this:\n  ipresIGSubst check (errMOD ?MOD) ?MOD\n  ipresIGSubstAbs check check (errMOD ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. ipresIGSubst check (errMOD MOD) MOD \\<and>\n    ipresIGSubstAbs check check (errMOD MOD) MOD", "by auto"], ["", "text\\<open>``check\" is a fresh-swap morphism:\\<close>"], ["", "lemma check_FSwImorph:\n\"FSwImorph check check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FSwImorph check check (errMOD MOD) MOD", "unfolding FSwImorph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGWlsAll check check (errMOD MOD) MOD \\<and>\n    ipresIGCons check check (errMOD MOD) MOD \\<and>\n    ipresIGFreshAll check check (errMOD MOD) MOD \\<and>\n    ipresIGSwapAll check check (errMOD MOD) MOD", "using check_ipresIGWlsAll check_ipresIGCons\ncheck_ipresIGFreshAll check_ipresIGSwapAll"], ["proof (prove)\nusing this:\n  ipresIGWlsAll check check (errMOD ?MOD) ?MOD\n  ipresIGCons check check (errMOD ?MOD) ?MOD\n  ipresIGFreshAll check check (errMOD ?MOD) ?MOD\n  ipresIGSwapAll check check (errMOD ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. ipresIGWlsAll check check (errMOD MOD) MOD \\<and>\n    ipresIGCons check check (errMOD MOD) MOD \\<and>\n    ipresIGFreshAll check check (errMOD MOD) MOD \\<and>\n    ipresIGSwapAll check check (errMOD MOD) MOD", "by auto"], ["", "text\\<open>``check\" is a fresh-subst morphism:\\<close>"], ["", "lemma check_FSbImorph:\n\"FSbImorph check check (errMOD MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FSbImorph check check (errMOD MOD) MOD", "unfolding FSbImorph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresIGWlsAll check check (errMOD MOD) MOD \\<and>\n    ipresIGCons check check (errMOD MOD) MOD \\<and>\n    ipresIGFreshAll check check (errMOD MOD) MOD \\<and>\n    ipresIGSubstAll check check (errMOD MOD) MOD", "using check_ipresIGWlsAll check_ipresIGCons\ncheck_ipresIGFreshAll check_ipresIGSubstAll"], ["proof (prove)\nusing this:\n  ipresIGWlsAll check check (errMOD ?MOD) ?MOD\n  ipresIGCons check check (errMOD ?MOD) ?MOD\n  ipresIGFreshAll check check (errMOD ?MOD) ?MOD\n  ipresIGSubstAll check check (errMOD ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. ipresIGWlsAll check check (errMOD MOD) MOD \\<and>\n    ipresIGCons check check (errMOD MOD) MOD \\<and>\n    ipresIGFreshAll check check (errMOD MOD) MOD \\<and>\n    ipresIGSubstAll check check (errMOD MOD) MOD", "by auto"], ["", "subsection \\<open>Initiality of the models of terms\\<close>"], ["", "text \\<open>We show that terms form initial models in all the considered kinds.\nThe desired initial morphism will be the composition of ``check\" with the\nfactorization of the standard (absolute-initial) function from quasi-terms, ``qInit\",\nto alpha-equivalence.\n``qInit\" preserving alpha-equivalence (in an unsorted fashion)\nwas the main reason for introducing error models.\\<close>"], ["", "(* Here we need to switch back for a while to the quasi-term ``implementation\" of terms: *)"], ["", "declare qItem_simps[simp]"], ["", "declare qItem_versus_item_simps[simp]"], ["", "declare good_item_simps[simp]"], ["", "subsubsection \\<open>The initial map from quasi-terms to a strong model\\<close>"], ["", "(* The next is needed in the termination arigument for ``qInit\": *)"], ["", "definition\naux_qInit_ignoreFirst ::\n\"('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs)model *\n ('index,'bindex,'varSort,'var,'opSym)qTerm +\n ('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs)model *\n ('index,'bindex,'varSort,'var,'opSym)qAbs \\<Rightarrow>\n ('index,'bindex,'varSort,'var,'opSym)qTermItem\"\nwhere\n\"aux_qInit_ignoreFirst K =\n (case K of Inl (MOD,qX) \\<Rightarrow> termIn qX\n           |Inr (MOD,qA) \\<Rightarrow> absIn qA)\""], ["", "lemma qTermLess_ingoreFirst_wf:\n\"wf (inv_image qTermLess aux_qInit_ignoreFirst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image qTermLess aux_qInit_ignoreFirst)", "using qTermLess_wf wf_inv_image"], ["proof (prove)\nusing this:\n  wf qTermLess\n  wf ?r \\<Longrightarrow> wf (inv_image ?r ?f)\n\ngoal (1 subgoal):\n 1. wf (inv_image qTermLess aux_qInit_ignoreFirst)", "by auto"], ["", "function\nqInit :: \"('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs)model \\<Rightarrow>\n          ('index,'bindex,'varSort,'var,'opSym)qTerm \\<Rightarrow> 'gTerm\"\nand\nqInitAbs :: \"('index,'bindex,'varSort,'sort,'opSym,'var,'gTerm,'gAbs)model \\<Rightarrow>\n          ('index,'bindex,'varSort,'var,'opSym)qAbs \\<Rightarrow> 'gAbs\"\nwhere\n\"qInit MOD (qVar xs x) = igVar MOD xs x\"\n|\n\"qInit MOD (qOp delta qinp qbinp) =\n igOp MOD delta (lift (qInit MOD) qinp) (lift (qInitAbs MOD) qbinp)\"\n|\n\"qInitAbs MOD (qAbs xs x qX) = igAbs MOD xs x (qInit MOD qX)\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>MOD xs xa.\n                   x = Inl (MOD, qVar xs xa) \\<Longrightarrow> P;\n        \\<And>MOD delta qinp qbinp.\n           x = Inl (MOD, qOp delta qinp qbinp) \\<Longrightarrow> P;\n        \\<And>MOD xs xa qX.\n           x = Inr (MOD, qAbs xs xa qX) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>MOD xs x MODa xsa xa.\n       Inl (MOD, qVar xs x) = Inl (MODa, qVar xsa xa) \\<Longrightarrow>\n       Inl (igVar MOD xs x) = Inl (igVar MODa xsa xa)\n 3. \\<And>MOD xs x MODa delta qinp qbinp.\n       Inl (MOD, qVar xs x) =\n       Inl (MODa, qOp delta qinp qbinp) \\<Longrightarrow>\n       Inl (igVar MOD xs x) =\n       Inl (igOp MODa delta\n             (lift\n               (\\<lambda>x1. projl (qInit_qInitAbs_sumC (Inl (MODa, x1))))\n               qinp)\n             (lift\n               (\\<lambda>x1. projr (qInit_qInitAbs_sumC (Inr (MODa, x1))))\n               qbinp))\n 4. \\<And>MOD xs x MODa xsa xa qX.\n       Inl (MOD, qVar xs x) = Inr (MODa, qAbs xsa xa qX) \\<Longrightarrow>\n       Inl (igVar MOD xs x) =\n       Inr (igAbs MODa xsa xa\n             (projl (qInit_qInitAbs_sumC (Inl (MODa, qX)))))\n 5. \\<And>MOD delta qinp qbinp MODa deltaa qinpa qbinpa.\n       Inl (MOD, qOp delta qinp qbinp) =\n       Inl (MODa, qOp deltaa qinpa qbinpa) \\<Longrightarrow>\n       Inl (igOp MOD delta\n             (lift\n               (\\<lambda>x1. projl (qInit_qInitAbs_sumC (Inl (MOD, x1))))\n               qinp)\n             (lift\n               (\\<lambda>x1. projr (qInit_qInitAbs_sumC (Inr (MOD, x1))))\n               qbinp)) =\n       Inl (igOp MODa deltaa\n             (lift\n               (\\<lambda>x1. projl (qInit_qInitAbs_sumC (Inl (MODa, x1))))\n               qinpa)\n             (lift\n               (\\<lambda>x1. projr (qInit_qInitAbs_sumC (Inr (MODa, x1))))\n               qbinpa))\n 6. \\<And>MOD delta qinp qbinp MODa xs x qX.\n       Inl (MOD, qOp delta qinp qbinp) =\n       Inr (MODa, qAbs xs x qX) \\<Longrightarrow>\n       Inl (igOp MOD delta\n             (lift\n               (\\<lambda>x1. projl (qInit_qInitAbs_sumC (Inl (MOD, x1))))\n               qinp)\n             (lift\n               (\\<lambda>x1. projr (qInit_qInitAbs_sumC (Inr (MOD, x1))))\n               qbinp)) =\n       Inr (igAbs MODa xs x (projl (qInit_qInitAbs_sumC (Inl (MODa, qX)))))\n 7. \\<And>MOD xs x qX MODa xsa xa qXa.\n       Inr (MOD, qAbs xs x qX) =\n       Inr (MODa, qAbs xsa xa qXa) \\<Longrightarrow>\n       Inr (igAbs MOD xs x (projl (qInit_qInitAbs_sumC (Inl (MOD, qX))))) =\n       Inr (igAbs MODa xsa xa\n             (projl (qInit_qInitAbs_sumC (Inl (MODa, qXa)))))", "by(pat_completeness) auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All qInit_qInitAbs_dom", "apply(relation \"inv_image qTermLess aux_qInit_ignoreFirst\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf (inv_image qTermLess aux_qInit_ignoreFirst)\n 2. \\<And>MOD delta qinp qbinp i v.\n       qinp i = Some v \\<Longrightarrow>\n       (Inl (MOD, v), Inl (MOD, qOp delta qinp qbinp))\n       \\<in> inv_image qTermLess aux_qInit_ignoreFirst\n 3. \\<And>MOD delta qinp qbinp i v.\n       qbinp i = Some v \\<Longrightarrow>\n       (Inr (MOD, v), Inl (MOD, qOp delta qinp qbinp))\n       \\<in> inv_image qTermLess aux_qInit_ignoreFirst\n 4. \\<And>MOD xs x qX.\n       (Inl (MOD, qX), Inr (MOD, qAbs xs x qX))\n       \\<in> inv_image qTermLess aux_qInit_ignoreFirst", "apply(simp add: qTermLess_ingoreFirst_wf)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>MOD delta qinp qbinp i v.\n       qinp i = Some v \\<Longrightarrow>\n       (Inl (MOD, v), Inl (MOD, qOp delta qinp qbinp))\n       \\<in> inv_image qTermLess aux_qInit_ignoreFirst\n 2. \\<And>MOD delta qinp qbinp i v.\n       qbinp i = Some v \\<Longrightarrow>\n       (Inr (MOD, v), Inl (MOD, qOp delta qinp qbinp))\n       \\<in> inv_image qTermLess aux_qInit_ignoreFirst\n 3. \\<And>MOD xs x qX.\n       (Inl (MOD, qX), Inr (MOD, qAbs xs x qX))\n       \\<in> inv_image qTermLess aux_qInit_ignoreFirst", "by(auto simp: qTermLess_def aux_qInit_ignoreFirst_def)"], ["", "lemma qFreshAll_igFreshAll_qInitAll:\nassumes \"igFreshClsSTR MOD\"\nshows\n\"(qFresh ys y qX \\<longrightarrow> igFresh MOD ys y (qInit MOD qX)) \\<and>\n (qFreshAbs ys y qA \\<longrightarrow> igFreshAbs MOD ys y (qInitAbs MOD qA))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (qFresh ys y qX \\<longrightarrow>\n     igFresh MOD ys y (qInit MOD qX)) \\<and>\n    (qFreshAbs ys y qA \\<longrightarrow>\n     igFreshAbs MOD ys y (qInitAbs MOD qA))", "apply(induct rule: qTerm_rawInduct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       qFresh ys y (qVar xs x) \\<longrightarrow>\n       igFresh MOD ys y (qInit MOD (qVar xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     qFresh ys y a \\<longrightarrow>\n                     igFresh MOD ys y (qInit MOD a))\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             qFreshAbs ys y a \\<longrightarrow>\n             igFreshAbs MOD ys y (qInitAbs MOD a))\n         binp\\<rbrakk>\n       \\<Longrightarrow> qFresh ys y (qOp delta inp binp) \\<longrightarrow>\n                         igFresh MOD ys y (qInit MOD (qOp delta inp binp))\n 3. \\<And>xs x X.\n       qFresh ys y X \\<longrightarrow>\n       igFresh MOD ys y (qInit MOD X) \\<Longrightarrow>\n       qFreshAbs ys y (qAbs xs x X) \\<longrightarrow>\n       igFreshAbs MOD ys y (qInitAbs MOD (qAbs xs x X))", "using assms"], ["proof (prove)\nusing this:\n  igFreshClsSTR MOD\n\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       qFresh ys y (qVar xs x) \\<longrightarrow>\n       igFresh MOD ys y (qInit MOD (qVar xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     qFresh ys y a \\<longrightarrow>\n                     igFresh MOD ys y (qInit MOD a))\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             qFreshAbs ys y a \\<longrightarrow>\n             igFreshAbs MOD ys y (qInitAbs MOD a))\n         binp\\<rbrakk>\n       \\<Longrightarrow> qFresh ys y (qOp delta inp binp) \\<longrightarrow>\n                         igFresh MOD ys y (qInit MOD (qOp delta inp binp))\n 3. \\<And>xs x X.\n       qFresh ys y X \\<longrightarrow>\n       igFresh MOD ys y (qInit MOD X) \\<Longrightarrow>\n       qFreshAbs ys y (qAbs xs x X) \\<longrightarrow>\n       igFreshAbs MOD ys y (qInitAbs MOD (qAbs xs x X))", "by (auto simp: igFreshClsSTR_def igFreshIGVar_def qFreshInp_def qFreshBinp_def liftAll_lift_comp\n  liftAll_def igFreshInp_def igFreshBinp_def lift_def igFreshIGAbs1STR_def igFreshIGAbs2STR_def igFreshIGOpSTR_def\n  split: option.splits)"], ["", "corollary iwlsFSwSTR_qFreshAll_igFreshAll_qInitAll:\nassumes \"iwlsFSwSTR MOD\"\nshows\n\"(qFresh ys y qX \\<longrightarrow> igFresh MOD ys y (qInit MOD qX)) \\<and>\n (qFreshAbs ys y qA \\<longrightarrow> igFreshAbs MOD ys y (qInitAbs MOD qA))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (qFresh ys y qX \\<longrightarrow>\n     igFresh MOD ys y (qInit MOD qX)) \\<and>\n    (qFreshAbs ys y qA \\<longrightarrow>\n     igFreshAbs MOD ys y (qInitAbs MOD qA))", "using assms"], ["proof (prove)\nusing this:\n  iwlsFSwSTR MOD\n\ngoal (1 subgoal):\n 1. (qFresh ys y qX \\<longrightarrow>\n     igFresh MOD ys y (qInit MOD qX)) \\<and>\n    (qFreshAbs ys y qA \\<longrightarrow>\n     igFreshAbs MOD ys y (qInitAbs MOD qA))", "unfolding iwlsFSwSTR_def"], ["proof (prove)\nusing this:\n  igWlsAllDisj MOD \\<and>\n  igWlsAbsIsInBar MOD \\<and>\n  igConsIPresIGWlsSTR MOD \\<and>\n  igSwapAllIPresIGWlsAllSTR MOD \\<and>\n  igFreshClsSTR MOD \\<and> igSwapClsSTR MOD \\<and> igAbsCongSSTR MOD\n\ngoal (1 subgoal):\n 1. (qFresh ys y qX \\<longrightarrow>\n     igFresh MOD ys y (qInit MOD qX)) \\<and>\n    (qFreshAbs ys y qA \\<longrightarrow>\n     igFreshAbs MOD ys y (qInitAbs MOD qA))", "by(simp add: qFreshAll_igFreshAll_qInitAll)"], ["", "corollary iwlsFSbSwTR_qFreshAll_igFreshAll_qInitAll:\nassumes \"iwlsFSbSwTR MOD\"\nshows\n\"(qFresh ys y qX \\<longrightarrow> igFresh MOD ys y (qInit MOD qX)) \\<and>\n (qFreshAbs ys y qA \\<longrightarrow> igFreshAbs MOD ys y (qInitAbs MOD qA))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (qFresh ys y qX \\<longrightarrow>\n     igFresh MOD ys y (qInit MOD qX)) \\<and>\n    (qFreshAbs ys y qA \\<longrightarrow>\n     igFreshAbs MOD ys y (qInitAbs MOD qA))", "using assms"], ["proof (prove)\nusing this:\n  iwlsFSbSwTR MOD\n\ngoal (1 subgoal):\n 1. (qFresh ys y qX \\<longrightarrow>\n     igFresh MOD ys y (qInit MOD qX)) \\<and>\n    (qFreshAbs ys y qA \\<longrightarrow>\n     igFreshAbs MOD ys y (qInitAbs MOD qA))", "unfolding iwlsFSbSwTR_def"], ["proof (prove)\nusing this:\n  igWlsAllDisj MOD \\<and>\n  igWlsAbsIsInBar MOD \\<and>\n  igConsIPresIGWlsSTR MOD \\<and>\n  igSubstAllIPresIGWlsAllSTR MOD \\<and>\n  igFreshClsSTR MOD \\<and> igSubstClsSTR MOD \\<and> igAbsRenSTR MOD\n\ngoal (1 subgoal):\n 1. (qFresh ys y qX \\<longrightarrow>\n     igFresh MOD ys y (qInit MOD qX)) \\<and>\n    (qFreshAbs ys y qA \\<longrightarrow>\n     igFreshAbs MOD ys y (qInitAbs MOD qA))", "by(simp add: qFreshAll_igFreshAll_qInitAll)"], ["", "lemma qSwapAll_igSwapAll_qInitAll:\nassumes \"igSwapClsSTR MOD\"\nshows\n\"qInit MOD (qX #[[ z1 \\<and> z2]]_zs) = igSwap MOD zs z1 z2 (qInit MOD qX) \\<and>\n qInitAbs MOD (qA $[[z1 \\<and> z2]]_zs) = igSwapAbs MOD zs z1 z2 (qInitAbs MOD qA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qInit MOD (qX #[[z1 \\<and> z2]]_zs) =\n    igSwap MOD zs z1 z2 (qInit MOD qX) \\<and>\n    qInitAbs MOD (qA $[[z1 \\<and> z2]]_zs) =\n    igSwapAbs MOD zs z1 z2 (qInitAbs MOD qA)", "proof(induction rule: qTerm_rawInduct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       qInit MOD (qVar xs x #[[z1 \\<and> z2]]_zs) =\n       igSwap MOD zs z1 z2 (qInit MOD (qVar xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     qInit MOD (a #[[z1 \\<and> z2]]_zs) =\n                     igSwap MOD zs z1 z2 (qInit MOD a))\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             qInitAbs MOD (a $[[z1 \\<and> z2]]_zs) =\n             igSwapAbs MOD zs z1 z2 (qInitAbs MOD a))\n         binp\\<rbrakk>\n       \\<Longrightarrow> qInit MOD\n                          (qOp delta inp binp #[[z1 \\<and> z2]]_zs) =\n                         igSwap MOD zs z1 z2\n                          (qInit MOD (qOp delta inp binp))\n 3. \\<And>xs x X.\n       qInit MOD (X #[[z1 \\<and> z2]]_zs) =\n       igSwap MOD zs z1 z2 (qInit MOD X) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n       igSwapAbs MOD zs z1 z2 (qInitAbs MOD (qAbs xs x X))", "case (Var xs x)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       qInit MOD (qVar xs x #[[z1 \\<and> z2]]_zs) =\n       igSwap MOD zs z1 z2 (qInit MOD (qVar xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     qInit MOD (a #[[z1 \\<and> z2]]_zs) =\n                     igSwap MOD zs z1 z2 (qInit MOD a))\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             qInitAbs MOD (a $[[z1 \\<and> z2]]_zs) =\n             igSwapAbs MOD zs z1 z2 (qInitAbs MOD a))\n         binp\\<rbrakk>\n       \\<Longrightarrow> qInit MOD\n                          (qOp delta inp binp #[[z1 \\<and> z2]]_zs) =\n                         igSwap MOD zs z1 z2\n                          (qInit MOD (qOp delta inp binp))\n 3. \\<And>xs x X.\n       qInit MOD (X #[[z1 \\<and> z2]]_zs) =\n       igSwap MOD zs z1 z2 (qInit MOD X) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n       igSwapAbs MOD zs z1 z2 (qInitAbs MOD (qAbs xs x X))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. qInit MOD (qVar xs x #[[z1 \\<and> z2]]_zs) =\n    igSwap MOD zs z1 z2 (qInit MOD (qVar xs x))", "using assms"], ["proof (prove)\nusing this:\n  igSwapClsSTR MOD\n\ngoal (1 subgoal):\n 1. qInit MOD (qVar xs x #[[z1 \\<and> z2]]_zs) =\n    igSwap MOD zs z1 z2 (qInit MOD (qVar xs x))", "unfolding igSwapClsSTR_def igSwapIGVar_def"], ["proof (prove)\nusing this:\n  (\\<forall>zs z1 z2 xs x.\n      igSwap MOD zs z1 z2 (igVar MOD xs x) =\n      igVar MOD xs (x @xs[z1 \\<and> z2]_zs)) \\<and>\n  igSwapIGAbsSTR MOD \\<and> igSwapIGOpSTR MOD\n\ngoal (1 subgoal):\n 1. qInit MOD (qVar xs x #[[z1 \\<and> z2]]_zs) =\n    igSwap MOD zs z1 z2 (qInit MOD (qVar xs x))", "by simp"], ["proof (state)\nthis:\n  qInit MOD (qVar xs x #[[z1 \\<and> z2]]_zs) =\n  igSwap MOD zs z1 z2 (qInit MOD (qVar xs x))\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     qInit MOD (a #[[z1 \\<and> z2]]_zs) =\n                     igSwap MOD zs z1 z2 (qInit MOD a))\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             qInitAbs MOD (a $[[z1 \\<and> z2]]_zs) =\n             igSwapAbs MOD zs z1 z2 (qInitAbs MOD a))\n         binp\\<rbrakk>\n       \\<Longrightarrow> qInit MOD\n                          (qOp delta inp binp #[[z1 \\<and> z2]]_zs) =\n                         igSwap MOD zs z1 z2\n                          (qInit MOD (qOp delta inp binp))\n 2. \\<And>xs x X.\n       qInit MOD (X #[[z1 \\<and> z2]]_zs) =\n       igSwap MOD zs z1 z2 (qInit MOD X) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n       igSwapAbs MOD zs z1 z2 (qInitAbs MOD (qAbs xs x X))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     qInit MOD (a #[[z1 \\<and> z2]]_zs) =\n                     igSwap MOD zs z1 z2 (qInit MOD a))\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             qInitAbs MOD (a $[[z1 \\<and> z2]]_zs) =\n             igSwapAbs MOD zs z1 z2 (qInitAbs MOD a))\n         binp\\<rbrakk>\n       \\<Longrightarrow> qInit MOD\n                          (qOp delta inp binp #[[z1 \\<and> z2]]_zs) =\n                         igSwap MOD zs z1 z2\n                          (qInit MOD (qOp delta inp binp))\n 2. \\<And>xs x X.\n       qInit MOD (X #[[z1 \\<and> z2]]_zs) =\n       igSwap MOD zs z1 z2 (qInit MOD X) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n       igSwapAbs MOD zs z1 z2 (qInitAbs MOD (qAbs xs x X))", "case (Op delta qinp qbinp)"], ["proof (state)\nthis:\n  liftAll\n   (\\<lambda>a.\n       qInit MOD (a #[[z1 \\<and> z2]]_zs) =\n       igSwap MOD zs z1 z2 (qInit MOD a))\n   qinp\n  liftAll\n   (\\<lambda>a.\n       qInitAbs MOD (a $[[z1 \\<and> z2]]_zs) =\n       igSwapAbs MOD zs z1 z2 (qInitAbs MOD a))\n   qbinp\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     qInit MOD (a #[[z1 \\<and> z2]]_zs) =\n                     igSwap MOD zs z1 z2 (qInit MOD a))\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             qInitAbs MOD (a $[[z1 \\<and> z2]]_zs) =\n             igSwapAbs MOD zs z1 z2 (qInitAbs MOD a))\n         binp\\<rbrakk>\n       \\<Longrightarrow> qInit MOD\n                          (qOp delta inp binp #[[z1 \\<and> z2]]_zs) =\n                         igSwap MOD zs z1 z2\n                          (qInit MOD (qOp delta inp binp))\n 2. \\<And>xs x X.\n       qInit MOD (X #[[z1 \\<and> z2]]_zs) =\n       igSwap MOD zs z1 z2 (qInit MOD X) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n       igSwapAbs MOD zs z1 z2 (qInitAbs MOD (qAbs xs x X))", "hence \"lift (qInit MOD) (qSwapInp zs z1 z2 qinp) =\n        igSwapInp MOD zs z1 z2 (lift (qInit MOD) qinp) \\<and>\n        lift (qInitAbs MOD) (qSwapBinp zs z1 z2 qbinp) =\n        igSwapBinp MOD zs z1 z2 (lift (qInitAbs MOD) qbinp)\""], ["proof (prove)\nusing this:\n  liftAll\n   (\\<lambda>a.\n       qInit MOD (a #[[z1 \\<and> z2]]_zs) =\n       igSwap MOD zs z1 z2 (qInit MOD a))\n   qinp\n  liftAll\n   (\\<lambda>a.\n       qInitAbs MOD (a $[[z1 \\<and> z2]]_zs) =\n       igSwapAbs MOD zs z1 z2 (qInitAbs MOD a))\n   qbinp\n\ngoal (1 subgoal):\n 1. lift (qInit MOD) (qSwapInp zs z1 z2 qinp) =\n    igSwapInp MOD zs z1 z2 (lift (qInit MOD) qinp) \\<and>\n    lift (qInitAbs MOD) (qSwapBinp zs z1 z2 qbinp) =\n    igSwapBinp MOD zs z1 z2 (lift (qInitAbs MOD) qbinp)", "using Op.IH"], ["proof (prove)\nusing this:\n  liftAll\n   (\\<lambda>a.\n       qInit MOD (a #[[z1 \\<and> z2]]_zs) =\n       igSwap MOD zs z1 z2 (qInit MOD a))\n   qinp\n  liftAll\n   (\\<lambda>a.\n       qInitAbs MOD (a $[[z1 \\<and> z2]]_zs) =\n       igSwapAbs MOD zs z1 z2 (qInitAbs MOD a))\n   qbinp\n  liftAll\n   (\\<lambda>a.\n       qInit MOD (a #[[z1 \\<and> z2]]_zs) =\n       igSwap MOD zs z1 z2 (qInit MOD a))\n   qinp\n  liftAll\n   (\\<lambda>a.\n       qInitAbs MOD (a $[[z1 \\<and> z2]]_zs) =\n       igSwapAbs MOD zs z1 z2 (qInitAbs MOD a))\n   qbinp\n\ngoal (1 subgoal):\n 1. lift (qInit MOD) (qSwapInp zs z1 z2 qinp) =\n    igSwapInp MOD zs z1 z2 (lift (qInit MOD) qinp) \\<and>\n    lift (qInitAbs MOD) (qSwapBinp zs z1 z2 qbinp) =\n    igSwapBinp MOD zs z1 z2 (lift (qInitAbs MOD) qbinp)", "by (auto simp: qSwapInp_def qSwapBinp_def igSwapInp_def lift_def liftAll_def \n  igSwapBinp_def iwlsFSwSTR_def igSwapClsSTR_def igSwapIGOpSTR_def\n  split: option.splits)"], ["proof (state)\nthis:\n  lift (qInit MOD) (qSwapInp zs z1 z2 qinp) =\n  igSwapInp MOD zs z1 z2 (lift (qInit MOD) qinp) \\<and>\n  lift (qInitAbs MOD) (qSwapBinp zs z1 z2 qbinp) =\n  igSwapBinp MOD zs z1 z2 (lift (qInitAbs MOD) qbinp)\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     qInit MOD (a #[[z1 \\<and> z2]]_zs) =\n                     igSwap MOD zs z1 z2 (qInit MOD a))\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             qInitAbs MOD (a $[[z1 \\<and> z2]]_zs) =\n             igSwapAbs MOD zs z1 z2 (qInitAbs MOD a))\n         binp\\<rbrakk>\n       \\<Longrightarrow> qInit MOD\n                          (qOp delta inp binp #[[z1 \\<and> z2]]_zs) =\n                         igSwap MOD zs z1 z2\n                          (qInit MOD (qOp delta inp binp))\n 2. \\<And>xs x X.\n       qInit MOD (X #[[z1 \\<and> z2]]_zs) =\n       igSwap MOD zs z1 z2 (qInit MOD X) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n       igSwapAbs MOD zs z1 z2 (qInitAbs MOD (qAbs xs x X))", "thus ?case"], ["proof (prove)\nusing this:\n  lift (qInit MOD) (qSwapInp zs z1 z2 qinp) =\n  igSwapInp MOD zs z1 z2 (lift (qInit MOD) qinp) \\<and>\n  lift (qInitAbs MOD) (qSwapBinp zs z1 z2 qbinp) =\n  igSwapBinp MOD zs z1 z2 (lift (qInitAbs MOD) qbinp)\n\ngoal (1 subgoal):\n 1. qInit MOD (qOp delta qinp qbinp #[[z1 \\<and> z2]]_zs) =\n    igSwap MOD zs z1 z2 (qInit MOD (qOp delta qinp qbinp))", "using assms"], ["proof (prove)\nusing this:\n  lift (qInit MOD) (qSwapInp zs z1 z2 qinp) =\n  igSwapInp MOD zs z1 z2 (lift (qInit MOD) qinp) \\<and>\n  lift (qInitAbs MOD) (qSwapBinp zs z1 z2 qbinp) =\n  igSwapBinp MOD zs z1 z2 (lift (qInitAbs MOD) qbinp)\n  igSwapClsSTR MOD\n\ngoal (1 subgoal):\n 1. qInit MOD (qOp delta qinp qbinp #[[z1 \\<and> z2]]_zs) =\n    igSwap MOD zs z1 z2 (qInit MOD (qOp delta qinp qbinp))", "unfolding iwlsFSwSTR_def igSwapClsSTR_def igSwapIGOpSTR_def"], ["proof (prove)\nusing this:\n  lift (qInit MOD) (qSwapInp zs z1 z2 qinp) =\n  igSwapInp MOD zs z1 z2 (lift (qInit MOD) qinp) \\<and>\n  lift (qInitAbs MOD) (qSwapBinp zs z1 z2 qbinp) =\n  igSwapBinp MOD zs z1 z2 (lift (qInitAbs MOD) qbinp)\n  igSwapIGVar MOD \\<and>\n  igSwapIGAbsSTR MOD \\<and>\n  (\\<forall>zs z1 z2 delta inp binp.\n      igSwap MOD zs z1 z2 (igOp MOD delta inp binp) =\n      igOp MOD delta (igSwapInp MOD zs z1 z2 inp)\n       (igSwapBinp MOD zs z1 z2 binp))\n\ngoal (1 subgoal):\n 1. qInit MOD (qOp delta qinp qbinp #[[z1 \\<and> z2]]_zs) =\n    igSwap MOD zs z1 z2 (qInit MOD (qOp delta qinp qbinp))", "by simp"], ["proof (state)\nthis:\n  qInit MOD (qOp delta qinp qbinp #[[z1 \\<and> z2]]_zs) =\n  igSwap MOD zs z1 z2 (qInit MOD (qOp delta qinp qbinp))\n\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       qInit MOD (X #[[z1 \\<and> z2]]_zs) =\n       igSwap MOD zs z1 z2 (qInit MOD X) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n       igSwapAbs MOD zs z1 z2 (qInitAbs MOD (qAbs xs x X))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       qInit MOD (X #[[z1 \\<and> z2]]_zs) =\n       igSwap MOD zs z1 z2 (qInit MOD X) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n       igSwapAbs MOD zs z1 z2 (qInitAbs MOD (qAbs xs x X))", "case (Abs xs x X)"], ["proof (state)\nthis:\n  qInit MOD (X #[[z1 \\<and> z2]]_zs) = igSwap MOD zs z1 z2 (qInit MOD X)\n\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       qInit MOD (X #[[z1 \\<and> z2]]_zs) =\n       igSwap MOD zs z1 z2 (qInit MOD X) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n       igSwapAbs MOD zs z1 z2 (qInitAbs MOD (qAbs xs x X))", "then"], ["proof (chain)\npicking this:\n  qInit MOD (X #[[z1 \\<and> z2]]_zs) = igSwap MOD zs z1 z2 (qInit MOD X)", "show ?case"], ["proof (prove)\nusing this:\n  qInit MOD (X #[[z1 \\<and> z2]]_zs) = igSwap MOD zs z1 z2 (qInit MOD X)\n\ngoal (1 subgoal):\n 1. qInitAbs MOD (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n    igSwapAbs MOD zs z1 z2 (qInitAbs MOD (qAbs xs x X))", "using assms"], ["proof (prove)\nusing this:\n  qInit MOD (X #[[z1 \\<and> z2]]_zs) = igSwap MOD zs z1 z2 (qInit MOD X)\n  igSwapClsSTR MOD\n\ngoal (1 subgoal):\n 1. qInitAbs MOD (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n    igSwapAbs MOD zs z1 z2 (qInitAbs MOD (qAbs xs x X))", "unfolding igSwapClsSTR_def igSwapIGAbsSTR_def"], ["proof (prove)\nusing this:\n  qInit MOD (X #[[z1 \\<and> z2]]_zs) = igSwap MOD zs z1 z2 (qInit MOD X)\n  igSwapIGVar MOD \\<and>\n  (\\<forall>zs z1 z2 xs x X.\n      igSwapAbs MOD zs z1 z2 (igAbs MOD xs x X) =\n      igAbs MOD xs (x @xs[z1 \\<and> z2]_zs) (igSwap MOD zs z1 z2 X)) \\<and>\n  igSwapIGOpSTR MOD\n\ngoal (1 subgoal):\n 1. qInitAbs MOD (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n    igSwapAbs MOD zs z1 z2 (qInitAbs MOD (qAbs xs x X))", "by simp"], ["proof (state)\nthis:\n  qInitAbs MOD (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n  igSwapAbs MOD zs z1 z2 (qInitAbs MOD (qAbs xs x X))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary iwlsFSwSTR_qSwapAll_igSwapAll_qInitAll:\nassumes wls: \"iwlsFSwSTR MOD\"\nshows\n\"qInit MOD (qX #[[ z1 \\<and> z2]]_zs) = igSwap MOD zs z1 z2 (qInit MOD qX) \\<and>\n qInitAbs MOD (qA $[[z1 \\<and> z2]]_zs) = igSwapAbs MOD zs z1 z2 (qInitAbs MOD qA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qInit MOD (qX #[[z1 \\<and> z2]]_zs) =\n    igSwap MOD zs z1 z2 (qInit MOD qX) \\<and>\n    qInitAbs MOD (qA $[[z1 \\<and> z2]]_zs) =\n    igSwapAbs MOD zs z1 z2 (qInitAbs MOD qA)", "using assms"], ["proof (prove)\nusing this:\n  iwlsFSwSTR MOD\n\ngoal (1 subgoal):\n 1. qInit MOD (qX #[[z1 \\<and> z2]]_zs) =\n    igSwap MOD zs z1 z2 (qInit MOD qX) \\<and>\n    qInitAbs MOD (qA $[[z1 \\<and> z2]]_zs) =\n    igSwapAbs MOD zs z1 z2 (qInitAbs MOD qA)", "unfolding iwlsFSwSTR_def"], ["proof (prove)\nusing this:\n  igWlsAllDisj MOD \\<and>\n  igWlsAbsIsInBar MOD \\<and>\n  igConsIPresIGWlsSTR MOD \\<and>\n  igSwapAllIPresIGWlsAllSTR MOD \\<and>\n  igFreshClsSTR MOD \\<and> igSwapClsSTR MOD \\<and> igAbsCongSSTR MOD\n\ngoal (1 subgoal):\n 1. qInit MOD (qX #[[z1 \\<and> z2]]_zs) =\n    igSwap MOD zs z1 z2 (qInit MOD qX) \\<and>\n    qInitAbs MOD (qA $[[z1 \\<and> z2]]_zs) =\n    igSwapAbs MOD zs z1 z2 (qInitAbs MOD qA)", "by(simp add: qSwapAll_igSwapAll_qInitAll)"], ["", "lemma qSwapAll_igSubstAll_qInitAll:\nfixes qX::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      qA::\"('index,'bindex,'varSort,'var,'opSym)qAbs\"\nassumes *: \"igSubstClsSTR MOD\"  and \"igFreshClsSTR MOD\"\nand \"igAbsRenSTR MOD\"\nshows\n\"(qGood qX \\<longrightarrow>\n  (\\<forall> ys y1 y.\n     qAFresh ys y1 qX \\<longrightarrow>\n     qInit MOD (qX #[[y1 \\<and> y]]_ys) = igSubst MOD ys (igVar MOD ys y1) y (qInit MOD qX)))\n \\<and>\n (qGoodAbs qA \\<longrightarrow>\n  (\\<forall> ys y1 y.\n     qAFreshAbs ys y1 qA \\<longrightarrow>\n     qInitAbs MOD (qA $[[y1 \\<and> y]]_ys) = igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD qA)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (qGood qX \\<longrightarrow>\n     (\\<forall>ys y1 y.\n         qAFresh ys y1 qX \\<longrightarrow>\n         qInit MOD (qX #[[y1 \\<and> y]]_ys) =\n         igSubst MOD ys (igVar MOD ys y1) y (qInit MOD qX))) \\<and>\n    (qGoodAbs qA \\<longrightarrow>\n     (\\<forall>ys y1 y.\n         qAFreshAbs ys y1 qA \\<longrightarrow>\n         qInitAbs MOD (qA $[[y1 \\<and> y]]_ys) =\n         igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD qA)))", "proof(induction rule: qGood_qTerm_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       \\<forall>ys y1 y.\n          qAFresh ys y1 (qVar xs x) \\<longrightarrow>\n          qInit MOD (qVar xs x #[[y1 \\<and> y]]_ys) =\n          igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qVar xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>|{i. inp i \\<noteq> None}| <o |UNIV|;\n        |{i. binp i \\<noteq> None}| <o |UNIV|;\n        liftAll\n         (\\<lambda>X.\n             qGood X \\<and>\n             (\\<forall>ys y1 y.\n                 qAFresh ys y1 X \\<longrightarrow>\n                 qInit MOD (X #[[y1 \\<and> y]]_ys) =\n                 igSubst MOD ys (igVar MOD ys y1) y (qInit MOD X)))\n         inp;\n        liftAll\n         (\\<lambda>A.\n             qGoodAbs A \\<and>\n             (\\<forall>ys y1 y.\n                 qAFreshAbs ys y1 A \\<longrightarrow>\n                 qInitAbs MOD (A $[[y1 \\<and> y]]_ys) =\n                 igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD A)))\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFresh ys y1\n                             (qOp delta inp binp) \\<longrightarrow>\n                            qInit MOD\n                             (qOp delta inp binp #[[y1 \\<and> y]]_ys) =\n                            igSubst MOD ys (igVar MOD ys y1) y\n                             (qInit MOD (qOp delta inp binp))\n 3. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y);\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFreshAbs ys y1 (qAbs xs x X) \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X $[[y1 \\<and> y]]_ys) =\n                            igSubstAbs MOD ys (igVar MOD ys y1) y\n                             (qInitAbs MOD (qAbs xs x X))", "case (Var xs x)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       \\<forall>ys y1 y.\n          qAFresh ys y1 (qVar xs x) \\<longrightarrow>\n          qInit MOD (qVar xs x #[[y1 \\<and> y]]_ys) =\n          igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qVar xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>|{i. inp i \\<noteq> None}| <o |UNIV|;\n        |{i. binp i \\<noteq> None}| <o |UNIV|;\n        liftAll\n         (\\<lambda>X.\n             qGood X \\<and>\n             (\\<forall>ys y1 y.\n                 qAFresh ys y1 X \\<longrightarrow>\n                 qInit MOD (X #[[y1 \\<and> y]]_ys) =\n                 igSubst MOD ys (igVar MOD ys y1) y (qInit MOD X)))\n         inp;\n        liftAll\n         (\\<lambda>A.\n             qGoodAbs A \\<and>\n             (\\<forall>ys y1 y.\n                 qAFreshAbs ys y1 A \\<longrightarrow>\n                 qInitAbs MOD (A $[[y1 \\<and> y]]_ys) =\n                 igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD A)))\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFresh ys y1\n                             (qOp delta inp binp) \\<longrightarrow>\n                            qInit MOD\n                             (qOp delta inp binp #[[y1 \\<and> y]]_ys) =\n                            igSubst MOD ys (igVar MOD ys y1) y\n                             (qInit MOD (qOp delta inp binp))\n 3. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y);\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFreshAbs ys y1 (qAbs xs x X) \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X $[[y1 \\<and> y]]_ys) =\n                            igSubstAbs MOD ys (igVar MOD ys y1) y\n                             (qInitAbs MOD (qAbs xs x X))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y1 y.\n       qAFresh ys y1 (qVar xs x) \\<longrightarrow>\n       qInit MOD (qVar xs x #[[y1 \\<and> y]]_ys) =\n       igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qVar xs x))", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFresh ys y1 (qVar xs x) \\<Longrightarrow>\n       qInit MOD (qVar xs x #[[y1 \\<and> y]]_ys) =\n       igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qVar xs x))", "subgoal for ys y1 y"], ["proof (prove)\ngoal (1 subgoal):\n 1. qAFresh ys y1 (qVar xs x) \\<Longrightarrow>\n    qInit MOD (qVar xs x #[[y1 \\<and> y]]_ys) =\n    igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qVar xs x))", "using *"], ["proof (prove)\nusing this:\n  igSubstClsSTR MOD\n\ngoal (1 subgoal):\n 1. qAFresh ys y1 (qVar xs x) \\<Longrightarrow>\n    qInit MOD (qVar xs x #[[y1 \\<and> y]]_ys) =\n    igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qVar xs x))", "by (cases \"ys = xs \\<and> y = x\")\n     (auto simp:  igSubstClsSTR_defs igSubstIGVar2STR_def igSubstClsSTR_defs igSubstIGVar1STR_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\nthis:\n  \\<forall>ys y1 y.\n     qAFresh ys y1 (qVar xs x) \\<longrightarrow>\n     qInit MOD (qVar xs x #[[y1 \\<and> y]]_ys) =\n     igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qVar xs x))\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>|{i. inp i \\<noteq> None}| <o |UNIV|;\n        |{i. binp i \\<noteq> None}| <o |UNIV|;\n        liftAll\n         (\\<lambda>X.\n             qGood X \\<and>\n             (\\<forall>ys y1 y.\n                 qAFresh ys y1 X \\<longrightarrow>\n                 qInit MOD (X #[[y1 \\<and> y]]_ys) =\n                 igSubst MOD ys (igVar MOD ys y1) y (qInit MOD X)))\n         inp;\n        liftAll\n         (\\<lambda>A.\n             qGoodAbs A \\<and>\n             (\\<forall>ys y1 y.\n                 qAFreshAbs ys y1 A \\<longrightarrow>\n                 qInitAbs MOD (A $[[y1 \\<and> y]]_ys) =\n                 igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD A)))\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFresh ys y1\n                             (qOp delta inp binp) \\<longrightarrow>\n                            qInit MOD\n                             (qOp delta inp binp #[[y1 \\<and> y]]_ys) =\n                            igSubst MOD ys (igVar MOD ys y1) y\n                             (qInit MOD (qOp delta inp binp))\n 2. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y);\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFreshAbs ys y1 (qAbs xs x X) \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X $[[y1 \\<and> y]]_ys) =\n                            igSubstAbs MOD ys (igVar MOD ys y1) y\n                             (qInitAbs MOD (qAbs xs x X))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>|{i. inp i \\<noteq> None}| <o |UNIV|;\n        |{i. binp i \\<noteq> None}| <o |UNIV|;\n        liftAll\n         (\\<lambda>X.\n             qGood X \\<and>\n             (\\<forall>ys y1 y.\n                 qAFresh ys y1 X \\<longrightarrow>\n                 qInit MOD (X #[[y1 \\<and> y]]_ys) =\n                 igSubst MOD ys (igVar MOD ys y1) y (qInit MOD X)))\n         inp;\n        liftAll\n         (\\<lambda>A.\n             qGoodAbs A \\<and>\n             (\\<forall>ys y1 y.\n                 qAFreshAbs ys y1 A \\<longrightarrow>\n                 qInitAbs MOD (A $[[y1 \\<and> y]]_ys) =\n                 igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD A)))\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFresh ys y1\n                             (qOp delta inp binp) \\<longrightarrow>\n                            qInit MOD\n                             (qOp delta inp binp #[[y1 \\<and> y]]_ys) =\n                            igSubst MOD ys (igVar MOD ys y1) y\n                             (qInit MOD (qOp delta inp binp))\n 2. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y);\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFreshAbs ys y1 (qAbs xs x X) \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X $[[y1 \\<and> y]]_ys) =\n                            igSubstAbs MOD ys (igVar MOD ys y1) y\n                             (qInitAbs MOD (qAbs xs x X))", "let ?h = \"qInit MOD\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>|{i. inp i \\<noteq> None}| <o |UNIV|;\n        |{i. binp i \\<noteq> None}| <o |UNIV|;\n        liftAll\n         (\\<lambda>X.\n             qGood X \\<and>\n             (\\<forall>ys y1 y.\n                 qAFresh ys y1 X \\<longrightarrow>\n                 qInit MOD (X #[[y1 \\<and> y]]_ys) =\n                 igSubst MOD ys (igVar MOD ys y1) y (qInit MOD X)))\n         inp;\n        liftAll\n         (\\<lambda>A.\n             qGoodAbs A \\<and>\n             (\\<forall>ys y1 y.\n                 qAFreshAbs ys y1 A \\<longrightarrow>\n                 qInitAbs MOD (A $[[y1 \\<and> y]]_ys) =\n                 igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD A)))\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFresh ys y1\n                             (qOp delta inp binp) \\<longrightarrow>\n                            qInit MOD\n                             (qOp delta inp binp #[[y1 \\<and> y]]_ys) =\n                            igSubst MOD ys (igVar MOD ys y1) y\n                             (qInit MOD (qOp delta inp binp))\n 2. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y);\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFreshAbs ys y1 (qAbs xs x X) \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X $[[y1 \\<and> y]]_ys) =\n                            igSubstAbs MOD ys (igVar MOD ys y1) y\n                             (qInitAbs MOD (qAbs xs x X))", "let ?hA = \"qInitAbs MOD\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>|{i. inp i \\<noteq> None}| <o |UNIV|;\n        |{i. binp i \\<noteq> None}| <o |UNIV|;\n        liftAll\n         (\\<lambda>X.\n             qGood X \\<and>\n             (\\<forall>ys y1 y.\n                 qAFresh ys y1 X \\<longrightarrow>\n                 qInit MOD (X #[[y1 \\<and> y]]_ys) =\n                 igSubst MOD ys (igVar MOD ys y1) y (qInit MOD X)))\n         inp;\n        liftAll\n         (\\<lambda>A.\n             qGoodAbs A \\<and>\n             (\\<forall>ys y1 y.\n                 qAFreshAbs ys y1 A \\<longrightarrow>\n                 qInitAbs MOD (A $[[y1 \\<and> y]]_ys) =\n                 igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD A)))\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFresh ys y1\n                             (qOp delta inp binp) \\<longrightarrow>\n                            qInit MOD\n                             (qOp delta inp binp #[[y1 \\<and> y]]_ys) =\n                            igSubst MOD ys (igVar MOD ys y1) y\n                             (qInit MOD (qOp delta inp binp))\n 2. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y);\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFreshAbs ys y1 (qAbs xs x X) \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X $[[y1 \\<and> y]]_ys) =\n                            igSubstAbs MOD ys (igVar MOD ys y1) y\n                             (qInitAbs MOD (qAbs xs x X))", "case (Op delta qinp qbinp)"], ["proof (state)\nthis:\n  |{i. qinp i \\<noteq> None}| <o |UNIV|\n  |{i. qbinp i \\<noteq> None}| <o |UNIV|\n  liftAll\n   (\\<lambda>X.\n       qGood X \\<and>\n       (\\<forall>ys y1 y.\n           qAFresh ys y1 X \\<longrightarrow>\n           qInit MOD (X #[[y1 \\<and> y]]_ys) =\n           igSubst MOD ys (igVar MOD ys y1) y (qInit MOD X)))\n   qinp\n  liftAll\n   (\\<lambda>A.\n       qGoodAbs A \\<and>\n       (\\<forall>ys y1 y.\n           qAFreshAbs ys y1 A \\<longrightarrow>\n           qInitAbs MOD (A $[[y1 \\<and> y]]_ys) =\n           igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD A)))\n   qbinp\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>|{i. inp i \\<noteq> None}| <o |UNIV|;\n        |{i. binp i \\<noteq> None}| <o |UNIV|;\n        liftAll\n         (\\<lambda>X.\n             qGood X \\<and>\n             (\\<forall>ys y1 y.\n                 qAFresh ys y1 X \\<longrightarrow>\n                 qInit MOD (X #[[y1 \\<and> y]]_ys) =\n                 igSubst MOD ys (igVar MOD ys y1) y (qInit MOD X)))\n         inp;\n        liftAll\n         (\\<lambda>A.\n             qGoodAbs A \\<and>\n             (\\<forall>ys y1 y.\n                 qAFreshAbs ys y1 A \\<longrightarrow>\n                 qInitAbs MOD (A $[[y1 \\<and> y]]_ys) =\n                 igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD A)))\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFresh ys y1\n                             (qOp delta inp binp) \\<longrightarrow>\n                            qInit MOD\n                             (qOp delta inp binp #[[y1 \\<and> y]]_ys) =\n                            igSubst MOD ys (igVar MOD ys y1) y\n                             (qInit MOD (qOp delta inp binp))\n 2. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y);\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFreshAbs ys y1 (qAbs xs x X) \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X $[[y1 \\<and> y]]_ys) =\n                            igSubstAbs MOD ys (igVar MOD ys y1) y\n                             (qInitAbs MOD (qAbs xs x X))", "then"], ["proof (chain)\npicking this:\n  |{i. qinp i \\<noteq> None}| <o |UNIV|\n  |{i. qbinp i \\<noteq> None}| <o |UNIV|\n  liftAll\n   (\\<lambda>X.\n       qGood X \\<and>\n       (\\<forall>ys y1 y.\n           qAFresh ys y1 X \\<longrightarrow>\n           qInit MOD (X #[[y1 \\<and> y]]_ys) =\n           igSubst MOD ys (igVar MOD ys y1) y (qInit MOD X)))\n   qinp\n  liftAll\n   (\\<lambda>A.\n       qGoodAbs A \\<and>\n       (\\<forall>ys y1 y.\n           qAFreshAbs ys y1 A \\<longrightarrow>\n           qInitAbs MOD (A $[[y1 \\<and> y]]_ys) =\n           igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD A)))\n   qbinp", "show ?case"], ["proof (prove)\nusing this:\n  |{i. qinp i \\<noteq> None}| <o |UNIV|\n  |{i. qbinp i \\<noteq> None}| <o |UNIV|\n  liftAll\n   (\\<lambda>X.\n       qGood X \\<and>\n       (\\<forall>ys y1 y.\n           qAFresh ys y1 X \\<longrightarrow>\n           qInit MOD (X #[[y1 \\<and> y]]_ys) =\n           igSubst MOD ys (igVar MOD ys y1) y (qInit MOD X)))\n   qinp\n  liftAll\n   (\\<lambda>A.\n       qGoodAbs A \\<and>\n       (\\<forall>ys y1 y.\n           qAFreshAbs ys y1 A \\<longrightarrow>\n           qInitAbs MOD (A $[[y1 \\<and> y]]_ys) =\n           igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD A)))\n   qbinp\n\ngoal (1 subgoal):\n 1. \\<forall>ys y1 y.\n       qAFresh ys y1 (qOp delta qinp qbinp) \\<longrightarrow>\n       qInit MOD (qOp delta qinp qbinp #[[y1 \\<and> y]]_ys) =\n       igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qOp delta qinp qbinp))", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       \\<lbrakk>|{i. qinp i \\<noteq> None}| <o |UNIV|;\n        |{i. qbinp i \\<noteq> None}| <o |UNIV|;\n        liftAll\n         (\\<lambda>X.\n             qGood X \\<and>\n             (\\<forall>ys y1 y.\n                 qAFresh ys y1 X \\<longrightarrow>\n                 qInit MOD (X #[[y1 \\<and> y]]_ys) =\n                 igSubst MOD ys (igVar MOD ys y1) y (qInit MOD X)))\n         qinp;\n        liftAll\n         (\\<lambda>A.\n             qGoodAbs A \\<and>\n             (\\<forall>ys y1 y.\n                 qAFreshAbs ys y1 A \\<longrightarrow>\n                 qInitAbs MOD (A $[[y1 \\<and> y]]_ys) =\n                 igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD A)))\n         qbinp;\n        qAFresh ys y1 (qOp delta qinp qbinp)\\<rbrakk>\n       \\<Longrightarrow> qInit MOD\n                          (qOp delta qinp qbinp #[[y1 \\<and> y]]_ys) =\n                         igSubst MOD ys (igVar MOD ys y1) y\n                          (qInit MOD (qOp delta qinp qbinp))", "fix ys y1 y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       \\<lbrakk>|{i. qinp i \\<noteq> None}| <o |UNIV|;\n        |{i. qbinp i \\<noteq> None}| <o |UNIV|;\n        liftAll\n         (\\<lambda>X.\n             qGood X \\<and>\n             (\\<forall>ys y1 y.\n                 qAFresh ys y1 X \\<longrightarrow>\n                 qInit MOD (X #[[y1 \\<and> y]]_ys) =\n                 igSubst MOD ys (igVar MOD ys y1) y (qInit MOD X)))\n         qinp;\n        liftAll\n         (\\<lambda>A.\n             qGoodAbs A \\<and>\n             (\\<forall>ys y1 y.\n                 qAFreshAbs ys y1 A \\<longrightarrow>\n                 qInitAbs MOD (A $[[y1 \\<and> y]]_ys) =\n                 igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD A)))\n         qbinp;\n        qAFresh ys y1 (qOp delta qinp qbinp)\\<rbrakk>\n       \\<Longrightarrow> qInit MOD\n                          (qOp delta qinp qbinp #[[y1 \\<and> y]]_ys) =\n                         igSubst MOD ys (igVar MOD ys y1) y\n                          (qInit MOD (qOp delta qinp qbinp))", "assume ***: \"qAFresh ys y1 (qOp delta qinp qbinp)\""], ["proof (state)\nthis:\n  qAFresh ys y1 (qOp delta qinp qbinp)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       \\<lbrakk>|{i. qinp i \\<noteq> None}| <o |UNIV|;\n        |{i. qbinp i \\<noteq> None}| <o |UNIV|;\n        liftAll\n         (\\<lambda>X.\n             qGood X \\<and>\n             (\\<forall>ys y1 y.\n                 qAFresh ys y1 X \\<longrightarrow>\n                 qInit MOD (X #[[y1 \\<and> y]]_ys) =\n                 igSubst MOD ys (igVar MOD ys y1) y (qInit MOD X)))\n         qinp;\n        liftAll\n         (\\<lambda>A.\n             qGoodAbs A \\<and>\n             (\\<forall>ys y1 y.\n                 qAFreshAbs ys y1 A \\<longrightarrow>\n                 qInitAbs MOD (A $[[y1 \\<and> y]]_ys) =\n                 igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD A)))\n         qbinp;\n        qAFresh ys y1 (qOp delta qinp qbinp)\\<rbrakk>\n       \\<Longrightarrow> qInit MOD\n                          (qOp delta qinp qbinp #[[y1 \\<and> y]]_ys) =\n                         igSubst MOD ys (igVar MOD ys y1) y\n                          (qInit MOD (qOp delta qinp qbinp))", "have \"lift ?h (qSwapInp ys y1 y qinp) =\n        igSubstInp MOD ys (igVar MOD ys y1) y (lift ?h qinp) \\<and>\n        lift ?hA (qSwapBinp ys y1 y qbinp) =\n        igSubstBinp MOD ys (igVar MOD ys y1) y (lift ?hA qbinp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (qInit MOD) (qSwapInp ys y1 y qinp) =\n    igSubstInp MOD ys (igVar MOD ys y1) y (lift (qInit MOD) qinp) \\<and>\n    lift (qInitAbs MOD) (qSwapBinp ys y1 y qbinp) =\n    igSubstBinp MOD ys (igVar MOD ys y1) y (lift (qInitAbs MOD) qbinp)", "using Op.IH ***"], ["proof (prove)\nusing this:\n  liftAll\n   (\\<lambda>X.\n       qGood X \\<and>\n       (\\<forall>ys y1 y.\n           qAFresh ys y1 X \\<longrightarrow>\n           qInit MOD (X #[[y1 \\<and> y]]_ys) =\n           igSubst MOD ys (igVar MOD ys y1) y (qInit MOD X)))\n   qinp\n  liftAll\n   (\\<lambda>A.\n       qGoodAbs A \\<and>\n       (\\<forall>ys y1 y.\n           qAFreshAbs ys y1 A \\<longrightarrow>\n           qInitAbs MOD (A $[[y1 \\<and> y]]_ys) =\n           igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD A)))\n   qbinp\n  qAFresh ys y1 (qOp delta qinp qbinp)\n\ngoal (1 subgoal):\n 1. lift (qInit MOD) (qSwapInp ys y1 y qinp) =\n    igSubstInp MOD ys (igVar MOD ys y1) y (lift (qInit MOD) qinp) \\<and>\n    lift (qInitAbs MOD) (qSwapBinp ys y1 y qbinp) =\n    igSubstBinp MOD ys (igVar MOD ys y1) y (lift (qInitAbs MOD) qbinp)", "by (auto simp: qSwapInp_def igSubstInp_def qSwapBinp_def igSubstBinp_def \n      lift_def liftAll_def split: option.splits)"], ["proof (state)\nthis:\n  lift (qInit MOD) (qSwapInp ys y1 y qinp) =\n  igSubstInp MOD ys (igVar MOD ys y1) y (lift (qInit MOD) qinp) \\<and>\n  lift (qInitAbs MOD) (qSwapBinp ys y1 y qbinp) =\n  igSubstBinp MOD ys (igVar MOD ys y1) y (lift (qInitAbs MOD) qbinp)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       \\<lbrakk>|{i. qinp i \\<noteq> None}| <o |UNIV|;\n        |{i. qbinp i \\<noteq> None}| <o |UNIV|;\n        liftAll\n         (\\<lambda>X.\n             qGood X \\<and>\n             (\\<forall>ys y1 y.\n                 qAFresh ys y1 X \\<longrightarrow>\n                 qInit MOD (X #[[y1 \\<and> y]]_ys) =\n                 igSubst MOD ys (igVar MOD ys y1) y (qInit MOD X)))\n         qinp;\n        liftAll\n         (\\<lambda>A.\n             qGoodAbs A \\<and>\n             (\\<forall>ys y1 y.\n                 qAFreshAbs ys y1 A \\<longrightarrow>\n                 qInitAbs MOD (A $[[y1 \\<and> y]]_ys) =\n                 igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD A)))\n         qbinp;\n        qAFresh ys y1 (qOp delta qinp qbinp)\\<rbrakk>\n       \\<Longrightarrow> qInit MOD\n                          (qOp delta qinp qbinp #[[y1 \\<and> y]]_ys) =\n                         igSubst MOD ys (igVar MOD ys y1) y\n                          (qInit MOD (qOp delta qinp qbinp))", "thus \"qInit MOD (qOp delta qinp qbinp #[[y1 \\<and> y]]_ys) =\n       igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qOp delta qinp qbinp))\""], ["proof (prove)\nusing this:\n  lift (qInit MOD) (qSwapInp ys y1 y qinp) =\n  igSubstInp MOD ys (igVar MOD ys y1) y (lift (qInit MOD) qinp) \\<and>\n  lift (qInitAbs MOD) (qSwapBinp ys y1 y qbinp) =\n  igSubstBinp MOD ys (igVar MOD ys y1) y (lift (qInitAbs MOD) qbinp)\n\ngoal (1 subgoal):\n 1. qInit MOD (qOp delta qinp qbinp #[[y1 \\<and> y]]_ys) =\n    igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qOp delta qinp qbinp))", "using assms"], ["proof (prove)\nusing this:\n  lift (qInit MOD) (qSwapInp ys y1 y qinp) =\n  igSubstInp MOD ys (igVar MOD ys y1) y (lift (qInit MOD) qinp) \\<and>\n  lift (qInitAbs MOD) (qSwapBinp ys y1 y qbinp) =\n  igSubstBinp MOD ys (igVar MOD ys y1) y (lift (qInitAbs MOD) qbinp)\n  igSubstClsSTR MOD\n  igFreshClsSTR MOD\n  igAbsRenSTR MOD\n\ngoal (1 subgoal):\n 1. qInit MOD (qOp delta qinp qbinp #[[y1 \\<and> y]]_ys) =\n    igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qOp delta qinp qbinp))", "unfolding iwlsFSwSTR_def igSubstClsSTR_defs igSubstIGOpSTR_def"], ["proof (prove)\nusing this:\n  lift (qInit MOD) (qSwapInp ys y1 y qinp) =\n  igSubstInp MOD ys (igVar MOD ys y1) y (lift (qInit MOD) qinp) \\<and>\n  lift (qInitAbs MOD) (qSwapBinp ys y1 y qbinp) =\n  igSubstBinp MOD ys (igVar MOD ys y1) y (lift (qInitAbs MOD) qbinp)\n  ((\\<forall>ys y y1 xs x.\n       ys \\<noteq> xs \\<or> x \\<noteq> y \\<longrightarrow>\n       igSubst MOD ys (igVar MOD ys y1) y (igVar MOD xs x) =\n       igVar MOD xs x) \\<and>\n   (\\<forall>ys y Y xs x.\n       igWls MOD (asSort ys) Y \\<longrightarrow>\n       ys \\<noteq> xs \\<or> y \\<noteq> x \\<longrightarrow>\n       igSubst MOD ys Y y (igVar MOD xs x) = igVar MOD xs x)) \\<and>\n  ((\\<forall>ys y y1.\n       igSubst MOD ys (igVar MOD ys y1) y (igVar MOD ys y) =\n       igVar MOD ys y1) \\<and>\n   (\\<forall>ys y Y.\n       igWls MOD (asSort ys) Y \\<longrightarrow>\n       igSubst MOD ys Y y (igVar MOD ys y) = Y)) \\<and>\n  (\\<forall>ys y Y xs x X.\n      (xs \\<noteq> ys \\<or> x \\<noteq> y) \\<and>\n      igFresh MOD xs x Y \\<longrightarrow>\n      igSubstAbs MOD ys Y y (igAbs MOD xs x X) =\n      igAbs MOD xs x (igSubst MOD ys Y y X)) \\<and>\n  (\\<forall>ys y y1 delta inp binp.\n      igSubst MOD ys (igVar MOD ys y1) y (igOp MOD delta inp binp) =\n      igOp MOD delta (igSubstInp MOD ys (igVar MOD ys y1) y inp)\n       (igSubstBinp MOD ys (igVar MOD ys y1) y binp)) \\<and>\n  (\\<forall>ys y Y delta inp binp.\n      igWls MOD (asSort ys) Y \\<longrightarrow>\n      igSubst MOD ys Y y (igOp MOD delta inp binp) =\n      igOp MOD delta (igSubstInp MOD ys Y y inp)\n       (igSubstBinp MOD ys Y y binp))\n  igFreshClsSTR MOD\n  igAbsRenSTR MOD\n\ngoal (1 subgoal):\n 1. qInit MOD (qOp delta qinp qbinp #[[y1 \\<and> y]]_ys) =\n    igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qOp delta qinp qbinp))", "by simp"], ["proof (state)\nthis:\n  qInit MOD (qOp delta qinp qbinp #[[y1 \\<and> y]]_ys) =\n  igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qOp delta qinp qbinp))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>ys y1 y.\n     qAFresh ys y1 (qOp delta qinp qbinp) \\<longrightarrow>\n     qInit MOD (qOp delta qinp qbinp #[[y1 \\<and> y]]_ys) =\n     igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qOp delta qinp qbinp))\n\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y);\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFreshAbs ys y1 (qAbs xs x X) \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X $[[y1 \\<and> y]]_ys) =\n                            igSubstAbs MOD ys (igVar MOD ys y1) y\n                             (qInitAbs MOD (qAbs xs x X))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y);\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFreshAbs ys y1 (qAbs xs x X) \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X $[[y1 \\<and> y]]_ys) =\n                            igSubstAbs MOD ys (igVar MOD ys y1) y\n                             (qInitAbs MOD (qAbs xs x X))", "let ?h = \"qInit MOD\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y);\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFreshAbs ys y1 (qAbs xs x X) \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X $[[y1 \\<and> y]]_ys) =\n                            igSubstAbs MOD ys (igVar MOD ys y1) y\n                             (qInitAbs MOD (qAbs xs x X))", "let ?hA = \"qInitAbs MOD\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y);\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFreshAbs ys y1 (qAbs xs x X) \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X $[[y1 \\<and> y]]_ys) =\n                            igSubstAbs MOD ys (igVar MOD ys y1) y\n                             (qInitAbs MOD (qAbs xs x X))", "case (Abs xs x qX)"], ["proof (state)\nthis:\n  qGood qX\n  qGood ?Y114 \\<and> qSkel ?Y114 = qSkel qX \\<Longrightarrow>\n  \\<forall>ys y1 y.\n     qAFresh ys y1 ?Y114 \\<longrightarrow>\n     qInit MOD (?Y114 #[[y1 \\<and> y]]_ys) =\n     igSubst MOD ys (igVar MOD ys y1) y (qInit MOD ?Y114)\n  (qX, ?Y114) \\<in> qSwapped \\<Longrightarrow>\n  \\<forall>ys y1 y.\n     qAFresh ys y1 ?Y114 \\<longrightarrow>\n     qInit MOD (?Y114 #[[y1 \\<and> y]]_ys) =\n     igSubst MOD ys (igVar MOD ys y1) y (qInit MOD ?Y114)\n\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y);\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>ys y1 y.\n              qAFresh ys y1 Y \\<longrightarrow>\n              qInit MOD (Y #[[y1 \\<and> y]]_ys) =\n              igSubst MOD ys (igVar MOD ys y1) y (qInit MOD Y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys y1 y.\n                            qAFreshAbs ys y1 (qAbs xs x X) \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X $[[y1 \\<and> y]]_ys) =\n                            igSubstAbs MOD ys (igVar MOD ys y1) y\n                             (qInitAbs MOD (qAbs xs x X))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "fix ys y1 y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "let ?xy1y = \"x @xs[y1 \\<and> y]_ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "let ?y1 = \"igVar MOD ys y1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "assume \"qAFreshAbs ys y1 (qAbs xs x qX)\""], ["proof (state)\nthis:\n  qAFreshAbs ys y1 (qAbs xs x qX)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "hence y1_fresh: \"ys = xs \\<longrightarrow> y1 \\<noteq> x\"   \"qAFresh ys y1 qX\""], ["proof (prove)\nusing this:\n  qAFreshAbs ys y1 (qAbs xs x qX)\n\ngoal (1 subgoal):\n 1. ys = xs \\<longrightarrow> y1 \\<noteq> x &&& qAFresh ys y1 qX", "by auto"], ["proof (state)\nthis:\n  ys = xs \\<longrightarrow> y1 \\<noteq> x\n  qAFresh ys y1 qX\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "hence 1: \"qFresh ys y1 qX\""], ["proof (prove)\nusing this:\n  ys = xs \\<longrightarrow> y1 \\<noteq> x\n  qAFresh ys y1 qX\n\ngoal (1 subgoal):\n 1. qFresh ys y1 qX", "using qAFresh_imp_qFresh"], ["proof (prove)\nusing this:\n  ys = xs \\<longrightarrow> y1 \\<noteq> x\n  qAFresh ys y1 qX\n  qAFresh ?xs ?x ?X \\<Longrightarrow> qFresh ?xs ?x ?X\n\ngoal (1 subgoal):\n 1. qFresh ys y1 qX", "by auto"], ["proof (state)\nthis:\n  qFresh ys y1 qX\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "hence y1_fresh_qX: \"igFresh MOD ys y1 (?h qX)\""], ["proof (prove)\nusing this:\n  qFresh ys y1 qX\n\ngoal (1 subgoal):\n 1. igFresh MOD ys y1 (qInit MOD qX)", "using assms"], ["proof (prove)\nusing this:\n  qFresh ys y1 qX\n  igSubstClsSTR MOD\n  igFreshClsSTR MOD\n  igAbsRenSTR MOD\n\ngoal (1 subgoal):\n 1. igFresh MOD ys y1 (qInit MOD qX)", "unfolding igSubstClsSTR_def"], ["proof (prove)\nusing this:\n  qFresh ys y1 qX\n  igSubstIGVar1STR MOD \\<and>\n  igSubstIGVar2STR MOD \\<and> igSubstIGAbsSTR MOD \\<and> igSubstIGOpSTR MOD\n  igFreshClsSTR MOD\n  igAbsRenSTR MOD\n\ngoal (1 subgoal):\n 1. igFresh MOD ys y1 (qInit MOD qX)", "by(simp add: qFreshAll_igFreshAll_qInitAll)"], ["proof (state)\nthis:\n  igFresh MOD ys y1 (qInit MOD qX)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "(* *)"], ["proof (state)\nthis:\n  igFresh MOD ys y1 (qInit MOD qX)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "obtain x1 where x1_fresh: \"x1 \\<notin> {y,y1}\"  \"qFresh xs x1 qX\"  \"qAFresh xs x1 qX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        \\<lbrakk>x1 \\<notin> {y, y1}; qFresh xs x1 qX;\n         qAFresh xs x1 qX\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using obtain_qFresh[of \"{y,y1}\" \"{qX}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {y, y1} \\<or> |{y, y1}| <o |UNIV|;\n   finite {qX} \\<or> |{qX}| <o |UNIV|; Ball {qX} qGood\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x.\n                       x \\<notin> {y, y1} \\<and>\n                       (\\<forall>X\\<in>{qX}.\n                           qAFresh ?xs x X \\<and> qFresh ?xs x X)\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        \\<lbrakk>x1 \\<notin> {y, y1}; qFresh xs x1 qX;\n         qAFresh xs x1 qX\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Abs"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {y, y1} \\<or> |{y, y1}| <o |UNIV|;\n   finite {qX} \\<or> |{qX}| <o |UNIV|; Ball {qX} qGood\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x.\n                       x \\<notin> {y, y1} \\<and>\n                       (\\<forall>X\\<in>{qX}.\n                           qAFresh ?xs x X \\<and> qFresh ?xs x X)\n  qGood qX\n  qGood ?Y114 \\<and> qSkel ?Y114 = qSkel qX \\<Longrightarrow>\n  \\<forall>ys y1 y.\n     qAFresh ys y1 ?Y114 \\<longrightarrow>\n     qInit MOD (?Y114 #[[y1 \\<and> y]]_ys) =\n     igSubst MOD ys (igVar MOD ys y1) y (qInit MOD ?Y114)\n  (qX, ?Y114) \\<in> qSwapped \\<Longrightarrow>\n  \\<forall>ys y1 y.\n     qAFresh ys y1 ?Y114 \\<longrightarrow>\n     qInit MOD (?Y114 #[[y1 \\<and> y]]_ys) =\n     igSubst MOD ys (igVar MOD ys y1) y (qInit MOD ?Y114)\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        \\<lbrakk>x1 \\<notin> {y, y1}; qFresh xs x1 qX;\n         qAFresh xs x1 qX\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x1 \\<notin> {y, y1}\n  qFresh xs x1 qX\n  qAFresh xs x1 qX\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "hence [simp]: \"igFresh MOD xs x1 (?h qX)\""], ["proof (prove)\nusing this:\n  x1 \\<notin> {y, y1}\n  qFresh xs x1 qX\n  qAFresh xs x1 qX\n\ngoal (1 subgoal):\n 1. igFresh MOD xs x1 (qInit MOD qX)", "using assms"], ["proof (prove)\nusing this:\n  x1 \\<notin> {y, y1}\n  qFresh xs x1 qX\n  qAFresh xs x1 qX\n  igSubstClsSTR MOD\n  igFreshClsSTR MOD\n  igAbsRenSTR MOD\n\ngoal (1 subgoal):\n 1. igFresh MOD xs x1 (qInit MOD qX)", "by(simp add: qFreshAll_igFreshAll_qInitAll)"], ["proof (state)\nthis:\n  igFresh MOD xs x1 (qInit MOD qX)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "let ?x1 = \"igVar MOD xs x1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "let ?x1y1y = \"x1 @xs[y1 \\<and> y]_ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "let ?qX_x1x = \"qX #[[x1 \\<and> x]]_xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "let ?qX_x1x_y1y = \"?qX_x1x #[[y1 \\<and> y]]_ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "let ?qX_y1y = \"qX #[[y1 \\<and> y]]_ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "let ?qX_y1y_x1_xy1y = \"?qX_y1y #[[x1 \\<and> ?xy1y]]_xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "let ?qX_y1y_x1y1y_xy1y = \"?qX_y1y #[[?x1y1y \\<and> ?xy1y]]_xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "have [simp]: \"qAFresh ys y1 ?qX_x1x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qAFresh ys y1 (qX #[[x1 \\<and> x]]_xs)", "using y1_fresh x1_fresh"], ["proof (prove)\nusing this:\n  ys = xs \\<longrightarrow> y1 \\<noteq> x\n  qAFresh ys y1 qX\n  x1 \\<notin> {y, y1}\n  qFresh xs x1 qX\n  qAFresh xs x1 qX\n\ngoal (1 subgoal):\n 1. qAFresh ys y1 (qX #[[x1 \\<and> x]]_xs)", "by(auto simp add: qSwap_preserves_qAFresh_distinct)"], ["proof (state)\nthis:\n  qAFresh ys y1 (qX #[[x1 \\<and> x]]_xs)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "have [simp]: \"qAFresh xs x1 ?qX_y1y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qAFresh xs x1 (qX #[[y1 \\<and> y]]_ys)", "using y1_fresh x1_fresh"], ["proof (prove)\nusing this:\n  ys = xs \\<longrightarrow> y1 \\<noteq> x\n  qAFresh ys y1 qX\n  x1 \\<notin> {y, y1}\n  qFresh xs x1 qX\n  qAFresh xs x1 qX\n\ngoal (1 subgoal):\n 1. qAFresh xs x1 (qX #[[y1 \\<and> y]]_ys)", "by(auto simp add: qSwap_preserves_qAFresh_distinct)"], ["proof (state)\nthis:\n  qAFresh xs x1 (qX #[[y1 \\<and> y]]_ys)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "hence \"qFresh xs x1 ?qX_y1y\""], ["proof (prove)\nusing this:\n  qAFresh xs x1 (qX #[[y1 \\<and> y]]_ys)\n\ngoal (1 subgoal):\n 1. qFresh xs x1 (qX #[[y1 \\<and> y]]_ys)", "by (simp add: qAFresh_imp_qFresh)"], ["proof (state)\nthis:\n  qFresh xs x1 (qX #[[y1 \\<and> y]]_ys)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "hence [simp]: \"igFresh MOD xs x1 (?h ?qX_y1y)\""], ["proof (prove)\nusing this:\n  qFresh xs x1 (qX #[[y1 \\<and> y]]_ys)\n\ngoal (1 subgoal):\n 1. igFresh MOD xs x1 (qInit MOD (qX #[[y1 \\<and> y]]_ys))", "using assms"], ["proof (prove)\nusing this:\n  qFresh xs x1 (qX #[[y1 \\<and> y]]_ys)\n  igSubstClsSTR MOD\n  igFreshClsSTR MOD\n  igAbsRenSTR MOD\n\ngoal (1 subgoal):\n 1. igFresh MOD xs x1 (qInit MOD (qX #[[y1 \\<and> y]]_ys))", "by(simp add: qFreshAll_igFreshAll_qInitAll)"], ["proof (state)\nthis:\n  igFresh MOD xs x1 (qInit MOD (qX #[[y1 \\<and> y]]_ys))\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "have [simp]: \"igFresh MOD xs x1 ?y1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFresh MOD xs x1 (igVar MOD ys y1)", "using x1_fresh assms"], ["proof (prove)\nusing this:\n  x1 \\<notin> {y, y1}\n  qFresh xs x1 qX\n  qAFresh xs x1 qX\n  igSubstClsSTR MOD\n  igFreshClsSTR MOD\n  igAbsRenSTR MOD\n\ngoal (1 subgoal):\n 1. igFresh MOD xs x1 (igVar MOD ys y1)", "unfolding igFreshClsSTR_def igFreshIGVar_def"], ["proof (prove)\nusing this:\n  x1 \\<notin> {y, y1}\n  qFresh xs x1 qX\n  qAFresh xs x1 qX\n  igSubstClsSTR MOD\n  (\\<forall>ys y xs x.\n      ys \\<noteq> xs \\<or> y \\<noteq> x \\<longrightarrow>\n      igFresh MOD ys y (igVar MOD xs x)) \\<and>\n  igFreshIGAbs1STR MOD \\<and> igFreshIGAbs2STR MOD \\<and> igFreshIGOpSTR MOD\n  igAbsRenSTR MOD\n\ngoal (1 subgoal):\n 1. igFresh MOD xs x1 (igVar MOD ys y1)", "by simp"], ["proof (state)\nthis:\n  igFresh MOD xs x1 (igVar MOD ys y1)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "have x1_def: \"x1 = ?x1y1y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 = x1 @xs[y1 \\<and> y]_ys", "using x1_fresh"], ["proof (prove)\nusing this:\n  x1 \\<notin> {y, y1}\n  qFresh xs x1 qX\n  qAFresh xs x1 qX\n\ngoal (1 subgoal):\n 1. x1 = x1 @xs[y1 \\<and> y]_ys", "by simp"], ["proof (state)\nthis:\n  x1 = x1 @xs[y1 \\<and> y]_ys\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "(*  *)"], ["proof (state)\nthis:\n  x1 = x1 @xs[y1 \\<and> y]_ys\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "have \"?hA ((qAbs xs x qX) $[[y1 \\<and> y]]_ys) = igAbs MOD xs ?xy1y (?h ?qX_y1y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n    igAbs MOD xs (x @xs[y1 \\<and> y]_ys)\n     (qInit MOD (qX #[[y1 \\<and> y]]_ys))", "by simp"], ["proof (state)\nthis:\n  qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n  igAbs MOD xs (x @xs[y1 \\<and> y]_ys) (qInit MOD (qX #[[y1 \\<and> y]]_ys))\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "also"], ["proof (state)\nthis:\n  qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n  igAbs MOD xs (x @xs[y1 \\<and> y]_ys) (qInit MOD (qX #[[y1 \\<and> y]]_ys))\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "have \"\\<dots> = igAbs MOD xs x1 (igSubst MOD xs ?x1 ?xy1y (?h ?qX_y1y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs MOD xs (x @xs[y1 \\<and> y]_ys)\n     (qInit MOD (qX #[[y1 \\<and> y]]_ys)) =\n    igAbs MOD xs x1\n     (igSubst MOD xs (igVar MOD xs x1) (x @xs[y1 \\<and> y]_ys)\n       (qInit MOD (qX #[[y1 \\<and> y]]_ys)))", "using assms"], ["proof (prove)\nusing this:\n  igSubstClsSTR MOD\n  igFreshClsSTR MOD\n  igAbsRenSTR MOD\n\ngoal (1 subgoal):\n 1. igAbs MOD xs (x @xs[y1 \\<and> y]_ys)\n     (qInit MOD (qX #[[y1 \\<and> y]]_ys)) =\n    igAbs MOD xs x1\n     (igSubst MOD xs (igVar MOD xs x1) (x @xs[y1 \\<and> y]_ys)\n       (qInit MOD (qX #[[y1 \\<and> y]]_ys)))", "unfolding igAbsRenSTR_def"], ["proof (prove)\nusing this:\n  igSubstClsSTR MOD\n  igFreshClsSTR MOD\n  \\<forall>xs y x X.\n     igFresh MOD xs y X \\<longrightarrow>\n     igAbs MOD xs y (igSubst MOD xs (igVar MOD xs y) x X) = igAbs MOD xs x X\n\ngoal (1 subgoal):\n 1. igAbs MOD xs (x @xs[y1 \\<and> y]_ys)\n     (qInit MOD (qX #[[y1 \\<and> y]]_ys)) =\n    igAbs MOD xs x1\n     (igSubst MOD xs (igVar MOD xs x1) (x @xs[y1 \\<and> y]_ys)\n       (qInit MOD (qX #[[y1 \\<and> y]]_ys)))", "by simp"], ["proof (state)\nthis:\n  igAbs MOD xs (x @xs[y1 \\<and> y]_ys)\n   (qInit MOD (qX #[[y1 \\<and> y]]_ys)) =\n  igAbs MOD xs x1\n   (igSubst MOD xs (igVar MOD xs x1) (x @xs[y1 \\<and> y]_ys)\n     (qInit MOD (qX #[[y1 \\<and> y]]_ys)))\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "also"], ["proof (state)\nthis:\n  igAbs MOD xs (x @xs[y1 \\<and> y]_ys)\n   (qInit MOD (qX #[[y1 \\<and> y]]_ys)) =\n  igAbs MOD xs x1\n   (igSubst MOD xs (igVar MOD xs x1) (x @xs[y1 \\<and> y]_ys)\n     (qInit MOD (qX #[[y1 \\<and> y]]_ys)))\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "have \"igSubst MOD xs ?x1 ?xy1y (?h ?qX_y1y) = ?h (?qX_y1y_x1_xy1y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubst MOD xs (igVar MOD xs x1) (x @xs[y1 \\<and> y]_ys)\n     (qInit MOD (qX #[[y1 \\<and> y]]_ys)) =\n    qInit MOD\n     (qX #[[y1 \\<and> y]]_ys #[[x1 \\<and> x @xs[y1 \\<and> y]_ys]]_xs)", "using y1_fresh Abs.IH[of \"?qX_y1y\"]"], ["proof (prove)\nusing this:\n  ys = xs \\<longrightarrow> y1 \\<noteq> x\n  qAFresh ys y1 qX\n  qGood (qX #[[y1 \\<and> y]]_ys) \\<and>\n  qSkel (qX #[[y1 \\<and> y]]_ys) = qSkel qX \\<Longrightarrow>\n  \\<forall>ysa y1a ya.\n     qAFresh ysa y1a (qX #[[y1 \\<and> y]]_ys) \\<longrightarrow>\n     qInit MOD (qX #[[y1 \\<and> y]]_ys #[[y1a \\<and> ya]]_ysa) =\n     igSubst MOD ysa (igVar MOD ysa y1a) ya\n      (qInit MOD (qX #[[y1 \\<and> y]]_ys))\n  (qX, qX #[[y1 \\<and> y]]_ys) \\<in> qSwapped \\<Longrightarrow>\n  \\<forall>ysa y1a ya.\n     qAFresh ysa y1a (qX #[[y1 \\<and> y]]_ys) \\<longrightarrow>\n     qInit MOD (qX #[[y1 \\<and> y]]_ys #[[y1a \\<and> ya]]_ysa) =\n     igSubst MOD ysa (igVar MOD ysa y1a) ya\n      (qInit MOD (qX #[[y1 \\<and> y]]_ys))\n\ngoal (1 subgoal):\n 1. igSubst MOD xs (igVar MOD xs x1) (x @xs[y1 \\<and> y]_ys)\n     (qInit MOD (qX #[[y1 \\<and> y]]_ys)) =\n    qInit MOD\n     (qX #[[y1 \\<and> y]]_ys #[[x1 \\<and> x @xs[y1 \\<and> y]_ys]]_xs)", "by(simp add: qSwap_qSwapped)"], ["proof (state)\nthis:\n  igSubst MOD xs (igVar MOD xs x1) (x @xs[y1 \\<and> y]_ys)\n   (qInit MOD (qX #[[y1 \\<and> y]]_ys)) =\n  qInit MOD (qX #[[y1 \\<and> y]]_ys #[[x1 \\<and> x @xs[y1 \\<and> y]_ys]]_xs)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "also"], ["proof (state)\nthis:\n  igSubst MOD xs (igVar MOD xs x1) (x @xs[y1 \\<and> y]_ys)\n   (qInit MOD (qX #[[y1 \\<and> y]]_ys)) =\n  qInit MOD (qX #[[y1 \\<and> y]]_ys #[[x1 \\<and> x @xs[y1 \\<and> y]_ys]]_xs)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "have \"?qX_y1y_x1_xy1y = ?qX_y1y_x1y1y_xy1y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qX #[[y1 \\<and> y]]_ys #[[x1 \\<and> x @xs[y1 \\<and> y]_ys]]_xs =\n    qX #[[y1 \\<and> y]]_ys #[[x1 @xs[y1 \\<and> y]_ys \\<and> x @xs[y1 \\<and> y]_ys]]_xs", "using x1_def"], ["proof (prove)\nusing this:\n  x1 = x1 @xs[y1 \\<and> y]_ys\n\ngoal (1 subgoal):\n 1. qX #[[y1 \\<and> y]]_ys #[[x1 \\<and> x @xs[y1 \\<and> y]_ys]]_xs =\n    qX #[[y1 \\<and> y]]_ys #[[x1 @xs[y1 \\<and> y]_ys \\<and> x @xs[y1 \\<and> y]_ys]]_xs", "by simp"], ["proof (state)\nthis:\n  qX #[[y1 \\<and> y]]_ys #[[x1 \\<and> x @xs[y1 \\<and> y]_ys]]_xs =\n  qX #[[y1 \\<and> y]]_ys #[[x1 @xs[y1 \\<and> y]_ys \\<and> x @xs[y1 \\<and> y]_ys]]_xs\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "also"], ["proof (state)\nthis:\n  qX #[[y1 \\<and> y]]_ys #[[x1 \\<and> x @xs[y1 \\<and> y]_ys]]_xs =\n  qX #[[y1 \\<and> y]]_ys #[[x1 @xs[y1 \\<and> y]_ys \\<and> x @xs[y1 \\<and> y]_ys]]_xs\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "have \"\\<dots> = ?qX_x1x_y1y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qX #[[y1 \\<and> y]]_ys #[[x1 @xs[y1 \\<and> y]_ys \\<and> x @xs[y1 \\<and> y]_ys]]_xs =\n    qX #[[x1 \\<and> x]]_xs #[[y1 \\<and> y]]_ys", "apply(rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. qX #[[x1 \\<and> x]]_xs #[[y1 \\<and> y]]_ys =\n    qX #[[y1 \\<and> y]]_ys #[[x1 @xs[y1 \\<and> y]_ys \\<and> x @xs[y1 \\<and> y]_ys]]_xs", "by(rule qSwap_compose)"], ["proof (state)\nthis:\n  qX #[[y1 \\<and> y]]_ys #[[x1 @xs[y1 \\<and> y]_ys \\<and> x @xs[y1 \\<and> y]_ys]]_xs =\n  qX #[[x1 \\<and> x]]_xs #[[y1 \\<and> y]]_ys\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "also"], ["proof (state)\nthis:\n  qX #[[y1 \\<and> y]]_ys #[[x1 @xs[y1 \\<and> y]_ys \\<and> x @xs[y1 \\<and> y]_ys]]_xs =\n  qX #[[x1 \\<and> x]]_xs #[[y1 \\<and> y]]_ys\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "have \"?h ?qX_x1x_y1y = igSubst MOD ys ?y1 y (?h ?qX_x1x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qInit MOD (qX #[[x1 \\<and> x]]_xs #[[y1 \\<and> y]]_ys) =\n    igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qX #[[x1 \\<and> x]]_xs))", "using Abs.IH[of \"?qX_x1x\"]"], ["proof (prove)\nusing this:\n  qGood (qX #[[x1 \\<and> x]]_xs) \\<and>\n  qSkel (qX #[[x1 \\<and> x]]_xs) = qSkel qX \\<Longrightarrow>\n  \\<forall>ys y1 y.\n     qAFresh ys y1 (qX #[[x1 \\<and> x]]_xs) \\<longrightarrow>\n     qInit MOD (qX #[[x1 \\<and> x]]_xs #[[y1 \\<and> y]]_ys) =\n     igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qX #[[x1 \\<and> x]]_xs))\n  (qX, qX #[[x1 \\<and> x]]_xs) \\<in> qSwapped \\<Longrightarrow>\n  \\<forall>ys y1 y.\n     qAFresh ys y1 (qX #[[x1 \\<and> x]]_xs) \\<longrightarrow>\n     qInit MOD (qX #[[x1 \\<and> x]]_xs #[[y1 \\<and> y]]_ys) =\n     igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qX #[[x1 \\<and> x]]_xs))\n\ngoal (1 subgoal):\n 1. qInit MOD (qX #[[x1 \\<and> x]]_xs #[[y1 \\<and> y]]_ys) =\n    igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qX #[[x1 \\<and> x]]_xs))", "by(simp add: qSwap_qSwapped)"], ["proof (state)\nthis:\n  qInit MOD (qX #[[x1 \\<and> x]]_xs #[[y1 \\<and> y]]_ys) =\n  igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qX #[[x1 \\<and> x]]_xs))\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "also"], ["proof (state)\nthis:\n  qInit MOD (qX #[[x1 \\<and> x]]_xs #[[y1 \\<and> y]]_ys) =\n  igSubst MOD ys (igVar MOD ys y1) y (qInit MOD (qX #[[x1 \\<and> x]]_xs))\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "have\n    \"igAbs MOD xs x1 (igSubst MOD ys ?y1 y (?h ?qX_x1x)) =\n     igSubstAbs MOD ys ?y1 y (igAbs MOD xs x1 (?h (?qX_x1x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs MOD xs x1\n     (igSubst MOD ys (igVar MOD ys y1) y\n       (qInit MOD (qX #[[x1 \\<and> x]]_xs))) =\n    igSubstAbs MOD ys (igVar MOD ys y1) y\n     (igAbs MOD xs x1 (qInit MOD (qX #[[x1 \\<and> x]]_xs)))", "using assms"], ["proof (prove)\nusing this:\n  igSubstClsSTR MOD\n  igFreshClsSTR MOD\n  igAbsRenSTR MOD\n\ngoal (1 subgoal):\n 1. igAbs MOD xs x1\n     (igSubst MOD ys (igVar MOD ys y1) y\n       (qInit MOD (qX #[[x1 \\<and> x]]_xs))) =\n    igSubstAbs MOD ys (igVar MOD ys y1) y\n     (igAbs MOD xs x1 (qInit MOD (qX #[[x1 \\<and> x]]_xs)))", "unfolding igSubstClsSTR_def igSubstIGAbsSTR_def"], ["proof (prove)\nusing this:\n  igSubstIGVar1STR MOD \\<and>\n  igSubstIGVar2STR MOD \\<and>\n  (\\<forall>ys y Y xs x X.\n      (xs \\<noteq> ys \\<or> x \\<noteq> y) \\<and>\n      igFresh MOD xs x Y \\<longrightarrow>\n      igSubstAbs MOD ys Y y (igAbs MOD xs x X) =\n      igAbs MOD xs x (igSubst MOD ys Y y X)) \\<and>\n  igSubstIGOpSTR MOD\n  igFreshClsSTR MOD\n  igAbsRenSTR MOD\n\ngoal (1 subgoal):\n 1. igAbs MOD xs x1\n     (igSubst MOD ys (igVar MOD ys y1) y\n       (qInit MOD (qX #[[x1 \\<and> x]]_xs))) =\n    igSubstAbs MOD ys (igVar MOD ys y1) y\n     (igAbs MOD xs x1 (qInit MOD (qX #[[x1 \\<and> x]]_xs)))", "using x1_fresh y1_fresh"], ["proof (prove)\nusing this:\n  igSubstIGVar1STR MOD \\<and>\n  igSubstIGVar2STR MOD \\<and>\n  (\\<forall>ys y Y xs x X.\n      (xs \\<noteq> ys \\<or> x \\<noteq> y) \\<and>\n      igFresh MOD xs x Y \\<longrightarrow>\n      igSubstAbs MOD ys Y y (igAbs MOD xs x X) =\n      igAbs MOD xs x (igSubst MOD ys Y y X)) \\<and>\n  igSubstIGOpSTR MOD\n  igFreshClsSTR MOD\n  igAbsRenSTR MOD\n  x1 \\<notin> {y, y1}\n  qFresh xs x1 qX\n  qAFresh xs x1 qX\n  ys = xs \\<longrightarrow> y1 \\<noteq> x\n  qAFresh ys y1 qX\n\ngoal (1 subgoal):\n 1. igAbs MOD xs x1\n     (igSubst MOD ys (igVar MOD ys y1) y\n       (qInit MOD (qX #[[x1 \\<and> x]]_xs))) =\n    igSubstAbs MOD ys (igVar MOD ys y1) y\n     (igAbs MOD xs x1 (qInit MOD (qX #[[x1 \\<and> x]]_xs)))", "by simp"], ["proof (state)\nthis:\n  igAbs MOD xs x1\n   (igSubst MOD ys (igVar MOD ys y1) y\n     (qInit MOD (qX #[[x1 \\<and> x]]_xs))) =\n  igSubstAbs MOD ys (igVar MOD ys y1) y\n   (igAbs MOD xs x1 (qInit MOD (qX #[[x1 \\<and> x]]_xs)))\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "also"], ["proof (state)\nthis:\n  igAbs MOD xs x1\n   (igSubst MOD ys (igVar MOD ys y1) y\n     (qInit MOD (qX #[[x1 \\<and> x]]_xs))) =\n  igSubstAbs MOD ys (igVar MOD ys y1) y\n   (igAbs MOD xs x1 (qInit MOD (qX #[[x1 \\<and> x]]_xs)))\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "have \"?h (?qX_x1x) = igSubst MOD xs ?x1 x (?h qX)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qInit MOD (qX #[[x1 \\<and> x]]_xs) =\n    igSubst MOD xs (igVar MOD xs x1) x (qInit MOD qX)", "using Abs.IH[of \"qX\"] x1_fresh"], ["proof (prove)\nusing this:\n  qGood qX \\<and> qSkel qX = qSkel qX \\<Longrightarrow>\n  \\<forall>ys y1 y.\n     qAFresh ys y1 qX \\<longrightarrow>\n     qInit MOD (qX #[[y1 \\<and> y]]_ys) =\n     igSubst MOD ys (igVar MOD ys y1) y (qInit MOD qX)\n  (qX, qX) \\<in> qSwapped \\<Longrightarrow>\n  \\<forall>ys y1 y.\n     qAFresh ys y1 qX \\<longrightarrow>\n     qInit MOD (qX #[[y1 \\<and> y]]_ys) =\n     igSubst MOD ys (igVar MOD ys y1) y (qInit MOD qX)\n  x1 \\<notin> {y, y1}\n  qFresh xs x1 qX\n  qAFresh xs x1 qX\n\ngoal (1 subgoal):\n 1. qInit MOD (qX #[[x1 \\<and> x]]_xs) =\n    igSubst MOD xs (igVar MOD xs x1) x (qInit MOD qX)", "by(simp add: qSwapped.Refl)"], ["proof (state)\nthis:\n  qInit MOD (qX #[[x1 \\<and> x]]_xs) =\n  igSubst MOD xs (igVar MOD xs x1) x (qInit MOD qX)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "also"], ["proof (state)\nthis:\n  qInit MOD (qX #[[x1 \\<and> x]]_xs) =\n  igSubst MOD xs (igVar MOD xs x1) x (qInit MOD qX)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "have\n    \"igAbs MOD xs x1 (igSubst MOD xs ?x1 x (?h qX)) =\n     igAbs MOD xs x (?h qX)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs MOD xs x1 (igSubst MOD xs (igVar MOD xs x1) x (qInit MOD qX)) =\n    igAbs MOD xs x (qInit MOD qX)", "using assms"], ["proof (prove)\nusing this:\n  igSubstClsSTR MOD\n  igFreshClsSTR MOD\n  igAbsRenSTR MOD\n\ngoal (1 subgoal):\n 1. igAbs MOD xs x1 (igSubst MOD xs (igVar MOD xs x1) x (qInit MOD qX)) =\n    igAbs MOD xs x (qInit MOD qX)", "unfolding igAbsRenSTR_def"], ["proof (prove)\nusing this:\n  igSubstClsSTR MOD\n  igFreshClsSTR MOD\n  \\<forall>xs y x X.\n     igFresh MOD xs y X \\<longrightarrow>\n     igAbs MOD xs y (igSubst MOD xs (igVar MOD xs y) x X) = igAbs MOD xs x X\n\ngoal (1 subgoal):\n 1. igAbs MOD xs x1 (igSubst MOD xs (igVar MOD xs x1) x (qInit MOD qX)) =\n    igAbs MOD xs x (qInit MOD qX)", "by simp"], ["proof (state)\nthis:\n  igAbs MOD xs x1 (igSubst MOD xs (igVar MOD xs x1) x (qInit MOD qX)) =\n  igAbs MOD xs x (qInit MOD qX)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "also"], ["proof (state)\nthis:\n  igAbs MOD xs x1 (igSubst MOD xs (igVar MOD xs x1) x (qInit MOD qX)) =\n  igAbs MOD xs x (qInit MOD qX)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "have \"igAbs MOD xs x (?h qX) = ?hA (qAbs xs x qX)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs MOD xs x (qInit MOD qX) = qInitAbs MOD (qAbs xs x qX)", "using assms"], ["proof (prove)\nusing this:\n  igSubstClsSTR MOD\n  igFreshClsSTR MOD\n  igAbsRenSTR MOD\n\ngoal (1 subgoal):\n 1. igAbs MOD xs x (qInit MOD qX) = qInitAbs MOD (qAbs xs x qX)", "by simp"], ["proof (state)\nthis:\n  igAbs MOD xs x (qInit MOD qX) = qInitAbs MOD (qAbs xs x qX)\n\ngoal (1 subgoal):\n 1. \\<And>ys y1 y.\n       qAFreshAbs ys y1 (qAbs xs x qX) \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n       igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "finally"], ["proof (chain)\npicking this:\n  qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n  igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "show \"?hA ((qAbs xs x qX) $[[y1 \\<and> y]]_ys) =\n        igSubstAbs MOD ys ?y1 y (?hA (qAbs xs x qX))\""], ["proof (prove)\nusing this:\n  qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n  igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))\n\ngoal (1 subgoal):\n 1. qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n    igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))", "."], ["proof (state)\nthis:\n  qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n  igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>ys y1 y.\n     qAFreshAbs ys y1 (qAbs xs x qX) \\<longrightarrow>\n     qInitAbs MOD (qAbs xs x qX $[[y1 \\<and> y]]_ys) =\n     igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD (qAbs xs x qX))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iwlsFSbSwTR_qSwapAll_igSubstAll_qInitAll:\nassumes wls: \"iwlsFSbSwTR MOD\"\nshows\n\"(qGood qX \\<longrightarrow>\n  qAFresh ys y1 qX \\<longrightarrow>\n  qInit MOD (qX #[[y1 \\<and> y]]_ys) = igSubst MOD ys (igVar MOD ys y1) y (qInit MOD qX))\n \\<and>\n (qGoodAbs qA \\<longrightarrow>\n  qAFreshAbs ys y1 qA \\<longrightarrow>\n  qInitAbs MOD (qA $[[y1 \\<and> y]]_ys) = igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD qA))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (qGood qX \\<longrightarrow>\n     qAFresh ys y1 qX \\<longrightarrow>\n     qInit MOD (qX #[[y1 \\<and> y]]_ys) =\n     igSubst MOD ys (igVar MOD ys y1) y (qInit MOD qX)) \\<and>\n    (qGoodAbs qA \\<longrightarrow>\n     qAFreshAbs ys y1 qA \\<longrightarrow>\n     qInitAbs MOD (qA $[[y1 \\<and> y]]_ys) =\n     igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD qA))", "using assms"], ["proof (prove)\nusing this:\n  iwlsFSbSwTR MOD\n\ngoal (1 subgoal):\n 1. (qGood qX \\<longrightarrow>\n     qAFresh ys y1 qX \\<longrightarrow>\n     qInit MOD (qX #[[y1 \\<and> y]]_ys) =\n     igSubst MOD ys (igVar MOD ys y1) y (qInit MOD qX)) \\<and>\n    (qGoodAbs qA \\<longrightarrow>\n     qAFreshAbs ys y1 qA \\<longrightarrow>\n     qInitAbs MOD (qA $[[y1 \\<and> y]]_ys) =\n     igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD qA))", "unfolding iwlsFSbSwTR_def"], ["proof (prove)\nusing this:\n  igWlsAllDisj MOD \\<and>\n  igWlsAbsIsInBar MOD \\<and>\n  igConsIPresIGWlsSTR MOD \\<and>\n  igSubstAllIPresIGWlsAllSTR MOD \\<and>\n  igFreshClsSTR MOD \\<and> igSubstClsSTR MOD \\<and> igAbsRenSTR MOD\n\ngoal (1 subgoal):\n 1. (qGood qX \\<longrightarrow>\n     qAFresh ys y1 qX \\<longrightarrow>\n     qInit MOD (qX #[[y1 \\<and> y]]_ys) =\n     igSubst MOD ys (igVar MOD ys y1) y (qInit MOD qX)) \\<and>\n    (qGoodAbs qA \\<longrightarrow>\n     qAFreshAbs ys y1 qA \\<longrightarrow>\n     qInitAbs MOD (qA $[[y1 \\<and> y]]_ys) =\n     igSubstAbs MOD ys (igVar MOD ys y1) y (qInitAbs MOD qA))", "by(simp add: qSwapAll_igSubstAll_qInitAll)"], ["", "lemma iwlsFSwSTR_alphaAll_qInitAll:\nassumes \"iwlsFSwSTR MOD\"\nshows\n\"(\\<forall> qX'. qX #= qX' \\<longrightarrow> qInit MOD qX = qInit MOD qX') \\<and>\n (\\<forall> qA'. qA $= qA' \\<longrightarrow> qInitAbs MOD qA = qInitAbs MOD qA')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>qX'.\n        qX #= qX' \\<longrightarrow> qInit MOD qX = qInit MOD qX') \\<and>\n    (\\<forall>qA'.\n        qA $= qA' \\<longrightarrow> qInitAbs MOD qA = qInitAbs MOD qA')", "proof(induction rule: qTerm_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       \\<forall>qX'.\n          qVar xs x #= qX' \\<longrightarrow>\n          qInit MOD (qVar xs x) = qInit MOD qX'\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     \\<forall>qX'.\n                        a #= qX' \\<longrightarrow>\n                        qInit MOD a = qInit MOD qX')\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             \\<forall>qA'.\n                a $= qA' \\<longrightarrow>\n                qInitAbs MOD a = qInitAbs MOD qA')\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qX'.\n                            qOp delta inp binp #= qX' \\<longrightarrow>\n                            qInit MOD (qOp delta inp binp) = qInit MOD qX'\n 3. \\<And>xs x X.\n       \\<lbrakk>\\<And>Y.\n                   (X, Y) \\<in> qSwapped \\<Longrightarrow>\n                   \\<forall>qX'.\n                      Y #= qX' \\<longrightarrow>\n                      qInit MOD Y = qInit MOD qX';\n        \\<And>Y.\n           qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow>\n              qInit MOD Y = qInit MOD qX'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qA'.\n                            qAbs xs x X $= qA' \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X) = qInitAbs MOD qA'", "case (Var xs x)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       \\<forall>qX'.\n          qVar xs x #= qX' \\<longrightarrow>\n          qInit MOD (qVar xs x) = qInit MOD qX'\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     \\<forall>qX'.\n                        a #= qX' \\<longrightarrow>\n                        qInit MOD a = qInit MOD qX')\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             \\<forall>qA'.\n                a $= qA' \\<longrightarrow>\n                qInitAbs MOD a = qInitAbs MOD qA')\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qX'.\n                            qOp delta inp binp #= qX' \\<longrightarrow>\n                            qInit MOD (qOp delta inp binp) = qInit MOD qX'\n 3. \\<And>xs x X.\n       \\<lbrakk>\\<And>Y.\n                   (X, Y) \\<in> qSwapped \\<Longrightarrow>\n                   \\<forall>qX'.\n                      Y #= qX' \\<longrightarrow>\n                      qInit MOD Y = qInit MOD qX';\n        \\<And>Y.\n           qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow>\n              qInit MOD Y = qInit MOD qX'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qA'.\n                            qAbs xs x X $= qA' \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X) = qInitAbs MOD qA'", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qX'.\n       qVar xs x #= qX' \\<longrightarrow>\n       qInit MOD (qVar xs x) = qInit MOD qX'", "by(simp add: qVar_alpha_iff)"], ["proof (state)\nthis:\n  \\<forall>qX'.\n     qVar xs x #= qX' \\<longrightarrow>\n     qInit MOD (qVar xs x) = qInit MOD qX'\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     \\<forall>qX'.\n                        a #= qX' \\<longrightarrow>\n                        qInit MOD a = qInit MOD qX')\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             \\<forall>qA'.\n                a $= qA' \\<longrightarrow>\n                qInitAbs MOD a = qInitAbs MOD qA')\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qX'.\n                            qOp delta inp binp #= qX' \\<longrightarrow>\n                            qInit MOD (qOp delta inp binp) = qInit MOD qX'\n 2. \\<And>xs x X.\n       \\<lbrakk>\\<And>Y.\n                   (X, Y) \\<in> qSwapped \\<Longrightarrow>\n                   \\<forall>qX'.\n                      Y #= qX' \\<longrightarrow>\n                      qInit MOD Y = qInit MOD qX';\n        \\<And>Y.\n           qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow>\n              qInit MOD Y = qInit MOD qX'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qA'.\n                            qAbs xs x X $= qA' \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X) = qInitAbs MOD qA'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     \\<forall>qX'.\n                        a #= qX' \\<longrightarrow>\n                        qInit MOD a = qInit MOD qX')\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             \\<forall>qA'.\n                a $= qA' \\<longrightarrow>\n                qInitAbs MOD a = qInitAbs MOD qA')\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qX'.\n                            qOp delta inp binp #= qX' \\<longrightarrow>\n                            qInit MOD (qOp delta inp binp) = qInit MOD qX'\n 2. \\<And>xs x X.\n       \\<lbrakk>\\<And>Y.\n                   (X, Y) \\<in> qSwapped \\<Longrightarrow>\n                   \\<forall>qX'.\n                      Y #= qX' \\<longrightarrow>\n                      qInit MOD Y = qInit MOD qX';\n        \\<And>Y.\n           qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow>\n              qInit MOD Y = qInit MOD qX'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qA'.\n                            qAbs xs x X $= qA' \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X) = qInitAbs MOD qA'", "case (Op delta qinp qbinp)"], ["proof (state)\nthis:\n  liftAll\n   (\\<lambda>a.\n       \\<forall>qX'. a #= qX' \\<longrightarrow> qInit MOD a = qInit MOD qX')\n   qinp\n  liftAll\n   (\\<lambda>a.\n       \\<forall>qA'.\n          a $= qA' \\<longrightarrow> qInitAbs MOD a = qInitAbs MOD qA')\n   qbinp\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     \\<forall>qX'.\n                        a #= qX' \\<longrightarrow>\n                        qInit MOD a = qInit MOD qX')\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             \\<forall>qA'.\n                a $= qA' \\<longrightarrow>\n                qInitAbs MOD a = qInitAbs MOD qA')\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qX'.\n                            qOp delta inp binp #= qX' \\<longrightarrow>\n                            qInit MOD (qOp delta inp binp) = qInit MOD qX'\n 2. \\<And>xs x X.\n       \\<lbrakk>\\<And>Y.\n                   (X, Y) \\<in> qSwapped \\<Longrightarrow>\n                   \\<forall>qX'.\n                      Y #= qX' \\<longrightarrow>\n                      qInit MOD Y = qInit MOD qX';\n        \\<And>Y.\n           qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow>\n              qInit MOD Y = qInit MOD qX'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qA'.\n                            qAbs xs x X $= qA' \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X) = qInitAbs MOD qA'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qX'.\n       qOp delta qinp qbinp #= qX' \\<longrightarrow>\n       qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qX'.\n       qOp delta qinp qbinp #= qX' \\<Longrightarrow>\n       qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "fix qX'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qX'.\n       qOp delta qinp qbinp #= qX' \\<Longrightarrow>\n       qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "assume \"qOp delta qinp qbinp #= qX'\""], ["proof (state)\nthis:\n  qOp delta qinp qbinp #= qX'\n\ngoal (1 subgoal):\n 1. \\<And>qX'.\n       qOp delta qinp qbinp #= qX' \\<Longrightarrow>\n       qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "then"], ["proof (chain)\npicking this:\n  qOp delta qinp qbinp #= qX'", "obtain qinp' qbinp' where qX': \"qX' = qOp delta qinp' qbinp'\"\n    and *: \"sameDom qinp qinp' \\<and> sameDom qbinp qbinp'\"\n    and **: \"liftAll2 (\\<lambda>qX qX'. qX #= qX') qinp qinp' \\<and>\n             liftAll2 (\\<lambda>qA qA'. qA $= qA') qbinp qbinp'\""], ["proof (prove)\nusing this:\n  qOp delta qinp qbinp #= qX'\n\ngoal (1 subgoal):\n 1. (\\<And>qinp' qbinp'.\n        \\<lbrakk>qX' = qOp delta qinp' qbinp';\n         sameDom qinp qinp' \\<and> sameDom qbinp qbinp';\n         liftAll2 (#=) qinp qinp' \\<and> liftAll2 ($=) qbinp qbinp'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using qOp_alpha_iff[of delta qinp qbinp qX']"], ["proof (prove)\nusing this:\n  qOp delta qinp qbinp #= qX'\n  (qOp delta qinp qbinp #= qX') =\n  (\\<exists>inp' binp'.\n      qX' = qOp delta inp' binp' \\<and>\n      sameDom qinp inp' \\<and>\n      sameDom qbinp binp' \\<and>\n      liftAll2 (#=) qinp inp' \\<and> liftAll2 ($=) qbinp binp')\n\ngoal (1 subgoal):\n 1. (\\<And>qinp' qbinp'.\n        \\<lbrakk>qX' = qOp delta qinp' qbinp';\n         sameDom qinp qinp' \\<and> sameDom qbinp qbinp';\n         liftAll2 (#=) qinp qinp' \\<and> liftAll2 ($=) qbinp qbinp'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  qX' = qOp delta qinp' qbinp'\n  sameDom qinp qinp' \\<and> sameDom qbinp qbinp'\n  liftAll2 (#=) qinp qinp' \\<and> liftAll2 ($=) qbinp qbinp'\n\ngoal (1 subgoal):\n 1. \\<And>qX'.\n       qOp delta qinp qbinp #= qX' \\<Longrightarrow>\n       qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "hence \"lift (qInit MOD) qinp = lift (qInit MOD) qinp'\""], ["proof (prove)\nusing this:\n  qX' = qOp delta qinp' qbinp'\n  sameDom qinp qinp' \\<and> sameDom qbinp qbinp'\n  liftAll2 (#=) qinp qinp' \\<and> liftAll2 ($=) qbinp qbinp'\n\ngoal (1 subgoal):\n 1. lift (qInit MOD) qinp = lift (qInit MOD) qinp'", "by (smt Op.IH(1) liftAll2_def liftAll2_lift_ext liftAll_def)"], ["proof (state)\nthis:\n  lift (qInit MOD) qinp = lift (qInit MOD) qinp'\n\ngoal (1 subgoal):\n 1. \\<And>qX'.\n       qOp delta qinp qbinp #= qX' \\<Longrightarrow>\n       qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "moreover"], ["proof (state)\nthis:\n  lift (qInit MOD) qinp = lift (qInit MOD) qinp'\n\ngoal (1 subgoal):\n 1. \\<And>qX'.\n       qOp delta qinp qbinp #= qX' \\<Longrightarrow>\n       qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "have \"lift (qInitAbs MOD) qbinp = lift (qInitAbs MOD) qbinp'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (qInitAbs MOD) qbinp = lift (qInitAbs MOD) qbinp'", "by (smt * ** Op.IH(2) liftAll2_def liftAll2_lift_ext liftAll_def)"], ["proof (state)\nthis:\n  lift (qInitAbs MOD) qbinp = lift (qInitAbs MOD) qbinp'\n\ngoal (1 subgoal):\n 1. \\<And>qX'.\n       qOp delta qinp qbinp #= qX' \\<Longrightarrow>\n       qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "ultimately"], ["proof (chain)\npicking this:\n  lift (qInit MOD) qinp = lift (qInit MOD) qinp'\n  lift (qInitAbs MOD) qbinp = lift (qInitAbs MOD) qbinp'", "show \"qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'\""], ["proof (prove)\nusing this:\n  lift (qInit MOD) qinp = lift (qInit MOD) qinp'\n  lift (qInitAbs MOD) qbinp = lift (qInitAbs MOD) qbinp'\n\ngoal (1 subgoal):\n 1. qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "unfolding qX'"], ["proof (prove)\nusing this:\n  lift (qInit MOD) qinp = lift (qInit MOD) qinp'\n  lift (qInitAbs MOD) qbinp = lift (qInitAbs MOD) qbinp'\n\ngoal (1 subgoal):\n 1. qInit MOD (qOp delta qinp qbinp) = qInit MOD (qOp delta qinp' qbinp')", "by simp"], ["proof (state)\nthis:\n  qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>qX'.\n     qOp delta qinp qbinp #= qX' \\<longrightarrow>\n     qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'\n\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       \\<lbrakk>\\<And>Y.\n                   (X, Y) \\<in> qSwapped \\<Longrightarrow>\n                   \\<forall>qX'.\n                      Y #= qX' \\<longrightarrow>\n                      qInit MOD Y = qInit MOD qX';\n        \\<And>Y.\n           qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow>\n              qInit MOD Y = qInit MOD qX'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qA'.\n                            qAbs xs x X $= qA' \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X) = qInitAbs MOD qA'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       \\<lbrakk>\\<And>Y.\n                   (X, Y) \\<in> qSwapped \\<Longrightarrow>\n                   \\<forall>qX'.\n                      Y #= qX' \\<longrightarrow>\n                      qInit MOD Y = qInit MOD qX';\n        \\<And>Y.\n           qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow>\n              qInit MOD Y = qInit MOD qX'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qA'.\n                            qAbs xs x X $= qA' \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X) = qInitAbs MOD qA'", "case (Abs xs x qX)"], ["proof (state)\nthis:\n  (qX, ?Y114) \\<in> qSwapped \\<Longrightarrow>\n  \\<forall>qX'.\n     ?Y114 #= qX' \\<longrightarrow> qInit MOD ?Y114 = qInit MOD qX'\n  qSkel ?Y114 = qSkel qX \\<Longrightarrow>\n  \\<forall>qX'.\n     ?Y114 #= qX' \\<longrightarrow> qInit MOD ?Y114 = qInit MOD qX'\n\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       \\<lbrakk>\\<And>Y.\n                   (X, Y) \\<in> qSwapped \\<Longrightarrow>\n                   \\<forall>qX'.\n                      Y #= qX' \\<longrightarrow>\n                      qInit MOD Y = qInit MOD qX';\n        \\<And>Y.\n           qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow>\n              qInit MOD Y = qInit MOD qX'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qA'.\n                            qAbs xs x X $= qA' \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X) = qInitAbs MOD qA'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qA'.\n       qAbs xs x qX $= qA' \\<longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "fix qA'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "assume \"qAbs xs x qX $= qA'\""], ["proof (state)\nthis:\n  qAbs xs x qX $= qA'\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "then"], ["proof (chain)\npicking this:\n  qAbs xs x qX $= qA'", "obtain x' y qX' where qA': \"qA' = qAbs xs x' qX'\"\n    and y_not: \"y \\<notin> {x, x'}\" and \"qAFresh xs y qX\"  \"qAFresh xs y qX'\"\n    and alpha: \"(qX #[[y \\<and> x]]_xs) #= (qX' #[[y \\<and> x']]_xs)\""], ["proof (prove)\nusing this:\n  qAbs xs x qX $= qA'\n\ngoal (1 subgoal):\n 1. (\\<And>x' qX' y.\n        \\<lbrakk>qA' = qAbs xs x' qX'; y \\<notin> {x, x'}; qAFresh xs y qX;\n         qAFresh xs y qX';\n         qX #[[y \\<and> x]]_xs #= qX' #[[y \\<and> x']]_xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using qAbs_alphaAbs_iff[of xs x qX qA']"], ["proof (prove)\nusing this:\n  qAbs xs x qX $= qA'\n  (qAbs xs x qX $= qA') =\n  (\\<exists>x' y X'.\n      qA' = qAbs xs x' X' \\<and>\n      y \\<notin> {x, x'} \\<and>\n      qAFresh xs y qX \\<and>\n      qAFresh xs y X' \\<and>\n      qX #[[y \\<and> x]]_xs #= X' #[[y \\<and> x']]_xs)\n\ngoal (1 subgoal):\n 1. (\\<And>x' qX' y.\n        \\<lbrakk>qA' = qAbs xs x' qX'; y \\<notin> {x, x'}; qAFresh xs y qX;\n         qAFresh xs y qX';\n         qX #[[y \\<and> x]]_xs #= qX' #[[y \\<and> x']]_xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  qA' = qAbs xs x' qX'\n  y \\<notin> {x, x'}\n  qAFresh xs y qX\n  qAFresh xs y qX'\n  qX #[[y \\<and> x]]_xs #= qX' #[[y \\<and> x']]_xs\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "hence y_fresh: \"qFresh xs y qX \\<and> qFresh xs y qX'\""], ["proof (prove)\nusing this:\n  qA' = qAbs xs x' qX'\n  y \\<notin> {x, x'}\n  qAFresh xs y qX\n  qAFresh xs y qX'\n  qX #[[y \\<and> x]]_xs #= qX' #[[y \\<and> x']]_xs\n\ngoal (1 subgoal):\n 1. qFresh xs y qX \\<and> qFresh xs y qX'", "using qAFresh_imp_qFresh"], ["proof (prove)\nusing this:\n  qA' = qAbs xs x' qX'\n  y \\<notin> {x, x'}\n  qAFresh xs y qX\n  qAFresh xs y qX'\n  qX #[[y \\<and> x]]_xs #= qX' #[[y \\<and> x']]_xs\n  qAFresh ?xs ?x ?X \\<Longrightarrow> qFresh ?xs ?x ?X\n\ngoal (1 subgoal):\n 1. qFresh xs y qX \\<and> qFresh xs y qX'", "by auto"], ["proof (state)\nthis:\n  qFresh xs y qX \\<and> qFresh xs y qX'\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "have \"(qX, qX #[[y \\<and> x]]_xs) \\<in> qSwapped\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (qX, qX #[[y \\<and> x]]_xs) \\<in> qSwapped", "using qSwap_qSwapped"], ["proof (prove)\nusing this:\n  (?X, ?X #[[?x \\<and> ?y]]_?zs) \\<in> qSwapped\n\ngoal (1 subgoal):\n 1. (qX, qX #[[y \\<and> x]]_xs) \\<in> qSwapped", "by fastforce"], ["proof (state)\nthis:\n  (qX, qX #[[y \\<and> x]]_xs) \\<in> qSwapped\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "hence \"qInit MOD (qX #[[y \\<and> x]]_xs) = qInit MOD (qX' #[[y \\<and> x']]_xs)\""], ["proof (prove)\nusing this:\n  (qX, qX #[[y \\<and> x]]_xs) \\<in> qSwapped\n\ngoal (1 subgoal):\n 1. qInit MOD (qX #[[y \\<and> x]]_xs) = qInit MOD (qX' #[[y \\<and> x']]_xs)", "using Abs.IH alpha"], ["proof (prove)\nusing this:\n  (qX, qX #[[y \\<and> x]]_xs) \\<in> qSwapped\n  (qX, ?Y114) \\<in> qSwapped \\<Longrightarrow>\n  \\<forall>qX'.\n     ?Y114 #= qX' \\<longrightarrow> qInit MOD ?Y114 = qInit MOD qX'\n  qSkel ?Y114 = qSkel qX \\<Longrightarrow>\n  \\<forall>qX'.\n     ?Y114 #= qX' \\<longrightarrow> qInit MOD ?Y114 = qInit MOD qX'\n  qX #[[y \\<and> x]]_xs #= qX' #[[y \\<and> x']]_xs\n\ngoal (1 subgoal):\n 1. qInit MOD (qX #[[y \\<and> x]]_xs) = qInit MOD (qX' #[[y \\<and> x']]_xs)", "by simp"], ["proof (state)\nthis:\n  qInit MOD (qX #[[y \\<and> x]]_xs) = qInit MOD (qX' #[[y \\<and> x']]_xs)\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "hence \"igSwap MOD xs y x (qInit MOD qX) = igSwap MOD xs y x' (qInit MOD qX')\""], ["proof (prove)\nusing this:\n  qInit MOD (qX #[[y \\<and> x]]_xs) = qInit MOD (qX' #[[y \\<and> x']]_xs)\n\ngoal (1 subgoal):\n 1. igSwap MOD xs y x (qInit MOD qX) = igSwap MOD xs y x' (qInit MOD qX')", "using assms"], ["proof (prove)\nusing this:\n  qInit MOD (qX #[[y \\<and> x]]_xs) = qInit MOD (qX' #[[y \\<and> x']]_xs)\n  iwlsFSwSTR MOD\n\ngoal (1 subgoal):\n 1. igSwap MOD xs y x (qInit MOD qX) = igSwap MOD xs y x' (qInit MOD qX')", "by(auto simp: iwlsFSwSTR_qSwapAll_igSwapAll_qInitAll)"], ["proof (state)\nthis:\n  igSwap MOD xs y x (qInit MOD qX) = igSwap MOD xs y x' (qInit MOD qX')\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "moreover"], ["proof (state)\nthis:\n  igSwap MOD xs y x (qInit MOD qX) = igSwap MOD xs y x' (qInit MOD qX')\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "have \"igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')", "using y_fresh assms"], ["proof (prove)\nusing this:\n  qFresh xs y qX \\<and> qFresh xs y qX'\n  iwlsFSwSTR MOD\n\ngoal (1 subgoal):\n 1. igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')", "by(auto simp add: iwlsFSwSTR_qFreshAll_igFreshAll_qInitAll)"], ["proof (state)\nthis:\n  igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "ultimately"], ["proof (chain)\npicking this:\n  igSwap MOD xs y x (qInit MOD qX) = igSwap MOD xs y x' (qInit MOD qX')\n  igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')", "have \"igAbs MOD xs x (qInit MOD qX) = igAbs MOD xs x' (qInit MOD qX')\""], ["proof (prove)\nusing this:\n  igSwap MOD xs y x (qInit MOD qX) = igSwap MOD xs y x' (qInit MOD qX')\n  igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')\n\ngoal (1 subgoal):\n 1. igAbs MOD xs x (qInit MOD qX) = igAbs MOD xs x' (qInit MOD qX')", "using y_not assms"], ["proof (prove)\nusing this:\n  igSwap MOD xs y x (qInit MOD qX) = igSwap MOD xs y x' (qInit MOD qX')\n  igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')\n  y \\<notin> {x, x'}\n  iwlsFSwSTR MOD\n\ngoal (1 subgoal):\n 1. igAbs MOD xs x (qInit MOD qX) = igAbs MOD xs x' (qInit MOD qX')", "unfolding iwlsFSwSTR_def igAbsCongSSTR_def"], ["proof (prove)\nusing this:\n  igSwap MOD xs y x (qInit MOD qX) = igSwap MOD xs y x' (qInit MOD qX')\n  igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')\n  y \\<notin> {x, x'}\n  igWlsAllDisj MOD \\<and>\n  igWlsAbsIsInBar MOD \\<and>\n  igConsIPresIGWlsSTR MOD \\<and>\n  igSwapAllIPresIGWlsAllSTR MOD \\<and>\n  igFreshClsSTR MOD \\<and>\n  igSwapClsSTR MOD \\<and>\n  (\\<forall>xs x x' y X X'.\n      igFresh MOD xs y X \\<and>\n      igFresh MOD xs y X' \\<and>\n      igSwap MOD xs y x X = igSwap MOD xs y x' X' \\<longrightarrow>\n      igAbs MOD xs x X = igAbs MOD xs x' X')\n\ngoal (1 subgoal):\n 1. igAbs MOD xs x (qInit MOD qX) = igAbs MOD xs x' (qInit MOD qX')", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igSwap MOD xs y x (qInit MOD qX) =\n             igSwap MOD xs y x' (qInit MOD qX');\n     igAbs MOD xs x (qInit MOD qX) \\<noteq> igAbs MOD xs x' (qInit MOD qX');\n     y \\<noteq> x; y \\<notin> {}; igFresh MOD xs y (qInit MOD qX);\n     igFresh MOD xs y (qInit MOD qX'); igWlsAllDisj MOD;\n     igWlsAbsIsInBar MOD; igConsIPresIGWlsSTR MOD;\n     igSwapAllIPresIGWlsAllSTR MOD; igFreshClsSTR MOD; igSwapClsSTR MOD;\n     \\<forall>xs x x' y X X'.\n        igFresh MOD xs y X \\<and>\n        igFresh MOD xs y X' \\<and>\n        igSwap MOD xs y x X = igSwap MOD xs y x' X' \\<longrightarrow>\n        igAbs MOD xs x X = igAbs MOD xs x' X'\\<rbrakk>\n    \\<Longrightarrow> y = x'", "by (erule allE[of _ xs], erule allE[of _ x]) blast"], ["proof (state)\nthis:\n  igAbs MOD xs x (qInit MOD qX) = igAbs MOD xs x' (qInit MOD qX')\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "thus \"qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'\""], ["proof (prove)\nusing this:\n  igAbs MOD xs x (qInit MOD qX) = igAbs MOD xs x' (qInit MOD qX')\n\ngoal (1 subgoal):\n 1. qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "unfolding qA'"], ["proof (prove)\nusing this:\n  igAbs MOD xs x (qInit MOD qX) = igAbs MOD xs x' (qInit MOD qX')\n\ngoal (1 subgoal):\n 1. qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD (qAbs xs x' qX')", "by simp"], ["proof (state)\nthis:\n  qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>qA'.\n     qAbs xs x qX $= qA' \\<longrightarrow>\n     qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary iwlsFSwSTR_qInit_respectsP_alpha:\nassumes \"iwlsFSwSTR MOD\" shows \"(qInit MOD) respectsP alpha\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qInit MOD respectsP (#=)", "unfolding congruentP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. x #= y \\<longrightarrow> qInit MOD x = qInit MOD y", "using assms iwlsFSwSTR_alphaAll_qInitAll"], ["proof (prove)\nusing this:\n  iwlsFSwSTR MOD\n  iwlsFSwSTR ?MOD \\<Longrightarrow>\n  (\\<forall>qX'.\n      ?qX #= qX' \\<longrightarrow> qInit ?MOD ?qX = qInit ?MOD qX') \\<and>\n  (\\<forall>qA'.\n      ?qA $= qA' \\<longrightarrow> qInitAbs ?MOD ?qA = qInitAbs ?MOD qA')\n\ngoal (1 subgoal):\n 1. \\<forall>x y. x #= y \\<longrightarrow> qInit MOD x = qInit MOD y", "by blast"], ["", "corollary iwlsFSwSTR_qInitAbs_respectsP_alphaAbs:\nassumes \"iwlsFSwSTR MOD\" shows \"(qInitAbs MOD) respectsP alphaAbs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qInitAbs MOD respectsP ($=)", "unfolding congruentP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. x $= y \\<longrightarrow> qInitAbs MOD x = qInitAbs MOD y", "using assms iwlsFSwSTR_alphaAll_qInitAll"], ["proof (prove)\nusing this:\n  iwlsFSwSTR MOD\n  iwlsFSwSTR ?MOD \\<Longrightarrow>\n  (\\<forall>qX'.\n      ?qX #= qX' \\<longrightarrow> qInit ?MOD ?qX = qInit ?MOD qX') \\<and>\n  (\\<forall>qA'.\n      ?qA $= qA' \\<longrightarrow> qInitAbs ?MOD ?qA = qInitAbs ?MOD qA')\n\ngoal (1 subgoal):\n 1. \\<forall>x y. x $= y \\<longrightarrow> qInitAbs MOD x = qInitAbs MOD y", "by blast"], ["", "lemma iwlsFSbSwTR_alphaAll_qInitAll:\nfixes qX::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      qA::\"('index,'bindex,'varSort,'var,'opSym)qAbs\"\nassumes \"iwlsFSbSwTR MOD\"\nshows\n\"(qGood qX \\<longrightarrow> (\\<forall> qX'. qX #= qX' \\<longrightarrow> qInit MOD qX = qInit MOD qX')) \\<and>\n (qGoodAbs qA \\<longrightarrow> (\\<forall> qA'. qA $= qA' \\<longrightarrow> qInitAbs MOD qA = qInitAbs MOD qA'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (qGood qX \\<longrightarrow>\n     (\\<forall>qX'.\n         qX #= qX' \\<longrightarrow> qInit MOD qX = qInit MOD qX')) \\<and>\n    (qGoodAbs qA \\<longrightarrow>\n     (\\<forall>qA'.\n         qA $= qA' \\<longrightarrow> qInitAbs MOD qA = qInitAbs MOD qA'))", "proof(induction rule: qGood_qTerm_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       \\<forall>qX'.\n          qVar xs x #= qX' \\<longrightarrow>\n          qInit MOD (qVar xs x) = qInit MOD qX'\n 2. \\<And>delta inp binp.\n       \\<lbrakk>|{i. inp i \\<noteq> None}| <o |UNIV|;\n        |{i. binp i \\<noteq> None}| <o |UNIV|;\n        liftAll\n         (\\<lambda>X.\n             qGood X \\<and>\n             (\\<forall>qX'.\n                 X #= qX' \\<longrightarrow> qInit MOD X = qInit MOD qX'))\n         inp;\n        liftAll\n         (\\<lambda>A.\n             qGoodAbs A \\<and>\n             (\\<forall>qA'.\n                 A $= qA' \\<longrightarrow>\n                 qInitAbs MOD A = qInitAbs MOD qA'))\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qX'.\n                            qOp delta inp binp #= qX' \\<longrightarrow>\n                            qInit MOD (qOp delta inp binp) = qInit MOD qX'\n 3. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow> qInit MOD Y = qInit MOD qX';\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow>\n              qInit MOD Y = qInit MOD qX'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qA'.\n                            qAbs xs x X $= qA' \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X) = qInitAbs MOD qA'", "case (Var xs x)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       \\<forall>qX'.\n          qVar xs x #= qX' \\<longrightarrow>\n          qInit MOD (qVar xs x) = qInit MOD qX'\n 2. \\<And>delta inp binp.\n       \\<lbrakk>|{i. inp i \\<noteq> None}| <o |UNIV|;\n        |{i. binp i \\<noteq> None}| <o |UNIV|;\n        liftAll\n         (\\<lambda>X.\n             qGood X \\<and>\n             (\\<forall>qX'.\n                 X #= qX' \\<longrightarrow> qInit MOD X = qInit MOD qX'))\n         inp;\n        liftAll\n         (\\<lambda>A.\n             qGoodAbs A \\<and>\n             (\\<forall>qA'.\n                 A $= qA' \\<longrightarrow>\n                 qInitAbs MOD A = qInitAbs MOD qA'))\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qX'.\n                            qOp delta inp binp #= qX' \\<longrightarrow>\n                            qInit MOD (qOp delta inp binp) = qInit MOD qX'\n 3. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow> qInit MOD Y = qInit MOD qX';\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow>\n              qInit MOD Y = qInit MOD qX'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qA'.\n                            qAbs xs x X $= qA' \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X) = qInitAbs MOD qA'", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qX'.\n       qVar xs x #= qX' \\<longrightarrow>\n       qInit MOD (qVar xs x) = qInit MOD qX'", "by(simp add: qVar_alpha_iff)"], ["proof (state)\nthis:\n  \\<forall>qX'.\n     qVar xs x #= qX' \\<longrightarrow>\n     qInit MOD (qVar xs x) = qInit MOD qX'\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>|{i. inp i \\<noteq> None}| <o |UNIV|;\n        |{i. binp i \\<noteq> None}| <o |UNIV|;\n        liftAll\n         (\\<lambda>X.\n             qGood X \\<and>\n             (\\<forall>qX'.\n                 X #= qX' \\<longrightarrow> qInit MOD X = qInit MOD qX'))\n         inp;\n        liftAll\n         (\\<lambda>A.\n             qGoodAbs A \\<and>\n             (\\<forall>qA'.\n                 A $= qA' \\<longrightarrow>\n                 qInitAbs MOD A = qInitAbs MOD qA'))\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qX'.\n                            qOp delta inp binp #= qX' \\<longrightarrow>\n                            qInit MOD (qOp delta inp binp) = qInit MOD qX'\n 2. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow> qInit MOD Y = qInit MOD qX';\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow>\n              qInit MOD Y = qInit MOD qX'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qA'.\n                            qAbs xs x X $= qA' \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X) = qInitAbs MOD qA'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>|{i. inp i \\<noteq> None}| <o |UNIV|;\n        |{i. binp i \\<noteq> None}| <o |UNIV|;\n        liftAll\n         (\\<lambda>X.\n             qGood X \\<and>\n             (\\<forall>qX'.\n                 X #= qX' \\<longrightarrow> qInit MOD X = qInit MOD qX'))\n         inp;\n        liftAll\n         (\\<lambda>A.\n             qGoodAbs A \\<and>\n             (\\<forall>qA'.\n                 A $= qA' \\<longrightarrow>\n                 qInitAbs MOD A = qInitAbs MOD qA'))\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qX'.\n                            qOp delta inp binp #= qX' \\<longrightarrow>\n                            qInit MOD (qOp delta inp binp) = qInit MOD qX'\n 2. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow> qInit MOD Y = qInit MOD qX';\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow>\n              qInit MOD Y = qInit MOD qX'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qA'.\n                            qAbs xs x X $= qA' \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X) = qInitAbs MOD qA'", "case (Op delta qinp qbinp)"], ["proof (state)\nthis:\n  |{i. qinp i \\<noteq> None}| <o |UNIV|\n  |{i. qbinp i \\<noteq> None}| <o |UNIV|\n  liftAll\n   (\\<lambda>X.\n       qGood X \\<and>\n       (\\<forall>qX'.\n           X #= qX' \\<longrightarrow> qInit MOD X = qInit MOD qX'))\n   qinp\n  liftAll\n   (\\<lambda>A.\n       qGoodAbs A \\<and>\n       (\\<forall>qA'.\n           A $= qA' \\<longrightarrow> qInitAbs MOD A = qInitAbs MOD qA'))\n   qbinp\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>|{i. inp i \\<noteq> None}| <o |UNIV|;\n        |{i. binp i \\<noteq> None}| <o |UNIV|;\n        liftAll\n         (\\<lambda>X.\n             qGood X \\<and>\n             (\\<forall>qX'.\n                 X #= qX' \\<longrightarrow> qInit MOD X = qInit MOD qX'))\n         inp;\n        liftAll\n         (\\<lambda>A.\n             qGoodAbs A \\<and>\n             (\\<forall>qA'.\n                 A $= qA' \\<longrightarrow>\n                 qInitAbs MOD A = qInitAbs MOD qA'))\n         binp\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qX'.\n                            qOp delta inp binp #= qX' \\<longrightarrow>\n                            qInit MOD (qOp delta inp binp) = qInit MOD qX'\n 2. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow> qInit MOD Y = qInit MOD qX';\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow>\n              qInit MOD Y = qInit MOD qX'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qA'.\n                            qAbs xs x X $= qA' \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X) = qInitAbs MOD qA'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qX'.\n       qOp delta qinp qbinp #= qX' \\<longrightarrow>\n       qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qX'.\n       qOp delta qinp qbinp #= qX' \\<Longrightarrow>\n       qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "fix qX'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qX'.\n       qOp delta qinp qbinp #= qX' \\<Longrightarrow>\n       qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "assume \"qOp delta qinp qbinp #= qX'\""], ["proof (state)\nthis:\n  qOp delta qinp qbinp #= qX'\n\ngoal (1 subgoal):\n 1. \\<And>qX'.\n       qOp delta qinp qbinp #= qX' \\<Longrightarrow>\n       qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "then"], ["proof (chain)\npicking this:\n  qOp delta qinp qbinp #= qX'", "obtain qinp' qbinp' where qX': \"qX' = qOp delta qinp' qbinp'\"\n    and *: \"sameDom qinp qinp' \\<and> sameDom qbinp qbinp'\"\n    and **: \"liftAll2 (\\<lambda>qX qX'. qX #= qX') qinp qinp' \\<and>\n           liftAll2 (\\<lambda>qA qA'. qA $= qA') qbinp qbinp'\""], ["proof (prove)\nusing this:\n  qOp delta qinp qbinp #= qX'\n\ngoal (1 subgoal):\n 1. (\\<And>qinp' qbinp'.\n        \\<lbrakk>qX' = qOp delta qinp' qbinp';\n         sameDom qinp qinp' \\<and> sameDom qbinp qbinp';\n         liftAll2 (#=) qinp qinp' \\<and> liftAll2 ($=) qbinp qbinp'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using qOp_alpha_iff[of delta qinp qbinp qX']"], ["proof (prove)\nusing this:\n  qOp delta qinp qbinp #= qX'\n  (qOp delta qinp qbinp #= qX') =\n  (\\<exists>inp' binp'.\n      qX' = qOp delta inp' binp' \\<and>\n      sameDom qinp inp' \\<and>\n      sameDom qbinp binp' \\<and>\n      liftAll2 (#=) qinp inp' \\<and> liftAll2 ($=) qbinp binp')\n\ngoal (1 subgoal):\n 1. (\\<And>qinp' qbinp'.\n        \\<lbrakk>qX' = qOp delta qinp' qbinp';\n         sameDom qinp qinp' \\<and> sameDom qbinp qbinp';\n         liftAll2 (#=) qinp qinp' \\<and> liftAll2 ($=) qbinp qbinp'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  qX' = qOp delta qinp' qbinp'\n  sameDom qinp qinp' \\<and> sameDom qbinp qbinp'\n  liftAll2 (#=) qinp qinp' \\<and> liftAll2 ($=) qbinp qbinp'\n\ngoal (1 subgoal):\n 1. \\<And>qX'.\n       qOp delta qinp qbinp #= qX' \\<Longrightarrow>\n       qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "have \"lift (qInit MOD) qinp = lift (qInit MOD) qinp'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (qInit MOD) qinp = lift (qInit MOD) qinp'", "using \"*\" \"**\" Op.IH(1)"], ["proof (prove)\nusing this:\n  sameDom qinp qinp' \\<and> sameDom qbinp qbinp'\n  liftAll2 (#=) qinp qinp' \\<and> liftAll2 ($=) qbinp qbinp'\n  liftAll\n   (\\<lambda>X.\n       qGood X \\<and>\n       (\\<forall>qX'.\n           X #= qX' \\<longrightarrow> qInit MOD X = qInit MOD qX'))\n   qinp\n\ngoal (1 subgoal):\n 1. lift (qInit MOD) qinp = lift (qInit MOD) qinp'", "by (simp add: lift_def liftAll2_def liftAll_def\n     sameDom_def fun_eq_iff split: option.splits) (metis option.exhaust)"], ["proof (state)\nthis:\n  lift (qInit MOD) qinp = lift (qInit MOD) qinp'\n\ngoal (1 subgoal):\n 1. \\<And>qX'.\n       qOp delta qinp qbinp #= qX' \\<Longrightarrow>\n       qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "moreover"], ["proof (state)\nthis:\n  lift (qInit MOD) qinp = lift (qInit MOD) qinp'\n\ngoal (1 subgoal):\n 1. \\<And>qX'.\n       qOp delta qinp qbinp #= qX' \\<Longrightarrow>\n       qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "have \"lift (qInitAbs MOD) qbinp = lift (qInitAbs MOD) qbinp'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (qInitAbs MOD) qbinp = lift (qInitAbs MOD) qbinp'", "using \"*\" \"**\" Op.IH(2)"], ["proof (prove)\nusing this:\n  sameDom qinp qinp' \\<and> sameDom qbinp qbinp'\n  liftAll2 (#=) qinp qinp' \\<and> liftAll2 ($=) qbinp qbinp'\n  liftAll\n   (\\<lambda>A.\n       qGoodAbs A \\<and>\n       (\\<forall>qA'.\n           A $= qA' \\<longrightarrow> qInitAbs MOD A = qInitAbs MOD qA'))\n   qbinp\n\ngoal (1 subgoal):\n 1. lift (qInitAbs MOD) qbinp = lift (qInitAbs MOD) qbinp'", "by (simp add: lift_def liftAll2_def liftAll_def\n     sameDom_def fun_eq_iff split: option.splits) (metis option.exhaust)"], ["proof (state)\nthis:\n  lift (qInitAbs MOD) qbinp = lift (qInitAbs MOD) qbinp'\n\ngoal (1 subgoal):\n 1. \\<And>qX'.\n       qOp delta qinp qbinp #= qX' \\<Longrightarrow>\n       qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "ultimately"], ["proof (chain)\npicking this:\n  lift (qInit MOD) qinp = lift (qInit MOD) qinp'\n  lift (qInitAbs MOD) qbinp = lift (qInitAbs MOD) qbinp'", "show \"qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'\""], ["proof (prove)\nusing this:\n  lift (qInit MOD) qinp = lift (qInit MOD) qinp'\n  lift (qInitAbs MOD) qbinp = lift (qInitAbs MOD) qbinp'\n\ngoal (1 subgoal):\n 1. qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'", "unfolding qX'"], ["proof (prove)\nusing this:\n  lift (qInit MOD) qinp = lift (qInit MOD) qinp'\n  lift (qInitAbs MOD) qbinp = lift (qInitAbs MOD) qbinp'\n\ngoal (1 subgoal):\n 1. qInit MOD (qOp delta qinp qbinp) = qInit MOD (qOp delta qinp' qbinp')", "by simp"], ["proof (state)\nthis:\n  qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>qX'.\n     qOp delta qinp qbinp #= qX' \\<longrightarrow>\n     qInit MOD (qOp delta qinp qbinp) = qInit MOD qX'\n\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow> qInit MOD Y = qInit MOD qX';\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow>\n              qInit MOD Y = qInit MOD qX'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qA'.\n                            qAbs xs x X $= qA' \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X) = qInitAbs MOD qA'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow> qInit MOD Y = qInit MOD qX';\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow>\n              qInit MOD Y = qInit MOD qX'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qA'.\n                            qAbs xs x X $= qA' \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X) = qInitAbs MOD qA'", "case (Abs xs x qX)"], ["proof (state)\nthis:\n  qGood qX\n  qGood ?Y114 \\<and> qSkel ?Y114 = qSkel qX \\<Longrightarrow>\n  \\<forall>qX'.\n     ?Y114 #= qX' \\<longrightarrow> qInit MOD ?Y114 = qInit MOD qX'\n  (qX, ?Y114) \\<in> qSwapped \\<Longrightarrow>\n  \\<forall>qX'.\n     ?Y114 #= qX' \\<longrightarrow> qInit MOD ?Y114 = qInit MOD qX'\n\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       \\<lbrakk>qGood X;\n        \\<And>Y.\n           qGood Y \\<and> qSkel Y = qSkel X \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow> qInit MOD Y = qInit MOD qX';\n        \\<And>Y.\n           (X, Y) \\<in> qSwapped \\<Longrightarrow>\n           \\<forall>qX'.\n              Y #= qX' \\<longrightarrow>\n              qInit MOD Y = qInit MOD qX'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>qA'.\n                            qAbs xs x X $= qA' \\<longrightarrow>\n                            qInitAbs MOD (qAbs xs x X) = qInitAbs MOD qA'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qA'.\n       qAbs xs x qX $= qA' \\<longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "fix qA'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "assume \"qAbs xs x qX $= qA'\""], ["proof (state)\nthis:\n  qAbs xs x qX $= qA'\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "then"], ["proof (chain)\npicking this:\n  qAbs xs x qX $= qA'", "obtain x' y qX' where qA': \"qA' = qAbs xs x' qX'\"\n    and y_not: \"y \\<notin> {x, x'}\" and y_afresh: \"qAFresh xs y qX\"  \"qAFresh xs y qX'\"\n    and alpha: \"(qX #[[y \\<and> x]]_xs) #= (qX' #[[y \\<and> x']]_xs)\""], ["proof (prove)\nusing this:\n  qAbs xs x qX $= qA'\n\ngoal (1 subgoal):\n 1. (\\<And>x' qX' y.\n        \\<lbrakk>qA' = qAbs xs x' qX'; y \\<notin> {x, x'}; qAFresh xs y qX;\n         qAFresh xs y qX';\n         qX #[[y \\<and> x]]_xs #= qX' #[[y \\<and> x']]_xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using qAbs_alphaAbs_iff[of xs x qX qA']"], ["proof (prove)\nusing this:\n  qAbs xs x qX $= qA'\n  (qAbs xs x qX $= qA') =\n  (\\<exists>x' y X'.\n      qA' = qAbs xs x' X' \\<and>\n      y \\<notin> {x, x'} \\<and>\n      qAFresh xs y qX \\<and>\n      qAFresh xs y X' \\<and>\n      qX #[[y \\<and> x]]_xs #= X' #[[y \\<and> x']]_xs)\n\ngoal (1 subgoal):\n 1. (\\<And>x' qX' y.\n        \\<lbrakk>qA' = qAbs xs x' qX'; y \\<notin> {x, x'}; qAFresh xs y qX;\n         qAFresh xs y qX';\n         qX #[[y \\<and> x]]_xs #= qX' #[[y \\<and> x']]_xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  qA' = qAbs xs x' qX'\n  y \\<notin> {x, x'}\n  qAFresh xs y qX\n  qAFresh xs y qX'\n  qX #[[y \\<and> x]]_xs #= qX' #[[y \\<and> x']]_xs\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "hence y_fresh: \"qFresh xs y qX \\<and> qFresh xs y qX'\""], ["proof (prove)\nusing this:\n  qA' = qAbs xs x' qX'\n  y \\<notin> {x, x'}\n  qAFresh xs y qX\n  qAFresh xs y qX'\n  qX #[[y \\<and> x]]_xs #= qX' #[[y \\<and> x']]_xs\n\ngoal (1 subgoal):\n 1. qFresh xs y qX \\<and> qFresh xs y qX'", "using qAFresh_imp_qFresh"], ["proof (prove)\nusing this:\n  qA' = qAbs xs x' qX'\n  y \\<notin> {x, x'}\n  qAFresh xs y qX\n  qAFresh xs y qX'\n  qX #[[y \\<and> x]]_xs #= qX' #[[y \\<and> x']]_xs\n  qAFresh ?xs ?x ?X \\<Longrightarrow> qFresh ?xs ?x ?X\n\ngoal (1 subgoal):\n 1. qFresh xs y qX \\<and> qFresh xs y qX'", "by auto"], ["proof (state)\nthis:\n  qFresh xs y qX \\<and> qFresh xs y qX'\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "have qX': \"qGood qX'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qGood qX'", "using alpha Abs"], ["proof (prove)\nusing this:\n  qX #[[y \\<and> x]]_xs #= qX' #[[y \\<and> x']]_xs\n  qGood qX\n  qGood ?Y114 \\<and> qSkel ?Y114 = qSkel qX \\<Longrightarrow>\n  \\<forall>qX'.\n     ?Y114 #= qX' \\<longrightarrow> qInit MOD ?Y114 = qInit MOD qX'\n  (qX, ?Y114) \\<in> qSwapped \\<Longrightarrow>\n  \\<forall>qX'.\n     ?Y114 #= qX' \\<longrightarrow> qInit MOD ?Y114 = qInit MOD qX'\n\ngoal (1 subgoal):\n 1. qGood qX'", "by(simp add: alpha_qSwap_preserves_qGood1)"], ["proof (state)\nthis:\n  qGood qX'\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "have \"(qX, qX #[[y \\<and> x]]_xs) \\<in> qSwapped\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (qX, qX #[[y \\<and> x]]_xs) \\<in> qSwapped", "using qSwap_qSwapped"], ["proof (prove)\nusing this:\n  (?X, ?X #[[?x \\<and> ?y]]_?zs) \\<in> qSwapped\n\ngoal (1 subgoal):\n 1. (qX, qX #[[y \\<and> x]]_xs) \\<in> qSwapped", "by fastforce"], ["proof (state)\nthis:\n  (qX, qX #[[y \\<and> x]]_xs) \\<in> qSwapped\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "hence \"qInit MOD (qX #[[y \\<and> x]]_xs) = qInit MOD (qX' #[[y \\<and> x']]_xs)\""], ["proof (prove)\nusing this:\n  (qX, qX #[[y \\<and> x]]_xs) \\<in> qSwapped\n\ngoal (1 subgoal):\n 1. qInit MOD (qX #[[y \\<and> x]]_xs) = qInit MOD (qX' #[[y \\<and> x']]_xs)", "using Abs.IH alpha"], ["proof (prove)\nusing this:\n  (qX, qX #[[y \\<and> x]]_xs) \\<in> qSwapped\n  qGood ?Y114 \\<and> qSkel ?Y114 = qSkel qX \\<Longrightarrow>\n  \\<forall>qX'.\n     ?Y114 #= qX' \\<longrightarrow> qInit MOD ?Y114 = qInit MOD qX'\n  (qX, ?Y114) \\<in> qSwapped \\<Longrightarrow>\n  \\<forall>qX'.\n     ?Y114 #= qX' \\<longrightarrow> qInit MOD ?Y114 = qInit MOD qX'\n  qX #[[y \\<and> x]]_xs #= qX' #[[y \\<and> x']]_xs\n\ngoal (1 subgoal):\n 1. qInit MOD (qX #[[y \\<and> x]]_xs) = qInit MOD (qX' #[[y \\<and> x']]_xs)", "by simp"], ["proof (state)\nthis:\n  qInit MOD (qX #[[y \\<and> x]]_xs) = qInit MOD (qX' #[[y \\<and> x']]_xs)\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "moreover"], ["proof (state)\nthis:\n  qInit MOD (qX #[[y \\<and> x]]_xs) = qInit MOD (qX' #[[y \\<and> x']]_xs)\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "have \"qInit MOD (qX #[[y \\<and> x]]_xs) = igSubst MOD xs (igVar MOD xs y) x (qInit MOD qX)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qInit MOD (qX #[[y \\<and> x]]_xs) =\n    igSubst MOD xs (igVar MOD xs y) x (qInit MOD qX)", "using Abs y_afresh assms"], ["proof (prove)\nusing this:\n  qGood qX\n  qGood ?Y114 \\<and> qSkel ?Y114 = qSkel qX \\<Longrightarrow>\n  \\<forall>qX'.\n     ?Y114 #= qX' \\<longrightarrow> qInit MOD ?Y114 = qInit MOD qX'\n  (qX, ?Y114) \\<in> qSwapped \\<Longrightarrow>\n  \\<forall>qX'.\n     ?Y114 #= qX' \\<longrightarrow> qInit MOD ?Y114 = qInit MOD qX'\n  qAFresh xs y qX\n  qAFresh xs y qX'\n  iwlsFSbSwTR MOD\n\ngoal (1 subgoal):\n 1. qInit MOD (qX #[[y \\<and> x]]_xs) =\n    igSubst MOD xs (igVar MOD xs y) x (qInit MOD qX)", "by(simp add: iwlsFSbSwTR_qSwapAll_igSubstAll_qInitAll)"], ["proof (state)\nthis:\n  qInit MOD (qX #[[y \\<and> x]]_xs) =\n  igSubst MOD xs (igVar MOD xs y) x (qInit MOD qX)\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "moreover"], ["proof (state)\nthis:\n  qInit MOD (qX #[[y \\<and> x]]_xs) =\n  igSubst MOD xs (igVar MOD xs y) x (qInit MOD qX)\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "have \"qInit MOD (qX' #[[y \\<and> x']]_xs) = igSubst MOD xs (igVar MOD xs y) x' (qInit MOD qX')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qInit MOD (qX' #[[y \\<and> x']]_xs) =\n    igSubst MOD xs (igVar MOD xs y) x' (qInit MOD qX')", "using qX' y_afresh assms"], ["proof (prove)\nusing this:\n  qGood qX'\n  qAFresh xs y qX\n  qAFresh xs y qX'\n  iwlsFSbSwTR MOD\n\ngoal (1 subgoal):\n 1. qInit MOD (qX' #[[y \\<and> x']]_xs) =\n    igSubst MOD xs (igVar MOD xs y) x' (qInit MOD qX')", "by(simp add: iwlsFSbSwTR_qSwapAll_igSubstAll_qInitAll)"], ["proof (state)\nthis:\n  qInit MOD (qX' #[[y \\<and> x']]_xs) =\n  igSubst MOD xs (igVar MOD xs y) x' (qInit MOD qX')\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "ultimately"], ["proof (chain)\npicking this:\n  qInit MOD (qX #[[y \\<and> x]]_xs) = qInit MOD (qX' #[[y \\<and> x']]_xs)\n  qInit MOD (qX #[[y \\<and> x]]_xs) =\n  igSubst MOD xs (igVar MOD xs y) x (qInit MOD qX)\n  qInit MOD (qX' #[[y \\<and> x']]_xs) =\n  igSubst MOD xs (igVar MOD xs y) x' (qInit MOD qX')", "have \"igSubst MOD xs (igVar MOD xs y) x (qInit MOD qX) =\n        igSubst MOD xs (igVar MOD xs y) x' (qInit MOD qX')\""], ["proof (prove)\nusing this:\n  qInit MOD (qX #[[y \\<and> x]]_xs) = qInit MOD (qX' #[[y \\<and> x']]_xs)\n  qInit MOD (qX #[[y \\<and> x]]_xs) =\n  igSubst MOD xs (igVar MOD xs y) x (qInit MOD qX)\n  qInit MOD (qX' #[[y \\<and> x']]_xs) =\n  igSubst MOD xs (igVar MOD xs y) x' (qInit MOD qX')\n\ngoal (1 subgoal):\n 1. igSubst MOD xs (igVar MOD xs y) x (qInit MOD qX) =\n    igSubst MOD xs (igVar MOD xs y) x' (qInit MOD qX')", "by simp"], ["proof (state)\nthis:\n  igSubst MOD xs (igVar MOD xs y) x (qInit MOD qX) =\n  igSubst MOD xs (igVar MOD xs y) x' (qInit MOD qX')\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "moreover"], ["proof (state)\nthis:\n  igSubst MOD xs (igVar MOD xs y) x (qInit MOD qX) =\n  igSubst MOD xs (igVar MOD xs y) x' (qInit MOD qX')\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "have \"igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')", "using y_fresh assms"], ["proof (prove)\nusing this:\n  qFresh xs y qX \\<and> qFresh xs y qX'\n  iwlsFSbSwTR MOD\n\ngoal (1 subgoal):\n 1. igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')", "by(auto simp add: iwlsFSbSwTR_qFreshAll_igFreshAll_qInitAll)"], ["proof (state)\nthis:\n  igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "moreover"], ["proof (state)\nthis:\n  igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "have \"igAbsCongUSTR MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbsCongUSTR MOD", "using assms"], ["proof (prove)\nusing this:\n  iwlsFSbSwTR MOD\n\ngoal (1 subgoal):\n 1. igAbsCongUSTR MOD", "unfolding iwlsFSbSwTR_def"], ["proof (prove)\nusing this:\n  igWlsAllDisj MOD \\<and>\n  igWlsAbsIsInBar MOD \\<and>\n  igConsIPresIGWlsSTR MOD \\<and>\n  igSubstAllIPresIGWlsAllSTR MOD \\<and>\n  igFreshClsSTR MOD \\<and> igSubstClsSTR MOD \\<and> igAbsRenSTR MOD\n\ngoal (1 subgoal):\n 1. igAbsCongUSTR MOD", "using igAbsRenSTR_imp_igAbsCongUSTR"], ["proof (prove)\nusing this:\n  igWlsAllDisj MOD \\<and>\n  igWlsAbsIsInBar MOD \\<and>\n  igConsIPresIGWlsSTR MOD \\<and>\n  igSubstAllIPresIGWlsAllSTR MOD \\<and>\n  igFreshClsSTR MOD \\<and> igSubstClsSTR MOD \\<and> igAbsRenSTR MOD\n  igAbsRenSTR ?MOD \\<Longrightarrow> igAbsCongUSTR ?MOD\n\ngoal (1 subgoal):\n 1. igAbsCongUSTR MOD", "by auto"], ["proof (state)\nthis:\n  igAbsCongUSTR MOD\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "ultimately"], ["proof (chain)\npicking this:\n  igSubst MOD xs (igVar MOD xs y) x (qInit MOD qX) =\n  igSubst MOD xs (igVar MOD xs y) x' (qInit MOD qX')\n  igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')\n  igAbsCongUSTR MOD", "have \"igAbs MOD xs x (qInit MOD qX) = igAbs MOD xs x' (qInit MOD qX')\""], ["proof (prove)\nusing this:\n  igSubst MOD xs (igVar MOD xs y) x (qInit MOD qX) =\n  igSubst MOD xs (igVar MOD xs y) x' (qInit MOD qX')\n  igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')\n  igAbsCongUSTR MOD\n\ngoal (1 subgoal):\n 1. igAbs MOD xs x (qInit MOD qX) = igAbs MOD xs x' (qInit MOD qX')", "using y_not"], ["proof (prove)\nusing this:\n  igSubst MOD xs (igVar MOD xs y) x (qInit MOD qX) =\n  igSubst MOD xs (igVar MOD xs y) x' (qInit MOD qX')\n  igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')\n  igAbsCongUSTR MOD\n  y \\<notin> {x, x'}\n\ngoal (1 subgoal):\n 1. igAbs MOD xs x (qInit MOD qX) = igAbs MOD xs x' (qInit MOD qX')", "unfolding igAbsCongUSTR_def"], ["proof (prove)\nusing this:\n  igSubst MOD xs (igVar MOD xs y) x (qInit MOD qX) =\n  igSubst MOD xs (igVar MOD xs y) x' (qInit MOD qX')\n  igFresh MOD xs y (qInit MOD qX) \\<and> igFresh MOD xs y (qInit MOD qX')\n  \\<forall>xs x x' y X X'.\n     igFresh MOD xs y X \\<and>\n     igFresh MOD xs y X' \\<and>\n     igSubst MOD xs (igVar MOD xs y) x X =\n     igSubst MOD xs (igVar MOD xs y) x' X' \\<longrightarrow>\n     igAbs MOD xs x X = igAbs MOD xs x' X'\n  y \\<notin> {x, x'}\n\ngoal (1 subgoal):\n 1. igAbs MOD xs x (qInit MOD qX) = igAbs MOD xs x' (qInit MOD qX')", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>igSubst MOD xs (igVar MOD xs y) x (qInit MOD qX) =\n             igSubst MOD xs (igVar MOD xs y) x' (qInit MOD qX');\n     \\<forall>xs x x' y X X'.\n        igFresh MOD xs y X \\<and>\n        igFresh MOD xs y X' \\<and>\n        igSubst MOD xs (igVar MOD xs y) x X =\n        igSubst MOD xs (igVar MOD xs y) x' X' \\<longrightarrow>\n        igAbs MOD xs x X = igAbs MOD xs x' X';\n     igAbs MOD xs x (qInit MOD qX) \\<noteq> igAbs MOD xs x' (qInit MOD qX');\n     y \\<noteq> x; y \\<notin> {}; igFresh MOD xs y (qInit MOD qX);\n     igFresh MOD xs y (qInit MOD qX')\\<rbrakk>\n    \\<Longrightarrow> y = x'", "by (erule allE[of _ xs], erule allE[of _ x]) blast"], ["proof (state)\nthis:\n  igAbs MOD xs x (qInit MOD qX) = igAbs MOD xs x' (qInit MOD qX')\n\ngoal (1 subgoal):\n 1. \\<And>qA'.\n       qAbs xs x qX $= qA' \\<Longrightarrow>\n       qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "thus \"qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'\""], ["proof (prove)\nusing this:\n  igAbs MOD xs x (qInit MOD qX) = igAbs MOD xs x' (qInit MOD qX')\n\ngoal (1 subgoal):\n 1. qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'", "unfolding qA'"], ["proof (prove)\nusing this:\n  igAbs MOD xs x (qInit MOD qX) = igAbs MOD xs x' (qInit MOD qX')\n\ngoal (1 subgoal):\n 1. qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD (qAbs xs x' qX')", "by simp"], ["proof (state)\nthis:\n  qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>qA'.\n     qAbs xs x qX $= qA' \\<longrightarrow>\n     qInitAbs MOD (qAbs xs x qX) = qInitAbs MOD qA'\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary iwlsFSbSwTR_qInit_respectsP_alphaGood:\nassumes \"iwlsFSbSwTR MOD\"\nshows \"(qInit MOD) respectsP alphaGood\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qInit MOD respectsP alphaGood", "unfolding congruentP_def alphaGood_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       qGood x \\<and> qGood y \\<and> x #= y \\<longrightarrow>\n       qInit MOD x = qInit MOD y", "using assms iwlsFSbSwTR_alphaAll_qInitAll"], ["proof (prove)\nusing this:\n  iwlsFSbSwTR MOD\n  iwlsFSbSwTR ?MOD \\<Longrightarrow>\n  (qGood ?qX \\<longrightarrow>\n   (\\<forall>qX'.\n       ?qX #= qX' \\<longrightarrow> qInit ?MOD ?qX = qInit ?MOD qX')) \\<and>\n  (qGoodAbs ?qA \\<longrightarrow>\n   (\\<forall>qA'.\n       ?qA $= qA' \\<longrightarrow> qInitAbs ?MOD ?qA = qInitAbs ?MOD qA'))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       qGood x \\<and> qGood y \\<and> x #= y \\<longrightarrow>\n       qInit MOD x = qInit MOD y", "by fastforce"], ["", "corollary iwlsFSbSwTR_qInitAbs_respectsP_alphaAbsGood:\nassumes \"iwlsFSbSwTR MOD\"\nshows \"(qInitAbs MOD) respectsP alphaAbsGood\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qInitAbs MOD respectsP alphaAbsGood", "unfolding congruentP_def alphaAbsGood_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       qGoodAbs x \\<and> qGoodAbs y \\<and> x $= y \\<longrightarrow>\n       qInitAbs MOD x = qInitAbs MOD y", "using assms iwlsFSbSwTR_alphaAll_qInitAll"], ["proof (prove)\nusing this:\n  iwlsFSbSwTR MOD\n  iwlsFSbSwTR ?MOD \\<Longrightarrow>\n  (qGood ?qX \\<longrightarrow>\n   (\\<forall>qX'.\n       ?qX #= qX' \\<longrightarrow> qInit ?MOD ?qX = qInit ?MOD qX')) \\<and>\n  (qGoodAbs ?qA \\<longrightarrow>\n   (\\<forall>qA'.\n       ?qA $= qA' \\<longrightarrow> qInitAbs ?MOD ?qA = qInitAbs ?MOD qA'))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       qGoodAbs x \\<and> qGoodAbs y \\<and> x $= y \\<longrightarrow>\n       qInitAbs MOD x = qInitAbs MOD y", "by auto"], ["", "subsubsection \\<open>The initial morphism (iteration map) from the term model to any strong model\\<close>"], ["", "text \\<open>This morphism has the same definition for fresh-swap and fresh-subst strong models\\<close>"], ["", "definition iterSTR where\n\"iterSTR MOD == univ (qInit MOD)\""], ["", "definition iterAbsSTR where\n\"iterAbsSTR MOD == univ (qInitAbs MOD)\""], ["", "lemma iwlsFSwSTR_iterSTR_ipresVar:\nassumes \"iwlsFSwSTR MOD\"\nshows \"ipresVar (iterSTR MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresVar (iterSTR MOD) MOD", "using assms"], ["proof (prove)\nusing this:\n  iwlsFSwSTR MOD\n\ngoal (1 subgoal):\n 1. ipresVar (iterSTR MOD) MOD", "by(simp add: ipresVar_def Var_def iterSTR_def iwlsFSwSTR_qInit_respectsP_alpha)"], ["", "lemma iwlsFSbSwTR_iterSTR_ipresVar:\nassumes \"iwlsFSbSwTR MOD\"\nshows \"ipresVar (iterSTR MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresVar (iterSTR MOD) MOD", "using assms"], ["proof (prove)\nusing this:\n  iwlsFSbSwTR MOD\n\ngoal (1 subgoal):\n 1. ipresVar (iterSTR MOD) MOD", "by (simp add: ipresVar_def Var_def iterSTR_def iwlsFSbSwTR_qInit_respectsP_alphaGood)"], ["", "lemma iwlsFSwSTR_iterSTR_ipresAbs:\nassumes \"iwlsFSwSTR MOD\"\nshows \"ipresAbs (iterSTR MOD) (iterAbsSTR MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresAbs (iterSTR MOD) (iterAbsSTR MOD) MOD", "unfolding ipresAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs x s X.\n       isInBar (xs, s) \\<and> wls s X \\<longrightarrow>\n       iterAbsSTR MOD (Abs xs x X) = igAbs MOD xs x (iterSTR MOD X)", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "fix xs x s X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "assume X: \"wls s X\""], ["proof (state)\nthis:\n  wls s X\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "hence \"qGood (pick X)\""], ["proof (prove)\nusing this:\n  wls s X\n\ngoal (1 subgoal):\n 1. qGood (pick X)", "by(simp add: good_imp_qGood_pick)"], ["proof (state)\nthis:\n  qGood (pick X)\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "hence 1: \"qGoodAbs (qAbs xs x (pick X))\""], ["proof (prove)\nusing this:\n  qGood (pick X)\n\ngoal (1 subgoal):\n 1. qGoodAbs (qAbs xs x (pick X))", "by simp"], ["proof (state)\nthis:\n  qGoodAbs (qAbs xs x (pick X))\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "have \"iterAbsSTR MOD (Abs xs x X) = univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterAbsSTR MOD (Abs xs x X) =\n    Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X)))", "using X"], ["proof (prove)\nusing this:\n  wls s X\n\ngoal (1 subgoal):\n 1. iterAbsSTR MOD (Abs xs x X) =\n    Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X)))", "unfolding Abs_def iterAbsSTR_def"], ["proof (prove)\nusing this:\n  wls s X\n\ngoal (1 subgoal):\n 1. Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X))) =\n    Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X)))", "by simp"], ["proof (state)\nthis:\n  iterAbsSTR MOD (Abs xs x X) =\n  Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X)))\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "also"], ["proof (state)\nthis:\n  iterAbsSTR MOD (Abs xs x X) =\n  Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X)))\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "have \"\\<dots> = qInitAbs MOD (qAbs xs x (pick X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X))) =\n    qInitAbs MOD (qAbs xs x (pick X))", "using assms 1"], ["proof (prove)\nusing this:\n  iwlsFSwSTR MOD\n  qGoodAbs (qAbs xs x (pick X))\n\ngoal (1 subgoal):\n 1. Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X))) =\n    qInitAbs MOD (qAbs xs x (pick X))", "by(simp add: iwlsFSwSTR_qInitAbs_respectsP_alphaAbs)"], ["proof (state)\nthis:\n  Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X))) =\n  qInitAbs MOD (qAbs xs x (pick X))\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "also"], ["proof (state)\nthis:\n  Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X))) =\n  qInitAbs MOD (qAbs xs x (pick X))\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "have \"\\<dots> = igAbs MOD xs x (qInit MOD (pick X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qInitAbs MOD (qAbs xs x (pick X)) = igAbs MOD xs x (qInit MOD (pick X))", "by simp"], ["proof (state)\nthis:\n  qInitAbs MOD (qAbs xs x (pick X)) = igAbs MOD xs x (qInit MOD (pick X))\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "also"], ["proof (state)\nthis:\n  qInitAbs MOD (qAbs xs x (pick X)) = igAbs MOD xs x (qInit MOD (pick X))\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "have \"\\<dots> = igAbs MOD xs x (iterSTR MOD X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs MOD xs x (qInit MOD (pick X)) = igAbs MOD xs x (iterSTR MOD X)", "unfolding iterSTR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs MOD xs x (qInit MOD (pick X)) =\n    igAbs MOD xs x (Equiv_Relation2.univ (qInit MOD) X)", "unfolding univ_def pick_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs MOD xs x (qInit MOD (SOME x. x \\<in> X)) =\n    igAbs MOD xs x (qInit MOD (SOME x. x \\<in> X))", ".."], ["proof (state)\nthis:\n  igAbs MOD xs x (qInit MOD (pick X)) = igAbs MOD xs x (iterSTR MOD X)\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "finally"], ["proof (chain)\npicking this:\n  iterAbsSTR MOD (Abs xs x X) = igAbs MOD xs x (iterSTR MOD X)", "show \"iterAbsSTR MOD (Abs xs x X) = igAbs MOD xs x (iterSTR MOD X)\""], ["proof (prove)\nusing this:\n  iterAbsSTR MOD (Abs xs x X) = igAbs MOD xs x (iterSTR MOD X)\n\ngoal (1 subgoal):\n 1. iterAbsSTR MOD (Abs xs x X) = igAbs MOD xs x (iterSTR MOD X)", "."], ["proof (state)\nthis:\n  iterAbsSTR MOD (Abs xs x X) = igAbs MOD xs x (iterSTR MOD X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iwlsFSbSwTR_iterSTR_ipresAbs:\nassumes \"iwlsFSbSwTR MOD\"\nshows \"ipresAbs (iterSTR MOD) (iterAbsSTR MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresAbs (iterSTR MOD) (iterAbsSTR MOD) MOD", "unfolding ipresAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs x s X.\n       isInBar (xs, s) \\<and> wls s X \\<longrightarrow>\n       iterAbsSTR MOD (Abs xs x X) = igAbs MOD xs x (iterSTR MOD X)", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "fix xs x s X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "assume X: \"wls s X\""], ["proof (state)\nthis:\n  wls s X\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "hence \"qGood (pick X)\""], ["proof (prove)\nusing this:\n  wls s X\n\ngoal (1 subgoal):\n 1. qGood (pick X)", "by(simp add: good_imp_qGood_pick)"], ["proof (state)\nthis:\n  qGood (pick X)\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "hence 1: \"qGoodAbs (qAbs xs x (pick X))\""], ["proof (prove)\nusing this:\n  qGood (pick X)\n\ngoal (1 subgoal):\n 1. qGoodAbs (qAbs xs x (pick X))", "by simp"], ["proof (state)\nthis:\n  qGoodAbs (qAbs xs x (pick X))\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "have \"iterAbsSTR MOD (Abs xs x X) = univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterAbsSTR MOD (Abs xs x X) =\n    Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X)))", "using X"], ["proof (prove)\nusing this:\n  wls s X\n\ngoal (1 subgoal):\n 1. iterAbsSTR MOD (Abs xs x X) =\n    Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X)))", "unfolding Abs_def iterAbsSTR_def"], ["proof (prove)\nusing this:\n  wls s X\n\ngoal (1 subgoal):\n 1. Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X))) =\n    Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X)))", "by simp"], ["proof (state)\nthis:\n  iterAbsSTR MOD (Abs xs x X) =\n  Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X)))\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "also"], ["proof (state)\nthis:\n  iterAbsSTR MOD (Abs xs x X) =\n  Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X)))\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "have \"\\<dots> = qInitAbs MOD (qAbs xs x (pick X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X))) =\n    qInitAbs MOD (qAbs xs x (pick X))", "using assms 1"], ["proof (prove)\nusing this:\n  iwlsFSbSwTR MOD\n  qGoodAbs (qAbs xs x (pick X))\n\ngoal (1 subgoal):\n 1. Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X))) =\n    qInitAbs MOD (qAbs xs x (pick X))", "by(simp add: iwlsFSbSwTR_qInitAbs_respectsP_alphaAbsGood)"], ["proof (state)\nthis:\n  Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X))) =\n  qInitAbs MOD (qAbs xs x (pick X))\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "also"], ["proof (state)\nthis:\n  Equiv_Relation2.univ (qInitAbs MOD) (asAbs (qAbs xs x (pick X))) =\n  qInitAbs MOD (qAbs xs x (pick X))\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "have \"\\<dots> = igAbs MOD xs x (qInit MOD (pick X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qInitAbs MOD (qAbs xs x (pick X)) = igAbs MOD xs x (qInit MOD (pick X))", "by simp"], ["proof (state)\nthis:\n  qInitAbs MOD (qAbs xs x (pick X)) = igAbs MOD xs x (qInit MOD (pick X))\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "also"], ["proof (state)\nthis:\n  qInitAbs MOD (qAbs xs x (pick X)) = igAbs MOD xs x (qInit MOD (pick X))\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "have \"\\<dots> = igAbs MOD xs x (iterSTR MOD X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs MOD xs x (qInit MOD (pick X)) = igAbs MOD xs x (iterSTR MOD X)", "unfolding iterSTR_def univ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs MOD xs x (qInit MOD (pick X)) =\n    igAbs MOD xs x (qInit MOD (SOME x. x \\<in> X))", "unfolding univ_def pick_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs MOD xs x (qInit MOD (SOME x. x \\<in> X)) =\n    igAbs MOD xs x (qInit MOD (SOME x. x \\<in> X))", ".."], ["proof (state)\nthis:\n  igAbs MOD xs x (qInit MOD (pick X)) = igAbs MOD xs x (iterSTR MOD X)\n\ngoal (1 subgoal):\n 1. \\<And>xs x s X.\n       \\<lbrakk>isInBar (xs, s); wls s X\\<rbrakk>\n       \\<Longrightarrow> iterAbsSTR MOD (Abs xs x X) =\n                         igAbs MOD xs x (iterSTR MOD X)", "finally"], ["proof (chain)\npicking this:\n  iterAbsSTR MOD (Abs xs x X) = igAbs MOD xs x (iterSTR MOD X)", "show \"iterAbsSTR MOD (Abs xs x X) = igAbs MOD xs x (iterSTR MOD X)\""], ["proof (prove)\nusing this:\n  iterAbsSTR MOD (Abs xs x X) = igAbs MOD xs x (iterSTR MOD X)\n\ngoal (1 subgoal):\n 1. iterAbsSTR MOD (Abs xs x X) = igAbs MOD xs x (iterSTR MOD X)", "."], ["proof (state)\nthis:\n  iterAbsSTR MOD (Abs xs x X) = igAbs MOD xs x (iterSTR MOD X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iwlsFSwSTR_iterSTR_ipresOp:\nassumes \"iwlsFSwSTR MOD\"\nshows \"ipresOp (iterSTR MOD) (iterAbsSTR MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresOp (iterSTR MOD) (iterAbsSTR MOD) MOD", "unfolding ipresOp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>delta inp binp.\n       wlsInp delta inp \\<and> wlsBinp delta binp \\<longrightarrow>\n       iterSTR MOD (Op delta inp binp) =\n       igOp MOD delta (lift (iterSTR MOD) inp) (lift (iterAbsSTR MOD) binp)", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "fix delta inp binp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "assume inp: \"wlsInp delta inp\"  \"wlsBinp delta binp\""], ["proof (state)\nthis:\n  wlsInp delta inp\n  wlsBinp delta binp\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "hence \"qGoodInp (pickInp inp) \\<and> qGoodBinp (pickBinp binp)\""], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n\ngoal (1 subgoal):\n 1. qGoodInp (pickInp inp) \\<and> qGoodBinp (pickBinp binp)", "by(simp add: goodInp_imp_qGoodInp_pickInp goodBinp_imp_qGoodBinp_pickBinp)"], ["proof (state)\nthis:\n  qGoodInp (pickInp inp) \\<and> qGoodBinp (pickBinp binp)\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "hence 1: \"qGood (qOp delta (pickInp inp) (pickBinp binp))\""], ["proof (prove)\nusing this:\n  qGoodInp (pickInp inp) \\<and> qGoodBinp (pickBinp binp)\n\ngoal (1 subgoal):\n 1. qGood (qOp delta (pickInp inp) (pickBinp binp))", "by simp"], ["proof (state)\nthis:\n  qGood (qOp delta (pickInp inp) (pickBinp binp))\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "have \"iterSTR MOD (Op delta inp binp) =\n         univ (qInit MOD) (asTerm (qOp delta (pickInp inp) (pickBinp binp)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterSTR MOD (Op delta inp binp) =\n    Equiv_Relation2.univ (qInit MOD)\n     (asTerm (qOp delta (pickInp inp) (pickBinp binp)))", "using inp"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n\ngoal (1 subgoal):\n 1. iterSTR MOD (Op delta inp binp) =\n    Equiv_Relation2.univ (qInit MOD)\n     (asTerm (qOp delta (pickInp inp) (pickBinp binp)))", "unfolding Op_def iterSTR_def"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n\ngoal (1 subgoal):\n 1. Equiv_Relation2.univ (qInit MOD)\n     (asTerm (qOp delta (pickInp inp) (pickBinp binp))) =\n    Equiv_Relation2.univ (qInit MOD)\n     (asTerm (qOp delta (pickInp inp) (pickBinp binp)))", "by simp"], ["proof (state)\nthis:\n  iterSTR MOD (Op delta inp binp) =\n  Equiv_Relation2.univ (qInit MOD)\n   (asTerm (qOp delta (pickInp inp) (pickBinp binp)))\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "moreover"], ["proof (state)\nthis:\n  iterSTR MOD (Op delta inp binp) =\n  Equiv_Relation2.univ (qInit MOD)\n   (asTerm (qOp delta (pickInp inp) (pickBinp binp)))\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "have \"\\<dots> = qInit MOD (qOp delta (pickInp inp) (pickBinp binp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Equiv_Relation2.univ (qInit MOD)\n     (asTerm (qOp delta (pickInp inp) (pickBinp binp))) =\n    qInit MOD (qOp delta (pickInp inp) (pickBinp binp))", "using assms 1"], ["proof (prove)\nusing this:\n  iwlsFSwSTR MOD\n  qGood (qOp delta (pickInp inp) (pickBinp binp))\n\ngoal (1 subgoal):\n 1. Equiv_Relation2.univ (qInit MOD)\n     (asTerm (qOp delta (pickInp inp) (pickBinp binp))) =\n    qInit MOD (qOp delta (pickInp inp) (pickBinp binp))", "by(simp add: iwlsFSwSTR_qInit_respectsP_alpha)"], ["proof (state)\nthis:\n  Equiv_Relation2.univ (qInit MOD)\n   (asTerm (qOp delta (pickInp inp) (pickBinp binp))) =\n  qInit MOD (qOp delta (pickInp inp) (pickBinp binp))\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "moreover"], ["proof (state)\nthis:\n  Equiv_Relation2.univ (qInit MOD)\n   (asTerm (qOp delta (pickInp inp) (pickBinp binp))) =\n  qInit MOD (qOp delta (pickInp inp) (pickBinp binp))\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "have \"\\<dots> = igOp MOD delta (lift (qInit MOD) (pickInp inp))\n                               (lift (qInitAbs MOD) (pickBinp binp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qInit MOD (qOp delta (pickInp inp) (pickBinp binp)) =\n    igOp MOD delta (lift (qInit MOD) (pickInp inp))\n     (lift (qInitAbs MOD) (pickBinp binp))", "by auto"], ["proof (state)\nthis:\n  qInit MOD (qOp delta (pickInp inp) (pickBinp binp)) =\n  igOp MOD delta (lift (qInit MOD) (pickInp inp))\n   (lift (qInitAbs MOD) (pickBinp binp))\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "moreover"], ["proof (state)\nthis:\n  qInit MOD (qOp delta (pickInp inp) (pickBinp binp)) =\n  igOp MOD delta (lift (qInit MOD) (pickInp inp))\n   (lift (qInitAbs MOD) (pickBinp binp))\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "have \"lift (qInit MOD) (pickInp inp) = lift (iterSTR MOD) inp \\<and>\n        lift (qInitAbs MOD) (pickBinp binp) = lift (iterAbsSTR MOD) binp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (qInit MOD) (pickInp inp) = lift (iterSTR MOD) inp \\<and>\n    lift (qInitAbs MOD) (pickBinp binp) = lift (iterAbsSTR MOD) binp", "unfolding pickInp_def pickBinp_def iterSTR_def iterAbsSTR_def\n            lift_comp univ_def[abs_def] comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (\\<lambda>x. qInit MOD (pick x)) inp =\n    lift (\\<lambda>X. qInit MOD (SOME x. x \\<in> X)) inp \\<and>\n    lift (\\<lambda>x. qInitAbs MOD (pick x)) binp =\n    lift (\\<lambda>X. qInitAbs MOD (SOME x. x \\<in> X)) binp", "unfolding univ_def pick_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (\\<lambda>x. qInit MOD (SOME xa. xa \\<in> x)) inp =\n    lift (\\<lambda>X. qInit MOD (SOME x. x \\<in> X)) inp \\<and>\n    lift (\\<lambda>x. qInitAbs MOD (SOME xa. xa \\<in> x)) binp =\n    lift (\\<lambda>X. qInitAbs MOD (SOME x. x \\<in> X)) binp", "by simp"], ["proof (state)\nthis:\n  lift (qInit MOD) (pickInp inp) = lift (iterSTR MOD) inp \\<and>\n  lift (qInitAbs MOD) (pickBinp binp) = lift (iterAbsSTR MOD) binp\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "ultimately"], ["proof (chain)\npicking this:\n  iterSTR MOD (Op delta inp binp) =\n  Equiv_Relation2.univ (qInit MOD)\n   (asTerm (qOp delta (pickInp inp) (pickBinp binp)))\n  Equiv_Relation2.univ (qInit MOD)\n   (asTerm (qOp delta (pickInp inp) (pickBinp binp))) =\n  qInit MOD (qOp delta (pickInp inp) (pickBinp binp))\n  qInit MOD (qOp delta (pickInp inp) (pickBinp binp)) =\n  igOp MOD delta (lift (qInit MOD) (pickInp inp))\n   (lift (qInitAbs MOD) (pickBinp binp))\n  lift (qInit MOD) (pickInp inp) = lift (iterSTR MOD) inp \\<and>\n  lift (qInitAbs MOD) (pickBinp binp) = lift (iterAbsSTR MOD) binp", "show \"iterSTR MOD (Op delta inp binp) =\n        igOp MOD delta (lift (iterSTR MOD) inp) (lift (iterAbsSTR MOD) binp)\""], ["proof (prove)\nusing this:\n  iterSTR MOD (Op delta inp binp) =\n  Equiv_Relation2.univ (qInit MOD)\n   (asTerm (qOp delta (pickInp inp) (pickBinp binp)))\n  Equiv_Relation2.univ (qInit MOD)\n   (asTerm (qOp delta (pickInp inp) (pickBinp binp))) =\n  qInit MOD (qOp delta (pickInp inp) (pickBinp binp))\n  qInit MOD (qOp delta (pickInp inp) (pickBinp binp)) =\n  igOp MOD delta (lift (qInit MOD) (pickInp inp))\n   (lift (qInitAbs MOD) (pickBinp binp))\n  lift (qInit MOD) (pickInp inp) = lift (iterSTR MOD) inp \\<and>\n  lift (qInitAbs MOD) (pickBinp binp) = lift (iterAbsSTR MOD) binp\n\ngoal (1 subgoal):\n 1. iterSTR MOD (Op delta inp binp) =\n    igOp MOD delta (lift (iterSTR MOD) inp) (lift (iterAbsSTR MOD) binp)", "by simp"], ["proof (state)\nthis:\n  iterSTR MOD (Op delta inp binp) =\n  igOp MOD delta (lift (iterSTR MOD) inp) (lift (iterAbsSTR MOD) binp)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iwlsFSbSwTR_iterSTR_ipresOp:\nassumes \"iwlsFSbSwTR MOD\"\nshows \"ipresOp (iterSTR MOD) (iterAbsSTR MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresOp (iterSTR MOD) (iterAbsSTR MOD) MOD", "unfolding ipresOp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>delta inp binp.\n       wlsInp delta inp \\<and> wlsBinp delta binp \\<longrightarrow>\n       iterSTR MOD (Op delta inp binp) =\n       igOp MOD delta (lift (iterSTR MOD) inp) (lift (iterAbsSTR MOD) binp)", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "fix delta inp binp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "assume inp: \"wlsInp delta inp\"  \"wlsBinp delta binp\""], ["proof (state)\nthis:\n  wlsInp delta inp\n  wlsBinp delta binp\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "hence \"qGoodInp (pickInp inp) \\<and> qGoodBinp (pickBinp binp)\""], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n\ngoal (1 subgoal):\n 1. qGoodInp (pickInp inp) \\<and> qGoodBinp (pickBinp binp)", "by(simp add: goodInp_imp_qGoodInp_pickInp goodBinp_imp_qGoodBinp_pickBinp)"], ["proof (state)\nthis:\n  qGoodInp (pickInp inp) \\<and> qGoodBinp (pickBinp binp)\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "hence 1: \"qGood (qOp delta (pickInp inp) (pickBinp binp))\""], ["proof (prove)\nusing this:\n  qGoodInp (pickInp inp) \\<and> qGoodBinp (pickBinp binp)\n\ngoal (1 subgoal):\n 1. qGood (qOp delta (pickInp inp) (pickBinp binp))", "by simp"], ["proof (state)\nthis:\n  qGood (qOp delta (pickInp inp) (pickBinp binp))\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "have \"iterSTR MOD (Op delta inp binp) =\n         univ (qInit MOD) (asTerm (qOp delta (pickInp inp) (pickBinp binp)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterSTR MOD (Op delta inp binp) =\n    Equiv_Relation2.univ (qInit MOD)\n     (asTerm (qOp delta (pickInp inp) (pickBinp binp)))", "using inp"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n\ngoal (1 subgoal):\n 1. iterSTR MOD (Op delta inp binp) =\n    Equiv_Relation2.univ (qInit MOD)\n     (asTerm (qOp delta (pickInp inp) (pickBinp binp)))", "unfolding Op_def iterSTR_def"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n\ngoal (1 subgoal):\n 1. Equiv_Relation2.univ (qInit MOD)\n     (asTerm (qOp delta (pickInp inp) (pickBinp binp))) =\n    Equiv_Relation2.univ (qInit MOD)\n     (asTerm (qOp delta (pickInp inp) (pickBinp binp)))", "by simp"], ["proof (state)\nthis:\n  iterSTR MOD (Op delta inp binp) =\n  Equiv_Relation2.univ (qInit MOD)\n   (asTerm (qOp delta (pickInp inp) (pickBinp binp)))\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "moreover"], ["proof (state)\nthis:\n  iterSTR MOD (Op delta inp binp) =\n  Equiv_Relation2.univ (qInit MOD)\n   (asTerm (qOp delta (pickInp inp) (pickBinp binp)))\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "have \"\\<dots> = qInit MOD (qOp delta (pickInp inp) (pickBinp binp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Equiv_Relation2.univ (qInit MOD)\n     (asTerm (qOp delta (pickInp inp) (pickBinp binp))) =\n    qInit MOD (qOp delta (pickInp inp) (pickBinp binp))", "using assms 1"], ["proof (prove)\nusing this:\n  iwlsFSbSwTR MOD\n  qGood (qOp delta (pickInp inp) (pickBinp binp))\n\ngoal (1 subgoal):\n 1. Equiv_Relation2.univ (qInit MOD)\n     (asTerm (qOp delta (pickInp inp) (pickBinp binp))) =\n    qInit MOD (qOp delta (pickInp inp) (pickBinp binp))", "by(simp add: iwlsFSbSwTR_qInit_respectsP_alphaGood)"], ["proof (state)\nthis:\n  Equiv_Relation2.univ (qInit MOD)\n   (asTerm (qOp delta (pickInp inp) (pickBinp binp))) =\n  qInit MOD (qOp delta (pickInp inp) (pickBinp binp))\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "moreover"], ["proof (state)\nthis:\n  Equiv_Relation2.univ (qInit MOD)\n   (asTerm (qOp delta (pickInp inp) (pickBinp binp))) =\n  qInit MOD (qOp delta (pickInp inp) (pickBinp binp))\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "have \"\\<dots> = igOp MOD delta (lift (qInit MOD) (pickInp inp))\n                                   (lift (qInitAbs MOD) (pickBinp binp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qInit MOD (qOp delta (pickInp inp) (pickBinp binp)) =\n    igOp MOD delta (lift (qInit MOD) (pickInp inp))\n     (lift (qInitAbs MOD) (pickBinp binp))", "by simp"], ["proof (state)\nthis:\n  qInit MOD (qOp delta (pickInp inp) (pickBinp binp)) =\n  igOp MOD delta (lift (qInit MOD) (pickInp inp))\n   (lift (qInitAbs MOD) (pickBinp binp))\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "moreover"], ["proof (state)\nthis:\n  qInit MOD (qOp delta (pickInp inp) (pickBinp binp)) =\n  igOp MOD delta (lift (qInit MOD) (pickInp inp))\n   (lift (qInitAbs MOD) (pickBinp binp))\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "have \"lift (qInit MOD) (pickInp inp) = lift (iterSTR MOD) inp \\<and>\n                 lift (qInitAbs MOD) (pickBinp binp) = lift (iterAbsSTR MOD) binp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (qInit MOD) (pickInp inp) = lift (iterSTR MOD) inp \\<and>\n    lift (qInitAbs MOD) (pickBinp binp) = lift (iterAbsSTR MOD) binp", "unfolding pickInp_def pickBinp_def iterSTR_def iterAbsSTR_def\n            lift_comp univ_def[abs_def] comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (\\<lambda>x. qInit MOD (pick x)) inp =\n    lift (\\<lambda>X. qInit MOD (SOME x. x \\<in> X)) inp \\<and>\n    lift (\\<lambda>x. qInitAbs MOD (pick x)) binp =\n    lift (\\<lambda>X. qInitAbs MOD (SOME x. x \\<in> X)) binp", "unfolding univ_def pick_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (\\<lambda>x. qInit MOD (SOME xa. xa \\<in> x)) inp =\n    lift (\\<lambda>X. qInit MOD (SOME x. x \\<in> X)) inp \\<and>\n    lift (\\<lambda>x. qInitAbs MOD (SOME xa. xa \\<in> x)) binp =\n    lift (\\<lambda>X. qInitAbs MOD (SOME x. x \\<in> X)) binp", "by simp"], ["proof (state)\nthis:\n  lift (qInit MOD) (pickInp inp) = lift (iterSTR MOD) inp \\<and>\n  lift (qInitAbs MOD) (pickBinp binp) = lift (iterAbsSTR MOD) binp\n\ngoal (1 subgoal):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp\\<rbrakk>\n       \\<Longrightarrow> iterSTR MOD (Op delta inp binp) =\n                         igOp MOD delta (lift (iterSTR MOD) inp)\n                          (lift (iterAbsSTR MOD) binp)", "ultimately"], ["proof (chain)\npicking this:\n  iterSTR MOD (Op delta inp binp) =\n  Equiv_Relation2.univ (qInit MOD)\n   (asTerm (qOp delta (pickInp inp) (pickBinp binp)))\n  Equiv_Relation2.univ (qInit MOD)\n   (asTerm (qOp delta (pickInp inp) (pickBinp binp))) =\n  qInit MOD (qOp delta (pickInp inp) (pickBinp binp))\n  qInit MOD (qOp delta (pickInp inp) (pickBinp binp)) =\n  igOp MOD delta (lift (qInit MOD) (pickInp inp))\n   (lift (qInitAbs MOD) (pickBinp binp))\n  lift (qInit MOD) (pickInp inp) = lift (iterSTR MOD) inp \\<and>\n  lift (qInitAbs MOD) (pickBinp binp) = lift (iterAbsSTR MOD) binp", "show \"iterSTR MOD (Op delta inp binp) =\n        igOp MOD delta (lift (iterSTR MOD) inp) (lift (iterAbsSTR MOD) binp)\""], ["proof (prove)\nusing this:\n  iterSTR MOD (Op delta inp binp) =\n  Equiv_Relation2.univ (qInit MOD)\n   (asTerm (qOp delta (pickInp inp) (pickBinp binp)))\n  Equiv_Relation2.univ (qInit MOD)\n   (asTerm (qOp delta (pickInp inp) (pickBinp binp))) =\n  qInit MOD (qOp delta (pickInp inp) (pickBinp binp))\n  qInit MOD (qOp delta (pickInp inp) (pickBinp binp)) =\n  igOp MOD delta (lift (qInit MOD) (pickInp inp))\n   (lift (qInitAbs MOD) (pickBinp binp))\n  lift (qInit MOD) (pickInp inp) = lift (iterSTR MOD) inp \\<and>\n  lift (qInitAbs MOD) (pickBinp binp) = lift (iterAbsSTR MOD) binp\n\ngoal (1 subgoal):\n 1. iterSTR MOD (Op delta inp binp) =\n    igOp MOD delta (lift (iterSTR MOD) inp) (lift (iterAbsSTR MOD) binp)", "by simp"], ["proof (state)\nthis:\n  iterSTR MOD (Op delta inp binp) =\n  igOp MOD delta (lift (iterSTR MOD) inp) (lift (iterAbsSTR MOD) binp)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iwlsFSwSTR_iterSTR_ipresCons:\nassumes \"iwlsFSwSTR MOD\"\nshows \"ipresCons (iterSTR MOD) (iterAbsSTR MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresCons (iterSTR MOD) (iterAbsSTR MOD) MOD", "unfolding ipresCons_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresVar (iterSTR MOD) MOD \\<and>\n    ipresAbs (iterSTR MOD) (iterAbsSTR MOD) MOD \\<and>\n    ipresOp (iterSTR MOD) (iterAbsSTR MOD) MOD", "using assms\niwlsFSwSTR_iterSTR_ipresVar\niwlsFSwSTR_iterSTR_ipresAbs\niwlsFSwSTR_iterSTR_ipresOp"], ["proof (prove)\nusing this:\n  iwlsFSwSTR MOD\n  iwlsFSwSTR ?MOD \\<Longrightarrow> ipresVar (iterSTR ?MOD) ?MOD\n  iwlsFSwSTR ?MOD \\<Longrightarrow>\n  ipresAbs (iterSTR ?MOD) (iterAbsSTR ?MOD) ?MOD\n  iwlsFSwSTR ?MOD \\<Longrightarrow>\n  ipresOp (iterSTR ?MOD) (iterAbsSTR ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. ipresVar (iterSTR MOD) MOD \\<and>\n    ipresAbs (iterSTR MOD) (iterAbsSTR MOD) MOD \\<and>\n    ipresOp (iterSTR MOD) (iterAbsSTR MOD) MOD", "by auto"], ["", "lemma iwlsFSbSwTR_iterSTR_ipresCons:\nassumes \"iwlsFSbSwTR MOD\"\nshows \"ipresCons (iterSTR MOD) (iterAbsSTR MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresCons (iterSTR MOD) (iterAbsSTR MOD) MOD", "unfolding ipresCons_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipresVar (iterSTR MOD) MOD \\<and>\n    ipresAbs (iterSTR MOD) (iterAbsSTR MOD) MOD \\<and>\n    ipresOp (iterSTR MOD) (iterAbsSTR MOD) MOD", "using assms\niwlsFSbSwTR_iterSTR_ipresVar\niwlsFSbSwTR_iterSTR_ipresAbs\niwlsFSbSwTR_iterSTR_ipresOp"], ["proof (prove)\nusing this:\n  iwlsFSbSwTR MOD\n  iwlsFSbSwTR ?MOD \\<Longrightarrow> ipresVar (iterSTR ?MOD) ?MOD\n  iwlsFSbSwTR ?MOD \\<Longrightarrow>\n  ipresAbs (iterSTR ?MOD) (iterAbsSTR ?MOD) ?MOD\n  iwlsFSbSwTR ?MOD \\<Longrightarrow>\n  ipresOp (iterSTR ?MOD) (iterAbsSTR ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. ipresVar (iterSTR MOD) MOD \\<and>\n    ipresAbs (iterSTR MOD) (iterAbsSTR MOD) MOD \\<and>\n    ipresOp (iterSTR MOD) (iterAbsSTR MOD) MOD", "by auto"], ["", "lemma iwlsFSwSTR_iterSTR_termFSwImorph:\nassumes \"iwlsFSwSTR MOD\"\nshows \"termFSwImorph (iterSTR MOD) (iterAbsSTR MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. termFSwImorph (iterSTR MOD) (iterAbsSTR MOD) MOD", "using assms"], ["proof (prove)\nusing this:\n  iwlsFSwSTR MOD\n\ngoal (1 subgoal):\n 1. termFSwImorph (iterSTR MOD) (iterAbsSTR MOD) MOD", "by (auto simp: iwlsFSwSTR_termFSwImorph_iff intro: iwlsFSwSTR_iterSTR_ipresCons)"], ["", "corollary iterSTR_termFSwImorph_errMOD:\nassumes \"iwlsFSw MOD\"\nshows\n\"termFSwImorph (iterSTR (errMOD MOD))\n             (iterAbsSTR (errMOD MOD))\n             (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. termFSwImorph (iterSTR (errMOD MOD)) (iterAbsSTR (errMOD MOD))\n     (errMOD MOD)", "using assms errMOD_iwlsFSwSTR iwlsFSwSTR_iterSTR_termFSwImorph"], ["proof (prove)\nusing this:\n  iwlsFSw MOD\n  iwlsFSw ?MOD \\<Longrightarrow> iwlsFSwSTR (errMOD ?MOD)\n  iwlsFSwSTR ?MOD \\<Longrightarrow>\n  termFSwImorph (iterSTR ?MOD) (iterAbsSTR ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. termFSwImorph (iterSTR (errMOD MOD)) (iterAbsSTR (errMOD MOD))\n     (errMOD MOD)", "by auto"], ["", "lemma iwlsFSbSwTR_iterSTR_termFSbImorph:\nassumes \"iwlsFSbSwTR MOD\"\nshows \"termFSbImorph (iterSTR MOD) (iterAbsSTR MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. termFSbImorph (iterSTR MOD) (iterAbsSTR MOD) MOD", "using assms"], ["proof (prove)\nusing this:\n  iwlsFSbSwTR MOD\n\ngoal (1 subgoal):\n 1. termFSbImorph (iterSTR MOD) (iterAbsSTR MOD) MOD", "by (auto simp: iwlsFSbSwTR_termFSbImorph_iff intro: iwlsFSbSwTR_iterSTR_ipresCons)"], ["", "corollary iterSTR_termFSbImorph_errMOD:\nassumes \"iwlsFSb MOD\"\nshows\n\"termFSbImorph (iterSTR (errMOD MOD))\n             (iterAbsSTR (errMOD MOD))\n             (errMOD MOD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. termFSbImorph (iterSTR (errMOD MOD)) (iterAbsSTR (errMOD MOD))\n     (errMOD MOD)", "using assms errMOD_iwlsFSbSwTR iwlsFSbSwTR_iterSTR_termFSbImorph"], ["proof (prove)\nusing this:\n  iwlsFSb MOD\n  iwlsFSb ?MOD \\<Longrightarrow> iwlsFSbSwTR (errMOD ?MOD)\n  iwlsFSbSwTR ?MOD \\<Longrightarrow>\n  termFSbImorph (iterSTR ?MOD) (iterAbsSTR ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. termFSbImorph (iterSTR (errMOD MOD)) (iterAbsSTR (errMOD MOD))\n     (errMOD MOD)", "by auto"], ["", "(* We are done with the use of quesi-term ``implementations\". *)"], ["", "declare qItem_simps[simp del]"], ["", "declare qItem_versus_item_simps[simp del]"], ["", "declare good_item_simps[simp del]"], ["", "subsubsection \\<open>The initial morhpism (iteration map) from the term model to any model\\<close>"], ["", "text \\<open>Again, this morphism has the same definition for fresh-swap and fresh-subst models,\nas well as (of course) for fresh-swap-subst and fresh-subst-swap models. (Remember that\nthere is no such thing as ``fresh-subst-swap\" morhpism -- we use the notion of\n``fresh-swap-subst\" morphism.)\\<close>"], ["", "text \\<open>Existence of the morphism:\\<close>"], ["", "definition iter where\n\"iter MOD == check o (iterSTR (errMOD MOD))\""], ["", "definition iterAbs where\n\"iterAbs MOD == check o (iterAbsSTR (errMOD MOD))\""], ["", "theorem iwlsFSw_iterAll_termFSwImorph:\n\"iwlsFSw MOD \\<Longrightarrow> termFSwImorph (iter MOD) (iterAbs MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSw MOD \\<Longrightarrow> termFSwImorph (iter MOD) (iterAbs MOD) MOD", "using iterSTR_termFSwImorph_errMOD check_FSwImorph"], ["proof (prove)\nusing this:\n  iwlsFSw ?MOD \\<Longrightarrow>\n  termFSwImorph (iterSTR (errMOD ?MOD)) (iterAbsSTR (errMOD ?MOD))\n   (errMOD ?MOD)\n  FSwImorph check check (errMOD ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. iwlsFSw MOD \\<Longrightarrow> termFSwImorph (iter MOD) (iterAbs MOD) MOD", "by (auto simp: iter_def iterAbs_def intro: comp_termFSwImorph)"], ["", "theorem iwlsFSb_iterAll_termFSbImorph:\n\"iwlsFSb MOD \\<Longrightarrow> termFSbImorph (iter MOD) (iterAbs MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSb MOD \\<Longrightarrow> termFSbImorph (iter MOD) (iterAbs MOD) MOD", "using iterSTR_termFSbImorph_errMOD check_FSbImorph"], ["proof (prove)\nusing this:\n  iwlsFSb ?MOD \\<Longrightarrow>\n  termFSbImorph (iterSTR (errMOD ?MOD)) (iterAbsSTR (errMOD ?MOD))\n   (errMOD ?MOD)\n  FSbImorph check check (errMOD ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. iwlsFSb MOD \\<Longrightarrow> termFSbImorph (iter MOD) (iterAbs MOD) MOD", "by (auto simp: iter_def iterAbs_def intro: comp_termFSbImorph)"], ["", "theorem iwlsFSwSb_iterAll_termFSwSbImorph:\n\"iwlsFSwSb MOD \\<Longrightarrow> termFSwSbImorph (iter MOD) (iterAbs MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSwSb MOD \\<Longrightarrow>\n    termFSwSbImorph (iter MOD) (iterAbs MOD) MOD", "using iwlsFSw_iterAll_termFSwImorph"], ["proof (prove)\nusing this:\n  iwlsFSw ?MOD \\<Longrightarrow>\n  termFSwImorph (iter ?MOD) (iterAbs ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. iwlsFSwSb MOD \\<Longrightarrow>\n    termFSwSbImorph (iter MOD) (iterAbs MOD) MOD", "by (auto simp: iwlsFSwSb_termFSwSbImorph_iff iwlsFSwSb_def termFSwImorph_def)"], ["", "theorem iwlsFSbSw_iterAll_termFSwSbImorph:\n\"iwlsFSbSw MOD \\<Longrightarrow> termFSwSbImorph (iter MOD) (iterAbs MOD) MOD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSbSw MOD \\<Longrightarrow>\n    termFSwSbImorph (iter MOD) (iterAbs MOD) MOD", "using iwlsFSb_iterAll_termFSbImorph"], ["proof (prove)\nusing this:\n  iwlsFSb ?MOD \\<Longrightarrow>\n  termFSbImorph (iter ?MOD) (iterAbs ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. iwlsFSbSw MOD \\<Longrightarrow>\n    termFSwSbImorph (iter MOD) (iterAbs MOD) MOD", "by (auto simp: iwlsFSbSw_termFSwSbImorph_iff iwlsFSbSw_def  termFSbImorph_def)"], ["", "text \\<open>Uniqueness of the morphism\\<close>"], ["", "text \\<open>In fact, already a presumptive construct-preserving map has to be unique:\\<close>"], ["", "lemma ipresCons_unique:\nassumes \"ipresCons f fA MOD\" and \"ipresCons ig igA MOD\"\nshows\n\"(wls s X \\<longrightarrow> f X = ig X) \\<and>\n (wlsAbs (us,s') A \\<longrightarrow> fA A = igA A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow> f X = ig X) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow> fA A = igA A)", "proof(induction rule: wls_rawInduct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs x. f (Var xs x) = ig (Var xs x)\n 2. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2 (\\<lambda>a b. f b = ig b) (arOf delta) inp;\n        liftAll2 (\\<lambda>a b. fA b = igA b) (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> f (Op delta inp binp) = ig (Op delta inp binp)\n 3. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; f X = ig X\\<rbrakk>\n       \\<Longrightarrow> fA (Abs xs x X) = igA (Abs xs x X)", "case (Var xs x)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>xs x. f (Var xs x) = ig (Var xs x)\n 2. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2 (\\<lambda>a b. f b = ig b) (arOf delta) inp;\n        liftAll2 (\\<lambda>a b. fA b = igA b) (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> f (Op delta inp binp) = ig (Op delta inp binp)\n 3. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; f X = ig X\\<rbrakk>\n       \\<Longrightarrow> fA (Abs xs x X) = igA (Abs xs x X)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Var xs x) = ig (Var xs x)", "using assms"], ["proof (prove)\nusing this:\n  ipresCons f fA MOD\n  ipresCons ig igA MOD\n\ngoal (1 subgoal):\n 1. f (Var xs x) = ig (Var xs x)", "unfolding ipresCons_def ipresVar_def"], ["proof (prove)\nusing this:\n  (\\<forall>xs x. f (Var xs x) = igVar MOD xs x) \\<and>\n  ipresAbs f fA MOD \\<and> ipresOp f fA MOD\n  (\\<forall>xs x. ig (Var xs x) = igVar MOD xs x) \\<and>\n  ipresAbs ig igA MOD \\<and> ipresOp ig igA MOD\n\ngoal (1 subgoal):\n 1. f (Var xs x) = ig (Var xs x)", "by simp"], ["proof (state)\nthis:\n  f (Var xs x) = ig (Var xs x)\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2 (\\<lambda>a b. f b = ig b) (arOf delta) inp;\n        liftAll2 (\\<lambda>a b. fA b = igA b) (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> f (Op delta inp binp) = ig (Op delta inp binp)\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; f X = ig X\\<rbrakk>\n       \\<Longrightarrow> fA (Abs xs x X) = igA (Abs xs x X)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2 (\\<lambda>a b. f b = ig b) (arOf delta) inp;\n        liftAll2 (\\<lambda>a b. fA b = igA b) (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> f (Op delta inp binp) = ig (Op delta inp binp)\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; f X = ig X\\<rbrakk>\n       \\<Longrightarrow> fA (Abs xs x X) = igA (Abs xs x X)", "case (Op delta inp binp)"], ["proof (state)\nthis:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2 (\\<lambda>a b. f b = ig b) (arOf delta) inp\n  liftAll2 (\\<lambda>a b. fA b = igA b) (barOf delta) binp\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2 (\\<lambda>a b. f b = ig b) (arOf delta) inp;\n        liftAll2 (\\<lambda>a b. fA b = igA b) (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> f (Op delta inp binp) = ig (Op delta inp binp)\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; f X = ig X\\<rbrakk>\n       \\<Longrightarrow> fA (Abs xs x X) = igA (Abs xs x X)", "hence \"lift f inp = lift ig inp \\<and> lift fA binp = lift igA binp\""], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2 (\\<lambda>a b. f b = ig b) (arOf delta) inp\n  liftAll2 (\\<lambda>a b. fA b = igA b) (barOf delta) binp\n\ngoal (1 subgoal):\n 1. lift f inp = lift ig inp \\<and> lift fA binp = lift igA binp", "using assms"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  wlsBinp delta binp\n  liftAll2 (\\<lambda>a b. f b = ig b) (arOf delta) inp\n  liftAll2 (\\<lambda>a b. fA b = igA b) (barOf delta) binp\n  ipresCons f fA MOD\n  ipresCons ig igA MOD\n\ngoal (1 subgoal):\n 1. lift f inp = lift ig inp \\<and> lift fA binp = lift igA binp", "apply(simp add: lift_def liftAll2_def sameDom_def fun_eq_iff wlsInp_iff wlsBinp_iff split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wlsOpS delta \\<and>\n             (\\<forall>i. (arOf delta i = None) = (inp i = None)) \\<and>\n             (\\<forall>i v1 v2.\n                 arOf delta i = Some v1 \\<and>\n                 inp i = Some v2 \\<longrightarrow>\n                 wls v1 v2);\n     (\\<forall>i. (barOf delta i = None) = (binp i = None)) \\<and>\n     (\\<forall>i a b v2.\n         barOf delta i = Some (a, b) \\<and>\n         binp i = Some v2 \\<longrightarrow>\n         wlsAbs (a, b) v2);\n     \\<forall>i v1 v2.\n        arOf delta i = Some v1 \\<and> inp i = Some v2 \\<longrightarrow>\n        f v2 = ig v2;\n     \\<forall>i a b v2.\n        barOf delta i = Some (a, b) \\<and>\n        binp i = Some v2 \\<longrightarrow>\n        fA v2 = igA v2;\n     ipresCons f fA MOD; ipresCons ig igA MOD\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x x2.\n                          inp x = Some x2 \\<longrightarrow>\n                          f x2 = ig x2) \\<and>\n                      (\\<forall>x x2.\n                          binp x = Some x2 \\<longrightarrow> fA x2 = igA x2)", "using not_None_eq"], ["proof (prove)\nusing this:\n  (?x \\<noteq> None) = (\\<exists>y. ?x = Some y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wlsOpS delta \\<and>\n             (\\<forall>i. (arOf delta i = None) = (inp i = None)) \\<and>\n             (\\<forall>i v1 v2.\n                 arOf delta i = Some v1 \\<and>\n                 inp i = Some v2 \\<longrightarrow>\n                 wls v1 v2);\n     (\\<forall>i. (barOf delta i = None) = (binp i = None)) \\<and>\n     (\\<forall>i a b v2.\n         barOf delta i = Some (a, b) \\<and>\n         binp i = Some v2 \\<longrightarrow>\n         wlsAbs (a, b) v2);\n     \\<forall>i v1 v2.\n        arOf delta i = Some v1 \\<and> inp i = Some v2 \\<longrightarrow>\n        f v2 = ig v2;\n     \\<forall>i a b v2.\n        barOf delta i = Some (a, b) \\<and>\n        binp i = Some v2 \\<longrightarrow>\n        fA v2 = igA v2;\n     ipresCons f fA MOD; ipresCons ig igA MOD\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x x2.\n                          inp x = Some x2 \\<longrightarrow>\n                          f x2 = ig x2) \\<and>\n                      (\\<forall>x x2.\n                          binp x = Some x2 \\<longrightarrow> fA x2 = igA x2)", "by (metis surj_pair)"], ["proof (state)\nthis:\n  lift f inp = lift ig inp \\<and> lift fA binp = lift igA binp\n\ngoal (2 subgoals):\n 1. \\<And>delta inp binp.\n       \\<lbrakk>wlsInp delta inp; wlsBinp delta binp;\n        liftAll2 (\\<lambda>a b. f b = ig b) (arOf delta) inp;\n        liftAll2 (\\<lambda>a b. fA b = igA b) (barOf delta) binp\\<rbrakk>\n       \\<Longrightarrow> f (Op delta inp binp) = ig (Op delta inp binp)\n 2. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; f X = ig X\\<rbrakk>\n       \\<Longrightarrow> fA (Abs xs x X) = igA (Abs xs x X)", "thus \"f (Op delta inp binp) = ig (Op delta inp binp)\""], ["proof (prove)\nusing this:\n  lift f inp = lift ig inp \\<and> lift fA binp = lift igA binp\n\ngoal (1 subgoal):\n 1. f (Op delta inp binp) = ig (Op delta inp binp)", "using assms"], ["proof (prove)\nusing this:\n  lift f inp = lift ig inp \\<and> lift fA binp = lift igA binp\n  ipresCons f fA MOD\n  ipresCons ig igA MOD\n\ngoal (1 subgoal):\n 1. f (Op delta inp binp) = ig (Op delta inp binp)", "unfolding ipresCons_def ipresOp_def"], ["proof (prove)\nusing this:\n  lift f inp = lift ig inp \\<and> lift fA binp = lift igA binp\n  ipresVar f MOD \\<and>\n  ipresAbs f fA MOD \\<and>\n  (\\<forall>delta inp binp.\n      wlsInp delta inp \\<and> wlsBinp delta binp \\<longrightarrow>\n      f (Op delta inp binp) = igOp MOD delta (lift f inp) (lift fA binp))\n  ipresVar ig MOD \\<and>\n  ipresAbs ig igA MOD \\<and>\n  (\\<forall>delta inp binp.\n      wlsInp delta inp \\<and> wlsBinp delta binp \\<longrightarrow>\n      ig (Op delta inp binp) = igOp MOD delta (lift ig inp) (lift igA binp))\n\ngoal (1 subgoal):\n 1. f (Op delta inp binp) = ig (Op delta inp binp)", "by (simp add: Op.IH)"], ["proof (state)\nthis:\n  f (Op delta inp binp) = ig (Op delta inp binp)\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; f X = ig X\\<rbrakk>\n       \\<Longrightarrow> fA (Abs xs x X) = igA (Abs xs x X)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; f X = ig X\\<rbrakk>\n       \\<Longrightarrow> fA (Abs xs x X) = igA (Abs xs x X)", "case (Abs s xs x X)"], ["proof (state)\nthis:\n  isInBar (xs, s)\n  wls s X\n  f X = ig X\n\ngoal (1 subgoal):\n 1. \\<And>s xs x X.\n       \\<lbrakk>isInBar (xs, s); wls s X; f X = ig X\\<rbrakk>\n       \\<Longrightarrow> fA (Abs xs x X) = igA (Abs xs x X)", "then"], ["proof (chain)\npicking this:\n  isInBar (xs, s)\n  wls s X\n  f X = ig X", "show ?case"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  f X = ig X\n\ngoal (1 subgoal):\n 1. fA (Abs xs x X) = igA (Abs xs x X)", "using assms"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  f X = ig X\n  ipresCons f fA MOD\n  ipresCons ig igA MOD\n\ngoal (1 subgoal):\n 1. fA (Abs xs x X) = igA (Abs xs x X)", "unfolding ipresCons_def ipresAbs_def"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  f X = ig X\n  ipresVar f MOD \\<and>\n  (\\<forall>xs x s X.\n      isInBar (xs, s) \\<and> wls s X \\<longrightarrow>\n      fA (Abs xs x X) = igAbs MOD xs x (f X)) \\<and>\n  ipresOp f fA MOD\n  ipresVar ig MOD \\<and>\n  (\\<forall>xs x s X.\n      isInBar (xs, s) \\<and> wls s X \\<longrightarrow>\n      igA (Abs xs x X) = igAbs MOD xs x (ig X)) \\<and>\n  ipresOp ig igA MOD\n\ngoal (1 subgoal):\n 1. fA (Abs xs x X) = igA (Abs xs x X)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isInBar (xs, s); wls s X; f X = ig X; ipresVar f MOD;\n     ipresVar ig MOD;\n     \\<forall>xs x s X.\n        isInBar (xs, s) \\<and> wls s X \\<longrightarrow>\n        fA (Abs xs x X) = igAbs MOD xs x (f X);\n     ipresOp f fA MOD;\n     \\<forall>xs x s X.\n        isInBar (xs, s) \\<and> wls s X \\<longrightarrow>\n        igA (Abs xs x X) = igAbs MOD xs x (ig X);\n     ipresOp ig igA MOD\\<rbrakk>\n    \\<Longrightarrow> fA (Abs xs x X) = igA (Abs xs x X)", "by (erule allE[of _ xs], erule allE[of _ x]) fastforce"], ["proof (state)\nthis:\n  fA (Abs xs x X) = igA (Abs xs x X)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem iwlsFSw_iterAll_unique_ipresCons:\nassumes \"iwlsFSw MOD\" and \"ipresCons h hA MOD\"\nshows\n\"(wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n (wlsAbs (us,s') A \\<longrightarrow> hA A = iterAbs MOD A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow> hA A = iterAbs MOD A)", "using assms iwlsFSw_iterAll_termFSwImorph"], ["proof (prove)\nusing this:\n  iwlsFSw MOD\n  ipresCons h hA MOD\n  iwlsFSw ?MOD \\<Longrightarrow>\n  termFSwImorph (iter ?MOD) (iterAbs ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow> hA A = iterAbs MOD A)", "by (auto simp: termFSwImorph_def intro!: ipresCons_unique)"], ["", "theorem iwlsFSb_iterAll_unique_ipresCons:\nassumes \"iwlsFSb MOD\" and \"ipresCons h hA MOD\"\nshows\n\"(wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n (wlsAbs (us,s') A \\<longrightarrow> hA A = iterAbs MOD A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow> hA A = iterAbs MOD A)", "using assms iwlsFSb_iterAll_termFSbImorph"], ["proof (prove)\nusing this:\n  iwlsFSb MOD\n  ipresCons h hA MOD\n  iwlsFSb ?MOD \\<Longrightarrow>\n  termFSbImorph (iter ?MOD) (iterAbs ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow> hA A = iterAbs MOD A)", "by (auto simp: termFSbImorph_def intro!: ipresCons_unique)"], ["", "theorem iwlsFSwSb_iterAll_unique_ipresCons:\nassumes \"iwlsFSwSb MOD\" and \"ipresCons h hA MOD\"\nshows\n\"(wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n (wlsAbs (us,s') A \\<longrightarrow> hA A = iterAbs MOD A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow> hA A = iterAbs MOD A)", "using assms"], ["proof (prove)\nusing this:\n  iwlsFSwSb MOD\n  ipresCons h hA MOD\n\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow> hA A = iterAbs MOD A)", "unfolding iwlsFSwSb_def"], ["proof (prove)\nusing this:\n  iwlsFSw MOD \\<and> igSubstAllIPresIGWlsAll MOD \\<and> igSubstCls MOD\n  ipresCons h hA MOD\n\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow> hA A = iterAbs MOD A)", "using iwlsFSw_iterAll_unique_ipresCons"], ["proof (prove)\nusing this:\n  iwlsFSw MOD \\<and> igSubstAllIPresIGWlsAll MOD \\<and> igSubstCls MOD\n  ipresCons h hA MOD\n  \\<lbrakk>iwlsFSw ?MOD; ipresCons ?h ?hA ?MOD\\<rbrakk>\n  \\<Longrightarrow> (wls ?s ?X \\<longrightarrow>\n                     ?h ?X = iter ?MOD ?X) \\<and>\n                    (wlsAbs (?us, ?s') ?A \\<longrightarrow>\n                     ?hA ?A = iterAbs ?MOD ?A)\n\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow> hA A = iterAbs MOD A)", "by blast"], ["", "theorem iwlsFSbSw_iterAll_unique_ipresCons:\nassumes *: \"iwlsFSbSw MOD\" and **: \"ipresCons h hA MOD\"\nshows\n\"(wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n (wlsAbs (us,s') A \\<longrightarrow> hA A = iterAbs MOD A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow> hA A = iterAbs MOD A)", "using assms"], ["proof (prove)\nusing this:\n  iwlsFSbSw MOD\n  ipresCons h hA MOD\n\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow> hA A = iterAbs MOD A)", "unfolding iwlsFSbSw_def"], ["proof (prove)\nusing this:\n  iwlsFSb MOD \\<and> igSwapAllIPresIGWlsAll MOD \\<and> igSwapCls MOD\n  ipresCons h hA MOD\n\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow> hA A = iterAbs MOD A)", "using iwlsFSb_iterAll_unique_ipresCons"], ["proof (prove)\nusing this:\n  iwlsFSb MOD \\<and> igSwapAllIPresIGWlsAll MOD \\<and> igSwapCls MOD\n  ipresCons h hA MOD\n  \\<lbrakk>iwlsFSb ?MOD; ipresCons ?h ?hA ?MOD\\<rbrakk>\n  \\<Longrightarrow> (wls ?s ?X \\<longrightarrow>\n                     ?h ?X = iter ?MOD ?X) \\<and>\n                    (wlsAbs (?us, ?s') ?A \\<longrightarrow>\n                     ?hA ?A = iterAbs ?MOD ?A)\n\ngoal (1 subgoal):\n 1. (wls s X \\<longrightarrow> h X = iter MOD X) \\<and>\n    (wlsAbs (us, s') A \\<longrightarrow> hA A = iterAbs MOD A)", "by blast"], ["", "(**************************************)"], ["", "lemmas iteration_simps =\ninput_igSwap_igSubst_None\ntermMOD_simps\nerror_model_simps"], ["", "declare iteration_simps [simp del]"], ["", "end"], ["", "(* context FixSyn *)\n(************************************************)"], ["", "end"]]}