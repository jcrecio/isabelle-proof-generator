{"file_name": "/home/qj213/afp-2021-10-22/thys/Binding_Syntax_Theory/QuasiTerms_Swap_Fresh.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Binding_Syntax_Theory", "problem_names": ["lemma qTerm_rawInduct[case_names Var Op Abs]:\nfixes X :: \"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A :: \"('index,'bindex,'varSort,'var,'opSym)qAbs\" and phi phiAbs\nassumes\n  Var: \"\\<And> xs x. phi (qVar xs x)\" and\n  Op: \"\\<And> delta inp binp. \\<lbrakk>liftAll phi inp; liftAll phiAbs binp\\<rbrakk> \\<Longrightarrow> phi (qOp delta inp binp)\" and\n  Abs: \"\\<And> xs x X. phi X \\<Longrightarrow> phiAbs (qAbs xs x X)\"\nshows \"phi X \\<and> phiAbs A\"", "lemma qTermLess_wf: \"wf qTermLess\"", "lemma qTermLessPlus_wf: \"wf (qTermLess ^+)\"", "lemma qTerm_templateInduct[case_names Var Op Abs]:\nfixes X :: \"('index,'bindex,'varSort,'var,'opSym)qTerm\"\nand A :: \"('index,'bindex,'varSort,'var,'opSym)qAbs\"\nand phi phiAbs and rel\nassumes\nREL: \"\\<And> X Y. (X,Y) \\<in> rel \\<Longrightarrow> qSkel Y = qSkel X\" and\nVar: \"\\<And> xs x. phi (qVar xs x)\" and\nOp: \"\\<And> delta inp binp. \\<lbrakk>liftAll phi inp; liftAll phiAbs binp\\<rbrakk>\n                       \\<Longrightarrow> phi (qOp delta inp binp)\" and\nAbs: \"\\<And> xs x X. (\\<And> Y. (X,Y) \\<in> rel \\<Longrightarrow> phi Y) \\<Longrightarrow> phiAbs (qAbs xs x X)\"\nshows \"phi X \\<and> phiAbs A\"", "lemma qTermLess_modulo_wf:\nfixes rel::\"('index,'bindex,'varSort,'var,'opSym)qTerm rel\"\nassumes \"\\<And> X Y. (X,Y) \\<in> rel \\<Longrightarrow> qSkel Y = qSkel X\"\nshows \"wf (qTermLess_modulo rel)\"", "theorem sw_simps1[simp]: \"(x @xs[x \\<and> y]_xs) = y\"", "theorem sw_simps2[simp]: \"(x @xs[y \\<and> x]_xs) = y\"", "theorem sw_simps3[simp]:\n\"(zs \\<noteq> xs \\<or> x \\<notin> {z1,z2}) \\<Longrightarrow> (x @xs[z1 \\<and> z2]_zs) = x\"", "lemmas sw_simps = sw_simps1 sw_simps2 sw_simps3", "theorem sw_ident[simp]: \"(x @xs[y \\<and> y]_ys) = x\"", "theorem sw_compose:\n\"((z @zs[x \\<and> y]_xs) @zs[x' \\<and> y']_xs') =\n ((z @zs[x' \\<and> y']_xs') @zs[(x @xs[x' \\<and> y']_xs') \\<and> (y @xs[x' \\<and> y']_xs')]_xs)\"", "theorem sw_commute:\nassumes \"zs \\<noteq> zs' \\<or> {x,y} Int {x',y'} = {}\"\nshows \"((u @us[x \\<and> y]_zs) @us[x' \\<and> y']_zs') = ((u @us[x' \\<and> y']_zs') @us[x \\<and> y]_zs)\"", "theorem sw_involutive[simp]:\n\"((z @zs[x \\<and> y]_xs) @zs[x \\<and> y]_xs) = z\"", "theorem sw_inj[simp]:\n\"((z @zs[x \\<and> y]_xs) = (z' @zs[x \\<and> y]_xs)) = (z = z')\"", "lemma sw_preserves_mship[simp]:\nassumes \"{y1,y2} \\<subseteq> Var ys\"\nshows \"((x @xs[y1 \\<and> y2]_ys) \\<in> Var xs) = (x \\<in> Var xs)\"", "theorem sw_sym:\n\"(z @zs[x \\<and> y]_xs) = (z @zs[y \\<and> x]_xs)\"", "theorem sw_involutive2[simp]:\n\"((z @zs[x \\<and> y]_xs) @zs[y \\<and> x]_xs) = z\"", "theorem sw_trans:\n\"us \\<noteq> zs \\<or> u \\<notin> {y,z} \\<Longrightarrow>\n ((u @us[y \\<and> x]_zs) @us[z \\<and> y]_zs) = (u @us[z \\<and> x]_zs)\"", "lemmas sw_otherSimps =\nsw_ident sw_involutive sw_inj sw_preserves_mship sw_involutive2", "theorem sb_simps1[simp]: \"(x @xs[y / x]_xs) = y\"", "theorem sb_simps2[simp]:\n\"(zs \\<noteq> xs \\<or> z2 \\<noteq> x) \\<Longrightarrow> (x @xs[z1 / z2]_zs) = x\"", "lemmas sb_simps = sb_simps1 sb_simps2", "theorem sb_ident[simp]: \"(x @xs[y / y]_ys) = x\"", "theorem sb_compose1:\n\"((z @zs[y1 / x]_xs) @zs[y2 / x]_xs) = (z @zs[(y1 @xs[y2 / x]_xs) / x]_xs)\"", "theorem sb_compose2:\n\"ys \\<noteq> xs \\<or> (x2 \\<notin> {y1,y2}) \\<Longrightarrow>\n ((z @zs[x1 / x2]_xs) @zs[y1 / y2]_ys) =\n ((z @zs[y1 / y2]_ys) @zs[(x1 @xs[y1 / y2]_ys) / x2]_xs)\"", "theorem sb_commute:\nassumes \"zs \\<noteq> zs' \\<or> {x,y} Int {x',y'} = {}\"\nshows \"((u @us[x / y]_zs) @us[x' / y']_zs') = ((u @us[x' / y']_zs') @us[x / y]_zs)\"", "theorem sb_idem[simp]:\n\"((z @zs[x / y]_xs) @zs[x / y]_xs) = (z @zs[x / y]_xs)\"", "lemma sb_preserves_mship[simp]:\nassumes \"{y1,y2} \\<subseteq> Var ys\"\nshows \"((x @xs[y1 / y2]_ys) \\<in> Var xs) = (x \\<in> Var xs)\"", "theorem sb_trans:\n\"us \\<noteq> zs \\<or> u \\<noteq> y \\<Longrightarrow>\n ((u @us[y / x]_zs) @us[z / y]_zs) = (u @us[z / x]_zs)\"", "lemmas sb_otherSimps =\nsb_ident sb_idem sb_preserves_mship", "lemma qTermLess_ingoreFirst3_wf:\n\"wf(inv_image qTermLess aux_qSwap_ignoreFirst3)\"", "lemmas qSwapAll_simps = qSwap.simps qSwapAbs.simps", "lemma qTermLess_ingoreFirst2_wf: \"wf(inv_image qTermLess aux_qFresh_ignoreFirst2)\"", "lemmas qAFreshAll_simps = qAFresh.simps qAFreshAbs.simps", "lemmas qFreshAll_simps = qFresh.simps qFreshAbs.simps", "lemma qSwapAll_ident:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\"\n    shows \"(X #[[x \\<and> x]]_zs) = X \\<and> (A $[[x \\<and> x]]_zs) = A\"", "lemma qSwapAll_compose:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\"  and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\" and zs x y x' y'\nshows\n\"((X #[[x \\<and> y]]_zs) #[[x' \\<and> y']]_zs') =\n ((X #[[x' \\<and> y']]_zs') #[[(x @zs[x' \\<and> y']_zs') \\<and> (y @zs[x' \\<and> y']_zs')]]_zs)\n\\<and>\n ((A $[[x \\<and> y]]_zs) $[[x' \\<and> y']]_zs') =\n ((A $[[x' \\<and> y']]_zs') $[[(x @zs[x' \\<and> y']_zs') \\<and> (y @zs[x' \\<and> y']_zs')]]_zs)\"", "lemma qSwap_commute:\nassumes \"zs \\<noteq> zs' \\<or> {x,y} Int {x',y'} = {}\"\nshows \"((X #[[x \\<and> y]]_zs) #[[x' \\<and> y']]_zs') = ((X #[[x' \\<and> y']]_zs') #[[x \\<and> y]]_zs)\"", "lemma qSwapAll_involutive:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\" and zs x y\nshows \"((X #[[x \\<and> y]]_zs) #[[x \\<and> y]]_zs) = X \\<and>\n       ((A $[[x \\<and> y]]_zs) $[[x \\<and> y]]_zs) = A\"", "lemma qSwapAll_sym:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\" and zs x y\nshows \"(X #[[x \\<and> y]]_zs) = (X #[[y \\<and> x]]_zs) \\<and>\n       (A $[[x \\<and> y]]_zs) = (A $[[y \\<and> x]]_zs)\"", "lemma qAFreshAll_qSwapAll_id:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\" and zs z1 z2\nshows \"(qAFresh zs z1 X \\<and> qAFresh zs z2 X  \\<longrightarrow> (X #[[z1 \\<and> z2]]_zs) = X) \\<and>\n       (qAFreshAbs zs z1 A \\<and> qAFreshAbs zs z2 A  \\<longrightarrow> (A $[[z1 \\<and> z2]]_zs) = A)\"", "lemma qAFreshAll_qSwapAll_compose:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\"and zs x y z\nshows  \"(qAFresh zs y X \\<and> qAFresh zs z X \\<longrightarrow>\n         ((X #[[y \\<and> x]]_zs) #[[z \\<and> y]]_zs) = (X #[[z \\<and> x]]_zs)) \\<and>\n        (qAFreshAbs zs y A \\<and> qAFreshAbs zs z A \\<longrightarrow>\n         ((A $[[y \\<and> x]]_zs) $[[z \\<and> y]]_zs) = (A $[[z \\<and> x]]_zs))\"", "lemma qSkel_qSwapAll:\nfixes  X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n       A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\" and x y zs\nshows \"qSkel(X #[[x \\<and> y]]_zs) = qSkel X \\<and>\n       qSkelAbs(A $[[x \\<and> y]]_zs) = qSkelAbs A\"", "lemmas qSwapped_Clauses = qSwapped.Refl qSwapped.Trans qSwapped.Swap", "lemma qSwap_qSwapped: \"(X, X #[[x \\<and> y]]_zs): qSwapped\"", "lemma qSwapped_qSkel:\n\"(X,Y) \\<in> qSwapped  \\<Longrightarrow> qSkel Y = qSkel X\"", "lemma qTerm_induct[case_names Var Op Abs]:\nfixes X :: \"('index,'bindex,'varSort,'var,'opSym)qTerm\"\nand A :: \"('index,'bindex,'varSort,'var,'opSym)qAbs\"  and phi phiAbs\nassumes\n  Var: \"\\<And> xs x. phi (qVar xs x)\" and\n  Op: \"\\<And> delta inp binp. \\<lbrakk>liftAll phi inp; liftAll phiAbs binp\\<rbrakk>\n                         \\<Longrightarrow> phi (qOp delta inp binp)\" and\n  Abs: \"\\<And> xs x X. \\<lbrakk>\\<And> Y. (X,Y) \\<in> qSwapped \\<Longrightarrow> phi Y;\n                    \\<And> Y. qSkel Y = qSkel X \\<Longrightarrow> phi Y\\<rbrakk>\n                    \\<Longrightarrow> phiAbs (qAbs xs x X)\"\nshows \"phi X \\<and> phiAbs A\"", "lemma qTermQSwappedLess_wf: \"wf qTermQSwappedLess\"", "lemma qSwap_3commute:\nassumes *: \"qAFresh ys y X\" and **: \"qAFresh ys y0 X\"\nand ***: \"ys \\<noteq> zs \\<or> y0 \\<notin> {z1,z2}\"\nshows \"((X #[[z1 \\<and> z2]]_zs) #[[y0 \\<and> x @ys[z1 \\<and> z2]_zs]]_ys) =\n       (((X #[[y \\<and> x]]_ys) #[[y0 \\<and> y]]_ys) #[[z1 \\<and> z2]]_zs)\"", "lemma qAFreshAll_imp_qFreshAll:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\" and xs x\nshows \"(qAFresh xs x X \\<longrightarrow> qFresh xs x X) \\<and>\n       (qAFreshAbs xs x A \\<longrightarrow> qFreshAbs xs x A)\"", "lemma qSwapAll_preserves_qAFreshAll:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\" and ys y zs z1 z2\nshows\n\"(qAFresh ys (y @ys[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) = qAFresh ys y X) \\<and>\n (qAFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (A $[[z1 \\<and> z2]]_zs) = qAFreshAbs ys y A)\"", "lemma qSwap_preserves_qAFresh_distinct:\nassumes \"ys \\<noteq> zs \\<or> y \\<notin> {z1,z2}\"\nshows \"qAFresh ys y (X #[[z1 \\<and> z2]]_zs) = qAFresh ys y X\"", "lemma qAFresh_qSwap_exchange1:\n\"qAFresh zs z2 (X #[[z1 \\<and> z2]]_zs) = qAFresh zs z1 X\"", "lemma qAFresh_qSwap_exchange2:\n\"qAFresh zs z2 (X #[[z2 \\<and> z1]]_zs) = qAFresh zs z1 X\"", "lemma qSwapAll_preserves_qFreshAll:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\" and ys y zs z1 z2\nshows\n\"(qFresh ys (y @ys[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) = qFresh ys y X) \\<and>\n (qFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (A $[[z1 \\<and> z2]]_zs) = qFreshAbs ys y A)\"", "lemma qSwap_preserves_qFresh_distinct:\nassumes \"ys \\<noteq> zs \\<or> y \\<notin> {z1,z2}\"\nshows \"qFresh ys y (X #[[z1 \\<and> z2]]_zs) = qFresh ys y X\"", "lemma qFresh_qSwap_exchange1:\n\"qFresh zs z2 (X #[[z1 \\<and> z2]]_zs) = qFresh zs z1 X\"", "lemma qFresh_qSwap_exchange2:\n\"qFresh zs z1 X = qFresh zs z2 (X #[[z2 \\<and> z1]]_zs)\"", "lemmas qSwap_qAFresh_otherSimps =\nqSwap_ident qSwap_involutive qAFresh_qSwap_id qSwap_preserves_qAFresh"], "translations": [["", "lemma qTerm_rawInduct[case_names Var Op Abs]:\nfixes X :: \"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A :: \"('index,'bindex,'varSort,'var,'opSym)qAbs\" and phi phiAbs\nassumes\n  Var: \"\\<And> xs x. phi (qVar xs x)\" and\n  Op: \"\\<And> delta inp binp. \\<lbrakk>liftAll phi inp; liftAll phiAbs binp\\<rbrakk> \\<Longrightarrow> phi (qOp delta inp binp)\" and\n  Abs: \"\\<And> xs x X. phi X \\<Longrightarrow> phiAbs (qAbs xs x X)\"\nshows \"phi X \\<and> phiAbs A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phi X \\<and> phiAbs A", "by (induct rule: qTerm_qAbs.induct)\n   (fastforce intro!: Var Op Abs rangeI simp: liftAll_def)+"], ["", "lemma qTermLess_wf: \"wf qTermLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf qTermLess", "unfolding wf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>P.\n       (\\<forall>x.\n           (\\<forall>y.\n               (y, x) \\<in> qTermLess \\<longrightarrow>\n               P y) \\<longrightarrow>\n           P x) \\<longrightarrow>\n       All P", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> qTermLess \\<longrightarrow>\n              P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P x", "fix chi item"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> qTermLess \\<longrightarrow>\n              P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P x", "assume *: \"\\<forall>item. (\\<forall>item'. (item', item) \\<in> qTermLess \\<longrightarrow> chi item') \\<longrightarrow> chi item\""], ["proof (state)\nthis:\n  \\<forall>item.\n     (\\<forall>item'.\n         (item', item) \\<in> qTermLess \\<longrightarrow>\n         chi item') \\<longrightarrow>\n     chi item\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> qTermLess \\<longrightarrow>\n              P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P x", "show \"chi item\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chi item", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. chi item", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. chi item", "fix X A"], ["proof (state)\ngoal (1 subgoal):\n 1. chi item", "have \"chi (termIn X) \\<and> chi (absIn A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chi (termIn X) \\<and> chi (absIn A)", "apply(induct rule: qTerm_rawInduct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs x. chi (termIn (qVar xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll (\\<lambda>a. chi (termIn a)) inp;\n        liftAll (\\<lambda>a. chi (absIn a)) binp\\<rbrakk>\n       \\<Longrightarrow> chi (termIn (qOp delta inp binp))\n 3. \\<And>xs x X. chi (termIn X) \\<Longrightarrow> chi (absIn (qAbs xs x X))", "using *"], ["proof (prove)\nusing this:\n  \\<forall>item.\n     (\\<forall>item'.\n         (item', item) \\<in> qTermLess \\<longrightarrow>\n         chi item') \\<longrightarrow>\n     chi item\n\ngoal (3 subgoals):\n 1. \\<And>xs x. chi (termIn (qVar xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll (\\<lambda>a. chi (termIn a)) inp;\n        liftAll (\\<lambda>a. chi (absIn a)) binp\\<rbrakk>\n       \\<Longrightarrow> chi (termIn (qOp delta inp binp))\n 3. \\<And>xs x X. chi (termIn X) \\<Longrightarrow> chi (absIn (qAbs xs x X))", "unfolding qTermLess_def liftAll_def"], ["proof (prove)\nusing this:\n  \\<forall>item.\n     (\\<forall>item'.\n         (item', item)\n         \\<in> {uu_.\n                \\<exists>X delta inp binp i.\n                   uu_ = (termIn X, termIn (qOp delta inp binp)) \\<and>\n                   inp i = Some X} \\<union>\n               {uu_.\n                \\<exists>A delta inp binp i.\n                   uu_ = (absIn A, termIn (qOp delta inp binp)) \\<and>\n                   binp i = Some A} \\<union>\n               {(termIn X, absIn (qAbs xs x X)) |X xs x.\n                True} \\<longrightarrow>\n         chi item') \\<longrightarrow>\n     chi item\n\ngoal (3 subgoals):\n 1. \\<And>xs x. chi (termIn (qVar xs x))\n 2. \\<And>delta inp binp.\n       \\<lbrakk>\\<forall>i v.\n                   inp i = Some v \\<longrightarrow> chi (termIn v);\n        \\<forall>i v.\n           binp i = Some v \\<longrightarrow> chi (absIn v)\\<rbrakk>\n       \\<Longrightarrow> chi (termIn (qOp delta inp binp))\n 3. \\<And>xs x X. chi (termIn X) \\<Longrightarrow> chi (absIn (qAbs xs x X))", "by blast+"], ["proof (state)\nthis:\n  chi (termIn X) \\<and> chi (absIn A)\n\ngoal (1 subgoal):\n 1. chi item", "}"], ["proof (state)\nthis:\n  chi (termIn ?X2) \\<and> chi (absIn ?A2)\n\ngoal (1 subgoal):\n 1. chi item", "thus ?thesis"], ["proof (prove)\nusing this:\n  chi (termIn ?X2) \\<and> chi (absIn ?A2)\n\ngoal (1 subgoal):\n 1. chi item", "by(cases item) auto"], ["proof (state)\nthis:\n  chi item\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chi item\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qTermLessPlus_wf: \"wf (qTermLess ^+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (qTermLess\\<^sup>+)", "using qTermLess_wf wf_trancl"], ["proof (prove)\nusing this:\n  wf qTermLess\n  wf ?r \\<Longrightarrow> wf (?r\\<^sup>+)\n\ngoal (1 subgoal):\n 1. wf (qTermLess\\<^sup>+)", "by auto"], ["", "text\\<open>The skeleton of a quasi-term item -- this is the generalization\n   of the size function from the case of finitary syntax.\n   We use the skeleton later for proving correct various recursive function definitions, notably that of ``alpha\".\\<close>"], ["", "function\nqSkel :: \"('index,'bindex,'varSort,'var,'opSym)qTerm \\<Rightarrow> ('index,'bindex)tree\"\nand\nqSkelAbs :: \"('index,'bindex,'varSort,'var,'opSym)qAbs \\<Rightarrow> ('index,'bindex)tree\"\nwhere\n\"qSkel (qVar xs x) = Branch (\\<lambda>i. None) (\\<lambda>i. None)\"\n|\n\"qSkel (qOp delta inp binp) = Branch (lift qSkel inp) (lift qSkelAbs binp)\"\n|\n\"qSkelAbs (qAbs xs x X) = Branch (\\<lambda>i. Some(qSkel X)) (\\<lambda>i. None)\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>xs xa. x = termIn (qVar xs xa) \\<Longrightarrow> P;\n        \\<And>delta inp binp.\n           x = termIn (qOp delta inp binp) \\<Longrightarrow> P;\n        \\<And>xs xa X. x = absIn (qAbs xs xa X) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>xs x xsa xa.\n       termIn (qVar xs x) = termIn (qVar xsa xa) \\<Longrightarrow>\n       Branch Map.empty Map.empty = Branch Map.empty Map.empty\n 3. \\<And>xs x delta inp binp.\n       termIn (qVar xs x) = termIn (qOp delta inp binp) \\<Longrightarrow>\n       Branch Map.empty Map.empty =\n       Branch (lift (\\<lambda>x0. qSkel_qSkelAbs_sumC (termIn x0)) inp)\n        (lift (\\<lambda>x0. qSkel_qSkelAbs_sumC (absIn x0)) binp)\n 4. \\<And>xs x xsa xa X.\n       termIn (qVar xs x) = absIn (qAbs xsa xa X) \\<Longrightarrow>\n       Branch Map.empty Map.empty =\n       Branch (\\<lambda>i. Some (qSkel_qSkelAbs_sumC (termIn X))) Map.empty\n 5. \\<And>delta inp binp deltaa inpa binpa.\n       termIn (qOp delta inp binp) =\n       termIn (qOp deltaa inpa binpa) \\<Longrightarrow>\n       Branch (lift (\\<lambda>x0. qSkel_qSkelAbs_sumC (termIn x0)) inp)\n        (lift (\\<lambda>x0. qSkel_qSkelAbs_sumC (absIn x0)) binp) =\n       Branch (lift (\\<lambda>x0. qSkel_qSkelAbs_sumC (termIn x0)) inpa)\n        (lift (\\<lambda>x0. qSkel_qSkelAbs_sumC (absIn x0)) binpa)\n 6. \\<And>delta inp binp xs x X.\n       termIn (qOp delta inp binp) = absIn (qAbs xs x X) \\<Longrightarrow>\n       Branch (lift (\\<lambda>x0. qSkel_qSkelAbs_sumC (termIn x0)) inp)\n        (lift (\\<lambda>x0. qSkel_qSkelAbs_sumC (absIn x0)) binp) =\n       Branch (\\<lambda>i. Some (qSkel_qSkelAbs_sumC (termIn X))) Map.empty\n 7. \\<And>xs x X xsa xa Xa.\n       absIn (qAbs xs x X) = absIn (qAbs xsa xa Xa) \\<Longrightarrow>\n       Branch (\\<lambda>i. Some (qSkel_qSkelAbs_sumC (termIn X)))\n        Map.empty =\n       Branch (\\<lambda>i. Some (qSkel_qSkelAbs_sumC (termIn Xa))) Map.empty", "by(pat_completeness, auto)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All qSkel_qSkelAbs_dom", "by(relation qTermLess, simp add: qTermLess_wf, auto simp add: qTermLess_def)"], ["", "text\\<open>Next is a template for generating induction principles whenever we come up\n  with relation on terms included in the kernel of the skeleton operator.\\<close>"], ["", "lemma qTerm_templateInduct[case_names Var Op Abs]:\nfixes X :: \"('index,'bindex,'varSort,'var,'opSym)qTerm\"\nand A :: \"('index,'bindex,'varSort,'var,'opSym)qAbs\"\nand phi phiAbs and rel\nassumes\nREL: \"\\<And> X Y. (X,Y) \\<in> rel \\<Longrightarrow> qSkel Y = qSkel X\" and\nVar: \"\\<And> xs x. phi (qVar xs x)\" and\nOp: \"\\<And> delta inp binp. \\<lbrakk>liftAll phi inp; liftAll phiAbs binp\\<rbrakk>\n                       \\<Longrightarrow> phi (qOp delta inp binp)\" and\nAbs: \"\\<And> xs x X. (\\<And> Y. (X,Y) \\<in> rel \\<Longrightarrow> phi Y) \\<Longrightarrow> phiAbs (qAbs xs x X)\"\nshows \"phi X \\<and> phiAbs A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phi X \\<and> phiAbs A", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. phi X \\<and> phiAbs A", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. phi X \\<and> phiAbs A", "fix T"], ["proof (state)\ngoal (1 subgoal):\n 1. phi X \\<and> phiAbs A", "have \"\\<forall> X A. (T = qSkel X \\<longrightarrow> phi X) \\<and> (T = qSkelAbs A \\<longrightarrow> phiAbs A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X A.\n       (T = qSkel X \\<longrightarrow> phi X) \\<and>\n       (T = qSkelAbs A \\<longrightarrow> phiAbs A)", "proof(induct rule: treeLess_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T'.\n       (\\<And>T.\n           (T, T') \\<in> treeLess \\<Longrightarrow>\n           \\<forall>X A.\n              (T = qSkel X \\<longrightarrow> phi X) \\<and>\n              (T = qSkelAbs A \\<longrightarrow> phiAbs A)) \\<Longrightarrow>\n       \\<forall>X A.\n          (T' = qSkel X \\<longrightarrow> phi X) \\<and>\n          (T' = qSkelAbs A \\<longrightarrow> phiAbs A)", "case (1 T')"], ["proof (state)\nthis:\n  (?T, T') \\<in> treeLess \\<Longrightarrow>\n  \\<forall>X A.\n     (?T = qSkel X \\<longrightarrow> phi X) \\<and>\n     (?T = qSkelAbs A \\<longrightarrow> phiAbs A)\n\ngoal (1 subgoal):\n 1. \\<And>T'.\n       (\\<And>T.\n           (T, T') \\<in> treeLess \\<Longrightarrow>\n           \\<forall>X A.\n              (T = qSkel X \\<longrightarrow> phi X) \\<and>\n              (T = qSkelAbs A \\<longrightarrow> phiAbs A)) \\<Longrightarrow>\n       \\<forall>X A.\n          (T' = qSkel X \\<longrightarrow> phi X) \\<and>\n          (T' = qSkelAbs A \\<longrightarrow> phiAbs A)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X A.\n       (T' = qSkel X \\<longrightarrow> phi X) \\<and>\n       (T' = qSkelAbs A \\<longrightarrow> phiAbs A)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X A. T' = qSkel X \\<Longrightarrow> phi X\n 2. \\<And>X A. T' = qSkelAbs A \\<Longrightarrow> phiAbs A", "subgoal for X _"], ["proof (prove)\ngoal (1 subgoal):\n 1. T' = qSkel X \\<Longrightarrow> phi X", "using assms 1"], ["proof (prove)\nusing this:\n  (?X, ?Y) \\<in> rel \\<Longrightarrow> qSkel ?Y = qSkel ?X\n  phi (qVar ?xs ?x)\n  \\<lbrakk>liftAll phi ?inp; liftAll phiAbs ?binp\\<rbrakk>\n  \\<Longrightarrow> phi (qOp ?delta ?inp ?binp)\n  (\\<And>Y. (?X, Y) \\<in> rel \\<Longrightarrow> phi Y) \\<Longrightarrow>\n  phiAbs (qAbs ?xs ?x ?X)\n  (?T, T') \\<in> treeLess \\<Longrightarrow>\n  \\<forall>X A.\n     (?T = qSkel X \\<longrightarrow> phi X) \\<and>\n     (?T = qSkelAbs A \\<longrightarrow> phiAbs A)\n\ngoal (1 subgoal):\n 1. T' = qSkel X \\<Longrightarrow> phi X", "unfolding treeLess_def liftAll_def"], ["proof (prove)\nusing this:\n  (?X, ?Y) \\<in> rel \\<Longrightarrow> qSkel ?Y = qSkel ?X\n  phi (qVar ?xs ?x)\n  \\<lbrakk>\\<forall>i v. ?inp i = Some v \\<longrightarrow> phi v;\n   \\<forall>i v. ?binp i = Some v \\<longrightarrow> phiAbs v\\<rbrakk>\n  \\<Longrightarrow> phi (qOp ?delta ?inp ?binp)\n  (\\<And>Y. (?X, Y) \\<in> rel \\<Longrightarrow> phi Y) \\<Longrightarrow>\n  phiAbs (qAbs ?xs ?x ?X)\n  (?T, T')\n  \\<in> {(T, T').\n         \\<exists>inp binp i j.\n            T' = Branch inp binp \\<and>\n            (inp i = Some T \\<or> binp j = Some T)} \\<Longrightarrow>\n  \\<forall>X A.\n     (?T = qSkel X \\<longrightarrow> phi X) \\<and>\n     (?T = qSkelAbs A \\<longrightarrow> phiAbs A)\n\ngoal (1 subgoal):\n 1. T' = qSkel X \\<Longrightarrow> phi X", "by (cases X) (auto simp add: lift_def, metis option.simps(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X A. T' = qSkelAbs A \\<Longrightarrow> phiAbs A", "subgoal for _ A"], ["proof (prove)\ngoal (1 subgoal):\n 1. T' = qSkelAbs A \\<Longrightarrow> phiAbs A", "apply (cases A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>T' = qSkelAbs A; A = qAbs x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> phiAbs A", "using assms 1"], ["proof (prove)\nusing this:\n  (?X, ?Y) \\<in> rel \\<Longrightarrow> qSkel ?Y = qSkel ?X\n  phi (qVar ?xs ?x)\n  \\<lbrakk>liftAll phi ?inp; liftAll phiAbs ?binp\\<rbrakk>\n  \\<Longrightarrow> phi (qOp ?delta ?inp ?binp)\n  (\\<And>Y. (?X, Y) \\<in> rel \\<Longrightarrow> phi Y) \\<Longrightarrow>\n  phiAbs (qAbs ?xs ?x ?X)\n  (?T, T') \\<in> treeLess \\<Longrightarrow>\n  \\<forall>X A.\n     (?T = qSkel X \\<longrightarrow> phi X) \\<and>\n     (?T = qSkelAbs A \\<longrightarrow> phiAbs A)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>T' = qSkelAbs A; A = qAbs x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> phiAbs A", "unfolding treeLess_def"], ["proof (prove)\nusing this:\n  (?X, ?Y) \\<in> rel \\<Longrightarrow> qSkel ?Y = qSkel ?X\n  phi (qVar ?xs ?x)\n  \\<lbrakk>liftAll phi ?inp; liftAll phiAbs ?binp\\<rbrakk>\n  \\<Longrightarrow> phi (qOp ?delta ?inp ?binp)\n  (\\<And>Y. (?X, Y) \\<in> rel \\<Longrightarrow> phi Y) \\<Longrightarrow>\n  phiAbs (qAbs ?xs ?x ?X)\n  (?T, T')\n  \\<in> {(T, T').\n         \\<exists>inp binp i j.\n            T' = Branch inp binp \\<and>\n            (inp i = Some T \\<or> binp j = Some T)} \\<Longrightarrow>\n  \\<forall>X A.\n     (?T = qSkel X \\<longrightarrow> phi X) \\<and>\n     (?T = qSkelAbs A \\<longrightarrow> phiAbs A)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>T' = qSkelAbs A; A = qAbs x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> phiAbs A", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\nthis:\n  \\<forall>X A.\n     (T' = qSkel X \\<longrightarrow> phi X) \\<and>\n     (T' = qSkelAbs A \\<longrightarrow> phiAbs A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>X A.\n     (T = qSkel X \\<longrightarrow> phi X) \\<and>\n     (T = qSkelAbs A \\<longrightarrow> phiAbs A)\n\ngoal (1 subgoal):\n 1. phi X \\<and> phiAbs A", "}"], ["proof (state)\nthis:\n  \\<forall>X A.\n     (?T2 = qSkel X \\<longrightarrow> phi X) \\<and>\n     (?T2 = qSkelAbs A \\<longrightarrow> phiAbs A)\n\ngoal (1 subgoal):\n 1. phi X \\<and> phiAbs A", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>X A.\n     (?T2 = qSkel X \\<longrightarrow> phi X) \\<and>\n     (?T2 = qSkelAbs A \\<longrightarrow> phiAbs A)\n\ngoal (1 subgoal):\n 1. phi X \\<and> phiAbs A", "by blast"], ["proof (state)\nthis:\n  phi X \\<and> phiAbs A\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>A modification of the canonical immediate-subterm\nrelation on quasi-terms, that takes into account a relation assumed included in the skeleton kernel.\\<close>"], ["", "definition qTermLess_modulo ::\n\"('index,'bindex,'varSort,'var,'opSym)qTerm rel \\<Rightarrow>\n ('index,'bindex,'varSort,'var,'opSym)qTermItem rel\"\nwhere\n\"qTermLess_modulo rel ==\n {(termIn X, termIn(qOp delta inp binp))| X delta inp binp i. inp i = Some X} \\<union>\n {(absIn A, termIn(qOp delta inp binp))| A delta inp binp j. binp j = Some A} \\<union>\n {(termIn Y, absIn (qAbs xs x X))| X Y xs x. (X,Y) \\<in> rel}\""], ["", "lemma qTermLess_modulo_wf:\nfixes rel::\"('index,'bindex,'varSort,'var,'opSym)qTerm rel\"\nassumes \"\\<And> X Y. (X,Y) \\<in> rel \\<Longrightarrow> qSkel Y = qSkel X\"\nshows \"wf (qTermLess_modulo rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (qTermLess_modulo rel)", "proof(unfold wf_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> qTermLess_modulo rel \\<longrightarrow>\n              P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P x", "fix chi item"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> qTermLess_modulo rel \\<longrightarrow>\n              P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P x", "assume *:\n  \"\\<forall>item. (\\<forall>item'. (item', item) \\<in> qTermLess_modulo rel  \\<longrightarrow> chi item')\n           \\<longrightarrow> chi item\""], ["proof (state)\nthis:\n  \\<forall>item.\n     (\\<forall>item'.\n         (item', item) \\<in> qTermLess_modulo rel \\<longrightarrow>\n         chi item') \\<longrightarrow>\n     chi item\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> qTermLess_modulo rel \\<longrightarrow>\n              P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P x", "show \"chi item\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chi item", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. chi item", "obtain phi where phi_def: \"phi = (\\<lambda> X. chi (termIn X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>phi.\n        phi = (\\<lambda>X. chi (termIn X)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  phi = (\\<lambda>X. chi (termIn X))\n\ngoal (1 subgoal):\n 1. chi item", "obtain phiAbs where phiAbs_def: \"phiAbs = (\\<lambda> A. chi (absIn A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>phiAbs.\n        phiAbs = (\\<lambda>A. chi (absIn A)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  phiAbs = (\\<lambda>A. chi (absIn A))\n\ngoal (1 subgoal):\n 1. chi item", "{"], ["proof (state)\nthis:\n  phiAbs = (\\<lambda>A. chi (absIn A))\n\ngoal (1 subgoal):\n 1. chi item", "fix X A"], ["proof (state)\ngoal (1 subgoal):\n 1. chi item", "have \"chi (termIn X) \\<and> chi (absIn A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chi (termIn X) \\<and> chi (absIn A)", "apply(induct rule: qTerm_templateInduct[of rel])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>X Y. (X, Y) \\<in> rel \\<Longrightarrow> qSkel Y = qSkel X\n 2. \\<And>xs x. chi (termIn (qVar xs x))\n 3. \\<And>delta inp binp.\n       \\<lbrakk>liftAll (\\<lambda>a. chi (termIn a)) inp;\n        liftAll (\\<lambda>a. chi (absIn a)) binp\\<rbrakk>\n       \\<Longrightarrow> chi (termIn (qOp delta inp binp))\n 4. \\<And>xs x X.\n       (\\<And>Y.\n           (X, Y) \\<in> rel \\<Longrightarrow>\n           chi (termIn Y)) \\<Longrightarrow>\n       chi (absIn (qAbs xs x X))", "using * assms"], ["proof (prove)\nusing this:\n  \\<forall>item.\n     (\\<forall>item'.\n         (item', item) \\<in> qTermLess_modulo rel \\<longrightarrow>\n         chi item') \\<longrightarrow>\n     chi item\n  (?X, ?Y) \\<in> rel \\<Longrightarrow> qSkel ?Y = qSkel ?X\n\ngoal (4 subgoals):\n 1. \\<And>X Y. (X, Y) \\<in> rel \\<Longrightarrow> qSkel Y = qSkel X\n 2. \\<And>xs x. chi (termIn (qVar xs x))\n 3. \\<And>delta inp binp.\n       \\<lbrakk>liftAll (\\<lambda>a. chi (termIn a)) inp;\n        liftAll (\\<lambda>a. chi (absIn a)) binp\\<rbrakk>\n       \\<Longrightarrow> chi (termIn (qOp delta inp binp))\n 4. \\<And>xs x X.\n       (\\<And>Y.\n           (X, Y) \\<in> rel \\<Longrightarrow>\n           chi (termIn Y)) \\<Longrightarrow>\n       chi (absIn (qAbs xs x X))", "unfolding qTermLess_modulo_def liftAll_def"], ["proof (prove)\nusing this:\n  \\<forall>item.\n     (\\<forall>item'.\n         (item', item)\n         \\<in> {uu_.\n                \\<exists>X delta inp binp i.\n                   uu_ = (termIn X, termIn (qOp delta inp binp)) \\<and>\n                   inp i = Some X} \\<union>\n               {uu_.\n                \\<exists>A delta inp binp j.\n                   uu_ = (absIn A, termIn (qOp delta inp binp)) \\<and>\n                   binp j = Some A} \\<union>\n               {(termIn Y, absIn (qAbs xs x X)) |X Y xs x.\n                (X, Y) \\<in> rel} \\<longrightarrow>\n         chi item') \\<longrightarrow>\n     chi item\n  (?X, ?Y) \\<in> rel \\<Longrightarrow> qSkel ?Y = qSkel ?X\n\ngoal (4 subgoals):\n 1. \\<And>X Y. (X, Y) \\<in> rel \\<Longrightarrow> qSkel Y = qSkel X\n 2. \\<And>xs x. chi (termIn (qVar xs x))\n 3. \\<And>delta inp binp.\n       \\<lbrakk>\\<forall>i v.\n                   inp i = Some v \\<longrightarrow> chi (termIn v);\n        \\<forall>i v.\n           binp i = Some v \\<longrightarrow> chi (absIn v)\\<rbrakk>\n       \\<Longrightarrow> chi (termIn (qOp delta inp binp))\n 4. \\<And>xs x X.\n       (\\<And>Y.\n           (X, Y) \\<in> rel \\<Longrightarrow>\n           chi (termIn Y)) \\<Longrightarrow>\n       chi (absIn (qAbs xs x X))", "by blast+"], ["proof (state)\nthis:\n  chi (termIn X) \\<and> chi (absIn A)\n\ngoal (1 subgoal):\n 1. chi item", "}"], ["proof (state)\nthis:\n  chi (termIn ?X2) \\<and> chi (absIn ?A2)\n\ngoal (1 subgoal):\n 1. chi item", "thus ?thesis"], ["proof (prove)\nusing this:\n  chi (termIn ?X2) \\<and> chi (absIn ?A2)\n\ngoal (1 subgoal):\n 1. chi item", "unfolding phi_def phiAbs_def"], ["proof (prove)\nusing this:\n  chi (termIn ?X2) \\<and> chi (absIn ?A2)\n\ngoal (1 subgoal):\n 1. chi item", "by(cases item, auto)"], ["proof (state)\nthis:\n  chi item\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chi item\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Swap and substitution on variables\\<close>"], ["", "definition sw :: \"'varSort \\<Rightarrow> 'var \\<Rightarrow> 'var \\<Rightarrow> 'varSort \\<Rightarrow> 'var \\<Rightarrow> 'var\"\nwhere\n\"sw ys y1 y2 xs x ==\n if ys = xs then if x = y1 then y2\n            else if x = y2 then y1\n                           else x\n else x\""], ["", "abbreviation sw_abbrev :: \"'var \\<Rightarrow> 'varSort \\<Rightarrow> 'var \\<Rightarrow> 'var \\<Rightarrow> 'varSort \\<Rightarrow> 'var\"\n(\"_ @_[_ \\<and> _]'__\" 200)\nwhere \"(x @xs[y1 \\<and> y2]_ys) == sw ys y1 y2 xs x\""], ["", "definition sb :: \"'varSort \\<Rightarrow> 'var \\<Rightarrow> 'var \\<Rightarrow> 'varSort \\<Rightarrow> 'var \\<Rightarrow> 'var\"\nwhere\n\"sb ys y1 y2 xs x ==\n if ys = xs then if x = y2 then y1\n                           else x\n else x\""], ["", "abbreviation sb_abbrev :: \"'var \\<Rightarrow> 'varSort \\<Rightarrow> 'var \\<Rightarrow> 'var \\<Rightarrow> 'varSort \\<Rightarrow> 'var\"\n(\"_ @_[_ '/ _]'__\" 200)\nwhere \"(x @xs[y1 / y2]_ys) == sb ys y1 y2 xs x\""], ["", "theorem sw_simps1[simp]: \"(x @xs[x \\<and> y]_xs) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x @xs[x \\<and> y]_xs = y", "unfolding sw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if xs = xs then if x = x then y else if x = y then x else x else x) = y", "by simp"], ["", "theorem sw_simps2[simp]: \"(x @xs[y \\<and> x]_xs) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x @xs[y \\<and> x]_xs = y", "unfolding sw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if xs = xs then if x = y then x else if x = x then y else x else x) = y", "by simp"], ["", "theorem sw_simps3[simp]:\n\"(zs \\<noteq> xs \\<or> x \\<notin> {z1,z2}) \\<Longrightarrow> (x @xs[z1 \\<and> z2]_zs) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zs \\<noteq> xs \\<or> x \\<notin> {z1, z2} \\<Longrightarrow>\n    x @xs[z1 \\<and> z2]_zs = x", "unfolding sw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. zs \\<noteq> xs \\<or> x \\<notin> {z1, z2} \\<Longrightarrow>\n    (if zs = xs then if x = z1 then z2 else if x = z2 then z1 else x\n     else x) =\n    x", "by simp"], ["", "lemmas sw_simps = sw_simps1 sw_simps2 sw_simps3"], ["", "theorem sw_ident[simp]: \"(x @xs[y \\<and> y]_ys) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x @xs[y \\<and> y]_ys = x", "unfolding sw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ys = xs then if x = y then y else if x = y then y else x else x) = x", "by auto"], ["", "theorem sw_compose:\n\"((z @zs[x \\<and> y]_xs) @zs[x' \\<and> y']_xs') =\n ((z @zs[x' \\<and> y']_xs') @zs[(x @xs[x' \\<and> y']_xs') \\<and> (y @xs[x' \\<and> y']_xs')]_xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z @zs[x \\<and> y]_xs @zs[x' \\<and> y']_xs' =\n    z @zs[x' \\<and> y']_xs' @zs[x @xs[x' \\<and> y']_xs' \\<and> y @xs[x' \\<and> y']_xs']_xs", "by(unfold sw_def, auto)"], ["", "theorem sw_commute:\nassumes \"zs \\<noteq> zs' \\<or> {x,y} Int {x',y'} = {}\"\nshows \"((u @us[x \\<and> y]_zs) @us[x' \\<and> y']_zs') = ((u @us[x' \\<and> y']_zs') @us[x \\<and> y]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u @us[x \\<and> y]_zs @us[x' \\<and> y']_zs' =\n    u @us[x' \\<and> y']_zs' @us[x \\<and> y]_zs", "using assms"], ["proof (prove)\nusing this:\n  zs \\<noteq> zs' \\<or> {x, y} \\<inter> {x', y'} = {}\n\ngoal (1 subgoal):\n 1. u @us[x \\<and> y]_zs @us[x' \\<and> y']_zs' =\n    u @us[x' \\<and> y']_zs' @us[x \\<and> y]_zs", "by(unfold sw_def, auto)"], ["", "theorem sw_involutive[simp]:\n\"((z @zs[x \\<and> y]_xs) @zs[x \\<and> y]_xs) = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z @zs[x \\<and> y]_xs @zs[x \\<and> y]_xs = z", "by(unfold sw_def, auto)"], ["", "theorem sw_inj[simp]:\n\"((z @zs[x \\<and> y]_xs) = (z' @zs[x \\<and> y]_xs)) = (z = z')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z @zs[x \\<and> y]_xs = z' @zs[x \\<and> y]_xs) = (z = z')", "by (simp add: sw_def)"], ["", "lemma sw_preserves_mship[simp]:\nassumes \"{y1,y2} \\<subseteq> Var ys\"\nshows \"((x @xs[y1 \\<and> y2]_ys) \\<in> Var xs) = (x \\<in> Var xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x @xs[y1 \\<and> y2]_ys \\<in> Var xs) = (x \\<in> Var xs)", "using assms"], ["proof (prove)\nusing this:\n  {y1, y2} \\<subseteq> Var ys\n\ngoal (1 subgoal):\n 1. (x @xs[y1 \\<and> y2]_ys \\<in> Var xs) = (x \\<in> Var xs)", "unfolding sw_def"], ["proof (prove)\nusing this:\n  {y1, y2} \\<subseteq> Var ys\n\ngoal (1 subgoal):\n 1. ((if ys = xs then if x = y1 then y2 else if x = y2 then y1 else x\n      else x)\n     \\<in> Var xs) =\n    (x \\<in> Var xs)", "by auto"], ["", "theorem sw_sym:\n\"(z @zs[x \\<and> y]_xs) = (z @zs[y \\<and> x]_xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z @zs[x \\<and> y]_xs = z @zs[y \\<and> x]_xs", "by (unfold sw_def) auto"], ["", "theorem sw_involutive2[simp]:\n\"((z @zs[x \\<and> y]_xs) @zs[y \\<and> x]_xs) = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z @zs[x \\<and> y]_xs @zs[y \\<and> x]_xs = z", "by (unfold sw_def) auto"], ["", "theorem sw_trans:\n\"us \\<noteq> zs \\<or> u \\<notin> {y,z} \\<Longrightarrow>\n ((u @us[y \\<and> x]_zs) @us[z \\<and> y]_zs) = (u @us[z \\<and> x]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<noteq> zs \\<or> u \\<notin> {y, z} \\<Longrightarrow>\n    u @us[y \\<and> x]_zs @us[z \\<and> y]_zs = u @us[z \\<and> x]_zs", "by (unfold sw_def) auto"], ["", "lemmas sw_otherSimps =\nsw_ident sw_involutive sw_inj sw_preserves_mship sw_involutive2"], ["", "theorem sb_simps1[simp]: \"(x @xs[y / x]_xs) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x @xs[y / x]_xs = y", "unfolding sb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if xs = xs then if x = x then y else x else x) = y", "by simp"], ["", "theorem sb_simps2[simp]:\n\"(zs \\<noteq> xs \\<or> z2 \\<noteq> x) \\<Longrightarrow> (x @xs[z1 / z2]_zs) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zs \\<noteq> xs \\<or> z2 \\<noteq> x \\<Longrightarrow>\n    x @xs[z1 / z2]_zs = x", "unfolding sb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. zs \\<noteq> xs \\<or> z2 \\<noteq> x \\<Longrightarrow>\n    (if zs = xs then if x = z2 then z1 else x else x) = x", "by auto"], ["", "lemmas sb_simps = sb_simps1 sb_simps2"], ["", "theorem sb_ident[simp]: \"(x @xs[y / y]_ys) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x @xs[y / y]_ys = x", "unfolding sb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ys = xs then if x = y then y else x else x) = x", "by auto"], ["", "theorem sb_compose1:\n\"((z @zs[y1 / x]_xs) @zs[y2 / x]_xs) = (z @zs[(y1 @xs[y2 / x]_xs) / x]_xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z @zs[y1 / x]_xs @zs[y2 / x]_xs = z @zs[y1 @xs[y2 / x]_xs / x]_xs", "by(unfold sb_def, auto)"], ["", "theorem sb_compose2:\n\"ys \\<noteq> xs \\<or> (x2 \\<notin> {y1,y2}) \\<Longrightarrow>\n ((z @zs[x1 / x2]_xs) @zs[y1 / y2]_ys) =\n ((z @zs[y1 / y2]_ys) @zs[(x1 @xs[y1 / y2]_ys) / x2]_xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<noteq> xs \\<or> x2 \\<notin> {y1, y2} \\<Longrightarrow>\n    z @zs[x1 / x2]_xs @zs[y1 / y2]_ys =\n    z @zs[y1 / y2]_ys @zs[x1 @xs[y1 / y2]_ys / x2]_xs", "by (unfold sb_def) auto"], ["", "theorem sb_commute:\nassumes \"zs \\<noteq> zs' \\<or> {x,y} Int {x',y'} = {}\"\nshows \"((u @us[x / y]_zs) @us[x' / y']_zs') = ((u @us[x' / y']_zs') @us[x / y]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u @us[x / y]_zs @us[x' / y']_zs' = u @us[x' / y']_zs' @us[x / y]_zs", "using assms"], ["proof (prove)\nusing this:\n  zs \\<noteq> zs' \\<or> {x, y} \\<inter> {x', y'} = {}\n\ngoal (1 subgoal):\n 1. u @us[x / y]_zs @us[x' / y']_zs' = u @us[x' / y']_zs' @us[x / y]_zs", "by (unfold sb_def) auto"], ["", "theorem sb_idem[simp]:\n\"((z @zs[x / y]_xs) @zs[x / y]_xs) = (z @zs[x / y]_xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z @zs[x / y]_xs @zs[x / y]_xs = z @zs[x / y]_xs", "by (unfold sb_def) auto"], ["", "lemma sb_preserves_mship[simp]:\nassumes \"{y1,y2} \\<subseteq> Var ys\"\nshows \"((x @xs[y1 / y2]_ys) \\<in> Var xs) = (x \\<in> Var xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x @xs[y1 / y2]_ys \\<in> Var xs) = (x \\<in> Var xs)", "using assms"], ["proof (prove)\nusing this:\n  {y1, y2} \\<subseteq> Var ys\n\ngoal (1 subgoal):\n 1. (x @xs[y1 / y2]_ys \\<in> Var xs) = (x \\<in> Var xs)", "by (unfold sb_def) auto"], ["", "theorem sb_trans:\n\"us \\<noteq> zs \\<or> u \\<noteq> y \\<Longrightarrow>\n ((u @us[y / x]_zs) @us[z / y]_zs) = (u @us[z / x]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<noteq> zs \\<or> u \\<noteq> y \\<Longrightarrow>\n    u @us[y / x]_zs @us[z / y]_zs = u @us[z / x]_zs", "by (unfold sb_def) auto"], ["", "lemmas sb_otherSimps =\nsb_ident sb_idem sb_preserves_mship"], ["", "subsection \\<open>The swapping and freshness operators\\<close>"], ["", "text \\<open>For establishing the preliminary results quickly, we use both the notion of\nbinding-sensitive freshness (operator ``qFresh\")\n       and that of ``absolute\" freshness, ignoring bindings (operator ``qAFresh\").  Later,\n       for alpha-equivalence classes, ``qAFresh\" will not make sense.\\<close>"], ["", "definition\naux_qSwap_ignoreFirst3 ::\n\"'varSort * 'var * 'var * ('index,'bindex,'varSort,'var,'opSym)qTerm +\n 'varSort * 'var * 'var * ('index,'bindex,'varSort,'var,'opSym)qAbs \\<Rightarrow>\n ('index,'bindex,'varSort,'var,'opSym)qTermItem\"\nwhere\n\"aux_qSwap_ignoreFirst3 K =\n (case K of Inl(zs,x,y,X) \\<Rightarrow> termIn X\n           |Inr(zs,x,y,A) \\<Rightarrow> absIn A)\""], ["", "lemma qTermLess_ingoreFirst3_wf:\n\"wf(inv_image qTermLess aux_qSwap_ignoreFirst3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image qTermLess aux_qSwap_ignoreFirst3)", "using qTermLess_wf wf_inv_image"], ["proof (prove)\nusing this:\n  wf qTermLess\n  wf ?r \\<Longrightarrow> wf (inv_image ?r ?f)\n\ngoal (1 subgoal):\n 1. wf (inv_image qTermLess aux_qSwap_ignoreFirst3)", "by auto"], ["", "function\nqSwap :: \"'varSort \\<Rightarrow> 'var \\<Rightarrow> 'var \\<Rightarrow> ('index,'bindex,'varSort,'var,'opSym)qTerm \\<Rightarrow>\n          ('index,'bindex,'varSort,'var,'opSym)qTerm\"\nand\nqSwapAbs :: \"'varSort \\<Rightarrow> 'var \\<Rightarrow> 'var \\<Rightarrow> ('index,'bindex,'varSort,'var,'opSym)qAbs \\<Rightarrow>\n             ('index,'bindex,'varSort,'var,'opSym)qAbs\"\nwhere\n\"qSwap zs x y (qVar zs' z) = qVar zs' (z @zs'[x \\<and> y]_zs)\"\n|\n\"qSwap zs x y (qOp delta inp binp) =\n qOp delta (lift (qSwap zs x y) inp) (lift (qSwapAbs zs x y) binp)\"\n|\n\"qSwapAbs zs x y (qAbs zs' z X) = qAbs zs' (z @zs'[x \\<and> y]_zs) (qSwap zs x y X)\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>zs xa y zs' z.\n                   x = Inl (zs, xa, y, qVar zs' z) \\<Longrightarrow> P;\n        \\<And>zs xa y delta inp binp.\n           x = Inl (zs, xa, y, qOp delta inp binp) \\<Longrightarrow> P;\n        \\<And>zs xa y zs' z X.\n           x = Inr (zs, xa, y, qAbs zs' z X) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>zs x y zs' z zsa xa ya zs'a za.\n       Inl (zs, x, y, qVar zs' z) =\n       Inl (zsa, xa, ya, qVar zs'a za) \\<Longrightarrow>\n       termIn (qVar zs' (z @zs'[x \\<and> y]_zs)) =\n       termIn (qVar zs'a (za @zs'a[xa \\<and> ya]_zsa))\n 3. \\<And>zs x y zs' z zsa xa ya delta inp binp.\n       Inl (zs, x, y, qVar zs' z) =\n       Inl (zsa, xa, ya, qOp delta inp binp) \\<Longrightarrow>\n       termIn (qVar zs' (z @zs'[x \\<and> y]_zs)) =\n       termIn\n        (qOp delta\n          (lift\n            (\\<lambda>x3.\n                projl (qSwap_qSwapAbs_sumC (Inl (zsa, xa, ya, x3))))\n            inp)\n          (lift\n            (\\<lambda>x3.\n                projr (qSwap_qSwapAbs_sumC (Inr (zsa, xa, ya, x3))))\n            binp))\n 4. \\<And>zs x y zs' z zsa xa ya zs'a za X.\n       Inl (zs, x, y, qVar zs' z) =\n       Inr (zsa, xa, ya, qAbs zs'a za X) \\<Longrightarrow>\n       termIn (qVar zs' (z @zs'[x \\<and> y]_zs)) =\n       absIn\n        (qAbs zs'a (za @zs'a[xa \\<and> ya]_zsa)\n          (projl (qSwap_qSwapAbs_sumC (Inl (zsa, xa, ya, X)))))\n 5. \\<And>zs x y delta inp binp zsa xa ya deltaa inpa binpa.\n       Inl (zs, x, y, qOp delta inp binp) =\n       Inl (zsa, xa, ya, qOp deltaa inpa binpa) \\<Longrightarrow>\n       termIn\n        (qOp delta\n          (lift\n            (\\<lambda>x3. projl (qSwap_qSwapAbs_sumC (Inl (zs, x, y, x3))))\n            inp)\n          (lift\n            (\\<lambda>x3. projr (qSwap_qSwapAbs_sumC (Inr (zs, x, y, x3))))\n            binp)) =\n       termIn\n        (qOp deltaa\n          (lift\n            (\\<lambda>x3.\n                projl (qSwap_qSwapAbs_sumC (Inl (zsa, xa, ya, x3))))\n            inpa)\n          (lift\n            (\\<lambda>x3.\n                projr (qSwap_qSwapAbs_sumC (Inr (zsa, xa, ya, x3))))\n            binpa))\n 6. \\<And>zs x y delta inp binp zsa xa ya zs' z X.\n       Inl (zs, x, y, qOp delta inp binp) =\n       Inr (zsa, xa, ya, qAbs zs' z X) \\<Longrightarrow>\n       termIn\n        (qOp delta\n          (lift\n            (\\<lambda>x3. projl (qSwap_qSwapAbs_sumC (Inl (zs, x, y, x3))))\n            inp)\n          (lift\n            (\\<lambda>x3. projr (qSwap_qSwapAbs_sumC (Inr (zs, x, y, x3))))\n            binp)) =\n       absIn\n        (qAbs zs' (z @zs'[xa \\<and> ya]_zsa)\n          (projl (qSwap_qSwapAbs_sumC (Inl (zsa, xa, ya, X)))))\n 7. \\<And>zs x y zs' z X zsa xa ya zs'a za Xa.\n       Inr (zs, x, y, qAbs zs' z X) =\n       Inr (zsa, xa, ya, qAbs zs'a za Xa) \\<Longrightarrow>\n       absIn\n        (qAbs zs' (z @zs'[x \\<and> y]_zs)\n          (projl (qSwap_qSwapAbs_sumC (Inl (zs, x, y, X))))) =\n       absIn\n        (qAbs zs'a (za @zs'a[xa \\<and> ya]_zsa)\n          (projl (qSwap_qSwapAbs_sumC (Inl (zsa, xa, ya, Xa)))))", "by(pat_completeness, auto)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All qSwap_qSwapAbs_dom", "by(relation \"inv_image qTermLess aux_qSwap_ignoreFirst3\",\n   simp add: qTermLess_ingoreFirst3_wf,\n   auto simp add: qTermLess_def aux_qSwap_ignoreFirst3_def)"], ["", "lemmas qSwapAll_simps = qSwap.simps qSwapAbs.simps"], ["", "abbreviation qSwap_abbrev ::\n  \"('index,'bindex,'varSort,'var,'opSym)qTerm \\<Rightarrow> 'var \\<Rightarrow> 'var \\<Rightarrow> 'varSort \\<Rightarrow>\n   ('index,'bindex,'varSort,'var,'opSym)qTerm\" (\"_ #[[_ \\<and> _]]'__\" 200)\nwhere \"(X #[[z1 \\<and> z2]]_zs) == qSwap zs z1 z2 X\""], ["", "abbreviation qSwapAbs_abbrev ::\n  \"('index,'bindex,'varSort,'var,'opSym)qAbs \\<Rightarrow> 'var \\<Rightarrow> 'var \\<Rightarrow> 'varSort \\<Rightarrow>\n   ('index,'bindex,'varSort,'var,'opSym)qAbs\" (\"_ $[[_ \\<and> _]]'__\" 200)\nwhere \"(A $[[z1 \\<and> z2]]_zs) == qSwapAbs zs z1 z2 A\""], ["", "definition\naux_qFresh_ignoreFirst2 ::\n\"'varSort * 'var * ('index,'bindex,'varSort,'var,'opSym)qTerm +\n 'varSort * 'var * ('index,'bindex,'varSort,'var,'opSym)qAbs \\<Rightarrow>\n ('index,'bindex,'varSort,'var,'opSym)qTermItem\"\nwhere\n\"aux_qFresh_ignoreFirst2 K =\n (case K of Inl(zs,x,X) \\<Rightarrow> termIn X\n           |Inr (zs,x,A) \\<Rightarrow> absIn A)\""], ["", "lemma qTermLess_ingoreFirst2_wf: \"wf(inv_image qTermLess aux_qFresh_ignoreFirst2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image qTermLess aux_qFresh_ignoreFirst2)", "using qTermLess_wf wf_inv_image"], ["proof (prove)\nusing this:\n  wf qTermLess\n  wf ?r \\<Longrightarrow> wf (inv_image ?r ?f)\n\ngoal (1 subgoal):\n 1. wf (inv_image qTermLess aux_qFresh_ignoreFirst2)", "by auto"], ["", "text\\<open>The quasi absolutely-fresh predicate:\n  (note that this is not an oxymoron: ``quasi\" refers\n   to being an operator on quasi-terms, and not on\nterms, i.e., on alpha-equivalence  classes;\n   ``absolutely'' refers to not ignoring bindings in the notion of freshness,\nand thus counting absolutely all the variables.\\<close>"], ["", "function\nqAFresh :: \"'varSort \\<Rightarrow> 'var \\<Rightarrow> ('index,'bindex,'varSort,'var,'opSym)qTerm \\<Rightarrow> bool\"\nand\nqAFreshAbs :: \"'varSort \\<Rightarrow> 'var \\<Rightarrow> ('index,'bindex,'varSort,'var,'opSym)qAbs \\<Rightarrow> bool\"\nwhere\n\"qAFresh xs x (qVar ys y) = (xs \\<noteq> ys \\<or> x \\<noteq> y)\"\n|\n\"qAFresh xs x (qOp delta inp binp) =\n (liftAll (qAFresh xs x) inp \\<and> liftAll (qAFreshAbs xs x) binp)\"\n|\n\"qAFreshAbs xs x (qAbs ys y X) = ((xs \\<noteq> ys \\<or> x \\<noteq> y) \\<and> qAFresh xs x X)\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>xs xa ys y.\n                   x = Inl (xs, xa, qVar ys y) \\<Longrightarrow> P;\n        \\<And>xs xa delta inp binp.\n           x = Inl (xs, xa, qOp delta inp binp) \\<Longrightarrow> P;\n        \\<And>xs xa ys y X.\n           x = Inr (xs, xa, qAbs ys y X) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>xs x ys y xsa xa ysa ya.\n       Inl (xs, x, qVar ys y) = Inl (xsa, xa, qVar ysa ya) \\<Longrightarrow>\n       (xs \\<noteq> ys \\<or> x \\<noteq> y) =\n       (xsa \\<noteq> ysa \\<or> xa \\<noteq> ya)\n 3. \\<And>xs x ys y xsa xa delta inp binp.\n       Inl (xs, x, qVar ys y) =\n       Inl (xsa, xa, qOp delta inp binp) \\<Longrightarrow>\n       (xs \\<noteq> ys \\<or> x \\<noteq> y) =\n       (liftAll (\\<lambda>x2. qAFresh_qAFreshAbs_sumC (Inl (xsa, xa, x2)))\n         inp \\<and>\n        liftAll (\\<lambda>x2. qAFresh_qAFreshAbs_sumC (Inr (xsa, xa, x2)))\n         binp)\n 4. \\<And>xs x ys y xsa xa ysa ya X.\n       Inl (xs, x, qVar ys y) =\n       Inr (xsa, xa, qAbs ysa ya X) \\<Longrightarrow>\n       (xs \\<noteq> ys \\<or> x \\<noteq> y) =\n       ((xsa \\<noteq> ysa \\<or> xa \\<noteq> ya) \\<and>\n        qAFresh_qAFreshAbs_sumC (Inl (xsa, xa, X)))\n 5. \\<And>xs x delta inp binp xsa xa deltaa inpa binpa.\n       Inl (xs, x, qOp delta inp binp) =\n       Inl (xsa, xa, qOp deltaa inpa binpa) \\<Longrightarrow>\n       (liftAll (\\<lambda>x2. qAFresh_qAFreshAbs_sumC (Inl (xs, x, x2)))\n         inp \\<and>\n        liftAll (\\<lambda>x2. qAFresh_qAFreshAbs_sumC (Inr (xs, x, x2)))\n         binp) =\n       (liftAll (\\<lambda>x2. qAFresh_qAFreshAbs_sumC (Inl (xsa, xa, x2)))\n         inpa \\<and>\n        liftAll (\\<lambda>x2. qAFresh_qAFreshAbs_sumC (Inr (xsa, xa, x2)))\n         binpa)\n 6. \\<And>xs x delta inp binp xsa xa ys y X.\n       Inl (xs, x, qOp delta inp binp) =\n       Inr (xsa, xa, qAbs ys y X) \\<Longrightarrow>\n       (liftAll (\\<lambda>x2. qAFresh_qAFreshAbs_sumC (Inl (xs, x, x2)))\n         inp \\<and>\n        liftAll (\\<lambda>x2. qAFresh_qAFreshAbs_sumC (Inr (xs, x, x2)))\n         binp) =\n       ((xsa \\<noteq> ys \\<or> xa \\<noteq> y) \\<and>\n        qAFresh_qAFreshAbs_sumC (Inl (xsa, xa, X)))\n 7. \\<And>xs x ys y X xsa xa ysa ya Xa.\n       Inr (xs, x, qAbs ys y X) =\n       Inr (xsa, xa, qAbs ysa ya Xa) \\<Longrightarrow>\n       ((xs \\<noteq> ys \\<or> x \\<noteq> y) \\<and>\n        qAFresh_qAFreshAbs_sumC (Inl (xs, x, X))) =\n       ((xsa \\<noteq> ysa \\<or> xa \\<noteq> ya) \\<and>\n        qAFresh_qAFreshAbs_sumC (Inl (xsa, xa, Xa)))", "by(pat_completeness, auto)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All qAFresh_qAFreshAbs_dom", "by(relation \"inv_image qTermLess aux_qFresh_ignoreFirst2\",\n   simp add: qTermLess_ingoreFirst2_wf,\n   auto simp add: qTermLess_def aux_qFresh_ignoreFirst2_def)"], ["", "lemmas qAFreshAll_simps = qAFresh.simps qAFreshAbs.simps"], ["", "text\\<open>The next is standard freshness -- note that its definition differs from that\nof absolute freshness only at the clause for abstractions.\\<close>"], ["", "function\nqFresh :: \"'varSort \\<Rightarrow> 'var \\<Rightarrow> ('index,'bindex,'varSort,'var,'opSym)qTerm \\<Rightarrow> bool\"\nand\nqFreshAbs :: \"'varSort \\<Rightarrow> 'var \\<Rightarrow> ('index,'bindex,'varSort,'var,'opSym)qAbs \\<Rightarrow> bool\"\nwhere\n\"qFresh xs x (qVar ys y) = (xs \\<noteq> ys \\<or> x \\<noteq> y)\"\n|\n\"qFresh xs x (qOp delta inp binp) =\n (liftAll (qFresh xs x) inp \\<and> liftAll (qFreshAbs xs x) binp)\"\n|\n\"qFreshAbs xs x (qAbs ys y X) = ((xs = ys \\<and> x = y) \\<or> qFresh xs x X)\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>xs xa ys y.\n                   x = Inl (xs, xa, qVar ys y) \\<Longrightarrow> P;\n        \\<And>xs xa delta inp binp.\n           x = Inl (xs, xa, qOp delta inp binp) \\<Longrightarrow> P;\n        \\<And>xs xa ys y X.\n           x = Inr (xs, xa, qAbs ys y X) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>xs x ys y xsa xa ysa ya.\n       Inl (xs, x, qVar ys y) = Inl (xsa, xa, qVar ysa ya) \\<Longrightarrow>\n       (xs \\<noteq> ys \\<or> x \\<noteq> y) =\n       (xsa \\<noteq> ysa \\<or> xa \\<noteq> ya)\n 3. \\<And>xs x ys y xsa xa delta inp binp.\n       Inl (xs, x, qVar ys y) =\n       Inl (xsa, xa, qOp delta inp binp) \\<Longrightarrow>\n       (xs \\<noteq> ys \\<or> x \\<noteq> y) =\n       (liftAll (\\<lambda>x2. qFresh_qFreshAbs_sumC (Inl (xsa, xa, x2)))\n         inp \\<and>\n        liftAll (\\<lambda>x2. qFresh_qFreshAbs_sumC (Inr (xsa, xa, x2)))\n         binp)\n 4. \\<And>xs x ys y xsa xa ysa ya X.\n       Inl (xs, x, qVar ys y) =\n       Inr (xsa, xa, qAbs ysa ya X) \\<Longrightarrow>\n       (xs \\<noteq> ys \\<or> x \\<noteq> y) =\n       (xsa = ysa \\<and> xa = ya \\<or>\n        qFresh_qFreshAbs_sumC (Inl (xsa, xa, X)))\n 5. \\<And>xs x delta inp binp xsa xa deltaa inpa binpa.\n       Inl (xs, x, qOp delta inp binp) =\n       Inl (xsa, xa, qOp deltaa inpa binpa) \\<Longrightarrow>\n       (liftAll (\\<lambda>x2. qFresh_qFreshAbs_sumC (Inl (xs, x, x2)))\n         inp \\<and>\n        liftAll (\\<lambda>x2. qFresh_qFreshAbs_sumC (Inr (xs, x, x2)))\n         binp) =\n       (liftAll (\\<lambda>x2. qFresh_qFreshAbs_sumC (Inl (xsa, xa, x2)))\n         inpa \\<and>\n        liftAll (\\<lambda>x2. qFresh_qFreshAbs_sumC (Inr (xsa, xa, x2)))\n         binpa)\n 6. \\<And>xs x delta inp binp xsa xa ys y X.\n       Inl (xs, x, qOp delta inp binp) =\n       Inr (xsa, xa, qAbs ys y X) \\<Longrightarrow>\n       (liftAll (\\<lambda>x2. qFresh_qFreshAbs_sumC (Inl (xs, x, x2)))\n         inp \\<and>\n        liftAll (\\<lambda>x2. qFresh_qFreshAbs_sumC (Inr (xs, x, x2)))\n         binp) =\n       (xsa = ys \\<and> xa = y \\<or>\n        qFresh_qFreshAbs_sumC (Inl (xsa, xa, X)))\n 7. \\<And>xs x ys y X xsa xa ysa ya Xa.\n       Inr (xs, x, qAbs ys y X) =\n       Inr (xsa, xa, qAbs ysa ya Xa) \\<Longrightarrow>\n       (xs = ys \\<and> x = y \\<or> qFresh_qFreshAbs_sumC (Inl (xs, x, X))) =\n       (xsa = ysa \\<and> xa = ya \\<or>\n        qFresh_qFreshAbs_sumC (Inl (xsa, xa, Xa)))", "by(pat_completeness, auto)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All qFresh_qFreshAbs_dom", "by(relation \"inv_image qTermLess aux_qFresh_ignoreFirst2\",\n   simp add: qTermLess_ingoreFirst2_wf,\n   auto simp add: qTermLess_def aux_qFresh_ignoreFirst2_def)"], ["", "lemmas qFreshAll_simps = qFresh.simps qFreshAbs.simps"], ["", "subsection \\<open>Compositional properties of swapping\\<close>"], ["", "lemma qSwapAll_ident:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\"\n    shows \"(X #[[x \\<and> x]]_zs) = X \\<and> (A $[[x \\<and> x]]_zs) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X #[[x \\<and> x]]_zs = X \\<and> A $[[x \\<and> x]]_zs = A", "by (induct rule: qTerm_rawInduct)\n     (auto simp add: liftAll_def lift_cong lift_ident)"], ["", "corollary qSwap_ident[simp]: \"(X #[[x \\<and> x]]_zs) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X #[[x \\<and> x]]_zs = X", "by(simp add: qSwapAll_ident)"], ["", "lemma qSwapAll_compose:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\"  and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\" and zs x y x' y'\nshows\n\"((X #[[x \\<and> y]]_zs) #[[x' \\<and> y']]_zs') =\n ((X #[[x' \\<and> y']]_zs') #[[(x @zs[x' \\<and> y']_zs') \\<and> (y @zs[x' \\<and> y']_zs')]]_zs)\n\\<and>\n ((A $[[x \\<and> y]]_zs) $[[x' \\<and> y']]_zs') =\n ((A $[[x' \\<and> y']]_zs') $[[(x @zs[x' \\<and> y']_zs') \\<and> (y @zs[x' \\<and> y']_zs')]]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n    X #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs \\<and>\n    A $[[x \\<and> y]]_zs $[[x' \\<and> y']]_zs' =\n    A $[[x' \\<and> y']]_zs' $[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs", "proof(induct rule: qTerm_rawInduct[of _ _ X A])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs xa.\n       qVar xs xa #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n       qVar xs\n        xa #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     a #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n                     a #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs)\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             a $[[x \\<and> y]]_zs $[[x' \\<and> y']]_zs' =\n             a $[[x' \\<and> y']]_zs' $[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs)\n         binp\\<rbrakk>\n       \\<Longrightarrow> qOp delta inp\n                          binp #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n                         qOp delta inp\n                          binp #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs\n 3. \\<And>xs xa X.\n       X #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n       X #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs \\<Longrightarrow>\n       qAbs xs xa X $[[x \\<and> y]]_zs $[[x' \\<and> y']]_zs' =\n       qAbs xs xa\n        X $[[x' \\<and> y']]_zs' $[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs", "case (Op delta inp binp)"], ["proof (state)\nthis:\n  liftAll\n   (\\<lambda>a.\n       a #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n       a #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs)\n   inp\n  liftAll\n   (\\<lambda>a.\n       a $[[x \\<and> y]]_zs $[[x' \\<and> y']]_zs' =\n       a $[[x' \\<and> y']]_zs' $[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs)\n   binp\n\ngoal (3 subgoals):\n 1. \\<And>xs xa.\n       qVar xs xa #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n       qVar xs\n        xa #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     a #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n                     a #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs)\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             a $[[x \\<and> y]]_zs $[[x' \\<and> y']]_zs' =\n             a $[[x' \\<and> y']]_zs' $[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs)\n         binp\\<rbrakk>\n       \\<Longrightarrow> qOp delta inp\n                          binp #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n                         qOp delta inp\n                          binp #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs\n 3. \\<And>xs xa X.\n       X #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n       X #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs \\<Longrightarrow>\n       qAbs xs xa X $[[x \\<and> y]]_zs $[[x' \\<and> y']]_zs' =\n       qAbs xs xa\n        X $[[x' \\<and> y']]_zs' $[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs", "then"], ["proof (chain)\npicking this:\n  liftAll\n   (\\<lambda>a.\n       a #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n       a #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs)\n   inp\n  liftAll\n   (\\<lambda>a.\n       a $[[x \\<and> y]]_zs $[[x' \\<and> y']]_zs' =\n       a $[[x' \\<and> y']]_zs' $[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs)\n   binp", "show ?case"], ["proof (prove)\nusing this:\n  liftAll\n   (\\<lambda>a.\n       a #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n       a #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs)\n   inp\n  liftAll\n   (\\<lambda>a.\n       a $[[x \\<and> y]]_zs $[[x' \\<and> y']]_zs' =\n       a $[[x' \\<and> y']]_zs' $[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs)\n   binp\n\ngoal (1 subgoal):\n 1. qOp delta inp binp #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n    qOp delta inp\n     binp #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs", "by (auto intro!: lift_cong simp: liftAll_def lift_comp)"], ["proof (state)\nthis:\n  qOp delta inp binp #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n  qOp delta inp\n   binp #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs\n\ngoal (2 subgoals):\n 1. \\<And>xs xa.\n       qVar xs xa #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n       qVar xs\n        xa #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs\n 2. \\<And>xs xa X.\n       X #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n       X #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs \\<Longrightarrow>\n       qAbs xs xa X $[[x \\<and> y]]_zs $[[x' \\<and> y']]_zs' =\n       qAbs xs xa\n        X $[[x' \\<and> y']]_zs' $[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs", "qed (auto simp add: sw_def sw_compose)"], ["", "corollary qSwap_compose:\n\"((X #[[x \\<and> y]]_zs) #[[x' \\<and> y']]_zs') =\n ((X #[[x' \\<and> y']]_zs') #[[(x @zs[x' \\<and> y']_zs') \\<and> (y @zs[x' \\<and> y']_zs')]]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n    X #[[x' \\<and> y']]_zs' #[[x @zs[x' \\<and> y']_zs' \\<and> y @zs[x' \\<and> y']_zs']]_zs", "by (meson qSwapAll_compose)"], ["", "lemma qSwap_commute:\nassumes \"zs \\<noteq> zs' \\<or> {x,y} Int {x',y'} = {}\"\nshows \"((X #[[x \\<and> y]]_zs) #[[x' \\<and> y']]_zs') = ((X #[[x' \\<and> y']]_zs') #[[x \\<and> y]]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X #[[x \\<and> y]]_zs #[[x' \\<and> y']]_zs' =\n    X #[[x' \\<and> y']]_zs' #[[x \\<and> y]]_zs", "by (metis assms disjoint_insert(1) qSwapAll_compose sw_simps3)"], ["", "lemma qSwapAll_involutive:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\" and zs x y\nshows \"((X #[[x \\<and> y]]_zs) #[[x \\<and> y]]_zs) = X \\<and>\n       ((A $[[x \\<and> y]]_zs) $[[x \\<and> y]]_zs) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs = X \\<and>\n    A $[[x \\<and> y]]_zs $[[x \\<and> y]]_zs = A", "proof(induct rule: qTerm_rawInduct[of _ _ X A])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs xa.\n       qVar xs xa #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs = qVar xs xa\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a. a #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs = a)\n                 inp;\n        liftAll (\\<lambda>a. a $[[x \\<and> y]]_zs $[[x \\<and> y]]_zs = a)\n         binp\\<rbrakk>\n       \\<Longrightarrow> qOp delta inp\n                          binp #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs =\n                         qOp delta inp binp\n 3. \\<And>xs xa X.\n       X #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs = X \\<Longrightarrow>\n       qAbs xs xa X $[[x \\<and> y]]_zs $[[x \\<and> y]]_zs = qAbs xs xa X", "case (Op delta inp binp)"], ["proof (state)\nthis:\n  liftAll (\\<lambda>a. a #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs = a) inp\n  liftAll (\\<lambda>a. a $[[x \\<and> y]]_zs $[[x \\<and> y]]_zs = a) binp\n\ngoal (3 subgoals):\n 1. \\<And>xs xa.\n       qVar xs xa #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs = qVar xs xa\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a. a #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs = a)\n                 inp;\n        liftAll (\\<lambda>a. a $[[x \\<and> y]]_zs $[[x \\<and> y]]_zs = a)\n         binp\\<rbrakk>\n       \\<Longrightarrow> qOp delta inp\n                          binp #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs =\n                         qOp delta inp binp\n 3. \\<And>xs xa X.\n       X #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs = X \\<Longrightarrow>\n       qAbs xs xa X $[[x \\<and> y]]_zs $[[x \\<and> y]]_zs = qAbs xs xa X", "then"], ["proof (chain)\npicking this:\n  liftAll (\\<lambda>a. a #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs = a) inp\n  liftAll (\\<lambda>a. a $[[x \\<and> y]]_zs $[[x \\<and> y]]_zs = a) binp", "show ?case"], ["proof (prove)\nusing this:\n  liftAll (\\<lambda>a. a #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs = a) inp\n  liftAll (\\<lambda>a. a $[[x \\<and> y]]_zs $[[x \\<and> y]]_zs = a) binp\n\ngoal (1 subgoal):\n 1. qOp delta inp binp #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs =\n    qOp delta inp binp", "unfolding qSwapAll_simps(2) liftAll_lift_ext\n    lift_comp o_def"], ["proof (prove)\nusing this:\n  lift (\\<lambda>a. a #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs) inp =\n  lift (\\<lambda>a. a) inp\n  lift (\\<lambda>a. a $[[x \\<and> y]]_zs $[[x \\<and> y]]_zs) binp =\n  lift (\\<lambda>a. a) binp\n\ngoal (1 subgoal):\n 1. qOp delta\n     (lift (\\<lambda>xa. xa #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs) inp)\n     (lift (\\<lambda>xa. xa $[[x \\<and> y]]_zs $[[x \\<and> y]]_zs) binp) =\n    qOp delta inp binp", "by (simp add: lift_ident)"], ["proof (state)\nthis:\n  qOp delta inp binp #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs =\n  qOp delta inp binp\n\ngoal (2 subgoals):\n 1. \\<And>xs xa.\n       qVar xs xa #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs = qVar xs xa\n 2. \\<And>xs xa X.\n       X #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs = X \\<Longrightarrow>\n       qAbs xs xa X $[[x \\<and> y]]_zs $[[x \\<and> y]]_zs = qAbs xs xa X", "qed(auto)"], ["", "corollary qSwap_involutive[simp]:\n\"((X #[[x \\<and> y]]_zs) #[[x \\<and> y]]_zs) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X #[[x \\<and> y]]_zs #[[x \\<and> y]]_zs = X", "by(simp add: qSwapAll_involutive)"], ["", "lemma qSwapAll_sym:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\" and zs x y\nshows \"(X #[[x \\<and> y]]_zs) = (X #[[y \\<and> x]]_zs) \\<and>\n       (A $[[x \\<and> y]]_zs) = (A $[[y \\<and> x]]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X #[[x \\<and> y]]_zs = X #[[y \\<and> x]]_zs \\<and>\n    A $[[x \\<and> y]]_zs = A $[[y \\<and> x]]_zs", "by (induct rule: qTerm_rawInduct[of _ _ X A])  \n   (auto simp: sw_sym lift_comp liftAll_lift_ext)"], ["", "corollary qSwap_sym:\n\"(X #[[x \\<and> y]]_zs) = (X #[[y \\<and> x]]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X #[[x \\<and> y]]_zs = X #[[y \\<and> x]]_zs", "by(simp add: qSwapAll_sym)"], ["", "lemma qAFreshAll_qSwapAll_id:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\" and zs z1 z2\nshows \"(qAFresh zs z1 X \\<and> qAFresh zs z2 X  \\<longrightarrow> (X #[[z1 \\<and> z2]]_zs) = X) \\<and>\n       (qAFreshAbs zs z1 A \\<and> qAFreshAbs zs z2 A  \\<longrightarrow> (A $[[z1 \\<and> z2]]_zs) = A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (qAFresh zs z1 X \\<and> qAFresh zs z2 X \\<longrightarrow>\n     X #[[z1 \\<and> z2]]_zs = X) \\<and>\n    (qAFreshAbs zs z1 A \\<and> qAFreshAbs zs z2 A \\<longrightarrow>\n     A $[[z1 \\<and> z2]]_zs = A)", "by (induct rule: qTerm_rawInduct[of _ _ X A])\n   (auto intro!: ext simp: liftAll_def lift_def option.case_eq_if)"], ["", "corollary qAFresh_qSwap_id[simp]:\n\"\\<lbrakk>qAFresh zs z1 X; qAFresh zs z2 X\\<rbrakk>  \\<Longrightarrow> (X #[[z1 \\<and> z2]]_zs) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qAFresh zs z1 X; qAFresh zs z2 X\\<rbrakk>\n    \\<Longrightarrow> X #[[z1 \\<and> z2]]_zs = X", "by(simp add: qAFreshAll_qSwapAll_id)"], ["", "lemma qAFreshAll_qSwapAll_compose:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\"and zs x y z\nshows  \"(qAFresh zs y X \\<and> qAFresh zs z X \\<longrightarrow>\n         ((X #[[y \\<and> x]]_zs) #[[z \\<and> y]]_zs) = (X #[[z \\<and> x]]_zs)) \\<and>\n        (qAFreshAbs zs y A \\<and> qAFreshAbs zs z A \\<longrightarrow>\n         ((A $[[y \\<and> x]]_zs) $[[z \\<and> y]]_zs) = (A $[[z \\<and> x]]_zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (qAFresh zs y X \\<and> qAFresh zs z X \\<longrightarrow>\n     X #[[y \\<and> x]]_zs #[[z \\<and> y]]_zs = X #[[z \\<and> x]]_zs) \\<and>\n    (qAFreshAbs zs y A \\<and> qAFreshAbs zs z A \\<longrightarrow>\n     A $[[y \\<and> x]]_zs $[[z \\<and> y]]_zs = A $[[z \\<and> x]]_zs)", "by (induct rule: qTerm_rawInduct[of _ _ X A])\n   (auto intro!: ext simp: sw_trans lift_comp lift_def liftAll_def option.case_eq_if)"], ["", "corollary qAFresh_qSwap_compose:\n\"\\<lbrakk>qAFresh zs y X; qAFresh zs z X\\<rbrakk> \\<Longrightarrow>\n ((X #[[y \\<and> x]]_zs) #[[z \\<and> y]]_zs) = (X #[[z \\<and> x]]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qAFresh zs y X; qAFresh zs z X\\<rbrakk>\n    \\<Longrightarrow> X #[[y \\<and> x]]_zs #[[z \\<and> y]]_zs =\n                      X #[[z \\<and> x]]_zs", "by(simp add: qAFreshAll_qSwapAll_compose)"], ["", "subsection \\<open>Induction and well-foundedness modulo swapping\\<close>"], ["", "lemma qSkel_qSwapAll:\nfixes  X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n       A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\" and x y zs\nshows \"qSkel(X #[[x \\<and> y]]_zs) = qSkel X \\<and>\n       qSkelAbs(A $[[x \\<and> y]]_zs) = qSkelAbs A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qSkel (X #[[x \\<and> y]]_zs) = qSkel X \\<and>\n    qSkelAbs (A $[[x \\<and> y]]_zs) = qSkelAbs A", "proof(induct rule: qTerm_rawInduct[of _ _ X A])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs xa. qSkel (qVar xs xa #[[x \\<and> y]]_zs) = qSkel (qVar xs xa)\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll (\\<lambda>a. qSkel (a #[[x \\<and> y]]_zs) = qSkel a)\n                 inp;\n        liftAll (\\<lambda>a. qSkelAbs (a $[[x \\<and> y]]_zs) = qSkelAbs a)\n         binp\\<rbrakk>\n       \\<Longrightarrow> qSkel (qOp delta inp binp #[[x \\<and> y]]_zs) =\n                         qSkel (qOp delta inp binp)\n 3. \\<And>xs xa X.\n       qSkel (X #[[x \\<and> y]]_zs) = qSkel X \\<Longrightarrow>\n       qSkelAbs (qAbs xs xa X $[[x \\<and> y]]_zs) = qSkelAbs (qAbs xs xa X)", "case (Op delta inp binp)"], ["proof (state)\nthis:\n  liftAll (\\<lambda>a. qSkel (a #[[x \\<and> y]]_zs) = qSkel a) inp\n  liftAll (\\<lambda>a. qSkelAbs (a $[[x \\<and> y]]_zs) = qSkelAbs a) binp\n\ngoal (3 subgoals):\n 1. \\<And>xs xa. qSkel (qVar xs xa #[[x \\<and> y]]_zs) = qSkel (qVar xs xa)\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll (\\<lambda>a. qSkel (a #[[x \\<and> y]]_zs) = qSkel a)\n                 inp;\n        liftAll (\\<lambda>a. qSkelAbs (a $[[x \\<and> y]]_zs) = qSkelAbs a)\n         binp\\<rbrakk>\n       \\<Longrightarrow> qSkel (qOp delta inp binp #[[x \\<and> y]]_zs) =\n                         qSkel (qOp delta inp binp)\n 3. \\<And>xs xa X.\n       qSkel (X #[[x \\<and> y]]_zs) = qSkel X \\<Longrightarrow>\n       qSkelAbs (qAbs xs xa X $[[x \\<and> y]]_zs) = qSkelAbs (qAbs xs xa X)", "then"], ["proof (chain)\npicking this:\n  liftAll (\\<lambda>a. qSkel (a #[[x \\<and> y]]_zs) = qSkel a) inp\n  liftAll (\\<lambda>a. qSkelAbs (a $[[x \\<and> y]]_zs) = qSkelAbs a) binp", "show ?case"], ["proof (prove)\nusing this:\n  liftAll (\\<lambda>a. qSkel (a #[[x \\<and> y]]_zs) = qSkel a) inp\n  liftAll (\\<lambda>a. qSkelAbs (a $[[x \\<and> y]]_zs) = qSkelAbs a) binp\n\ngoal (1 subgoal):\n 1. qSkel (qOp delta inp binp #[[x \\<and> y]]_zs) =\n    qSkel (qOp delta inp binp)", "unfolding qSwapAll_simps(2) liftAll_lift_ext qSkel.simps(2)\n    lift_comp comp_apply"], ["proof (prove)\nusing this:\n  lift (\\<lambda>a. qSkel (a #[[x \\<and> y]]_zs)) inp = lift qSkel inp\n  lift (\\<lambda>a. qSkelAbs (a $[[x \\<and> y]]_zs)) binp =\n  lift qSkelAbs binp\n\ngoal (1 subgoal):\n 1. Branch (lift (\\<lambda>xa. qSkel (xa #[[x \\<and> y]]_zs)) inp)\n     (lift (\\<lambda>xa. qSkelAbs (xa $[[x \\<and> y]]_zs)) binp) =\n    Branch (lift qSkel inp) (lift qSkelAbs binp)", "by simp"], ["proof (state)\nthis:\n  qSkel (qOp delta inp binp #[[x \\<and> y]]_zs) = qSkel (qOp delta inp binp)\n\ngoal (2 subgoals):\n 1. \\<And>xs xa. qSkel (qVar xs xa #[[x \\<and> y]]_zs) = qSkel (qVar xs xa)\n 2. \\<And>xs xa X.\n       qSkel (X #[[x \\<and> y]]_zs) = qSkel X \\<Longrightarrow>\n       qSkelAbs (qAbs xs xa X $[[x \\<and> y]]_zs) = qSkelAbs (qAbs xs xa X)", "qed auto"], ["", "corollary qSkel_qSwap: \"qSkel(X #[[x \\<and> y]]_zs) = qSkel X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qSkel (X #[[x \\<and> y]]_zs) = qSkel X", "by(simp add: qSkel_qSwapAll)"], ["", "text\\<open>\n  For induction modulo swapping, one may wish to swap not just once,\n   but several times at the\n   induction hypothesis (an example of this will be the proof of compatibility\n   of ``qSwap\" with alpha) -- for this, we introduce the following relation\n  (the suffix ``Raw\" signifies the fact that the involved variables are\n  not required to be well-sorted):\\<close>"], ["", "inductive_set qSwapped :: \"('index,'bindex,'varSort,'var,'opSym)qTerm rel\"\nwhere\nRefl: \"(X,X) \\<in> qSwapped\"\n|\nTrans: \"\\<lbrakk>(X,Y) \\<in> qSwapped; (Y,Z) \\<in> qSwapped\\<rbrakk> \\<Longrightarrow> (X,Z) \\<in> qSwapped\"\n|\nSwap: \"(X,Y) \\<in> qSwapped \\<Longrightarrow> (X, Y #[[x \\<and> y]]_zs) \\<in> qSwapped\""], ["", "lemmas qSwapped_Clauses = qSwapped.Refl qSwapped.Trans qSwapped.Swap"], ["", "lemma qSwap_qSwapped: \"(X, X #[[x \\<and> y]]_zs): qSwapped\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X, X #[[x \\<and> y]]_zs) \\<in> qSwapped", "by (auto simp add: qSwapped_Clauses)"], ["", "lemma qSwapped_qSkel:\n\"(X,Y) \\<in> qSwapped  \\<Longrightarrow> qSkel Y = qSkel X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X, Y) \\<in> qSwapped \\<Longrightarrow> qSkel Y = qSkel X", "by(erule qSwapped.induct, auto simp add: qSkel_qSwap)"], ["", "text\\<open>The following is henceforth our main induction principle for quasi-terms.  At the\n clause for abstractions, the user may choose among the two\n induction hypotheses (IHs):\n \\\\-(1) IH for all swapped terms\n \\\\-(2) IH for all terms with the same skeleton.\n\nThe user may choose only one of the above, and ignore the others, but may of course also\nassume both.  (2) is stronger than (1),\nbut we offer both of them for convenience in proofs.\nMost of the times, (1) will be the most convenient.\\<close>"], ["", "lemma qTerm_induct[case_names Var Op Abs]:\nfixes X :: \"('index,'bindex,'varSort,'var,'opSym)qTerm\"\nand A :: \"('index,'bindex,'varSort,'var,'opSym)qAbs\"  and phi phiAbs\nassumes\n  Var: \"\\<And> xs x. phi (qVar xs x)\" and\n  Op: \"\\<And> delta inp binp. \\<lbrakk>liftAll phi inp; liftAll phiAbs binp\\<rbrakk>\n                         \\<Longrightarrow> phi (qOp delta inp binp)\" and\n  Abs: \"\\<And> xs x X. \\<lbrakk>\\<And> Y. (X,Y) \\<in> qSwapped \\<Longrightarrow> phi Y;\n                    \\<And> Y. qSkel Y = qSkel X \\<Longrightarrow> phi Y\\<rbrakk>\n                    \\<Longrightarrow> phiAbs (qAbs xs x X)\"\nshows \"phi X \\<and> phiAbs A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phi X \\<and> phiAbs A", "by (induct rule: qTerm_templateInduct[of \"qSwapped \\<union> {(X,Y). qSkel Y = qSkel X}\"], \n      auto simp add: qSwapped_qSkel assms)"], ["", "text\\<open>The following relation will be needed for proving alpha-equivalence well-defined:\\<close>"], ["", "definition qTermQSwappedLess :: \"('index,'bindex,'varSort,'var,'opSym)qTermItem rel\"\nwhere \"qTermQSwappedLess = qTermLess_modulo qSwapped\""], ["", "lemma qTermQSwappedLess_wf: \"wf qTermQSwappedLess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf qTermQSwappedLess", "unfolding qTermQSwappedLess_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (qTermLess_modulo qSwapped)", "using qSwapped_qSkel qTermLess_modulo_wf[of qSwapped]"], ["proof (prove)\nusing this:\n  (?X, ?Y) \\<in> qSwapped \\<Longrightarrow> qSkel ?Y = qSkel ?X\n  (\\<And>X Y.\n      (X, Y) \\<in> qSwapped \\<Longrightarrow>\n      qSkel Y = qSkel X) \\<Longrightarrow>\n  wf (qTermLess_modulo qSwapped)\n\ngoal (1 subgoal):\n 1. wf (qTermLess_modulo qSwapped)", "by blast"], ["", "subsection\\<open>More properties connecting swapping and freshness\\<close>"], ["", "lemma qSwap_3commute:\nassumes *: \"qAFresh ys y X\" and **: \"qAFresh ys y0 X\"\nand ***: \"ys \\<noteq> zs \\<or> y0 \\<notin> {z1,z2}\"\nshows \"((X #[[z1 \\<and> z2]]_zs) #[[y0 \\<and> x @ys[z1 \\<and> z2]_zs]]_ys) =\n       (((X #[[y \\<and> x]]_ys) #[[y0 \\<and> y]]_ys) #[[z1 \\<and> z2]]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X #[[z1 \\<and> z2]]_zs #[[y0 \\<and> x @ys[z1 \\<and> z2]_zs]]_ys =\n    X #[[y \\<and> x]]_ys #[[y0 \\<and> y]]_ys #[[z1 \\<and> z2]]_zs", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. X #[[z1 \\<and> z2]]_zs #[[y0 \\<and> x @ys[z1 \\<and> z2]_zs]]_ys =\n    X #[[y \\<and> x]]_ys #[[y0 \\<and> y]]_ys #[[z1 \\<and> z2]]_zs", "have \"y0 = (y0 @ys[z1 \\<and> z2]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y0 = y0 @ys[z1 \\<and> z2]_zs", "using ***"], ["proof (prove)\nusing this:\n  ys \\<noteq> zs \\<or> y0 \\<notin> {z1, z2}\n\ngoal (1 subgoal):\n 1. y0 = y0 @ys[z1 \\<and> z2]_zs", "unfolding sw_def"], ["proof (prove)\nusing this:\n  ys \\<noteq> zs \\<or> y0 \\<notin> {z1, z2}\n\ngoal (1 subgoal):\n 1. y0 =\n    (if zs = ys then if y0 = z1 then z2 else if y0 = z2 then z1 else y0\n     else y0)", "by auto"], ["proof (state)\nthis:\n  y0 = y0 @ys[z1 \\<and> z2]_zs\n\ngoal (1 subgoal):\n 1. X #[[z1 \\<and> z2]]_zs #[[y0 \\<and> x @ys[z1 \\<and> z2]_zs]]_ys =\n    X #[[y \\<and> x]]_ys #[[y0 \\<and> y]]_ys #[[z1 \\<and> z2]]_zs", "hence \"((X #[[z1 \\<and> z2]]_zs) #[[y0 \\<and> x @ys[z1 \\<and> z2]_zs]]_ys) =\n         ((X #[[y0 \\<and> x]]_ys) #[[z1 \\<and> z2]]_zs)\""], ["proof (prove)\nusing this:\n  y0 = y0 @ys[z1 \\<and> z2]_zs\n\ngoal (1 subgoal):\n 1. X #[[z1 \\<and> z2]]_zs #[[y0 \\<and> x @ys[z1 \\<and> z2]_zs]]_ys =\n    X #[[y0 \\<and> x]]_ys #[[z1 \\<and> z2]]_zs", "by(simp add: qSwap_compose[of _ z1])"], ["proof (state)\nthis:\n  X #[[z1 \\<and> z2]]_zs #[[y0 \\<and> x @ys[z1 \\<and> z2]_zs]]_ys =\n  X #[[y0 \\<and> x]]_ys #[[z1 \\<and> z2]]_zs\n\ngoal (1 subgoal):\n 1. X #[[z1 \\<and> z2]]_zs #[[y0 \\<and> x @ys[z1 \\<and> z2]_zs]]_ys =\n    X #[[y \\<and> x]]_ys #[[y0 \\<and> y]]_ys #[[z1 \\<and> z2]]_zs", "also"], ["proof (state)\nthis:\n  X #[[z1 \\<and> z2]]_zs #[[y0 \\<and> x @ys[z1 \\<and> z2]_zs]]_ys =\n  X #[[y0 \\<and> x]]_ys #[[z1 \\<and> z2]]_zs\n\ngoal (1 subgoal):\n 1. X #[[z1 \\<and> z2]]_zs #[[y0 \\<and> x @ys[z1 \\<and> z2]_zs]]_ys =\n    X #[[y \\<and> x]]_ys #[[y0 \\<and> y]]_ys #[[z1 \\<and> z2]]_zs", "have \"((X #[[y0 \\<and> x]]_ys) #[[z1 \\<and> z2]]_zs) =\n             (((X #[[y \\<and> x]]_ys) #[[y0 \\<and> y]]_ys) #[[z1 \\<and> z2]]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X #[[y0 \\<and> x]]_ys #[[z1 \\<and> z2]]_zs =\n    X #[[y \\<and> x]]_ys #[[y0 \\<and> y]]_ys #[[z1 \\<and> z2]]_zs", "using * **"], ["proof (prove)\nusing this:\n  qAFresh ys y X\n  qAFresh ys y0 X\n\ngoal (1 subgoal):\n 1. X #[[y0 \\<and> x]]_ys #[[z1 \\<and> z2]]_zs =\n    X #[[y \\<and> x]]_ys #[[y0 \\<and> y]]_ys #[[z1 \\<and> z2]]_zs", "by (simp add: qAFresh_qSwap_compose)"], ["proof (state)\nthis:\n  X #[[y0 \\<and> x]]_ys #[[z1 \\<and> z2]]_zs =\n  X #[[y \\<and> x]]_ys #[[y0 \\<and> y]]_ys #[[z1 \\<and> z2]]_zs\n\ngoal (1 subgoal):\n 1. X #[[z1 \\<and> z2]]_zs #[[y0 \\<and> x @ys[z1 \\<and> z2]_zs]]_ys =\n    X #[[y \\<and> x]]_ys #[[y0 \\<and> y]]_ys #[[z1 \\<and> z2]]_zs", "finally"], ["proof (chain)\npicking this:\n  X #[[z1 \\<and> z2]]_zs #[[y0 \\<and> x @ys[z1 \\<and> z2]_zs]]_ys =\n  X #[[y \\<and> x]]_ys #[[y0 \\<and> y]]_ys #[[z1 \\<and> z2]]_zs", "show ?thesis"], ["proof (prove)\nusing this:\n  X #[[z1 \\<and> z2]]_zs #[[y0 \\<and> x @ys[z1 \\<and> z2]_zs]]_ys =\n  X #[[y \\<and> x]]_ys #[[y0 \\<and> y]]_ys #[[z1 \\<and> z2]]_zs\n\ngoal (1 subgoal):\n 1. X #[[z1 \\<and> z2]]_zs #[[y0 \\<and> x @ys[z1 \\<and> z2]_zs]]_ys =\n    X #[[y \\<and> x]]_ys #[[y0 \\<and> y]]_ys #[[z1 \\<and> z2]]_zs", "."], ["proof (state)\nthis:\n  X #[[z1 \\<and> z2]]_zs #[[y0 \\<and> x @ys[z1 \\<and> z2]_zs]]_ys =\n  X #[[y \\<and> x]]_ys #[[y0 \\<and> y]]_ys #[[z1 \\<and> z2]]_zs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qAFreshAll_imp_qFreshAll:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\" and xs x\nshows \"(qAFresh xs x X \\<longrightarrow> qFresh xs x X) \\<and>\n       (qAFreshAbs xs x A \\<longrightarrow> qFreshAbs xs x A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (qAFresh xs x X \\<longrightarrow> qFresh xs x X) \\<and>\n    (qAFreshAbs xs x A \\<longrightarrow> qFreshAbs xs x A)", "by(induct rule: qTerm_rawInduct, auto simp add: liftAll_def)"], ["", "corollary qAFresh_imp_qFresh:\n\"qAFresh xs x X \\<Longrightarrow> qFresh xs x X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qAFresh xs x X \\<Longrightarrow> qFresh xs x X", "by(simp add: qAFreshAll_imp_qFreshAll)"], ["", "lemma qSwapAll_preserves_qAFreshAll:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\" and ys y zs z1 z2\nshows\n\"(qAFresh ys (y @ys[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) = qAFresh ys y X) \\<and>\n (qAFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (A $[[z1 \\<and> z2]]_zs) = qAFreshAbs ys y A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qAFresh ys (y @ys[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) =\n    qAFresh ys y X \\<and>\n    qAFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (A $[[z1 \\<and> z2]]_zs) =\n    qAFreshAbs ys y A", "proof(induct rule: qTerm_rawInduct[of _ _ X A])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       qAFresh ys (y @ys[z1 \\<and> z2]_zs)\n        (qVar xs x #[[z1 \\<and> z2]]_zs) =\n       qAFresh ys y (qVar xs x)\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     qAFresh ys (y @ys[z1 \\<and> z2]_zs)\n                      (a #[[z1 \\<and> z2]]_zs) =\n                     qAFresh ys y a)\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             qAFreshAbs ys (y @ys[z1 \\<and> z2]_zs)\n              (a $[[z1 \\<and> z2]]_zs) =\n             qAFreshAbs ys y a)\n         binp\\<rbrakk>\n       \\<Longrightarrow> qAFresh ys (y @ys[z1 \\<and> z2]_zs)\n                          (qOp delta inp binp #[[z1 \\<and> z2]]_zs) =\n                         qAFresh ys y (qOp delta inp binp)\n 3. \\<And>xs x X.\n       qAFresh ys (y @ys[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) =\n       qAFresh ys y X \\<Longrightarrow>\n       qAFreshAbs ys (y @ys[z1 \\<and> z2]_zs)\n        (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n       qAFreshAbs ys y (qAbs xs x X)", "case (Op delta inp binp)"], ["proof (state)\nthis:\n  liftAll\n   (\\<lambda>a.\n       qAFresh ys (y @ys[z1 \\<and> z2]_zs) (a #[[z1 \\<and> z2]]_zs) =\n       qAFresh ys y a)\n   inp\n  liftAll\n   (\\<lambda>a.\n       qAFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (a $[[z1 \\<and> z2]]_zs) =\n       qAFreshAbs ys y a)\n   binp\n\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       qAFresh ys (y @ys[z1 \\<and> z2]_zs)\n        (qVar xs x #[[z1 \\<and> z2]]_zs) =\n       qAFresh ys y (qVar xs x)\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     qAFresh ys (y @ys[z1 \\<and> z2]_zs)\n                      (a #[[z1 \\<and> z2]]_zs) =\n                     qAFresh ys y a)\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             qAFreshAbs ys (y @ys[z1 \\<and> z2]_zs)\n              (a $[[z1 \\<and> z2]]_zs) =\n             qAFreshAbs ys y a)\n         binp\\<rbrakk>\n       \\<Longrightarrow> qAFresh ys (y @ys[z1 \\<and> z2]_zs)\n                          (qOp delta inp binp #[[z1 \\<and> z2]]_zs) =\n                         qAFresh ys y (qOp delta inp binp)\n 3. \\<And>xs x X.\n       qAFresh ys (y @ys[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) =\n       qAFresh ys y X \\<Longrightarrow>\n       qAFreshAbs ys (y @ys[z1 \\<and> z2]_zs)\n        (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n       qAFreshAbs ys y (qAbs xs x X)", "then"], ["proof (chain)\npicking this:\n  liftAll\n   (\\<lambda>a.\n       qAFresh ys (y @ys[z1 \\<and> z2]_zs) (a #[[z1 \\<and> z2]]_zs) =\n       qAFresh ys y a)\n   inp\n  liftAll\n   (\\<lambda>a.\n       qAFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (a $[[z1 \\<and> z2]]_zs) =\n       qAFreshAbs ys y a)\n   binp", "show ?case"], ["proof (prove)\nusing this:\n  liftAll\n   (\\<lambda>a.\n       qAFresh ys (y @ys[z1 \\<and> z2]_zs) (a #[[z1 \\<and> z2]]_zs) =\n       qAFresh ys y a)\n   inp\n  liftAll\n   (\\<lambda>a.\n       qAFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (a $[[z1 \\<and> z2]]_zs) =\n       qAFreshAbs ys y a)\n   binp\n\ngoal (1 subgoal):\n 1. qAFresh ys (y @ys[z1 \\<and> z2]_zs)\n     (qOp delta inp binp #[[z1 \\<and> z2]]_zs) =\n    qAFresh ys y (qOp delta inp binp)", "unfolding qAFreshAll_simps(2) qSwapAll_simps(2) liftAll_lift_comp o_def"], ["proof (prove)\nusing this:\n  liftAll\n   (\\<lambda>a.\n       qAFresh ys (y @ys[z1 \\<and> z2]_zs) (a #[[z1 \\<and> z2]]_zs) =\n       qAFresh ys y a)\n   inp\n  liftAll\n   (\\<lambda>a.\n       qAFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (a $[[z1 \\<and> z2]]_zs) =\n       qAFreshAbs ys y a)\n   binp\n\ngoal (1 subgoal):\n 1. (liftAll\n      (\\<lambda>x.\n          qAFresh ys (y @ys[z1 \\<and> z2]_zs) (x #[[z1 \\<and> z2]]_zs))\n      inp \\<and>\n     liftAll\n      (\\<lambda>x.\n          qAFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (x $[[z1 \\<and> z2]]_zs))\n      binp) =\n    (liftAll (qAFresh ys y) inp \\<and> liftAll (qAFreshAbs ys y) binp)", "unfolding liftAll_def"], ["proof (prove)\nusing this:\n  \\<forall>i v.\n     inp i = Some v \\<longrightarrow>\n     qAFresh ys (y @ys[z1 \\<and> z2]_zs) (v #[[z1 \\<and> z2]]_zs) =\n     qAFresh ys y v\n  \\<forall>i v.\n     binp i = Some v \\<longrightarrow>\n     qAFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (v $[[z1 \\<and> z2]]_zs) =\n     qAFreshAbs ys y v\n\ngoal (1 subgoal):\n 1. ((\\<forall>i v.\n         inp i = Some v \\<longrightarrow>\n         qAFresh ys (y @ys[z1 \\<and> z2]_zs)\n          (v #[[z1 \\<and> z2]]_zs)) \\<and>\n     (\\<forall>i v.\n         binp i = Some v \\<longrightarrow>\n         qAFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (v $[[z1 \\<and> z2]]_zs))) =\n    ((\\<forall>i v. inp i = Some v \\<longrightarrow> qAFresh ys y v) \\<and>\n     (\\<forall>i v. binp i = Some v \\<longrightarrow> qAFreshAbs ys y v))", "by presburger"], ["proof (state)\nthis:\n  qAFresh ys (y @ys[z1 \\<and> z2]_zs)\n   (qOp delta inp binp #[[z1 \\<and> z2]]_zs) =\n  qAFresh ys y (qOp delta inp binp)\n\ngoal (2 subgoals):\n 1. \\<And>xs x.\n       qAFresh ys (y @ys[z1 \\<and> z2]_zs)\n        (qVar xs x #[[z1 \\<and> z2]]_zs) =\n       qAFresh ys y (qVar xs x)\n 2. \\<And>xs x X.\n       qAFresh ys (y @ys[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) =\n       qAFresh ys y X \\<Longrightarrow>\n       qAFreshAbs ys (y @ys[z1 \\<and> z2]_zs)\n        (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n       qAFreshAbs ys y (qAbs xs x X)", "qed(auto simp add: sw_def)"], ["", "corollary qSwap_preserves_qAFresh[simp]:\n\"(qAFresh ys (y @ys[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) = qAFresh ys y X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qAFresh ys (y @ys[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) =\n    qAFresh ys y X", "by(simp add: qSwapAll_preserves_qAFreshAll)"], ["", "lemma qSwap_preserves_qAFresh_distinct:\nassumes \"ys \\<noteq> zs \\<or> y \\<notin> {z1,z2}\"\nshows \"qAFresh ys y (X #[[z1 \\<and> z2]]_zs) = qAFresh ys y X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qAFresh ys y (X #[[z1 \\<and> z2]]_zs) = qAFresh ys y X", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. qAFresh ys y (X #[[z1 \\<and> z2]]_zs) = qAFresh ys y X", "have \"y = (y @ys[z1 \\<and> z2]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = y @ys[z1 \\<and> z2]_zs", "using assms"], ["proof (prove)\nusing this:\n  ys \\<noteq> zs \\<or> y \\<notin> {z1, z2}\n\ngoal (1 subgoal):\n 1. y = y @ys[z1 \\<and> z2]_zs", "unfolding sw_def"], ["proof (prove)\nusing this:\n  ys \\<noteq> zs \\<or> y \\<notin> {z1, z2}\n\ngoal (1 subgoal):\n 1. y =\n    (if zs = ys then if y = z1 then z2 else if y = z2 then z1 else y else y)", "by auto"], ["proof (state)\nthis:\n  y = y @ys[z1 \\<and> z2]_zs\n\ngoal (1 subgoal):\n 1. qAFresh ys y (X #[[z1 \\<and> z2]]_zs) = qAFresh ys y X", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = y @ys[z1 \\<and> z2]_zs\n\ngoal (1 subgoal):\n 1. qAFresh ys y (X #[[z1 \\<and> z2]]_zs) = qAFresh ys y X", "using qSwap_preserves_qAFresh[of ys zs z1 z2 y]"], ["proof (prove)\nusing this:\n  y = y @ys[z1 \\<and> z2]_zs\n  qAFresh ys (y @ys[z1 \\<and> z2]_zs) (?X #[[z1 \\<and> z2]]_zs) =\n  qAFresh ys y ?X\n\ngoal (1 subgoal):\n 1. qAFresh ys y (X #[[z1 \\<and> z2]]_zs) = qAFresh ys y X", "by auto"], ["proof (state)\nthis:\n  qAFresh ys y (X #[[z1 \\<and> z2]]_zs) = qAFresh ys y X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qAFresh_qSwap_exchange1:\n\"qAFresh zs z2 (X #[[z1 \\<and> z2]]_zs) = qAFresh zs z1 X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qAFresh zs z2 (X #[[z1 \\<and> z2]]_zs) = qAFresh zs z1 X", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. qAFresh zs z2 (X #[[z1 \\<and> z2]]_zs) = qAFresh zs z1 X", "have \"z2 = (z1 @zs[z1 \\<and> z2]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z2 = z1 @zs[z1 \\<and> z2]_zs", "unfolding sw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. z2 =\n    (if zs = zs then if z1 = z1 then z2 else if z1 = z2 then z1 else z1\n     else z1)", "by auto"], ["proof (state)\nthis:\n  z2 = z1 @zs[z1 \\<and> z2]_zs\n\ngoal (1 subgoal):\n 1. qAFresh zs z2 (X #[[z1 \\<and> z2]]_zs) = qAFresh zs z1 X", "thus ?thesis"], ["proof (prove)\nusing this:\n  z2 = z1 @zs[z1 \\<and> z2]_zs\n\ngoal (1 subgoal):\n 1. qAFresh zs z2 (X #[[z1 \\<and> z2]]_zs) = qAFresh zs z1 X", "using qSwap_preserves_qAFresh[of zs zs z1 z2 z1 X]"], ["proof (prove)\nusing this:\n  z2 = z1 @zs[z1 \\<and> z2]_zs\n  qAFresh zs (z1 @zs[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) =\n  qAFresh zs z1 X\n\ngoal (1 subgoal):\n 1. qAFresh zs z2 (X #[[z1 \\<and> z2]]_zs) = qAFresh zs z1 X", "by auto"], ["proof (state)\nthis:\n  qAFresh zs z2 (X #[[z1 \\<and> z2]]_zs) = qAFresh zs z1 X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qAFresh_qSwap_exchange2:\n\"qAFresh zs z2 (X #[[z2 \\<and> z1]]_zs) = qAFresh zs z1 X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qAFresh zs z2 (X #[[z2 \\<and> z1]]_zs) = qAFresh zs z1 X", "by(auto simp add: qAFresh_qSwap_exchange1 qSwap_sym)"], ["", "lemma qSwapAll_preserves_qFreshAll:\nfixes X::\"('index,'bindex,'varSort,'var,'opSym)qTerm\" and\n      A::\"('index,'bindex,'varSort,'var,'opSym)qAbs\" and ys y zs z1 z2\nshows\n\"(qFresh ys (y @ys[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) = qFresh ys y X) \\<and>\n (qFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (A $[[z1 \\<and> z2]]_zs) = qFreshAbs ys y A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qFresh ys (y @ys[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) =\n    qFresh ys y X \\<and>\n    qFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (A $[[z1 \\<and> z2]]_zs) =\n    qFreshAbs ys y A", "proof(induct rule: qTerm_rawInduct[of _ _ X A])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       qFresh ys (y @ys[z1 \\<and> z2]_zs) (qVar xs x #[[z1 \\<and> z2]]_zs) =\n       qFresh ys y (qVar xs x)\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     qFresh ys (y @ys[z1 \\<and> z2]_zs)\n                      (a #[[z1 \\<and> z2]]_zs) =\n                     qFresh ys y a)\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             qFreshAbs ys (y @ys[z1 \\<and> z2]_zs)\n              (a $[[z1 \\<and> z2]]_zs) =\n             qFreshAbs ys y a)\n         binp\\<rbrakk>\n       \\<Longrightarrow> qFresh ys (y @ys[z1 \\<and> z2]_zs)\n                          (qOp delta inp binp #[[z1 \\<and> z2]]_zs) =\n                         qFresh ys y (qOp delta inp binp)\n 3. \\<And>xs x X.\n       qFresh ys (y @ys[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) =\n       qFresh ys y X \\<Longrightarrow>\n       qFreshAbs ys (y @ys[z1 \\<and> z2]_zs)\n        (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n       qFreshAbs ys y (qAbs xs x X)", "case (Op delta inp binp)"], ["proof (state)\nthis:\n  liftAll\n   (\\<lambda>a.\n       qFresh ys (y @ys[z1 \\<and> z2]_zs) (a #[[z1 \\<and> z2]]_zs) =\n       qFresh ys y a)\n   inp\n  liftAll\n   (\\<lambda>a.\n       qFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (a $[[z1 \\<and> z2]]_zs) =\n       qFreshAbs ys y a)\n   binp\n\ngoal (3 subgoals):\n 1. \\<And>xs x.\n       qFresh ys (y @ys[z1 \\<and> z2]_zs) (qVar xs x #[[z1 \\<and> z2]]_zs) =\n       qFresh ys y (qVar xs x)\n 2. \\<And>delta inp binp.\n       \\<lbrakk>liftAll\n                 (\\<lambda>a.\n                     qFresh ys (y @ys[z1 \\<and> z2]_zs)\n                      (a #[[z1 \\<and> z2]]_zs) =\n                     qFresh ys y a)\n                 inp;\n        liftAll\n         (\\<lambda>a.\n             qFreshAbs ys (y @ys[z1 \\<and> z2]_zs)\n              (a $[[z1 \\<and> z2]]_zs) =\n             qFreshAbs ys y a)\n         binp\\<rbrakk>\n       \\<Longrightarrow> qFresh ys (y @ys[z1 \\<and> z2]_zs)\n                          (qOp delta inp binp #[[z1 \\<and> z2]]_zs) =\n                         qFresh ys y (qOp delta inp binp)\n 3. \\<And>xs x X.\n       qFresh ys (y @ys[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) =\n       qFresh ys y X \\<Longrightarrow>\n       qFreshAbs ys (y @ys[z1 \\<and> z2]_zs)\n        (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n       qFreshAbs ys y (qAbs xs x X)", "then"], ["proof (chain)\npicking this:\n  liftAll\n   (\\<lambda>a.\n       qFresh ys (y @ys[z1 \\<and> z2]_zs) (a #[[z1 \\<and> z2]]_zs) =\n       qFresh ys y a)\n   inp\n  liftAll\n   (\\<lambda>a.\n       qFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (a $[[z1 \\<and> z2]]_zs) =\n       qFreshAbs ys y a)\n   binp", "show ?case"], ["proof (prove)\nusing this:\n  liftAll\n   (\\<lambda>a.\n       qFresh ys (y @ys[z1 \\<and> z2]_zs) (a #[[z1 \\<and> z2]]_zs) =\n       qFresh ys y a)\n   inp\n  liftAll\n   (\\<lambda>a.\n       qFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (a $[[z1 \\<and> z2]]_zs) =\n       qFreshAbs ys y a)\n   binp\n\ngoal (1 subgoal):\n 1. qFresh ys (y @ys[z1 \\<and> z2]_zs)\n     (qOp delta inp binp #[[z1 \\<and> z2]]_zs) =\n    qFresh ys y (qOp delta inp binp)", "unfolding qFreshAll_simps(2) qSwapAll_simps(2) liftAll_lift_comp o_def"], ["proof (prove)\nusing this:\n  liftAll\n   (\\<lambda>a.\n       qFresh ys (y @ys[z1 \\<and> z2]_zs) (a #[[z1 \\<and> z2]]_zs) =\n       qFresh ys y a)\n   inp\n  liftAll\n   (\\<lambda>a.\n       qFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (a $[[z1 \\<and> z2]]_zs) =\n       qFreshAbs ys y a)\n   binp\n\ngoal (1 subgoal):\n 1. (liftAll\n      (\\<lambda>x.\n          qFresh ys (y @ys[z1 \\<and> z2]_zs) (x #[[z1 \\<and> z2]]_zs))\n      inp \\<and>\n     liftAll\n      (\\<lambda>x.\n          qFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (x $[[z1 \\<and> z2]]_zs))\n      binp) =\n    (liftAll (qFresh ys y) inp \\<and> liftAll (qFreshAbs ys y) binp)", "unfolding liftAll_def"], ["proof (prove)\nusing this:\n  \\<forall>i v.\n     inp i = Some v \\<longrightarrow>\n     qFresh ys (y @ys[z1 \\<and> z2]_zs) (v #[[z1 \\<and> z2]]_zs) =\n     qFresh ys y v\n  \\<forall>i v.\n     binp i = Some v \\<longrightarrow>\n     qFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (v $[[z1 \\<and> z2]]_zs) =\n     qFreshAbs ys y v\n\ngoal (1 subgoal):\n 1. ((\\<forall>i v.\n         inp i = Some v \\<longrightarrow>\n         qFresh ys (y @ys[z1 \\<and> z2]_zs) (v #[[z1 \\<and> z2]]_zs)) \\<and>\n     (\\<forall>i v.\n         binp i = Some v \\<longrightarrow>\n         qFreshAbs ys (y @ys[z1 \\<and> z2]_zs) (v $[[z1 \\<and> z2]]_zs))) =\n    ((\\<forall>i v. inp i = Some v \\<longrightarrow> qFresh ys y v) \\<and>\n     (\\<forall>i v. binp i = Some v \\<longrightarrow> qFreshAbs ys y v))", "by presburger"], ["proof (state)\nthis:\n  qFresh ys (y @ys[z1 \\<and> z2]_zs)\n   (qOp delta inp binp #[[z1 \\<and> z2]]_zs) =\n  qFresh ys y (qOp delta inp binp)\n\ngoal (2 subgoals):\n 1. \\<And>xs x.\n       qFresh ys (y @ys[z1 \\<and> z2]_zs) (qVar xs x #[[z1 \\<and> z2]]_zs) =\n       qFresh ys y (qVar xs x)\n 2. \\<And>xs x X.\n       qFresh ys (y @ys[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) =\n       qFresh ys y X \\<Longrightarrow>\n       qFreshAbs ys (y @ys[z1 \\<and> z2]_zs)\n        (qAbs xs x X $[[z1 \\<and> z2]]_zs) =\n       qFreshAbs ys y (qAbs xs x X)", "qed (auto simp add: sw_def)"], ["", "corollary qSwap_preserves_qFresh:\n\"(qFresh ys (y @ys[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) = qFresh ys y X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qFresh ys (y @ys[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) =\n    qFresh ys y X", "by(simp add: qSwapAll_preserves_qFreshAll)"], ["", "lemma qSwap_preserves_qFresh_distinct:\nassumes \"ys \\<noteq> zs \\<or> y \\<notin> {z1,z2}\"\nshows \"qFresh ys y (X #[[z1 \\<and> z2]]_zs) = qFresh ys y X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qFresh ys y (X #[[z1 \\<and> z2]]_zs) = qFresh ys y X", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. qFresh ys y (X #[[z1 \\<and> z2]]_zs) = qFresh ys y X", "have \"y = (y @ys[z1 \\<and> z2]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = y @ys[z1 \\<and> z2]_zs", "using assms"], ["proof (prove)\nusing this:\n  ys \\<noteq> zs \\<or> y \\<notin> {z1, z2}\n\ngoal (1 subgoal):\n 1. y = y @ys[z1 \\<and> z2]_zs", "unfolding sw_def"], ["proof (prove)\nusing this:\n  ys \\<noteq> zs \\<or> y \\<notin> {z1, z2}\n\ngoal (1 subgoal):\n 1. y =\n    (if zs = ys then if y = z1 then z2 else if y = z2 then z1 else y else y)", "by auto"], ["proof (state)\nthis:\n  y = y @ys[z1 \\<and> z2]_zs\n\ngoal (1 subgoal):\n 1. qFresh ys y (X #[[z1 \\<and> z2]]_zs) = qFresh ys y X", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = y @ys[z1 \\<and> z2]_zs\n\ngoal (1 subgoal):\n 1. qFresh ys y (X #[[z1 \\<and> z2]]_zs) = qFresh ys y X", "using qSwap_preserves_qFresh[of ys zs z1 z2 y]"], ["proof (prove)\nusing this:\n  y = y @ys[z1 \\<and> z2]_zs\n  qFresh ys (y @ys[z1 \\<and> z2]_zs) (?X #[[z1 \\<and> z2]]_zs) =\n  qFresh ys y ?X\n\ngoal (1 subgoal):\n 1. qFresh ys y (X #[[z1 \\<and> z2]]_zs) = qFresh ys y X", "by auto"], ["proof (state)\nthis:\n  qFresh ys y (X #[[z1 \\<and> z2]]_zs) = qFresh ys y X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qFresh_qSwap_exchange1:\n\"qFresh zs z2 (X #[[z1 \\<and> z2]]_zs) = qFresh zs z1 X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qFresh zs z2 (X #[[z1 \\<and> z2]]_zs) = qFresh zs z1 X", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. qFresh zs z2 (X #[[z1 \\<and> z2]]_zs) = qFresh zs z1 X", "have \"z2 = (z1 @zs[z1 \\<and> z2]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z2 = z1 @zs[z1 \\<and> z2]_zs", "unfolding sw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. z2 =\n    (if zs = zs then if z1 = z1 then z2 else if z1 = z2 then z1 else z1\n     else z1)", "by auto"], ["proof (state)\nthis:\n  z2 = z1 @zs[z1 \\<and> z2]_zs\n\ngoal (1 subgoal):\n 1. qFresh zs z2 (X #[[z1 \\<and> z2]]_zs) = qFresh zs z1 X", "thus ?thesis"], ["proof (prove)\nusing this:\n  z2 = z1 @zs[z1 \\<and> z2]_zs\n\ngoal (1 subgoal):\n 1. qFresh zs z2 (X #[[z1 \\<and> z2]]_zs) = qFresh zs z1 X", "using qSwap_preserves_qFresh[of zs zs z1 z2 z1 X]"], ["proof (prove)\nusing this:\n  z2 = z1 @zs[z1 \\<and> z2]_zs\n  qFresh zs (z1 @zs[z1 \\<and> z2]_zs) (X #[[z1 \\<and> z2]]_zs) =\n  qFresh zs z1 X\n\ngoal (1 subgoal):\n 1. qFresh zs z2 (X #[[z1 \\<and> z2]]_zs) = qFresh zs z1 X", "by auto"], ["proof (state)\nthis:\n  qFresh zs z2 (X #[[z1 \\<and> z2]]_zs) = qFresh zs z1 X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qFresh_qSwap_exchange2:\n\"qFresh zs z1 X = qFresh zs z2 (X #[[z2 \\<and> z1]]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qFresh zs z1 X = qFresh zs z2 (X #[[z2 \\<and> z1]]_zs)", "by (auto simp add: qFresh_qSwap_exchange1 qSwap_sym)"], ["", "lemmas qSwap_qAFresh_otherSimps =\nqSwap_ident qSwap_involutive qAFresh_qSwap_id qSwap_preserves_qAFresh"], ["", "end"]]}