{"file_name": "/home/qj213/afp-2021-10-22/thys/Binding_Syntax_Theory/Semantic_Domains.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Binding_Syntax_Theory", "problem_names": ["lemma sWlsNE_imp_sWlsAbsNE:\nassumes \"sWlsNE SEM\"\nshows \"sWlsAbsNE SEM\"", "lemma sWlsDisj_imp_sWlsAbsDisj:\n\"sWlsDisj SEM \\<Longrightarrow> sWlsNE SEM \\<Longrightarrow> sWlsAbsDisj SEM\"", "lemma sWlsNE_imp_sWlsValNE:\n\"sWlsNE SEM \\<Longrightarrow> sWlsValNE SEM x\"", "theorem updVal_simp[simp]:\n\"(val (x := sX)_xs) ys y = (if ys = xs \\<and> y = x then sX else val ys y)\"", "theorem updVal_over[simp]:\n\"((val (x := sX)_xs) (x := sX')_xs) = (val (x := sX')_xs)\"", "theorem updVal_commute:\nassumes \"xs \\<noteq> ys \\<or> x \\<noteq> y\"\nshows \"((val (x := sX)_xs) (y := sY)_ys) = ((val (y := sY)_ys) (x := sX)_xs)\"", "theorem updVal_preserves_sWls[simp]:\nassumes \"sWls SEM (asSort xs) sX\" and \"sWlsVal SEM val\"\nshows \"sWlsVal SEM (val (x := sX)_xs)\"", "lemmas updVal_simps = updVal_simp updVal_over updVal_preserves_sWls", "theorem swapVal_ident[simp]: \"(val ^[x \\<and> x]_xs) = val\"", "theorem swapVal_compose:\n\"((val ^[x \\<and> y]_zs) ^[x' \\<and> y']_zs') =\n ((val ^[x' @zs'[x \\<and> y]_zs \\<and> y' @zs'[x \\<and> y]_zs]_zs') ^[x \\<and> y]_zs)\"", "theorem swapVal_commute:\n\"zs \\<noteq> zs' \\<or> {x,y} \\<inter> {x',y'} = {} \\<Longrightarrow>\n ((val ^[x \\<and> y]_zs) ^[x' \\<and> y']_zs') = ((val ^[x' \\<and> y']_zs') ^[x \\<and> y]_zs)\"", "lemma swapVal_involutive[simp]: \"((val ^[x \\<and> y]_zs) ^[x \\<and> y]_zs) = val\"", "lemma swapVal_sym: \"(val ^[x \\<and> y]_zs) = (val ^[y \\<and> x]_zs)\"", "lemma swapVal_preserves_sWls1:\nassumes \"sWlsVal SEM val\"\nshows \"sWlsVal SEM (val ^[z1 \\<and> z2]_zs)\"", "theorem swapVal_preserves_sWls[simp]:\n\"sWlsVal SEM (val ^[z1 \\<and> z2]_zs) = sWlsVal SEM val\"", "lemmas swapVal_simps = swapVal_ident swapVal_involutive swapVal_preserves_sWls", "lemma updVal_swapVal:\n\"((val (x := sX)_xs) ^[y1 \\<and> y2]_ys) =\n ((val ^[y1 \\<and> y2]_ys) ((x @xs[y1 \\<and> y2]_ys) := sX)_xs)\"", "lemma updVal_preserves_eqBut:\nassumes \"eqBut val val' ys y\"\nshows \"eqBut (val (x := sX)_xs) (val' (x := sX)_xs) ys y\"", "lemma updVal_eqBut_eq:\nassumes \"eqBut val val' ys y\"\nshows \"(val (y := sY)_ys) = (val' (y := sY)_ys)\"", "lemma swapVal_preserves_eqBut:\nassumes \"eqBut val val' xs x\"\nshows \"eqBut (val ^[z1 \\<and> z2]_zs) (val' ^[z1 \\<and> z2]_zs) xs (x @xs[z1 \\<and> z2]_zs)\"", "lemma prWls_wlsInp:\nassumes \"wlsInp delta inp\" and \"prWls g SEM\" and \"sWlsVal SEM val\"\nshows \"sWlsInp SEM delta (lift (\\<lambda> X. g X val) inp)\"", "lemma prWlsAbs_wlsBinp:\nassumes \"wlsBinp delta binp\" and \"prWlsAbs gA SEM\" and \"sWlsVal SEM val\"\nshows \"sWlsBinp SEM delta (lift (\\<lambda> A. gA A val) binp)\"", "lemma asIMOD_igWls:\n\"igWls (asIMOD SEM) s X \\<longleftrightarrow> \n (\\<forall> val. (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n         (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)))\"", "lemma asIMOD_igWlsAbs:\n\"igWlsAbs (asIMOD SEM) (us,s) A \\<longleftrightarrow> \n (\\<forall> val. (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n         (sWlsVal SEM val \\<longrightarrow> sWlsAbs SEM (us,s) (A val)))\"", "lemma asIMOD_igOp:\n\"igOp (asIMOD SEM) delta inp binp =\n(\\<lambda>val. if sWlsVal SEM val then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                                             (lift (\\<lambda>A. A val) binp)\n                          else undefined)\"", "lemma asIMOD_igVar:\n\"igVar (asIMOD SEM) ys y = (\\<lambda>val. if sWlsVal SEM val then val ys y else undefined)\"", "lemma asIMOD_igAbs:\n\"igAbs (asIMOD SEM) xs x X =\n(\\<lambda>val. if sWlsVal SEM val then sAbs xs (\\<lambda>sX. if sWls SEM (asSort xs) sX\n                                                then X (val (x := sX)_xs)\n                                                else sDummy SEM (SOME s. sWls SEM s (X val)))\n                          else undefined)\"", "lemma asIMOD_igAbs2:\nfixes SEM :: \"('index,'bindex,'varSort,'sort,'opSym,'sTerm)semDom\"\nassumes *: \"sWlsDisj SEM\" and **: \"igWls (asIMOD SEM) s X\"\nshows \"igAbs (asIMOD SEM) xs x X =\n(\\<lambda>val. if sWlsVal SEM val then sAbs xs (\\<lambda>sX. if sWls SEM (asSort xs) sX\n                                                then X (val (x := sX)_xs)\n                                                else sDummy SEM s)\n                          else undefined)\"", "lemma asIMOD_igFresh:\n\"igFresh (asIMOD SEM) ys y X =\n(\\<forall> val val'. sWlsVal SEM val \\<and> sWlsVal SEM val' \\<and> eqBut val val' ys y\n             \\<longrightarrow> X val = X val')\"", "lemma asIMOD_igFreshAbs:\n\"igFreshAbs (asIMOD SEM) ys y A =\n(\\<forall> val val'. sWlsVal SEM val \\<and> sWlsVal SEM val' \\<and> eqBut val val' ys y\n             \\<longrightarrow> A val = A val')\"", "lemma asIMOD_igSwap:\n\"igSwap (asIMOD SEM) zs z1 z2 X =\n(\\<lambda>val. if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs) else undefined)\"", "lemma asIMOD_igSwapAbs:\n\"igSwapAbs (asIMOD SEM) zs z1 z2 A =\n(\\<lambda>val. if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs) else undefined)\"", "lemma asIMOD_igSubst:\n\"igSubst (asIMOD SEM) ys Y y X =\n(\\<lambda>val. if sWlsVal SEM val then X (val (y := Y val)_ys) else undefined)\"", "lemma asIMOD_igSubstAbs:\n\"igSubstAbs (asIMOD SEM) ys Y y A =\n(\\<lambda>val. if sWlsVal SEM val then A (val (y := Y val)_ys) else undefined)\"", "lemma asIMOD_igWlsInp: \nassumes \"sWlsNE SEM\"\nshows\n\"igWlsInp (asIMOD SEM) delta inp \\<longleftrightarrow> \n ((\\<forall> val. liftAll (\\<lambda>X. sWlsVal SEM val \\<or> X val = undefined) inp) \\<and>\n  (\\<forall> val. sWlsVal SEM val \\<longrightarrow> sWlsInp SEM delta (lift (\\<lambda>X. X val) inp)))\"", "lemma asIMOD_igSwapInp:\n\"sWlsVal SEM val \\<Longrightarrow> \n lift (\\<lambda>X. X val) (igSwapInp (asIMOD SEM) zs z1 z2 inp) =\n lift (\\<lambda>X. X (swapVal zs z1 z2 val)) inp\"", "lemma asIMOD_igSubstInp:\n\"sWlsVal SEM val \\<Longrightarrow> \n lift (\\<lambda>X. X val) (igSubstInp (asIMOD SEM) ys Y y inp) =\n lift (\\<lambda>X. X (val (y := Y val)_ys)) inp\"", "lemma asIMOD_igWlsBinp: \nassumes \"sWlsNE SEM\"\nshows\n\"igWlsBinp (asIMOD SEM) delta binp =\n ((\\<forall> val. liftAll (\\<lambda>X. sWlsVal SEM val \\<or> X val = undefined) binp) \\<and>\n  (\\<forall> val. sWlsVal SEM val \\<longrightarrow> sWlsBinp SEM delta (lift (\\<lambda>X. X val) binp)))\"", "lemma asIMOD_igSwapBinp:\n\"sWlsVal SEM val \\<Longrightarrow> \n lift (\\<lambda>A. A val) (igSwapBinp (asIMOD SEM) zs z1 z2 binp) =\n lift (\\<lambda>A. A (swapVal zs z1 z2 val)) binp\"", "lemma asIMOD_igSubstBinp:\n\"sWlsVal SEM val \\<Longrightarrow> \n lift (\\<lambda>A. A val) (igSubstBinp (asIMOD SEM) ys Y y binp) =\n lift (\\<lambda>A. A (val (y := Y val)_ys)) binp\"", "lemma asIMOD_igWlsDisj:\n\"sWlsNE SEM \\<Longrightarrow> sWlsDisj SEM \\<Longrightarrow> igWlsDisj (asIMOD SEM)\"", "lemma asIMOD_igWlsAbsDisj:\n\"sWlsNE SEM \\<Longrightarrow> sWlsDisj SEM \\<Longrightarrow> igWlsAbsDisj (asIMOD SEM)\"", "lemma asIMOD_igWlsAllDisj: \n\"sWlsNE SEM \\<Longrightarrow> sWlsDisj SEM \\<Longrightarrow> igWlsAllDisj (asIMOD SEM)\"", "lemma asIMOD_igWlsAbsIsInBar:\n\"sWlsNE SEM \\<Longrightarrow> igWlsAbsIsInBar (asIMOD SEM)\"", "lemma asIMOD_igVarIPresIGWls: \"igVarIPresIGWls (asIMOD SEM)\"", "lemma asIMOD_igAbsIPresIGWls:\n\"sWlsDisj SEM \\<Longrightarrow> igAbsIPresIGWls (asIMOD SEM)\"", "lemma asIMOD_igOpIPresIGWls: \n\"sOpPrSWls SEM \\<Longrightarrow> sWlsNE SEM \\<Longrightarrow> igOpIPresIGWls (asIMOD SEM)\"", "lemma asIMOD_igConsIPresIGWls: \n\"wlsSEM SEM \\<Longrightarrow> igConsIPresIGWls (asIMOD SEM)\"", "lemma asIMOD_igSwapIPresIGWls: \"igSwapIPresIGWls (asIMOD SEM)\"", "lemma asIMOD_igSwapAbsIPresIGWlsAbs: \"igSwapAbsIPresIGWlsAbs (asIMOD SEM)\"", "lemma asIMOD_igSwapAllIPresIGWlsAll: \"igSwapAllIPresIGWlsAll (asIMOD SEM)\"", "lemma asIMOD_igSubstIPresIGWls: \"igSubstIPresIGWls (asIMOD SEM)\"", "lemma asIMOD_igSubstAbsIPresIGWlsAbs: \"igSubstAbsIPresIGWlsAbs (asIMOD SEM)\"", "lemma asIMOD_igSubstAllIPresIGWlsAll: \"igSubstAllIPresIGWlsAll (asIMOD SEM)\"", "lemma asIMOD_igFreshIGVar: \"igFreshIGVar (asIMOD SEM)\"", "lemma asIMOD_igFreshIGAbs1:\n\"sWlsDisj SEM \\<Longrightarrow> igFreshIGAbs1 (asIMOD SEM)\"", "lemma asIMOD_igFreshIGAbs2:\n\"sWlsDisj SEM \\<Longrightarrow> igFreshIGAbs2 (asIMOD SEM)\"", "lemma asIMOD_igFreshIGOp:\nfixes SEM :: \"('index,'bindex,'varSort,'sort,'opSym,'sTerm)semDom\"\nshows \"igFreshIGOp (asIMOD SEM)\"", "lemma asIMOD_igFreshCls:\nassumes \"sWlsDisj SEM\"\nshows \"igFreshCls (asIMOD SEM)\"", "lemma asIMOD_igSwapIGVar: \"igSwapIGVar (asIMOD SEM)\"", "lemma asIMOD_igSwapIGAbs: \"igSwapIGAbs (asIMOD SEM)\"", "lemma asIMOD_igSwapIGOp: \"igSwapIGOp (asIMOD SEM)\"", "lemma asIMOD_igSwapCls: \"igSwapCls (asIMOD SEM)\"", "lemma asIMOD_igSubstIGVar1: \"igSubstIGVar1 (asIMOD SEM)\"", "lemma asIMOD_igSubstIGVar2: \"igSubstIGVar2 (asIMOD SEM)\"", "lemma asIMOD_igSubstIGAbs: \"igSubstIGAbs (asIMOD SEM)\"", "lemma asIMOD_igSubstIGOp: \"igSubstIGOp (asIMOD SEM)\"", "lemma asIMOD_igSubstCls: \"igSubstCls (asIMOD SEM)\"", "lemma updVal_swapVal_eqBut: \"eqBut (val (x := sX)_xs) ((val (y := sX)_xs) ^[y \\<and> x]_xs) xs y\"", "lemma asIMOD_igAbsCongS: \"sWlsDisj SEM \\<Longrightarrow> igAbsCongS (asIMOD SEM)\"", "lemma asIMOD_igAbs3:\nassumes \"sWlsDisj SEM\" and \"igWls (asIMOD SEM) s X\"\nshows\n\"igAbs (asIMOD SEM) xs y (igSubst (asIMOD SEM) xs (igVar (asIMOD SEM) xs y) x X) =\n (\\<lambda>val. if sWlsVal SEM val\n            then sAbs xs (\\<lambda>sX. if sWls SEM (asSort xs) sX\n                                 then (igSubst (asIMOD SEM) xs (igVar (asIMOD SEM) xs y) x X) (val (y := sX)_xs)\n                                 else sDummy SEM s)\n            else undefined)\"", "lemma asIMOD_igAbsRen:\n\"sWlsDisj SEM \\<Longrightarrow> igAbsRen (asIMOD SEM)\"", "lemma asIMOD_wlsFSw:\nassumes \"wlsSEM SEM\"\nshows \"iwlsFSw (asIMOD SEM)\"", "lemma asIMOD_wlsFSb:\nassumes \"wlsSEM SEM\"\nshows \"iwlsFSb (asIMOD SEM)\"", "lemma asIMOD_wlsFSwSb: \"wlsSEM SEM \\<Longrightarrow> iwlsFSwSb (asIMOD SEM)\"", "lemma asIMOD_wlsFSbSw: \"wlsSEM SEM \\<Longrightarrow> iwlsFSbSw (asIMOD SEM)\"", "lemma semIntAll_termFSwSbImorph:\n\"wlsSEM SEM \\<Longrightarrow>\n termFSwSbImorph (semInt SEM) (semIntAbs SEM) (asIMOD SEM)\"", "lemma semInt_prWls:\n\"wlsSEM SEM \\<Longrightarrow> prWls (semInt SEM) SEM\"", "lemma semIntAbs_prWlsAbs:\n\"wlsSEM SEM \\<Longrightarrow> prWlsAbs (semIntAbs SEM) SEM\"", "lemma semIntAll_prWlsAll:\n\"wlsSEM SEM \\<Longrightarrow> prWlsAll (semInt SEM) (semIntAbs SEM) SEM\"", "lemma semInt_prVar:\n\"wlsSEM SEM \\<Longrightarrow> prVar (semInt SEM) SEM\"", "lemma semIntAll_prAbs:\nfixes SEM :: \"('index,'bindex,'varSort,'sort,'opSym,'sTerm)semDom\"\nassumes \"wlsSEM SEM\"\nshows \"prAbs (semInt SEM) (semIntAbs SEM) SEM\"", "lemma semIntAll_prOp:\nassumes \"wlsSEM SEM\"\nshows \"prOp (semInt SEM) (semIntAbs SEM) SEM\"", "lemma semIntAll_prCons:\nassumes \"wlsSEM SEM\"\nshows \"prCons (semInt SEM) (semIntAbs SEM) SEM\"", "lemma semInt_prFresh:\nassumes \"wlsSEM SEM\"\nshows \"prFresh (semInt SEM) SEM\"", "lemma semIntAbs_prFreshAbs:\nassumes \"wlsSEM SEM\"\nshows \"prFreshAbs (semIntAbs SEM) SEM\"", "lemma semIntAll_prFreshAll:\nassumes \"wlsSEM SEM\"\nshows \"prFreshAll (semInt SEM) (semIntAbs SEM) SEM\"", "lemma semInt_prSwap:\nassumes \"wlsSEM SEM\"\nshows \"prSwap (semInt SEM) SEM\"", "lemma semIntAbs_prSwapAbs:\nassumes \"wlsSEM SEM\"\nshows \"prSwapAbs (semIntAbs SEM) SEM\"", "lemma semIntAll_prSwapAll:\nassumes \"wlsSEM SEM\"\nshows \"prSwapAll (semInt SEM) (semIntAbs SEM) SEM\"", "lemma semInt_prSubst:\nassumes \"wlsSEM SEM\"\nshows \"prSubst (semInt SEM) SEM\"", "lemma semIntAbs_prSubstAbs:\nassumes \"wlsSEM SEM\"\nshows \"prSubstAbs (semInt SEM) (semIntAbs SEM) SEM\"", "lemma semIntAll_prSubstAll:\nassumes \"wlsSEM SEM\"\nshows \"prSubstAll (semInt SEM) (semIntAbs SEM) SEM\"", "theorem semIntAll_compInt:\nassumes \"wlsSEM SEM\"\nshows \"compInt (semInt SEM) (semIntAbs SEM) SEM\"", "lemmas semDom_simps = updVal_simps swapVal_simps"], "translations": [["", "lemma sWlsNE_imp_sWlsAbsNE:\nassumes \"sWlsNE SEM\"\nshows \"sWlsAbsNE SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsAbsNE SEM", "unfolding sWlsAbsNE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>us s.\n       isInBar (us, s) \\<longrightarrow>\n       (\\<exists>sA. sWlsAbs SEM (us, s) sA)", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>us s.\n       isInBar (us, s) \\<Longrightarrow> \\<exists>sA. sWlsAbs SEM (us, s) sA", "fix xs s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>us s.\n       isInBar (us, s) \\<Longrightarrow> \\<exists>sA. sWlsAbs SEM (us, s) sA", "obtain sY where \"sWls SEM s sY\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sY. sWls SEM s sY \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  sWlsNE SEM\n\ngoal (1 subgoal):\n 1. (\\<And>sY. sWls SEM s sY \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding sWlsNE_def"], ["proof (prove)\nusing this:\n  \\<forall>s. \\<exists>sX. sWls SEM s sX\n\ngoal (1 subgoal):\n 1. (\\<And>sY. sWls SEM s sY \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  sWls SEM s sY\n\ngoal (1 subgoal):\n 1. \\<And>us s.\n       isInBar (us, s) \\<Longrightarrow> \\<exists>sA. sWlsAbs SEM (us, s) sA", "moreover"], ["proof (state)\nthis:\n  sWls SEM s sY\n\ngoal (1 subgoal):\n 1. \\<And>us s.\n       isInBar (us, s) \\<Longrightarrow> \\<exists>sA. sWlsAbs SEM (us, s) sA", "assume \"isInBar (xs,s)\""], ["proof (state)\nthis:\n  isInBar (xs, s)\n\ngoal (1 subgoal):\n 1. \\<And>us s.\n       isInBar (us, s) \\<Longrightarrow> \\<exists>sA. sWlsAbs SEM (us, s) sA", "ultimately"], ["proof (chain)\npicking this:\n  sWls SEM s sY\n  isInBar (xs, s)", "have \"sWlsAbs SEM (xs,s) (sAbs xs (\\<lambda>sX. if sWls SEM (asSort xs) sX\n                                           then sY\n                                           else sDummy SEM s))\""], ["proof (prove)\nusing this:\n  sWls SEM s sY\n  isInBar (xs, s)\n\ngoal (1 subgoal):\n 1. sWlsAbs SEM (xs, s)\n     (sAbs xs\n       (\\<lambda>sX. if sWls SEM (asSort xs) sX then sY else sDummy SEM s))", "by simp"], ["proof (state)\nthis:\n  sWlsAbs SEM (xs, s)\n   (sAbs xs\n     (\\<lambda>sX. if sWls SEM (asSort xs) sX then sY else sDummy SEM s))\n\ngoal (1 subgoal):\n 1. \\<And>us s.\n       isInBar (us, s) \\<Longrightarrow> \\<exists>sA. sWlsAbs SEM (us, s) sA", "thus \"\\<exists>sA. sWlsAbs SEM (xs,s) sA\""], ["proof (prove)\nusing this:\n  sWlsAbs SEM (xs, s)\n   (sAbs xs\n     (\\<lambda>sX. if sWls SEM (asSort xs) sX then sY else sDummy SEM s))\n\ngoal (1 subgoal):\n 1. \\<exists>sA. sWlsAbs SEM (xs, s) sA", "by blast"], ["proof (state)\nthis:\n  \\<exists>sA. sWlsAbs SEM (xs, s) sA\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sWlsDisj_imp_sWlsAbsDisj:\n\"sWlsDisj SEM \\<Longrightarrow> sWlsNE SEM \\<Longrightarrow> sWlsAbsDisj SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsDisj SEM; sWlsNE SEM\\<rbrakk>\n    \\<Longrightarrow> sWlsAbsDisj SEM", "by (simp add: sWlsAbsDisj_def sWlsNE_def sWlsDisj_def) \n   (smt prod.inject sAbs.inject sWlsAbs.elims(2))"], ["", "lemma sWlsNE_imp_sWlsValNE:\n\"sWlsNE SEM \\<Longrightarrow> sWlsValNE SEM x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsNE SEM \\<Longrightarrow> sWlsValNE SEM x", "by (auto simp: sWlsNE_def  sWlsValNE_def sWlsVal_def \n intro!: exI someI_ex[of \"(\\<lambda> sY. sWls SEM (asSort _) sY)\"])"], ["", "theorem updVal_simp[simp]:\n\"(val (x := sX)_xs) ys y = (if ys = xs \\<and> y = x then sX else val ys y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (val (x := sX)_xs) ys y =\n    (if ys = xs \\<and> y = x then sX else val ys y)", "unfolding updVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ys = xs \\<and> y = x then sX else val ys y) =\n    (if ys = xs \\<and> y = x then sX else val ys y)", "by simp"], ["", "theorem updVal_over[simp]:\n\"((val (x := sX)_xs) (x := sX')_xs) = (val (x := sX')_xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val (x := sX)_xs (x := sX')_xs = val (x := sX')_xs", "unfolding updVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ys y.\n        if ys = xs \\<and> y = x then sX'\n        else if ys = xs \\<and> y = x then sX else val ys y) =\n    (\\<lambda>ys y. if ys = xs \\<and> y = x then sX' else val ys y)", "by fastforce"], ["", "theorem updVal_commute:\nassumes \"xs \\<noteq> ys \\<or> x \\<noteq> y\"\nshows \"((val (x := sX)_xs) (y := sY)_ys) = ((val (y := sY)_ys) (x := sX)_xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val (x := sX)_xs (y := sY)_ys = val (y := sY)_ys (x := sX)_xs", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> ys \\<or> x \\<noteq> y\n\ngoal (1 subgoal):\n 1. val (x := sX)_xs (y := sY)_ys = val (y := sY)_ys (x := sX)_xs", "unfolding updVal_def"], ["proof (prove)\nusing this:\n  xs \\<noteq> ys \\<or> x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (\\<lambda>ysa ya.\n        if ysa = ys \\<and> ya = y then sY\n        else if ysa = xs \\<and> ya = x then sX else val ysa ya) =\n    (\\<lambda>ysa ya.\n        if ysa = xs \\<and> ya = x then sX\n        else if ysa = ys \\<and> ya = y then sY else val ysa ya)", "by fastforce"], ["", "theorem updVal_preserves_sWls[simp]:\nassumes \"sWls SEM (asSort xs) sX\" and \"sWlsVal SEM val\"\nshows \"sWlsVal SEM (val (x := sX)_xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsVal SEM (val (x := sX)_xs)", "using assms"], ["proof (prove)\nusing this:\n  sWls SEM (asSort xs) sX\n  sWlsVal SEM val\n\ngoal (1 subgoal):\n 1. sWlsVal SEM (val (x := sX)_xs)", "unfolding sWlsVal_def"], ["proof (prove)\nusing this:\n  sWls SEM (asSort xs) sX\n  \\<forall>ys y. sWls SEM (asSort ys) (val ys y)\n\ngoal (1 subgoal):\n 1. \\<forall>ys y. sWls SEM (asSort ys) ((val (x := sX)_xs) ys y)", "by auto"], ["", "lemmas updVal_simps = updVal_simp updVal_over updVal_preserves_sWls"], ["", "theorem swapVal_ident[simp]: \"(val ^[x \\<and> x]_xs) = val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val ^[x \\<and> x]_xs = val", "unfolding swapVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xsa xa. val xsa (xa @xsa[x \\<and> x]_xs)) = val", "by auto"], ["", "theorem swapVal_compose:\n\"((val ^[x \\<and> y]_zs) ^[x' \\<and> y']_zs') =\n ((val ^[x' @zs'[x \\<and> y]_zs \\<and> y' @zs'[x \\<and> y]_zs]_zs') ^[x \\<and> y]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val ^[x \\<and> y]_zs ^[x' \\<and> y']_zs' =\n    val ^[x' @zs'[x \\<and> y]_zs \\<and> y' @zs'[x \\<and> y]_zs]_zs' ^[x \\<and> y]_zs", "unfolding swapVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xs xa. val xs (xa @xs[x' \\<and> y']_zs' @xs[x \\<and> y]_zs)) =\n    (\\<lambda>xs xa.\n        val xs\n         (xa @xs[x \\<and> y]_zs @xs[x' @zs'[x \\<and> y]_zs \\<and> y' @zs'[x \\<and> y]_zs]_zs'))", "by (metis sw_compose)"], ["", "theorem swapVal_commute:\n\"zs \\<noteq> zs' \\<or> {x,y} \\<inter> {x',y'} = {} \\<Longrightarrow>\n ((val ^[x \\<and> y]_zs) ^[x' \\<and> y']_zs') = ((val ^[x' \\<and> y']_zs') ^[x \\<and> y]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zs \\<noteq> zs' \\<or> {x, y} \\<inter> {x', y'} = {} \\<Longrightarrow>\n    val ^[x \\<and> y]_zs ^[x' \\<and> y']_zs' =\n    val ^[x' \\<and> y']_zs' ^[x \\<and> y]_zs", "using swapVal_compose[of zs' x' y' zs x y val]"], ["proof (prove)\nusing this:\n  val ^[x \\<and> y]_zs ^[x' \\<and> y']_zs' =\n  val ^[x' @zs'[x \\<and> y]_zs \\<and> y' @zs'[x \\<and> y]_zs]_zs' ^[x \\<and> y]_zs\n\ngoal (1 subgoal):\n 1. zs \\<noteq> zs' \\<or> {x, y} \\<inter> {x', y'} = {} \\<Longrightarrow>\n    val ^[x \\<and> y]_zs ^[x' \\<and> y']_zs' =\n    val ^[x' \\<and> y']_zs' ^[x \\<and> y]_zs", "by(simp add: sw_def)"], ["", "lemma swapVal_involutive[simp]: \"((val ^[x \\<and> y]_zs) ^[x \\<and> y]_zs) = val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val ^[x \\<and> y]_zs ^[x \\<and> y]_zs = val", "unfolding swapVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xs xa. val xs (xa @xs[x \\<and> y]_zs @xs[x \\<and> y]_zs)) =\n    val", "by auto"], ["", "lemma swapVal_sym: \"(val ^[x \\<and> y]_zs) = (val ^[y \\<and> x]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val ^[x \\<and> y]_zs = val ^[y \\<and> x]_zs", "unfolding swapVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xs xa. val xs (xa @xs[x \\<and> y]_zs)) =\n    (\\<lambda>xs xa. val xs (xa @xs[y \\<and> x]_zs))", "by(auto simp add: sw_sym)"], ["", "lemma swapVal_preserves_sWls1:\nassumes \"sWlsVal SEM val\"\nshows \"sWlsVal SEM (val ^[z1 \\<and> z2]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsVal SEM (val ^[z1 \\<and> z2]_zs)", "using assms"], ["proof (prove)\nusing this:\n  sWlsVal SEM val\n\ngoal (1 subgoal):\n 1. sWlsVal SEM (val ^[z1 \\<and> z2]_zs)", "unfolding sWlsVal_def swapVal_def"], ["proof (prove)\nusing this:\n  \\<forall>ys y. sWls SEM (asSort ys) (val ys y)\n\ngoal (1 subgoal):\n 1. \\<forall>ys y. sWls SEM (asSort ys) (val ys (y @ys[z1 \\<and> z2]_zs))", "by simp"], ["", "theorem swapVal_preserves_sWls[simp]:\n\"sWlsVal SEM (val ^[z1 \\<and> z2]_zs) = sWlsVal SEM val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsVal SEM (val ^[z1 \\<and> z2]_zs) = sWlsVal SEM val", "using swapVal_preserves_sWls1[of _ _ zs z1 z2]"], ["proof (prove)\nusing this:\n  sWlsVal ?SEM ?val \\<Longrightarrow> sWlsVal ?SEM (?val ^[z1 \\<and> z2]_zs)\n\ngoal (1 subgoal):\n 1. sWlsVal SEM (val ^[z1 \\<and> z2]_zs) = sWlsVal SEM val", "by fastforce"], ["", "lemmas swapVal_simps = swapVal_ident swapVal_involutive swapVal_preserves_sWls"], ["", "lemma updVal_swapVal:\n\"((val (x := sX)_xs) ^[y1 \\<and> y2]_ys) =\n ((val ^[y1 \\<and> y2]_ys) ((x @xs[y1 \\<and> y2]_ys) := sX)_xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val (x := sX)_xs ^[y1 \\<and> y2]_ys =\n    val ^[y1 \\<and> y2]_ys (x @xs[y1 \\<and> y2]_ys := sX)_xs", "unfolding swapVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xsa xa. (val (x := sX)_xs) xsa (xa @xsa[y1 \\<and> y2]_ys)) =\n    \\<lambda>xs x.\n       val xs (x @xs[y1 \\<and> y2]_ys) (x @xs[y1 \\<and> y2]_ys := sX)_xs", "by fastforce"], ["", "lemma updVal_preserves_eqBut:\nassumes \"eqBut val val' ys y\"\nshows \"eqBut (val (x := sX)_xs) (val' (x := sX)_xs) ys y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqBut (val (x := sX)_xs) (val' (x := sX)_xs) ys y", "using assms"], ["proof (prove)\nusing this:\n  eqBut val val' ys y\n\ngoal (1 subgoal):\n 1. eqBut (val (x := sX)_xs) (val' (x := sX)_xs) ys y", "unfolding eqBut_def updVal_def"], ["proof (prove)\nusing this:\n  \\<forall>ysa ya. ysa = ys \\<and> ya = y \\<or> val ysa ya = val' ysa ya\n\ngoal (1 subgoal):\n 1. \\<forall>ysa ya.\n       ysa = ys \\<and> ya = y \\<or>\n       (if ysa = xs \\<and> ya = x then sX else val ysa ya) =\n       (if ysa = xs \\<and> ya = x then sX else val' ysa ya)", "by auto"], ["", "lemma updVal_eqBut_eq:\nassumes \"eqBut val val' ys y\"\nshows \"(val (y := sY)_ys) = (val' (y := sY)_ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val (y := sY)_ys = val' (y := sY)_ys", "using assms"], ["proof (prove)\nusing this:\n  eqBut val val' ys y\n\ngoal (1 subgoal):\n 1. val (y := sY)_ys = val' (y := sY)_ys", "unfolding eqBut_def"], ["proof (prove)\nusing this:\n  \\<forall>ysa ya. ysa = ys \\<and> ya = y \\<or> val ysa ya = val' ysa ya\n\ngoal (1 subgoal):\n 1. val (y := sY)_ys = val' (y := sY)_ys", "by fastforce"], ["", "lemma swapVal_preserves_eqBut:\nassumes \"eqBut val val' xs x\"\nshows \"eqBut (val ^[z1 \\<and> z2]_zs) (val' ^[z1 \\<and> z2]_zs) xs (x @xs[z1 \\<and> z2]_zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqBut (val ^[z1 \\<and> z2]_zs) (val' ^[z1 \\<and> z2]_zs) xs\n     (x @xs[z1 \\<and> z2]_zs)", "using assms"], ["proof (prove)\nusing this:\n  eqBut val val' xs x\n\ngoal (1 subgoal):\n 1. eqBut (val ^[z1 \\<and> z2]_zs) (val' ^[z1 \\<and> z2]_zs) xs\n     (x @xs[z1 \\<and> z2]_zs)", "unfolding eqBut_def swapVal_def"], ["proof (prove)\nusing this:\n  \\<forall>ys y. ys = xs \\<and> y = x \\<or> val ys y = val' ys y\n\ngoal (1 subgoal):\n 1. \\<forall>ys y.\n       ys = xs \\<and> y = x @xs[z1 \\<and> z2]_zs \\<or>\n       val ys (y @ys[z1 \\<and> z2]_zs) = val' ys (y @ys[z1 \\<and> z2]_zs)", "by force"], ["", "subsection \\<open>Interpretation maps\\<close>"], ["", "text\\<open>An interpretation map, of syntax in a semantic domain,\nis the usual one w.r.t. valuations.  Here we state its compostionality conditions\n(including the ``substitution lemma\"), and later we prove the existence of a map\nsatisfying these conditions.\\<close>"], ["", "subsubsection \\<open>Definitions\\<close>"], ["", "text \\<open>Below, prefix ``pr\" means ``preserves\".\\<close>"], ["", "definition prWls where\n\"prWls g SEM \\<equiv> \\<forall> s X val.\n    wls s X \\<and> sWlsVal SEM val\n    \\<longrightarrow> sWls SEM s (g X val)\""], ["", "definition prWlsAbs where\n\"prWlsAbs gA SEM \\<equiv> \\<forall> us s A val.\n    wlsAbs (us,s) A \\<and> sWlsVal SEM val\n    \\<longrightarrow> sWlsAbs SEM (us,s) (gA A val)\""], ["", "definition prWlsAll where\n\"prWlsAll g gA SEM \\<equiv> prWls g SEM \\<and> prWlsAbs gA SEM\""], ["", "definition prVar where\n\"prVar g SEM \\<equiv> \\<forall> xs x val.\n    sWlsVal SEM val \\<longrightarrow> g (Var xs x) val = val xs x\""], ["", "definition prAbs where\n\"prAbs g gA SEM \\<equiv> \\<forall> xs s x X val.\n    isInBar (xs,s) \\<and> wls s X \\<and> sWlsVal SEM val\n    \\<longrightarrow>\n    gA (Abs xs x X) val =\n    sAbs xs (\\<lambda>sX. if sWls SEM (asSort xs) sX then g X (val (x := sX)_xs)\n                                             else sDummy SEM s)\""], ["", "definition prOp where\n\"prOp g gA SEM \\<equiv> \\<forall> delta inp binp val.\n    wlsInp delta inp \\<and> wlsBinp delta binp \\<and> sWlsVal SEM val\n    \\<longrightarrow>\n    g (Op delta inp binp) val =\n    sOp SEM delta (lift (\\<lambda>X. g X val) inp)\n                  (lift (\\<lambda>A. gA A val) binp)\""], ["", "definition prCons where\n\"prCons g gA SEM \\<equiv> prVar g SEM \\<and> prAbs g gA SEM \\<and> prOp g gA SEM\""], ["", "definition prFresh where\n\"prFresh g SEM \\<equiv> \\<forall> ys y s X val val'.\n   wls s X \\<and> fresh ys y X \\<and>\n   sWlsVal SEM val \\<and> sWlsVal SEM val' \\<and> eqBut val val' ys y\n   \\<longrightarrow> g X val = g X val'\""], ["", "definition prFreshAbs where\n\"prFreshAbs gA SEM \\<equiv> \\<forall> ys y us s A val val'.\n   wlsAbs (us,s) A \\<and> freshAbs ys y A \\<and>\n   sWlsVal SEM val \\<and> sWlsVal SEM val' \\<and> eqBut val val' ys y\n   \\<longrightarrow> gA A val = gA A val'\""], ["", "definition prFreshAll where\n\"prFreshAll g gA SEM \\<equiv> prFresh g SEM \\<and> prFreshAbs gA SEM\""], ["", "definition prSwap where\n\"prSwap g SEM \\<equiv> \\<forall> zs z1 z2 s X val.\n   wls s X \\<and> sWlsVal SEM val\n   \\<longrightarrow>\n   g (X #[z1 \\<and> z2]_zs) val =\n   g X (val ^[z1 \\<and> z2]_zs)\""], ["", "definition prSwapAbs where\n\"prSwapAbs gA SEM \\<equiv> \\<forall> zs z1 z2 us s A val.\n   wlsAbs (us,s) A \\<and> sWlsVal SEM val\n   \\<longrightarrow>\n   gA (A $[z1 \\<and> z2]_zs) val =\n   gA A (val ^[z1 \\<and> z2]_zs)\""], ["", "definition prSwapAll where\n\"prSwapAll g gA SEM \\<equiv> prSwap g SEM \\<and> prSwapAbs gA SEM\""], ["", "definition prSubst where\n\"prSubst g SEM \\<equiv> \\<forall> ys Y y s X val.\n    wls (asSort ys) Y \\<and> wls s X\n    \\<and> sWlsVal SEM val\n    \\<longrightarrow>\n    g (X #[Y / y]_ys) val =\n    g X (val (y := g Y val)_ys)\""], ["", "definition prSubstAbs where\n\"prSubstAbs g gA SEM \\<equiv> \\<forall> ys Y y us s A val.\n    wls (asSort ys) Y \\<and> wlsAbs (us,s) A\n    \\<and> sWlsVal SEM val\n    \\<longrightarrow>\n    gA (A $[Y / y]_ys) val =\n    gA A (val (y := g Y val)_ys)\""], ["", "definition prSubstAll where\n\"prSubstAll g gA SEM \\<equiv> prSubst g SEM \\<and> prSubstAbs g gA SEM\""], ["", "definition compInt where\n\"compInt g gA SEM \\<equiv> prWlsAll g gA SEM \\<and> prCons g gA SEM \\<and>\n prFreshAll g gA SEM \\<and> prSwapAll g gA SEM \\<and> prSubstAll g gA SEM\""], ["", "subsubsection \\<open>Extension of domain preservation to inputs\\<close>"], ["", "lemma prWls_wlsInp:\nassumes \"wlsInp delta inp\" and \"prWls g SEM\" and \"sWlsVal SEM val\"\nshows \"sWlsInp SEM delta (lift (\\<lambda> X. g X val) inp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsInp SEM delta (lift (\\<lambda>X. g X val) inp)", "using assms"], ["proof (prove)\nusing this:\n  wlsInp delta inp\n  prWls g SEM\n  sWlsVal SEM val\n\ngoal (1 subgoal):\n 1. sWlsInp SEM delta (lift (\\<lambda>X. g X val) inp)", "unfolding sWlsInp_def wlsInp_iff liftAll2_def lift_def prWls_def"], ["proof (prove)\nusing this:\n  wlsOpS delta \\<and>\n  sameDom (arOf delta) inp \\<and>\n  (\\<forall>i v1 v2.\n      arOf delta i = Some v1 \\<and> inp i = Some v2 \\<longrightarrow>\n      wls v1 v2)\n  \\<forall>s X val.\n     wls s X \\<and> sWlsVal SEM val \\<longrightarrow> sWls SEM s (g X val)\n  sWlsVal SEM val\n\ngoal (1 subgoal):\n 1. wlsOpS delta \\<and>\n    sameDom (arOf delta)\n     (\\<lambda>i.\n         case inp i of None \\<Rightarrow> None\n         | Some v \\<Rightarrow> Some (g v val)) \\<and>\n    (\\<forall>i v1 v2.\n        arOf delta i = Some v1 \\<and>\n        (case inp i of None \\<Rightarrow> None\n         | Some v \\<Rightarrow> Some (g v val)) =\n        Some v2 \\<longrightarrow>\n        sWls SEM v1 v2)", "by (auto simp add: option.case_eq_if sameDom_def)"], ["", "lemma prWlsAbs_wlsBinp:\nassumes \"wlsBinp delta binp\" and \"prWlsAbs gA SEM\" and \"sWlsVal SEM val\"\nshows \"sWlsBinp SEM delta (lift (\\<lambda> A. gA A val) binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsBinp SEM delta (lift (\\<lambda>A. gA A val) binp)", "using assms"], ["proof (prove)\nusing this:\n  wlsBinp delta binp\n  prWlsAbs gA SEM\n  sWlsVal SEM val\n\ngoal (1 subgoal):\n 1. sWlsBinp SEM delta (lift (\\<lambda>A. gA A val) binp)", "unfolding sWlsBinp_def wlsBinp_iff liftAll2_def lift_def prWlsAbs_def"], ["proof (prove)\nusing this:\n  wlsOpS delta \\<and>\n  sameDom (barOf delta) binp \\<and>\n  (\\<forall>i v1 v2.\n      barOf delta i = Some v1 \\<and> binp i = Some v2 \\<longrightarrow>\n      wlsAbs v1 v2)\n  \\<forall>us s A val.\n     wlsAbs (us, s) A \\<and> sWlsVal SEM val \\<longrightarrow>\n     sWlsAbs SEM (us, s) (gA A val)\n  sWlsVal SEM val\n\ngoal (1 subgoal):\n 1. wlsOpS delta \\<and>\n    sameDom (barOf delta)\n     (\\<lambda>i.\n         case binp i of None \\<Rightarrow> None\n         | Some v \\<Rightarrow> Some (gA v val)) \\<and>\n    (\\<forall>i v1 v2.\n        barOf delta i = Some v1 \\<and>\n        (case binp i of None \\<Rightarrow> None\n         | Some v \\<Rightarrow> Some (gA v val)) =\n        Some v2 \\<longrightarrow>\n        sWlsAbs SEM v1 v2)", "by (auto simp add: option.case_eq_if sameDom_def)"], ["", "end"], ["", "(* context FixSyn *)\n(***************************************)"], ["", "subsection \\<open>The iterative model associated to a semantic domain\\<close>"], ["", "text\\<open>\n``asIMOD SEM\" stands for ``SEM (regarded) as a model\".\n%\n\\footnote{\nWe use the word ``model\" as introduced in the theory ``Models-and-Recursion\".\n}\n%\nThe associated model is built essentially as follows:\n%\n\\\\- Its carrier sets consist of functions from valuations to semantic items.\n%\n\\\\- The construct operations (i.e., those corresponding to the syntactic constructs\nindicated in the given binding signature) are lifted componentwise from those of the semantic domain\n``SEM\" (also taking into account the higher-order nature of of the semantic counterparts of abstractions).\n%\n\\\\- For a map from valuations to items (terms or abstractions), freshness of a variable ``x\"\nis defined as being oblivious what the argument valuation returns for ``x\".\n%\n\\\\- Swapping is defined componentwise, by two iterations of the notion of swapping the\nreturned value of a function.\n%\n\\\\- Substitution of a semantic term ``Y\" for a variable ``y\" is a semantic term ``X\"\nis defined to map each valuation ``val\" to the application of ``X\" to\n[``val\" updated at ``y\" with whatever ``Y\" returns for ``val\"].\n\nNote that:\n%\n\\\\- The construct operations definitions are determined by the desired clauses of the standard\nnotion of interpreting syntax in a semantic domains.\n%\n\\\\- Substitution and freshness are defined having in mind the (again standard) facts of\nthe interpretation commuting with substitution versus valuation update and the interpretation\nbeing oblivious to the valuation of fresh variables.\n\\<close>"], ["", "subsubsection \\<open>Definition and basic facts\\<close>"], ["", "text\\<open>\nThe next two types of ``generalized items\" are used to build models from semantic domains:\n%\n\\footnote{\nRecall that ``generalized items\" inhabit models.\n}\n%\n\\<close>"], ["", "type_synonym ('varSort,'var,'sTerm) gTerm = \"('varSort,'var,'sTerm)val \\<Rightarrow> 'sTerm\""], ["", "type_synonym ('varSort,'var,'sTerm) gAbs = \"('varSort,'var,'sTerm)val \\<Rightarrow> ('varSort,'sTerm)sAbs\""], ["", "(* *************************************************** *)"], ["", "context FixSyn\nbegin"], ["", "definition asIMOD ::\n\"('index,'bindex,'varSort,'sort,'opSym,'sTerm)semDom \\<Rightarrow>\n ('index,'bindex,'varSort,'sort,'opSym,'var,\n  ('varSort,'var,'sTerm)gTerm,\n  ('varSort,'var,'sTerm)gAbs)model\"\nwhere\n\"asIMOD SEM \\<equiv>\n \\<lparr>igWls = \\<lambda>s X. \\<forall> val. (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n                      (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)),\n  igWlsAbs = \\<lambda>(xs,s) A. \\<forall> val. (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n                              (sWlsVal SEM val \\<longrightarrow> sWlsAbs SEM (xs,s) (A val)),\n  igVar = \\<lambda>ys y. \\<lambda>val. if sWlsVal SEM val then val ys y else undefined,\n  igAbs =\n  \\<lambda>xs x X. \\<lambda>val. if sWlsVal SEM val\n                   then sAbs xs (\\<lambda>sX. if sWls SEM (asSort xs) sX\n                                         then X (val (x := sX)_xs)\n                                         else sDummy SEM (SOME s. sWls SEM s (X val)))\n                   else undefined,\n  igOp = \\<lambda>delta inp binp. \\<lambda>val.\n          if sWlsVal SEM val then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                                                (lift (\\<lambda>A. A val) binp)\n                             else undefined,\n  igFresh =\n  \\<lambda>ys y X. \\<forall> val val'. sWlsVal SEM val \\<and> sWlsVal SEM val' \\<and> eqBut val val' ys y\n                       \\<longrightarrow> X val = X val',\n  igFreshAbs =\n  \\<lambda>ys y A. \\<forall> val val'. sWlsVal SEM val \\<and> sWlsVal SEM val' \\<and> eqBut val val' ys y\n                       \\<longrightarrow> A val = A val',\n  igSwap = \\<lambda>zs z1 z2 X. \\<lambda>val. if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs)\n                                                else undefined,\n  igSwapAbs = \\<lambda>zs z1 z2 A. \\<lambda>val. if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs)\n                                                   else undefined,\n  igSubst = \\<lambda>ys Y y X. \\<lambda>val. if sWlsVal SEM val then X (val (y := Y val)_ys)\n                                                else undefined,\n  igSubstAbs = \\<lambda>ys Y y A. \\<lambda>val. if sWlsVal SEM val then A (val (y := Y val)_ys)\n                                                   else undefined\\<rparr>\""], ["", "text\\<open>Next we state, as usual, the direct definitions of the operators and relations\nof associated model, freeing ourselves from\nhaving to go through the ``asIMOD\" definition each time we reason about them.\\<close>"], ["", "lemma asIMOD_igWls:\n\"igWls (asIMOD SEM) s X \\<longleftrightarrow> \n (\\<forall> val. (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n         (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls (asIMOD SEM) s X =\n    (\\<forall>val.\n        (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n        (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)))", "unfolding asIMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWls\n     \\<lparr>igWls =\n               \\<lambda>s X.\n                  \\<forall>val.\n                     (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n                     (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)),\n        igWlsAbs =\n          \\<lambda>(xs, s) A.\n             \\<forall>val.\n                (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n                (sWlsVal SEM val \\<longrightarrow>\n                 sWlsAbs SEM (xs, s) (A val)),\n        igVar =\n          \\<lambda>ys y val.\n             if sWlsVal SEM val then val ys y else undefined,\n        igAbs =\n          \\<lambda>xs x X val.\n             if sWlsVal SEM val\n             then sAbs xs\n                   (\\<lambda>sX.\n                       if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                       else sDummy SEM (SOME s. sWls SEM s (X val)))\n             else undefined,\n        igOp =\n          \\<lambda>delta inp binp val.\n             if sWlsVal SEM val\n             then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                   (lift (\\<lambda>A. A val) binp)\n             else undefined,\n        igFresh =\n          \\<lambda>ys y X.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                X val = X val',\n        igFreshAbs =\n          \\<lambda>ys y A.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                A val = A val',\n        igSwap =\n          \\<lambda>zs z1 z2 X val.\n             if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 A val.\n             if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSubst =\n          \\<lambda>ys Y y X val.\n             if sWlsVal SEM val then X (val (y := Y val)_ys) else undefined,\n        igSubstAbs =\n          \\<lambda>ys Y y A val.\n             if sWlsVal SEM val then A (val (y := Y val)_ys)\n             else undefined\\<rparr>\n     s X =\n    (\\<forall>val.\n        (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n        (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)))", "by simp"], ["", "lemma asIMOD_igWlsAbs:\n\"igWlsAbs (asIMOD SEM) (us,s) A \\<longleftrightarrow> \n (\\<forall> val. (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n         (sWlsVal SEM val \\<longrightarrow> sWlsAbs SEM (us,s) (A val)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAbs (asIMOD SEM) (us, s) A =\n    (\\<forall>val.\n        (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n        (sWlsVal SEM val \\<longrightarrow> sWlsAbs SEM (us, s) (A val)))", "unfolding asIMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsAbs\n     \\<lparr>igWls =\n               \\<lambda>s X.\n                  \\<forall>val.\n                     (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n                     (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)),\n        igWlsAbs =\n          \\<lambda>(xs, s) A.\n             \\<forall>val.\n                (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n                (sWlsVal SEM val \\<longrightarrow>\n                 sWlsAbs SEM (xs, s) (A val)),\n        igVar =\n          \\<lambda>ys y val.\n             if sWlsVal SEM val then val ys y else undefined,\n        igAbs =\n          \\<lambda>xs x X val.\n             if sWlsVal SEM val\n             then sAbs xs\n                   (\\<lambda>sX.\n                       if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                       else sDummy SEM (SOME s. sWls SEM s (X val)))\n             else undefined,\n        igOp =\n          \\<lambda>delta inp binp val.\n             if sWlsVal SEM val\n             then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                   (lift (\\<lambda>A. A val) binp)\n             else undefined,\n        igFresh =\n          \\<lambda>ys y X.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                X val = X val',\n        igFreshAbs =\n          \\<lambda>ys y A.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                A val = A val',\n        igSwap =\n          \\<lambda>zs z1 z2 X val.\n             if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 A val.\n             if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSubst =\n          \\<lambda>ys Y y X val.\n             if sWlsVal SEM val then X (val (y := Y val)_ys) else undefined,\n        igSubstAbs =\n          \\<lambda>ys Y y A val.\n             if sWlsVal SEM val then A (val (y := Y val)_ys)\n             else undefined\\<rparr>\n     (us, s) A =\n    (\\<forall>val.\n        (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n        (sWlsVal SEM val \\<longrightarrow> sWlsAbs SEM (us, s) (A val)))", "by simp"], ["", "lemma asIMOD_igOp:\n\"igOp (asIMOD SEM) delta inp binp =\n(\\<lambda>val. if sWlsVal SEM val then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                                             (lift (\\<lambda>A. A val) binp)\n                          else undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igOp (asIMOD SEM) delta inp binp =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n              (lift (\\<lambda>A. A val) binp)\n        else undefined)", "unfolding asIMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igOp\n     \\<lparr>igWls =\n               \\<lambda>s X.\n                  \\<forall>val.\n                     (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n                     (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)),\n        igWlsAbs =\n          \\<lambda>(xs, s) A.\n             \\<forall>val.\n                (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n                (sWlsVal SEM val \\<longrightarrow>\n                 sWlsAbs SEM (xs, s) (A val)),\n        igVar =\n          \\<lambda>ys y val.\n             if sWlsVal SEM val then val ys y else undefined,\n        igAbs =\n          \\<lambda>xs x X val.\n             if sWlsVal SEM val\n             then sAbs xs\n                   (\\<lambda>sX.\n                       if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                       else sDummy SEM (SOME s. sWls SEM s (X val)))\n             else undefined,\n        igOp =\n          \\<lambda>delta inp binp val.\n             if sWlsVal SEM val\n             then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                   (lift (\\<lambda>A. A val) binp)\n             else undefined,\n        igFresh =\n          \\<lambda>ys y X.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                X val = X val',\n        igFreshAbs =\n          \\<lambda>ys y A.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                A val = A val',\n        igSwap =\n          \\<lambda>zs z1 z2 X val.\n             if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 A val.\n             if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSubst =\n          \\<lambda>ys Y y X val.\n             if sWlsVal SEM val then X (val (y := Y val)_ys) else undefined,\n        igSubstAbs =\n          \\<lambda>ys Y y A val.\n             if sWlsVal SEM val then A (val (y := Y val)_ys)\n             else undefined\\<rparr>\n     delta inp binp =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n              (lift (\\<lambda>A. A val) binp)\n        else undefined)", "by simp"], ["", "lemma asIMOD_igVar:\n\"igVar (asIMOD SEM) ys y = (\\<lambda>val. if sWlsVal SEM val then val ys y else undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igVar (asIMOD SEM) ys y =\n    (\\<lambda>val. if sWlsVal SEM val then val ys y else undefined)", "unfolding asIMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igVar\n     \\<lparr>igWls =\n               \\<lambda>s X.\n                  \\<forall>val.\n                     (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n                     (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)),\n        igWlsAbs =\n          \\<lambda>(xs, s) A.\n             \\<forall>val.\n                (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n                (sWlsVal SEM val \\<longrightarrow>\n                 sWlsAbs SEM (xs, s) (A val)),\n        igVar =\n          \\<lambda>ys y val.\n             if sWlsVal SEM val then val ys y else undefined,\n        igAbs =\n          \\<lambda>xs x X val.\n             if sWlsVal SEM val\n             then sAbs xs\n                   (\\<lambda>sX.\n                       if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                       else sDummy SEM (SOME s. sWls SEM s (X val)))\n             else undefined,\n        igOp =\n          \\<lambda>delta inp binp val.\n             if sWlsVal SEM val\n             then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                   (lift (\\<lambda>A. A val) binp)\n             else undefined,\n        igFresh =\n          \\<lambda>ys y X.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                X val = X val',\n        igFreshAbs =\n          \\<lambda>ys y A.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                A val = A val',\n        igSwap =\n          \\<lambda>zs z1 z2 X val.\n             if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 A val.\n             if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSubst =\n          \\<lambda>ys Y y X val.\n             if sWlsVal SEM val then X (val (y := Y val)_ys) else undefined,\n        igSubstAbs =\n          \\<lambda>ys Y y A val.\n             if sWlsVal SEM val then A (val (y := Y val)_ys)\n             else undefined\\<rparr>\n     ys y =\n    (\\<lambda>val. if sWlsVal SEM val then val ys y else undefined)", "by simp"], ["", "lemma asIMOD_igAbs:\n\"igAbs (asIMOD SEM) xs x X =\n(\\<lambda>val. if sWlsVal SEM val then sAbs xs (\\<lambda>sX. if sWls SEM (asSort xs) sX\n                                                then X (val (x := sX)_xs)\n                                                else sDummy SEM (SOME s. sWls SEM s (X val)))\n                          else undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs (asIMOD SEM) xs x X =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sAbs xs\n              (\\<lambda>sX.\n                  if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                  else sDummy SEM (SOME s. sWls SEM s (X val)))\n        else undefined)", "unfolding asIMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs\n     \\<lparr>igWls =\n               \\<lambda>s X.\n                  \\<forall>val.\n                     (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n                     (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)),\n        igWlsAbs =\n          \\<lambda>(xs, s) A.\n             \\<forall>val.\n                (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n                (sWlsVal SEM val \\<longrightarrow>\n                 sWlsAbs SEM (xs, s) (A val)),\n        igVar =\n          \\<lambda>ys y val.\n             if sWlsVal SEM val then val ys y else undefined,\n        igAbs =\n          \\<lambda>xs x X val.\n             if sWlsVal SEM val\n             then sAbs xs\n                   (\\<lambda>sX.\n                       if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                       else sDummy SEM (SOME s. sWls SEM s (X val)))\n             else undefined,\n        igOp =\n          \\<lambda>delta inp binp val.\n             if sWlsVal SEM val\n             then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                   (lift (\\<lambda>A. A val) binp)\n             else undefined,\n        igFresh =\n          \\<lambda>ys y X.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                X val = X val',\n        igFreshAbs =\n          \\<lambda>ys y A.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                A val = A val',\n        igSwap =\n          \\<lambda>zs z1 z2 X val.\n             if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 A val.\n             if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSubst =\n          \\<lambda>ys Y y X val.\n             if sWlsVal SEM val then X (val (y := Y val)_ys) else undefined,\n        igSubstAbs =\n          \\<lambda>ys Y y A val.\n             if sWlsVal SEM val then A (val (y := Y val)_ys)\n             else undefined\\<rparr>\n     xs x X =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sAbs xs\n              (\\<lambda>sX.\n                  if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                  else sDummy SEM (SOME s. sWls SEM s (X val)))\n        else undefined)", "by simp"], ["", "lemma asIMOD_igAbs2:\nfixes SEM :: \"('index,'bindex,'varSort,'sort,'opSym,'sTerm)semDom\"\nassumes *: \"sWlsDisj SEM\" and **: \"igWls (asIMOD SEM) s X\"\nshows \"igAbs (asIMOD SEM) xs x X =\n(\\<lambda>val. if sWlsVal SEM val then sAbs xs (\\<lambda>sX. if sWls SEM (asSort xs) sX\n                                                then X (val (x := sX)_xs)\n                                                else sDummy SEM s)\n                          else undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs (asIMOD SEM) xs x X =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sAbs xs\n              (\\<lambda>sX.\n                  if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                  else sDummy SEM s)\n        else undefined)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. igAbs (asIMOD SEM) xs x X =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sAbs xs\n              (\\<lambda>sX.\n                  if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                  else sDummy SEM s)\n        else undefined)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. igAbs (asIMOD SEM) xs x X =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sAbs xs\n              (\\<lambda>sX.\n                  if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                  else sDummy SEM s)\n        else undefined)", "fix val :: \"('varSort,'var,'sTerm)val\""], ["proof (state)\ngoal (1 subgoal):\n 1. igAbs (asIMOD SEM) xs x X =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sAbs xs\n              (\\<lambda>sX.\n                  if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                  else sDummy SEM s)\n        else undefined)", "assume val: \"sWlsVal SEM val\""], ["proof (state)\nthis:\n  sWlsVal SEM val\n\ngoal (1 subgoal):\n 1. igAbs (asIMOD SEM) xs x X =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sAbs xs\n              (\\<lambda>sX.\n                  if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                  else sDummy SEM s)\n        else undefined)", "hence Xval: \"sWls SEM s (X val)\""], ["proof (prove)\nusing this:\n  sWlsVal SEM val\n\ngoal (1 subgoal):\n 1. sWls SEM s (X val)", "using **"], ["proof (prove)\nusing this:\n  sWlsVal SEM val\n  igWls (asIMOD SEM) s X\n\ngoal (1 subgoal):\n 1. sWls SEM s (X val)", "unfolding asIMOD_igWls"], ["proof (prove)\nusing this:\n  sWlsVal SEM val\n  \\<forall>val.\n     (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n     (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val))\n\ngoal (1 subgoal):\n 1. sWls SEM s (X val)", "by simp"], ["proof (state)\nthis:\n  sWls SEM s (X val)\n\ngoal (1 subgoal):\n 1. igAbs (asIMOD SEM) xs x X =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sAbs xs\n              (\\<lambda>sX.\n                  if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                  else sDummy SEM s)\n        else undefined)", "hence \"(SOME s. sWls SEM s (X val)) = s\""], ["proof (prove)\nusing this:\n  sWls SEM s (X val)\n\ngoal (1 subgoal):\n 1. (SOME s. sWls SEM s (X val)) = s", "using Xval *"], ["proof (prove)\nusing this:\n  sWls SEM s (X val)\n  sWls SEM s (X val)\n  sWlsDisj SEM\n\ngoal (1 subgoal):\n 1. (SOME s. sWls SEM s (X val)) = s", "unfolding sWlsDisj_def"], ["proof (prove)\nusing this:\n  sWls SEM s (X val)\n  sWls SEM s (X val)\n  \\<forall>s s' sX.\n     sWls SEM s sX \\<and> sWls SEM s' sX \\<longrightarrow> s = s'\n\ngoal (1 subgoal):\n 1. (SOME s. sWls SEM s (X val)) = s", "by auto"], ["proof (state)\nthis:\n  (SOME s. sWls SEM s (X val)) = s\n\ngoal (1 subgoal):\n 1. igAbs (asIMOD SEM) xs x X =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sAbs xs\n              (\\<lambda>sX.\n                  if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                  else sDummy SEM s)\n        else undefined)", "}"], ["proof (state)\nthis:\n  sWlsVal SEM ?val154 \\<Longrightarrow> (SOME s. sWls SEM s (X ?val154)) = s\n\ngoal (1 subgoal):\n 1. igAbs (asIMOD SEM) xs x X =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sAbs xs\n              (\\<lambda>sX.\n                  if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                  else sDummy SEM s)\n        else undefined)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sWlsVal SEM ?val154 \\<Longrightarrow> (SOME s. sWls SEM s (X ?val154)) = s\n\ngoal (1 subgoal):\n 1. igAbs (asIMOD SEM) xs x X =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sAbs xs\n              (\\<lambda>sX.\n                  if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                  else sDummy SEM s)\n        else undefined)", "unfolding asIMOD_igAbs"], ["proof (prove)\nusing this:\n  sWlsVal SEM ?val154 \\<Longrightarrow> (SOME s. sWls SEM s (X ?val154)) = s\n\ngoal (1 subgoal):\n 1. (\\<lambda>val.\n        if sWlsVal SEM val\n        then sAbs xs\n              (\\<lambda>sX.\n                  if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                  else sDummy SEM (SOME s. sWls SEM s (X val)))\n        else undefined) =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sAbs xs\n              (\\<lambda>sX.\n                  if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                  else sDummy SEM s)\n        else undefined)", "by fastforce"], ["proof (state)\nthis:\n  igAbs (asIMOD SEM) xs x X =\n  (\\<lambda>val.\n      if sWlsVal SEM val\n      then sAbs xs\n            (\\<lambda>sX.\n                if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                else sDummy SEM s)\n      else undefined)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma asIMOD_igFresh:\n\"igFresh (asIMOD SEM) ys y X =\n(\\<forall> val val'. sWlsVal SEM val \\<and> sWlsVal SEM val' \\<and> eqBut val val' ys y\n             \\<longrightarrow> X val = X val')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFresh (asIMOD SEM) ys y X =\n    (\\<forall>val val'.\n        sWlsVal SEM val \\<and>\n        sWlsVal SEM val' \\<and> eqBut val val' ys y \\<longrightarrow>\n        X val = X val')", "unfolding asIMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igFresh\n     \\<lparr>igWls =\n               \\<lambda>s X.\n                  \\<forall>val.\n                     (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n                     (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)),\n        igWlsAbs =\n          \\<lambda>(xs, s) A.\n             \\<forall>val.\n                (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n                (sWlsVal SEM val \\<longrightarrow>\n                 sWlsAbs SEM (xs, s) (A val)),\n        igVar =\n          \\<lambda>ys y val.\n             if sWlsVal SEM val then val ys y else undefined,\n        igAbs =\n          \\<lambda>xs x X val.\n             if sWlsVal SEM val\n             then sAbs xs\n                   (\\<lambda>sX.\n                       if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                       else sDummy SEM (SOME s. sWls SEM s (X val)))\n             else undefined,\n        igOp =\n          \\<lambda>delta inp binp val.\n             if sWlsVal SEM val\n             then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                   (lift (\\<lambda>A. A val) binp)\n             else undefined,\n        igFresh =\n          \\<lambda>ys y X.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                X val = X val',\n        igFreshAbs =\n          \\<lambda>ys y A.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                A val = A val',\n        igSwap =\n          \\<lambda>zs z1 z2 X val.\n             if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 A val.\n             if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSubst =\n          \\<lambda>ys Y y X val.\n             if sWlsVal SEM val then X (val (y := Y val)_ys) else undefined,\n        igSubstAbs =\n          \\<lambda>ys Y y A val.\n             if sWlsVal SEM val then A (val (y := Y val)_ys)\n             else undefined\\<rparr>\n     ys y X =\n    (\\<forall>val val'.\n        sWlsVal SEM val \\<and>\n        sWlsVal SEM val' \\<and> eqBut val val' ys y \\<longrightarrow>\n        X val = X val')", "by simp"], ["", "lemma asIMOD_igFreshAbs:\n\"igFreshAbs (asIMOD SEM) ys y A =\n(\\<forall> val val'. sWlsVal SEM val \\<and> sWlsVal SEM val' \\<and> eqBut val val' ys y\n             \\<longrightarrow> A val = A val')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshAbs (asIMOD SEM) ys y A =\n    (\\<forall>val val'.\n        sWlsVal SEM val \\<and>\n        sWlsVal SEM val' \\<and> eqBut val val' ys y \\<longrightarrow>\n        A val = A val')", "unfolding asIMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshAbs\n     \\<lparr>igWls =\n               \\<lambda>s X.\n                  \\<forall>val.\n                     (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n                     (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)),\n        igWlsAbs =\n          \\<lambda>(xs, s) A.\n             \\<forall>val.\n                (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n                (sWlsVal SEM val \\<longrightarrow>\n                 sWlsAbs SEM (xs, s) (A val)),\n        igVar =\n          \\<lambda>ys y val.\n             if sWlsVal SEM val then val ys y else undefined,\n        igAbs =\n          \\<lambda>xs x X val.\n             if sWlsVal SEM val\n             then sAbs xs\n                   (\\<lambda>sX.\n                       if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                       else sDummy SEM (SOME s. sWls SEM s (X val)))\n             else undefined,\n        igOp =\n          \\<lambda>delta inp binp val.\n             if sWlsVal SEM val\n             then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                   (lift (\\<lambda>A. A val) binp)\n             else undefined,\n        igFresh =\n          \\<lambda>ys y X.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                X val = X val',\n        igFreshAbs =\n          \\<lambda>ys y A.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                A val = A val',\n        igSwap =\n          \\<lambda>zs z1 z2 X val.\n             if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 A val.\n             if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSubst =\n          \\<lambda>ys Y y X val.\n             if sWlsVal SEM val then X (val (y := Y val)_ys) else undefined,\n        igSubstAbs =\n          \\<lambda>ys Y y A val.\n             if sWlsVal SEM val then A (val (y := Y val)_ys)\n             else undefined\\<rparr>\n     ys y A =\n    (\\<forall>val val'.\n        sWlsVal SEM val \\<and>\n        sWlsVal SEM val' \\<and> eqBut val val' ys y \\<longrightarrow>\n        A val = A val')", "by simp"], ["", "lemma asIMOD_igSwap:\n\"igSwap (asIMOD SEM) zs z1 z2 X =\n(\\<lambda>val. if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs) else undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwap (asIMOD SEM) zs z1 z2 X =\n    (\\<lambda>val.\n        if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs) else undefined)", "unfolding asIMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwap\n     \\<lparr>igWls =\n               \\<lambda>s X.\n                  \\<forall>val.\n                     (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n                     (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)),\n        igWlsAbs =\n          \\<lambda>(xs, s) A.\n             \\<forall>val.\n                (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n                (sWlsVal SEM val \\<longrightarrow>\n                 sWlsAbs SEM (xs, s) (A val)),\n        igVar =\n          \\<lambda>ys y val.\n             if sWlsVal SEM val then val ys y else undefined,\n        igAbs =\n          \\<lambda>xs x X val.\n             if sWlsVal SEM val\n             then sAbs xs\n                   (\\<lambda>sX.\n                       if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                       else sDummy SEM (SOME s. sWls SEM s (X val)))\n             else undefined,\n        igOp =\n          \\<lambda>delta inp binp val.\n             if sWlsVal SEM val\n             then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                   (lift (\\<lambda>A. A val) binp)\n             else undefined,\n        igFresh =\n          \\<lambda>ys y X.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                X val = X val',\n        igFreshAbs =\n          \\<lambda>ys y A.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                A val = A val',\n        igSwap =\n          \\<lambda>zs z1 z2 X val.\n             if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 A val.\n             if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSubst =\n          \\<lambda>ys Y y X val.\n             if sWlsVal SEM val then X (val (y := Y val)_ys) else undefined,\n        igSubstAbs =\n          \\<lambda>ys Y y A val.\n             if sWlsVal SEM val then A (val (y := Y val)_ys)\n             else undefined\\<rparr>\n     zs z1 z2 X =\n    (\\<lambda>val.\n        if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs) else undefined)", "by simp"], ["", "lemma asIMOD_igSwapAbs:\n\"igSwapAbs (asIMOD SEM) zs z1 z2 A =\n(\\<lambda>val. if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs) else undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapAbs (asIMOD SEM) zs z1 z2 A =\n    (\\<lambda>val.\n        if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs) else undefined)", "unfolding asIMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapAbs\n     \\<lparr>igWls =\n               \\<lambda>s X.\n                  \\<forall>val.\n                     (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n                     (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)),\n        igWlsAbs =\n          \\<lambda>(xs, s) A.\n             \\<forall>val.\n                (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n                (sWlsVal SEM val \\<longrightarrow>\n                 sWlsAbs SEM (xs, s) (A val)),\n        igVar =\n          \\<lambda>ys y val.\n             if sWlsVal SEM val then val ys y else undefined,\n        igAbs =\n          \\<lambda>xs x X val.\n             if sWlsVal SEM val\n             then sAbs xs\n                   (\\<lambda>sX.\n                       if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                       else sDummy SEM (SOME s. sWls SEM s (X val)))\n             else undefined,\n        igOp =\n          \\<lambda>delta inp binp val.\n             if sWlsVal SEM val\n             then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                   (lift (\\<lambda>A. A val) binp)\n             else undefined,\n        igFresh =\n          \\<lambda>ys y X.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                X val = X val',\n        igFreshAbs =\n          \\<lambda>ys y A.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                A val = A val',\n        igSwap =\n          \\<lambda>zs z1 z2 X val.\n             if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 A val.\n             if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSubst =\n          \\<lambda>ys Y y X val.\n             if sWlsVal SEM val then X (val (y := Y val)_ys) else undefined,\n        igSubstAbs =\n          \\<lambda>ys Y y A val.\n             if sWlsVal SEM val then A (val (y := Y val)_ys)\n             else undefined\\<rparr>\n     zs z1 z2 A =\n    (\\<lambda>val.\n        if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs) else undefined)", "by simp"], ["", "lemma asIMOD_igSubst:\n\"igSubst (asIMOD SEM) ys Y y X =\n(\\<lambda>val. if sWlsVal SEM val then X (val (y := Y val)_ys) else undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubst (asIMOD SEM) ys Y y X =\n    (\\<lambda>val.\n        if sWlsVal SEM val then X (val (y := Y val)_ys) else undefined)", "unfolding asIMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubst\n     \\<lparr>igWls =\n               \\<lambda>s X.\n                  \\<forall>val.\n                     (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n                     (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)),\n        igWlsAbs =\n          \\<lambda>(xs, s) A.\n             \\<forall>val.\n                (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n                (sWlsVal SEM val \\<longrightarrow>\n                 sWlsAbs SEM (xs, s) (A val)),\n        igVar =\n          \\<lambda>ys y val.\n             if sWlsVal SEM val then val ys y else undefined,\n        igAbs =\n          \\<lambda>xs x X val.\n             if sWlsVal SEM val\n             then sAbs xs\n                   (\\<lambda>sX.\n                       if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                       else sDummy SEM (SOME s. sWls SEM s (X val)))\n             else undefined,\n        igOp =\n          \\<lambda>delta inp binp val.\n             if sWlsVal SEM val\n             then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                   (lift (\\<lambda>A. A val) binp)\n             else undefined,\n        igFresh =\n          \\<lambda>ys y X.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                X val = X val',\n        igFreshAbs =\n          \\<lambda>ys y A.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                A val = A val',\n        igSwap =\n          \\<lambda>zs z1 z2 X val.\n             if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 A val.\n             if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSubst =\n          \\<lambda>ys Y y X val.\n             if sWlsVal SEM val then X (val (y := Y val)_ys) else undefined,\n        igSubstAbs =\n          \\<lambda>ys Y y A val.\n             if sWlsVal SEM val then A (val (y := Y val)_ys)\n             else undefined\\<rparr>\n     ys Y y X =\n    (\\<lambda>val.\n        if sWlsVal SEM val then X (val (y := Y val)_ys) else undefined)", "by simp"], ["", "lemma asIMOD_igSubstAbs:\n\"igSubstAbs (asIMOD SEM) ys Y y A =\n(\\<lambda>val. if sWlsVal SEM val then A (val (y := Y val)_ys) else undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAbs (asIMOD SEM) ys Y y A =\n    (\\<lambda>val.\n        if sWlsVal SEM val then A (val (y := Y val)_ys) else undefined)", "unfolding asIMOD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAbs\n     \\<lparr>igWls =\n               \\<lambda>s X.\n                  \\<forall>val.\n                     (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n                     (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)),\n        igWlsAbs =\n          \\<lambda>(xs, s) A.\n             \\<forall>val.\n                (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n                (sWlsVal SEM val \\<longrightarrow>\n                 sWlsAbs SEM (xs, s) (A val)),\n        igVar =\n          \\<lambda>ys y val.\n             if sWlsVal SEM val then val ys y else undefined,\n        igAbs =\n          \\<lambda>xs x X val.\n             if sWlsVal SEM val\n             then sAbs xs\n                   (\\<lambda>sX.\n                       if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                       else sDummy SEM (SOME s. sWls SEM s (X val)))\n             else undefined,\n        igOp =\n          \\<lambda>delta inp binp val.\n             if sWlsVal SEM val\n             then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                   (lift (\\<lambda>A. A val) binp)\n             else undefined,\n        igFresh =\n          \\<lambda>ys y X.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                X val = X val',\n        igFreshAbs =\n          \\<lambda>ys y A.\n             \\<forall>val val'.\n                sWlsVal SEM val \\<and>\n                sWlsVal SEM val' \\<and>\n                eqBut val val' ys y \\<longrightarrow>\n                A val = A val',\n        igSwap =\n          \\<lambda>zs z1 z2 X val.\n             if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSwapAbs =\n          \\<lambda>zs z1 z2 A val.\n             if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs)\n             else undefined,\n        igSubst =\n          \\<lambda>ys Y y X val.\n             if sWlsVal SEM val then X (val (y := Y val)_ys) else undefined,\n        igSubstAbs =\n          \\<lambda>ys Y y A val.\n             if sWlsVal SEM val then A (val (y := Y val)_ys)\n             else undefined\\<rparr>\n     ys Y y A =\n    (\\<lambda>val.\n        if sWlsVal SEM val then A (val (y := Y val)_ys) else undefined)", "by simp"], ["", "lemma asIMOD_igWlsInp: \nassumes \"sWlsNE SEM\"\nshows\n\"igWlsInp (asIMOD SEM) delta inp \\<longleftrightarrow> \n ((\\<forall> val. liftAll (\\<lambda>X. sWlsVal SEM val \\<or> X val = undefined) inp) \\<and>\n  (\\<forall> val. sWlsVal SEM val \\<longrightarrow> sWlsInp SEM delta (lift (\\<lambda>X. X val) inp)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsInp (asIMOD SEM) delta inp =\n    ((\\<forall>val.\n         liftAll (\\<lambda>X. sWlsVal SEM val \\<or> X val = undefined)\n          inp) \\<and>\n     (\\<forall>val.\n         sWlsVal SEM val \\<longrightarrow>\n         sWlsInp SEM delta (lift (\\<lambda>X. X val) inp)))", "using assms"], ["proof (prove)\nusing this:\n  sWlsNE SEM\n\ngoal (1 subgoal):\n 1. igWlsInp (asIMOD SEM) delta inp =\n    ((\\<forall>val.\n         liftAll (\\<lambda>X. sWlsVal SEM val \\<or> X val = undefined)\n          inp) \\<and>\n     (\\<forall>val.\n         sWlsVal SEM val \\<longrightarrow>\n         sWlsInp SEM delta (lift (\\<lambda>X. X val) inp)))", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>val.\n       \\<lbrakk>sWlsNE SEM; igWlsInp (asIMOD SEM) delta inp\\<rbrakk>\n       \\<Longrightarrow> liftAll\n                          (\\<lambda>X.\n                              sWlsVal SEM val \\<or> X val = undefined)\n                          inp\n 2. \\<And>val.\n       \\<lbrakk>sWlsNE SEM; igWlsInp (asIMOD SEM) delta inp;\n        sWlsVal SEM val\\<rbrakk>\n       \\<Longrightarrow> sWlsInp SEM delta (lift (\\<lambda>X. X val) inp)\n 3. \\<lbrakk>sWlsNE SEM;\n     \\<forall>val.\n        liftAll (\\<lambda>X. sWlsVal SEM val \\<or> X val = undefined) inp;\n     \\<forall>val.\n        sWlsVal SEM val \\<longrightarrow>\n        sWlsInp SEM delta (lift (\\<lambda>X. X val) inp)\\<rbrakk>\n    \\<Longrightarrow> igWlsInp (asIMOD SEM) delta inp", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsNE SEM; igWlsInp (asIMOD SEM) delta inp\\<rbrakk>\n    \\<Longrightarrow> liftAll\n                       (\\<lambda>X.\n                           sWlsVal SEM val_ \\<or> X val_ = undefined)\n                       inp", "by (simp add: asIMOD_igWls liftAll_def liftAll2_def igWlsInp_def \n  sameDom_def split: option.splits) (metis option.distinct(1) option.exhaust)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>val.\n       \\<lbrakk>sWlsNE SEM; igWlsInp (asIMOD SEM) delta inp;\n        sWlsVal SEM val\\<rbrakk>\n       \\<Longrightarrow> sWlsInp SEM delta (lift (\\<lambda>X. X val) inp)\n 2. \\<lbrakk>sWlsNE SEM;\n     \\<forall>val.\n        liftAll (\\<lambda>X. sWlsVal SEM val \\<or> X val = undefined) inp;\n     \\<forall>val.\n        sWlsVal SEM val \\<longrightarrow>\n        sWlsInp SEM delta (lift (\\<lambda>X. X val) inp)\\<rbrakk>\n    \\<Longrightarrow> igWlsInp (asIMOD SEM) delta inp", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsNE SEM; igWlsInp (asIMOD SEM) delta inp;\n     sWlsVal SEM val_\\<rbrakk>\n    \\<Longrightarrow> sWlsInp SEM delta (lift (\\<lambda>X. X val_) inp)", "by (simp add: igWlsInp_def asIMOD_igWls liftAll_def liftAll2_def \n  lift_def sWlsInp_def sameDom_def split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsNE SEM;\n     \\<forall>val.\n        liftAll (\\<lambda>X. sWlsVal SEM val \\<or> X val = undefined) inp;\n     \\<forall>val.\n        sWlsVal SEM val \\<longrightarrow>\n        sWlsInp SEM delta (lift (\\<lambda>X. X val) inp)\\<rbrakk>\n    \\<Longrightarrow> igWlsInp (asIMOD SEM) delta inp", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsNE SEM;\n     \\<forall>val.\n        liftAll (\\<lambda>X. sWlsVal SEM val \\<or> X val = undefined) inp;\n     \\<forall>val.\n        sWlsVal SEM val \\<longrightarrow>\n        sWlsInp SEM delta (lift (\\<lambda>X. X val) inp)\\<rbrakk>\n    \\<Longrightarrow> igWlsInp (asIMOD SEM) delta inp", "by (simp add:igWlsInp_def asIMOD_igWls liftAll_def liftAll2_def \n  lift_def sWlsInp_def sameDom_def split: option.splits) \n  (metis (no_types) option.distinct(1) sWlsNE_imp_sWlsValNE sWlsValNE_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma asIMOD_igSwapInp:\n\"sWlsVal SEM val \\<Longrightarrow> \n lift (\\<lambda>X. X val) (igSwapInp (asIMOD SEM) zs z1 z2 inp) =\n lift (\\<lambda>X. X (swapVal zs z1 z2 val)) inp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    lift (\\<lambda>X. X val) (igSwapInp (asIMOD SEM) zs z1 z2 inp) =\n    lift (\\<lambda>X. X (val ^[z1 \\<and> z2]_zs)) inp", "by (auto simp: igSwapInp_def asIMOD_igSwap lift_def split: option.splits)"], ["", "lemma asIMOD_igSubstInp:\n\"sWlsVal SEM val \\<Longrightarrow> \n lift (\\<lambda>X. X val) (igSubstInp (asIMOD SEM) ys Y y inp) =\n lift (\\<lambda>X. X (val (y := Y val)_ys)) inp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    lift (\\<lambda>X. X val) (igSubstInp (asIMOD SEM) ys Y y inp) =\n    lift (\\<lambda>X. X (val (y := Y val)_ys)) inp", "by (auto simp: igSubstInp_def asIMOD_igSubst lift_def split: option.splits)"], ["", "lemma asIMOD_igWlsBinp: \nassumes \"sWlsNE SEM\"\nshows\n\"igWlsBinp (asIMOD SEM) delta binp =\n ((\\<forall> val. liftAll (\\<lambda>X. sWlsVal SEM val \\<or> X val = undefined) binp) \\<and>\n  (\\<forall> val. sWlsVal SEM val \\<longrightarrow> sWlsBinp SEM delta (lift (\\<lambda>X. X val) binp)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igWlsBinp (asIMOD SEM) delta binp =\n    ((\\<forall>val.\n         liftAll (\\<lambda>X. sWlsVal SEM val \\<or> X val = undefined)\n          binp) \\<and>\n     (\\<forall>val.\n         sWlsVal SEM val \\<longrightarrow>\n         sWlsBinp SEM delta (lift (\\<lambda>X. X val) binp)))", "using assms"], ["proof (prove)\nusing this:\n  sWlsNE SEM\n\ngoal (1 subgoal):\n 1. igWlsBinp (asIMOD SEM) delta binp =\n    ((\\<forall>val.\n         liftAll (\\<lambda>X. sWlsVal SEM val \\<or> X val = undefined)\n          binp) \\<and>\n     (\\<forall>val.\n         sWlsVal SEM val \\<longrightarrow>\n         sWlsBinp SEM delta (lift (\\<lambda>X. X val) binp)))", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>val.\n       \\<lbrakk>sWlsNE SEM; igWlsBinp (asIMOD SEM) delta binp\\<rbrakk>\n       \\<Longrightarrow> liftAll\n                          (\\<lambda>X.\n                              sWlsVal SEM val \\<or> X val = undefined)\n                          binp\n 2. \\<And>val.\n       \\<lbrakk>sWlsNE SEM; igWlsBinp (asIMOD SEM) delta binp;\n        sWlsVal SEM val\\<rbrakk>\n       \\<Longrightarrow> sWlsBinp SEM delta (lift (\\<lambda>X. X val) binp)\n 3. \\<lbrakk>sWlsNE SEM;\n     \\<forall>val.\n        liftAll (\\<lambda>X. sWlsVal SEM val \\<or> X val = undefined) binp;\n     \\<forall>val.\n        sWlsVal SEM val \\<longrightarrow>\n        sWlsBinp SEM delta (lift (\\<lambda>X. X val) binp)\\<rbrakk>\n    \\<Longrightarrow> igWlsBinp (asIMOD SEM) delta binp", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsNE SEM; igWlsBinp (asIMOD SEM) delta binp\\<rbrakk>\n    \\<Longrightarrow> liftAll\n                       (\\<lambda>X.\n                           sWlsVal SEM val_ \\<or> X val_ = undefined)\n                       binp", "by (simp add: asIMOD_igWlsAbs liftAll_def liftAll2_def igWlsBinp_def \n  sameDom_def split: option.splits)\n (metis option.distinct(1) option.exhaust surj_pair)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>val.\n       \\<lbrakk>sWlsNE SEM; igWlsBinp (asIMOD SEM) delta binp;\n        sWlsVal SEM val\\<rbrakk>\n       \\<Longrightarrow> sWlsBinp SEM delta (lift (\\<lambda>X. X val) binp)\n 2. \\<lbrakk>sWlsNE SEM;\n     \\<forall>val.\n        liftAll (\\<lambda>X. sWlsVal SEM val \\<or> X val = undefined) binp;\n     \\<forall>val.\n        sWlsVal SEM val \\<longrightarrow>\n        sWlsBinp SEM delta (lift (\\<lambda>X. X val) binp)\\<rbrakk>\n    \\<Longrightarrow> igWlsBinp (asIMOD SEM) delta binp", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsNE SEM; igWlsBinp (asIMOD SEM) delta binp;\n     sWlsVal SEM val_\\<rbrakk>\n    \\<Longrightarrow> sWlsBinp SEM delta (lift (\\<lambda>X. X val_) binp)", "by (simp add: igWlsBinp_def asIMOD_igWlsAbs liftAll_def liftAll2_def \n  lift_def sWlsBinp_def sameDom_def split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsNE SEM;\n     \\<forall>val.\n        liftAll (\\<lambda>X. sWlsVal SEM val \\<or> X val = undefined) binp;\n     \\<forall>val.\n        sWlsVal SEM val \\<longrightarrow>\n        sWlsBinp SEM delta (lift (\\<lambda>X. X val) binp)\\<rbrakk>\n    \\<Longrightarrow> igWlsBinp (asIMOD SEM) delta binp", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsNE SEM;\n     \\<forall>val.\n        liftAll (\\<lambda>X. sWlsVal SEM val \\<or> X val = undefined) binp;\n     \\<forall>val.\n        sWlsVal SEM val \\<longrightarrow>\n        sWlsBinp SEM delta (lift (\\<lambda>X. X val) binp)\\<rbrakk>\n    \\<Longrightarrow> igWlsBinp (asIMOD SEM) delta binp", "by (simp add:igWlsBinp_def asIMOD_igWlsAbs liftAll_def liftAll2_def \n  lift_def sWlsBinp_def sameDom_def split: option.splits) \n  (metis (no_types) old.prod.exhaust option.distinct(1) option.exhaust \n   sWlsNE_imp_sWlsValNE sWlsValNE_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma asIMOD_igSwapBinp:\n\"sWlsVal SEM val \\<Longrightarrow> \n lift (\\<lambda>A. A val) (igSwapBinp (asIMOD SEM) zs z1 z2 binp) =\n lift (\\<lambda>A. A (swapVal zs z1 z2 val)) binp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    lift (\\<lambda>A. A val) (igSwapBinp (asIMOD SEM) zs z1 z2 binp) =\n    lift (\\<lambda>A. A (val ^[z1 \\<and> z2]_zs)) binp", "by (auto simp: igSwapBinp_def asIMOD_igSwapAbs lift_def split: option.splits)"], ["", "lemma asIMOD_igSubstBinp:\n\"sWlsVal SEM val \\<Longrightarrow> \n lift (\\<lambda>A. A val) (igSubstBinp (asIMOD SEM) ys Y y binp) =\n lift (\\<lambda>A. A (val (y := Y val)_ys)) binp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    lift (\\<lambda>A. A val) (igSubstBinp (asIMOD SEM) ys Y y binp) =\n    lift (\\<lambda>A. A (val (y := Y val)_ys)) binp", "by (auto simp: igSubstBinp_def asIMOD_igSubstAbs lift_def split: option.splits)"], ["", "subsubsection \\<open>The associated model is well-structured\\<close>"], ["", "text\\<open>That is to say: it is a fresh-swap-subst\nand fresh-subst-swap model (hence of course also a fresh-swap and fresh-subst) model.\\<close>"], ["", "text\\<open>Domain disjointness:\\<close>"], ["", "lemma asIMOD_igWlsDisj:\n\"sWlsNE SEM \\<Longrightarrow> sWlsDisj SEM \\<Longrightarrow> igWlsDisj (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsNE SEM; sWlsDisj SEM\\<rbrakk>\n    \\<Longrightarrow> igWlsDisj (asIMOD SEM)", "using sWlsNE_imp_sWlsValNE"], ["proof (prove)\nusing this:\n  sWlsNE ?SEM \\<Longrightarrow> sWlsValNE ?SEM ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsNE SEM; sWlsDisj SEM\\<rbrakk>\n    \\<Longrightarrow> igWlsDisj (asIMOD SEM)", "by (fastforce simp: igWlsDisj_def asIMOD_igWls sWlsValNE_def sWlsDisj_def)"], ["", "lemma asIMOD_igWlsAbsDisj:\n\"sWlsNE SEM \\<Longrightarrow> sWlsDisj SEM \\<Longrightarrow> igWlsAbsDisj (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsNE SEM; sWlsDisj SEM\\<rbrakk>\n    \\<Longrightarrow> igWlsAbsDisj (asIMOD SEM)", "using sWlsNE_imp_sWlsValNE sWlsDisj_imp_sWlsAbsDisj"], ["proof (prove)\nusing this:\n  sWlsNE ?SEM \\<Longrightarrow> sWlsValNE ?SEM ?x\n  \\<lbrakk>sWlsDisj ?SEM; sWlsNE ?SEM\\<rbrakk>\n  \\<Longrightarrow> sWlsAbsDisj ?SEM\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsNE SEM; sWlsDisj SEM\\<rbrakk>\n    \\<Longrightarrow> igWlsAbsDisj (asIMOD SEM)", "by (fastforce simp: igWlsAbsDisj_def asIMOD_igWlsAbs sWlsAbsDisj_def sWlsValNE_def)"], ["", "lemma asIMOD_igWlsAllDisj: \n\"sWlsNE SEM \\<Longrightarrow> sWlsDisj SEM \\<Longrightarrow> igWlsAllDisj (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsNE SEM; sWlsDisj SEM\\<rbrakk>\n    \\<Longrightarrow> igWlsAllDisj (asIMOD SEM)", "unfolding igWlsAllDisj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsNE SEM; sWlsDisj SEM\\<rbrakk>\n    \\<Longrightarrow> igWlsDisj (asIMOD SEM) \\<and>\n                      igWlsAbsDisj (asIMOD SEM)", "using asIMOD_igWlsDisj asIMOD_igWlsAbsDisj"], ["proof (prove)\nusing this:\n  \\<lbrakk>sWlsNE ?SEM; sWlsDisj ?SEM\\<rbrakk>\n  \\<Longrightarrow> igWlsDisj (asIMOD ?SEM)\n  \\<lbrakk>sWlsNE ?SEM; sWlsDisj ?SEM\\<rbrakk>\n  \\<Longrightarrow> igWlsAbsDisj (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsNE SEM; sWlsDisj SEM\\<rbrakk>\n    \\<Longrightarrow> igWlsDisj (asIMOD SEM) \\<and>\n                      igWlsAbsDisj (asIMOD SEM)", "by auto"], ["", "text \\<open>Only ``bound arit\" abstraction domains are inhabited:\\<close>"], ["", "lemma asIMOD_igWlsAbsIsInBar:\n\"sWlsNE SEM \\<Longrightarrow> igWlsAbsIsInBar (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsNE SEM \\<Longrightarrow> igWlsAbsIsInBar (asIMOD SEM)", "using sWlsNE_imp_sWlsValNE"], ["proof (prove)\nusing this:\n  sWlsNE ?SEM \\<Longrightarrow> sWlsValNE ?SEM ?x\n\ngoal (1 subgoal):\n 1. sWlsNE SEM \\<Longrightarrow> igWlsAbsIsInBar (asIMOD SEM)", "by (auto simp: sWlsValNE_def igWlsAbsIsInBar_def asIMOD_igWlsAbs \n         split: option.splits elim: sWlsAbs.elims(2))"], ["", "text\\<open>Domain preservation by the operators\\<close>"], ["", "text\\<open>The constructs preserve the domains:\\<close>"], ["", "lemma asIMOD_igVarIPresIGWls: \"igVarIPresIGWls (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igVarIPresIGWls (asIMOD SEM)", "unfolding igVarIPresIGWls_def asIMOD_igWls asIMOD_igVar sWlsVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs x val.\n       ((\\<forall>ys y. sWls SEM (asSort ys) (val ys y)) \\<or>\n        (if \\<forall>ys y. sWls SEM (asSort ys) (val ys y) then val xs x\n         else undefined) =\n        undefined) \\<and>\n       ((\\<forall>ys y. sWls SEM (asSort ys) (val ys y)) \\<longrightarrow>\n        sWls SEM (asSort xs)\n         (if \\<forall>ys y. sWls SEM (asSort ys) (val ys y) then val xs x\n          else undefined))", "by simp"], ["", "lemma asIMOD_igAbsIPresIGWls:\n\"sWlsDisj SEM \\<Longrightarrow> igAbsIPresIGWls (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsDisj SEM \\<Longrightarrow> igAbsIPresIGWls (asIMOD SEM)", "unfolding igAbsIPresIGWls_def asIMOD_igWlsAbs"], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsDisj SEM \\<Longrightarrow>\n    \\<forall>xs s x X.\n       isInBar (xs, s) \\<and> igWls (asIMOD SEM) s X \\<longrightarrow>\n       (\\<forall>val.\n           (sWlsVal SEM val \\<or>\n            igAbs (asIMOD SEM) xs x X val = undefined) \\<and>\n           (sWlsVal SEM val \\<longrightarrow>\n            sWlsAbs SEM (xs, s) (igAbs (asIMOD SEM) xs x X val)))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs s x X val.\n       \\<lbrakk>sWlsDisj SEM; isInBar (xs, s);\n        igWls (asIMOD SEM) s X\\<rbrakk>\n       \\<Longrightarrow> (sWlsVal SEM val \\<or>\n                          igAbs (asIMOD SEM) xs x X val = undefined) \\<and>\n                         (sWlsVal SEM val \\<longrightarrow>\n                          sWlsAbs SEM (xs, s)\n                           (igAbs (asIMOD SEM) xs x X val))", "subgoal for _ _ _ _ val"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsDisj SEM; isInBar (xs_, s_);\n     igWls (asIMOD SEM) s_ X_\\<rbrakk>\n    \\<Longrightarrow> (sWlsVal SEM val \\<or>\n                       igAbs (asIMOD SEM) xs_ x_ X_ val = undefined) \\<and>\n                      (sWlsVal SEM val \\<longrightarrow>\n                       sWlsAbs SEM (xs_, s_)\n                        (igAbs (asIMOD SEM) xs_ x_ X_ val))", "unfolding asIMOD_igAbs2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sWlsDisj SEM; isInBar (xs_, s_);\n     igWls (asIMOD SEM) s_ X_\\<rbrakk>\n    \\<Longrightarrow> (sWlsVal SEM val \\<or>\n                       (if sWlsVal SEM val\n                        then sAbs xs_\n                              (\\<lambda>sX.\n                                  if sWls SEM (asSort xs_) sX\n                                  then X_ (val (x_ := sX)_xs_)\n                                  else sDummy SEM s_)\n                        else undefined) =\n                       undefined) \\<and>\n                      (sWlsVal SEM val \\<longrightarrow>\n                       sWlsAbs SEM (xs_, s_)\n                        (if sWlsVal SEM val\n                         then sAbs xs_\n                               (\\<lambda>sX.\n                                   if sWls SEM (asSort xs_) sX\n                                   then X_ (val (x_ := sX)_xs_)\n                                   else sDummy SEM s_)\n                         else undefined))", "by (cases \"sWlsVal SEM val\") (auto simp: asIMOD_igWls)"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma asIMOD_igOpIPresIGWls: \n\"sOpPrSWls SEM \\<Longrightarrow> sWlsNE SEM \\<Longrightarrow> igOpIPresIGWls (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sOpPrSWls SEM; sWlsNE SEM\\<rbrakk>\n    \\<Longrightarrow> igOpIPresIGWls (asIMOD SEM)", "using asIMOD_igWlsInp asIMOD_igWlsBinp"], ["proof (prove)\nusing this:\n  sWlsNE ?SEM \\<Longrightarrow>\n  igWlsInp (asIMOD ?SEM) ?delta ?inp =\n  ((\\<forall>val.\n       liftAll (\\<lambda>X. sWlsVal ?SEM val \\<or> X val = undefined)\n        ?inp) \\<and>\n   (\\<forall>val.\n       sWlsVal ?SEM val \\<longrightarrow>\n       sWlsInp ?SEM ?delta (lift (\\<lambda>X. X val) ?inp)))\n  sWlsNE ?SEM \\<Longrightarrow>\n  igWlsBinp (asIMOD ?SEM) ?delta ?binp =\n  ((\\<forall>val.\n       liftAll (\\<lambda>X. sWlsVal ?SEM val \\<or> X val = undefined)\n        ?binp) \\<and>\n   (\\<forall>val.\n       sWlsVal ?SEM val \\<longrightarrow>\n       sWlsBinp ?SEM ?delta (lift (\\<lambda>X. X val) ?binp)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sOpPrSWls SEM; sWlsNE SEM\\<rbrakk>\n    \\<Longrightarrow> igOpIPresIGWls (asIMOD SEM)", "by (fastforce simp: igOpIPresIGWls_def asIMOD_igWls asIMOD_igOp sOpPrSWls_def)"], ["", "lemma asIMOD_igConsIPresIGWls: \n\"wlsSEM SEM \\<Longrightarrow> igConsIPresIGWls (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow> igConsIPresIGWls (asIMOD SEM)", "unfolding igConsIPresIGWls_def wlsSEM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsNE SEM \\<and> sWlsDisj SEM \\<and> sOpPrSWls SEM \\<Longrightarrow>\n    igVarIPresIGWls (asIMOD SEM) \\<and>\n    igAbsIPresIGWls (asIMOD SEM) \\<and> igOpIPresIGWls (asIMOD SEM)", "using asIMOD_igVarIPresIGWls asIMOD_igAbsIPresIGWls asIMOD_igOpIPresIGWls"], ["proof (prove)\nusing this:\n  igVarIPresIGWls (asIMOD ?SEM)\n  sWlsDisj ?SEM \\<Longrightarrow> igAbsIPresIGWls (asIMOD ?SEM)\n  \\<lbrakk>sOpPrSWls ?SEM; sWlsNE ?SEM\\<rbrakk>\n  \\<Longrightarrow> igOpIPresIGWls (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. sWlsNE SEM \\<and> sWlsDisj SEM \\<and> sOpPrSWls SEM \\<Longrightarrow>\n    igVarIPresIGWls (asIMOD SEM) \\<and>\n    igAbsIPresIGWls (asIMOD SEM) \\<and> igOpIPresIGWls (asIMOD SEM)", "by auto"], ["", "text\\<open>Swap preserves the domains:\\<close>"], ["", "lemma asIMOD_igSwapIPresIGWls: \"igSwapIPresIGWls (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIPresIGWls (asIMOD SEM)", "unfolding igSwapIPresIGWls_def asIMOD_igSwap asIMOD_igWls"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 s X.\n       (\\<forall>val.\n           (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n           (sWlsVal SEM val \\<longrightarrow>\n            sWls SEM s (X val))) \\<longrightarrow>\n       (\\<forall>val.\n           (sWlsVal SEM val \\<or>\n            (if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs)\n             else undefined) =\n            undefined) \\<and>\n           (sWlsVal SEM val \\<longrightarrow>\n            sWls SEM s\n             (if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs)\n              else undefined)))", "by auto"], ["", "lemma asIMOD_igSwapAbsIPresIGWlsAbs: \"igSwapAbsIPresIGWlsAbs (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapAbsIPresIGWlsAbs (asIMOD SEM)", "unfolding igSwapAbsIPresIGWlsAbs_def asIMOD_igSwapAbs asIMOD_igWlsAbs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 us s A.\n       isInBar (us, s) \\<and>\n       (\\<forall>val.\n           (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n           (sWlsVal SEM val \\<longrightarrow>\n            sWlsAbs SEM (us, s) (A val))) \\<longrightarrow>\n       (\\<forall>val.\n           (sWlsVal SEM val \\<or>\n            (if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs)\n             else undefined) =\n            undefined) \\<and>\n           (sWlsVal SEM val \\<longrightarrow>\n            sWlsAbs SEM (us, s)\n             (if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs)\n              else undefined)))", "by auto"], ["", "lemma asIMOD_igSwapAllIPresIGWlsAll: \"igSwapAllIPresIGWlsAll (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapAllIPresIGWlsAll (asIMOD SEM)", "unfolding igSwapAllIPresIGWlsAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIPresIGWls (asIMOD SEM) \\<and> igSwapAbsIPresIGWlsAbs (asIMOD SEM)", "using asIMOD_igSwapIPresIGWls asIMOD_igSwapAbsIPresIGWlsAbs"], ["proof (prove)\nusing this:\n  igSwapIPresIGWls (asIMOD ?SEM)\n  igSwapAbsIPresIGWlsAbs (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. igSwapIPresIGWls (asIMOD SEM) \\<and> igSwapAbsIPresIGWlsAbs (asIMOD SEM)", "by auto"], ["", "text \\<open>Subst preserves the domains:\\<close>"], ["", "lemma asIMOD_igSubstIPresIGWls: \"igSubstIPresIGWls (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIPresIGWls (asIMOD SEM)", "unfolding igSubstIPresIGWls_def asIMOD_igSubst asIMOD_igWls"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys Y y s X.\n       (\\<forall>val.\n           (sWlsVal SEM val \\<or> Y val = undefined) \\<and>\n           (sWlsVal SEM val \\<longrightarrow>\n            sWls SEM (asSort ys) (Y val))) \\<and>\n       (\\<forall>val.\n           (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n           (sWlsVal SEM val \\<longrightarrow>\n            sWls SEM s (X val))) \\<longrightarrow>\n       (\\<forall>val.\n           (sWlsVal SEM val \\<or>\n            (if sWlsVal SEM val then X (val (y := Y val)_ys)\n             else undefined) =\n            undefined) \\<and>\n           (sWlsVal SEM val \\<longrightarrow>\n            sWls SEM s\n             (if sWlsVal SEM val then X (val (y := Y val)_ys)\n              else undefined)))", "by simp"], ["", "lemma asIMOD_igSubstAbsIPresIGWlsAbs: \"igSubstAbsIPresIGWlsAbs (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAbsIPresIGWlsAbs (asIMOD SEM)", "unfolding igSubstAbsIPresIGWlsAbs_def asIMOD_igSubstAbs asIMOD_igWls asIMOD_igWlsAbs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys Y y us s A.\n       isInBar (us, s) \\<and>\n       (\\<forall>val.\n           (sWlsVal SEM val \\<or> Y val = undefined) \\<and>\n           (sWlsVal SEM val \\<longrightarrow>\n            sWls SEM (asSort ys) (Y val))) \\<and>\n       (\\<forall>val.\n           (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n           (sWlsVal SEM val \\<longrightarrow>\n            sWlsAbs SEM (us, s) (A val))) \\<longrightarrow>\n       (\\<forall>val.\n           (sWlsVal SEM val \\<or>\n            (if sWlsVal SEM val then A (val (y := Y val)_ys)\n             else undefined) =\n            undefined) \\<and>\n           (sWlsVal SEM val \\<longrightarrow>\n            sWlsAbs SEM (us, s)\n             (if sWlsVal SEM val then A (val (y := Y val)_ys)\n              else undefined)))", "by simp"], ["", "lemma asIMOD_igSubstAllIPresIGWlsAll: \"igSubstAllIPresIGWlsAll (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAllIPresIGWlsAll (asIMOD SEM)", "unfolding igSubstAllIPresIGWlsAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIPresIGWls (asIMOD SEM) \\<and>\n    igSubstAbsIPresIGWlsAbs (asIMOD SEM)", "using asIMOD_igSubstIPresIGWls asIMOD_igSubstAbsIPresIGWlsAbs"], ["proof (prove)\nusing this:\n  igSubstIPresIGWls (asIMOD ?SEM)\n  igSubstAbsIPresIGWlsAbs (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. igSubstIPresIGWls (asIMOD SEM) \\<and>\n    igSubstAbsIPresIGWlsAbs (asIMOD SEM)", "by auto"], ["", "text \\<open>The clauses for fresh hold:\\<close>"], ["", "lemma asIMOD_igFreshIGVar: \"igFreshIGVar (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshIGVar (asIMOD SEM)", "unfolding igFreshIGVar_def asIMOD_igFresh asIMOD_igVar eqBut_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y xs x.\n       ys \\<noteq> xs \\<or> y \\<noteq> x \\<longrightarrow>\n       (\\<forall>val val'.\n           sWlsVal SEM val \\<and>\n           sWlsVal SEM val' \\<and>\n           (\\<forall>ysa ya.\n               ysa = ys \\<and> ya = y \\<or>\n               val ysa ya = val' ysa ya) \\<longrightarrow>\n           (if sWlsVal SEM val then val xs x else undefined) =\n           (if sWlsVal SEM val' then val' xs x else undefined))", "by force"], ["", "lemma asIMOD_igFreshIGAbs1:\n\"sWlsDisj SEM \\<Longrightarrow> igFreshIGAbs1 (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsDisj SEM \\<Longrightarrow> igFreshIGAbs1 (asIMOD SEM)", "by(fastforce simp: igFreshIGAbs1_def asIMOD_igFresh asIMOD_igFreshAbs asIMOD_igAbs2 updVal_eqBut_eq)"], ["", "lemma asIMOD_igFreshIGAbs2:\n\"sWlsDisj SEM \\<Longrightarrow> igFreshIGAbs2 (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsDisj SEM \\<Longrightarrow> igFreshIGAbs2 (asIMOD SEM)", "by(fastforce simp: igFreshIGAbs2_def asIMOD_igFresh asIMOD_igFreshAbs asIMOD_igAbs2  updVal_preserves_eqBut)"], ["", "lemma asIMOD_igFreshIGOp:\nfixes SEM :: \"('index,'bindex,'varSort,'sort,'opSym,'sTerm)semDom\"\nshows \"igFreshIGOp (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshIGOp (asIMOD SEM)", "unfolding igFreshIGOp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y delta inp binp.\n       igWlsInp (asIMOD SEM) delta inp \\<and>\n       igWlsBinp (asIMOD SEM) delta binp \\<longrightarrow>\n       igFreshInp (asIMOD SEM) ys y inp \\<and>\n       igFreshBinp (asIMOD SEM) ys y binp \\<longrightarrow>\n       igFresh (asIMOD SEM) ys y (igOp (asIMOD SEM) delta inp binp)", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y delta inp binp.\n       \\<lbrakk>igWlsInp (asIMOD SEM) delta inp;\n        igWlsBinp (asIMOD SEM) delta binp; igFreshInp (asIMOD SEM) ys y inp;\n        igFreshBinp (asIMOD SEM) ys y binp\\<rbrakk>\n       \\<Longrightarrow> igFresh (asIMOD SEM) ys y\n                          (igOp (asIMOD SEM) delta inp binp)", "fix ys y delta and inp :: \"('index, ('varSort,'var,'sTerm)gTerm)input\"\n  and binp :: \"('bindex, ('varSort,'var,'sTerm)gAbs)input\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y delta inp binp.\n       \\<lbrakk>igWlsInp (asIMOD SEM) delta inp;\n        igWlsBinp (asIMOD SEM) delta binp; igFreshInp (asIMOD SEM) ys y inp;\n        igFreshBinp (asIMOD SEM) ys y binp\\<rbrakk>\n       \\<Longrightarrow> igFresh (asIMOD SEM) ys y\n                          (igOp (asIMOD SEM) delta inp binp)", "assume inp_fresh: \"igFreshInp (asIMOD SEM) ys y inp\"\n                    \"igFreshBinp (asIMOD SEM) ys y binp\""], ["proof (state)\nthis:\n  igFreshInp (asIMOD SEM) ys y inp\n  igFreshBinp (asIMOD SEM) ys y binp\n\ngoal (1 subgoal):\n 1. \\<And>ys y delta inp binp.\n       \\<lbrakk>igWlsInp (asIMOD SEM) delta inp;\n        igWlsBinp (asIMOD SEM) delta binp; igFreshInp (asIMOD SEM) ys y inp;\n        igFreshBinp (asIMOD SEM) ys y binp\\<rbrakk>\n       \\<Longrightarrow> igFresh (asIMOD SEM) ys y\n                          (igOp (asIMOD SEM) delta inp binp)", "show \"igFresh (asIMOD SEM) ys y (igOp (asIMOD SEM) delta inp binp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFresh (asIMOD SEM) ys y (igOp (asIMOD SEM) delta inp binp)", "unfolding asIMOD_igFresh asIMOD_igOp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>val val'.\n       sWlsVal SEM val \\<and>\n       sWlsVal SEM val' \\<and> eqBut val val' ys y \\<longrightarrow>\n       (if sWlsVal SEM val\n        then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n              (lift (\\<lambda>A. A val) binp)\n        else undefined) =\n       (if sWlsVal SEM val'\n        then sOp SEM delta (lift (\\<lambda>X. X val') inp)\n              (lift (\\<lambda>A. A val') binp)\n        else undefined)", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>val val'.\n       \\<lbrakk>sWlsVal SEM val; sWlsVal SEM val';\n        eqBut val val' ys y\\<rbrakk>\n       \\<Longrightarrow> (if sWlsVal SEM val\n                          then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                                (lift (\\<lambda>A. A val) binp)\n                          else undefined) =\n                         (if sWlsVal SEM val'\n                          then sOp SEM delta (lift (\\<lambda>X. X val') inp)\n                                (lift (\\<lambda>A. A val') binp)\n                          else undefined)", "fix val val'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>val val'.\n       \\<lbrakk>sWlsVal SEM val; sWlsVal SEM val';\n        eqBut val val' ys y\\<rbrakk>\n       \\<Longrightarrow> (if sWlsVal SEM val\n                          then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                                (lift (\\<lambda>A. A val) binp)\n                          else undefined) =\n                         (if sWlsVal SEM val'\n                          then sOp SEM delta (lift (\\<lambda>X. X val') inp)\n                                (lift (\\<lambda>A. A val') binp)\n                          else undefined)", "let ?sinp = \"lift (\\<lambda>X. X val) inp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>val val'.\n       \\<lbrakk>sWlsVal SEM val; sWlsVal SEM val';\n        eqBut val val' ys y\\<rbrakk>\n       \\<Longrightarrow> (if sWlsVal SEM val\n                          then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                                (lift (\\<lambda>A. A val) binp)\n                          else undefined) =\n                         (if sWlsVal SEM val'\n                          then sOp SEM delta (lift (\\<lambda>X. X val') inp)\n                                (lift (\\<lambda>A. A val') binp)\n                          else undefined)", "let ?sinp' = \"lift (\\<lambda>X. X val') inp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>val val'.\n       \\<lbrakk>sWlsVal SEM val; sWlsVal SEM val';\n        eqBut val val' ys y\\<rbrakk>\n       \\<Longrightarrow> (if sWlsVal SEM val\n                          then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                                (lift (\\<lambda>A. A val) binp)\n                          else undefined) =\n                         (if sWlsVal SEM val'\n                          then sOp SEM delta (lift (\\<lambda>X. X val') inp)\n                                (lift (\\<lambda>A. A val') binp)\n                          else undefined)", "let ?sbinp = \"lift (\\<lambda>A. A val) binp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>val val'.\n       \\<lbrakk>sWlsVal SEM val; sWlsVal SEM val';\n        eqBut val val' ys y\\<rbrakk>\n       \\<Longrightarrow> (if sWlsVal SEM val\n                          then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                                (lift (\\<lambda>A. A val) binp)\n                          else undefined) =\n                         (if sWlsVal SEM val'\n                          then sOp SEM delta (lift (\\<lambda>X. X val') inp)\n                                (lift (\\<lambda>A. A val') binp)\n                          else undefined)", "let ?sbinp' = \"lift (\\<lambda>A. A val') binp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>val val'.\n       \\<lbrakk>sWlsVal SEM val; sWlsVal SEM val';\n        eqBut val val' ys y\\<rbrakk>\n       \\<Longrightarrow> (if sWlsVal SEM val\n                          then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                                (lift (\\<lambda>A. A val) binp)\n                          else undefined) =\n                         (if sWlsVal SEM val'\n                          then sOp SEM delta (lift (\\<lambda>X. X val') inp)\n                                (lift (\\<lambda>A. A val') binp)\n                          else undefined)", "assume wls: \"sWlsVal SEM val\" \"sWlsVal SEM val'\" and \"eqBut val val' ys y\""], ["proof (state)\nthis:\n  sWlsVal SEM val\n  sWlsVal SEM val'\n  eqBut val val' ys y\n\ngoal (1 subgoal):\n 1. \\<And>val val'.\n       \\<lbrakk>sWlsVal SEM val; sWlsVal SEM val';\n        eqBut val val' ys y\\<rbrakk>\n       \\<Longrightarrow> (if sWlsVal SEM val\n                          then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                                (lift (\\<lambda>A. A val) binp)\n                          else undefined) =\n                         (if sWlsVal SEM val'\n                          then sOp SEM delta (lift (\\<lambda>X. X val') inp)\n                                (lift (\\<lambda>A. A val') binp)\n                          else undefined)", "hence \"?sinp = ?sinp' \\<and> ?sbinp = ?sbinp'\""], ["proof (prove)\nusing this:\n  sWlsVal SEM val\n  sWlsVal SEM val'\n  eqBut val val' ys y\n\ngoal (1 subgoal):\n 1. lift (\\<lambda>X. X val) inp = lift (\\<lambda>X. X val') inp \\<and>\n    lift (\\<lambda>A. A val) binp = lift (\\<lambda>A. A val') binp", "using inp_fresh"], ["proof (prove)\nusing this:\n  sWlsVal SEM val\n  sWlsVal SEM val'\n  eqBut val val' ys y\n  igFreshInp (asIMOD SEM) ys y inp\n  igFreshBinp (asIMOD SEM) ys y binp\n\ngoal (1 subgoal):\n 1. lift (\\<lambda>X. X val) inp = lift (\\<lambda>X. X val') inp \\<and>\n    lift (\\<lambda>A. A val) binp = lift (\\<lambda>A. A val') binp", "by (auto simp: lift_def igFreshInp_def igFreshBinp_def errMOD_def liftAll_def \n    asIMOD_igFresh asIMOD_igFreshAbs split: option.splits)"], ["proof (state)\nthis:\n  lift (\\<lambda>X. X val) inp = lift (\\<lambda>X. X val') inp \\<and>\n  lift (\\<lambda>A. A val) binp = lift (\\<lambda>A. A val') binp\n\ngoal (1 subgoal):\n 1. \\<And>val val'.\n       \\<lbrakk>sWlsVal SEM val; sWlsVal SEM val';\n        eqBut val val' ys y\\<rbrakk>\n       \\<Longrightarrow> (if sWlsVal SEM val\n                          then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                                (lift (\\<lambda>A. A val) binp)\n                          else undefined) =\n                         (if sWlsVal SEM val'\n                          then sOp SEM delta (lift (\\<lambda>X. X val') inp)\n                                (lift (\\<lambda>A. A val') binp)\n                          else undefined)", "then"], ["proof (chain)\npicking this:\n  lift (\\<lambda>X. X val) inp = lift (\\<lambda>X. X val') inp \\<and>\n  lift (\\<lambda>A. A val) binp = lift (\\<lambda>A. A val') binp", "show \"(if sWlsVal SEM val then sOp SEM delta (lift (\\<lambda>X. X val) inp) (lift (\\<lambda>A. A val) binp)\n           else undefined) =\n          (if sWlsVal SEM val' then sOp SEM delta (lift (\\<lambda>X. X val') inp) (lift (\\<lambda>A. A val') binp)\n           else undefined)\""], ["proof (prove)\nusing this:\n  lift (\\<lambda>X. X val) inp = lift (\\<lambda>X. X val') inp \\<and>\n  lift (\\<lambda>A. A val) binp = lift (\\<lambda>A. A val') binp\n\ngoal (1 subgoal):\n 1. (if sWlsVal SEM val\n     then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n           (lift (\\<lambda>A. A val) binp)\n     else undefined) =\n    (if sWlsVal SEM val'\n     then sOp SEM delta (lift (\\<lambda>X. X val') inp)\n           (lift (\\<lambda>A. A val') binp)\n     else undefined)", "using wls"], ["proof (prove)\nusing this:\n  lift (\\<lambda>X. X val) inp = lift (\\<lambda>X. X val') inp \\<and>\n  lift (\\<lambda>A. A val) binp = lift (\\<lambda>A. A val') binp\n  sWlsVal SEM val\n  sWlsVal SEM val'\n\ngoal (1 subgoal):\n 1. (if sWlsVal SEM val\n     then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n           (lift (\\<lambda>A. A val) binp)\n     else undefined) =\n    (if sWlsVal SEM val'\n     then sOp SEM delta (lift (\\<lambda>X. X val') inp)\n           (lift (\\<lambda>A. A val') binp)\n     else undefined)", "by auto"], ["proof (state)\nthis:\n  (if sWlsVal SEM val\n   then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n         (lift (\\<lambda>A. A val) binp)\n   else undefined) =\n  (if sWlsVal SEM val'\n   then sOp SEM delta (lift (\\<lambda>X. X val') inp)\n         (lift (\\<lambda>A. A val') binp)\n   else undefined)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  igFresh (asIMOD SEM) ys y (igOp (asIMOD SEM) delta inp binp)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma asIMOD_igFreshCls:\nassumes \"sWlsDisj SEM\"\nshows \"igFreshCls (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igFreshCls (asIMOD SEM)", "using assms"], ["proof (prove)\nusing this:\n  sWlsDisj SEM\n\ngoal (1 subgoal):\n 1. igFreshCls (asIMOD SEM)", "unfolding igFreshCls_def"], ["proof (prove)\nusing this:\n  sWlsDisj SEM\n\ngoal (1 subgoal):\n 1. igFreshIGVar (asIMOD SEM) \\<and>\n    igFreshIGAbs1 (asIMOD SEM) \\<and>\n    igFreshIGAbs2 (asIMOD SEM) \\<and> igFreshIGOp (asIMOD SEM)", "using asIMOD_igFreshIGVar asIMOD_igFreshIGAbs1 asIMOD_igFreshIGAbs2 asIMOD_igFreshIGOp"], ["proof (prove)\nusing this:\n  sWlsDisj SEM\n  igFreshIGVar (asIMOD ?SEM)\n  sWlsDisj ?SEM \\<Longrightarrow> igFreshIGAbs1 (asIMOD ?SEM)\n  sWlsDisj ?SEM \\<Longrightarrow> igFreshIGAbs2 (asIMOD ?SEM)\n  igFreshIGOp (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. igFreshIGVar (asIMOD SEM) \\<and>\n    igFreshIGAbs1 (asIMOD SEM) \\<and>\n    igFreshIGAbs2 (asIMOD SEM) \\<and> igFreshIGOp (asIMOD SEM)", "by auto"], ["", "text \\<open>The clauses for swap hold:\\<close>"], ["", "lemma asIMOD_igSwapIGVar: \"igSwapIGVar (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIGVar (asIMOD SEM)", "unfolding igSwapIGVar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 xs x.\n       igSwap (asIMOD SEM) zs z1 z2 (igVar (asIMOD SEM) xs x) =\n       igVar (asIMOD SEM) xs (x @xs[z1 \\<and> z2]_zs)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 xs x.\n       igSwap (asIMOD SEM) zs z1 z2 (igVar (asIMOD SEM) xs x) =\n       igVar (asIMOD SEM) xs (x @xs[z1 \\<and> z2]_zs)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 xs x xa.\n       igSwap (asIMOD SEM) zs z1 z2 (igVar (asIMOD SEM) xs x) xa =\n       igVar (asIMOD SEM) xs (x @xs[z1 \\<and> z2]_zs) xa", "unfolding asIMOD_igSwap asIMOD_igVar"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 xs x xa.\n       (if sWlsVal SEM xa\n        then if sWlsVal SEM (xa ^[z1 \\<and> z2]_zs)\n             then (xa ^[z1 \\<and> z2]_zs) xs x else undefined\n        else undefined) =\n       (if sWlsVal SEM xa then xa xs (x @xs[z1 \\<and> z2]_zs)\n        else undefined)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 xs x xa.\n       sWlsVal SEM xa \\<Longrightarrow>\n       (xa ^[z1 \\<and> z2]_zs) xs x = xa xs (x @xs[z1 \\<and> z2]_zs)", "unfolding swapVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs z1 z2 xs x xa.\n       sWlsVal SEM xa \\<Longrightarrow>\n       xa xs (x @xs[z1 \\<and> z2]_zs) = xa xs (x @xs[z1 \\<and> z2]_zs)", "by simp"], ["", "lemma asIMOD_igSwapIGAbs: \"igSwapIGAbs (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIGAbs (asIMOD SEM)", "by (fastforce simp: igSwapIGAbs_def asIMOD_igSwap asIMOD_igSwapAbs asIMOD_igAbs updVal_swapVal)"], ["", "lemma asIMOD_igSwapIGOp: \"igSwapIGOp (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIGOp (asIMOD SEM)", "by (auto simp: igSwapIGOp_def asIMOD_igSwap asIMOD_igOp asIMOD_igSwapInp asIMOD_igSwapBinp)"], ["", "lemma asIMOD_igSwapCls: \"igSwapCls (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapCls (asIMOD SEM)", "unfolding igSwapCls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSwapIGVar (asIMOD SEM) \\<and>\n    igSwapIGAbs (asIMOD SEM) \\<and> igSwapIGOp (asIMOD SEM)", "using asIMOD_igSwapIGVar asIMOD_igSwapIGAbs asIMOD_igSwapIGOp"], ["proof (prove)\nusing this:\n  igSwapIGVar (asIMOD ?SEM)\n  igSwapIGAbs (asIMOD ?SEM)\n  igSwapIGOp (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. igSwapIGVar (asIMOD SEM) \\<and>\n    igSwapIGAbs (asIMOD SEM) \\<and> igSwapIGOp (asIMOD SEM)", "by auto"], ["", "text\\<open>The clauses for subst hold:\\<close>"], ["", "lemma asIMOD_igSubstIGVar1: \"igSubstIGVar1 (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGVar1 (asIMOD SEM)", "by (auto simp: igSubstIGVar1_def asIMOD_igSubst asIMOD_igVar asIMOD_igWls)"], ["", "lemma asIMOD_igSubstIGVar2: \"igSubstIGVar2 (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGVar2 (asIMOD SEM)", "by (fastforce simp: igSubstIGVar2_def asIMOD_igSubst asIMOD_igVar asIMOD_igWls)"], ["", "lemma asIMOD_igSubstIGAbs: \"igSubstIGAbs (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGAbs (asIMOD SEM)", "unfolding igSubstIGAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y Y xs x s X.\n       isInBar (xs, s) \\<and>\n       igWls (asIMOD SEM) (asSort ys) Y \\<and>\n       igWls (asIMOD SEM) s X \\<longrightarrow>\n       (xs \\<noteq> ys \\<or> x \\<noteq> y) \\<and>\n       igFresh (asIMOD SEM) xs x Y \\<longrightarrow>\n       igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) =\n       igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X)", "proof(clarify, rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y xs x s X xa.\n       \\<lbrakk>isInBar (xs, s); igWls (asIMOD SEM) (asSort ys) Y;\n        igWls (asIMOD SEM) s X; xs \\<noteq> ys \\<or> x \\<noteq> y;\n        igFresh (asIMOD SEM) xs x Y\\<rbrakk>\n       \\<Longrightarrow> igSubstAbs (asIMOD SEM) ys Y y\n                          (igAbs (asIMOD SEM) xs x X) xa =\n                         igAbs (asIMOD SEM) xs x\n                          (igSubst (asIMOD SEM) ys Y y X) xa", "fix ys y Y xs x s X val"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y xs x s X xa.\n       \\<lbrakk>isInBar (xs, s); igWls (asIMOD SEM) (asSort ys) Y;\n        igWls (asIMOD SEM) s X; xs \\<noteq> ys \\<or> x \\<noteq> y;\n        igFresh (asIMOD SEM) xs x Y\\<rbrakk>\n       \\<Longrightarrow> igSubstAbs (asIMOD SEM) ys Y y\n                          (igAbs (asIMOD SEM) xs x X) xa =\n                         igAbs (asIMOD SEM) xs x\n                          (igSubst (asIMOD SEM) ys Y y X) xa", "assume Y: \"igWls (asIMOD SEM) (asSort ys) Y\"\n  and X: \"igWls (asIMOD SEM) s X\" and x_diff_y: \"xs \\<noteq> ys \\<or> x \\<noteq> y\"\n  and x_fresh_Y: \"igFresh (asIMOD SEM) xs x Y\""], ["proof (state)\nthis:\n  igWls (asIMOD SEM) (asSort ys) Y\n  igWls (asIMOD SEM) s X\n  xs \\<noteq> ys \\<or> x \\<noteq> y\n  igFresh (asIMOD SEM) xs x Y\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y xs x s X xa.\n       \\<lbrakk>isInBar (xs, s); igWls (asIMOD SEM) (asSort ys) Y;\n        igWls (asIMOD SEM) s X; xs \\<noteq> ys \\<or> x \\<noteq> y;\n        igFresh (asIMOD SEM) xs x Y\\<rbrakk>\n       \\<Longrightarrow> igSubstAbs (asIMOD SEM) ys Y y\n                          (igAbs (asIMOD SEM) xs x X) xa =\n                         igAbs (asIMOD SEM) xs x\n                          (igSubst (asIMOD SEM) ys Y y X) xa", "show \"igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n        igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "proof(cases \"sWlsVal SEM val\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val\n 2. \\<not> sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "case False"], ["proof (state)\nthis:\n  \\<not> sWlsVal SEM val\n\ngoal (2 subgoals):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val\n 2. \\<not> sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> sWlsVal SEM val\n\ngoal (1 subgoal):\n 1. igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "unfolding asIMOD_igSubst asIMOD_igSubstAbs asIMOD_igAbs"], ["proof (prove)\nusing this:\n  \\<not> sWlsVal SEM val\n\ngoal (1 subgoal):\n 1. (if sWlsVal SEM val\n     then if sWlsVal SEM (val (y := Y val)_ys)\n          then sAbs xs\n                (\\<lambda>sX.\n                    if sWls SEM (asSort xs) sX\n                    then X (val (y := Y val)_ys (x := sX)_xs)\n                    else sDummy SEM\n                          (SOME s. sWls SEM s (X (val (y := Y val)_ys))))\n          else undefined\n     else undefined) =\n    (if sWlsVal SEM val\n     then sAbs xs\n           (\\<lambda>sX.\n               if sWls SEM (asSort xs) sX\n               then if sWlsVal SEM (val (x := sX)_xs)\n                    then X (val (x := sX)_xs (y := Y (val (x := sX)_xs))_ys)\n                    else undefined\n               else sDummy SEM\n                     (SOME s.\n                         sWls SEM s\n                          (if sWlsVal SEM val then X (val (y := Y val)_ys)\n                           else undefined)))\n     else undefined)", "by simp"], ["proof (state)\nthis:\n  igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n  igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val\n\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "case True"], ["proof (state)\nthis:\n  sWlsVal SEM val\n\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "hence Yval: \"sWls SEM (asSort ys) (Y val)\""], ["proof (prove)\nusing this:\n  sWlsVal SEM val\n\ngoal (1 subgoal):\n 1. sWls SEM (asSort ys) (Y val)", "using Y"], ["proof (prove)\nusing this:\n  sWlsVal SEM val\n  igWls (asIMOD SEM) (asSort ys) Y\n\ngoal (1 subgoal):\n 1. sWls SEM (asSort ys) (Y val)", "unfolding asIMOD_igWls"], ["proof (prove)\nusing this:\n  sWlsVal SEM val\n  \\<forall>val.\n     (sWlsVal SEM val \\<or> Y val = undefined) \\<and>\n     (sWlsVal SEM val \\<longrightarrow> sWls SEM (asSort ys) (Y val))\n\ngoal (1 subgoal):\n 1. sWls SEM (asSort ys) (Y val)", "by simp"], ["proof (state)\nthis:\n  sWls SEM (asSort ys) (Y val)\n\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "{"], ["proof (state)\nthis:\n  sWls SEM (asSort ys) (Y val)\n\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "fix sX"], ["proof (state)\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "assume sX: \"sWls SEM (asSort xs) sX\""], ["proof (state)\nthis:\n  sWls SEM (asSort xs) sX\n\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "let ?val_x = \"val (x := sX)_xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "have \"sWlsVal SEM ?val_x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsVal SEM (val (x := sX)_xs)", "using True sX"], ["proof (prove)\nusing this:\n  sWlsVal SEM val\n  sWls SEM (asSort xs) sX\n\ngoal (1 subgoal):\n 1. sWlsVal SEM (val (x := sX)_xs)", "by simp"], ["proof (state)\nthis:\n  sWlsVal SEM (val (x := sX)_xs)\n\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "moreover"], ["proof (state)\nthis:\n  sWlsVal SEM (val (x := sX)_xs)\n\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "have \"eqBut ?val_x val xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqBut (val (x := sX)_xs) val xs x", "unfolding eqBut_def updVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y.\n       ys = xs \\<and> y = x \\<or>\n       (if ys = xs \\<and> y = x then sX else val ys y) = val ys y", "by simp"], ["proof (state)\nthis:\n  eqBut (val (x := sX)_xs) val xs x\n\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "ultimately"], ["proof (chain)\npicking this:\n  sWlsVal SEM (val (x := sX)_xs)\n  eqBut (val (x := sX)_xs) val xs x", "have 1: \"Y ?val_x = Y val\""], ["proof (prove)\nusing this:\n  sWlsVal SEM (val (x := sX)_xs)\n  eqBut (val (x := sX)_xs) val xs x\n\ngoal (1 subgoal):\n 1. Y (val (x := sX)_xs) = Y val", "using True x_fresh_Y"], ["proof (prove)\nusing this:\n  sWlsVal SEM (val (x := sX)_xs)\n  eqBut (val (x := sX)_xs) val xs x\n  sWlsVal SEM val\n  igFresh (asIMOD SEM) xs x Y\n\ngoal (1 subgoal):\n 1. Y (val (x := sX)_xs) = Y val", "unfolding asIMOD_igFresh"], ["proof (prove)\nusing this:\n  sWlsVal SEM (val (x := sX)_xs)\n  eqBut (val (x := sX)_xs) val xs x\n  sWlsVal SEM val\n  \\<forall>val val'.\n     sWlsVal SEM val \\<and>\n     sWlsVal SEM val' \\<and> eqBut val val' xs x \\<longrightarrow>\n     Y val = Y val'\n\ngoal (1 subgoal):\n 1. Y (val (x := sX)_xs) = Y val", "by simp"], ["proof (state)\nthis:\n  Y (val (x := sX)_xs) = Y val\n\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "let ?Left = \"X ((val (y := Y val)_ys) (x := sX)_xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "let ?Riight = \"X (?val_x (y := Y ?val_x)_ys)\""], ["proof (state)\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "have \"?Left = X (?val_x (y := Y val)_ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X (val (y := Y val)_ys (x := sX)_xs) =\n    X (val (x := sX)_xs (y := Y val)_ys)", "using x_diff_y"], ["proof (prove)\nusing this:\n  xs \\<noteq> ys \\<or> x \\<noteq> y\n\ngoal (1 subgoal):\n 1. X (val (y := Y val)_ys (x := sX)_xs) =\n    X (val (x := sX)_xs (y := Y val)_ys)", "by(auto simp add: updVal_commute)"], ["proof (state)\nthis:\n  X (val (y := Y val)_ys (x := sX)_xs) =\n  X (val (x := sX)_xs (y := Y val)_ys)\n\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "also"], ["proof (state)\nthis:\n  X (val (y := Y val)_ys (x := sX)_xs) =\n  X (val (x := sX)_xs (y := Y val)_ys)\n\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "have \"\\<dots> = ?Riight\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X (val (x := sX)_xs (y := Y val)_ys) =\n    X (val (x := sX)_xs (y := Y (val (x := sX)_xs))_ys)", "using 1"], ["proof (prove)\nusing this:\n  Y (val (x := sX)_xs) = Y val\n\ngoal (1 subgoal):\n 1. X (val (x := sX)_xs (y := Y val)_ys) =\n    X (val (x := sX)_xs (y := Y (val (x := sX)_xs))_ys)", "by simp"], ["proof (state)\nthis:\n  X (val (x := sX)_xs (y := Y val)_ys) =\n  X (val (x := sX)_xs (y := Y (val (x := sX)_xs))_ys)\n\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "finally"], ["proof (chain)\npicking this:\n  X (val (y := Y val)_ys (x := sX)_xs) =\n  X (val (x := sX)_xs (y := Y (val (x := sX)_xs))_ys)", "have \"?Left = ?Riight\""], ["proof (prove)\nusing this:\n  X (val (y := Y val)_ys (x := sX)_xs) =\n  X (val (x := sX)_xs (y := Y (val (x := sX)_xs))_ys)\n\ngoal (1 subgoal):\n 1. X (val (y := Y val)_ys (x := sX)_xs) =\n    X (val (x := sX)_xs (y := Y (val (x := sX)_xs))_ys)", "."], ["proof (state)\nthis:\n  X (val (y := Y val)_ys (x := sX)_xs) =\n  X (val (x := sX)_xs (y := Y (val (x := sX)_xs))_ys)\n\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "}"], ["proof (state)\nthis:\n  sWls SEM (asSort xs) ?sX154 \\<Longrightarrow>\n  X (val (y := Y val)_ys (x := ?sX154)_xs) =\n  X (val (x := ?sX154)_xs (y := Y (val (x := ?sX154)_xs))_ys)\n\ngoal (1 subgoal):\n 1. sWlsVal SEM val \\<Longrightarrow>\n    igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "thus ?thesis"], ["proof (prove)\nusing this:\n  sWls SEM (asSort xs) ?sX154 \\<Longrightarrow>\n  X (val (y := Y val)_ys (x := ?sX154)_xs) =\n  X (val (x := ?sX154)_xs (y := Y (val (x := ?sX154)_xs))_ys)\n\ngoal (1 subgoal):\n 1. igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "using True Yval"], ["proof (prove)\nusing this:\n  sWls SEM (asSort xs) ?sX154 \\<Longrightarrow>\n  X (val (y := Y val)_ys (x := ?sX154)_xs) =\n  X (val (x := ?sX154)_xs (y := Y (val (x := ?sX154)_xs))_ys)\n  sWlsVal SEM val\n  sWls SEM (asSort ys) (Y val)\n\ngoal (1 subgoal):\n 1. igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n    igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val", "by(auto simp: asIMOD_igSubst asIMOD_igSubstAbs asIMOD_igAbs)"], ["proof (state)\nthis:\n  igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n  igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  igSubstAbs (asIMOD SEM) ys Y y (igAbs (asIMOD SEM) xs x X) val =\n  igAbs (asIMOD SEM) xs x (igSubst (asIMOD SEM) ys Y y X) val\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma asIMOD_igSubstIGOp: \"igSubstIGOp (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGOp (asIMOD SEM)", "unfolding igSubstIGOp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys y Y delta inp binp.\n       igWls (asIMOD SEM) (asSort ys) Y \\<and>\n       igWlsInp (asIMOD SEM) delta inp \\<and>\n       igWlsBinp (asIMOD SEM) delta binp \\<longrightarrow>\n       igSubst (asIMOD SEM) ys Y y (igOp (asIMOD SEM) delta inp binp) =\n       igOp (asIMOD SEM) delta (igSubstInp (asIMOD SEM) ys Y y inp)\n        (igSubstBinp (asIMOD SEM) ys Y y binp)", "proof(clarify,rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y delta inp binp x.\n       \\<lbrakk>igWls (asIMOD SEM) (asSort ys) Y;\n        igWlsInp (asIMOD SEM) delta inp;\n        igWlsBinp (asIMOD SEM) delta binp\\<rbrakk>\n       \\<Longrightarrow> igSubst (asIMOD SEM) ys Y y\n                          (igOp (asIMOD SEM) delta inp binp) x =\n                         igOp (asIMOD SEM) delta\n                          (igSubstInp (asIMOD SEM) ys Y y inp)\n                          (igSubstBinp (asIMOD SEM) ys Y y binp) x", "fix ys y Y delta inp binp val"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y delta inp binp x.\n       \\<lbrakk>igWls (asIMOD SEM) (asSort ys) Y;\n        igWlsInp (asIMOD SEM) delta inp;\n        igWlsBinp (asIMOD SEM) delta binp\\<rbrakk>\n       \\<Longrightarrow> igSubst (asIMOD SEM) ys Y y\n                          (igOp (asIMOD SEM) delta inp binp) x =\n                         igOp (asIMOD SEM) delta\n                          (igSubstInp (asIMOD SEM) ys Y y inp)\n                          (igSubstBinp (asIMOD SEM) ys Y y binp) x", "assume Y: \"igWls (asIMOD SEM) (asSort ys) Y\"\n  and inp: \"igWlsInp (asIMOD SEM) delta inp\"\n  and binp: \"igWlsBinp (asIMOD SEM) delta binp\""], ["proof (state)\nthis:\n  igWls (asIMOD SEM) (asSort ys) Y\n  igWlsInp (asIMOD SEM) delta inp\n  igWlsBinp (asIMOD SEM) delta binp\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y delta inp binp x.\n       \\<lbrakk>igWls (asIMOD SEM) (asSort ys) Y;\n        igWlsInp (asIMOD SEM) delta inp;\n        igWlsBinp (asIMOD SEM) delta binp\\<rbrakk>\n       \\<Longrightarrow> igSubst (asIMOD SEM) ys Y y\n                          (igOp (asIMOD SEM) delta inp binp) x =\n                         igOp (asIMOD SEM) delta\n                          (igSubstInp (asIMOD SEM) ys Y y inp)\n                          (igSubstBinp (asIMOD SEM) ys Y y binp) x", "define inpsb binpsb where\n  inpsb_def: \"inpsb \\<equiv> igSubstInp (asIMOD SEM) ys Y y inp\"\n             \"binpsb \\<equiv> igSubstBinp (asIMOD SEM) ys Y y binp\""], ["proof (state)\nthis:\n  inpsb \\<equiv> igSubstInp (asIMOD SEM) ys Y y inp\n  binpsb \\<equiv> igSubstBinp (asIMOD SEM) ys Y y binp\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y delta inp binp x.\n       \\<lbrakk>igWls (asIMOD SEM) (asSort ys) Y;\n        igWlsInp (asIMOD SEM) delta inp;\n        igWlsBinp (asIMOD SEM) delta binp\\<rbrakk>\n       \\<Longrightarrow> igSubst (asIMOD SEM) ys Y y\n                          (igOp (asIMOD SEM) delta inp binp) x =\n                         igOp (asIMOD SEM) delta\n                          (igSubstInp (asIMOD SEM) ys Y y inp)\n                          (igSubstBinp (asIMOD SEM) ys Y y binp) x", "note inpsb_rev = inpsb_def[symmetric]"], ["proof (state)\nthis:\n  igSubstInp (asIMOD SEM) ys Y y inp \\<equiv> inpsb\n  igSubstBinp (asIMOD SEM) ys Y y binp \\<equiv> binpsb\n\ngoal (1 subgoal):\n 1. \\<And>ys y Y delta inp binp x.\n       \\<lbrakk>igWls (asIMOD SEM) (asSort ys) Y;\n        igWlsInp (asIMOD SEM) delta inp;\n        igWlsBinp (asIMOD SEM) delta binp\\<rbrakk>\n       \\<Longrightarrow> igSubst (asIMOD SEM) ys Y y\n                          (igOp (asIMOD SEM) delta inp binp) x =\n                         igOp (asIMOD SEM) delta\n                          (igSubstInp (asIMOD SEM) ys Y y inp)\n                          (igSubstBinp (asIMOD SEM) ys Y y binp) x", "let ?sinpsb = \"lift (\\<lambda>X. X (val (y := Y val)_ys)) inp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y delta inp binp x.\n       \\<lbrakk>igWls (asIMOD SEM) (asSort ys) Y;\n        igWlsInp (asIMOD SEM) delta inp;\n        igWlsBinp (asIMOD SEM) delta binp\\<rbrakk>\n       \\<Longrightarrow> igSubst (asIMOD SEM) ys Y y\n                          (igOp (asIMOD SEM) delta inp binp) x =\n                         igOp (asIMOD SEM) delta\n                          (igSubstInp (asIMOD SEM) ys Y y inp)\n                          (igSubstBinp (asIMOD SEM) ys Y y binp) x", "let ?sbinpsb = \"lift (\\<lambda>A. A (val (y := Y val)_ys)) binp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y Y delta inp binp x.\n       \\<lbrakk>igWls (asIMOD SEM) (asSort ys) Y;\n        igWlsInp (asIMOD SEM) delta inp;\n        igWlsBinp (asIMOD SEM) delta binp\\<rbrakk>\n       \\<Longrightarrow> igSubst (asIMOD SEM) ys Y y\n                          (igOp (asIMOD SEM) delta inp binp) x =\n                         igOp (asIMOD SEM) delta\n                          (igSubstInp (asIMOD SEM) ys Y y inp)\n                          (igSubstBinp (asIMOD SEM) ys Y y binp) x", "show \"igSubst (asIMOD SEM) ys Y y (igOp (asIMOD SEM) delta inp binp) val =\n        igOp (asIMOD SEM) delta (igSubstInp (asIMOD SEM) ys Y y inp)\n                              (igSubstBinp (asIMOD SEM) ys Y y binp) val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubst (asIMOD SEM) ys Y y (igOp (asIMOD SEM) delta inp binp) val =\n    igOp (asIMOD SEM) delta (igSubstInp (asIMOD SEM) ys Y y inp)\n     (igSubstBinp (asIMOD SEM) ys Y y binp) val", "unfolding inpsb_rev"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubst (asIMOD SEM) ys Y y (igOp (asIMOD SEM) delta inp binp) val =\n    igOp (asIMOD SEM) delta inpsb binpsb val", "unfolding asIMOD_igSubst asIMOD_igOp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if sWlsVal SEM val\n     then if sWlsVal SEM (val (y := Y val)_ys)\n          then sOp SEM delta\n                (lift (\\<lambda>X. X (val (y := Y val)_ys)) inp)\n                (lift (\\<lambda>A. A (val (y := Y val)_ys)) binp)\n          else undefined\n     else undefined) =\n    (if sWlsVal SEM val\n     then sOp SEM delta (lift (\\<lambda>X. X val) inpsb)\n           (lift (\\<lambda>A. A val) binpsb)\n     else undefined)", "unfolding inpsb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if sWlsVal SEM val\n     then if sWlsVal SEM (val (y := Y val)_ys)\n          then sOp SEM delta\n                (lift (\\<lambda>X. X (val (y := Y val)_ys)) inp)\n                (lift (\\<lambda>A. A (val (y := Y val)_ys)) binp)\n          else undefined\n     else undefined) =\n    (if sWlsVal SEM val\n     then sOp SEM delta\n           (lift (\\<lambda>X. X val) (igSubstInp (asIMOD SEM) ys Y y inp))\n           (lift (\\<lambda>A. A val) (igSubstBinp (asIMOD SEM) ys Y y binp))\n     else undefined)", "apply(simp add: asIMOD_igSubstInp asIMOD_igSubstBinp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sWlsVal SEM (val (y := Y val)_ys) \\<longrightarrow>\n    sWlsVal SEM val \\<longrightarrow>\n    undefined =\n    sOp SEM delta (lift (\\<lambda>X. X (val (y := Y val)_ys)) inp)\n     (lift (\\<lambda>A. A (val (y := Y val)_ys)) binp)", "using Y"], ["proof (prove)\nusing this:\n  igWls (asIMOD SEM) (asSort ys) Y\n\ngoal (1 subgoal):\n 1. \\<not> sWlsVal SEM (val (y := Y val)_ys) \\<longrightarrow>\n    sWlsVal SEM val \\<longrightarrow>\n    undefined =\n    sOp SEM delta (lift (\\<lambda>X. X (val (y := Y val)_ys)) inp)\n     (lift (\\<lambda>A. A (val (y := Y val)_ys)) binp)", "unfolding asIMOD_def"], ["proof (prove)\nusing this:\n  igWls\n   \\<lparr>igWls =\n             \\<lambda>s X.\n                \\<forall>val.\n                   (sWlsVal SEM val \\<or> X val = undefined) \\<and>\n                   (sWlsVal SEM val \\<longrightarrow> sWls SEM s (X val)),\n      igWlsAbs =\n        \\<lambda>(xs, s) A.\n           \\<forall>val.\n              (sWlsVal SEM val \\<or> A val = undefined) \\<and>\n              (sWlsVal SEM val \\<longrightarrow>\n               sWlsAbs SEM (xs, s) (A val)),\n      igVar =\n        \\<lambda>ys y val. if sWlsVal SEM val then val ys y else undefined,\n      igAbs =\n        \\<lambda>xs x X val.\n           if sWlsVal SEM val\n           then sAbs xs\n                 (\\<lambda>sX.\n                     if sWls SEM (asSort xs) sX then X (val (x := sX)_xs)\n                     else sDummy SEM (SOME s. sWls SEM s (X val)))\n           else undefined,\n      igOp =\n        \\<lambda>delta inp binp val.\n           if sWlsVal SEM val\n           then sOp SEM delta (lift (\\<lambda>X. X val) inp)\n                 (lift (\\<lambda>A. A val) binp)\n           else undefined,\n      igFresh =\n        \\<lambda>ys y X.\n           \\<forall>val val'.\n              sWlsVal SEM val \\<and>\n              sWlsVal SEM val' \\<and> eqBut val val' ys y \\<longrightarrow>\n              X val = X val',\n      igFreshAbs =\n        \\<lambda>ys y A.\n           \\<forall>val val'.\n              sWlsVal SEM val \\<and>\n              sWlsVal SEM val' \\<and> eqBut val val' ys y \\<longrightarrow>\n              A val = A val',\n      igSwap =\n        \\<lambda>zs z1 z2 X val.\n           if sWlsVal SEM val then X (val ^[z1 \\<and> z2]_zs)\n           else undefined,\n      igSwapAbs =\n        \\<lambda>zs z1 z2 A val.\n           if sWlsVal SEM val then A (val ^[z1 \\<and> z2]_zs)\n           else undefined,\n      igSubst =\n        \\<lambda>ys Y y X val.\n           if sWlsVal SEM val then X (val (y := Y val)_ys) else undefined,\n      igSubstAbs =\n        \\<lambda>ys Y y A val.\n           if sWlsVal SEM val then A (val (y := Y val)_ys)\n           else undefined\\<rparr>\n   (asSort ys) Y\n\ngoal (1 subgoal):\n 1. \\<not> sWlsVal SEM (val (y := Y val)_ys) \\<longrightarrow>\n    sWlsVal SEM val \\<longrightarrow>\n    undefined =\n    sOp SEM delta (lift (\\<lambda>X. X (val (y := Y val)_ys)) inp)\n     (lift (\\<lambda>A. A (val (y := Y val)_ys)) binp)", "by auto"], ["proof (state)\nthis:\n  igSubst (asIMOD SEM) ys Y y (igOp (asIMOD SEM) delta inp binp) val =\n  igOp (asIMOD SEM) delta (igSubstInp (asIMOD SEM) ys Y y inp)\n   (igSubstBinp (asIMOD SEM) ys Y y binp) val\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma asIMOD_igSubstCls: \"igSubstCls (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstCls (asIMOD SEM)", "unfolding igSubstCls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. igSubstIGVar1 (asIMOD SEM) \\<and>\n    igSubstIGVar2 (asIMOD SEM) \\<and>\n    igSubstIGAbs (asIMOD SEM) \\<and> igSubstIGOp (asIMOD SEM)", "using asIMOD_igSubstIGVar1 asIMOD_igSubstIGVar2 asIMOD_igSubstIGAbs asIMOD_igSubstIGOp"], ["proof (prove)\nusing this:\n  igSubstIGVar1 (asIMOD ?SEM)\n  igSubstIGVar2 (asIMOD ?SEM)\n  igSubstIGAbs (asIMOD ?SEM)\n  igSubstIGOp (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. igSubstIGVar1 (asIMOD SEM) \\<and>\n    igSubstIGVar2 (asIMOD SEM) \\<and>\n    igSubstIGAbs (asIMOD SEM) \\<and> igSubstIGOp (asIMOD SEM)", "by auto"], ["", "text \\<open>The fresh-swap-based congruence clause holds:\\<close>"], ["", "lemma updVal_swapVal_eqBut: \"eqBut (val (x := sX)_xs) ((val (y := sX)_xs) ^[y \\<and> x]_xs) xs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqBut (val (x := sX)_xs) (val (y := sX)_xs ^[y \\<and> x]_xs) xs y", "by (simp add: updVal_def swapVal_def eqBut_def sw_def)"], ["", "lemma asIMOD_igAbsCongS: \"sWlsDisj SEM \\<Longrightarrow> igAbsCongS (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsDisj SEM \\<Longrightarrow> igAbsCongS (asIMOD SEM)", "unfolding igAbsCongS_def asIMOD_igFresh asIMOD_igSwap asIMOD_igAbs2"], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsDisj SEM \\<Longrightarrow>\n    \\<forall>xs x x' y s X X'.\n       isInBar (xs, s) \\<and>\n       igWls (asIMOD SEM) s X \\<and>\n       igWls (asIMOD SEM) s X' \\<longrightarrow>\n       (\\<forall>val val'.\n           sWlsVal SEM val \\<and>\n           sWlsVal SEM val' \\<and> eqBut val val' xs y \\<longrightarrow>\n           X val = X val') \\<and>\n       (\\<forall>val val'.\n           sWlsVal SEM val \\<and>\n           sWlsVal SEM val' \\<and> eqBut val val' xs y \\<longrightarrow>\n           X' val = X' val') \\<and>\n       (\\<lambda>val.\n           if sWlsVal SEM val then X (val ^[y \\<and> x]_xs)\n           else undefined) =\n       (\\<lambda>val.\n           if sWlsVal SEM val then X' (val ^[y \\<and> x']_xs)\n           else undefined) \\<longrightarrow>\n       igAbs (asIMOD SEM) xs x X = igAbs (asIMOD SEM) xs x' X'", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs x x' y s X X'.\n       \\<lbrakk>sWlsDisj SEM; isInBar (xs, s); igWls (asIMOD SEM) s X;\n        igWls (asIMOD SEM) s X';\n        \\<forall>val val'.\n           sWlsVal SEM val \\<and>\n           sWlsVal SEM val' \\<and> eqBut val val' xs y \\<longrightarrow>\n           X val = X val';\n        \\<forall>val val'.\n           sWlsVal SEM val \\<and>\n           sWlsVal SEM val' \\<and> eqBut val val' xs y \\<longrightarrow>\n           X' val = X' val';\n        (\\<lambda>val.\n            if sWlsVal SEM val then X (val ^[y \\<and> x]_xs)\n            else undefined) =\n        (\\<lambda>val.\n            if sWlsVal SEM val then X' (val ^[y \\<and> x']_xs)\n            else undefined)\\<rbrakk>\n       \\<Longrightarrow> igAbs (asIMOD SEM) xs x X =\n                         igAbs (asIMOD SEM) xs x' X'", "apply (simp add: asIMOD_igAbs2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs x x' y s X X'.\n       \\<lbrakk>sWlsDisj SEM; isInBar (xs, s); igWls (asIMOD SEM) s X;\n        igWls (asIMOD SEM) s X';\n        \\<forall>val val'.\n           sWlsVal SEM val \\<and>\n           sWlsVal SEM val' \\<and> eqBut val val' xs y \\<longrightarrow>\n           X val = X val';\n        \\<forall>val val'.\n           sWlsVal SEM val \\<and>\n           sWlsVal SEM val' \\<and> eqBut val val' xs y \\<longrightarrow>\n           X' val = X' val';\n        (\\<lambda>val.\n            if sWlsVal SEM val then X (val ^[y \\<and> x]_xs)\n            else undefined) =\n        (\\<lambda>val.\n            if sWlsVal SEM val then X' (val ^[y \\<and> x']_xs)\n            else undefined)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>val.\n                             if sWlsVal SEM val\n                             then sAbs xs\n                                   (\\<lambda>sX.\n if sWls SEM (asSort xs) sX then X (val (x := sX)_xs) else sDummy SEM s)\n                             else undefined) =\n                         (\\<lambda>val.\n                             if sWlsVal SEM val\n                             then sAbs xs\n                                   (\\<lambda>sX.\n if sWls SEM (asSort xs) sX then X' (val (x' := sX)_xs) else sDummy SEM s)\n                             else undefined)", "by (rule ext) (metis (hide_lams) updVal_swapVal_eqBut swapVal_preserves_sWls updVal_preserves_sWls)"], ["", "text \\<open>The abstraction-renaming clause holds:\\<close>"], ["", "lemma asIMOD_igAbs3:\nassumes \"sWlsDisj SEM\" and \"igWls (asIMOD SEM) s X\"\nshows\n\"igAbs (asIMOD SEM) xs y (igSubst (asIMOD SEM) xs (igVar (asIMOD SEM) xs y) x X) =\n (\\<lambda>val. if sWlsVal SEM val\n            then sAbs xs (\\<lambda>sX. if sWls SEM (asSort xs) sX\n                                 then (igSubst (asIMOD SEM) xs (igVar (asIMOD SEM) xs y) x X) (val (y := sX)_xs)\n                                 else sDummy SEM s)\n            else undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igAbs (asIMOD SEM) xs y\n     (igSubst (asIMOD SEM) xs (igVar (asIMOD SEM) xs y) x X) =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sAbs xs\n              (\\<lambda>sX.\n                  if sWls SEM (asSort xs) sX\n                  then igSubst (asIMOD SEM) xs (igVar (asIMOD SEM) xs y) x X\n                        (val (y := sX)_xs)\n                  else sDummy SEM s)\n        else undefined)", "using assms asIMOD_igVarIPresIGWls asIMOD_igSubstIPresIGWls"], ["proof (prove)\nusing this:\n  sWlsDisj SEM\n  igWls (asIMOD SEM) s X\n  igVarIPresIGWls (asIMOD ?SEM)\n  igSubstIPresIGWls (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. igAbs (asIMOD SEM) xs y\n     (igSubst (asIMOD SEM) xs (igVar (asIMOD SEM) xs y) x X) =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sAbs xs\n              (\\<lambda>sX.\n                  if sWls SEM (asSort xs) sX\n                  then igSubst (asIMOD SEM) xs (igVar (asIMOD SEM) xs y) x X\n                        (val (y := sX)_xs)\n                  else sDummy SEM s)\n        else undefined)", "unfolding igVarIPresIGWls_def igSubstIPresIGWls_def"], ["proof (prove)\nusing this:\n  sWlsDisj SEM\n  igWls (asIMOD SEM) s X\n  \\<forall>xs x. igWls (asIMOD ?SEM) (asSort xs) (igVar (asIMOD ?SEM) xs x)\n  \\<forall>ys Y y s X.\n     igWls (asIMOD ?SEM) (asSort ys) Y \\<and>\n     igWls (asIMOD ?SEM) s X \\<longrightarrow>\n     igWls (asIMOD ?SEM) s (igSubst (asIMOD ?SEM) ys Y y X)\n\ngoal (1 subgoal):\n 1. igAbs (asIMOD SEM) xs y\n     (igSubst (asIMOD SEM) xs (igVar (asIMOD SEM) xs y) x X) =\n    (\\<lambda>val.\n        if sWlsVal SEM val\n        then sAbs xs\n              (\\<lambda>sX.\n                  if sWls SEM (asSort xs) sX\n                  then igSubst (asIMOD SEM) xs (igVar (asIMOD SEM) xs y) x X\n                        (val (y := sX)_xs)\n                  else sDummy SEM s)\n        else undefined)", "by (fastforce intro!: asIMOD_igAbs2)"], ["", "lemma asIMOD_igAbsRen:\n\"sWlsDisj SEM \\<Longrightarrow> igAbsRen (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsDisj SEM \\<Longrightarrow> igAbsRen (asIMOD SEM)", "unfolding igAbsRen_def asIMOD_igFresh asIMOD_igSwap"], ["proof (prove)\ngoal (1 subgoal):\n 1. sWlsDisj SEM \\<Longrightarrow>\n    \\<forall>xs y x s X.\n       isInBar (xs, s) \\<and> igWls (asIMOD SEM) s X \\<longrightarrow>\n       (\\<forall>val val'.\n           sWlsVal SEM val \\<and>\n           sWlsVal SEM val' \\<and> eqBut val val' xs y \\<longrightarrow>\n           X val = X val') \\<longrightarrow>\n       igAbs (asIMOD SEM) xs y\n        (igSubst (asIMOD SEM) xs (igVar (asIMOD SEM) xs y) x X) =\n       igAbs (asIMOD SEM) xs x X", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs y x s X.\n       \\<lbrakk>sWlsDisj SEM; isInBar (xs, s); igWls (asIMOD SEM) s X;\n        \\<forall>val val'.\n           sWlsVal SEM val \\<and>\n           sWlsVal SEM val' \\<and> eqBut val val' xs y \\<longrightarrow>\n           X val = X val'\\<rbrakk>\n       \\<Longrightarrow> igAbs (asIMOD SEM) xs y\n                          (igSubst (asIMOD SEM) xs (igVar (asIMOD SEM) xs y)\n                            x X) =\n                         igAbs (asIMOD SEM) xs x X", "by (simp add: asIMOD_igAbs2 asIMOD_igAbs3)  \n   (auto intro!: ext simp: asIMOD_igAbs2 asIMOD_igAbs3 eqBut_def asIMOD_igSubst asIMOD_igVar)"], ["", "text \\<open>The associated model forms well-structured models of all 4 kinds:\\<close>"], ["", "lemma asIMOD_wlsFSw:\nassumes \"wlsSEM SEM\"\nshows \"iwlsFSw (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSw (asIMOD SEM)", "using assms"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n\ngoal (1 subgoal):\n 1. iwlsFSw (asIMOD SEM)", "unfolding wlsSEM_def iwlsFSw_def"], ["proof (prove)\nusing this:\n  sWlsNE SEM \\<and> sWlsDisj SEM \\<and> sOpPrSWls SEM\n\ngoal (1 subgoal):\n 1. igWlsAllDisj (asIMOD SEM) \\<and>\n    igWlsAbsIsInBar (asIMOD SEM) \\<and>\n    igConsIPresIGWls (asIMOD SEM) \\<and>\n    igSwapAllIPresIGWlsAll (asIMOD SEM) \\<and>\n    igFreshCls (asIMOD SEM) \\<and>\n    igSwapCls (asIMOD SEM) \\<and> igAbsCongS (asIMOD SEM)", "using assms asIMOD_igWlsAllDisj asIMOD_igWlsAbsIsInBar \nasIMOD_igConsIPresIGWls asIMOD_igSwapAllIPresIGWlsAll \nasIMOD_igFreshCls asIMOD_igSwapCls asIMOD_igAbsCongS"], ["proof (prove)\nusing this:\n  sWlsNE SEM \\<and> sWlsDisj SEM \\<and> sOpPrSWls SEM\n  wlsSEM SEM\n  \\<lbrakk>sWlsNE ?SEM; sWlsDisj ?SEM\\<rbrakk>\n  \\<Longrightarrow> igWlsAllDisj (asIMOD ?SEM)\n  sWlsNE ?SEM \\<Longrightarrow> igWlsAbsIsInBar (asIMOD ?SEM)\n  wlsSEM ?SEM \\<Longrightarrow> igConsIPresIGWls (asIMOD ?SEM)\n  igSwapAllIPresIGWlsAll (asIMOD ?SEM)\n  sWlsDisj ?SEM \\<Longrightarrow> igFreshCls (asIMOD ?SEM)\n  igSwapCls (asIMOD ?SEM)\n  sWlsDisj ?SEM \\<Longrightarrow> igAbsCongS (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. igWlsAllDisj (asIMOD SEM) \\<and>\n    igWlsAbsIsInBar (asIMOD SEM) \\<and>\n    igConsIPresIGWls (asIMOD SEM) \\<and>\n    igSwapAllIPresIGWlsAll (asIMOD SEM) \\<and>\n    igFreshCls (asIMOD SEM) \\<and>\n    igSwapCls (asIMOD SEM) \\<and> igAbsCongS (asIMOD SEM)", "by auto"], ["", "lemma asIMOD_wlsFSb:\nassumes \"wlsSEM SEM\"\nshows \"iwlsFSb (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwlsFSb (asIMOD SEM)", "using assms"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n\ngoal (1 subgoal):\n 1. iwlsFSb (asIMOD SEM)", "unfolding wlsSEM_def iwlsFSb_def"], ["proof (prove)\nusing this:\n  sWlsNE SEM \\<and> sWlsDisj SEM \\<and> sOpPrSWls SEM\n\ngoal (1 subgoal):\n 1. igWlsAllDisj (asIMOD SEM) \\<and>\n    igWlsAbsIsInBar (asIMOD SEM) \\<and>\n    igConsIPresIGWls (asIMOD SEM) \\<and>\n    igSubstAllIPresIGWlsAll (asIMOD SEM) \\<and>\n    igFreshCls (asIMOD SEM) \\<and>\n    igSubstCls (asIMOD SEM) \\<and> igAbsRen (asIMOD SEM)", "using assms asIMOD_igWlsAllDisj asIMOD_igWlsAbsIsInBar \nasIMOD_igConsIPresIGWls[of SEM] asIMOD_igSubstAllIPresIGWlsAll \nasIMOD_igFreshCls  asIMOD_igSubstCls asIMOD_igAbsRen"], ["proof (prove)\nusing this:\n  sWlsNE SEM \\<and> sWlsDisj SEM \\<and> sOpPrSWls SEM\n  wlsSEM SEM\n  \\<lbrakk>sWlsNE ?SEM; sWlsDisj ?SEM\\<rbrakk>\n  \\<Longrightarrow> igWlsAllDisj (asIMOD ?SEM)\n  sWlsNE ?SEM \\<Longrightarrow> igWlsAbsIsInBar (asIMOD ?SEM)\n  wlsSEM SEM \\<Longrightarrow> igConsIPresIGWls (asIMOD SEM)\n  igSubstAllIPresIGWlsAll (asIMOD ?SEM)\n  sWlsDisj ?SEM \\<Longrightarrow> igFreshCls (asIMOD ?SEM)\n  igSubstCls (asIMOD ?SEM)\n  sWlsDisj ?SEM \\<Longrightarrow> igAbsRen (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. igWlsAllDisj (asIMOD SEM) \\<and>\n    igWlsAbsIsInBar (asIMOD SEM) \\<and>\n    igConsIPresIGWls (asIMOD SEM) \\<and>\n    igSubstAllIPresIGWlsAll (asIMOD SEM) \\<and>\n    igFreshCls (asIMOD SEM) \\<and>\n    igSubstCls (asIMOD SEM) \\<and> igAbsRen (asIMOD SEM)", "by auto"], ["", "lemma asIMOD_wlsFSwSb: \"wlsSEM SEM \\<Longrightarrow> iwlsFSwSb (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow> iwlsFSwSb (asIMOD SEM)", "unfolding iwlsFSwSb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow>\n    iwlsFSw (asIMOD SEM) \\<and>\n    igSubstAllIPresIGWlsAll (asIMOD SEM) \\<and> igSubstCls (asIMOD SEM)", "using asIMOD_wlsFSw asIMOD_igSubstAllIPresIGWlsAll asIMOD_igSubstCls"], ["proof (prove)\nusing this:\n  wlsSEM ?SEM \\<Longrightarrow> iwlsFSw (asIMOD ?SEM)\n  igSubstAllIPresIGWlsAll (asIMOD ?SEM)\n  igSubstCls (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow>\n    iwlsFSw (asIMOD SEM) \\<and>\n    igSubstAllIPresIGWlsAll (asIMOD SEM) \\<and> igSubstCls (asIMOD SEM)", "by auto"], ["", "lemma asIMOD_wlsFSbSw: \"wlsSEM SEM \\<Longrightarrow> iwlsFSbSw (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow> iwlsFSbSw (asIMOD SEM)", "unfolding iwlsFSbSw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow>\n    iwlsFSb (asIMOD SEM) \\<and>\n    igSwapAllIPresIGWlsAll (asIMOD SEM) \\<and> igSwapCls (asIMOD SEM)", "using asIMOD_wlsFSb asIMOD_igSwapAllIPresIGWlsAll asIMOD_igSwapCls"], ["proof (prove)\nusing this:\n  wlsSEM ?SEM \\<Longrightarrow> iwlsFSb (asIMOD ?SEM)\n  igSwapAllIPresIGWlsAll (asIMOD ?SEM)\n  igSwapCls (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow>\n    iwlsFSb (asIMOD SEM) \\<and>\n    igSwapAllIPresIGWlsAll (asIMOD SEM) \\<and> igSwapCls (asIMOD SEM)", "by auto"], ["", "subsection \\<open>The semantic interpretation\\<close>"], ["", "text\\<open>The well-definedness of the semantic interpretation, as well\nas its associated substitution lemma and non-dependence of fresh variables,\nare the end products of this theory.\n\nNote that in order to establish these results either fresh-subst-swap or\nfresh-swap-subst aligebras would do the job, and, moreover, if we did not care\nabout swapping, fresh-subst aligebras would do the job.  Therefore, our\nexhaustive study of the model from previous section had a deigree of redundancy w.r.t. to our main\nigoal -- we pursued it however in order to better illustrate the rich structure laying under\nthe apparent paucity of the notion of a semantic domain.  Next, we choose to employ\nfresh-subst-swap aligebras to establish the required results. (Recall however that either aligebraic route\nwe take, the initial morphism turns out to be the same function.)\\<close>"], ["", "definition semInt where \"semInt SEM \\<equiv> iter (asIMOD SEM)\""], ["", "definition semIntAbs where \"semIntAbs SEM \\<equiv> iterAbs (asIMOD SEM)\""], ["", "lemma semIntAll_termFSwSbImorph:\n\"wlsSEM SEM \\<Longrightarrow>\n termFSwSbImorph (semInt SEM) (semIntAbs SEM) (asIMOD SEM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow>\n    termFSwSbImorph (semInt SEM) (semIntAbs SEM) (asIMOD SEM)", "unfolding semInt_def semInt_def semIntAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow>\n    termFSwSbImorph (iter (asIMOD SEM)) (iterAbs (asIMOD SEM)) (asIMOD SEM)", "using asIMOD_wlsFSbSw iwlsFSbSw_iterAll_termFSwSbImorph"], ["proof (prove)\nusing this:\n  wlsSEM ?SEM \\<Longrightarrow> iwlsFSbSw (asIMOD ?SEM)\n  iwlsFSbSw ?MOD \\<Longrightarrow>\n  termFSwSbImorph (iter ?MOD) (iterAbs ?MOD) ?MOD\n\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow>\n    termFSwSbImorph (iter (asIMOD SEM)) (iterAbs (asIMOD SEM)) (asIMOD SEM)", "by auto"], ["", "lemma semInt_prWls:\n\"wlsSEM SEM \\<Longrightarrow> prWls (semInt SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow> prWls (semInt SEM) SEM", "unfolding prWls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow>\n    \\<forall>s X val.\n       wls s X \\<and> sWlsVal SEM val \\<longrightarrow>\n       sWls SEM s (semInt SEM X val)", "using semIntAll_termFSwSbImorph"], ["proof (prove)\nusing this:\n  wlsSEM ?SEM \\<Longrightarrow>\n  termFSwSbImorph (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow>\n    \\<forall>s X val.\n       wls s X \\<and> sWlsVal SEM val \\<longrightarrow>\n       sWls SEM s (semInt SEM X val)", "unfolding termFSwSbImorph_def termFSwImorph_def ipresWlsAll_def ipresWls_def asIMOD_igWls"], ["proof (prove)\nusing this:\n  wlsSEM ?SEM \\<Longrightarrow>\n  (((\\<forall>s X.\n        wls s X \\<longrightarrow>\n        (\\<forall>val.\n            (sWlsVal ?SEM val \\<or> semInt ?SEM X val = undefined) \\<and>\n            (sWlsVal ?SEM val \\<longrightarrow>\n             sWls ?SEM s (semInt ?SEM X val)))) \\<and>\n    ipresWlsAbs (semIntAbs ?SEM) (asIMOD ?SEM)) \\<and>\n   ipresCons (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresFreshAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresSwapAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)) \\<and>\n  ipresSubstAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow>\n    \\<forall>s X val.\n       wls s X \\<and> sWlsVal SEM val \\<longrightarrow>\n       sWls SEM s (semInt SEM X val)", "by auto"], ["", "lemma semIntAbs_prWlsAbs:\n\"wlsSEM SEM \\<Longrightarrow> prWlsAbs (semIntAbs SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow> prWlsAbs (semIntAbs SEM) SEM", "unfolding prWlsAbs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow>\n    \\<forall>us s A val.\n       wlsAbs (us, s) A \\<and> sWlsVal SEM val \\<longrightarrow>\n       sWlsAbs SEM (us, s) (semIntAbs SEM A val)", "using semIntAll_termFSwSbImorph"], ["proof (prove)\nusing this:\n  wlsSEM ?SEM \\<Longrightarrow>\n  termFSwSbImorph (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow>\n    \\<forall>us s A val.\n       wlsAbs (us, s) A \\<and> sWlsVal SEM val \\<longrightarrow>\n       sWlsAbs SEM (us, s) (semIntAbs SEM A val)", "unfolding termFSwSbImorph_def termFSwImorph_def ipresWlsAll_def ipresWlsAbs_def asIMOD_igWlsAbs"], ["proof (prove)\nusing this:\n  wlsSEM ?SEM \\<Longrightarrow>\n  ((ipresWls (semInt ?SEM) (asIMOD ?SEM) \\<and>\n    (\\<forall>us s A.\n        wlsAbs (us, s) A \\<longrightarrow>\n        (\\<forall>val.\n            (sWlsVal ?SEM val \\<or> semIntAbs ?SEM A val = undefined) \\<and>\n            (sWlsVal ?SEM val \\<longrightarrow>\n             sWlsAbs ?SEM (us, s) (semIntAbs ?SEM A val))))) \\<and>\n   ipresCons (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresFreshAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresSwapAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)) \\<and>\n  ipresSubstAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow>\n    \\<forall>us s A val.\n       wlsAbs (us, s) A \\<and> sWlsVal SEM val \\<longrightarrow>\n       sWlsAbs SEM (us, s) (semIntAbs SEM A val)", "by blast"], ["", "lemma semIntAll_prWlsAll:\n\"wlsSEM SEM \\<Longrightarrow> prWlsAll (semInt SEM) (semIntAbs SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow> prWlsAll (semInt SEM) (semIntAbs SEM) SEM", "unfolding prWlsAll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow>\n    prWls (semInt SEM) SEM \\<and> prWlsAbs (semIntAbs SEM) SEM", "by(simp add: semInt_prWls semIntAbs_prWlsAbs)"], ["", "lemma semInt_prVar:\n\"wlsSEM SEM \\<Longrightarrow> prVar (semInt SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow> prVar (semInt SEM) SEM", "using semIntAll_termFSwSbImorph"], ["proof (prove)\nusing this:\n  wlsSEM ?SEM \\<Longrightarrow>\n  termFSwSbImorph (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow> prVar (semInt SEM) SEM", "unfolding prVar_def termFSwSbImorph_def termFSwImorph_def ipresCons_def ipresVar_def asIMOD_igVar"], ["proof (prove)\nusing this:\n  wlsSEM ?SEM \\<Longrightarrow>\n  (ipresWlsAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ((\\<forall>xs x.\n        semInt ?SEM (Var xs x) =\n        (\\<lambda>val.\n            if sWlsVal ?SEM val then val xs x else undefined)) \\<and>\n    ipresAbs (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n    ipresOp (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)) \\<and>\n   ipresFreshAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresSwapAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)) \\<and>\n  ipresSubstAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. wlsSEM SEM \\<Longrightarrow>\n    \\<forall>xs x val.\n       sWlsVal SEM val \\<longrightarrow>\n       semInt SEM (Var xs x) val = val xs x", "by fastforce"], ["", "lemma semIntAll_prAbs:\nfixes SEM :: \"('index,'bindex,'varSort,'sort,'opSym,'sTerm)semDom\"\nassumes \"wlsSEM SEM\"\nshows \"prAbs (semInt SEM) (semIntAbs SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "fix xs s x X and val :: \"('varSort,'var,'sTerm)val\""], ["proof (state)\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "assume xs_s: \"isInBar (xs,s)\" and X: \"wls s X\"\n   and val: \"sWlsVal SEM val\""], ["proof (state)\nthis:\n  isInBar (xs, s)\n  wls s X\n  sWlsVal SEM val\n\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "let ?L = \"semIntAbs SEM (Abs xs x X)\""], ["proof (state)\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "let ?R = \"\\<lambda> val. sAbs xs (\\<lambda>sX. if sWls SEM (asSort xs) sX\n                              then semInt SEM X (val (x := sX)_xs)\n                              else sDummy SEM s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "have \"?L = igAbs (asIMOD SEM) xs x (semInt SEM X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semIntAbs SEM (Abs xs x X) = igAbs (asIMOD SEM) xs x (semInt SEM X)", "using xs_s X assms semIntAll_termFSwSbImorph[of SEM]"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  wlsSEM SEM\n  wlsSEM SEM \\<Longrightarrow>\n  termFSwSbImorph (semInt SEM) (semIntAbs SEM) (asIMOD SEM)\n\ngoal (1 subgoal):\n 1. semIntAbs SEM (Abs xs x X) = igAbs (asIMOD SEM) xs x (semInt SEM X)", "unfolding termFSwSbImorph_def termFSwImorph_def ipresCons_def ipresAbs_def"], ["proof (prove)\nusing this:\n  isInBar (xs, s)\n  wls s X\n  wlsSEM SEM\n  wlsSEM SEM \\<Longrightarrow>\n  (ipresWlsAll (semInt SEM) (semIntAbs SEM) (asIMOD SEM) \\<and>\n   (ipresVar (semInt SEM) (asIMOD SEM) \\<and>\n    (\\<forall>xs x s X.\n        isInBar (xs, s) \\<and> wls s X \\<longrightarrow>\n        semIntAbs SEM (Abs xs x X) =\n        igAbs (asIMOD SEM) xs x (semInt SEM X)) \\<and>\n    ipresOp (semInt SEM) (semIntAbs SEM) (asIMOD SEM)) \\<and>\n   ipresFreshAll (semInt SEM) (semIntAbs SEM) (asIMOD SEM) \\<and>\n   ipresSwapAll (semInt SEM) (semIntAbs SEM) (asIMOD SEM)) \\<and>\n  ipresSubstAll (semInt SEM) (semIntAbs SEM) (asIMOD SEM)\n\ngoal (1 subgoal):\n 1. semIntAbs SEM (Abs xs x X) = igAbs (asIMOD SEM) xs x (semInt SEM X)", "by auto"], ["proof (state)\nthis:\n  semIntAbs SEM (Abs xs x X) = igAbs (asIMOD SEM) xs x (semInt SEM X)\n\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "moreover"], ["proof (state)\nthis:\n  semIntAbs SEM (Abs xs x X) = igAbs (asIMOD SEM) xs x (semInt SEM X)\n\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "{"], ["proof (state)\nthis:\n  semIntAbs SEM (Abs xs x X) = igAbs (asIMOD SEM) xs x (semInt SEM X)\n\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "have \"prWls (semInt SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prWls (semInt SEM) SEM", "using assms semInt_prWls"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n  wlsSEM ?SEM \\<Longrightarrow> prWls (semInt ?SEM) ?SEM\n\ngoal (1 subgoal):\n 1. prWls (semInt SEM) SEM", "by auto"], ["proof (state)\nthis:\n  prWls (semInt SEM) SEM\n\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "hence 1: \"sWls SEM s (semInt SEM X val)\""], ["proof (prove)\nusing this:\n  prWls (semInt SEM) SEM\n\ngoal (1 subgoal):\n 1. sWls SEM s (semInt SEM X val)", "using val X"], ["proof (prove)\nusing this:\n  prWls (semInt SEM) SEM\n  sWlsVal SEM val\n  wls s X\n\ngoal (1 subgoal):\n 1. sWls SEM s (semInt SEM X val)", "unfolding prWls_def"], ["proof (prove)\nusing this:\n  \\<forall>s X val.\n     wls s X \\<and> sWlsVal SEM val \\<longrightarrow>\n     sWls SEM s (semInt SEM X val)\n  sWlsVal SEM val\n  wls s X\n\ngoal (1 subgoal):\n 1. sWls SEM s (semInt SEM X val)", "by simp"], ["proof (state)\nthis:\n  sWls SEM s (semInt SEM X val)\n\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "hence \"(SOME s. sWls SEM s (semInt SEM X val)) = s\""], ["proof (prove)\nusing this:\n  sWls SEM s (semInt SEM X val)\n\ngoal (1 subgoal):\n 1. (SOME s. sWls SEM s (semInt SEM X val)) = s", "using 1 assms"], ["proof (prove)\nusing this:\n  sWls SEM s (semInt SEM X val)\n  sWls SEM s (semInt SEM X val)\n  wlsSEM SEM\n\ngoal (1 subgoal):\n 1. (SOME s. sWls SEM s (semInt SEM X val)) = s", "unfolding wlsSEM_def sWlsDisj_def"], ["proof (prove)\nusing this:\n  sWls SEM s (semInt SEM X val)\n  sWls SEM s (semInt SEM X val)\n  sWlsNE SEM \\<and>\n  (\\<forall>s s' sX.\n      sWls SEM s sX \\<and> sWls SEM s' sX \\<longrightarrow> s = s') \\<and>\n  sOpPrSWls SEM\n\ngoal (1 subgoal):\n 1. (SOME s. sWls SEM s (semInt SEM X val)) = s", "by auto"], ["proof (state)\nthis:\n  (SOME s. sWls SEM s (semInt SEM X val)) = s\n\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "hence \"igAbs (asIMOD SEM) xs x (semInt SEM X) val = ?R val\""], ["proof (prove)\nusing this:\n  (SOME s. sWls SEM s (semInt SEM X val)) = s\n\ngoal (1 subgoal):\n 1. igAbs (asIMOD SEM) xs x (semInt SEM X) val =\n    sAbs xs\n     (\\<lambda>sX.\n         if sWls SEM (asSort xs) sX then semInt SEM X (val (x := sX)_xs)\n         else sDummy SEM s)", "unfolding asIMOD_igAbs"], ["proof (prove)\nusing this:\n  (SOME s. sWls SEM s (semInt SEM X val)) = s\n\ngoal (1 subgoal):\n 1. (if sWlsVal SEM val\n     then sAbs xs\n           (\\<lambda>sX.\n               if sWls SEM (asSort xs) sX\n               then semInt SEM X (val (x := sX)_xs)\n               else sDummy SEM (SOME s. sWls SEM s (semInt SEM X val)))\n     else undefined) =\n    sAbs xs\n     (\\<lambda>sX.\n         if sWls SEM (asSort xs) sX then semInt SEM X (val (x := sX)_xs)\n         else sDummy SEM s)", "using val"], ["proof (prove)\nusing this:\n  (SOME s. sWls SEM s (semInt SEM X val)) = s\n  sWlsVal SEM val\n\ngoal (1 subgoal):\n 1. (if sWlsVal SEM val\n     then sAbs xs\n           (\\<lambda>sX.\n               if sWls SEM (asSort xs) sX\n               then semInt SEM X (val (x := sX)_xs)\n               else sDummy SEM (SOME s. sWls SEM s (semInt SEM X val)))\n     else undefined) =\n    sAbs xs\n     (\\<lambda>sX.\n         if sWls SEM (asSort xs) sX then semInt SEM X (val (x := sX)_xs)\n         else sDummy SEM s)", "by fastforce"], ["proof (state)\nthis:\n  igAbs (asIMOD SEM) xs x (semInt SEM X) val =\n  sAbs xs\n   (\\<lambda>sX.\n       if sWls SEM (asSort xs) sX then semInt SEM X (val (x := sX)_xs)\n       else sDummy SEM s)\n\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "}"], ["proof (state)\nthis:\n  igAbs (asIMOD SEM) xs x (semInt SEM X) val =\n  sAbs xs\n   (\\<lambda>sX.\n       if sWls SEM (asSort xs) sX then semInt SEM X (val (x := sX)_xs)\n       else sDummy SEM s)\n\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "ultimately"], ["proof (chain)\npicking this:\n  semIntAbs SEM (Abs xs x X) = igAbs (asIMOD SEM) xs x (semInt SEM X)\n  igAbs (asIMOD SEM) xs x (semInt SEM X) val =\n  sAbs xs\n   (\\<lambda>sX.\n       if sWls SEM (asSort xs) sX then semInt SEM X (val (x := sX)_xs)\n       else sDummy SEM s)", "have \"?L val = ?R val\""], ["proof (prove)\nusing this:\n  semIntAbs SEM (Abs xs x X) = igAbs (asIMOD SEM) xs x (semInt SEM X)\n  igAbs (asIMOD SEM) xs x (semInt SEM X) val =\n  sAbs xs\n   (\\<lambda>sX.\n       if sWls SEM (asSort xs) sX then semInt SEM X (val (x := sX)_xs)\n       else sDummy SEM s)\n\ngoal (1 subgoal):\n 1. semIntAbs SEM (Abs xs x X) val =\n    sAbs xs\n     (\\<lambda>sX.\n         if sWls SEM (asSort xs) sX then semInt SEM X (val (x := sX)_xs)\n         else sDummy SEM s)", "by simp"], ["proof (state)\nthis:\n  semIntAbs SEM (Abs xs x X) val =\n  sAbs xs\n   (\\<lambda>sX.\n       if sWls SEM (asSort xs) sX then semInt SEM X (val (x := sX)_xs)\n       else sDummy SEM s)\n\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "}"], ["proof (state)\nthis:\n  \\<lbrakk>isInBar (?xs156, ?s156); wls ?s156 ?X156;\n   sWlsVal SEM ?val156\\<rbrakk>\n  \\<Longrightarrow> semIntAbs SEM (Abs ?xs156 ?x156 ?X156) ?val156 =\n                    sAbs ?xs156\n                     (\\<lambda>sX.\n                         if sWls SEM (asSort ?xs156) sX\n                         then semInt SEM ?X156\n                               (?val156 (?x156 := sX)_?xs156)\n                         else sDummy SEM ?s156)\n\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>isInBar (?xs156, ?s156); wls ?s156 ?X156;\n   sWlsVal SEM ?val156\\<rbrakk>\n  \\<Longrightarrow> semIntAbs SEM (Abs ?xs156 ?x156 ?X156) ?val156 =\n                    sAbs ?xs156\n                     (\\<lambda>sX.\n                         if sWls SEM (asSort ?xs156) sX\n                         then semInt SEM ?X156\n                               (?val156 (?x156 := sX)_?xs156)\n                         else sDummy SEM ?s156)\n\ngoal (1 subgoal):\n 1. prAbs (semInt SEM) (semIntAbs SEM) SEM", "unfolding prAbs_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>isInBar (?xs156, ?s156); wls ?s156 ?X156;\n   sWlsVal SEM ?val156\\<rbrakk>\n  \\<Longrightarrow> semIntAbs SEM (Abs ?xs156 ?x156 ?X156) ?val156 =\n                    sAbs ?xs156\n                     (\\<lambda>sX.\n                         if sWls SEM (asSort ?xs156) sX\n                         then semInt SEM ?X156\n                               (?val156 (?x156 := sX)_?xs156)\n                         else sDummy SEM ?s156)\n\ngoal (1 subgoal):\n 1. \\<forall>xs s x X val.\n       isInBar (xs, s) \\<and>\n       wls s X \\<and> sWlsVal SEM val \\<longrightarrow>\n       semIntAbs SEM (Abs xs x X) val =\n       sAbs xs\n        (\\<lambda>sX.\n            if sWls SEM (asSort xs) sX then semInt SEM X (val (x := sX)_xs)\n            else sDummy SEM s)", "by auto"], ["proof (state)\nthis:\n  prAbs (semInt SEM) (semIntAbs SEM) SEM\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma semIntAll_prOp:\nassumes \"wlsSEM SEM\"\nshows \"prOp (semInt SEM) (semIntAbs SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prOp (semInt SEM) (semIntAbs SEM) SEM", "using assms semIntAll_termFSwSbImorph"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n  wlsSEM ?SEM \\<Longrightarrow>\n  termFSwSbImorph (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. prOp (semInt SEM) (semIntAbs SEM) SEM", "unfolding prOp_def termFSwSbImorph_def termFSwImorph_def ipresCons_def ipresOp_def\nasIMOD_igOp lift_comp comp_def"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n  wlsSEM ?SEM \\<Longrightarrow>\n  (ipresWlsAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   (ipresVar (semInt ?SEM) (asIMOD ?SEM) \\<and>\n    ipresAbs (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n    (\\<forall>delta inp binp.\n        wlsInp delta inp \\<and> wlsBinp delta binp \\<longrightarrow>\n        semInt ?SEM (Op delta inp binp) =\n        (\\<lambda>val.\n            if sWlsVal ?SEM val\n            then sOp ?SEM delta (lift (\\<lambda>x. semInt ?SEM x val) inp)\n                  (lift (\\<lambda>x. semIntAbs ?SEM x val) binp)\n            else undefined))) \\<and>\n   ipresFreshAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresSwapAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)) \\<and>\n  ipresSubstAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. \\<forall>delta inp binp val.\n       wlsInp delta inp \\<and>\n       wlsBinp delta binp \\<and> sWlsVal SEM val \\<longrightarrow>\n       semInt SEM (Op delta inp binp) val =\n       sOp SEM delta (lift (\\<lambda>X. semInt SEM X val) inp)\n        (lift (\\<lambda>A. semIntAbs SEM A val) binp)", "by fastforce"], ["", "lemma semIntAll_prCons:\nassumes \"wlsSEM SEM\"\nshows \"prCons (semInt SEM) (semIntAbs SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prCons (semInt SEM) (semIntAbs SEM) SEM", "using assms"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n\ngoal (1 subgoal):\n 1. prCons (semInt SEM) (semIntAbs SEM) SEM", "unfolding prCons_def"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n\ngoal (1 subgoal):\n 1. prVar (semInt SEM) SEM \\<and>\n    prAbs (semInt SEM) (semIntAbs SEM) SEM \\<and>\n    prOp (semInt SEM) (semIntAbs SEM) SEM", "by(simp add: semInt_prVar semIntAll_prAbs semIntAll_prOp)"], ["", "lemma semInt_prFresh:\nassumes \"wlsSEM SEM\"\nshows \"prFresh (semInt SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prFresh (semInt SEM) SEM", "using assms semIntAll_termFSwSbImorph"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n  wlsSEM ?SEM \\<Longrightarrow>\n  termFSwSbImorph (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. prFresh (semInt SEM) SEM", "unfolding prFresh_def termFSwSbImorph_def termFSwImorph_def ipresFreshAll_def ipresFresh_def\nasIMOD_igFresh"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n  wlsSEM ?SEM \\<Longrightarrow>\n  (ipresWlsAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresCons (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ((\\<forall>ys y s X.\n        wls s X \\<longrightarrow>\n        fresh ys y X \\<longrightarrow>\n        (\\<forall>val val'.\n            sWlsVal ?SEM val \\<and>\n            sWlsVal ?SEM val' \\<and> eqBut val val' ys y \\<longrightarrow>\n            semInt ?SEM X val = semInt ?SEM X val')) \\<and>\n    ipresFreshAbs (semIntAbs ?SEM) (asIMOD ?SEM)) \\<and>\n   ipresSwapAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)) \\<and>\n  ipresSubstAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. \\<forall>ys y s X val val'.\n       wls s X \\<and>\n       fresh ys y X \\<and>\n       sWlsVal SEM val \\<and>\n       sWlsVal SEM val' \\<and> eqBut val val' ys y \\<longrightarrow>\n       semInt SEM X val = semInt SEM X val'", "by fastforce"], ["", "lemma semIntAbs_prFreshAbs:\nassumes \"wlsSEM SEM\"\nshows \"prFreshAbs (semIntAbs SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prFreshAbs (semIntAbs SEM) SEM", "using assms semIntAll_termFSwSbImorph"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n  wlsSEM ?SEM \\<Longrightarrow>\n  termFSwSbImorph (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. prFreshAbs (semIntAbs SEM) SEM", "unfolding prFreshAbs_def termFSwSbImorph_def termFSwImorph_def ipresFreshAll_def ipresFreshAbs_def\nasIMOD_igFreshAbs"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n  wlsSEM ?SEM \\<Longrightarrow>\n  (ipresWlsAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresCons (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   (ipresFresh (semInt ?SEM) (asIMOD ?SEM) \\<and>\n    (\\<forall>ys y us s A.\n        wlsAbs (us, s) A \\<longrightarrow>\n        freshAbs ys y A \\<longrightarrow>\n        (\\<forall>val val'.\n            sWlsVal ?SEM val \\<and>\n            sWlsVal ?SEM val' \\<and> eqBut val val' ys y \\<longrightarrow>\n            semIntAbs ?SEM A val = semIntAbs ?SEM A val'))) \\<and>\n   ipresSwapAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)) \\<and>\n  ipresSubstAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. \\<forall>ys y us s A val val'.\n       wlsAbs (us, s) A \\<and>\n       freshAbs ys y A \\<and>\n       sWlsVal SEM val \\<and>\n       sWlsVal SEM val' \\<and> eqBut val val' ys y \\<longrightarrow>\n       semIntAbs SEM A val = semIntAbs SEM A val'", "by fastforce"], ["", "lemma semIntAll_prFreshAll:\nassumes \"wlsSEM SEM\"\nshows \"prFreshAll (semInt SEM) (semIntAbs SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prFreshAll (semInt SEM) (semIntAbs SEM) SEM", "using assms"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n\ngoal (1 subgoal):\n 1. prFreshAll (semInt SEM) (semIntAbs SEM) SEM", "unfolding prFreshAll_def"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n\ngoal (1 subgoal):\n 1. prFresh (semInt SEM) SEM \\<and> prFreshAbs (semIntAbs SEM) SEM", "by(simp add: semInt_prFresh semIntAbs_prFreshAbs)"], ["", "lemma semInt_prSwap:\nassumes \"wlsSEM SEM\"\nshows \"prSwap (semInt SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prSwap (semInt SEM) SEM", "using assms semIntAll_termFSwSbImorph"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n  wlsSEM ?SEM \\<Longrightarrow>\n  termFSwSbImorph (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. prSwap (semInt SEM) SEM", "unfolding prSwap_def termFSwSbImorph_def termFSwImorph_def ipresSwapAll_def ipresSwap_def\nasIMOD_igSwap"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n  wlsSEM ?SEM \\<Longrightarrow>\n  (ipresWlsAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresCons (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresFreshAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   (\\<forall>zs z1 z2 s X.\n       wls s X \\<longrightarrow>\n       semInt ?SEM (X #[z1 \\<and> z2]_zs) =\n       (\\<lambda>val.\n           if sWlsVal ?SEM val then semInt ?SEM X (val ^[z1 \\<and> z2]_zs)\n           else undefined)) \\<and>\n   ipresSwapAbs (semIntAbs ?SEM) (asIMOD ?SEM)) \\<and>\n  ipresSubstAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 s X val.\n       wls s X \\<and> sWlsVal SEM val \\<longrightarrow>\n       semInt SEM (X #[z1 \\<and> z2]_zs) val =\n       semInt SEM X (val ^[z1 \\<and> z2]_zs)", "by fastforce"], ["", "lemma semIntAbs_prSwapAbs:\nassumes \"wlsSEM SEM\"\nshows \"prSwapAbs (semIntAbs SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prSwapAbs (semIntAbs SEM) SEM", "using assms semIntAll_termFSwSbImorph"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n  wlsSEM ?SEM \\<Longrightarrow>\n  termFSwSbImorph (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. prSwapAbs (semIntAbs SEM) SEM", "unfolding prSwapAbs_def termFSwSbImorph_def termFSwImorph_def ipresSwapAll_def ipresSwapAbs_def\nasIMOD_igSwapAbs"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n  wlsSEM ?SEM \\<Longrightarrow>\n  (ipresWlsAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresCons (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresFreshAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresSwap (semInt ?SEM) (asIMOD ?SEM) \\<and>\n   (\\<forall>zs z1 z2 us s A.\n       wlsAbs (us, s) A \\<longrightarrow>\n       semIntAbs ?SEM (A $[z1 \\<and> z2]_zs) =\n       (\\<lambda>val.\n           if sWlsVal ?SEM val\n           then semIntAbs ?SEM A (val ^[z1 \\<and> z2]_zs)\n           else undefined))) \\<and>\n  ipresSubstAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. \\<forall>zs z1 z2 us s A val.\n       wlsAbs (us, s) A \\<and> sWlsVal SEM val \\<longrightarrow>\n       semIntAbs SEM (A $[z1 \\<and> z2]_zs) val =\n       semIntAbs SEM A (val ^[z1 \\<and> z2]_zs)", "by fastforce"], ["", "lemma semIntAll_prSwapAll:\nassumes \"wlsSEM SEM\"\nshows \"prSwapAll (semInt SEM) (semIntAbs SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prSwapAll (semInt SEM) (semIntAbs SEM) SEM", "using assms"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n\ngoal (1 subgoal):\n 1. prSwapAll (semInt SEM) (semIntAbs SEM) SEM", "unfolding prSwapAll_def"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n\ngoal (1 subgoal):\n 1. prSwap (semInt SEM) SEM \\<and> prSwapAbs (semIntAbs SEM) SEM", "by(simp add: semInt_prSwap semIntAbs_prSwapAbs)"], ["", "lemma semInt_prSubst:\nassumes \"wlsSEM SEM\"\nshows \"prSubst (semInt SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prSubst (semInt SEM) SEM", "using assms semIntAll_termFSwSbImorph"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n  wlsSEM ?SEM \\<Longrightarrow>\n  termFSwSbImorph (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. prSubst (semInt SEM) SEM", "unfolding prSubst_def termFSwSbImorph_def termFSwImorph_def ipresSubstAll_def ipresSubst_def\nasIMOD_igSubst"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n  wlsSEM ?SEM \\<Longrightarrow>\n  (ipresWlsAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresCons (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresFreshAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresSwapAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)) \\<and>\n  (\\<forall>ys Y y s X.\n      wls (asSort ys) Y \\<and> wls s X \\<longrightarrow>\n      semInt ?SEM (X #[Y / y]_ys) =\n      (\\<lambda>val.\n          if sWlsVal ?SEM val\n          then semInt ?SEM X (val (y := semInt ?SEM Y val)_ys)\n          else undefined)) \\<and>\n  ipresSubstAbs (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. \\<forall>ys Y y s X val.\n       wls (asSort ys) Y \\<and>\n       wls s X \\<and> sWlsVal SEM val \\<longrightarrow>\n       semInt SEM (X #[Y / y]_ys) val =\n       semInt SEM X (val (y := semInt SEM Y val)_ys)", "by fastforce"], ["", "lemma semIntAbs_prSubstAbs:\nassumes \"wlsSEM SEM\"\nshows \"prSubstAbs (semInt SEM) (semIntAbs SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prSubstAbs (semInt SEM) (semIntAbs SEM) SEM", "using assms semIntAll_termFSwSbImorph"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n  wlsSEM ?SEM \\<Longrightarrow>\n  termFSwSbImorph (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)\n\ngoal (1 subgoal):\n 1. prSubstAbs (semInt SEM) (semIntAbs SEM) SEM", "unfolding prSubstAbs_def termFSwSbImorph_def termFSwImorph_def ipresSubstAll_def ipresSubstAbs_def\nasIMOD_igSubstAbs"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n  wlsSEM ?SEM \\<Longrightarrow>\n  (ipresWlsAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresCons (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresFreshAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM) \\<and>\n   ipresSwapAll (semInt ?SEM) (semIntAbs ?SEM) (asIMOD ?SEM)) \\<and>\n  ipresSubst (semInt ?SEM) (asIMOD ?SEM) \\<and>\n  (\\<forall>ys Y y us s A.\n      wls (asSort ys) Y \\<and> wlsAbs (us, s) A \\<longrightarrow>\n      semIntAbs ?SEM (A $[Y / y]_ys) =\n      (\\<lambda>val.\n          if sWlsVal ?SEM val\n          then semIntAbs ?SEM A (val (y := semInt ?SEM Y val)_ys)\n          else undefined))\n\ngoal (1 subgoal):\n 1. \\<forall>ys Y y us s A val.\n       wls (asSort ys) Y \\<and>\n       wlsAbs (us, s) A \\<and> sWlsVal SEM val \\<longrightarrow>\n       semIntAbs SEM (A $[Y / y]_ys) val =\n       semIntAbs SEM A (val (y := semInt SEM Y val)_ys)", "by fastforce"], ["", "lemma semIntAll_prSubstAll:\nassumes \"wlsSEM SEM\"\nshows \"prSubstAll (semInt SEM) (semIntAbs SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prSubstAll (semInt SEM) (semIntAbs SEM) SEM", "using assms"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n\ngoal (1 subgoal):\n 1. prSubstAll (semInt SEM) (semIntAbs SEM) SEM", "unfolding prSubstAll_def"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n\ngoal (1 subgoal):\n 1. prSubst (semInt SEM) SEM \\<and>\n    prSubstAbs (semInt SEM) (semIntAbs SEM) SEM", "by(simp add: semInt_prSubst semIntAbs_prSubstAbs)"], ["", "theorem semIntAll_compInt:\nassumes \"wlsSEM SEM\"\nshows \"compInt (semInt SEM) (semIntAbs SEM) SEM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compInt (semInt SEM) (semIntAbs SEM) SEM", "using assms"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n\ngoal (1 subgoal):\n 1. compInt (semInt SEM) (semIntAbs SEM) SEM", "unfolding compInt_def"], ["proof (prove)\nusing this:\n  wlsSEM SEM\n\ngoal (1 subgoal):\n 1. prWlsAll (semInt SEM) (semIntAbs SEM) SEM \\<and>\n    prCons (semInt SEM) (semIntAbs SEM) SEM \\<and>\n    prFreshAll (semInt SEM) (semIntAbs SEM) SEM \\<and>\n    prSwapAll (semInt SEM) (semIntAbs SEM) SEM \\<and>\n    prSubstAll (semInt SEM) (semIntAbs SEM) SEM", "by(simp add: semIntAll_prWlsAll semIntAll_prCons\nsemIntAll_prFreshAll semIntAll_prSwapAll semIntAll_prSubstAll)"], ["", "lemmas semDom_simps = updVal_simps swapVal_simps"], ["", "end"], ["", "(* context FixSyn *)"], ["", "end"]]}