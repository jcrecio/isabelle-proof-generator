{"file_name": "/home/qj213/afp-2021-10-22/thys/POPLmark-deBruijn/Execute.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/POPLmark-deBruijn", "problem_names": ["lemma [code_pred_intro Rcd_Nil]: \"valuep (Rcd [])\"", "lemma [code_pred_intro Rcd_Cons]: \"valuep t \\<Longrightarrow> valuep (Rcd fs) \\<Longrightarrow> valuep (Rcd ((l, t) # fs))\"", "lemmas valuep.intros(1)[code_pred_intro Abs'] valuep.intros(2)[code_pred_intro TAbs']", "lemma [code]:\n  \"normal_forms = set_of_pred o normalize\"", "lemma [code_unfold]: \"x \\<in> value \\<longleftrightarrow> valuep x\""], "translations": [["", "lemma [code_pred_intro Rcd_Nil]: \"valuep (Rcd [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuep (Rcd [])", "by (auto intro: valuep.intros)"], ["", "lemma [code_pred_intro Rcd_Cons]: \"valuep t \\<Longrightarrow> valuep (Rcd fs) \\<Longrightarrow> valuep (Rcd ((l, t) # fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valuep t; valuep (Rcd fs)\\<rbrakk>\n    \\<Longrightarrow> valuep (Rcd ((l, t) \\<Colon> fs))", "by (auto intro!: valuep.intros elim!: valuep.cases)"], ["", "lemmas valuep.intros(1)[code_pred_intro Abs'] valuep.intros(2)[code_pred_intro TAbs']"], ["", "code_pred (modes: i => bool) valuep"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valuep x; x = Rcd [] \\<Longrightarrow> thesis;\n     \\<And>l_ t_ fs_.\n        \\<lbrakk>x = Rcd ((l_, t_) \\<Colon> fs_); valuep t_;\n         valuep (Rcd fs_)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>T_ t_. x = (\\<lambda>:T_. t_) \\<Longrightarrow> thesis;\n     \\<And>T_ t_. x = (\\<lambda><:T_. t_) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>valuep x; x = Rcd [] \\<Longrightarrow> thesis;\n     \\<And>l_ t_ fs_.\n        \\<lbrakk>x = Rcd ((l_, t_) \\<Colon> fs_); valuep t_;\n         valuep (Rcd fs_)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>T_ t_. x = (\\<lambda>:T_. t_) \\<Longrightarrow> thesis;\n     \\<And>T_ t_. x = (\\<lambda><:T_. t_) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "case valuep"], ["proof (state)\nthis:\n  x = Rcd [] \\<Longrightarrow> thesis\n  \\<lbrakk>x = Rcd ((?l, ?t) \\<Colon> ?fs); valuep ?t;\n   valuep (Rcd ?fs)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  x = (\\<lambda>:?T. ?t) \\<Longrightarrow> thesis\n  x = (\\<lambda><:?T. ?t) \\<Longrightarrow> thesis\n  valuep x\n  x = Rcd [] \\<Longrightarrow> thesis\n  \\<lbrakk>x = Rcd ((?l, ?t) \\<Colon> ?fs); valuep ?t;\n   valuep (Rcd ?fs)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  x = (\\<lambda>:?T. ?t) \\<Longrightarrow> thesis\n  x = (\\<lambda><:?T. ?t) \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valuep x; x = Rcd [] \\<Longrightarrow> thesis;\n     \\<And>l_ t_ fs_.\n        \\<lbrakk>x = Rcd ((l_, t_) \\<Colon> fs_); valuep t_;\n         valuep (Rcd fs_)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>T_ t_. x = (\\<lambda>:T_. t_) \\<Longrightarrow> thesis;\n     \\<And>T_ t_. x = (\\<lambda><:T_. t_) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "from valuep.prems"], ["proof (chain)\npicking this:\n  valuep x", "show thesis"], ["proof (prove)\nusing this:\n  valuep x\n\ngoal (1 subgoal):\n 1. thesis", "proof (cases rule: valuep.cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>T t. x = (\\<lambda>:T. t) \\<Longrightarrow> thesis\n 2. \\<And>T t. x = (\\<lambda><:T. t) \\<Longrightarrow> thesis\n 3. \\<And>fs.\n       \\<lbrakk>x = Rcd fs; \\<forall>(l, t)\\<in>set fs. valuep t\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Rcd fs)"], ["proof (state)\nthis:\n  x = Rcd fs\n  \\<forall>(l, t)\\<in>set fs. valuep t\n\ngoal (3 subgoals):\n 1. \\<And>T t. x = (\\<lambda>:T. t) \\<Longrightarrow> thesis\n 2. \\<And>T t. x = (\\<lambda><:T. t) \\<Longrightarrow> thesis\n 3. \\<And>fs.\n       \\<lbrakk>x = Rcd fs; \\<forall>(l, t)\\<in>set fs. valuep t\\<rbrakk>\n       \\<Longrightarrow> thesis", "from this valuep.Rcd_Nil valuep.Rcd_Cons"], ["proof (chain)\npicking this:\n  x = Rcd fs\n  \\<forall>(l, t)\\<in>set fs. valuep t\n  x = Rcd [] \\<Longrightarrow> thesis\n  \\<lbrakk>x = Rcd ((?l, ?t) \\<Colon> ?fs); valuep ?t;\n   valuep (Rcd ?fs)\\<rbrakk>\n  \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\nusing this:\n  x = Rcd fs\n  \\<forall>(l, t)\\<in>set fs. valuep t\n  x = Rcd [] \\<Longrightarrow> thesis\n  \\<lbrakk>x = Rcd ((?l, ?t) \\<Colon> ?fs); valuep ?t;\n   valuep (Rcd ?fs)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (cases fs) (auto intro: valuep.intros)"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>T t. x = (\\<lambda>:T. t) \\<Longrightarrow> thesis\n 2. \\<And>T t. x = (\\<lambda><:T. t) \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T t. x = (\\<lambda>:T. t) \\<Longrightarrow> thesis\n 2. \\<And>T t. x = (\\<lambda><:T. t) \\<Longrightarrow> thesis", "case Abs"], ["proof (state)\nthis:\n  x = (\\<lambda>:T_. t_)\n\ngoal (2 subgoals):\n 1. \\<And>T t. x = (\\<lambda>:T. t) \\<Longrightarrow> thesis\n 2. \\<And>T t. x = (\\<lambda><:T. t) \\<Longrightarrow> thesis", "with valuep.Abs'"], ["proof (chain)\npicking this:\n  x = (\\<lambda>:?T. ?t) \\<Longrightarrow> thesis\n  x = (\\<lambda>:T_. t_)", "show thesis"], ["proof (prove)\nusing this:\n  x = (\\<lambda>:?T. ?t) \\<Longrightarrow> thesis\n  x = (\\<lambda>:T_. t_)\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>T t. x = (\\<lambda><:T. t) \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T t. x = (\\<lambda><:T. t) \\<Longrightarrow> thesis", "case TAbs"], ["proof (state)\nthis:\n  x = (\\<lambda><:T_. t_)\n\ngoal (1 subgoal):\n 1. \\<And>T t. x = (\\<lambda><:T. t) \\<Longrightarrow> thesis", "with valuep.TAbs'"], ["proof (chain)\npicking this:\n  x = (\\<lambda><:?T. ?t) \\<Longrightarrow> thesis\n  x = (\\<lambda><:T_. t_)", "show thesis"], ["proof (prove)\nusing this:\n  x = (\\<lambda><:?T. ?t) \\<Longrightarrow> thesis\n  x = (\\<lambda><:T_. t_)\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "thm valuep.equation"], ["", "code_pred (modes: i => i => bool, i => o => bool as normalize) norm"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "thm norm.equation"], ["", "lemma [code]:\n  \"normal_forms = set_of_pred o normalize\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal_forms = set_of_pred \\<circ> Execute.normalize", "unfolding set_of_pred_def o_def normal_forms_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. {u. t \\<Down> u}) =\n    (\\<lambda>x. Collect (pred.eval (Execute.normalize x)))", "by (auto intro: set_eqI normalizeI elim: normalizeE)"], ["", "lemma [code_unfold]: \"x \\<in> value \\<longleftrightarrow> valuep x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> value) = valuep x", "by (simp add: value_def)"], ["", "definition\n  natT :: type where\n  \"natT \\<equiv> \\<forall><:Top. (\\<forall><:TVar 0. (\\<forall><:TVar 1. (TVar 2 \\<rightarrow> TVar 1) \\<rightarrow> TVar 0 \\<rightarrow> TVar 1))\""], ["", "definition\n  fact2 :: trm where\n  \"fact2 \\<equiv>\n   LET PVar natT =\n     (\\<lambda><:Top. \\<lambda><:TVar 0. \\<lambda><:TVar 1. \\<lambda>:TVar 2 \\<rightarrow> TVar 1. \\<lambda>: TVar 1. Var 1 \\<bullet> Var 0)\n   IN\n   LET PRcd\n     [(''pluspp'', PVar (natT \\<rightarrow> natT \\<rightarrow> natT)),\n      (''multpp'', PVar (natT \\<rightarrow> natT \\<rightarrow> natT))] = Rcd\n     [(''multpp'', \\<lambda>:natT. \\<lambda>:natT. \\<lambda><:Top. \\<lambda><:TVar 0. \\<lambda><:TVar 1. \\<lambda>:TVar 2 \\<rightarrow> TVar 1.\n        Var 5 \\<bullet>\\<^sub>\\<tau> TVar 3 \\<bullet>\\<^sub>\\<tau> TVar 2 \\<bullet>\\<^sub>\\<tau> TVar 1 \\<bullet> (Var 4 \\<bullet>\\<^sub>\\<tau> TVar 3 \\<bullet>\\<^sub>\\<tau> TVar 2 \\<bullet>\\<^sub>\\<tau> TVar 1) \\<bullet> Var 0),\n      (''pluspp'', \\<lambda>:natT. \\<lambda>:natT. \\<lambda><:Top. \\<lambda><:TVar 0. \\<lambda><:TVar 1. \\<lambda>:TVar 2 \\<rightarrow> TVar 1. \\<lambda>:TVar 1.\n        Var 6 \\<bullet>\\<^sub>\\<tau> TVar 4 \\<bullet>\\<^sub>\\<tau> TVar 3 \\<bullet>\\<^sub>\\<tau> TVar 3 \\<bullet> Var 1 \\<bullet>\n          (Var 5 \\<bullet>\\<^sub>\\<tau> TVar 4 \\<bullet>\\<^sub>\\<tau> TVar 3 \\<bullet>\\<^sub>\\<tau> TVar 2 \\<bullet> Var 1 \\<bullet> Var 0))]\n   IN\n     Var 0 \\<bullet> (Var 1 \\<bullet> Var 2 \\<bullet> Var 2) \\<bullet> Var 2\""], ["", "value \"normal_forms fact2\""], ["", "text \\<open>\nUnfortunately, the definition based\non evaluation contexts from \\secref{sec:evaluation-ctxt} is not directly executable.\nThe reason is that from the definition of evaluation contexts, the code generator\ncannot immediately read off an algorithm that, given a term \\<open>t\\<close>, computes a context\n\\<open>E\\<close> and a term \\<open>t\\<^sub>0\\<close> such that \\<open>t = E t\\<^sub>0\\<close>. In order to do this, one\nwould have to extract the algorithm contained in the proof of the {\\it decomposition lemma}\nfrom \\secref{sec:evaluation-ctxt}.\n\\<close>"], ["", "values \"{u. norm fact2 u}\""], ["", "end"]]}