{"file_name": "/home/qj213/afp-2021-10-22/thys/POPLmark-deBruijn/Basis.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/POPLmark-deBruijn", "problem_names": ["lemma True_simps:\n  \"(True \\<Longrightarrow> PROP P) \\<equiv> PROP P\"\n  \"(PROP P \\<Longrightarrow> True) \\<equiv> PROP Trueprop True\"\n  \"(\\<And>x. True) \\<equiv> PROP Trueprop True\"", "lemma ballpI: \"(\\<And>x y. (x, y) \\<in> A \\<Longrightarrow> P x y) \\<Longrightarrow> \\<forall>(x, y) \\<in> A. P x y\"", "lemma bpspec: \"\\<forall>(x, y) \\<in> A. P x y \\<Longrightarrow> (x, y) \\<in> A \\<Longrightarrow> P x y\"", "lemma ballpE: \"\\<forall>(x, y) \\<in> A. P x y \\<Longrightarrow> (P x y \\<Longrightarrow> Q) \\<Longrightarrow>\n  ((x, y) \\<notin> A \\<Longrightarrow> Q) \\<Longrightarrow> Q\"", "lemma bexpI: \"P x y \\<Longrightarrow> (x, y) \\<in> A \\<Longrightarrow> \\<exists>(x, y) \\<in> A. P x y\"", "lemma bexpE: \"\\<exists>(x, y) \\<in> A. P x y \\<Longrightarrow>\n  (\\<And>x y. (x, y) \\<in> A \\<Longrightarrow> P x y \\<Longrightarrow> Q) \\<Longrightarrow> Q\"", "lemma ball_eq_sym: \"\\<forall>(x, y) \\<in> S. f x y = g x y \\<Longrightarrow> \\<forall>(x, y) \\<in> S. g x y = f x y\"", "lemma wf_measure_size: \"wf (measure size)\"", "lemma [simp]: \"i < \\<parallel>xs\\<parallel> \\<Longrightarrow> (xs @ ys)\\<langle>i\\<rangle> = xs\\<langle>i\\<rangle>\"", "lemma [simp]: \"\\<parallel>xs\\<parallel> \\<le> i \\<Longrightarrow> (xs @ ys)\\<langle>i\\<rangle> = ys\\<langle>i - \\<parallel>xs\\<parallel>\\<rangle>\"", "lemma assoc_set: \"ps\\<langle>x\\<rangle>\\<^sub>? = \\<lfloor>y\\<rfloor> \\<Longrightarrow> (x, y) \\<in> set ps\"", "lemma map_assoc_None [simp]:\n  \"ps\\<langle>x\\<rangle>\\<^sub>? = \\<bottom> \\<Longrightarrow> map (\\<lambda>(x, y). (x, f x y)) ps\\<langle>x\\<rangle>\\<^sub>? = \\<bottom>\""], "translations": [["", "lemma True_simps:\n  \"(True \\<Longrightarrow> PROP P) \\<equiv> PROP P\"\n  \"(PROP P \\<Longrightarrow> True) \\<equiv> PROP Trueprop True\"\n  \"(\\<And>x. True) \\<equiv> PROP Trueprop True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((True \\<Longrightarrow> PROP P) \\<equiv> PROP P) &&&\n    ((PROP P \\<Longrightarrow> True) \\<equiv> True) &&&\n    (\\<And>x. True) \\<equiv> True", "apply -"], ["proof (prove)\ngoal (3 subgoals):\n 1. (True \\<Longrightarrow> PROP P) \\<equiv> PROP P\n 2. (PROP P \\<Longrightarrow> True) \\<equiv> True\n 3. (\\<And>x. True) \\<equiv> True", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. (True \\<Longrightarrow> PROP P) \\<Longrightarrow> PROP P\n 2. \\<lbrakk>PROP P; True\\<rbrakk> \\<Longrightarrow> PROP P\n 3. (PROP P \\<Longrightarrow> True) \\<equiv> True\n 4. (\\<And>x. True) \\<equiv> True", "apply (erule meta_mp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. True\n 2. \\<lbrakk>PROP P; True\\<rbrakk> \\<Longrightarrow> PROP P\n 3. (PROP P \\<Longrightarrow> True) \\<equiv> True\n 4. (\\<And>x. True) \\<equiv> True", "apply (rule TrueI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>PROP P; True\\<rbrakk> \\<Longrightarrow> PROP P\n 2. (PROP P \\<Longrightarrow> True) \\<equiv> True\n 3. (\\<And>x. True) \\<equiv> True", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. (PROP P \\<Longrightarrow> True) \\<equiv> True\n 2. (\\<And>x. True) \\<equiv> True", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. (PROP P \\<Longrightarrow> True) \\<Longrightarrow> True\n 2. \\<lbrakk>True; PROP P\\<rbrakk> \\<Longrightarrow> True\n 3. (\\<And>x. True) \\<equiv> True", "apply (rule TrueI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>True; PROP P\\<rbrakk> \\<Longrightarrow> True\n 2. (\\<And>x. True) \\<equiv> True", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. True) \\<equiv> True", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>x. True) \\<Longrightarrow> True\n 2. \\<And>x. True \\<Longrightarrow> True", "apply (rule TrueI)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\nUnfortunately, the standard introduction and elimination rules for bounded\nuniversal and existential quantifier do not work properly for sets of pairs.\n\\<close>"], ["", "lemma ballpI: \"(\\<And>x y. (x, y) \\<in> A \\<Longrightarrow> P x y) \\<Longrightarrow> \\<forall>(x, y) \\<in> A. P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. (x, y) \\<in> A \\<Longrightarrow> P x y) \\<Longrightarrow>\n    \\<forall>(x, y)\\<in>A. P x y", "by blast"], ["", "lemma bpspec: \"\\<forall>(x, y) \\<in> A. P x y \\<Longrightarrow> (x, y) \\<in> A \\<Longrightarrow> P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(x, y)\\<in>A. P x y; (x, y) \\<in> A\\<rbrakk>\n    \\<Longrightarrow> P x y", "by blast"], ["", "lemma ballpE: \"\\<forall>(x, y) \\<in> A. P x y \\<Longrightarrow> (P x y \\<Longrightarrow> Q) \\<Longrightarrow>\n  ((x, y) \\<notin> A \\<Longrightarrow> Q) \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(x, y)\\<in>A. P x y; P x y \\<Longrightarrow> Q;\n     (x, y) \\<notin> A \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by blast"], ["", "lemma bexpI: \"P x y \\<Longrightarrow> (x, y) \\<in> A \\<Longrightarrow> \\<exists>(x, y) \\<in> A. P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P x y; (x, y) \\<in> A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(x, y)\\<in>A. P x y", "by blast"], ["", "lemma bexpE: \"\\<exists>(x, y) \\<in> A. P x y \\<Longrightarrow>\n  (\\<And>x y. (x, y) \\<in> A \\<Longrightarrow> P x y \\<Longrightarrow> Q) \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>(x, y)\\<in>A. P x y;\n     \\<And>x y.\n        \\<lbrakk>(x, y) \\<in> A; P x y\\<rbrakk> \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by blast"], ["", "lemma ball_eq_sym: \"\\<forall>(x, y) \\<in> S. f x y = g x y \\<Longrightarrow> \\<forall>(x, y) \\<in> S. g x y = f x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(x, y)\\<in>S. f x y = g x y \\<Longrightarrow>\n    \\<forall>(x, y)\\<in>S. g x y = f x y", "by auto"], ["", "lemma wf_measure_size: \"wf (measure size)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure size)", "by simp"], ["", "notation\n  Some (\"\\<lfloor>_\\<rfloor>\")"], ["", "notation\n  None (\"\\<bottom>\")"], ["", "notation\n  length (\"\\<parallel>_\\<parallel>\")"], ["", "notation\n  Cons (\"_ \\<Colon>/ _\" [66, 65] 65)"], ["", "text \\<open>\nThe following variant of the standard \\<open>nth\\<close> function returns\n\\<open>\\<bottom>\\<close> if the index is out of range.\n\\<close>"], ["", "primrec\n  nth_el :: \"'a list \\<Rightarrow> nat \\<Rightarrow> 'a option\" (\"_\\<langle>_\\<rangle>\" [90, 0] 91)\nwhere\n  \"[]\\<langle>i\\<rangle> = \\<bottom>\"\n| \"(x # xs)\\<langle>i\\<rangle> = (case i of 0 \\<Rightarrow> \\<lfloor>x\\<rfloor> | Suc j \\<Rightarrow> xs \\<langle>j\\<rangle>)\""], ["", "lemma [simp]: \"i < \\<parallel>xs\\<parallel> \\<Longrightarrow> (xs @ ys)\\<langle>i\\<rangle> = xs\\<langle>i\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < \\<parallel>xs\\<parallel> \\<Longrightarrow>\n    (xs @ ys)\\<langle>i\\<rangle> = xs\\<langle>i\\<rangle>", "apply (induct xs arbitrary: i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < \\<parallel>[]\\<parallel> \\<Longrightarrow>\n       ([] @ ys)\\<langle>i\\<rangle> = []\\<langle>i\\<rangle>\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < \\<parallel>xs\\<parallel> \\<Longrightarrow>\n                   (xs @ ys)\\<langle>i\\<rangle> = xs\\<langle>i\\<rangle>;\n        i < \\<parallel>a \\<Colon> xs\\<parallel>\\<rbrakk>\n       \\<Longrightarrow> ((a \\<Colon> xs) @ ys)\\<langle>i\\<rangle> =\n                         (a \\<Colon> xs)\\<langle>i\\<rangle>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < \\<parallel>xs\\<parallel> \\<Longrightarrow>\n                   (xs @ ys)\\<langle>i\\<rangle> = xs\\<langle>i\\<rangle>;\n        i < \\<parallel>a \\<Colon> xs\\<parallel>\\<rbrakk>\n       \\<Longrightarrow> ((a \\<Colon> xs) @ ys)\\<langle>i\\<rangle> =\n                         (a \\<Colon> xs)\\<langle>i\\<rangle>", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < \\<parallel>xs\\<parallel> \\<Longrightarrow>\n                   (xs @ ys)\\<langle>i\\<rangle> = xs\\<langle>i\\<rangle>;\n        i < \\<parallel>a \\<Colon> xs\\<parallel>; i = 0\\<rbrakk>\n       \\<Longrightarrow> ((a \\<Colon> xs) @ ys)\\<langle>i\\<rangle> =\n                         (a \\<Colon> xs)\\<langle>i\\<rangle>\n 2. \\<And>a xs i nat.\n       \\<lbrakk>\\<And>i.\n                   i < \\<parallel>xs\\<parallel> \\<Longrightarrow>\n                   (xs @ ys)\\<langle>i\\<rangle> = xs\\<langle>i\\<rangle>;\n        i < \\<parallel>a \\<Colon> xs\\<parallel>; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> ((a \\<Colon> xs) @ ys)\\<langle>i\\<rangle> =\n                         (a \\<Colon> xs)\\<langle>i\\<rangle>", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]: \"\\<parallel>xs\\<parallel> \\<le> i \\<Longrightarrow> (xs @ ys)\\<langle>i\\<rangle> = ys\\<langle>i - \\<parallel>xs\\<parallel>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>xs\\<parallel> \\<le> i \\<Longrightarrow>\n    (xs @ ys)\\<langle>i\\<rangle> =\n    ys\\<langle>i - \\<parallel>xs\\<parallel>\\<rangle>", "apply (induct xs arbitrary: i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<parallel>[]\\<parallel> \\<le> i \\<Longrightarrow>\n       ([] @ ys)\\<langle>i\\<rangle> =\n       ys\\<langle>i - \\<parallel>[]\\<parallel>\\<rangle>\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<parallel>xs\\<parallel> \\<le> i \\<Longrightarrow>\n                   (xs @ ys)\\<langle>i\\<rangle> =\n                   ys\\<langle>i - \\<parallel>xs\\<parallel>\\<rangle>;\n        \\<parallel>a \\<Colon> xs\\<parallel> \\<le> i\\<rbrakk>\n       \\<Longrightarrow> ((a \\<Colon> xs) @ ys)\\<langle>i\\<rangle> =\n                         ys\\<langle>i - \\<parallel>a \\<Colon>\n                                    xs\\<parallel>\\<rangle>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<parallel>xs\\<parallel> \\<le> i \\<Longrightarrow>\n                   (xs @ ys)\\<langle>i\\<rangle> =\n                   ys\\<langle>i - \\<parallel>xs\\<parallel>\\<rangle>;\n        \\<parallel>a \\<Colon> xs\\<parallel> \\<le> i\\<rbrakk>\n       \\<Longrightarrow> ((a \\<Colon> xs) @ ys)\\<langle>i\\<rangle> =\n                         ys\\<langle>i - \\<parallel>a \\<Colon>\n                                    xs\\<parallel>\\<rangle>", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<parallel>xs\\<parallel> \\<le> i \\<Longrightarrow>\n                   (xs @ ys)\\<langle>i\\<rangle> =\n                   ys\\<langle>i - \\<parallel>xs\\<parallel>\\<rangle>;\n        \\<parallel>a \\<Colon> xs\\<parallel> \\<le> i; i = 0\\<rbrakk>\n       \\<Longrightarrow> ((a \\<Colon> xs) @ ys)\\<langle>i\\<rangle> =\n                         ys\\<langle>i - \\<parallel>a \\<Colon>\n                                    xs\\<parallel>\\<rangle>\n 2. \\<And>a xs i nat.\n       \\<lbrakk>\\<And>i.\n                   \\<parallel>xs\\<parallel> \\<le> i \\<Longrightarrow>\n                   (xs @ ys)\\<langle>i\\<rangle> =\n                   ys\\<langle>i - \\<parallel>xs\\<parallel>\\<rangle>;\n        \\<parallel>a \\<Colon> xs\\<parallel> \\<le> i; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> ((a \\<Colon> xs) @ ys)\\<langle>i\\<rangle> =\n                         ys\\<langle>i - \\<parallel>a \\<Colon>\n                                    xs\\<parallel>\\<rangle>", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Association lists\\<close>"], ["", "primrec assoc :: \"('a \\<times> 'b) list \\<Rightarrow> 'a \\<Rightarrow> 'b option\" (\"_\\<langle>_\\<rangle>\\<^sub>?\" [90, 0] 91)\nwhere\n  \"[]\\<langle>a\\<rangle>\\<^sub>? = \\<bottom>\"\n| \"(x # xs)\\<langle>a\\<rangle>\\<^sub>? = (if fst x = a then \\<lfloor>snd x\\<rfloor> else xs\\<langle>a\\<rangle>\\<^sub>?)\""], ["", "primrec unique :: \"('a \\<times> 'b) list \\<Rightarrow> bool\"\nwhere\n  \"unique [] = True\"\n| \"unique (x # xs) = (xs\\<langle>fst x\\<rangle>\\<^sub>? = \\<bottom> \\<and> unique xs)\""], ["", "lemma assoc_set: \"ps\\<langle>x\\<rangle>\\<^sub>? = \\<lfloor>y\\<rfloor> \\<Longrightarrow> (x, y) \\<in> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps\\<langle>x\\<rangle>\\<^sub>? = \\<lfloor>y\\<rfloor> \\<Longrightarrow>\n    (x, y) \\<in> set ps", "by (induct ps) (auto split: if_split_asm)"], ["", "lemma map_assoc_None [simp]:\n  \"ps\\<langle>x\\<rangle>\\<^sub>? = \\<bottom> \\<Longrightarrow> map (\\<lambda>(x, y). (x, f x y)) ps\\<langle>x\\<rangle>\\<^sub>? = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps\\<langle>x\\<rangle>\\<^sub>? = \\<bottom> \\<Longrightarrow>\n    map (\\<lambda>(x, y). (x, f x y)) ps\\<langle>x\\<rangle>\\<^sub>? =\n    \\<bottom>", "by (induct ps) auto"], ["", "no_syntax\n  \"_Map\" :: \"maplets => 'a \\<rightharpoonup> 'b\"  (\"(1[_])\")"], ["", "end"]]}