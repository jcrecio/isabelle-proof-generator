{"file_name": "/home/qj213/afp-2021-10-22/thys/AWN/AWN_SOS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/AWN", "problem_names": ["lemma seqp_broadcastTE [elim]:\n  \"\\<lbrakk>((\\<xi>, {l}broadcast(s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>;\n    \\<lbrakk>a = broadcast (s\\<^sub>m\\<^sub>s\\<^sub>g \\<xi>); \\<xi>' = \\<xi>; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma seqp_groupcastTE [elim]:\n  \"\\<lbrakk>((\\<xi>, {l}groupcast(s\\<^sub>i\\<^sub>p\\<^sub>s, s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>;\n    \\<lbrakk>a = groupcast (s\\<^sub>i\\<^sub>p\\<^sub>s \\<xi>) (s\\<^sub>m\\<^sub>s\\<^sub>g \\<xi>); \\<xi>' = \\<xi>; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma seqp_unicastTE [elim]:\n  \"\\<lbrakk>((\\<xi>, {l}unicast(s\\<^sub>i\\<^sub>p, s\\<^sub>m\\<^sub>s\\<^sub>g). p \\<triangleright> q), a, (\\<xi>', r)) \\<in> seqp_sos \\<Gamma>;\n    \\<lbrakk>a = unicast (s\\<^sub>i\\<^sub>p \\<xi>) (s\\<^sub>m\\<^sub>s\\<^sub>g \\<xi>); \\<xi>' = \\<xi>; r = p\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>a = \\<not>unicast (s\\<^sub>i\\<^sub>p \\<xi>); \\<xi>' = \\<xi>; r = q\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma seqp_sendTE [elim]:\n  \"\\<lbrakk>((\\<xi>, {l}send(s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>;\n    \\<lbrakk>a = send (s\\<^sub>m\\<^sub>s\\<^sub>g \\<xi>); \\<xi>' = \\<xi>; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma seqp_deliverTE [elim]:\n  \"\\<lbrakk>((\\<xi>, {l}deliver(s\\<^sub>d\\<^sub>a\\<^sub>t\\<^sub>a). p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>;\n    \\<lbrakk>a = deliver (s\\<^sub>d\\<^sub>a\\<^sub>t\\<^sub>a \\<xi>); \\<xi>' = \\<xi>; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma seqp_receiveTE [elim]:\n  \"\\<lbrakk>((\\<xi>, {l}receive(u\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>;\n    \\<And>msg. \\<lbrakk>a = receive msg; \\<xi>' = u\\<^sub>m\\<^sub>s\\<^sub>g msg \\<xi>; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma seqp_assignTE [elim]:\n  \"\\<lbrakk>((\\<xi>, {l}\\<lbrakk>u\\<rbrakk> p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>; \\<lbrakk>a = \\<tau>; \\<xi>' = u \\<xi>; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma seqp_guardTE [elim]:\n  \"\\<lbrakk>((\\<xi>, {l}\\<langle>g\\<rangle> p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>; \\<lbrakk>a = \\<tau>; \\<xi>' \\<in> g \\<xi>; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemmas seqpTEs =\n  seqp_broadcastTE\n  seqp_groupcastTE\n  seqp_unicastTE\n  seqp_sendTE\n  seqp_deliverTE\n  seqp_receiveTE\n  seqp_assignTE\n  seqp_callTE\n  seqp_choiceTE\n  seqp_guardTE", "lemma par_broadcastTE [elim]:\n  \"\\<lbrakk>((s, t), broadcast m, (s', t')) \\<in> parp_sos S T;\n    \\<lbrakk>(s, broadcast m, s') \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, broadcast m, t') \\<in> T; s' = s\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma par_groupcastTE [elim]:\n  \"\\<lbrakk>((s, t), groupcast ips m, (s', t')) \\<in> parp_sos S T;\n    \\<lbrakk>(s, groupcast ips m, s') \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, groupcast ips m, t') \\<in> T; s' = s\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma par_unicastTE [elim]:\n  \"\\<lbrakk>((s, t), unicast i m, (s', t')) \\<in> parp_sos S T;\n    \\<lbrakk>(s, unicast i m, s') \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, unicast i m, t') \\<in> T; s' = s\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma par_notunicastTE [elim]:\n  \"\\<lbrakk>((s, t), notunicast i, (s', t')) \\<in> parp_sos S T;\n    \\<lbrakk>(s, notunicast i, s') \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, notunicast i, t') \\<in> T; s' = s\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma par_sendTE [elim]:\n  \"\\<lbrakk>((s, t), send m, (s', t')) \\<in> parp_sos S T;\n    \\<lbrakk>(s, send m, s') \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma par_deliverTE [elim]:\n  \"\\<lbrakk>((s, t), deliver d, (s', t')) \\<in> parp_sos S T;\n    \\<lbrakk>(s, deliver d, s') \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, deliver d, t') \\<in> T; s' = s\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma par_receiveTE [elim]:\n  \"\\<lbrakk>((s, t), receive m, (s', t')) \\<in> parp_sos S T;\n    \\<lbrakk>(t, receive m, t') \\<in> T; s' = s\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemmas parpTEs =\n  par_broadcastTE\n  par_groupcastTE\n  par_unicastTE\n  par_notunicastTE\n  par_sendTE\n  par_deliverTE\n  par_receiveTE", "lemma parp_sos_cases [elim]:\n  assumes \"((s, t), a, (s', t')) \\<in> parp_sos S T\"\n      and \"\\<lbrakk> (s, a, s') \\<in> S; \\<And>m. a \\<noteq> receive m; t' = t \\<rbrakk> \\<Longrightarrow> P\"\n      and \"\\<lbrakk> (t, a, t') \\<in> T; \\<And>m. a \\<noteq> send m; s' = s \\<rbrakk> \\<Longrightarrow> P\"\n      and \"\\<And>m. \\<lbrakk> (s, receive m, s') \\<in> S; (t, send m, t') \\<in> T \\<rbrakk> \\<Longrightarrow> P\"\n    shows \"P\"", "lemma trans_par_comp [simp]:\n  \"trans (s \\<langle>\\<langle> t) = parp_sos (trans s) (trans t)\"", "lemma init_par_comp [simp]:\n  \"init (s \\<langle>\\<langle> t) = init s \\<times> init t\"", "lemma node_sos_never_newpkt [simp]:\n  assumes \"(s, a, s') \\<in> node_sos S\"\n    shows \"a \\<noteq> i:newpkt(d, di)\"", "lemma arrives_or_not:\n  assumes \"(NodeS i s R, ii\\<not>ni:arrive(m), NodeS i' s' R') \\<in> node_sos S\"\n    shows \"(ii = {i} \\<and> ni = {}) \\<or> (ii = {} \\<and> ni = {i})\"", "lemma trans_node_comp:\n  \"trans (\\<langle>i : np : R\\<^sub>i\\<rangle>) = node_sos (trans np)\"", "lemma init_node_comp:\n  \"init (\\<langle>i : np : R\\<^sub>i\\<rangle>) = {NodeS i s R\\<^sub>i|s. s \\<in> init np}\"", "lemmas node_comps = trans_node_comp init_node_comp", "lemma trans_par_node_comp [simp]:\n  \"trans (\\<langle>i : s \\<langle>\\<langle> t : R\\<rangle>) = node_sos (parp_sos (trans s) (trans t))\"", "lemma snd_par_node_comp [simp]:\n  \"init (\\<langle>i : s \\<langle>\\<langle> t : R\\<rangle>) = {NodeS i st R|st. st \\<in> init s \\<times> init t}\"", "lemma node_sos_dest_is_net_state:\n  assumes \"(s, a, s') \\<in> node_sos S\"\n    shows \"\\<exists>i' P' R'. s' = NodeS i' P' R'\"", "lemma node_sos_dest:\n  assumes \"(NodeS i p R, a, s') \\<in> node_sos S\"\n    shows \"\\<exists>P' R'. s' = NodeS i P' R'\"", "lemma node_sos_states [elim]:\n  assumes \"(ns, a, ns') \\<in> node_sos S\"\n  obtains i s R s' R' where \"ns  = NodeS i s  R\"\n                        and \"ns' = NodeS i s' R'\"", "lemma node_sos_cases [elim]:\n  \"(NodeS i p R, a, NodeS i p' R') \\<in> node_sos S \\<Longrightarrow>\n  (\\<And>m .       \\<lbrakk> a = R:*cast(m);          R' = R; (p, broadcast m, p') \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>m D.      \\<lbrakk> a = (R \\<inter> D):*cast(m);    R' = R; (p, groupcast D m, p') \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>d m.      \\<lbrakk> a = {d}:*cast(m);        R' = R; (p, unicast d m, p') \\<in> S; d \\<in> R \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>d.        \\<lbrakk> a = \\<tau>;                   R' = R; (p, \\<not>unicast d, p') \\<in> S; d \\<notin> R \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>d.        \\<lbrakk> a = i:deliver(d);        R' = R; (p, deliver d, p') \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>m.        \\<lbrakk> a = {i}\\<not>{}:arrive(m);    R' = R; (p, receive m, p') \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (            \\<lbrakk> a = \\<tau>;                   R' = R; (p, \\<tau>, p') \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>m.        \\<lbrakk> a = {}\\<not>{i}:arrive(m);    R' = R; p = p' \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i'.     \\<lbrakk> a = connect(i, i');      R' = R \\<union> {i'}; p = p' \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i'.     \\<lbrakk> a = connect(i', i);      R' = R \\<union> {i'}; p = p' \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i'.     \\<lbrakk> a = disconnect(i, i');   R' = R - {i'}; p = p' \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i'.     \\<lbrakk> a = disconnect(i', i);   R' = R - {i'}; p = p' \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i' i''. \\<lbrakk> a = connect(i', i'');    R' = R; p = p'; i \\<noteq> i'; i \\<noteq> i'' \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i' i''. \\<lbrakk> a = disconnect(i', i''); R' = R; p = p'; i \\<noteq> i'; i \\<noteq> i'' \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  P\"", "lemma pnet_sos_never_newpkt:\n  assumes \"(st, a, st') \\<in> pnet_sos S T\"\n      and \"\\<And>i d di a s s'. (s, a, s') \\<in> S \\<Longrightarrow> a \\<noteq> i:newpkt(d, di)\"\n      and \"\\<And>i d di a t t'. (t, a, t') \\<in> T \\<Longrightarrow> a \\<noteq> i:newpkt(d, di)\"\n    shows \"a \\<noteq> i:newpkt(d, di)\"", "lemma pnet_node_init [elim, simp]:\n  assumes \"s \\<in> init (pnet np \\<langle>i; R\\<rangle>)\"\n    shows \"s \\<in> { NodeS i s R |s. s \\<in> init (np i)}\"", "lemma pnet_node_init' [elim]:\n assumes \"s \\<in> init (pnet np \\<langle>i; R\\<rangle>)\"\n obtains ns where \"s = NodeS i ns R\"\n             and \"ns \\<in> init (np i)\"", "lemma pnet_node_trans [elim, simp]:\n  assumes \"(s, a, s') \\<in> trans (pnet np \\<langle>i; R\\<rangle>)\"\n    shows \"(s, a, s') \\<in> node_sos (trans (np i))\"", "lemma pnet_never_newpkt':\n  assumes \"(s, a, s') \\<in> trans (pnet np n)\"\n    shows \"\\<forall>i d di. a \\<noteq> i:newpkt(d, di)\"", "lemma pnet_never_newpkt:\n  assumes \"(s, a, s') \\<in> trans (pnet np n)\"\n    shows \"a \\<noteq> i:newpkt(d, di)\"", "lemmas completeTEs = connect_completeTE\n                     disconnect_completeTE\n                     tau_completeTE\n                     deliver_completeTE\n                     newpkt_completeTE", "lemma complete_no_cast [simp]:\n  \"(s, R:*cast(m), s') \\<notin> cnet_sos T\"", "lemma complete_no_arrive [simp]:\n  \"(s, ii\\<not>ni:arrive(m), s') \\<notin> cnet_sos T\""], "translations": [["", "lemma seqp_broadcastTE [elim]:\n  \"\\<lbrakk>((\\<xi>, {l}broadcast(s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>;\n    \\<lbrakk>a = broadcast (s\\<^sub>m\\<^sub>s\\<^sub>g \\<xi>); \\<xi>' = \\<xi>; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<xi>, {l}broadcast(s\\<^sub>m\\<^sub>s\\<^sub>g) .\n               p),\n              a, \\<xi>', q)\n             \\<in> seqp_sos \\<Gamma>;\n     \\<lbrakk>a = broadcast (s\\<^sub>m\\<^sub>s\\<^sub>g \\<xi>);\n      \\<xi>' = \\<xi>; q = p\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<xi>, {l}broadcast(s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>\") simp"], ["", "lemma seqp_groupcastTE [elim]:\n  \"\\<lbrakk>((\\<xi>, {l}groupcast(s\\<^sub>i\\<^sub>p\\<^sub>s, s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>;\n    \\<lbrakk>a = groupcast (s\\<^sub>i\\<^sub>p\\<^sub>s \\<xi>) (s\\<^sub>m\\<^sub>s\\<^sub>g \\<xi>); \\<xi>' = \\<xi>; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<xi>,\n               {l}groupcast(s\\<^sub>i\\<^sub>p\\<^sub>s,\n                             s\\<^sub>m\\<^sub>s\\<^sub>g) .\n               p),\n              a, \\<xi>', q)\n             \\<in> seqp_sos \\<Gamma>;\n     \\<lbrakk>a =\n              groupcast (s\\<^sub>i\\<^sub>p\\<^sub>s \\<xi>)\n               (s\\<^sub>m\\<^sub>s\\<^sub>g \\<xi>);\n      \\<xi>' = \\<xi>; q = p\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<xi>, {l}groupcast(s\\<^sub>i\\<^sub>p\\<^sub>s, s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>\") simp"], ["", "lemma seqp_unicastTE [elim]:\n  \"\\<lbrakk>((\\<xi>, {l}unicast(s\\<^sub>i\\<^sub>p, s\\<^sub>m\\<^sub>s\\<^sub>g). p \\<triangleright> q), a, (\\<xi>', r)) \\<in> seqp_sos \\<Gamma>;\n    \\<lbrakk>a = unicast (s\\<^sub>i\\<^sub>p \\<xi>) (s\\<^sub>m\\<^sub>s\\<^sub>g \\<xi>); \\<xi>' = \\<xi>; r = p\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>a = \\<not>unicast (s\\<^sub>i\\<^sub>p \\<xi>); \\<xi>' = \\<xi>; r = q\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<xi>,\n               {l}unicast(s\\<^sub>i\\<^sub>p, s\\<^sub>m\\<^sub>s\\<^sub>g) .\n                  p \\<triangleright> q),\n              a, \\<xi>', r)\n             \\<in> seqp_sos \\<Gamma>;\n     \\<lbrakk>a =\n              unicast (s\\<^sub>i\\<^sub>p \\<xi>)\n               (s\\<^sub>m\\<^sub>s\\<^sub>g \\<xi>);\n      \\<xi>' = \\<xi>; r = p\\<rbrakk>\n     \\<Longrightarrow> P;\n     \\<lbrakk>a = \\<not>unicast (s\\<^sub>i\\<^sub>p \\<xi>); \\<xi>' = \\<xi>;\n      r = q\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<xi>, {l}unicast(s\\<^sub>i\\<^sub>p, s\\<^sub>m\\<^sub>s\\<^sub>g). p \\<triangleright> q), a, (\\<xi>', r)) \\<in> seqp_sos \\<Gamma>\") simp_all"], ["", "lemma seqp_sendTE [elim]:\n  \"\\<lbrakk>((\\<xi>, {l}send(s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>;\n    \\<lbrakk>a = send (s\\<^sub>m\\<^sub>s\\<^sub>g \\<xi>); \\<xi>' = \\<xi>; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<xi>, {l}send(s\\<^sub>m\\<^sub>s\\<^sub>g) .\n               p),\n              a, \\<xi>', q)\n             \\<in> seqp_sos \\<Gamma>;\n     \\<lbrakk>a = send (s\\<^sub>m\\<^sub>s\\<^sub>g \\<xi>); \\<xi>' = \\<xi>;\n      q = p\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<xi>, {l}send(s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>\") simp"], ["", "lemma seqp_deliverTE [elim]:\n  \"\\<lbrakk>((\\<xi>, {l}deliver(s\\<^sub>d\\<^sub>a\\<^sub>t\\<^sub>a). p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>;\n    \\<lbrakk>a = deliver (s\\<^sub>d\\<^sub>a\\<^sub>t\\<^sub>a \\<xi>); \\<xi>' = \\<xi>; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<xi>, {l}deliver(s\\<^sub>d\\<^sub>a\\<^sub>t\\<^sub>a) .\n               p),\n              a, \\<xi>', q)\n             \\<in> seqp_sos \\<Gamma>;\n     \\<lbrakk>a = deliver (s\\<^sub>d\\<^sub>a\\<^sub>t\\<^sub>a \\<xi>);\n      \\<xi>' = \\<xi>; q = p\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<xi>, {l}deliver(s\\<^sub>d\\<^sub>a\\<^sub>t\\<^sub>a). p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>\") simp"], ["", "lemma seqp_receiveTE [elim]:\n  \"\\<lbrakk>((\\<xi>, {l}receive(u\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>;\n    \\<And>msg. \\<lbrakk>a = receive msg; \\<xi>' = u\\<^sub>m\\<^sub>s\\<^sub>g msg \\<xi>; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<xi>, {l}receive(u\\<^sub>m\\<^sub>s\\<^sub>g) .\n               p),\n              a, \\<xi>', q)\n             \\<in> seqp_sos \\<Gamma>;\n     \\<And>msg.\n        \\<lbrakk>a = receive msg;\n         \\<xi>' = u\\<^sub>m\\<^sub>s\\<^sub>g msg \\<xi>; q = p\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<xi>, {l}receive(u\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>\") simp"], ["", "lemma seqp_assignTE [elim]:\n  \"\\<lbrakk>((\\<xi>, {l}\\<lbrakk>u\\<rbrakk> p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>; \\<lbrakk>a = \\<tau>; \\<xi>' = u \\<xi>; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<xi>, {l}\\<lbrakk>u\\<rbrakk>\n               p),\n              a, \\<xi>', q)\n             \\<in> seqp_sos \\<Gamma>;\n     \\<lbrakk>a = \\<tau>; \\<xi>' = u \\<xi>; q = p\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<xi>, {l}\\<lbrakk>u\\<rbrakk> p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>\") simp"], ["", "lemma seqp_guardTE [elim]:\n  \"\\<lbrakk>((\\<xi>, {l}\\<langle>g\\<rangle> p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>; \\<lbrakk>a = \\<tau>; \\<xi>' \\<in> g \\<xi>; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<xi>, {l}\\<langle>g\\<rangle>\n               p),\n              a, \\<xi>', q)\n             \\<in> seqp_sos \\<Gamma>;\n     \\<lbrakk>a = \\<tau>; \\<xi>' \\<in> g \\<xi>; q = p\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<xi>, {l}\\<langle>g\\<rangle> p), a, (\\<xi>', q)) \\<in> seqp_sos \\<Gamma>\") simp"], ["", "lemmas seqpTEs =\n  seqp_broadcastTE\n  seqp_groupcastTE\n  seqp_unicastTE\n  seqp_sendTE\n  seqp_deliverTE\n  seqp_receiveTE\n  seqp_assignTE\n  seqp_callTE\n  seqp_choiceTE\n  seqp_guardTE"], ["", "declare seqp_sos.intros [intro]"], ["", "subsection \"Table 2: Structural operational semantics for parallel process expressions \""], ["", "inductive_set\n  parp_sos :: \"('s1, 'm seq_action) transition set\n                    \\<Rightarrow> ('s2, 'm seq_action) transition set\n                    \\<Rightarrow> ('s1 \\<times> 's2, 'm seq_action) transition set\"\n  for S :: \"('s1, 'm seq_action) transition set\"\n  and T :: \"('s2, 'm seq_action) transition set\"\nwhere\n    parleft:  \"\\<lbrakk> (s, a, s') \\<in> S; \\<And>m. a \\<noteq> receive m \\<rbrakk> \\<Longrightarrow> ((s, t), a, (s', t)) \\<in> parp_sos S T\"\n  | parright: \"\\<lbrakk> (t, a, t') \\<in> T; \\<And>m. a \\<noteq> send m \\<rbrakk> \\<Longrightarrow> ((s, t), a, (s, t')) \\<in> parp_sos S T\"\n  | parboth:  \"\\<lbrakk> (s, receive m, s') \\<in> S; (t, send m, t') \\<in> T \\<rbrakk>\n               \\<Longrightarrow>((s, t), \\<tau>, (s', t')) \\<in> parp_sos S T\""], ["", "lemma par_broadcastTE [elim]:\n  \"\\<lbrakk>((s, t), broadcast m, (s', t')) \\<in> parp_sos S T;\n    \\<lbrakk>(s, broadcast m, s') \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, broadcast m, t') \\<in> T; s' = s\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, t), broadcast m, s', t') \\<in> parp_sos S T;\n     \\<lbrakk>(s, broadcast m, s') \\<in> S; t' = t\\<rbrakk>\n     \\<Longrightarrow> P;\n     \\<lbrakk>(t, broadcast m, t') \\<in> T; s' = s\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((s, t), broadcast m, (s', t')) \\<in> parp_sos S T\") simp_all"], ["", "lemma par_groupcastTE [elim]:\n  \"\\<lbrakk>((s, t), groupcast ips m, (s', t')) \\<in> parp_sos S T;\n    \\<lbrakk>(s, groupcast ips m, s') \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, groupcast ips m, t') \\<in> T; s' = s\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, t), groupcast ips m, s', t') \\<in> parp_sos S T;\n     \\<lbrakk>(s, groupcast ips m, s') \\<in> S; t' = t\\<rbrakk>\n     \\<Longrightarrow> P;\n     \\<lbrakk>(t, groupcast ips m, t') \\<in> T; s' = s\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((s, t), groupcast ips m, (s', t')) \\<in> parp_sos S T\") simp_all"], ["", "lemma par_unicastTE [elim]:\n  \"\\<lbrakk>((s, t), unicast i m, (s', t')) \\<in> parp_sos S T;\n    \\<lbrakk>(s, unicast i m, s') \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, unicast i m, t') \\<in> T; s' = s\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, t), unicast i m, s', t') \\<in> parp_sos S T;\n     \\<lbrakk>(s, unicast i m, s') \\<in> S; t' = t\\<rbrakk>\n     \\<Longrightarrow> P;\n     \\<lbrakk>(t, unicast i m, t') \\<in> T; s' = s\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((s, t), unicast i m, (s', t')) \\<in> parp_sos S T\") simp_all"], ["", "lemma par_notunicastTE [elim]:\n  \"\\<lbrakk>((s, t), notunicast i, (s', t')) \\<in> parp_sos S T;\n    \\<lbrakk>(s, notunicast i, s') \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, notunicast i, t') \\<in> T; s' = s\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, t), \\<not>unicast i, s', t') \\<in> parp_sos S T;\n     \\<lbrakk>(s, \\<not>unicast i, s') \\<in> S; t' = t\\<rbrakk>\n     \\<Longrightarrow> P;\n     \\<lbrakk>(t, \\<not>unicast i, t') \\<in> T; s' = s\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((s, t), notunicast i, (s', t')) \\<in> parp_sos S T\") simp_all"], ["", "lemma par_sendTE [elim]:\n  \"\\<lbrakk>((s, t), send m, (s', t')) \\<in> parp_sos S T;\n    \\<lbrakk>(s, send m, s') \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, t), send m, s', t') \\<in> parp_sos S T;\n     \\<lbrakk>(s, send m, s') \\<in> S; t' = t\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((s, t), send m, (s', t')) \\<in> parp_sos S T\") auto"], ["", "lemma par_deliverTE [elim]:\n  \"\\<lbrakk>((s, t), deliver d, (s', t')) \\<in> parp_sos S T;\n    \\<lbrakk>(s, deliver d, s') \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, deliver d, t') \\<in> T; s' = s\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, t), deliver d, s', t') \\<in> parp_sos S T;\n     \\<lbrakk>(s, deliver d, s') \\<in> S; t' = t\\<rbrakk>\n     \\<Longrightarrow> P;\n     \\<lbrakk>(t, deliver d, t') \\<in> T; s' = s\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((s, t), deliver d, (s', t')) \\<in> parp_sos S T\") simp_all"], ["", "lemma par_receiveTE [elim]:\n  \"\\<lbrakk>((s, t), receive m, (s', t')) \\<in> parp_sos S T;\n    \\<lbrakk>(t, receive m, t') \\<in> T; s' = s\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, t), receive m, s', t') \\<in> parp_sos S T;\n     \\<lbrakk>(t, receive m, t') \\<in> T; s' = s\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((s, t), receive m, (s', t')) \\<in> parp_sos S T\") auto"], ["", "inductive_cases par_tauTE: \"((s, t), \\<tau>, (s', t')) \\<in> parp_sos S T\""], ["", "lemmas parpTEs =\n  par_broadcastTE\n  par_groupcastTE\n  par_unicastTE\n  par_notunicastTE\n  par_sendTE\n  par_deliverTE\n  par_receiveTE"], ["", "lemma parp_sos_cases [elim]:\n  assumes \"((s, t), a, (s', t')) \\<in> parp_sos S T\"\n      and \"\\<lbrakk> (s, a, s') \\<in> S; \\<And>m. a \\<noteq> receive m; t' = t \\<rbrakk> \\<Longrightarrow> P\"\n      and \"\\<lbrakk> (t, a, t') \\<in> T; \\<And>m. a \\<noteq> send m; s' = s \\<rbrakk> \\<Longrightarrow> P\"\n      and \"\\<And>m. \\<lbrakk> (s, receive m, s') \\<in> S; (t, send m, t') \\<in> T \\<rbrakk> \\<Longrightarrow> P\"\n    shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  ((s, t), a, s', t') \\<in> parp_sos S T\n  \\<lbrakk>(s, a, s') \\<in> S; \\<And>m. a \\<noteq> receive m;\n   t' = t\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>(t, a, t') \\<in> T; \\<And>m. a \\<noteq> send m; s' = s\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>(s, receive ?m, s') \\<in> S; (t, send ?m, t') \\<in> T\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by cases auto"], ["", "definition\n  par_comp :: \"('s1, 'm seq_action) automaton\n              \\<Rightarrow> ('s2, 'm seq_action) automaton\n              \\<Rightarrow> ('s1 \\<times> 's2, 'm seq_action) automaton\"\n  (\"(_ \\<langle>\\<langle> _)\" [102, 103] 102)\nwhere\n  \"s \\<langle>\\<langle> t \\<equiv> \\<lparr> init = init s \\<times> init t, trans = parp_sos (trans s) (trans t) \\<rparr>\""], ["", "lemma trans_par_comp [simp]:\n  \"trans (s \\<langle>\\<langle> t) = parp_sos (trans s) (trans t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton.trans (s \\<langle>\\<langle> t) =\n    parp_sos (automaton.trans s) (automaton.trans t)", "unfolding par_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton.trans\n     \\<lparr>init = init s \\<times> init t,\n        trans = parp_sos (automaton.trans s) (automaton.trans t)\\<rparr> =\n    parp_sos (automaton.trans s) (automaton.trans t)", "by simp"], ["", "lemma init_par_comp [simp]:\n  \"init (s \\<langle>\\<langle> t) = init s \\<times> init t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init (s \\<langle>\\<langle> t) = init s \\<times> init t", "unfolding par_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. init\n     \\<lparr>init = init s \\<times> init t,\n        trans = parp_sos (automaton.trans s) (automaton.trans t)\\<rparr> =\n    init s \\<times> init t", "by simp"], ["", "subsection \"Table 3: Structural operational semantics for node expressions \""], ["", "inductive_set\n  node_sos :: \"('s, 'm seq_action) transition set \\<Rightarrow> ('s net_state, 'm node_action) transition set\"\n  for S :: \"('s, 'm seq_action) transition set\"\nwhere\n    node_bcast:\n    \"(s, broadcast m, s') \\<in> S \\<Longrightarrow> (NodeS i s R, R:*cast(m), NodeS i s' R) \\<in> node_sos S\"\n  | node_gcast:\n    \"(s, groupcast D m, s') \\<in> S \\<Longrightarrow> (NodeS i s R, (R\\<inter>D):*cast(m), NodeS i s' R) \\<in> node_sos S\"\n  | node_ucast:\n    \"\\<lbrakk> (s, unicast d m, s') \\<in> S; d\\<in>R \\<rbrakk> \\<Longrightarrow> (NodeS i s R, {d}:*cast(m), NodeS i s' R) \\<in> node_sos S\"\n  | node_notucast:\n    \"\\<lbrakk> (s, \\<not>unicast d, s') \\<in> S; d\\<notin>R \\<rbrakk> \\<Longrightarrow> (NodeS i s R, \\<tau>, NodeS i s' R) \\<in> node_sos S\"\n  | node_deliver:\n    \"(s, deliver d, s') \\<in> S \\<Longrightarrow> (NodeS i s R, i:deliver(d), NodeS i s' R) \\<in> node_sos S\"\n  | node_receive:\n    \"(s, receive m, s') \\<in> S \\<Longrightarrow> (NodeS i s R, {i}\\<not>{}:arrive(m), NodeS i s' R) \\<in> node_sos S\"\n  | node_tau:\n    \"(s, \\<tau>, s') \\<in> S         \\<Longrightarrow> (NodeS i s R, \\<tau>, NodeS i s' R) \\<in> node_sos S\"\n  | node_arrive:\n    \"(NodeS i s R, {}\\<not>{i}:arrive(m),  NodeS i s R) \\<in> node_sos S\"\n  | node_connect1:\n    \"(NodeS i s R, connect(i, i'),    NodeS i s (R \\<union> {i'})) \\<in> node_sos S\"\n  | node_connect2:\n    \"(NodeS i s R, connect(i', i),    NodeS i s (R \\<union> {i'})) \\<in> node_sos S\"\n  | node_disconnect1:\n    \"(NodeS i s R, disconnect(i, i'), NodeS i s (R - {i'})) \\<in> node_sos S\"\n  | node_disconnect2:\n    \"(NodeS i s R, disconnect(i', i), NodeS i s (R - {i'})) \\<in> node_sos S\"\n  | node_connect_other:\n    \"\\<lbrakk> i \\<noteq> i'; i \\<noteq> i'' \\<rbrakk> \\<Longrightarrow> (NodeS i s R, connect(i', i''), NodeS i s R) \\<in> node_sos S\"\n  | node_disconnect_other:\n    \"\\<lbrakk> i \\<noteq> i'; i \\<noteq> i'' \\<rbrakk> \\<Longrightarrow> (NodeS i s R, disconnect(i', i''), NodeS i s R) \\<in> node_sos S\""], ["", "inductive_cases node_arriveTE:  \"(NodeS i s R, ii\\<not>ni:arrive(m), NodeS i s' R) \\<in> node_sos S\"\n            and node_arriveTE': \"(NodeS i s R, H\\<not>K:arrive(m), s') \\<in> node_sos S\"\n            and node_castTE:    \"(NodeS i s R, RM:*cast(m), NodeS i s' R') \\<in> node_sos S\"\n            and node_castTE':   \"(NodeS i s R, RM:*cast(m), s') \\<in> node_sos S\"\n            and node_deliverTE: \"(NodeS i s R, i:deliver(d), NodeS i s' R) \\<in> node_sos S\"\n            and node_deliverTE': \"(s, i:deliver(d), s') \\<in> node_sos S\"\n            and node_deliverTE'': \"(NodeS ii s R, i:deliver(d), s') \\<in> node_sos S\"\n            and node_tauTE:     \"(NodeS i s R, \\<tau>, NodeS i s' R) \\<in> node_sos S\"\n            and node_tauTE':    \"(NodeS i s R, \\<tau>, s') \\<in> node_sos S\"\n            and node_connectTE: \"(NodeS ii s R, connect(i, i'), NodeS ii s' R') \\<in> node_sos S\"\n            and node_connectTE': \"(NodeS ii s R, connect(i, i'), s') \\<in> node_sos S\"\n            and node_disconnectTE: \"(NodeS ii s R, disconnect(i, i'), NodeS ii s' R') \\<in> node_sos S\"\n            and node_disconnectTE': \"(NodeS ii s R, disconnect(i, i'), s') \\<in> node_sos S\""], ["", "lemma node_sos_never_newpkt [simp]:\n  assumes \"(s, a, s') \\<in> node_sos S\"\n    shows \"a \\<noteq> i:newpkt(d, di)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> i:newpkt(d, di)", "using assms"], ["proof (prove)\nusing this:\n  (s, a, s') \\<in> node_sos S\n\ngoal (1 subgoal):\n 1. a \\<noteq> i:newpkt(d, di)", "by cases auto"], ["", "lemma arrives_or_not:\n  assumes \"(NodeS i s R, ii\\<not>ni:arrive(m), NodeS i' s' R') \\<in> node_sos S\"\n    shows \"(ii = {i} \\<and> ni = {}) \\<or> (ii = {} \\<and> ni = {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ii = {i} \\<and> ni = {} \\<or> ii = {} \\<and> ni = {i}", "using assms"], ["proof (prove)\nusing this:\n  (NodeS i s R, ii\\<not>ni:arrive(m), NodeS i' s' R') \\<in> node_sos S\n\ngoal (1 subgoal):\n 1. ii = {i} \\<and> ni = {} \\<or> ii = {} \\<and> ni = {i}", "by rule simp_all"], ["", "definition\n  node_comp :: \"ip \\<Rightarrow> ('s, 'm seq_action) automaton \\<Rightarrow> ip set\n                   \\<Rightarrow> ('s net_state, 'm node_action) automaton\"\n    (\"(\\<langle>_ : (_) : _\\<rangle>)\" [0, 0, 0] 104)\nwhere\n  \"\\<langle>i : np : R\\<^sub>i\\<rangle> \\<equiv> \\<lparr> init = {NodeS i s R\\<^sub>i|s. s \\<in> init np}, trans = node_sos (trans np) \\<rparr>\""], ["", "lemma trans_node_comp:\n  \"trans (\\<langle>i : np : R\\<^sub>i\\<rangle>) = node_sos (trans np)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton.trans (\\<langle>i : np : R\\<^sub>i\\<rangle>) =\n    node_sos (automaton.trans np)", "unfolding node_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton.trans\n     \\<lparr>init = {NodeS i s R\\<^sub>i |s. s \\<in> init np},\n        trans = node_sos (automaton.trans np)\\<rparr> =\n    node_sos (automaton.trans np)", "by simp"], ["", "lemma init_node_comp:\n  \"init (\\<langle>i : np : R\\<^sub>i\\<rangle>) = {NodeS i s R\\<^sub>i|s. s \\<in> init np}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init (\\<langle>i : np : R\\<^sub>i\\<rangle>) =\n    {NodeS i s R\\<^sub>i |s. s \\<in> init np}", "unfolding node_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. init\n     \\<lparr>init = {NodeS i s R\\<^sub>i |s. s \\<in> init np},\n        trans = node_sos (automaton.trans np)\\<rparr> =\n    {NodeS i s R\\<^sub>i |s. s \\<in> init np}", "by simp"], ["", "lemmas node_comps = trans_node_comp init_node_comp"], ["", "lemma trans_par_node_comp [simp]:\n  \"trans (\\<langle>i : s \\<langle>\\<langle> t : R\\<rangle>) = node_sos (parp_sos (trans s) (trans t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton.trans (\\<langle>i : s \\<langle>\\<langle> t : R\\<rangle>) =\n    node_sos (parp_sos (automaton.trans s) (automaton.trans t))", "unfolding node_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton.trans\n     \\<lparr>init =\n               {NodeS i sa R |sa. sa \\<in> init (s \\<langle>\\<langle> t)},\n        trans =\n          node_sos (automaton.trans (s \\<langle>\\<langle> t))\\<rparr> =\n    node_sos (parp_sos (automaton.trans s) (automaton.trans t))", "by simp"], ["", "lemma snd_par_node_comp [simp]:\n  \"init (\\<langle>i : s \\<langle>\\<langle> t : R\\<rangle>) = {NodeS i st R|st. st \\<in> init s \\<times> init t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init (\\<langle>i : s \\<langle>\\<langle> t : R\\<rangle>) =\n    {NodeS i st R |st. st \\<in> init s \\<times> init t}", "unfolding node_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. init\n     \\<lparr>init =\n               {NodeS i sa R |sa. sa \\<in> init (s \\<langle>\\<langle> t)},\n        trans =\n          node_sos (automaton.trans (s \\<langle>\\<langle> t))\\<rparr> =\n    {NodeS i st R |st. st \\<in> init s \\<times> init t}", "by simp"], ["", "lemma node_sos_dest_is_net_state:\n  assumes \"(s, a, s') \\<in> node_sos S\"\n    shows \"\\<exists>i' P' R'. s' = NodeS i' P' R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i' P' R'. s' = NodeS i' P' R'", "using assms"], ["proof (prove)\nusing this:\n  (s, a, s') \\<in> node_sos S\n\ngoal (1 subgoal):\n 1. \\<exists>i' P' R'. s' = NodeS i' P' R'", "by induct auto"], ["", "lemma node_sos_dest:\n  assumes \"(NodeS i p R, a, s') \\<in> node_sos S\"\n    shows \"\\<exists>P' R'. s' = NodeS i P' R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P' R'. s' = NodeS i P' R'", "using assms assms [THEN node_sos_dest_is_net_state]"], ["proof (prove)\nusing this:\n  (NodeS i p R, a, s') \\<in> node_sos S\n  \\<exists>i' P' R'. s' = NodeS i' P' R'\n\ngoal (1 subgoal):\n 1. \\<exists>P' R'. s' = NodeS i P' R'", "by - (erule node_sos.cases, auto)"], ["", "lemma node_sos_states [elim]:\n  assumes \"(ns, a, ns') \\<in> node_sos S\"\n  obtains i s R s' R' where \"ns  = NodeS i s  R\"\n                        and \"ns' = NodeS i s' R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i s R s' R'.\n        \\<lbrakk>ns = NodeS i s R; ns' = NodeS i s' R'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>i s R s' R'.\n        \\<lbrakk>ns = NodeS i s R; ns' = NodeS i s' R'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume [intro!]: \"\\<And>i s R s' R'. ns = NodeS i s R \\<Longrightarrow> ns' = NodeS i s' R' \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<lbrakk>ns = NodeS ?i ?s ?R; ns' = NodeS ?i ?s' ?R'\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>i s R s' R'.\n        \\<lbrakk>ns = NodeS i s R; ns' = NodeS i s' R'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(1)"], ["proof (chain)\npicking this:\n  (ns, a, ns') \\<in> node_sos S", "obtain i s R where \"ns = NodeS i s R\""], ["proof (prove)\nusing this:\n  (ns, a, ns') \\<in> node_sos S\n\ngoal (1 subgoal):\n 1. (\\<And>i s R.\n        ns = NodeS i s R \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ns) auto"], ["proof (state)\nthis:\n  ns = NodeS i s R\n\ngoal (1 subgoal):\n 1. (\\<And>i s R s' R'.\n        \\<lbrakk>ns = NodeS i s R; ns' = NodeS i s' R'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  ns = NodeS i s R\n\ngoal (1 subgoal):\n 1. (\\<And>i s R s' R'.\n        \\<lbrakk>ns = NodeS i s R; ns' = NodeS i s' R'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms(1)"], ["proof (chain)\npicking this:\n  (ns, a, ns') \\<in> node_sos S\n  ns = NodeS i s R", "obtain s' R' where \"ns' = NodeS i s' R'\""], ["proof (prove)\nusing this:\n  (ns, a, ns') \\<in> node_sos S\n  ns = NodeS i s R\n\ngoal (1 subgoal):\n 1. (\\<And>s' R'.\n        ns' = NodeS i s' R' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis node_sos_dest)"], ["proof (state)\nthis:\n  ns' = NodeS i s' R'\n\ngoal (1 subgoal):\n 1. (\\<And>i s R s' R'.\n        \\<lbrakk>ns = NodeS i s R; ns' = NodeS i s' R'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  ns = NodeS i s R\n  ns' = NodeS i s' R'", "show thesis"], ["proof (prove)\nusing this:\n  ns = NodeS i s R\n  ns' = NodeS i s' R'\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma node_sos_cases [elim]:\n  \"(NodeS i p R, a, NodeS i p' R') \\<in> node_sos S \\<Longrightarrow>\n  (\\<And>m .       \\<lbrakk> a = R:*cast(m);          R' = R; (p, broadcast m, p') \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>m D.      \\<lbrakk> a = (R \\<inter> D):*cast(m);    R' = R; (p, groupcast D m, p') \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>d m.      \\<lbrakk> a = {d}:*cast(m);        R' = R; (p, unicast d m, p') \\<in> S; d \\<in> R \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>d.        \\<lbrakk> a = \\<tau>;                   R' = R; (p, \\<not>unicast d, p') \\<in> S; d \\<notin> R \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>d.        \\<lbrakk> a = i:deliver(d);        R' = R; (p, deliver d, p') \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>m.        \\<lbrakk> a = {i}\\<not>{}:arrive(m);    R' = R; (p, receive m, p') \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (            \\<lbrakk> a = \\<tau>;                   R' = R; (p, \\<tau>, p') \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>m.        \\<lbrakk> a = {}\\<not>{i}:arrive(m);    R' = R; p = p' \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i'.     \\<lbrakk> a = connect(i, i');      R' = R \\<union> {i'}; p = p' \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i'.     \\<lbrakk> a = connect(i', i);      R' = R \\<union> {i'}; p = p' \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i'.     \\<lbrakk> a = disconnect(i, i');   R' = R - {i'}; p = p' \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i'.     \\<lbrakk> a = disconnect(i', i);   R' = R - {i'}; p = p' \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i' i''. \\<lbrakk> a = connect(i', i'');    R' = R; p = p'; i \\<noteq> i'; i \\<noteq> i'' \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i' i''. \\<lbrakk> a = disconnect(i', i''); R' = R; p = p'; i \\<noteq> i'; i \\<noteq> i'' \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(NodeS i p R, a, NodeS i p' R') \\<in> node_sos S;\n     \\<And>m.\n        \\<lbrakk>a = R:*cast(m); R' = R;\n         (p, broadcast m, p') \\<in> S\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>m D.\n        \\<lbrakk>a = (R \\<inter> D):*cast(m); R' = R;\n         (p, groupcast D m, p') \\<in> S\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>d m.\n        \\<lbrakk>a = {d}:*cast(m); R' = R; (p, unicast d m, p') \\<in> S;\n         d \\<in> R\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>d.\n        \\<lbrakk>a = \\<tau>; R' = R; (p, \\<not>unicast d, p') \\<in> S;\n         d \\<notin> R\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>d.\n        \\<lbrakk>a = i:deliver(d); R' = R;\n         (p, deliver d, p') \\<in> S\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>m.\n        \\<lbrakk>a = {i}\\<not>{}:arrive(m); R' = R;\n         (p, receive m, p') \\<in> S\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<lbrakk>a = \\<tau>; R' = R; (p, \\<tau>, p') \\<in> S\\<rbrakk>\n     \\<Longrightarrow> P;\n     \\<And>m.\n        \\<lbrakk>a = {}\\<not>{i}:arrive(m); R' = R; p = p'\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>i i'.\n        \\<lbrakk>a = connect(i, i'); R' = R \\<union> {i'}; p = p'\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>i i'.\n        \\<lbrakk>a = connect(i', i); R' = R \\<union> {i'}; p = p'\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>i i'.\n        \\<lbrakk>a = disconnect(i, i'); R' = R - {i'}; p = p'\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>i i'.\n        \\<lbrakk>a = disconnect(i', i); R' = R - {i'}; p = p'\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>i i' i''.\n        \\<lbrakk>a = connect(i', i''); R' = R; p = p'; i \\<noteq> i';\n         i \\<noteq> i''\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>i i' i''.\n        \\<lbrakk>a = disconnect(i', i''); R' = R; p = p'; i \\<noteq> i';\n         i \\<noteq> i''\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (erule node_sos.cases) simp_all"], ["", "subsection \"Table 4: Structural operational semantics for partial network expressions \""], ["", "inductive_set\n  pnet_sos :: \"('s net_state, 'm node_action) transition set\n                    \\<Rightarrow> ('s net_state, 'm node_action) transition set\n                    \\<Rightarrow> ('s net_state, 'm node_action) transition set\"\n  for S :: \"('s net_state, 'm node_action) transition set\"\n  and T :: \"('s net_state, 'm node_action) transition set\"\nwhere\n    pnet_cast1: \"\\<lbrakk> (s, R:*cast(m), s') \\<in> S; (t, H\\<not>K:arrive(m), t') \\<in> T; H \\<subseteq> R; K \\<inter> R = {} \\<rbrakk>\n      \\<Longrightarrow> (SubnetS s t, R:*cast(m), SubnetS s' t') \\<in> pnet_sos S T\"\n\n  | pnet_cast2: \"\\<lbrakk> (s, H\\<not>K:arrive(m), s') \\<in> S; (t, R:*cast(m), t') \\<in> T;  H \\<subseteq> R; K \\<inter> R = {} \\<rbrakk>\n      \\<Longrightarrow> (SubnetS s t, R:*cast(m), SubnetS s' t') \\<in> pnet_sos S T\"\n\n  | pnet_arrive: \"\\<lbrakk> (s, H\\<not>K:arrive(m), s') \\<in> S; (t, H'\\<not>K':arrive(m), t') \\<in> T \\<rbrakk>\n      \\<Longrightarrow> (SubnetS s t,  (H \\<union> H')\\<not>(K \\<union> K'):arrive(m), SubnetS s' t') \\<in> pnet_sos S T\"\n\n  | pnet_deliver1: \"(s, i:deliver(d), s') \\<in> S\n      \\<Longrightarrow> (SubnetS s t, i:deliver(d), SubnetS s' t) \\<in> pnet_sos S T\"\n  | pnet_deliver2: \"\\<lbrakk> (t, i:deliver(d), t') \\<in> T \\<rbrakk>\n      \\<Longrightarrow> (SubnetS s t, i:deliver(d), SubnetS s t') \\<in> pnet_sos S T\"\n\n  | pnet_tau1: \"(s, \\<tau>, s') \\<in> S \\<Longrightarrow> (SubnetS s t, \\<tau>, SubnetS s' t) \\<in> pnet_sos S T\"\n  | pnet_tau2: \"(t, \\<tau>, t') \\<in> T \\<Longrightarrow> (SubnetS s t, \\<tau>, SubnetS s t') \\<in> pnet_sos S T\"\n\n  | pnet_connect: \"\\<lbrakk> (s, connect(i, i'), s') \\<in> S; (t, connect(i, i'), t') \\<in> T \\<rbrakk>\n      \\<Longrightarrow> (SubnetS s t, connect(i, i'), SubnetS s' t') \\<in> pnet_sos S T\"\n\n  | pnet_disconnect: \"\\<lbrakk> (s, disconnect(i, i'), s') \\<in> S; (t, disconnect(i, i'), t') \\<in> T \\<rbrakk>\n      \\<Longrightarrow> (SubnetS s t, disconnect(i, i'), SubnetS s' t') \\<in> pnet_sos S T\""], ["", "inductive_cases partial_castTE [elim]:       \"(s, R:*cast(m), s') \\<in> pnet_sos S T\"\n            and partial_arriveTE [elim]:     \"(s, H\\<not>K:arrive(m), s') \\<in> pnet_sos S T\"\n            and partial_deliverTE [elim]:    \"(s, i:deliver(d), s') \\<in> pnet_sos S T\"\n            and partial_tauTE [elim]:        \"(s, \\<tau>, s') \\<in> pnet_sos S T\"\n            and partial_connectTE [elim]:    \"(s, connect(i, i'), s') \\<in> pnet_sos S T\"\n            and partial_disconnectTE [elim]: \"(s, disconnect(i, i'), s') \\<in> pnet_sos S T\""], ["", "lemma pnet_sos_never_newpkt:\n  assumes \"(st, a, st') \\<in> pnet_sos S T\"\n      and \"\\<And>i d di a s s'. (s, a, s') \\<in> S \\<Longrightarrow> a \\<noteq> i:newpkt(d, di)\"\n      and \"\\<And>i d di a t t'. (t, a, t') \\<in> T \\<Longrightarrow> a \\<noteq> i:newpkt(d, di)\"\n    shows \"a \\<noteq> i:newpkt(d, di)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> i:newpkt(d, di)", "using assms(1)"], ["proof (prove)\nusing this:\n  (st, a, st') \\<in> pnet_sos S T\n\ngoal (1 subgoal):\n 1. a \\<noteq> i:newpkt(d, di)", "by cases (auto dest!: assms(2-3))"], ["", "fun pnet :: \"(ip \\<Rightarrow> ('s, 'm seq_action) automaton)\n              \\<Rightarrow> net_tree \\<Rightarrow> ('s net_state, 'm node_action) automaton\"\nwhere\n    \"pnet np (\\<langle>i; R\\<^sub>i\\<rangle>)  =  \\<langle>i : np i : R\\<^sub>i\\<rangle>\"\n  | \"pnet np (p\\<^sub>1 \\<parallel> p\\<^sub>2) = \\<lparr> init = {SubnetS s\\<^sub>1 s\\<^sub>2 |s\\<^sub>1 s\\<^sub>2. s\\<^sub>1 \\<in> init (pnet np p\\<^sub>1)\n                                                      \\<and> s\\<^sub>2 \\<in> init (pnet np p\\<^sub>2)},\n                           trans = pnet_sos (trans (pnet np p\\<^sub>1)) (trans (pnet np p\\<^sub>2)) \\<rparr>\""], ["", "lemma pnet_node_init [elim, simp]:\n  assumes \"s \\<in> init (pnet np \\<langle>i; R\\<rangle>)\"\n    shows \"s \\<in> { NodeS i s R |s. s \\<in> init (np i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {NodeS i s R |s. s \\<in> init (np i)}", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> init (pnet np \\<langle>i; R\\<rangle>)\n\ngoal (1 subgoal):\n 1. s \\<in> {NodeS i s R |s. s \\<in> init (np i)}", "by (simp add: node_comp_def)"], ["", "lemma pnet_node_init' [elim]:\n assumes \"s \\<in> init (pnet np \\<langle>i; R\\<rangle>)\"\n obtains ns where \"s = NodeS i ns R\"\n             and \"ns \\<in> init (np i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>s = NodeS i ns R; ns \\<in> init (np i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> init (pnet np \\<langle>i; R\\<rangle>)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>s = NodeS i ns R; ns \\<in> init (np i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: node_comp_def)"], ["", "lemma pnet_node_trans [elim, simp]:\n  assumes \"(s, a, s') \\<in> trans (pnet np \\<langle>i; R\\<rangle>)\"\n    shows \"(s, a, s') \\<in> node_sos (trans (np i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, a, s') \\<in> node_sos (automaton.trans (np i))", "using assms"], ["proof (prove)\nusing this:\n  (s, a, s') \\<in> automaton.trans (pnet np \\<langle>i; R\\<rangle>)\n\ngoal (1 subgoal):\n 1. (s, a, s') \\<in> node_sos (automaton.trans (np i))", "by (simp add: trans_node_comp)"], ["", "lemma pnet_never_newpkt':\n  assumes \"(s, a, s') \\<in> trans (pnet np n)\"\n    shows \"\\<forall>i d di. a \\<noteq> i:newpkt(d, di)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i d di. a \\<noteq> i:newpkt(d, di)", "using assms"], ["proof (prove)\nusing this:\n  (s, a, s') \\<in> automaton.trans (pnet np n)\n\ngoal (1 subgoal):\n 1. \\<forall>i d di. a \\<noteq> i:newpkt(d, di)", "proof (induction n arbitrary: s a s')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i R s a s'.\n       (s, a, s')\n       \\<in> automaton.trans\n              (pnet np \\<langle>i; R\\<rangle>) \\<Longrightarrow>\n       \\<forall>i d di. a \\<noteq> i:newpkt(d, di)\n 2. \\<And>n1 n2 s a s'.\n       \\<lbrakk>\\<And>s a s'.\n                   (s, a, s')\n                   \\<in> automaton.trans (pnet np n1) \\<Longrightarrow>\n                   \\<forall>i d di. a \\<noteq> i:newpkt(d, di);\n        \\<And>s a s'.\n           (s, a, s') \\<in> automaton.trans (pnet np n2) \\<Longrightarrow>\n           \\<forall>i d di. a \\<noteq> i:newpkt(d, di);\n        (s, a, s')\n        \\<in> automaton.trans (pnet np (n1 \\<parallel> n2))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i d di. a \\<noteq> i:newpkt(d, di)", "fix n1 n2 s a s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i R s a s'.\n       (s, a, s')\n       \\<in> automaton.trans\n              (pnet np \\<langle>i; R\\<rangle>) \\<Longrightarrow>\n       \\<forall>i d di. a \\<noteq> i:newpkt(d, di)\n 2. \\<And>n1 n2 s a s'.\n       \\<lbrakk>\\<And>s a s'.\n                   (s, a, s')\n                   \\<in> automaton.trans (pnet np n1) \\<Longrightarrow>\n                   \\<forall>i d di. a \\<noteq> i:newpkt(d, di);\n        \\<And>s a s'.\n           (s, a, s') \\<in> automaton.trans (pnet np n2) \\<Longrightarrow>\n           \\<forall>i d di. a \\<noteq> i:newpkt(d, di);\n        (s, a, s')\n        \\<in> automaton.trans (pnet np (n1 \\<parallel> n2))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i d di. a \\<noteq> i:newpkt(d, di)", "assume IH1: \"\\<And>s a s'. (s, a, s') \\<in> trans (pnet np n1) \\<Longrightarrow> \\<forall>i d di. a \\<noteq> i:newpkt(d, di)\"\n       and IH2: \"\\<And>s a s'. (s, a, s') \\<in> trans (pnet np n2) \\<Longrightarrow> \\<forall>i d di. a \\<noteq> i:newpkt(d, di)\"\n       and \"(s, a, s') \\<in> trans (pnet np (n1 \\<parallel> n2))\""], ["proof (state)\nthis:\n  (?s, ?a, ?s') \\<in> automaton.trans (pnet np n1) \\<Longrightarrow>\n  \\<forall>i d di. ?a \\<noteq> i:newpkt(d, di)\n  (?s, ?a, ?s') \\<in> automaton.trans (pnet np n2) \\<Longrightarrow>\n  \\<forall>i d di. ?a \\<noteq> i:newpkt(d, di)\n  (s, a, s') \\<in> automaton.trans (pnet np (n1 \\<parallel> n2))\n\ngoal (2 subgoals):\n 1. \\<And>i R s a s'.\n       (s, a, s')\n       \\<in> automaton.trans\n              (pnet np \\<langle>i; R\\<rangle>) \\<Longrightarrow>\n       \\<forall>i d di. a \\<noteq> i:newpkt(d, di)\n 2. \\<And>n1 n2 s a s'.\n       \\<lbrakk>\\<And>s a s'.\n                   (s, a, s')\n                   \\<in> automaton.trans (pnet np n1) \\<Longrightarrow>\n                   \\<forall>i d di. a \\<noteq> i:newpkt(d, di);\n        \\<And>s a s'.\n           (s, a, s') \\<in> automaton.trans (pnet np n2) \\<Longrightarrow>\n           \\<forall>i d di. a \\<noteq> i:newpkt(d, di);\n        (s, a, s')\n        \\<in> automaton.trans (pnet np (n1 \\<parallel> n2))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i d di. a \\<noteq> i:newpkt(d, di)", "show \"\\<forall>i d di. a \\<noteq> i:newpkt(d, di)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i d di. a \\<noteq> i:newpkt(d, di)", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i d di. a \\<noteq> i:newpkt(d, di)", "fix i d di"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i d di. a \\<noteq> i:newpkt(d, di)", "from \\<open>(s, a, s') \\<in> trans (pnet np (n1 \\<parallel> n2))\\<close>"], ["proof (chain)\npicking this:\n  (s, a, s') \\<in> automaton.trans (pnet np (n1 \\<parallel> n2))", "have \"(s, a, s') \\<in> pnet_sos (trans (pnet np n1)) (trans (pnet np n2))\""], ["proof (prove)\nusing this:\n  (s, a, s') \\<in> automaton.trans (pnet np (n1 \\<parallel> n2))\n\ngoal (1 subgoal):\n 1. (s, a, s')\n    \\<in> pnet_sos (automaton.trans (pnet np n1))\n           (automaton.trans (pnet np n2))", "by simp"], ["proof (state)\nthis:\n  (s, a, s')\n  \\<in> pnet_sos (automaton.trans (pnet np n1))\n         (automaton.trans (pnet np n2))\n\ngoal (1 subgoal):\n 1. \\<And>i d di. a \\<noteq> i:newpkt(d, di)", "thus \"a \\<noteq> i:newpkt(d, di)\""], ["proof (prove)\nusing this:\n  (s, a, s')\n  \\<in> pnet_sos (automaton.trans (pnet np n1))\n         (automaton.trans (pnet np n2))\n\ngoal (1 subgoal):\n 1. a \\<noteq> i:newpkt(d, di)", "by (rule pnet_sos_never_newpkt) (auto dest!: IH1 IH2)"], ["proof (state)\nthis:\n  a \\<noteq> i:newpkt(d, di)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i d di. a \\<noteq> i:newpkt(d, di)\n\ngoal (1 subgoal):\n 1. \\<And>i R s a s'.\n       (s, a, s')\n       \\<in> automaton.trans\n              (pnet np \\<langle>i; R\\<rangle>) \\<Longrightarrow>\n       \\<forall>i d di. a \\<noteq> i:newpkt(d, di)", "qed (simp add: node_comps)"], ["", "lemma pnet_never_newpkt:\n  assumes \"(s, a, s') \\<in> trans (pnet np n)\"\n    shows \"a \\<noteq> i:newpkt(d, di)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> i:newpkt(d, di)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> i:newpkt(d, di)", "from assms"], ["proof (chain)\npicking this:\n  (s, a, s') \\<in> automaton.trans (pnet np n)", "have \"\\<forall>i d di. a \\<noteq> i:newpkt(d, di)\""], ["proof (prove)\nusing this:\n  (s, a, s') \\<in> automaton.trans (pnet np n)\n\ngoal (1 subgoal):\n 1. \\<forall>i d di. a \\<noteq> i:newpkt(d, di)", "by (rule pnet_never_newpkt')"], ["proof (state)\nthis:\n  \\<forall>i d di. a \\<noteq> i:newpkt(d, di)\n\ngoal (1 subgoal):\n 1. a \\<noteq> i:newpkt(d, di)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i d di. a \\<noteq> i:newpkt(d, di)\n\ngoal (1 subgoal):\n 1. a \\<noteq> i:newpkt(d, di)", "by clarsimp"], ["proof (state)\nthis:\n  a \\<noteq> i:newpkt(d, di)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Table 5: Structural operational semantics for complete network expressions \""], ["", "inductive_set\n  cnet_sos :: \"('s, ('m::msg) node_action) transition set\n                    \\<Rightarrow> ('s, 'm node_action) transition set\"\n  for S :: \"('s, 'm node_action) transition set\"\nwhere\n    cnet_connect: \"(s, connect(i, i'), s') \\<in> S  \\<Longrightarrow> (s, connect(i, i'), s') \\<in> cnet_sos S\"\n  | cnet_disconnect: \"(s, disconnect(i, i'), s') \\<in> S  \\<Longrightarrow> (s, disconnect(i, i'), s') \\<in> cnet_sos S\"\n  | cnet_cast: \"(s, R:*cast(m), s') \\<in> S  \\<Longrightarrow> (s, \\<tau>, s') \\<in> cnet_sos S\"\n  | cnet_tau: \"(s, \\<tau>, s') \\<in> S  \\<Longrightarrow> (s, \\<tau>, s') \\<in> cnet_sos S\"\n  | cnet_deliver: \"(s, i:deliver(d), s') \\<in> S  \\<Longrightarrow> (s, i:deliver(d), s') \\<in> cnet_sos S\"\n  | cnet_newpkt: \"(s, {i}\\<not>K:arrive(newpkt(d, di)), s') \\<in> S  \\<Longrightarrow> (s, i:newpkt(d, di), s') \\<in> cnet_sos S\""], ["", "inductive_cases connect_completeTE: \"(s, connect(i, i'), s') \\<in> cnet_sos S\"\n            and disconnect_completeTE: \"(s, disconnect(i, i'), s') \\<in> cnet_sos S\"\n            and tau_completeTE: \"(s, \\<tau>, s') \\<in> cnet_sos S\"\n            and deliver_completeTE: \"(s, i:deliver(d), s') \\<in> cnet_sos S\"\n            and newpkt_completeTE: \"(s, i:newpkt(d, di), s') \\<in> cnet_sos S\""], ["", "lemmas completeTEs = connect_completeTE\n                     disconnect_completeTE\n                     tau_completeTE\n                     deliver_completeTE\n                     newpkt_completeTE"], ["", "lemma complete_no_cast [simp]:\n  \"(s, R:*cast(m), s') \\<notin> cnet_sos T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, R:*cast(m), s') \\<notin> cnet_sos T", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (s, R:*cast(m), s') \\<in> cnet_sos T \\<Longrightarrow> False", "assume \"(s, R:*cast(m), s') \\<in> cnet_sos T\""], ["proof (state)\nthis:\n  (s, R:*cast(m), s') \\<in> cnet_sos T\n\ngoal (1 subgoal):\n 1. (s, R:*cast(m), s') \\<in> cnet_sos T \\<Longrightarrow> False", "hence \"R:*cast(m) \\<noteq> R:*cast(m)\""], ["proof (prove)\nusing this:\n  (s, R:*cast(m), s') \\<in> cnet_sos T\n\ngoal (1 subgoal):\n 1. R:*cast(m) \\<noteq> R:*cast(m)", "by (rule cnet_sos.cases) auto"], ["proof (state)\nthis:\n  R:*cast(m) \\<noteq> R:*cast(m)\n\ngoal (1 subgoal):\n 1. (s, R:*cast(m), s') \\<in> cnet_sos T \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  R:*cast(m) \\<noteq> R:*cast(m)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complete_no_arrive [simp]:\n  \"(s, ii\\<not>ni:arrive(m), s') \\<notin> cnet_sos T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, ii\\<not>ni:arrive(m), s') \\<notin> cnet_sos T", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (s, ii\\<not>ni:arrive(m), s') \\<in> cnet_sos T \\<Longrightarrow> False", "assume \"(s, ii\\<not>ni:arrive(m), s') \\<in> cnet_sos T\""], ["proof (state)\nthis:\n  (s, ii\\<not>ni:arrive(m), s') \\<in> cnet_sos T\n\ngoal (1 subgoal):\n 1. (s, ii\\<not>ni:arrive(m), s') \\<in> cnet_sos T \\<Longrightarrow> False", "hence \"ii\\<not>ni:arrive(m) \\<noteq> ii\\<not>ni:arrive(m)\""], ["proof (prove)\nusing this:\n  (s, ii\\<not>ni:arrive(m), s') \\<in> cnet_sos T\n\ngoal (1 subgoal):\n 1. ii\\<not>ni:arrive(m) \\<noteq> ii\\<not>ni:arrive(m)", "by (rule cnet_sos.cases) auto"], ["proof (state)\nthis:\n  ii\\<not>ni:arrive(m) \\<noteq> ii\\<not>ni:arrive(m)\n\ngoal (1 subgoal):\n 1. (s, ii\\<not>ni:arrive(m), s') \\<in> cnet_sos T \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  ii\\<not>ni:arrive(m) \\<noteq> ii\\<not>ni:arrive(m)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation\n  closed :: \"('s net_state, ('m::msg) node_action) automaton \\<Rightarrow> ('s net_state, 'm node_action) automaton\"\nwhere\n  \"closed \\<equiv> (\\<lambda>A. A \\<lparr> trans := cnet_sos (trans A) \\<rparr>)\""], ["", "end"]]}