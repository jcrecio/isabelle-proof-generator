{"file_name": "/home/qj213/afp-2021-10-22/thys/AWN/Inv_Cterms.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/AWN", "problem_names": ["lemma has_ctermsl: \"p \\<in> ctermsl \\<Gamma> \\<Longrightarrow> p \\<in> ctermsl \\<Gamma>\""], "translations": [["", "lemma has_ctermsl: \"p \\<in> ctermsl \\<Gamma> \\<Longrightarrow> p \\<in> ctermsl \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> ctermsl \\<Gamma> \\<Longrightarrow> p \\<in> ctermsl \\<Gamma>", "."], ["", "named_theorems cterms_elimders \"rules for truncating sequential process terms\""], ["", "named_theorems cterms_seqte \"elimination rules for sequential process terms\""], ["", "named_theorems cterms_env \"simplification rules for sequential process environments\""], ["", "named_theorems ctermsl_cases \"destruction rules for case splitting ctermsl\""], ["", "named_theorems cterms_intros \"introduction rules from cterms\""], ["", "named_theorems cterms_invs \"invariants to try to apply at each vc\""], ["", "named_theorems cterms_final \"elimination rules to try on each vc after simplification\""], ["", "ML \\<open>\nfun simp_only thms ctxt =\n  asm_full_simp_tac\n     (ctxt |> Raw_Simplifier.clear_simpset |> fold Simplifier.add_simp thms)\n\n(* shallow_simp is useful for mopping up assumptions before really trying to simplify.\n   Perhaps surprisingly, this saves minutes in some of the proofs that use a lot of\n   invariants of the form (l = P-:n --> P). *)\nfun shallow_simp ctxt =\n  let val ctxt' = Config.put simp_depth_limit 2 ctxt in\n    TRY o safe_asm_full_simp_tac ctxt'\n  end\n\nfun create_vcs ctxt i =\n  let val main_simp_thms = rev (Named_Theorems.get ctxt @{named_theorems cterms_env})\n      val ctermsl_cases = rev (Named_Theorems.get ctxt @{named_theorems ctermsl_cases})\n  in\n    dresolve_tac ctxt @{thms has_ctermsl} i\n    THEN_ELSE (dmatch_tac ctxt ctermsl_cases i\n               THEN\n               TRY (REPEAT_ALL_NEW (ematch_tac ctxt [@{thm disjE}]) i)\n               THEN\n               PARALLEL_ALLGOALS\n                 (fn i => simp_only main_simp_thms ctxt i\n                  THEN TRY (REPEAT_ALL_NEW (ematch_tac ctxt [@{thm disjE}]) i)), all_tac)\n  end\n\nfun try_invs ctxt =\n  let val inv_thms = rev (Named_Theorems.get ctxt @{named_theorems cterms_invs})\n      fun fapp thm =\n        TRY o (EVERY' (forward_tac ctxt [thm] :: replicate (Thm.nprems_of thm - 1) (assume_tac ctxt)))\n  in\n    EVERY' (map fapp inv_thms)\n  end\n\nfun try_final ctxt =\n  let val final_thms = rev (Named_Theorems.get ctxt @{named_theorems cterms_final})\n      fun eapp thm = EVERY' (eresolve_tac ctxt [thm] :: replicate (Thm.nprems_of thm - 1) (assume_tac ctxt))\n  in\n    TRY o (FIRST' (map eapp final_thms))\n  end\n\nfun each ctxt =\n  (EVERY' ((ematch_tac ctxt (rev (Named_Theorems.get ctxt @{named_theorems cterms_elimders})) ::\n    replicate 2 (assume_tac ctxt)))\n   THEN' simp_only @{thms labels_psimps} ctxt\n   THEN' (ematch_tac ctxt (rev (Named_Theorems.get ctxt @{named_theorems cterms_seqte}))\n     THEN_ALL_NEW\n       (fn j => simp_only [@{thm mem_Collect_eq}] ctxt j\n                  THEN REPEAT (eresolve_tac ctxt @{thms exE} j)\n                  THEN REPEAT (eresolve_tac ctxt @{thms conjE} j))))\n  ORELSE' (SOLVED' (clarsimp_tac ctxt))\n\nfun simp_all ctxt =\n  let val ctxt' =\n        ctxt |> fold Splitter.add_split [@{thm if_split_asm}]\n  in\n    PARALLEL_ALLGOALS (shallow_simp ctxt)\n    THEN\n    TRY (CHANGED_PROP (PARALLEL_ALLGOALS (asm_full_simp_tac ctxt' THEN' try_final ctxt)))\n  end\n\nfun intro_and_invs ctxt i =\n  let val cterms_intros = rev (Named_Theorems.get ctxt @{named_theorems cterms_intros}) in\n    match_tac ctxt cterms_intros i\n    THEN PARALLEL_ALLGOALS (try_invs ctxt)\n  end\n\nfun process_vcs ctxt _ =\n  ALLGOALS (create_vcs ctxt ORELSE' (SOLVED' (clarsimp_tac ctxt)))\n  THEN PARALLEL_ALLGOALS (TRY o each ctxt)\n\\<close>"], ["", "method_setup inv_cterms = \\<open>\n  let\n    val intro_onlyN = \"intro_only\"\n    val vcs_onlyN = \"vcs_only\"\n    val invN = \"inv\"\n    val solveN = \"solve\"\n\n    val inv_cterms_options =\n      (Args.parens (Args.$$$ intro_onlyN) >>  K intro_and_invs ||\n       Args.parens (Args.$$$ vcs_onlyN) >>  K (fn ctxt => intro_and_invs ctxt\n                                                          THEN' process_vcs ctxt) ||\n       Scan.succeed (fn ctxt => intro_and_invs ctxt\n                                THEN' process_vcs ctxt\n                                THEN' K (simp_all ctxt)))\n  in\n    (Scan.lift inv_cterms_options --| Method.sections\n      ((Args.$$$ invN -- Args.add -- Args.colon >>\n        K (Method.modifier (Named_Theorems.add @{named_theorems cterms_invs}) \\<^here>))\n       :: (Args.$$$ solveN -- Args.colon >>\n        K (Method.modifier (Named_Theorems.add @{named_theorems cterms_final}) \\<^here>))\n       :: Simplifier.simp_modifiers)\n      >> (fn tac => SIMPLE_METHOD' o tac))\n  end\n\\<close> \"solve invariants by considering all (interesting) control terms\""], ["", "declare\n  insert_iff [cterms_env]                                                \n  Un_insert_right [cterms_env]\n  sup_bot_right [cterms_env]\n  Product_Type.prod_cases [cterms_env]\n  ctermsl.simps [cterms_env]"], ["", "end"]]}