{"file_name": "/home/qj213/afp-2021-10-22/thys/AWN/OAWN_SOS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/AWN", "problem_names": ["lemma oseq_broadcastTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, {l}broadcast(s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i;\n    \\<lbrakk>a = broadcast (s\\<^sub>m\\<^sub>s\\<^sub>g (\\<sigma> i)); \\<sigma>' i = \\<sigma> i; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma oseq_groupcastTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, {l}groupcast(s\\<^sub>i\\<^sub>p\\<^sub>s, s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i;\n    \\<lbrakk>a = groupcast (s\\<^sub>i\\<^sub>p\\<^sub>s (\\<sigma> i)) (s\\<^sub>m\\<^sub>s\\<^sub>g (\\<sigma> i)); \\<sigma>' i = \\<sigma> i; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma oseq_unicastTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, {l}unicast(s\\<^sub>i\\<^sub>p, s\\<^sub>m\\<^sub>s\\<^sub>g). p \\<triangleright> q), a, (\\<sigma>', r)) \\<in> oseqp_sos \\<Gamma> i;\n    \\<lbrakk>a = unicast (s\\<^sub>i\\<^sub>p (\\<sigma> i)) (s\\<^sub>m\\<^sub>s\\<^sub>g (\\<sigma> i)); \\<sigma>' i = \\<sigma> i; r = p\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>a = \\<not>unicast (s\\<^sub>i\\<^sub>p (\\<sigma> i)); \\<sigma>' i = \\<sigma> i; r = q\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma oseq_sendTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, {l}send(s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i;\n    \\<lbrakk>a = send (s\\<^sub>m\\<^sub>s\\<^sub>g (\\<sigma> i)); \\<sigma>' i = \\<sigma> i; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma oseq_deliverTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, {l}deliver(s\\<^sub>d\\<^sub>a\\<^sub>t\\<^sub>a). p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i;\n    \\<lbrakk>a = deliver (s\\<^sub>d\\<^sub>a\\<^sub>t\\<^sub>a (\\<sigma> i)); \\<sigma>' i = \\<sigma> i; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma oseq_receiveTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, {l}receive(u\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i;\n    \\<And>msg. \\<lbrakk>a = receive msg; \\<sigma>' i = u\\<^sub>m\\<^sub>s\\<^sub>g msg (\\<sigma> i); q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma oseq_assignTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, {l}\\<lbrakk>u\\<rbrakk> p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i; \\<lbrakk>a = \\<tau>; \\<sigma>' i = u (\\<sigma> i); q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma oseq_guardTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, {l}\\<langle>g\\<rangle> p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i; \\<lbrakk>a = \\<tau>; \\<sigma>' i \\<in> g (\\<sigma> i); q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemmas oseqpTEs =\n  oseq_broadcastTE\n  oseq_groupcastTE\n  oseq_unicastTE\n  oseq_sendTE\n  oseq_deliverTE\n  oseq_receiveTE\n  oseq_assignTE\n  oseq_callTE\n  oseq_choiceTE\n  oseq_guardTE", "lemma opar_broadcastTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, (s, t)), broadcast m, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T;\n    \\<lbrakk>((\\<sigma>, s), broadcast m, (\\<sigma>', s')) \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, broadcast m, t') \\<in> T; s' = s; \\<sigma>' i = \\<sigma> i\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma opar_groupcastTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, (s, t)), groupcast ips m, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T;\n    \\<lbrakk>((\\<sigma>, s), groupcast ips m, (\\<sigma>', s')) \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, groupcast ips m, t') \\<in> T; s' = s; \\<sigma>' i = \\<sigma> i\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma opar_unicastTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, (s, t)), unicast i m, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T;\n    \\<lbrakk>((\\<sigma>, s), unicast i m, (\\<sigma>', s')) \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, unicast i m, t') \\<in> T; s' = s; \\<sigma>' i = \\<sigma> i\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma opar_notunicastTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, (s, t)), notunicast i, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T;\n    \\<lbrakk>((\\<sigma>, s), notunicast i, (\\<sigma>', s')) \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, notunicast i, t') \\<in> T; s' = s; \\<sigma>' i = \\<sigma> i\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma opar_sendTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, (s, t)), send m, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T;\n    \\<lbrakk>((\\<sigma>, s), send m, (\\<sigma>', s')) \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma opar_deliverTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, (s, t)), deliver d, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T;\n    \\<lbrakk>((\\<sigma>, s), deliver d, (\\<sigma>', s')) \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, deliver d, t') \\<in> T; s' = s; \\<sigma>' i = \\<sigma> i\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma opar_receiveTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, (s, t)), receive m, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T;\n    \\<lbrakk>(t, receive m, t') \\<in> T; s' = s; \\<sigma>' i = \\<sigma> i\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemmas oparpTEs =\n  opar_broadcastTE\n  opar_groupcastTE\n  opar_unicastTE\n  opar_notunicastTE\n  opar_sendTE\n  opar_deliverTE\n  opar_receiveTE", "lemma oparp_sos_cases [elim]:\n  assumes \"((\\<sigma>, (s, t)), a, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T\"\n      and \"\\<lbrakk> ((\\<sigma>, s), a, (\\<sigma>', s')) \\<in> S; \\<And>m. a \\<noteq> receive m; t' = t \\<rbrakk> \\<Longrightarrow> P\"\n      and \"\\<lbrakk> (t, a, t') \\<in> T; \\<And>m. a \\<noteq> send m; s' = s; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> P\"\n      and \"\\<And>m. \\<lbrakk> a = \\<tau>; ((\\<sigma>, s), receive m, (\\<sigma>', s')) \\<in> S; (t, send m, t') \\<in> T \\<rbrakk> \\<Longrightarrow> P\"\n    shows \"P\"", "lemma extgsimp [simp]:\n  \"extg ((\\<sigma>, l1), l2) = (\\<sigma>, (l1, l2))\"", "lemma extg_range_prod: \"extg ` (i1 \\<times> i2) = {(\\<sigma>, (s1, s2))|\\<sigma> s1 s2. (\\<sigma>, s1) \\<in> i1 \\<and> s2 \\<in> i2}\"", "lemma opar_comp_def':\n  \"s \\<langle>\\<langle>\\<^bsub>i\\<^esub> t = \\<lparr> init = {(\\<sigma>, (s\\<^sub>l, t\\<^sub>l))|\\<sigma> s\\<^sub>l t\\<^sub>l. (\\<sigma>, s\\<^sub>l) \\<in> init s \\<and> t\\<^sub>l \\<in> init t},\n                trans = oparp_sos i (trans s) (trans t) \\<rparr>\"", "lemma trans_opar_comp [simp]:\n  \"trans (s \\<langle>\\<langle>\\<^bsub>i\\<^esub> t) = oparp_sos i (trans s) (trans t)\"", "lemma init_opar_comp [simp]:\n  \"init (s \\<langle>\\<langle>\\<^bsub>i\\<^esub> t) = extg ` (init s \\<times> init t)\"", "lemma oarrives_or_not:\n  assumes \"((\\<sigma>, NodeS i s R), ii\\<not>ni:arrive(m), (\\<sigma>', NodeS i' s' R')) \\<in> onode_sos S\"\n    shows \"(ii = {i} \\<and> ni = {}) \\<or> (ii = {} \\<and> ni = {i})\"", "lemma trans_onode_comp:\n  \"trans (\\<langle>i : S : R\\<rangle>\\<^sub>o) = onode_sos (trans S)\"", "lemma init_onode_comp:\n  \"init (\\<langle>i : S : R\\<rangle>\\<^sub>o) = {(\\<sigma>, NodeS i s R)|\\<sigma> s. (\\<sigma>, s) \\<in> init S}\"", "lemmas onode_comps = trans_onode_comp init_onode_comp", "lemma fst_par_onode_comp [simp]:\n  \"trans (\\<langle>i : s \\<langle>\\<langle>\\<^bsub>I\\<^esub> t : R\\<rangle>\\<^sub>o) = onode_sos (oparp_sos I (trans s) (trans t))\"", "lemma init_par_onode_comp [simp]:\n  \"init (\\<langle>i : s \\<langle>\\<langle>\\<^bsub>I\\<^esub> t : R\\<rangle>\\<^sub>o) = {(\\<sigma>, NodeS i (s1, s2) R)|\\<sigma> s1 s2. ((\\<sigma>, s1), s2) \\<in> init s \\<times> init t}\"", "lemma onode_sos_dest_is_net_state:\n  assumes \"((\\<sigma>, p), a, s') \\<in> onode_sos S\"\n    shows \"\\<exists>\\<sigma>' i' \\<zeta>' R'. s' = (\\<sigma>', NodeS i' \\<zeta>' R')\"", "lemma onode_sos_dest_is_net_state':\n  assumes \"((\\<sigma>, NodeS i p R), a, s') \\<in> onode_sos S\"\n    shows \"\\<exists>\\<sigma>' \\<zeta>' R'. s' = (\\<sigma>', NodeS i \\<zeta>' R')\"", "lemma onode_sos_dest_is_net_state'':\n  assumes \"((\\<sigma>, NodeS i p R), a, (\\<sigma>', s')) \\<in> onode_sos S\"\n    shows \"\\<exists>\\<zeta>' R'. s' = NodeS i \\<zeta>' R'\"", "lemma onode_sos_src_is_net_state:\n  assumes \"((\\<sigma>, p), a, s') \\<in> onode_sos S\"\n    shows \"\\<exists>i \\<zeta> R. p = NodeS i \\<zeta> R\"", "lemma onode_sos_net_states:\n  assumes \"((\\<sigma>, s), a, (\\<sigma>', s')) \\<in> onode_sos S\"\n    shows \"\\<exists>i \\<zeta> R \\<zeta>' R'. s = NodeS i \\<zeta> R \\<and> s' = NodeS i \\<zeta>' R'\"", "lemma node_sos_cases [elim]:\n  \"((\\<sigma>, NodeS i p R), a, (\\<sigma>', NodeS i p' R')) \\<in> onode_sos S \\<Longrightarrow>\n  (\\<And>m .       \\<lbrakk> a = R:*cast(m);          R' = R; ((\\<sigma>, p), broadcast m,   (\\<sigma>', p')) \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>m D.      \\<lbrakk> a = (R \\<inter> D):*cast(m);    R' = R; ((\\<sigma>, p), groupcast D m, (\\<sigma>', p')) \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>d m.      \\<lbrakk> a = {d}:*cast(m);        R' = R; ((\\<sigma>, p), unicast d m,   (\\<sigma>', p')) \\<in> S; d \\<in> R \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>d.        \\<lbrakk> a = \\<tau>;                   R' = R; ((\\<sigma>, p), \\<not>unicast d,    (\\<sigma>', p')) \\<in> S; d \\<notin> R \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>d.        \\<lbrakk> a = i:deliver(d);        R' = R; ((\\<sigma>, p), deliver d,     (\\<sigma>', p')) \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>m.        \\<lbrakk> a = {i}\\<not>{}:arrive(m);    R' = R; ((\\<sigma>, p), receive m,     (\\<sigma>', p')) \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (            \\<lbrakk> a = \\<tau>;                   R' = R; ((\\<sigma>, p), \\<tau>,             (\\<sigma>', p')) \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>m.        \\<lbrakk> a = {}\\<not>{i}:arrive(m);    R' = R; p = p'; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i'.     \\<lbrakk> a = connect(i, i');      R' = R \\<union> {i'}; p = p'; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i'.     \\<lbrakk> a = connect(i', i);      R' = R \\<union> {i'}; p = p'; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i'.     \\<lbrakk> a = disconnect(i, i');   R' = R - {i'}; p = p'; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i'.     \\<lbrakk> a = disconnect(i', i);   R' = R - {i'}; p = p'; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i' i''. \\<lbrakk> a = connect(i', i'');    R' = R; p = p'; i \\<noteq> i'; i \\<noteq> i''; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i' i''. \\<lbrakk> a = disconnect(i', i''); R' = R; p = p'; i \\<noteq> i'; i \\<noteq> i''; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  P\"", "lemma opnet_node_init [elim, simp]:\n  assumes \"(\\<sigma>, s) \\<in> init (opnet onp \\<langle>i; R\\<rangle>)\"\n    shows \"(\\<sigma>, s) \\<in> { (\\<sigma>, NodeS i ns R) |\\<sigma> ns. (\\<sigma>, ns) \\<in> init (onp i)}\"", "lemma opnet_node_init' [elim]:\n assumes \"(\\<sigma>, s) \\<in> init (opnet onp \\<langle>i; R\\<rangle>)\"\n obtains ns where \"s = NodeS i ns R\"\n             and \"(\\<sigma>, ns) \\<in> init (onp i)\"", "lemma opnet_node_trans [elim, simp]:\n  assumes \"(s, a, s') \\<in> trans (opnet onp \\<langle>i; R\\<rangle>)\"\n    shows \"(s, a, s') \\<in> onode_sos (trans (onp i))\"", "lemmas ocompleteTEs = oconnect_completeTE\n                      odisconnect_completeTE\n                      otau_completeTE\n                      odeliver_completeTE\n                      onewpkt_completeTE", "lemma ocomplete_no_cast [simp]:\n  \"((\\<sigma>, s), R:*cast(m), (\\<sigma>', s')) \\<notin> ocnet_sos T\"", "lemma ocomplete_no_arrive [simp]:\n  \"((\\<sigma>, s), ii\\<not>ni:arrive(m), (\\<sigma>', s')) \\<notin> ocnet_sos T\"", "lemma ocomplete_no_change [elim]:\n  assumes \"((\\<sigma>, s), a, (\\<sigma>', s')) \\<in> ocnet_sos T\"\n      and \"j \\<notin> net_ips s\"\n    shows \"\\<sigma>' j = \\<sigma> j\"", "lemma ocomplete_transE [elim]:\n  assumes \"((\\<sigma>, \\<zeta>), a, (\\<sigma>', \\<zeta>')) \\<in> ocnet_sos (trans (opnet onp n))\"\n  obtains a' where \"((\\<sigma>, \\<zeta>), a', (\\<sigma>', \\<zeta>')) \\<in> trans (opnet onp n)\""], "translations": [["", "lemma oseq_broadcastTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, {l}broadcast(s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i;\n    \\<lbrakk>a = broadcast (s\\<^sub>m\\<^sub>s\\<^sub>g (\\<sigma> i)); \\<sigma>' i = \\<sigma> i; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<sigma>, {l}broadcast(s\\<^sub>m\\<^sub>s\\<^sub>g) .\n               p),\n              a, \\<sigma>', q)\n             \\<in> oseqp_sos \\<Gamma> i;\n     \\<lbrakk>a = broadcast (s\\<^sub>m\\<^sub>s\\<^sub>g (\\<sigma> i));\n      \\<sigma>' i = \\<sigma> i; q = p\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<sigma>, {l}broadcast(s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i\") simp"], ["", "lemma oseq_groupcastTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, {l}groupcast(s\\<^sub>i\\<^sub>p\\<^sub>s, s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i;\n    \\<lbrakk>a = groupcast (s\\<^sub>i\\<^sub>p\\<^sub>s (\\<sigma> i)) (s\\<^sub>m\\<^sub>s\\<^sub>g (\\<sigma> i)); \\<sigma>' i = \\<sigma> i; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<sigma>,\n               {l}groupcast(s\\<^sub>i\\<^sub>p\\<^sub>s,\n                             s\\<^sub>m\\<^sub>s\\<^sub>g) .\n               p),\n              a, \\<sigma>', q)\n             \\<in> oseqp_sos \\<Gamma> i;\n     \\<lbrakk>a =\n              groupcast (s\\<^sub>i\\<^sub>p\\<^sub>s (\\<sigma> i))\n               (s\\<^sub>m\\<^sub>s\\<^sub>g (\\<sigma> i));\n      \\<sigma>' i = \\<sigma> i; q = p\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<sigma>, {l}groupcast(s\\<^sub>i\\<^sub>p\\<^sub>s, s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i\") simp"], ["", "lemma oseq_unicastTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, {l}unicast(s\\<^sub>i\\<^sub>p, s\\<^sub>m\\<^sub>s\\<^sub>g). p \\<triangleright> q), a, (\\<sigma>', r)) \\<in> oseqp_sos \\<Gamma> i;\n    \\<lbrakk>a = unicast (s\\<^sub>i\\<^sub>p (\\<sigma> i)) (s\\<^sub>m\\<^sub>s\\<^sub>g (\\<sigma> i)); \\<sigma>' i = \\<sigma> i; r = p\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>a = \\<not>unicast (s\\<^sub>i\\<^sub>p (\\<sigma> i)); \\<sigma>' i = \\<sigma> i; r = q\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<sigma>,\n               {l}unicast(s\\<^sub>i\\<^sub>p, s\\<^sub>m\\<^sub>s\\<^sub>g) .\n                  p \\<triangleright> q),\n              a, \\<sigma>', r)\n             \\<in> oseqp_sos \\<Gamma> i;\n     \\<lbrakk>a =\n              unicast (s\\<^sub>i\\<^sub>p (\\<sigma> i))\n               (s\\<^sub>m\\<^sub>s\\<^sub>g (\\<sigma> i));\n      \\<sigma>' i = \\<sigma> i; r = p\\<rbrakk>\n     \\<Longrightarrow> P;\n     \\<lbrakk>a = \\<not>unicast (s\\<^sub>i\\<^sub>p (\\<sigma> i));\n      \\<sigma>' i = \\<sigma> i; r = q\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<sigma>, {l}unicast(s\\<^sub>i\\<^sub>p, s\\<^sub>m\\<^sub>s\\<^sub>g). p \\<triangleright> q), a, (\\<sigma>', r)) \\<in> oseqp_sos \\<Gamma> i\") simp_all"], ["", "lemma oseq_sendTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, {l}send(s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i;\n    \\<lbrakk>a = send (s\\<^sub>m\\<^sub>s\\<^sub>g (\\<sigma> i)); \\<sigma>' i = \\<sigma> i; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<sigma>, {l}send(s\\<^sub>m\\<^sub>s\\<^sub>g) .\n               p),\n              a, \\<sigma>', q)\n             \\<in> oseqp_sos \\<Gamma> i;\n     \\<lbrakk>a = send (s\\<^sub>m\\<^sub>s\\<^sub>g (\\<sigma> i));\n      \\<sigma>' i = \\<sigma> i; q = p\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<sigma>, {l}send(s\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i\") simp"], ["", "lemma oseq_deliverTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, {l}deliver(s\\<^sub>d\\<^sub>a\\<^sub>t\\<^sub>a). p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i;\n    \\<lbrakk>a = deliver (s\\<^sub>d\\<^sub>a\\<^sub>t\\<^sub>a (\\<sigma> i)); \\<sigma>' i = \\<sigma> i; q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<sigma>, {l}deliver(s\\<^sub>d\\<^sub>a\\<^sub>t\\<^sub>a) .\n               p),\n              a, \\<sigma>', q)\n             \\<in> oseqp_sos \\<Gamma> i;\n     \\<lbrakk>a = deliver (s\\<^sub>d\\<^sub>a\\<^sub>t\\<^sub>a (\\<sigma> i));\n      \\<sigma>' i = \\<sigma> i; q = p\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<sigma>, {l}deliver(s\\<^sub>d\\<^sub>a\\<^sub>t\\<^sub>a). p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i\") simp"], ["", "lemma oseq_receiveTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, {l}receive(u\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i;\n    \\<And>msg. \\<lbrakk>a = receive msg; \\<sigma>' i = u\\<^sub>m\\<^sub>s\\<^sub>g msg (\\<sigma> i); q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<sigma>, {l}receive(u\\<^sub>m\\<^sub>s\\<^sub>g) .\n               p),\n              a, \\<sigma>', q)\n             \\<in> oseqp_sos \\<Gamma> i;\n     \\<And>msg.\n        \\<lbrakk>a = receive msg;\n         \\<sigma>' i = u\\<^sub>m\\<^sub>s\\<^sub>g msg (\\<sigma> i);\n         q = p\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<sigma>, {l}receive(u\\<^sub>m\\<^sub>s\\<^sub>g). p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i\") simp"], ["", "lemma oseq_assignTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, {l}\\<lbrakk>u\\<rbrakk> p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i; \\<lbrakk>a = \\<tau>; \\<sigma>' i = u (\\<sigma> i); q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<sigma>, {l}\\<lbrakk>u\\<rbrakk>\n               p),\n              a, \\<sigma>', q)\n             \\<in> oseqp_sos \\<Gamma> i;\n     \\<lbrakk>a = \\<tau>; \\<sigma>' i = u (\\<sigma> i); q = p\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<sigma>, {l}\\<lbrakk>u\\<rbrakk> p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i\") simp"], ["", "lemma oseq_guardTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, {l}\\<langle>g\\<rangle> p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i; \\<lbrakk>a = \\<tau>; \\<sigma>' i \\<in> g (\\<sigma> i); q = p\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<sigma>, {l}\\<langle>g\\<rangle>\n               p),\n              a, \\<sigma>', q)\n             \\<in> oseqp_sos \\<Gamma> i;\n     \\<lbrakk>a = \\<tau>; \\<sigma>' i \\<in> g (\\<sigma> i); q = p\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<sigma>, {l}\\<langle>g\\<rangle> p), a, (\\<sigma>', q)) \\<in> oseqp_sos \\<Gamma> i\") simp"], ["", "lemmas oseqpTEs =\n  oseq_broadcastTE\n  oseq_groupcastTE\n  oseq_unicastTE\n  oseq_sendTE\n  oseq_deliverTE\n  oseq_receiveTE\n  oseq_assignTE\n  oseq_callTE\n  oseq_choiceTE\n  oseq_guardTE"], ["", "declare oseqp_sos.intros [intro]"], ["", "subsection \"Open structural operational semantics for parallel process expressions \""], ["", "inductive_set\n  oparp_sos :: \"ip\n               \\<Rightarrow> ((ip \\<Rightarrow> 's) \\<times> 's1, 'm seq_action) transition set\n               \\<Rightarrow> ('s2, 'm seq_action) transition set\n               \\<Rightarrow> ((ip \\<Rightarrow> 's) \\<times> ('s1 \\<times> 's2), 'm seq_action) transition set\"\n  for i :: ip\n  and S :: \"((ip \\<Rightarrow> 's) \\<times> 's1, 'm seq_action) transition set\"\n  and T :: \"('s2, 'm seq_action) transition set\"\nwhere\n    oparleft:  \"\\<lbrakk> ((\\<sigma>, s), a, (\\<sigma>', s')) \\<in> S; \\<And>m. a \\<noteq> receive m \\<rbrakk> \\<Longrightarrow>\n                ((\\<sigma>, (s, t)), a, (\\<sigma>', (s', t))) \\<in> oparp_sos i S T\"\n  | oparright: \"\\<lbrakk> (t, a, t') \\<in> T; \\<And>m. a \\<noteq> send m; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow>\n                ((\\<sigma>, (s, t)), a, (\\<sigma>', (s, t'))) \\<in> oparp_sos i S T\"\n  | oparboth:  \"\\<lbrakk> ((\\<sigma>, s), receive m, (\\<sigma>', s')) \\<in> S; (t, send m, t') \\<in> T \\<rbrakk> \\<Longrightarrow>\n                ((\\<sigma>, (s, t)), \\<tau>, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T\""], ["", "lemma opar_broadcastTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, (s, t)), broadcast m, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T;\n    \\<lbrakk>((\\<sigma>, s), broadcast m, (\\<sigma>', s')) \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, broadcast m, t') \\<in> T; s' = s; \\<sigma>' i = \\<sigma> i\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<sigma>, s, t), broadcast m, \\<sigma>', s', t')\n             \\<in> oparp_sos i S T;\n     \\<lbrakk>((\\<sigma>, s), broadcast m, \\<sigma>', s') \\<in> S;\n      t' = t\\<rbrakk>\n     \\<Longrightarrow> P;\n     \\<lbrakk>(t, broadcast m, t') \\<in> T; s' = s;\n      \\<sigma>' i = \\<sigma> i\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<sigma>, (s, t)), broadcast m, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T\") simp_all"], ["", "lemma opar_groupcastTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, (s, t)), groupcast ips m, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T;\n    \\<lbrakk>((\\<sigma>, s), groupcast ips m, (\\<sigma>', s')) \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, groupcast ips m, t') \\<in> T; s' = s; \\<sigma>' i = \\<sigma> i\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<sigma>, s, t), groupcast ips m, \\<sigma>', s', t')\n             \\<in> oparp_sos i S T;\n     \\<lbrakk>((\\<sigma>, s), groupcast ips m, \\<sigma>', s') \\<in> S;\n      t' = t\\<rbrakk>\n     \\<Longrightarrow> P;\n     \\<lbrakk>(t, groupcast ips m, t') \\<in> T; s' = s;\n      \\<sigma>' i = \\<sigma> i\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<sigma>, (s, t)), groupcast ips m, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T\") simp_all"], ["", "lemma opar_unicastTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, (s, t)), unicast i m, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T;\n    \\<lbrakk>((\\<sigma>, s), unicast i m, (\\<sigma>', s')) \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, unicast i m, t') \\<in> T; s' = s; \\<sigma>' i = \\<sigma> i\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<sigma>, s, t), unicast i m, \\<sigma>', s', t')\n             \\<in> oparp_sos i S T;\n     \\<lbrakk>((\\<sigma>, s), unicast i m, \\<sigma>', s') \\<in> S;\n      t' = t\\<rbrakk>\n     \\<Longrightarrow> P;\n     \\<lbrakk>(t, unicast i m, t') \\<in> T; s' = s;\n      \\<sigma>' i = \\<sigma> i\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<sigma>, (s, t)), unicast i m, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T\") simp_all"], ["", "lemma opar_notunicastTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, (s, t)), notunicast i, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T;\n    \\<lbrakk>((\\<sigma>, s), notunicast i, (\\<sigma>', s')) \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, notunicast i, t') \\<in> T; s' = s; \\<sigma>' i = \\<sigma> i\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<sigma>, s, t), \\<not>unicast i, \\<sigma>', s', t')\n             \\<in> oparp_sos i S T;\n     \\<lbrakk>((\\<sigma>, s), \\<not>unicast i, \\<sigma>', s') \\<in> S;\n      t' = t\\<rbrakk>\n     \\<Longrightarrow> P;\n     \\<lbrakk>(t, \\<not>unicast i, t') \\<in> T; s' = s;\n      \\<sigma>' i = \\<sigma> i\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<sigma>, (s, t)), notunicast i, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T\") simp_all"], ["", "lemma opar_sendTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, (s, t)), send m, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T;\n    \\<lbrakk>((\\<sigma>, s), send m, (\\<sigma>', s')) \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<sigma>, s, t), send m, \\<sigma>', s', t')\n             \\<in> oparp_sos i S T;\n     \\<lbrakk>((\\<sigma>, s), send m, \\<sigma>', s') \\<in> S;\n      t' = t\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<sigma>, (s, t)), send m, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T\") auto"], ["", "lemma opar_deliverTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, (s, t)), deliver d, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T;\n    \\<lbrakk>((\\<sigma>, s), deliver d, (\\<sigma>', s')) \\<in> S; t' = t\\<rbrakk> \\<Longrightarrow> P;\n    \\<lbrakk>(t, deliver d, t') \\<in> T; s' = s; \\<sigma>' i = \\<sigma> i\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<sigma>, s, t), deliver d, \\<sigma>', s', t')\n             \\<in> oparp_sos i S T;\n     \\<lbrakk>((\\<sigma>, s), deliver d, \\<sigma>', s') \\<in> S;\n      t' = t\\<rbrakk>\n     \\<Longrightarrow> P;\n     \\<lbrakk>(t, deliver d, t') \\<in> T; s' = s;\n      \\<sigma>' i = \\<sigma> i\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<sigma>, (s, t)), deliver d, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T\") simp_all"], ["", "lemma opar_receiveTE [elim]:\n  \"\\<lbrakk>((\\<sigma>, (s, t)), receive m, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T;\n    \\<lbrakk>(t, receive m, t') \\<in> T; s' = s; \\<sigma>' i = \\<sigma> i\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<sigma>, s, t), receive m, \\<sigma>', s', t')\n             \\<in> oparp_sos i S T;\n     \\<lbrakk>(t, receive m, t') \\<in> T; s' = s;\n      \\<sigma>' i = \\<sigma> i\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (ind_cases \"((\\<sigma>, (s, t)), receive m, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T\") auto"], ["", "inductive_cases opar_tauTE: \"((\\<sigma>, (s, t)), \\<tau>, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T\""], ["", "lemmas oparpTEs =\n  opar_broadcastTE\n  opar_groupcastTE\n  opar_unicastTE\n  opar_notunicastTE\n  opar_sendTE\n  opar_deliverTE\n  opar_receiveTE"], ["", "lemma oparp_sos_cases [elim]:\n  assumes \"((\\<sigma>, (s, t)), a, (\\<sigma>', (s', t'))) \\<in> oparp_sos i S T\"\n      and \"\\<lbrakk> ((\\<sigma>, s), a, (\\<sigma>', s')) \\<in> S; \\<And>m. a \\<noteq> receive m; t' = t \\<rbrakk> \\<Longrightarrow> P\"\n      and \"\\<lbrakk> (t, a, t') \\<in> T; \\<And>m. a \\<noteq> send m; s' = s; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> P\"\n      and \"\\<And>m. \\<lbrakk> a = \\<tau>; ((\\<sigma>, s), receive m, (\\<sigma>', s')) \\<in> S; (t, send m, t') \\<in> T \\<rbrakk> \\<Longrightarrow> P\"\n    shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  ((\\<sigma>, s, t), a, \\<sigma>', s', t') \\<in> oparp_sos i S T\n  \\<lbrakk>((\\<sigma>, s), a, \\<sigma>', s') \\<in> S;\n   \\<And>m. a \\<noteq> receive m; t' = t\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>(t, a, t') \\<in> T; \\<And>m. a \\<noteq> send m; s' = s;\n   \\<sigma>' i = \\<sigma> i\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>a = \\<tau>; ((\\<sigma>, s), receive ?m, \\<sigma>', s') \\<in> S;\n   (t, send ?m, t') \\<in> T\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by cases auto"], ["", "definition extg :: \"('a \\<times> 'b) \\<times> 'c \\<Rightarrow> 'a \\<times> 'b \\<times> 'c\"\nwhere \"extg \\<equiv> \\<lambda>((\\<sigma>, l1), l2). (\\<sigma>, (l1, l2))\""], ["", "lemma extgsimp [simp]:\n  \"extg ((\\<sigma>, l1), l2) = (\\<sigma>, (l1, l2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extg ((\\<sigma>, l1), l2) = (\\<sigma>, l1, l2)", "unfolding extg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ((\\<sigma>, l1), l2) of\n     (x, xa) \\<Rightarrow>\n       (case x of\n        (\\<sigma>, l1) \\<Rightarrow> \\<lambda>l2. (\\<sigma>, l1, l2))\n        xa) =\n    (\\<sigma>, l1, l2)", "by simp"], ["", "lemma extg_range_prod: \"extg ` (i1 \\<times> i2) = {(\\<sigma>, (s1, s2))|\\<sigma> s1 s2. (\\<sigma>, s1) \\<in> i1 \\<and> s2 \\<in> i2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extg ` (i1 \\<times> i2) =\n    {(\\<sigma>, s1, s2) |\\<sigma> s1 s2.\n     (\\<sigma>, s1) \\<in> i1 \\<and> s2 \\<in> i2}", "unfolding image_def extg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>i1 \\<times> i2.\n           y =\n           (case x of\n            (x, xa) \\<Rightarrow>\n              (case x of\n               (\\<sigma>, l1) \\<Rightarrow> \\<lambda>l2. (\\<sigma>, l1, l2))\n               xa)} =\n    {(\\<sigma>, s1, s2) |\\<sigma> s1 s2.\n     (\\<sigma>, s1) \\<in> i1 \\<and> s2 \\<in> i2}", "by (rule Collect_cong) (auto split: prod.split)"], ["", "definition\n  opar_comp :: \"((ip \\<Rightarrow> 's) \\<times> 's1, 'm seq_action) automaton\n               \\<Rightarrow> ip\n               \\<Rightarrow> ('s2, 'm seq_action) automaton\n               \\<Rightarrow> ((ip \\<Rightarrow> 's) \\<times> 's1 \\<times> 's2, 'm seq_action) automaton\"\n  (\"(_ \\<langle>\\<langle>\\<^bsub>_\\<^esub> _)\" [102, 0, 103] 102)\nwhere\n  \"s \\<langle>\\<langle>\\<^bsub>i\\<^esub> t \\<equiv> \\<lparr> init = extg ` (init s \\<times> init t), trans = oparp_sos i (trans s) (trans t) \\<rparr>\""], ["", "lemma opar_comp_def':\n  \"s \\<langle>\\<langle>\\<^bsub>i\\<^esub> t = \\<lparr> init = {(\\<sigma>, (s\\<^sub>l, t\\<^sub>l))|\\<sigma> s\\<^sub>l t\\<^sub>l. (\\<sigma>, s\\<^sub>l) \\<in> init s \\<and> t\\<^sub>l \\<in> init t},\n                trans = oparp_sos i (trans s) (trans t) \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<langle>\\<langle>\\<^bsub>i\\<^esub> t =\n    \\<lparr>init =\n              {(\\<sigma>, s\\<^sub>l, t\\<^sub>l) |\\<sigma> s\\<^sub>l\n               t\\<^sub>l.\n               (\\<sigma>, s\\<^sub>l) \\<in> init s \\<and>\n               t\\<^sub>l \\<in> init t},\n       trans = oparp_sos i (automaton.trans s) (automaton.trans t)\\<rparr>", "unfolding opar_comp_def extg_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>init =\n              {y. \\<exists>x\\<in>init s \\<times> init t.\n                     y =\n                     (case x of\n                      (x, xa) \\<Rightarrow>\n                        (case x of\n                         (\\<sigma>, l1) \\<Rightarrow>\n                           \\<lambda>l2. (\\<sigma>, l1, l2))\n                         xa)},\n       trans = oparp_sos i (automaton.trans s) (automaton.trans t)\\<rparr> =\n    \\<lparr>init =\n              {(\\<sigma>, s\\<^sub>l, t\\<^sub>l) |\\<sigma> s\\<^sub>l\n               t\\<^sub>l.\n               (\\<sigma>, s\\<^sub>l) \\<in> init s \\<and>\n               t\\<^sub>l \\<in> init t},\n       trans = oparp_sos i (automaton.trans s) (automaton.trans t)\\<rparr>", "by (auto split: prod.split)"], ["", "lemma trans_opar_comp [simp]:\n  \"trans (s \\<langle>\\<langle>\\<^bsub>i\\<^esub> t) = oparp_sos i (trans s) (trans t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton.trans (s \\<langle>\\<langle>\\<^bsub>i\\<^esub> t) =\n    oparp_sos i (automaton.trans s) (automaton.trans t)", "unfolding opar_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton.trans\n     \\<lparr>init = extg ` (init s \\<times> init t),\n        trans =\n          oparp_sos i (automaton.trans s) (automaton.trans t)\\<rparr> =\n    oparp_sos i (automaton.trans s) (automaton.trans t)", "by simp"], ["", "lemma init_opar_comp [simp]:\n  \"init (s \\<langle>\\<langle>\\<^bsub>i\\<^esub> t) = extg ` (init s \\<times> init t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init (s \\<langle>\\<langle>\\<^bsub>i\\<^esub> t) =\n    extg ` (init s \\<times> init t)", "unfolding opar_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. init\n     \\<lparr>init = extg ` (init s \\<times> init t),\n        trans =\n          oparp_sos i (automaton.trans s) (automaton.trans t)\\<rparr> =\n    extg ` (init s \\<times> init t)", "by simp"], ["", "subsection \"Open structural operational semantics for node expressions \""], ["", "inductive_set\n  onode_sos :: \"((ip \\<Rightarrow> 's) \\<times> 'l, 'm seq_action) transition set\n                \\<Rightarrow> ((ip \\<Rightarrow> 's) \\<times> 'l net_state, 'm node_action) transition set\"\n  for S :: \"((ip \\<Rightarrow> 's) \\<times> 'l, 'm seq_action) transition set\"\nwhere\n    onode_bcast:\n    \"((\\<sigma>, s), broadcast m, (\\<sigma>', s')) \\<in> S \\<Longrightarrow> ((\\<sigma>, NodeS i s R), R:*cast(m), (\\<sigma>', NodeS i s' R)) \\<in> onode_sos S\"\n\n  | onode_gcast:\n    \"((\\<sigma>, s), groupcast D m, (\\<sigma>', s')) \\<in> S \\<Longrightarrow> ((\\<sigma>, NodeS i s R), (R\\<inter>D):*cast(m), (\\<sigma>', NodeS i s' R)) \\<in> onode_sos S\"\n\n  | onode_ucast:\n    \"\\<lbrakk> ((\\<sigma>, s), unicast d m, (\\<sigma>', s')) \\<in> S; d\\<in>R \\<rbrakk> \\<Longrightarrow> ((\\<sigma>, NodeS i s R), {d}:*cast(m), (\\<sigma>', NodeS i s' R)) \\<in> onode_sos S\"\n\n    (* Such assumptions aid later proofs, but they must be justified when transferring results\n       to closed systems. *)\n  | onode_notucast: \"\\<lbrakk> ((\\<sigma>, s), \\<not>unicast d, (\\<sigma>', s')) \\<in> S; d\\<notin>R; \\<forall>j. j\\<noteq>i \\<longrightarrow> \\<sigma>' j = \\<sigma> j \\<rbrakk>\n     \\<Longrightarrow> ((\\<sigma>, NodeS i s R), \\<tau>, (\\<sigma>', NodeS i s' R)) \\<in> onode_sos S\"\n\n  | onode_deliver: \"\\<lbrakk> ((\\<sigma>, s), deliver d, (\\<sigma>', s')) \\<in> S; \\<forall>j. j\\<noteq>i \\<longrightarrow> \\<sigma>' j = \\<sigma> j \\<rbrakk>\n     \\<Longrightarrow> ((\\<sigma>, NodeS i s R), i:deliver(d), (\\<sigma>', NodeS i s' R)) \\<in> onode_sos S\"\n\n  | onode_tau: \"\\<lbrakk> ((\\<sigma>, s), \\<tau>, (\\<sigma>', s')) \\<in> S; \\<forall>j. j\\<noteq>i \\<longrightarrow> \\<sigma>' j = \\<sigma> j \\<rbrakk>\n     \\<Longrightarrow> ((\\<sigma>, NodeS i s R),   \\<tau>, (\\<sigma>', NodeS i s' R)) \\<in> onode_sos S\"\n\n  | onode_receive:\n    \"((\\<sigma>, s), receive m, (\\<sigma>', s')) \\<in> S \\<Longrightarrow> ((\\<sigma>, NodeS i s R), {i}\\<not>{}:arrive(m), (\\<sigma>', NodeS i s' R)) \\<in> onode_sos S\"\n\n  | onode_arrive:\n    \"\\<sigma>' i = \\<sigma> i \\<Longrightarrow> ((\\<sigma>, NodeS i s R), {}\\<not>{i}:arrive(m),  (\\<sigma>', NodeS i s R)) \\<in> onode_sos S\"\n\n  | onode_connect1:\n    \"\\<sigma>' i = \\<sigma> i \\<Longrightarrow> ((\\<sigma>, NodeS i s R), connect(i, i'),    (\\<sigma>', NodeS i s (R \\<union> {i'}))) \\<in> onode_sos S\"\n\n  | onode_connect2:\n    \"\\<sigma>' i = \\<sigma> i \\<Longrightarrow> ((\\<sigma>, NodeS i s R), connect(i', i),    (\\<sigma>', NodeS i s (R \\<union> {i'}))) \\<in> onode_sos S\"\n\n  | onode_disconnect1:\n    \"\\<sigma>' i = \\<sigma> i \\<Longrightarrow> ((\\<sigma>, NodeS i s R), disconnect(i, i'), (\\<sigma>', NodeS i s (R - {i'}))) \\<in> onode_sos S\"\n\n  | onode_disconnect2:\n    \"\\<sigma>' i = \\<sigma> i \\<Longrightarrow> ((\\<sigma>, NodeS i s R), disconnect(i', i), (\\<sigma>', NodeS i s (R - {i'}))) \\<in> onode_sos S\"\n\n  | onode_connect_other:\n    \"\\<lbrakk> i \\<noteq> i'; i \\<noteq> i''; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> ((\\<sigma>, NodeS i s R), connect(i', i''),    (\\<sigma>', NodeS i s R)) \\<in> onode_sos S\"\n\n  | onode_disconnect_other:\n    \"\\<lbrakk> i \\<noteq> i'; i \\<noteq> i''; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> ((\\<sigma>, NodeS i s R), disconnect(i', i''), (\\<sigma>', NodeS i s R)) \\<in> onode_sos S\""], ["", "inductive_cases\n      onode_arriveTE [elim]:     \"((\\<sigma>, NodeS i s R), ii\\<not>ni:arrive(m),   (\\<sigma>', NodeS i' s' R')) \\<in> onode_sos S\"\n  and onode_castTE [elim]:       \"((\\<sigma>, NodeS i s R), RR:*cast(m),        (\\<sigma>', NodeS i' s' R')) \\<in> onode_sos S\"\n  and onode_deliverTE [elim]:    \"((\\<sigma>, NodeS i s R), ii:deliver(d),      (\\<sigma>', NodeS i' s' R')) \\<in> onode_sos S\"\n  and onode_connectTE [elim]:    \"((\\<sigma>, NodeS i s R), connect(ii, ii'),   (\\<sigma>', NodeS i' s' R')) \\<in> onode_sos S\"\n  and onode_disconnectTE [elim]: \"((\\<sigma>, NodeS i s R), disconnect(ii, ii'),(\\<sigma>', NodeS i' s' R')) \\<in> onode_sos S\"\n  and onode_newpktTE [elim]:     \"((\\<sigma>, NodeS i s R), ii:newpkt(d, di),   (\\<sigma>', NodeS i' s' R')) \\<in> onode_sos S\"\n  and onode_tauTE [elim]:        \"((\\<sigma>, NodeS i s R), \\<tau>,                  (\\<sigma>', NodeS i' s' R')) \\<in> onode_sos S\""], ["", "lemma oarrives_or_not:\n  assumes \"((\\<sigma>, NodeS i s R), ii\\<not>ni:arrive(m), (\\<sigma>', NodeS i' s' R')) \\<in> onode_sos S\"\n    shows \"(ii = {i} \\<and> ni = {}) \\<or> (ii = {} \\<and> ni = {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ii = {i} \\<and> ni = {} \\<or> ii = {} \\<and> ni = {i}", "using assms"], ["proof (prove)\nusing this:\n  ((\\<sigma>, NodeS i s R), ii\\<not>ni:arrive(m), \\<sigma>', NodeS i' s' R')\n  \\<in> onode_sos S\n\ngoal (1 subgoal):\n 1. ii = {i} \\<and> ni = {} \\<or> ii = {} \\<and> ni = {i}", "by rule simp_all"], ["", "definition\n  onode_comp :: \"ip\n                 \\<Rightarrow> ((ip \\<Rightarrow> 's) \\<times> 'l, 'm seq_action) automaton\n                 \\<Rightarrow> ip set\n                 \\<Rightarrow> ((ip \\<Rightarrow> 's) \\<times> 'l net_state, 'm node_action) automaton\"\n    (\"(\\<langle>_ : (_) : _\\<rangle>\\<^sub>o)\" [0, 0, 0] 104)\nwhere\n  \"\\<langle>i : onp : R\\<^sub>i\\<rangle>\\<^sub>o \\<equiv> \\<lparr> init = {(\\<sigma>, NodeS i s R\\<^sub>i)|\\<sigma> s. (\\<sigma>, s) \\<in> init onp},\n                      trans = onode_sos (trans onp) \\<rparr>\""], ["", "lemma trans_onode_comp:\n  \"trans (\\<langle>i : S : R\\<rangle>\\<^sub>o) = onode_sos (trans S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton.trans (\\<langle>i : S : R\\<rangle>\\<^sub>o) =\n    onode_sos (automaton.trans S)", "unfolding onode_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton.trans\n     \\<lparr>init =\n               {(\\<sigma>, NodeS i s R) |\\<sigma> s.\n                (\\<sigma>, s) \\<in> init S},\n        trans = onode_sos (automaton.trans S)\\<rparr> =\n    onode_sos (automaton.trans S)", "by simp"], ["", "lemma init_onode_comp:\n  \"init (\\<langle>i : S : R\\<rangle>\\<^sub>o) = {(\\<sigma>, NodeS i s R)|\\<sigma> s. (\\<sigma>, s) \\<in> init S}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init (\\<langle>i : S : R\\<rangle>\\<^sub>o) =\n    {(\\<sigma>, NodeS i s R) |\\<sigma> s. (\\<sigma>, s) \\<in> init S}", "unfolding onode_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. init\n     \\<lparr>init =\n               {(\\<sigma>, NodeS i s R) |\\<sigma> s.\n                (\\<sigma>, s) \\<in> init S},\n        trans = onode_sos (automaton.trans S)\\<rparr> =\n    {(\\<sigma>, NodeS i s R) |\\<sigma> s. (\\<sigma>, s) \\<in> init S}", "by simp"], ["", "lemmas onode_comps = trans_onode_comp init_onode_comp"], ["", "lemma fst_par_onode_comp [simp]:\n  \"trans (\\<langle>i : s \\<langle>\\<langle>\\<^bsub>I\\<^esub> t : R\\<rangle>\\<^sub>o) = onode_sos (oparp_sos I (trans s) (trans t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton.trans\n     (\\<langle>i : s \\<langle>\\<langle>\\<^bsub>I\\<^esub> t : R\\<rangle>\\<^sub>o) =\n    onode_sos (oparp_sos I (automaton.trans s) (automaton.trans t))", "unfolding onode_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton.trans\n     \\<lparr>init =\n               {(\\<sigma>, NodeS i sa R) |\\<sigma> sa.\n                (\\<sigma>, sa)\n                \\<in> init (s \\<langle>\\<langle>\\<^bsub>I\\<^esub> t)},\n        trans =\n          onode_sos\n           (automaton.trans\n             (s \\<langle>\\<langle>\\<^bsub>I\\<^esub> t))\\<rparr> =\n    onode_sos (oparp_sos I (automaton.trans s) (automaton.trans t))", "by simp"], ["", "lemma init_par_onode_comp [simp]:\n  \"init (\\<langle>i : s \\<langle>\\<langle>\\<^bsub>I\\<^esub> t : R\\<rangle>\\<^sub>o) = {(\\<sigma>, NodeS i (s1, s2) R)|\\<sigma> s1 s2. ((\\<sigma>, s1), s2) \\<in> init s \\<times> init t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init\n     (\\<langle>i : s \\<langle>\\<langle>\\<^bsub>I\\<^esub> t : R\\<rangle>\\<^sub>o) =\n    {(\\<sigma>, NodeS i (s1, s2) R) |\\<sigma> s1 s2.\n     ((\\<sigma>, s1), s2) \\<in> init s \\<times> init t}", "unfolding onode_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. init\n     \\<lparr>init =\n               {(\\<sigma>, NodeS i sa R) |\\<sigma> sa.\n                (\\<sigma>, sa)\n                \\<in> init (s \\<langle>\\<langle>\\<^bsub>I\\<^esub> t)},\n        trans =\n          onode_sos\n           (automaton.trans\n             (s \\<langle>\\<langle>\\<^bsub>I\\<^esub> t))\\<rparr> =\n    {(\\<sigma>, NodeS i (s1, s2) R) |\\<sigma> s1 s2.\n     ((\\<sigma>, s1), s2) \\<in> init s \\<times> init t}", "by (simp add: extg_range_prod)"], ["", "lemma onode_sos_dest_is_net_state:\n  assumes \"((\\<sigma>, p), a, s') \\<in> onode_sos S\"\n    shows \"\\<exists>\\<sigma>' i' \\<zeta>' R'. s' = (\\<sigma>', NodeS i' \\<zeta>' R')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' i' \\<zeta>' R'.\n       s' = (\\<sigma>', NodeS i' \\<zeta>' R')", "using assms"], ["proof (prove)\nusing this:\n  ((\\<sigma>, p), a, s') \\<in> onode_sos S\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' i' \\<zeta>' R'.\n       s' = (\\<sigma>', NodeS i' \\<zeta>' R')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<sigma>, p), a, s') \\<in> onode_sos S \\<Longrightarrow>\n    \\<exists>\\<sigma>' i' \\<zeta>' R'.\n       s' = (\\<sigma>', NodeS i' \\<zeta>' R')", "assume \"((\\<sigma>, p), a, s') \\<in> onode_sos S\""], ["proof (state)\nthis:\n  ((\\<sigma>, p), a, s') \\<in> onode_sos S\n\ngoal (1 subgoal):\n 1. ((\\<sigma>, p), a, s') \\<in> onode_sos S \\<Longrightarrow>\n    \\<exists>\\<sigma>' i' \\<zeta>' R'.\n       s' = (\\<sigma>', NodeS i' \\<zeta>' R')", "then"], ["proof (chain)\npicking this:\n  ((\\<sigma>, p), a, s') \\<in> onode_sos S", "obtain \\<sigma>' i' \\<zeta>' R' where \"s' = (\\<sigma>', NodeS i' \\<zeta>' R')\""], ["proof (prove)\nusing this:\n  ((\\<sigma>, p), a, s') \\<in> onode_sos S\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>' i' \\<zeta>' R'.\n        s' = (\\<sigma>', NodeS i' \\<zeta>' R') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases s') (auto elim!: onode_sos.cases)"], ["proof (state)\nthis:\n  s' = (\\<sigma>', NodeS i' \\<zeta>' R')\n\ngoal (1 subgoal):\n 1. ((\\<sigma>, p), a, s') \\<in> onode_sos S \\<Longrightarrow>\n    \\<exists>\\<sigma>' i' \\<zeta>' R'.\n       s' = (\\<sigma>', NodeS i' \\<zeta>' R')", "thus ?thesis"], ["proof (prove)\nusing this:\n  s' = (\\<sigma>', NodeS i' \\<zeta>' R')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' i' \\<zeta>' R'.\n       s' = (\\<sigma>', NodeS i' \\<zeta>' R')", "by simp"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>' i' \\<zeta>' R'. s' = (\\<sigma>', NodeS i' \\<zeta>' R')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma onode_sos_dest_is_net_state':\n  assumes \"((\\<sigma>, NodeS i p R), a, s') \\<in> onode_sos S\"\n    shows \"\\<exists>\\<sigma>' \\<zeta>' R'. s' = (\\<sigma>', NodeS i \\<zeta>' R')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' \\<zeta>' R'. s' = (\\<sigma>', NodeS i \\<zeta>' R')", "using assms"], ["proof (prove)\nusing this:\n  ((\\<sigma>, NodeS i p R), a, s') \\<in> onode_sos S\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' \\<zeta>' R'. s' = (\\<sigma>', NodeS i \\<zeta>' R')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<sigma>, NodeS i p R), a, s') \\<in> onode_sos S \\<Longrightarrow>\n    \\<exists>\\<sigma>' \\<zeta>' R'. s' = (\\<sigma>', NodeS i \\<zeta>' R')", "assume \"((\\<sigma>, NodeS i p R), a, s') \\<in> onode_sos S\""], ["proof (state)\nthis:\n  ((\\<sigma>, NodeS i p R), a, s') \\<in> onode_sos S\n\ngoal (1 subgoal):\n 1. ((\\<sigma>, NodeS i p R), a, s') \\<in> onode_sos S \\<Longrightarrow>\n    \\<exists>\\<sigma>' \\<zeta>' R'. s' = (\\<sigma>', NodeS i \\<zeta>' R')", "then"], ["proof (chain)\npicking this:\n  ((\\<sigma>, NodeS i p R), a, s') \\<in> onode_sos S", "obtain \\<sigma>' \\<zeta>' R' where \"s' = (\\<sigma>', NodeS i \\<zeta>' R')\""], ["proof (prove)\nusing this:\n  ((\\<sigma>, NodeS i p R), a, s') \\<in> onode_sos S\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>' \\<zeta>' R'.\n        s' = (\\<sigma>', NodeS i \\<zeta>' R') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases s') (auto elim!: onode_sos.cases)"], ["proof (state)\nthis:\n  s' = (\\<sigma>', NodeS i \\<zeta>' R')\n\ngoal (1 subgoal):\n 1. ((\\<sigma>, NodeS i p R), a, s') \\<in> onode_sos S \\<Longrightarrow>\n    \\<exists>\\<sigma>' \\<zeta>' R'. s' = (\\<sigma>', NodeS i \\<zeta>' R')", "thus ?thesis"], ["proof (prove)\nusing this:\n  s' = (\\<sigma>', NodeS i \\<zeta>' R')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' \\<zeta>' R'. s' = (\\<sigma>', NodeS i \\<zeta>' R')", "by simp"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>' \\<zeta>' R'. s' = (\\<sigma>', NodeS i \\<zeta>' R')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma onode_sos_dest_is_net_state'':\n  assumes \"((\\<sigma>, NodeS i p R), a, (\\<sigma>', s')) \\<in> onode_sos S\"\n    shows \"\\<exists>\\<zeta>' R'. s' = NodeS i \\<zeta>' R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<zeta>' R'. s' = NodeS i \\<zeta>' R'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<zeta>' R'. s' = NodeS i \\<zeta>' R'", "define ns' where \"ns' = (\\<sigma>', s')\""], ["proof (state)\nthis:\n  ns' = (\\<sigma>', s')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<zeta>' R'. s' = NodeS i \\<zeta>' R'", "with assms"], ["proof (chain)\npicking this:\n  ((\\<sigma>, NodeS i p R), a, \\<sigma>', s') \\<in> onode_sos S\n  ns' = (\\<sigma>', s')", "have \"((\\<sigma>, NodeS i p R), a, ns') \\<in> onode_sos S\""], ["proof (prove)\nusing this:\n  ((\\<sigma>, NodeS i p R), a, \\<sigma>', s') \\<in> onode_sos S\n  ns' = (\\<sigma>', s')\n\ngoal (1 subgoal):\n 1. ((\\<sigma>, NodeS i p R), a, ns') \\<in> onode_sos S", "by simp"], ["proof (state)\nthis:\n  ((\\<sigma>, NodeS i p R), a, ns') \\<in> onode_sos S\n\ngoal (1 subgoal):\n 1. \\<exists>\\<zeta>' R'. s' = NodeS i \\<zeta>' R'", "then"], ["proof (chain)\npicking this:\n  ((\\<sigma>, NodeS i p R), a, ns') \\<in> onode_sos S", "obtain \\<sigma>'' \\<zeta>' R' where \"ns' = (\\<sigma>'', NodeS i \\<zeta>' R')\""], ["proof (prove)\nusing this:\n  ((\\<sigma>, NodeS i p R), a, ns') \\<in> onode_sos S\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'' \\<zeta>' R'.\n        ns' = (\\<sigma>'', NodeS i \\<zeta>' R') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis onode_sos_dest_is_net_state')"], ["proof (state)\nthis:\n  ns' = (\\<sigma>'', NodeS i \\<zeta>' R')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<zeta>' R'. s' = NodeS i \\<zeta>' R'", "hence \"s' = NodeS i \\<zeta>' R'\""], ["proof (prove)\nusing this:\n  ns' = (\\<sigma>'', NodeS i \\<zeta>' R')\n\ngoal (1 subgoal):\n 1. s' = NodeS i \\<zeta>' R'", "by (simp add: ns'_def)"], ["proof (state)\nthis:\n  s' = NodeS i \\<zeta>' R'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<zeta>' R'. s' = NodeS i \\<zeta>' R'", "thus ?thesis"], ["proof (prove)\nusing this:\n  s' = NodeS i \\<zeta>' R'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<zeta>' R'. s' = NodeS i \\<zeta>' R'", "by simp"], ["proof (state)\nthis:\n  \\<exists>\\<zeta>' R'. s' = NodeS i \\<zeta>' R'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma onode_sos_src_is_net_state:\n  assumes \"((\\<sigma>, p), a, s') \\<in> onode_sos S\"\n    shows \"\\<exists>i \\<zeta> R. p = NodeS i \\<zeta> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i \\<zeta> R. p = NodeS i \\<zeta> R", "using assms"], ["proof (prove)\nusing this:\n  ((\\<sigma>, p), a, s') \\<in> onode_sos S\n\ngoal (1 subgoal):\n 1. \\<exists>i \\<zeta> R. p = NodeS i \\<zeta> R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<sigma>, p), a, s') \\<in> onode_sos S \\<Longrightarrow>\n    \\<exists>i \\<zeta> R. p = NodeS i \\<zeta> R", "assume \"((\\<sigma>, p), a, s') \\<in> onode_sos S\""], ["proof (state)\nthis:\n  ((\\<sigma>, p), a, s') \\<in> onode_sos S\n\ngoal (1 subgoal):\n 1. ((\\<sigma>, p), a, s') \\<in> onode_sos S \\<Longrightarrow>\n    \\<exists>i \\<zeta> R. p = NodeS i \\<zeta> R", "then"], ["proof (chain)\npicking this:\n  ((\\<sigma>, p), a, s') \\<in> onode_sos S", "obtain i \\<zeta> R where \"p = NodeS i \\<zeta> R\""], ["proof (prove)\nusing this:\n  ((\\<sigma>, p), a, s') \\<in> onode_sos S\n\ngoal (1 subgoal):\n 1. (\\<And>i \\<zeta> R.\n        p = NodeS i \\<zeta> R \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s') (auto elim!: onode_sos.cases)"], ["proof (state)\nthis:\n  p = NodeS i \\<zeta> R\n\ngoal (1 subgoal):\n 1. ((\\<sigma>, p), a, s') \\<in> onode_sos S \\<Longrightarrow>\n    \\<exists>i \\<zeta> R. p = NodeS i \\<zeta> R", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = NodeS i \\<zeta> R\n\ngoal (1 subgoal):\n 1. \\<exists>i \\<zeta> R. p = NodeS i \\<zeta> R", "by simp"], ["proof (state)\nthis:\n  \\<exists>i \\<zeta> R. p = NodeS i \\<zeta> R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma onode_sos_net_states:\n  assumes \"((\\<sigma>, s), a, (\\<sigma>', s')) \\<in> onode_sos S\"\n    shows \"\\<exists>i \\<zeta> R \\<zeta>' R'. s = NodeS i \\<zeta> R \\<and> s' = NodeS i \\<zeta>' R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i \\<zeta> R \\<zeta>' R'.\n       s = NodeS i \\<zeta> R \\<and> s' = NodeS i \\<zeta>' R'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i \\<zeta> R \\<zeta>' R'.\n       s = NodeS i \\<zeta> R \\<and> s' = NodeS i \\<zeta>' R'", "from assms"], ["proof (chain)\npicking this:\n  ((\\<sigma>, s), a, \\<sigma>', s') \\<in> onode_sos S", "obtain i \\<zeta> R where \"s = NodeS i \\<zeta> R\""], ["proof (prove)\nusing this:\n  ((\\<sigma>, s), a, \\<sigma>', s') \\<in> onode_sos S\n\ngoal (1 subgoal):\n 1. (\\<And>i \\<zeta> R.\n        s = NodeS i \\<zeta> R \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis onode_sos_src_is_net_state)"], ["proof (state)\nthis:\n  s = NodeS i \\<zeta> R\n\ngoal (1 subgoal):\n 1. \\<exists>i \\<zeta> R \\<zeta>' R'.\n       s = NodeS i \\<zeta> R \\<and> s' = NodeS i \\<zeta>' R'", "moreover"], ["proof (state)\nthis:\n  s = NodeS i \\<zeta> R\n\ngoal (1 subgoal):\n 1. \\<exists>i \\<zeta> R \\<zeta>' R'.\n       s = NodeS i \\<zeta> R \\<and> s' = NodeS i \\<zeta>' R'", "with assms"], ["proof (chain)\npicking this:\n  ((\\<sigma>, s), a, \\<sigma>', s') \\<in> onode_sos S\n  s = NodeS i \\<zeta> R", "obtain \\<zeta>' R' where \"s' = NodeS i \\<zeta>' R'\""], ["proof (prove)\nusing this:\n  ((\\<sigma>, s), a, \\<sigma>', s') \\<in> onode_sos S\n  s = NodeS i \\<zeta> R\n\ngoal (1 subgoal):\n 1. (\\<And>\\<zeta>' R'.\n        s' = NodeS i \\<zeta>' R' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest!: onode_sos_dest_is_net_state')"], ["proof (state)\nthis:\n  s' = NodeS i \\<zeta>' R'\n\ngoal (1 subgoal):\n 1. \\<exists>i \\<zeta> R \\<zeta>' R'.\n       s = NodeS i \\<zeta> R \\<and> s' = NodeS i \\<zeta>' R'", "ultimately"], ["proof (chain)\npicking this:\n  s = NodeS i \\<zeta> R\n  s' = NodeS i \\<zeta>' R'", "show ?thesis"], ["proof (prove)\nusing this:\n  s = NodeS i \\<zeta> R\n  s' = NodeS i \\<zeta>' R'\n\ngoal (1 subgoal):\n 1. \\<exists>i \\<zeta> R \\<zeta>' R'.\n       s = NodeS i \\<zeta> R \\<and> s' = NodeS i \\<zeta>' R'", "by simp"], ["proof (state)\nthis:\n  \\<exists>i \\<zeta> R \\<zeta>' R'.\n     s = NodeS i \\<zeta> R \\<and> s' = NodeS i \\<zeta>' R'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma node_sos_cases [elim]:\n  \"((\\<sigma>, NodeS i p R), a, (\\<sigma>', NodeS i p' R')) \\<in> onode_sos S \\<Longrightarrow>\n  (\\<And>m .       \\<lbrakk> a = R:*cast(m);          R' = R; ((\\<sigma>, p), broadcast m,   (\\<sigma>', p')) \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>m D.      \\<lbrakk> a = (R \\<inter> D):*cast(m);    R' = R; ((\\<sigma>, p), groupcast D m, (\\<sigma>', p')) \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>d m.      \\<lbrakk> a = {d}:*cast(m);        R' = R; ((\\<sigma>, p), unicast d m,   (\\<sigma>', p')) \\<in> S; d \\<in> R \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>d.        \\<lbrakk> a = \\<tau>;                   R' = R; ((\\<sigma>, p), \\<not>unicast d,    (\\<sigma>', p')) \\<in> S; d \\<notin> R \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>d.        \\<lbrakk> a = i:deliver(d);        R' = R; ((\\<sigma>, p), deliver d,     (\\<sigma>', p')) \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>m.        \\<lbrakk> a = {i}\\<not>{}:arrive(m);    R' = R; ((\\<sigma>, p), receive m,     (\\<sigma>', p')) \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (            \\<lbrakk> a = \\<tau>;                   R' = R; ((\\<sigma>, p), \\<tau>,             (\\<sigma>', p')) \\<in> S \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>m.        \\<lbrakk> a = {}\\<not>{i}:arrive(m);    R' = R; p = p'; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i'.     \\<lbrakk> a = connect(i, i');      R' = R \\<union> {i'}; p = p'; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i'.     \\<lbrakk> a = connect(i', i);      R' = R \\<union> {i'}; p = p'; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i'.     \\<lbrakk> a = disconnect(i, i');   R' = R - {i'}; p = p'; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i'.     \\<lbrakk> a = disconnect(i', i);   R' = R - {i'}; p = p'; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i' i''. \\<lbrakk> a = connect(i', i'');    R' = R; p = p'; i \\<noteq> i'; i \\<noteq> i''; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  (\\<And>i i' i''. \\<lbrakk> a = disconnect(i', i''); R' = R; p = p'; i \\<noteq> i'; i \\<noteq> i''; \\<sigma>' i = \\<sigma> i \\<rbrakk> \\<Longrightarrow> P) \\<Longrightarrow>\n  P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<sigma>, NodeS i p R), a, \\<sigma>', NodeS i p' R')\n             \\<in> onode_sos S;\n     \\<And>m.\n        \\<lbrakk>a = R:*cast(m); R' = R;\n         ((\\<sigma>, p), broadcast m, \\<sigma>', p') \\<in> S\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>m D.\n        \\<lbrakk>a = (R \\<inter> D):*cast(m); R' = R;\n         ((\\<sigma>, p), groupcast D m, \\<sigma>', p') \\<in> S\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>d m.\n        \\<lbrakk>a = {d}:*cast(m); R' = R;\n         ((\\<sigma>, p), unicast d m, \\<sigma>', p') \\<in> S;\n         d \\<in> R\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>d.\n        \\<lbrakk>a = \\<tau>; R' = R;\n         ((\\<sigma>, p), \\<not>unicast d, \\<sigma>', p') \\<in> S;\n         d \\<notin> R\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>d.\n        \\<lbrakk>a = i:deliver(d); R' = R;\n         ((\\<sigma>, p), deliver d, \\<sigma>', p') \\<in> S\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>m.\n        \\<lbrakk>a = {i}\\<not>{}:arrive(m); R' = R;\n         ((\\<sigma>, p), receive m, \\<sigma>', p') \\<in> S\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<lbrakk>a = \\<tau>; R' = R;\n      ((\\<sigma>, p), \\<tau>, \\<sigma>', p') \\<in> S\\<rbrakk>\n     \\<Longrightarrow> P;\n     \\<And>m.\n        \\<lbrakk>a = {}\\<not>{i}:arrive(m); R' = R; p = p';\n         \\<sigma>' i = \\<sigma> i\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>i i'.\n        \\<lbrakk>a = connect(i, i'); R' = R \\<union> {i'}; p = p';\n         \\<sigma>' i = \\<sigma> i\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>i i'.\n        \\<lbrakk>a = connect(i', i); R' = R \\<union> {i'}; p = p';\n         \\<sigma>' i = \\<sigma> i\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>i i'.\n        \\<lbrakk>a = disconnect(i, i'); R' = R - {i'}; p = p';\n         \\<sigma>' i = \\<sigma> i\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>i i'.\n        \\<lbrakk>a = disconnect(i', i); R' = R - {i'}; p = p';\n         \\<sigma>' i = \\<sigma> i\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>i i' i''.\n        \\<lbrakk>a = connect(i', i''); R' = R; p = p'; i \\<noteq> i';\n         i \\<noteq> i''; \\<sigma>' i = \\<sigma> i\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>i i' i''.\n        \\<lbrakk>a = disconnect(i', i''); R' = R; p = p'; i \\<noteq> i';\n         i \\<noteq> i''; \\<sigma>' i = \\<sigma> i\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (erule onode_sos.cases) (simp | metis)+"], ["", "subsection \"Open structural operational semantics for partial network expressions \""], ["", "inductive_set\n  opnet_sos :: \"((ip \\<Rightarrow> 's) \\<times> 'l net_state, 'm node_action) transition set\n                       \\<Rightarrow> ((ip \\<Rightarrow> 's) \\<times> 'l net_state, 'm node_action) transition set\n                       \\<Rightarrow> ((ip \\<Rightarrow> 's) \\<times> 'l net_state, 'm node_action) transition set\"\n  for S :: \"((ip \\<Rightarrow> 's) \\<times> 'l net_state, 'm node_action) transition set\"\n  and T :: \"((ip \\<Rightarrow> 's) \\<times> 'l net_state, 'm node_action) transition set\"\nwhere\n    opnet_cast1:\n    \"\\<lbrakk> ((\\<sigma>, s), R:*cast(m), (\\<sigma>', s')) \\<in> S; ((\\<sigma>, t), H\\<not>K:arrive(m), (\\<sigma>', t')) \\<in> T; H \\<subseteq> R; K \\<inter> R = {} \\<rbrakk>\n      \\<Longrightarrow> ((\\<sigma>, SubnetS s t), R:*cast(m), (\\<sigma>', SubnetS s' t')) \\<in> opnet_sos S T\"\n\n  | opnet_cast2:\n    \"\\<lbrakk> ((\\<sigma>, s), H\\<not>K:arrive(m), (\\<sigma>', s')) \\<in> S; ((\\<sigma>, t), R:*cast(m), (\\<sigma>', t')) \\<in> T;  H \\<subseteq> R; K \\<inter> R = {} \\<rbrakk>\n      \\<Longrightarrow> ((\\<sigma>, SubnetS s t), R:*cast(m), (\\<sigma>', SubnetS s' t')) \\<in> opnet_sos S T\"\n\n  | opnet_arrive:\n    \"\\<lbrakk> ((\\<sigma>, s), H\\<not>K:arrive(m), (\\<sigma>', s')) \\<in> S; ((\\<sigma>, t), H'\\<not>K':arrive(m), (\\<sigma>', t')) \\<in> T \\<rbrakk>\n      \\<Longrightarrow> ((\\<sigma>, SubnetS s t),  (H \\<union> H')\\<not>(K \\<union> K'):arrive(m), (\\<sigma>', SubnetS s' t')) \\<in> opnet_sos S T\"\n\n  | opnet_deliver1:\n    \"((\\<sigma>, s), i:deliver(d), (\\<sigma>', s')) \\<in> S\n      \\<Longrightarrow> ((\\<sigma>, SubnetS s t), i:deliver(d), (\\<sigma>', SubnetS s' t)) \\<in> opnet_sos S T\"\n\n  | opnet_deliver2:\n    \"\\<lbrakk> ((\\<sigma>, t), i:deliver(d), (\\<sigma>', t')) \\<in> T \\<rbrakk>\n      \\<Longrightarrow> ((\\<sigma>, SubnetS s t), i:deliver(d), (\\<sigma>', SubnetS s t')) \\<in> opnet_sos S T\"\n\n  | opnet_tau1:\n    \"((\\<sigma>, s), \\<tau>, (\\<sigma>', s')) \\<in> S \\<Longrightarrow> ((\\<sigma>, SubnetS s t), \\<tau>, (\\<sigma>', SubnetS s' t)) \\<in> opnet_sos S T\"\n\n  | opnet_tau2:\n    \"((\\<sigma>, t), \\<tau>, (\\<sigma>', t')) \\<in> T \\<Longrightarrow> ((\\<sigma>, SubnetS s t), \\<tau>, (\\<sigma>', SubnetS s t')) \\<in> opnet_sos S T\"\n\n  | opnet_connect:\n    \"\\<lbrakk> ((\\<sigma>, s), connect(i, i'), (\\<sigma>', s')) \\<in> S; ((\\<sigma>, t), connect(i, i'), (\\<sigma>', t')) \\<in> T \\<rbrakk>\n      \\<Longrightarrow> ((\\<sigma>, SubnetS s t), connect(i, i'), (\\<sigma>', SubnetS s' t')) \\<in> opnet_sos S T\"\n\n  | opnet_disconnect:\n    \"\\<lbrakk> ((\\<sigma>, s), disconnect(i, i'), (\\<sigma>', s')) \\<in> S; ((\\<sigma>, t), disconnect(i, i'), (\\<sigma>', t')) \\<in> T \\<rbrakk>\n      \\<Longrightarrow> ((\\<sigma>, SubnetS s t), disconnect(i, i'), (\\<sigma>', SubnetS s' t')) \\<in> opnet_sos S T\""], ["", "inductive_cases opartial_castTE [elim]:       \"((\\<sigma>, s), R:*cast(m), (\\<sigma>', s')) \\<in> opnet_sos S T\"\n            and opartial_arriveTE [elim]:     \"((\\<sigma>, s), H\\<not>K:arrive(m), (\\<sigma>', s')) \\<in> opnet_sos S T\"\n            and opartial_deliverTE [elim]:    \"((\\<sigma>, s), i:deliver(d), (\\<sigma>', s')) \\<in> opnet_sos S T\"\n            and opartial_tauTE [elim]:        \"((\\<sigma>, s), \\<tau>, (\\<sigma>', s')) \\<in> opnet_sos S T\"\n            and opartial_connectTE [elim]:    \"((\\<sigma>, s), connect(i, i'), (\\<sigma>', s')) \\<in> opnet_sos S T\"\n            and opartial_disconnectTE [elim]: \"((\\<sigma>, s), disconnect(i, i'), (\\<sigma>', s')) \\<in> opnet_sos S T\"\n            and opartial_newpktTE [elim]:     \"((\\<sigma>, s), i:newpkt(d, di), (\\<sigma>', s')) \\<in> opnet_sos S T\""], ["", "fun opnet :: \"(ip \\<Rightarrow> ((ip \\<Rightarrow> 's) \\<times> 'l, 'm seq_action) automaton)\n              \\<Rightarrow> net_tree \\<Rightarrow> ((ip \\<Rightarrow> 's) \\<times> 'l net_state, 'm node_action) automaton\"\nwhere\n    \"opnet onp (\\<langle>i; R\\<^sub>i\\<rangle>)  =  \\<langle>i : onp i : R\\<^sub>i\\<rangle>\\<^sub>o\"\n  | \"opnet onp (p\\<^sub>1 \\<parallel> p\\<^sub>2) = \\<lparr> init = {(\\<sigma>, SubnetS s\\<^sub>1 s\\<^sub>2) |\\<sigma> s\\<^sub>1 s\\<^sub>2.\n                                        (\\<sigma>, s\\<^sub>1) \\<in> init (opnet onp p\\<^sub>1)\n                                      \\<and> (\\<sigma>, s\\<^sub>2) \\<in> init (opnet onp p\\<^sub>2)\n                                      \\<and> net_ips s\\<^sub>1 \\<inter> net_ips s\\<^sub>2 = {}},\n                             trans = opnet_sos (trans (opnet onp p\\<^sub>1)) (trans (opnet onp p\\<^sub>2)) \\<rparr>\""], ["", "lemma opnet_node_init [elim, simp]:\n  assumes \"(\\<sigma>, s) \\<in> init (opnet onp \\<langle>i; R\\<rangle>)\"\n    shows \"(\\<sigma>, s) \\<in> { (\\<sigma>, NodeS i ns R) |\\<sigma> ns. (\\<sigma>, ns) \\<in> init (onp i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>, s)\n    \\<in> {(\\<sigma>, NodeS i ns R) |\\<sigma> ns.\n           (\\<sigma>, ns) \\<in> init (onp i)}", "using assms"], ["proof (prove)\nusing this:\n  (\\<sigma>, s) \\<in> init (opnet onp \\<langle>i; R\\<rangle>)\n\ngoal (1 subgoal):\n 1. (\\<sigma>, s)\n    \\<in> {(\\<sigma>, NodeS i ns R) |\\<sigma> ns.\n           (\\<sigma>, ns) \\<in> init (onp i)}", "by (simp add: onode_comp_def)"], ["", "lemma opnet_node_init' [elim]:\n assumes \"(\\<sigma>, s) \\<in> init (opnet onp \\<langle>i; R\\<rangle>)\"\n obtains ns where \"s = NodeS i ns R\"\n             and \"(\\<sigma>, ns) \\<in> init (onp i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>s = NodeS i ns R;\n         (\\<sigma>, ns) \\<in> init (onp i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (\\<sigma>, s) \\<in> init (opnet onp \\<langle>i; R\\<rangle>)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>s = NodeS i ns R;\n         (\\<sigma>, ns) \\<in> init (onp i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: onode_comp_def)"], ["", "lemma opnet_node_trans [elim, simp]:\n  assumes \"(s, a, s') \\<in> trans (opnet onp \\<langle>i; R\\<rangle>)\"\n    shows \"(s, a, s') \\<in> onode_sos (trans (onp i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, a, s') \\<in> onode_sos (automaton.trans (onp i))", "using assms"], ["proof (prove)\nusing this:\n  (s, a, s') \\<in> automaton.trans (opnet onp \\<langle>i; R\\<rangle>)\n\ngoal (1 subgoal):\n 1. (s, a, s') \\<in> onode_sos (automaton.trans (onp i))", "by (simp add: trans_onode_comp)"], ["", "subsection \"Open structural operational semantics for complete network expressions \""], ["", "inductive_set\n  ocnet_sos :: \"((ip \\<Rightarrow> 's) \\<times> 'l net_state, 'm::msg node_action) transition set\n                         \\<Rightarrow> ((ip \\<Rightarrow> 's) \\<times> 'l net_state, 'm node_action) transition set\"\n  for S :: \"((ip \\<Rightarrow> 's) \\<times> 'l net_state, 'm node_action) transition set\"\nwhere\n    ocnet_connect:\n    \"\\<lbrakk> ((\\<sigma>, s), connect(i, i'), (\\<sigma>', s')) \\<in> S; \\<forall>j. j \\<notin> net_ips s \\<longrightarrow> (\\<sigma>' j = \\<sigma> j) \\<rbrakk>\n     \\<Longrightarrow> ((\\<sigma>, s), connect(i, i'), (\\<sigma>', s')) \\<in> ocnet_sos S\"\n\n  | ocnet_disconnect:\n    \"\\<lbrakk> ((\\<sigma>, s), disconnect(i, i'), (\\<sigma>', s')) \\<in> S; \\<forall>j. j \\<notin> net_ips s \\<longrightarrow> (\\<sigma>' j = \\<sigma> j) \\<rbrakk>\n     \\<Longrightarrow> ((\\<sigma>, s), disconnect(i, i'), (\\<sigma>', s')) \\<in> ocnet_sos S\"\n\n  | ocnet_cast:\n    \"\\<lbrakk> ((\\<sigma>, s), R:*cast(m), (\\<sigma>', s')) \\<in> S; \\<forall>j. j \\<notin> net_ips s \\<longrightarrow> (\\<sigma>' j = \\<sigma> j) \\<rbrakk>\n     \\<Longrightarrow> ((\\<sigma>, s), \\<tau>, (\\<sigma>', s')) \\<in> ocnet_sos S\"\n\n  | ocnet_tau:  \n    \"\\<lbrakk> ((\\<sigma>, s), \\<tau>, (\\<sigma>', s')) \\<in> S; \\<forall>j. j \\<notin> net_ips s \\<longrightarrow> (\\<sigma>' j = \\<sigma> j) \\<rbrakk>\n     \\<Longrightarrow> ((\\<sigma>, s), \\<tau>, (\\<sigma>', s')) \\<in> ocnet_sos S\"\n\n  | ocnet_deliver:\n    \"\\<lbrakk> ((\\<sigma>, s), i:deliver(d), (\\<sigma>', s')) \\<in> S; \\<forall>j. j \\<notin> net_ips s \\<longrightarrow> (\\<sigma>' j = \\<sigma> j) \\<rbrakk>\n     \\<Longrightarrow> ((\\<sigma>, s), i:deliver(d), (\\<sigma>', s')) \\<in> ocnet_sos S\"\n\n  | ocnet_newpkt:\n    \"\\<lbrakk> ((\\<sigma>, s), {i}\\<not>K:arrive(newpkt(d, di)), (\\<sigma>', s')) \\<in> S; \\<forall>j. j \\<notin> net_ips s \\<longrightarrow> (\\<sigma>' j = \\<sigma> j) \\<rbrakk>\n     \\<Longrightarrow> ((\\<sigma>, s), i:newpkt(d, di), (\\<sigma>', s')) \\<in> ocnet_sos S\""], ["", "inductive_cases oconnect_completeTE: \"((\\<sigma>, s), connect(i, i'), (\\<sigma>', s')) \\<in> ocnet_sos S\"\n            and odisconnect_completeTE: \"((\\<sigma>, s), disconnect(i, i'), (\\<sigma>', s')) \\<in> ocnet_sos S\"\n            and otau_completeTE: \"((\\<sigma>, s), \\<tau>, (\\<sigma>', s')) \\<in> ocnet_sos S\"\n            and odeliver_completeTE: \"((\\<sigma>, s), i:deliver(d), (\\<sigma>', s')) \\<in> ocnet_sos S\"\n            and onewpkt_completeTE: \"((\\<sigma>, s), i:newpkt(d, di), (\\<sigma>', s')) \\<in> ocnet_sos S\""], ["", "lemmas ocompleteTEs = oconnect_completeTE\n                      odisconnect_completeTE\n                      otau_completeTE\n                      odeliver_completeTE\n                      onewpkt_completeTE"], ["", "lemma ocomplete_no_cast [simp]:\n  \"((\\<sigma>, s), R:*cast(m), (\\<sigma>', s')) \\<notin> ocnet_sos T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<sigma>, s), R:*cast(m), \\<sigma>', s') \\<notin> ocnet_sos T", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<sigma>, s), R:*cast(m), \\<sigma>', s')\n    \\<in> ocnet_sos T \\<Longrightarrow>\n    False", "assume \"((\\<sigma>, s), R:*cast(m), (\\<sigma>', s')) \\<in> ocnet_sos T\""], ["proof (state)\nthis:\n  ((\\<sigma>, s), R:*cast(m), \\<sigma>', s') \\<in> ocnet_sos T\n\ngoal (1 subgoal):\n 1. ((\\<sigma>, s), R:*cast(m), \\<sigma>', s')\n    \\<in> ocnet_sos T \\<Longrightarrow>\n    False", "hence \"R:*cast(m) \\<noteq> R:*cast(m)\""], ["proof (prove)\nusing this:\n  ((\\<sigma>, s), R:*cast(m), \\<sigma>', s') \\<in> ocnet_sos T\n\ngoal (1 subgoal):\n 1. R:*cast(m) \\<noteq> R:*cast(m)", "by (rule ocnet_sos.cases) auto"], ["proof (state)\nthis:\n  R:*cast(m) \\<noteq> R:*cast(m)\n\ngoal (1 subgoal):\n 1. ((\\<sigma>, s), R:*cast(m), \\<sigma>', s')\n    \\<in> ocnet_sos T \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  R:*cast(m) \\<noteq> R:*cast(m)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ocomplete_no_arrive [simp]:\n  \"((\\<sigma>, s), ii\\<not>ni:arrive(m), (\\<sigma>', s')) \\<notin> ocnet_sos T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<sigma>, s), ii\\<not>ni:arrive(m), \\<sigma>', s')\n    \\<notin> ocnet_sos T", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<sigma>, s), ii\\<not>ni:arrive(m), \\<sigma>', s')\n    \\<in> ocnet_sos T \\<Longrightarrow>\n    False", "assume \"((\\<sigma>, s), ii\\<not>ni:arrive(m), (\\<sigma>', s')) \\<in> ocnet_sos T\""], ["proof (state)\nthis:\n  ((\\<sigma>, s), ii\\<not>ni:arrive(m), \\<sigma>', s') \\<in> ocnet_sos T\n\ngoal (1 subgoal):\n 1. ((\\<sigma>, s), ii\\<not>ni:arrive(m), \\<sigma>', s')\n    \\<in> ocnet_sos T \\<Longrightarrow>\n    False", "hence \"ii\\<not>ni:arrive(m) \\<noteq> ii\\<not>ni:arrive(m)\""], ["proof (prove)\nusing this:\n  ((\\<sigma>, s), ii\\<not>ni:arrive(m), \\<sigma>', s') \\<in> ocnet_sos T\n\ngoal (1 subgoal):\n 1. ii\\<not>ni:arrive(m) \\<noteq> ii\\<not>ni:arrive(m)", "by (rule ocnet_sos.cases) auto"], ["proof (state)\nthis:\n  ii\\<not>ni:arrive(m) \\<noteq> ii\\<not>ni:arrive(m)\n\ngoal (1 subgoal):\n 1. ((\\<sigma>, s), ii\\<not>ni:arrive(m), \\<sigma>', s')\n    \\<in> ocnet_sos T \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  ii\\<not>ni:arrive(m) \\<noteq> ii\\<not>ni:arrive(m)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ocomplete_no_change [elim]:\n  assumes \"((\\<sigma>, s), a, (\\<sigma>', s')) \\<in> ocnet_sos T\"\n      and \"j \\<notin> net_ips s\"\n    shows \"\\<sigma>' j = \\<sigma> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>' j = \\<sigma> j", "using assms"], ["proof (prove)\nusing this:\n  ((\\<sigma>, s), a, \\<sigma>', s') \\<in> ocnet_sos T\n  j \\<notin> net_ips s\n\ngoal (1 subgoal):\n 1. \\<sigma>' j = \\<sigma> j", "by cases simp_all"], ["", "lemma ocomplete_transE [elim]:\n  assumes \"((\\<sigma>, \\<zeta>), a, (\\<sigma>', \\<zeta>')) \\<in> ocnet_sos (trans (opnet onp n))\"\n  obtains a' where \"((\\<sigma>, \\<zeta>), a', (\\<sigma>', \\<zeta>')) \\<in> trans (opnet onp n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        ((\\<sigma>, \\<zeta>), a', \\<sigma>', \\<zeta>')\n        \\<in> automaton.trans (opnet onp n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  ((\\<sigma>, \\<zeta>), a, \\<sigma>', \\<zeta>')\n  \\<in> ocnet_sos (automaton.trans (opnet onp n))\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        ((\\<sigma>, \\<zeta>), a', \\<sigma>', \\<zeta>')\n        \\<in> automaton.trans (opnet onp n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases a) (auto elim!: ocompleteTEs [simplified])"], ["", "abbreviation\n  oclosed :: \"((ip \\<Rightarrow> 's) \\<times> 'l net_state, ('m::msg) node_action) automaton\n              \\<Rightarrow> ((ip \\<Rightarrow> 's) \\<times> 'l net_state, 'm node_action) automaton\"\nwhere\n  \"oclosed \\<equiv> (\\<lambda>A. A \\<lparr> trans := ocnet_sos (trans A) \\<rparr>)\""], ["", "end"]]}