{"file_name": "/home/qj213/afp-2021-10-22/thys/UPF_Firewall/FWNormalisation/NormalisationIntegerPortProof.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UPF_Firewall", "problem_names": ["lemma ConcAssoc: \"C((A \\<oplus> B) \\<oplus> D) = C(A \\<oplus> (B \\<oplus> D))\"", "lemma aux26[simp]: \"twoNetsDistinct a b c d \\<Longrightarrow> \n             dom (C (AllowPortFromTo a b p)) \\<inter> dom (C (DenyAllFromTo c d)) = {}\"", "lemma wp2_aux[rule_format]: \"wellformed_policy2 (xs @ [x]) \\<longrightarrow> \n                             wellformed_policy2 xs\"", "lemma Cdom2: \"x \\<in> dom(C b) \\<Longrightarrow> C (a \\<oplus> b) x = (C b) x\"", "lemma wp2Conc[rule_format]: \"wellformed_policy2 (x#xs) \\<Longrightarrow> wellformed_policy2 xs\"", "lemma DAimpliesMR_E[rule_format]: \"DenyAll \\<in> set p \\<longrightarrow>\n                                   (\\<exists> r. applied_rule_rev C x p = Some r)\"", "lemma DAimplieMR[rule_format]: \"DenyAll \\<in> set p \\<Longrightarrow> applied_rule_rev C x p \\<noteq> None\"", "lemma MRList1[rule_format]: \"x \\<in> dom (C a) \\<Longrightarrow> applied_rule_rev C x (b@[a]) = Some a\"", "lemma MRList2: \"x \\<in> dom (C a) \\<Longrightarrow> applied_rule_rev C x (c@b@[a]) = Some a\"", "lemma MRList3: \n  \"x \\<notin> dom (C xa) \\<Longrightarrow> applied_rule_rev C x (a @ b # xs @ [xa]) = applied_rule_rev C x (a @ b # xs)\"", "lemma CConcEnd[rule_format]: \n  \"C a x = Some y \\<longrightarrow>  C (list2FWpolicy (xs @ [a])) x = Some y\"\n (is \"?P xs\")", "lemma CConcStartaux: \" C a x = None \\<Longrightarrow> (C aa ++ C a) x = C aa x\"", "lemma CConcStart[rule_format]: \n  \"xs \\<noteq> [] \\<longrightarrow> C a x = None \\<longrightarrow> C (list2FWpolicy (xs @ [a])) x = C (list2FWpolicy xs) x\"", "lemma mrNnt[simp]: \"applied_rule_rev C x p = Some a \\<Longrightarrow> p \\<noteq> []\"", "lemma mr_is_C[rule_format]: \n   \"applied_rule_rev C x p = Some a \\<longrightarrow> C (list2FWpolicy (p)) x = C a x\"", "lemma CConcStart2: \n  \"p \\<noteq> [] \\<Longrightarrow> x \\<notin> dom (C a) \\<Longrightarrow> C (list2FWpolicy (p @ [a])) x = C (list2FWpolicy p) x\"", "lemma CConcEnd1: \n  \"q @ p \\<noteq> [] \\<Longrightarrow> x \\<notin> dom (C a) \\<Longrightarrow> C (list2FWpolicy (q @ p @ [a])) x = C (list2FWpolicy (q @ p)) x\"", "lemma CConcEnd2[rule_format]: \n  \"x \\<in> dom (C a) \\<longrightarrow> C (list2FWpolicy (xs @ [a])) x = C a x\"  (is \"?P xs\")", "lemma bar3: \n   \"x \\<in> dom (C (list2FWpolicy (xs @ [xa]))) \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy xs)) \\<or> x \\<in> dom (C xa)\"", "lemma CeqEnd[rule_format,simp]: \n  \"a \\<noteq> [] \\<longrightarrow> x \\<in> dom (C (list2FWpolicy a)) \\<longrightarrow> C (list2FWpolicy(b@a)) x = (C (list2FWpolicy a)) x\"", "lemma CConcStartA[rule_format,simp]: \n  \"x \\<in> dom (C a) \\<longrightarrow> x \\<in> dom (C (list2FWpolicy (a # b)))\" (is \"?P b\")", "lemma domConc: \n  \"x \\<in> dom (C (list2FWpolicy b)) \\<Longrightarrow> b \\<noteq> [] \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy (a @ b)))\"", "lemma CeqStart[rule_format,simp]:\n  \"x\\<notin>dom(C(list2FWpolicy a)) \\<longrightarrow> a\\<noteq>[] \\<longrightarrow> b\\<noteq>[] \\<longrightarrow> C(list2FWpolicy(b@a)) x = (C(list2FWpolicy b)) x\"", "lemma C_eq_if_mr_eq2: \n  \"applied_rule_rev C x a = \\<lfloor>r\\<rfloor> \\<Longrightarrow>\n   applied_rule_rev C x b = \\<lfloor>r\\<rfloor> \\<Longrightarrow> a \\<noteq> [] \\<Longrightarrow> b \\<noteq> [] \\<Longrightarrow> \n   C (list2FWpolicy a) x = C (list2FWpolicy b) x\"", "lemma nMRtoNone[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> applied_rule_rev C x p = None \\<longrightarrow> C (list2FWpolicy p) x = None\"", "lemma C_eq_if_mr_eq: \n \"applied_rule_rev C x b = applied_rule_rev C x a \\<Longrightarrow> a \\<noteq> [] \\<Longrightarrow> b \\<noteq> [] \\<Longrightarrow> \n  C (list2FWpolicy a) x = C (list2FWpolicy b) x\"", "lemma notmatching_notdom: \"applied_rule_rev C x (p@[a]) \\<noteq> Some a \\<Longrightarrow> x \\<notin> dom (C a)\"", "lemma foo3a[rule_format]: \n  \"applied_rule_rev C x (a@[b]@c) = Some b \\<longrightarrow>  r \\<in> set c \\<longrightarrow> b \\<notin> set c \\<longrightarrow> x \\<notin> dom (C r)\"", "lemma foo3D: \n  \"wellformed_policy1 p \\<Longrightarrow> p = DenyAll # ps \\<Longrightarrow> \n   applied_rule_rev C x p = \\<lfloor>DenyAll\\<rfloor> \\<Longrightarrow> r \\<in> set ps \\<Longrightarrow> x \\<notin> dom (C r)\"", "lemma foo4[rule_format]: \n  \"set p = set s \\<and> (\\<forall> r. r \\<in> set p \\<longrightarrow> x \\<notin> dom (C r)) \\<longrightarrow>  (\\<forall> r .r \\<in> set s \\<longrightarrow> x \\<notin> dom (C r))\"", "lemma foo5b[rule_format]: \n  \"x \\<in> dom (C b) \\<longrightarrow> (\\<forall> r. r \\<in> set c \\<longrightarrow> x \\<notin> dom (C r)) \\<longrightarrow> applied_rule_rev C x (b#c) = Some b\"", "lemma mr_first: \n  \"x \\<in> dom (C b) \\<Longrightarrow> \\<forall>r. r \\<in> set c \\<longrightarrow> x \\<notin> dom (C r) \\<Longrightarrow> s = b # c \\<Longrightarrow> applied_rule_rev C x s = \\<lfloor>b\\<rfloor>\"", "lemma mr_charn[rule_format]: \n  \"a \\<in> set p \\<longrightarrow> (x \\<in> dom (C a)) \\<longrightarrow>   (\\<forall> r. r \\<in> set p \\<and> x \\<in> dom (C r) \\<longrightarrow> r = a) \\<longrightarrow>  \n   applied_rule_rev C x p = Some a\"", "lemma foo8: \n  \"\\<forall>r. r \\<in> set p \\<and> x \\<in> dom (C r) \\<longrightarrow> r = a \\<Longrightarrow> set p = set s \\<Longrightarrow> \n   \\<forall>r. r \\<in> set s \\<and> x \\<in> dom (C r) \\<longrightarrow> r = a\"", "lemma mrConcEnd[rule_format]: \n  \"applied_rule_rev C x (b # p) = Some a \\<longrightarrow> a \\<noteq> b \\<longrightarrow>  applied_rule_rev C x p = Some a\"", "lemma wp3tl[rule_format]: \"wellformed_policy3 p \\<longrightarrow> wellformed_policy3 (tl p)\"", "lemma wp3Conc[rule_format]: \"wellformed_policy3 (a#p) \\<longrightarrow> wellformed_policy3 p\"", "lemma foo98[rule_format]:\n  \"applied_rule_rev C x (aa # p) = Some a \\<longrightarrow> x \\<in> dom (C r) \\<longrightarrow>  r \\<in> set p \\<longrightarrow> a \\<in> set p\"", "lemma mrMTNone[simp]: \"applied_rule_rev C x [] = None\"", "lemma DAAux[simp]: \"x \\<in> dom (C DenyAll)\"", "lemma mrSet[rule_format]: \"applied_rule_rev C x p = Some r \\<longrightarrow> r \\<in> set p\"", "lemma mr_not_Conc: \"singleCombinators p \\<Longrightarrow> applied_rule_rev C x p \\<noteq> Some (a\\<oplus>b)\"", "lemma foo25[rule_format]: \"wellformed_policy3 (p@[x]) \\<longrightarrow> wellformed_policy3 p\"", "lemma mr_in_dom[rule_format]: \"applied_rule_rev C x p = Some a \\<longrightarrow> x \\<in> dom (C a)\"", "lemma wp3EndMT[rule_format]: \n  \"wellformed_policy3 (p@[xs]) \\<longrightarrow>  AllowPortFromTo a b po \\<in> set p \\<longrightarrow>\n   dom (C (AllowPortFromTo a b po)) \\<inter> dom (C xs) = {}\"", "lemma foo29: \"\\<lbrakk>dom (C a) \\<noteq> {}; dom (C a) \\<inter> dom (C b) = {}\\<rbrakk> \\<Longrightarrow> a \\<noteq> b\"", "lemma foo28:  \n  \"AllowPortFromTo a b po \\<in> set p \\<Longrightarrow> dom (C (AllowPortFromTo a b po)) \\<noteq> {} \\<Longrightarrow> \n   wellformed_policy3 (p @ [x])   \\<Longrightarrow> x \\<noteq> AllowPortFromTo a b po\"", "lemma foo28a[rule_format]: \"x \\<in> dom (C a) \\<Longrightarrow> dom (C a) \\<noteq> {}\"", "lemma allow_deny_dom[simp]: \n  \"dom (C (AllowPortFromTo a b po)) \\<subseteq> dom (C (DenyAllFromTo a b))\"", "lemma DenyAllowDisj: \n  \"dom (C (AllowPortFromTo a b p)) \\<noteq> {} \\<Longrightarrow> \n   dom (C (DenyAllFromTo a b)) \\<inter> dom (C (AllowPortFromTo a b p))  \\<noteq> {}\"", "lemma foo31: \n  \"\\<forall>r. r \\<in> set p \\<and> x \\<in> dom (C r) \\<longrightarrow> \n       r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll \\<Longrightarrow>\n   set p = set s \\<Longrightarrow> \n   \\<forall>r. r \\<in> set s \\<and> x \\<in> dom (C r) \\<longrightarrow> r=AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll\"", "lemma wp1_auxa: \n  \"wellformed_policy1_strong p\\<Longrightarrow>(\\<exists> r. applied_rule_rev C x p = Some r)\"", "lemma deny_dom[simp]:  \n  \"twoNetsDistinct a b c d \\<Longrightarrow> dom (C (DenyAllFromTo a b)) \\<inter> dom (C (DenyAllFromTo c d)) = {}\"", "lemma domTrans: \"dom a \\<subseteq> dom b \\<Longrightarrow> dom b \\<inter> dom c = {} \\<Longrightarrow> dom a \\<inter> dom c = {}\"", "lemma DomInterAllowsMT:\n  \"twoNetsDistinct a b c d  \\<Longrightarrow> \ndom (C (AllowPortFromTo a b p)) \\<inter> dom (C (AllowPortFromTo c d po)) = {}\"", "lemma DomInterAllowsMT_Ports: \n  \"p \\<noteq> po \\<Longrightarrow> dom (C (AllowPortFromTo a b p)) \\<inter> dom (C (AllowPortFromTo c d po)) = {}\"", "lemma wellformed_policy3_charn[rule_format]: \n  \"singleCombinators p \\<longrightarrow> distinct p \\<longrightarrow> allNetsDistinct p \\<longrightarrow> \n   wellformed_policy1 p \\<longrightarrow> wellformed_policy2 p  \\<longrightarrow> wellformed_policy3 p\"", "lemma DistinctNetsDenyAllow: \n \"DenyAllFromTo b c \\<in> set p \\<Longrightarrow>\n  AllowPortFromTo a d po \\<in> set p \\<Longrightarrow>\n  allNetsDistinct p \\<Longrightarrow> dom (C (DenyAllFromTo b c)) \\<inter> dom (C (AllowPortFromTo a d po)) \\<noteq> {} \\<Longrightarrow> \n  b = a \\<and> c = d\"", "lemma DistinctNetsAllowAllow: \n \"AllowPortFromTo b c poo \\<in> set p \\<Longrightarrow>\n    AllowPortFromTo a d po \\<in> set p \\<Longrightarrow>\n    allNetsDistinct p \\<Longrightarrow> \n    dom (C (AllowPortFromTo b c poo)) \\<inter> dom (C (AllowPortFromTo a d po)) \\<noteq> {} \\<Longrightarrow> \n    b = a \\<and> c = d \\<and> poo = po\"", "lemma WP2RS2[simp]: \n  \"singleCombinators p \\<Longrightarrow> distinct p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> \n   wellformed_policy2 (removeShadowRules2 p)\"", "lemma AD_aux: \n  \"AllowPortFromTo a b po \\<in> set p \\<Longrightarrow>  DenyAllFromTo c d \\<in> set p \\<Longrightarrow>\n   allNetsDistinct p \\<Longrightarrow>  singleCombinators p \\<Longrightarrow> a \\<noteq> c \\<or> b \\<noteq> d \\<Longrightarrow> \n   dom (C (AllowPortFromTo a b po)) \\<inter> dom (C (DenyAllFromTo c d)) = {}\"", "lemma sorted_WP2[rule_format]: \"sorted p l \\<longrightarrow> all_in_list p l \\<longrightarrow> distinct p \\<longrightarrow> \n            allNetsDistinct p \\<longrightarrow> singleCombinators p \\<longrightarrow> wellformed_policy2 p\"", "lemma wellformed2_sorted[simp]: \n  \"all_in_list p l \\<Longrightarrow> distinct p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> \n   singleCombinators p \\<Longrightarrow> wellformed_policy2 (sort p l)\"", "lemma wellformed2_sortedQ[simp]: \"\\<lbrakk>all_in_list p l; distinct p; allNetsDistinct p;\n                         singleCombinators p\\<rbrakk> \\<Longrightarrow> wellformed_policy2 (qsort p l)\"", "lemma C_DenyAll[simp]: \"C (list2FWpolicy (xs @ [DenyAll])) x = Some (deny ())\"", "lemma C_eq_RS1n:\n  \"C(list2FWpolicy (removeShadowRules1_alternative p)) = C(list2FWpolicy p)\"", "lemma C_eq_RS1[simp]: \n  \"p \\<noteq> [] \\<Longrightarrow>  C(list2FWpolicy (removeShadowRules1 p)) = C(list2FWpolicy p)\"", "lemma EX_MR_aux[rule_format]: \n  \"applied_rule_rev C x (DenyAll # p) \\<noteq> Some DenyAll \\<longrightarrow> (\\<exists>y. applied_rule_rev C x p = Some y)\"", "lemma EX_MR : \n  \"applied_rule_rev C x p \\<noteq> \\<lfloor>DenyAll\\<rfloor> \\<Longrightarrow> p = DenyAll # ps \\<Longrightarrow> \n applied_rule_rev C x p = applied_rule_rev C x ps\"", "lemma mr_not_DA:\n  \"wellformed_policy1_strong s \\<Longrightarrow>\n   applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a ab\\<rfloor> \\<Longrightarrow> set p = set s \\<Longrightarrow>\n   applied_rule_rev C x s \\<noteq> \\<lfloor>DenyAll\\<rfloor>\"", "lemma domsMT_notND_DD: \n  \"dom (C (DenyAllFromTo a b)) \\<inter> dom (C (DenyAllFromTo c d)) \\<noteq> {} \\<Longrightarrow> \\<not> netsDistinct a c\"", "lemma domsMT_notND_DD2: \n  \"dom (C (DenyAllFromTo a b)) \\<inter> dom (C (DenyAllFromTo c d)) \\<noteq> {} \\<Longrightarrow> \\<not> netsDistinct b d\"", "lemma domsMT_notND_DD3: \n  \"x \\<in> dom (C (DenyAllFromTo a b)) \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo c d)) \\<Longrightarrow>  \\<not> netsDistinct a c\"", "lemma domsMT_notND_DD4: \n  \"x \\<in> dom (C (DenyAllFromTo a b)) \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo c d)) \\<Longrightarrow> \\<not> netsDistinct b d\"", "lemma NetsEq_if_sameP_DD: \n  \"allNetsDistinct p \\<Longrightarrow>  u \\<in> set p \\<Longrightarrow>  v \\<in> set p \\<Longrightarrow> u = DenyAllFromTo a b \\<Longrightarrow> \n   v = DenyAllFromTo c d \\<Longrightarrow> x \\<in> dom (C u) \\<Longrightarrow> x \\<in> dom (C v) \\<Longrightarrow> a = c \\<and> b = d\"", "lemma rule_charn1: \n  assumes aND: \"allNetsDistinct p\"\n    and mr_is_allow: \"applied_rule_rev C x p = Some (AllowPortFromTo a b po)\"\n    and SC: \"singleCombinators p\"\n    and inp: \"r \\<in> set p\" \n    and inDom: \"x \\<in> dom (C r)\"\n  shows \"(r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll)\"", "lemma none_MT_rulessubset[rule_format]: \n  \"none_MT_rules C a \\<longrightarrow> set b \\<subseteq> set a \\<longrightarrow> none_MT_rules C b\"", "lemma nMTSort: \"none_MT_rules C p \\<Longrightarrow> none_MT_rules C (sort p l)\"", "lemma nMTSortQ: \"none_MT_rules C p \\<Longrightarrow> none_MT_rules C (qsort p l)\"", "lemma wp3char[rule_format]: \n  \"none_MT_rules C xs \\<and> C (AllowPortFromTo a b po)=\\<emptyset> \\<and> wellformed_policy3(xs@[DenyAllFromTo a b]) \\<longrightarrow>\n AllowPortFromTo a b po \\<notin> set xs\"", "lemma wp3charn[rule_format]: \n  assumes domAllow: \"dom (C (AllowPortFromTo a b po)) \\<noteq> {}\" \n    and     wp3:      \"wellformed_policy3 (xs @ [DenyAllFromTo a b])\"\n  shows             \"AllowPortFromTo a b po \\<notin> set xs\"", "lemma rule_charn2: \n  assumes aND: \"allNetsDistinct p\"\n    and wp1: \"wellformed_policy1 p\"\n    and SC: \"singleCombinators p\"\n    and wp3: \"wellformed_policy3 p\"\n    and allow_in_list: \"AllowPortFromTo c d po \\<in> set p\"\n    and x_in_dom_allow: \"x \\<in> dom (C (AllowPortFromTo c d po))\"\n  shows  \"applied_rule_rev C x p = Some (AllowPortFromTo c d po)\"", "lemma rule_charn3: \n  \" wellformed_policy1 p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> singleCombinators p \\<Longrightarrow>\n   wellformed_policy3 p \\<Longrightarrow> applied_rule_rev C x p = \\<lfloor>DenyAllFromTo c d\\<rfloor> \\<Longrightarrow> \n   AllowPortFromTo a b po \\<in> set p \\<Longrightarrow> x \\<notin> dom (C (AllowPortFromTo a b po))\"", "lemma rule_charn4: \n  assumes wp1: \"wellformed_policy1 p\" \n    and aND: \"allNetsDistinct p\" \n    and SC: \"singleCombinators p\"\n    and wp3: \"wellformed_policy3 p\"  \n    and DA: \"DenyAll \\<notin> set p\" \n    and mr: \"applied_rule_rev C x p = Some (DenyAllFromTo a b)\"\n    and rinp: \"r \\<in> set p\"\n    and xindom: \"x \\<in> dom (C r)\"\n  shows \"r = DenyAllFromTo a b\"", "lemma foo31a: \n  \"\\<forall>r. r \\<in> set p \\<and> x \\<in> dom (C r) \\<longrightarrow> r=AllowPortFromTo a b po \\<or> r=DenyAllFromTo a b \\<or> r=DenyAll \\<Longrightarrow>\n    set p = set s \\<Longrightarrow> r \\<in> set s \\<Longrightarrow> x \\<in> dom (C r) \\<Longrightarrow> \n   r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll\"", "lemma aux4[rule_format]: \n  \"applied_rule_rev C x (a#p) = Some a \\<longrightarrow> a \\<notin> set (p) \\<longrightarrow> applied_rule_rev C x p = None\"", "lemma mrDA_tl: \n  assumes mr_DA: \"applied_rule_rev C x p = Some DenyAll\"\n    and     wp1n:  \"wellformed_policy1_strong p\"\n  shows          \"applied_rule_rev C x (tl p) = None\"", "lemma rule_charnDAFT: \n  \"wellformed_policy1_strong p \\<Longrightarrow>  allNetsDistinct p \\<Longrightarrow>  singleCombinators p \\<Longrightarrow>\n    wellformed_policy3 p \\<Longrightarrow> applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor> \\<Longrightarrow> r \\<in> set (tl p) \\<Longrightarrow> \n    x \\<in> dom (C r) \\<Longrightarrow> r = DenyAllFromTo a b\"", "lemma mrDenyAll_is_unique: \n  \"\\<lbrakk>wellformed_policy1_strong p; applied_rule_rev C x p = Some DenyAll;\n   r \\<in> set (tl p)\\<rbrakk> \\<Longrightarrow> x \\<notin> dom (C r)\"", "theorem  C_eq_Sets_mr: \n  assumes sets_eq: \"set p = set s\"\n    and SC:          \"singleCombinators p\"\n    and wp1_p:       \"wellformed_policy1_strong p\"\n    and wp1_s:       \"wellformed_policy1_strong s\"\n    and wp3_p:       \"wellformed_policy3 p\"       \n    and wp3_s:       \"wellformed_policy3 s\"  \n    and aND:         \"allNetsDistinct p\"        \n  shows \"applied_rule_rev C x p = applied_rule_rev C x s\"", "lemma C_eq_Sets: \n  \"singleCombinators p \\<Longrightarrow>  wellformed_policy1_strong p \\<Longrightarrow>  wellformed_policy1_strong s \\<Longrightarrow>\n   wellformed_policy3 p \\<Longrightarrow>  wellformed_policy3 s \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> set p = set s \\<Longrightarrow> \n   C (list2FWpolicy p) x = C (list2FWpolicy s) x\"", "lemma C_eq_sorted: \n  \"distinct p \\<Longrightarrow> all_in_list p l \\<Longrightarrow> singleCombinators p \\<Longrightarrow> wellformed_policy1_strong p \\<Longrightarrow>\n    wellformed_policy3 p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> \n   C (list2FWpolicy (FWNormalisationCore.sort p l)) = C (list2FWpolicy p)\"", "lemma C_eq_sortedQ: \n  \"distinct p \\<Longrightarrow> all_in_list p l \\<Longrightarrow> singleCombinators p \\<Longrightarrow> wellformed_policy1_strong p \\<Longrightarrow>\n   wellformed_policy3 p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> \n   C (list2FWpolicy (qsort p l)) = C (list2FWpolicy p)\"", "lemma C_eq_RS2_mr: \"applied_rule_rev C x (removeShadowRules2 p)= applied_rule_rev C x p\"", "lemma C_eq_None[rule_format]: \n  \"p \\<noteq> []  --> applied_rule_rev C x p = None \\<longrightarrow>  C (list2FWpolicy p) x = None\"", "lemma C_eq_None2:\n  \"a \\<noteq> [] \\<Longrightarrow> b \\<noteq> [] \\<Longrightarrow> applied_rule_rev C x a = \\<bottom> \\<Longrightarrow> applied_rule_rev C x b = \\<bottom> \\<Longrightarrow> \n   C (list2FWpolicy a) x = C (list2FWpolicy b) x\"", "lemma C_eq_RS2: \n  \"wellformed_policy1_strong p \\<Longrightarrow> C (list2FWpolicy (removeShadowRules2 p))= C (list2FWpolicy p)\"", "lemma none_MT_rulesRS2: \n  \"none_MT_rules C p \\<Longrightarrow> none_MT_rules C (removeShadowRules2 p)\"", "lemma CconcNone: \n  \"dom (C a) = {} \\<Longrightarrow> p \\<noteq> [] \\<Longrightarrow> C (list2FWpolicy (a # p)) x = C (list2FWpolicy p) x\"", "lemma none_MT_rulesrd[rule_format]: \n  \"none_MT_rules C p \\<longrightarrow> none_MT_rules C (remdups p)\"", "lemma DARS3[rule_format]:\n  \"DenyAll \\<notin> set p\\<longrightarrow>DenyAll \\<notin> set (rm_MT_rules C p)\"", "lemma DAnMT: \"dom (C DenyAll) \\<noteq> {}\"", "lemma DAnMT2: \"C DenyAll \\<noteq> Map.empty\"", "lemma wp1n_RS3[rule_format,simp]: \n  \"wellformed_policy1_strong p \\<longrightarrow>  wellformed_policy1_strong (rm_MT_rules C p)\"", "lemma AILRS3[rule_format,simp]: \n  \"all_in_list p l \\<longrightarrow> all_in_list (rm_MT_rules C p) l\"", "lemma SCRS3[rule_format,simp]: \n  \"singleCombinators p \\<longrightarrow> singleCombinators(rm_MT_rules C p)\"", "lemma RS3subset: \"set (rm_MT_rules C p)  \\<subseteq> set p \"", "lemma ANDRS3[simp]: \n  \"singleCombinators p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> allNetsDistinct (rm_MT_rules C p)\"", "lemma nlpaux: \"x \\<notin> dom (C b) \\<Longrightarrow> C (a \\<oplus> b) x = C a x\"", "lemma notindom[rule_format]: \n  \"a \\<in> set p \\<longrightarrow>  x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow>  x \\<notin> dom (C a)\"", "lemma C_eq_rd[rule_format]: \n  \"p \\<noteq> [] \\<Longrightarrow> C (list2FWpolicy (remdups p)) = C (list2FWpolicy p)\"", "lemma nMT_domMT:\n  \"\\<not> not_MT C  p \\<Longrightarrow> p \\<noteq> [] \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy p))\"", "lemma C_eq_RS3_aux[rule_format]: \n  \"not_MT C  p \\<Longrightarrow>  C (list2FWpolicy p) x = C (list2FWpolicy (rm_MT_rules C p)) x\"", "lemma C_eq_id: \n  \"wellformed_policy1_strong p \\<Longrightarrow>  C(list2FWpolicy (insertDeny p)) = C (list2FWpolicy p)\"", "lemma C_eq_RS3: \n  \"not_MT C  p \\<Longrightarrow> C(list2FWpolicy (rm_MT_rules C p)) = C (list2FWpolicy p)\"", "lemma NMPrd[rule_format]:  \"not_MT C  p \\<longrightarrow> not_MT C  (remdups p)\"", "lemma NMPDA[rule_format]: \"DenyAll \\<in> set p \\<longrightarrow> not_MT C  p\"", "lemma NMPiD[rule_format]: \"not_MT C  (insertDeny p)\"", "lemma list2FWpolicy2list[rule_format]: \"C (list2FWpolicy(policy2list p)) = (C p)\"", "lemmas C_eq_Lemmas = none_MT_rulesRS2 none_MT_rulesrd  SCp2l  wp1n_RS2  wp1ID NMPiD wp1_eq\n                     wp1alternative_RS1 p2lNmt list2FWpolicy2list wellformed_policy3_charn waux2", "lemmas C_eq_subst_Lemmas = C_eq_sorted C_eq_sortedQ C_eq_RS2 C_eq_rd C_eq_RS3 C_eq_id", "lemma C_eq_All_untilSorted: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n    C (list2FWpolicy\n        (FWNormalisationCore.sort\n          (removeShadowRules2 (remdups (rm_MT_rules C \n             (insertDeny (removeShadowRules1 (policy2list p)))))) l)) =\n    C p\"", "lemma C_eq_All_untilSortedQ: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n    C (list2FWpolicy\n        (qsort (removeShadowRules2 (remdups (rm_MT_rules C \n             (insertDeny (removeShadowRules1 (policy2list p)))))) l)) =\n    C p\"", "lemma C_eq_All_untilSorted_withSimps: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow>all_in_list(policy2list p) l \\<Longrightarrow> allNetsDistinct (policy2list p) \\<Longrightarrow>\n    C (list2FWpolicy\n        (FWNormalisationCore.sort\n          (removeShadowRules2 (remdups (rm_MT_rules C \n              (insertDeny (removeShadowRules1 (policy2list p)))))) l)) =\n    C p\"", "lemma C_eq_All_untilSorted_withSimpsQ: \n  \" DenyAll\\<in>set(policy2list p)\\<Longrightarrow>all_in_list(policy2list p) l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n    C (list2FWpolicy\n        (qsort (removeShadowRules2 (remdups (rm_MT_rules C \n             (insertDeny (removeShadowRules1 (policy2list p)))))) l)) =\n    C p\"", "lemma InDomConc[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> x \\<in> dom (C (list2FWpolicy (p))) \\<longrightarrow> x \\<in>  dom (C (list2FWpolicy (a#p)))\"", "lemma not_in_member[rule_format]: \"member a b \\<longrightarrow> x \\<notin> dom (C b) \\<longrightarrow> x \\<notin> dom (C a)\"", "lemma src_in_sdnets[rule_format]: \n  \"\\<not> member DenyAll x \\<longrightarrow> p \\<in> dom (C x) \\<longrightarrow> subnetsOfAdr (src p) \\<inter> (fst_set (sdnets x)) \\<noteq> {}\"", "lemma dest_in_sdnets[rule_format]: \n  \"\\<not> member DenyAll x \\<longrightarrow> p \\<in> dom (C x) \\<longrightarrow>  subnetsOfAdr (dest p) \\<inter> (snd_set (sdnets x)) \\<noteq> {}\"", "lemma sdnets_in_subnets[rule_format]: \n  \"p\\<in> dom (C x) \\<longrightarrow> \\<not> member DenyAll x \\<longrightarrow>\n        (\\<exists> (a,b)\\<in>sdnets x. a \\<in> subnetsOfAdr (src p) \\<and> b \\<in> subnetsOfAdr (dest p))\"", "lemma disjSD_no_p_in_both[rule_format]:   \n  \"disjSD_2 x y \\<Longrightarrow> \\<not> member DenyAll x \\<Longrightarrow> \\<not> member DenyAll y \\<Longrightarrow> p \\<in> dom(C x) \\<Longrightarrow> p \\<in> dom(C y) \\<Longrightarrow> \n  False\"", "lemma list2FWpolicy_eq: \n  \"zs \\<noteq> [] \\<Longrightarrow>  C (list2FWpolicy (x \\<oplus> y # z)) p = C (x \\<oplus> list2FWpolicy (y # z)) p\"", "lemma dom_sep[rule_format]: \n  \"x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow> x \\<in> dom (C (list2FWpolicy(separate p)))\"", "lemma domdConcStart[rule_format]: \n  \"x \\<in> dom (C (list2FWpolicy (a#b))) \\<longrightarrow> x \\<notin> dom (C (list2FWpolicy b)) \\<longrightarrow> x \\<in> dom (C (a))\"", "lemma sep_dom2_aux: \n  \" x \\<in> dom (C (list2FWpolicy (a \\<oplus> y # z))) \\<Longrightarrow> x \\<in> dom (C (a \\<oplus> list2FWpolicy (y # z)))\"", "lemma sep_dom2_aux2: \n  \"x \\<in> dom (C (list2FWpolicy (separate (y # z)))) \\<longrightarrow> x \\<in> dom (C (list2FWpolicy (y # z))) \\<Longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (a # separate (y # z)))) \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy (a \\<oplus> y # z)))\"", "lemma sep_dom2[rule_format]: \n  \"x \\<in> dom (C (list2FWpolicy (separate p))) \\<longrightarrow> x \\<in> dom (C (list2FWpolicy( p)))\"", "lemma sepDom: \"dom (C (list2FWpolicy p)) = dom (C (list2FWpolicy (separate p)))\"", "lemma C_eq_s_ext[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow>  C (list2FWpolicy (separate p)) a  = C (list2FWpolicy p) a \"", "lemma C_eq_s: \n  \"p \\<noteq> [] \\<Longrightarrow> C (list2FWpolicy (separate p)) = C (list2FWpolicy p)\"", "lemma sortnMTQ: \"p \\<noteq> [] \\<Longrightarrow> qsort p l \\<noteq> []\"", "lemmas C_eq_Lemmas_sep =\n       C_eq_Lemmas sortnMT sortnMTQ RS2_NMT NMPrd not_MTimpnotMT", "lemma C_eq_until_separated:\n  \" DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p)l \\<Longrightarrow> allNetsDistinct (policy2list p) \\<Longrightarrow>\n    C (list2FWpolicy\n        (separate\n          (FWNormalisationCore.sort\n            (removeShadowRules2 (remdups (rm_MT_rules C \n               (insertDeny (removeShadowRules1 (policy2list p)))))) l))) =\n    C p\"", "lemma C_eq_until_separatedQ:\n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p)l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n    C (list2FWpolicy\n        (separate (qsort (removeShadowRules2 (remdups (rm_MT_rules C \n             (insertDeny (removeShadowRules1 (policy2list p)))))) l))) =\n    C p\"", "lemma domID[rule_format]: \"p \\<noteq> [] \\<and> x \\<in> dom(C(list2FWpolicy p)) \\<longrightarrow>\n                           x \\<in> dom (C(list2FWpolicy(insertDenies p)))\"", "lemma DA_is_deny: \n  \"x \\<in> dom (C (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)) \\<Longrightarrow>\n   C (DenyAllFromTo a b\\<oplus>DenyAllFromTo b a \\<oplus> DenyAllFromTo a b) x = Some (deny ())\"", "lemma iDdomAux[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow>\n   x \\<in> dom (C (list2FWpolicy (insertDenies p))) \\<longrightarrow>\n   C (list2FWpolicy (insertDenies p)) x = Some (deny ())\"", "lemma iD_isD[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow> \n   C (DenyAll \\<oplus> list2FWpolicy (insertDenies p)) x = C DenyAll x\"", "lemma inDomConc:\"\\<lbrakk> x\\<notin>dom (C a); x\\<notin>dom (C (list2FWpolicy p))\\<rbrakk> \\<Longrightarrow>\n                 x \\<notin> dom (C (list2FWpolicy(a#p)))\"", "lemma domsdisj[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> (\\<forall> x s. s \\<in> set p \\<and> x \\<in> dom (C A) \\<longrightarrow>  x \\<notin> dom (C s)) \\<longrightarrow> y \\<in> dom (C A) \\<longrightarrow>\n   y \\<notin> dom (C (list2FWpolicy p))\"", "lemma isSepaux:\n  \" p \\<noteq> [] \\<Longrightarrow> noDenyAll (a # p) \\<Longrightarrow> separated (a # p) \\<Longrightarrow>\n    x \\<in> dom (C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus> \n                DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a)) \\<Longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy p))\"", "lemma none_MT_rulessep[rule_format]: \"none_MT_rules C p \\<longrightarrow> none_MT_rules C (separate p)\"", "lemma dom_id: \n  \"noDenyAll(a#p) \\<Longrightarrow> separated(a#p) \\<Longrightarrow> p \\<noteq> [] \\<Longrightarrow> x\\<notin>dom(C(list2FWpolicy p)) \\<Longrightarrow> x\\<in>dom (C a) \\<Longrightarrow> \n   x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\"", "lemma C_eq_iD_aux2[rule_format]: \n  \"noDenyAll1 p \\<longrightarrow> separated p\\<longrightarrow> p \\<noteq> []\\<longrightarrow> x \\<in> dom (C (list2FWpolicy p))\\<longrightarrow>\n  C(list2FWpolicy (insertDenies p)) x = C(list2FWpolicy p) x\"", "lemma C_eq_iD: \n  \"separated p \\<Longrightarrow> noDenyAll1 p \\<Longrightarrow> wellformed_policy1_strong p \\<Longrightarrow> \n   C (list2FWpolicy (insertDenies p)) = C (list2FWpolicy p)\"", "lemma noDAsortQ[rule_format]: \"noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)\"", "lemma NetsCollectedSortQ: \n  \"distinct p \\<Longrightarrow>noDenyAll1 p \\<Longrightarrow> all_in_list p l \\<Longrightarrow>  singleCombinators p \\<Longrightarrow> \n   NetsCollected (qsort p l)\"", "lemmas CLemmas =  nMTSort nMTSortQ none_MT_rulesRS2 none_MT_rulesrd\n                  noDAsort noDAsortQ nDASC wp1_eq  wp1ID  \n                  SCp2l ANDSep   wp1n_RS2 \n                  OTNSEp OTNSC noDA1sep wp1_alternativesep wellformed_eq \n                  wellformed1_alternative_sorted", "lemmas C_eqLemmas_id = CLemmas  NC2Sep NetsCollectedSep \n                       NetsCollectedSort NetsCollectedSortQ separatedNC", "lemma C_eq_Until_InsertDenies: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p)l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n   C (list2FWpolicy\n        (insertDenies\n          (separate\n            (FWNormalisationCore.sort\n              (removeShadowRules2 (remdups (rm_MT_rules C \n                  (insertDeny (removeShadowRules1 (policy2list p)))))) l)))) =\n    C p\"", "lemma C_eq_Until_InsertDeniesQ: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p)l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n   C(list2FWpolicy\n       (insertDenies\n          (separate (qsort (removeShadowRules2 (remdups (rm_MT_rules C \n              (insertDeny (removeShadowRules1 (policy2list p)))))) l)))) =\n    C p\"", "lemma C_eq_RD_aux[rule_format]: \"C (p) x = C (removeDuplicates p) x\"", "lemma C_eq_RAD_aux[rule_format]: \n  \"p \\<noteq> []  \\<longrightarrow> C (list2FWpolicy p) x = C (list2FWpolicy (removeAllDuplicates p)) x\"", "lemma C_eq_RAD: \n  \"p \\<noteq> []  \\<Longrightarrow> C (list2FWpolicy p) = C (list2FWpolicy (removeAllDuplicates p)) \"", "lemma C_eq_compile: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p)l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n    C (list2FWpolicy\n        (removeAllDuplicates\n          (insertDenies\n            (separate\n              (FWNormalisationCore.sort\n                (removeShadowRules2 (remdups (rm_MT_rules C \n                    (insertDeny (removeShadowRules1 (policy2list p)))))) l))))) =\n    C p\"", "lemma C_eq_compileQ: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p)l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n   C (list2FWpolicy\n       (removeAllDuplicates\n         (insertDenies\n           (separate\n             (qsort (removeShadowRules2 (remdups (rm_MT_rules C \n                  (insertDeny (removeShadowRules1 (policy2list p)))))) l))))) =\n    C p\"", "lemma C_eq_normalize: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> allNetsDistinct (policy2list p) \\<Longrightarrow>\n all_in_list(policy2list p)(Nets_List p) \\<Longrightarrow> \n C (list2FWpolicy (normalize p)) = C p\"", "lemma C_eq_normalizeQ: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> allNetsDistinct (policy2list p) \\<Longrightarrow> \n   all_in_list (policy2list p) (Nets_List p) \\<Longrightarrow> \n   C (list2FWpolicy (normalizeQ p)) = C p\"", "lemma domSubset3: \"dom (C (DenyAll \\<oplus> x)) = dom (C (DenyAll))\"", "lemma domSubset4: \n  \"dom (C (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x \\<oplus> AllowPortFromTo x y dn)) = \n   dom (C (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x))\"", "lemma domSubset5: \n  \"dom (C (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x \\<oplus> AllowPortFromTo y x dn)) = \n  dom (C (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x))\"", "lemma domSubset1: \n  \"dom (C (DenyAllFromTo one two \\<oplus> DenyAllFromTo two one \\<oplus> AllowPortFromTo one two dn \\<oplus> x)) = \n   dom (C (DenyAllFromTo one two \\<oplus> DenyAllFromTo two one \\<oplus> x))\"", "lemma domSubset2: \n  \"dom (C (DenyAllFromTo one two \\<oplus> DenyAllFromTo two one \\<oplus> AllowPortFromTo two one dn \\<oplus> x)) = \n  dom (C (DenyAllFromTo one two \\<oplus> DenyAllFromTo two one \\<oplus> x))\"", "lemma ConcAssoc2: \"C (X \\<oplus> Y \\<oplus> ((A \\<oplus> B) \\<oplus> D)) = C (X \\<oplus> Y \\<oplus> A \\<oplus> B \\<oplus> D)\"", "lemma ConcAssoc3: \"C (X \\<oplus> ((Y \\<oplus> A) \\<oplus> D)) = C (X \\<oplus> Y \\<oplus> A \\<oplus> D)\"", "lemma RS3_NMT[rule_format]: \n  \"DenyAll \\<in> set p \\<longrightarrow> rm_MT_rules C p \\<noteq> []\"", "lemma norm_notMT: \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> normalize p \\<noteq> []\"", "lemma norm_notMTQ: \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> normalizeQ p \\<noteq> []\"", "lemmas domDA = NormalisationIntegerPortProof.domSubset3", "lemmas domain_reasoning = domDA ConcAssoc2 domSubset1 domSubset2 \n                          domSubset3 domSubset4  domSubset5 domSubsetDistr1\n                          domSubsetDistr2 domSubsetDistrA domSubsetDistrD coerc_assoc ConcAssoc \n                          ConcAssoc3", "lemma list2policyR_Start[rule_format]: \"p \\<in> dom (C a) \\<longrightarrow>\n                 C (list2policyR (a # list)) p = C a p\"", "lemma list2policyR_End: \"p \\<notin> dom (C a) \\<Longrightarrow>\n        C (list2policyR (a # list)) p = (C a \\<Oplus> list2policy (map C list)) p\"", "lemma l2polR_eq_el[rule_format]: \n  \"N \\<noteq> [] \\<longrightarrow> C(list2policyR N) p =  (list2policy (map C N)) p\"", "lemma l2polR_eq: \n  \"N \\<noteq> [] \\<Longrightarrow> C( list2policyR N) =  (list2policy (map C N))\"", "lemma list2FWpolicys_eq_el[rule_format]: \n  \"Filter \\<noteq> []  \\<longrightarrow>  C (list2policyR Filter) p =  C (list2FWpolicy (rev Filter)) p\"", "lemma list2FWpolicys_eq: \n  \"Filter \\<noteq> []  \\<Longrightarrow> C (list2policyR Filter) =  C (list2FWpolicy (rev Filter))\"", "lemma list2FWpolicys_eq_sym: \n  \"Filter \\<noteq> [] \\<Longrightarrow>C (list2policyR (rev Filter)) =  C (list2FWpolicy Filter)\"", "lemma p_eq[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow>  list2policy (map C (rev p)) = C (list2FWpolicy p)\"", "lemma p_eq2[rule_format]: \n  \"normalize x \\<noteq> [] \\<longrightarrow> C(list2FWpolicy(normalize x)) = C x \\<longrightarrow> \n   list2policy(map C (rev(normalize x))) = C x\"", "lemma p_eq2Q[rule_format]: \n  \"normalizeQ x \\<noteq> [] \\<longrightarrow>  C (list2FWpolicy (normalizeQ x)) = C x \\<longrightarrow>\n   list2policy (map C (rev (normalizeQ x))) = C x\"", "lemma list2listNMT[rule_format]: \"x \\<noteq> [] \\<longrightarrow>map sem x \\<noteq> []\"", "lemma Norm_Distr2: \n  \"r o_f ((P \\<Otimes>\\<^sub>2 (list2policy Q)) o d) = (list2policy ((P \\<Otimes>\\<^sub>L Q) (\\<Otimes>\\<^sub>2) r d))\"", "lemma NATDistr: \n  \"N \\<noteq> [] \\<Longrightarrow> F = C (list2policyR N) \\<Longrightarrow>\n    (\\<lambda>(x, y). x) o\\<^sub>f (NAT \\<Otimes>\\<^sub>2 F \\<circ> (\\<lambda>x. (x, x))) = \n    list2policy ((NAT \\<Otimes>\\<^sub>L map C N) (\\<Otimes>\\<^sub>2) (\\<lambda>(x, y). x) (\\<lambda>x. (x, x)))\"", "lemma C_eq_normalize_manual: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow> \n C (list2FWpolicy (normalize_manual_order p l)) = C p\"", "lemma p_eq2_manualQ[rule_format]: \n  \"normalize_manual_orderQ x l \\<noteq> [] \\<longrightarrow> C(list2FWpolicy (normalize_manual_orderQ x l)) = C x \\<longrightarrow>\n   list2policy (map C (rev (normalize_manual_orderQ x l))) = C x\"", "lemma norm_notMT_manualQ: \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> normalize_manual_orderQ p l \\<noteq> []\"", "lemma C_eq_normalize_manualQ: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow> \n   C (list2FWpolicy (normalize_manual_orderQ p l)) = C p\"", "lemma p_eq2_manual[rule_format]: \n  \"normalize_manual_order x l \\<noteq> [] \\<longrightarrow> C (list2FWpolicy (normalize_manual_order x l)) = C x \\<longrightarrow>\n   list2policy (map C (rev (normalize_manual_order x l))) = C x\"", "lemma norm_notMT_manual: \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> normalize_manual_order p l \\<noteq> []\"", "lemma normalizeNAT: \n  \"DenyAll \\<in> set (policy2list Filter) \\<Longrightarrow> allNetsDistinct (policy2list Filter) \\<Longrightarrow>\n   all_in_list (policy2list Filter) (Nets_List Filter) \\<Longrightarrow>\n   (\\<lambda>(x, y). x) o\\<^sub>f (NAT \\<Otimes>\\<^sub>2 C Filter \\<circ> (\\<lambda>x. (x, x))) =\n   list2policy ((NAT \\<Otimes>\\<^sub>L map C (rev (FWNormalisationCore.normalize Filter))) (\\<Otimes>\\<^sub>2) \n       (\\<lambda>(x, y). x) (\\<lambda>x. (x, x)))\"", "lemma domSimpl[simp]: \"dom (C (A \\<oplus> DenyAll)) = dom (C (DenyAll))\"", "lemma CRotate_eq_rotateC: \"CRotate p = C (rotatePolicy p)\"", "lemma DAinRotate: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> DenyAll \\<in> set (policy2list (rotatePolicy p))\"", "lemma DAUniv: \"dom (CRotate (P \\<oplus> DenyAll)) = UNIV\"", "lemma p_eq2R[rule_format]: \n  \"normalize (rotatePolicy x) \\<noteq> [] \\<longrightarrow> C(list2FWpolicy(normalize (rotatePolicy x))) = CRotate x \\<longrightarrow>\n   list2policy (map C (rev (normalize (rotatePolicy x)))) = CRotate x\"", "lemma C_eq_normalizeRotate: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> allNetsDistinct (policy2list (rotatePolicy p)) \\<Longrightarrow>\n   all_in_list (policy2list (rotatePolicy p)) (Nets_List (rotatePolicy p)) \\<Longrightarrow>\n   C (list2FWpolicy\n        (removeAllDuplicates\n          (insertDenies\n            (separate\n              (sort(removeShadowRules2(remdups(rm_MT_rules C \n                        (insertDeny(removeShadowRules1(policy2list(rotatePolicy p)))))))\n                (Nets_List (rotatePolicy p))))))) =\n   CRotate p\"", "lemma C_eq_normalizeRotate2:\n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow>\n   allNetsDistinct (policy2list (rotatePolicy p)) \\<Longrightarrow>\n   all_in_list (policy2list (rotatePolicy p)) (Nets_List (rotatePolicy p)) \\<Longrightarrow>\n   C (list2FWpolicy (FWNormalisationCore.normalize (rotatePolicy p))) = CRotate p\""], "translations": [["", "lemma ConcAssoc: \"C((A \\<oplus> B) \\<oplus> D) = C(A \\<oplus> (B \\<oplus> D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C ((A \\<oplus> B) \\<oplus> D) = C (A \\<oplus> B \\<oplus> D)", "by (simp add: C.simps)"], ["", "lemma aux26[simp]: \"twoNetsDistinct a b c d \\<Longrightarrow> \n             dom (C (AllowPortFromTo a b p)) \\<inter> dom (C (DenyAllFromTo c d)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. twoNetsDistinct a b c d \\<Longrightarrow>\n    dom (C (AllowPortFromTo a b p)) \\<inter> dom (C (DenyAllFromTo c d)) =\n    {}", "apply (auto simp: PLemmas twoNetsDistinct_def netsDistinct_def)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa aaa ba ab baa bb x xa xb xc.\n       \\<lbrakk>p = dest_port (aa, (aaa, ba), (ab, baa), bb); x \\<in> c;\n        (aaa, ba) \\<in> x; xa \\<in> d; (ab, baa) \\<in> xa; xb \\<in> a;\n        (aaa, ba) \\<in> xb; xc \\<in> b; (ab, baa) \\<in> xc;\n        \\<forall>aa b.\n           (\\<forall>x\\<in>a. (aa, b) \\<notin> x) \\<or>\n           (\\<forall>x\\<in>c. (aa, b) \\<notin> x)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa aaa ba ab baa bb x xa xb xc.\n       \\<lbrakk>p = dest_port (aa, (aaa, ba), (ab, baa), bb); x \\<in> c;\n        (aaa, ba) \\<in> x; xa \\<in> d; (ab, baa) \\<in> xa; xb \\<in> a;\n        (aaa, ba) \\<in> xb; xc \\<in> b; (ab, baa) \\<in> xc;\n        \\<forall>a ba.\n           (\\<forall>x\\<in>b. (a, ba) \\<notin> x) \\<or>\n           (\\<forall>x\\<in>d. (a, ba) \\<notin> x)\\<rbrakk>\n       \\<Longrightarrow> False", "by auto"], ["", "lemma wp2_aux[rule_format]: \"wellformed_policy2 (xs @ [x]) \\<longrightarrow> \n                             wellformed_policy2 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy2 (xs @ [x]) \\<longrightarrow> wellformed_policy2 xs", "apply (induct xs, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       wellformed_policy2 (xs @ [x]) \\<longrightarrow>\n       wellformed_policy2 xs \\<Longrightarrow>\n       wellformed_policy2 (a # xs @ [x]) \\<longrightarrow>\n       wellformed_policy2 (a # xs)", "subgoal for a xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy2 (xs @ [x]) \\<longrightarrow>\n    wellformed_policy2 xs \\<Longrightarrow>\n    wellformed_policy2 (a # xs @ [x]) \\<longrightarrow>\n    wellformed_policy2 (a # xs)", "apply (case_tac \"a\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Cdom2: \"x \\<in> dom(C b) \\<Longrightarrow> C (a \\<oplus> b) x = (C b) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C b) \\<Longrightarrow> C (a \\<oplus> b) x = C b x", "by (auto simp: C.simps)"], ["", "lemma wp2Conc[rule_format]: \"wellformed_policy2 (x#xs) \\<Longrightarrow> wellformed_policy2 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy2 (x # xs) \\<Longrightarrow> wellformed_policy2 xs", "by (case_tac \"x\",simp_all)"], ["", "lemma DAimpliesMR_E[rule_format]: \"DenyAll \\<in> set p \\<longrightarrow>\n                                   (\\<exists> r. applied_rule_rev C x p = Some r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set p \\<longrightarrow>\n    (\\<exists>r. applied_rule_rev C x p = \\<lfloor>r\\<rfloor>)", "apply (simp add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set p \\<longrightarrow>\n    (\\<exists>r. applied_rule C x (rev p) = \\<lfloor>r\\<rfloor>)", "apply (rule_tac xs = p in rev_induct, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       DenyAll \\<in> set xs \\<longrightarrow>\n       (\\<exists>r.\n           applied_rule C x (rev xs) =\n           \\<lfloor>r\\<rfloor>) \\<Longrightarrow>\n       x \\<notin> dom (C DenyAll) \\<longrightarrow>\n       DenyAll = xa \\<longrightarrow>\n       (\\<exists>r. applied_rule C x (rev xs) = \\<lfloor>r\\<rfloor>)", "by (metis C.simps(1) denyAllDom)"], ["", "lemma DAimplieMR[rule_format]: \"DenyAll \\<in> set p \\<Longrightarrow> applied_rule_rev C x p \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set p \\<Longrightarrow>\n    applied_rule_rev C x p \\<noteq> \\<bottom>", "by (auto intro: DAimpliesMR_E)"], ["", "lemma MRList1[rule_format]: \"x \\<in> dom (C a) \\<Longrightarrow> applied_rule_rev C x (b@[a]) = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C a) \\<Longrightarrow>\n    applied_rule_rev C x (b @ [a]) = \\<lfloor>a\\<rfloor>", "by (simp add: applied_rule_rev_def)"], ["", "lemma MRList2: \"x \\<in> dom (C a) \\<Longrightarrow> applied_rule_rev C x (c@b@[a]) = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C a) \\<Longrightarrow>\n    applied_rule_rev C x (c @ b @ [a]) = \\<lfloor>a\\<rfloor>", "by (simp add: applied_rule_rev_def)"], ["", "lemma MRList3: \n  \"x \\<notin> dom (C xa) \\<Longrightarrow> applied_rule_rev C x (a @ b # xs @ [xa]) = applied_rule_rev C x (a @ b # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom (C xa) \\<Longrightarrow>\n    applied_rule_rev C x (a @ b # xs @ [xa]) =\n    applied_rule_rev C x (a @ b # xs)", "by (simp add: applied_rule_rev_def)"], ["", "lemma CConcEnd[rule_format]: \n  \"C a x = Some y \\<longrightarrow>  C (list2FWpolicy (xs @ [a])) x = Some y\"\n (is \"?P xs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. C a x = \\<lfloor>y\\<rfloor> \\<longrightarrow>\n    C (list2FWpolicy (xs @ [a])) x = \\<lfloor>y\\<rfloor>", "apply (rule_tac P = ?P in list2FWpolicy.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. C a x = \\<lfloor>y\\<rfloor> \\<longrightarrow>\n    C (list2FWpolicy ([] @ [a])) x = \\<lfloor>y\\<rfloor>\n 2. \\<And>xa.\n       C a x = \\<lfloor>y\\<rfloor> \\<longrightarrow>\n       C (list2FWpolicy ([xa] @ [a])) x = \\<lfloor>y\\<rfloor>\n 3. \\<And>xa v va.\n       C a x = \\<lfloor>y\\<rfloor> \\<longrightarrow>\n       C (list2FWpolicy ((v # va) @ [a])) x =\n       \\<lfloor>y\\<rfloor> \\<Longrightarrow>\n       C a x = \\<lfloor>y\\<rfloor> \\<longrightarrow>\n       C (list2FWpolicy ((xa # v # va) @ [a])) x = \\<lfloor>y\\<rfloor>", "by (simp_all add:C.simps)"], ["", "lemma CConcStartaux: \" C a x = None \\<Longrightarrow> (C aa ++ C a) x = C aa x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C a x = \\<bottom> \\<Longrightarrow> (C a \\<Oplus> C aa) x = C aa x", "by (simp add: PLemmas)"], ["", "lemma CConcStart[rule_format]: \n  \"xs \\<noteq> [] \\<longrightarrow> C a x = None \\<longrightarrow> C (list2FWpolicy (xs @ [a])) x = C (list2FWpolicy xs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<longrightarrow>\n    C a x = \\<bottom> \\<longrightarrow>\n    C (list2FWpolicy (xs @ [a])) x = C (list2FWpolicy xs) x", "apply (rule list2FWpolicy.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    C a x = \\<bottom> \\<longrightarrow>\n    C (list2FWpolicy ([] @ [a])) x = C (list2FWpolicy []) x\n 2. \\<And>xa.\n       [xa] \\<noteq> [] \\<longrightarrow>\n       C a x = \\<bottom> \\<longrightarrow>\n       C (list2FWpolicy ([xa] @ [a])) x = C (list2FWpolicy [xa]) x\n 3. \\<And>xa v va.\n       v # va \\<noteq> [] \\<longrightarrow>\n       C a x = \\<bottom> \\<longrightarrow>\n       C (list2FWpolicy ((v # va) @ [a])) x =\n       C (list2FWpolicy (v # va)) x \\<Longrightarrow>\n       xa # v # va \\<noteq> [] \\<longrightarrow>\n       C a x = \\<bottom> \\<longrightarrow>\n       C (list2FWpolicy ((xa # v # va) @ [a])) x =\n       C (list2FWpolicy (xa # v # va)) x", "by (simp_all add: PLemmas)"], ["", "lemma mrNnt[simp]: \"applied_rule_rev C x p = Some a \\<Longrightarrow> p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n    p \\<noteq> []", "apply (simp add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule C x (rev p) = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n    p \\<noteq> []", "by auto"], ["", "lemma mr_is_C[rule_format]: \n   \"applied_rule_rev C x p = Some a \\<longrightarrow> C (list2FWpolicy (p)) x = C a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    C (list2FWpolicy p) x = C a x", "apply (simp add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule C x (rev p) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    C (list2FWpolicy p) x = C a x", "apply (rule rev_induct,auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs y.\n       \\<lbrakk>applied_rule C x (rev xs) \\<noteq> \\<lfloor>a\\<rfloor>;\n        C a x = \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (xs @ [a])) x =\n                         \\<lfloor>y\\<rfloor>\n 2. \\<And>xs y.\n       \\<lbrakk>C (list2FWpolicy xs) x = \\<lfloor>y\\<rfloor>;\n        C a x = \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (xs @ [a])) x =\n                         \\<lfloor>y\\<rfloor>\n 3. \\<And>xa xs.\n       \\<lbrakk>C (list2FWpolicy xs) x = C a x; C xa x = \\<bottom>;\n        applied_rule C x (rev xs) = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (xs @ [xa])) x = C a x", "apply (metis CConcEnd)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs y.\n       \\<lbrakk>C (list2FWpolicy xs) x = \\<lfloor>y\\<rfloor>;\n        C a x = \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (xs @ [a])) x =\n                         \\<lfloor>y\\<rfloor>\n 2. \\<And>xa xs.\n       \\<lbrakk>C (list2FWpolicy xs) x = C a x; C xa x = \\<bottom>;\n        applied_rule C x (rev xs) = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (xs @ [xa])) x = C a x", "apply (metis CConcEnd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>C (list2FWpolicy xs) x = C a x; C xa x = \\<bottom>;\n        applied_rule C x (rev xs) = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (xs @ [xa])) x = C a x", "by (metis CConcStart applied_rule_rev_def mrNnt option.exhaust)"], ["", "lemma CConcStart2: \n  \"p \\<noteq> [] \\<Longrightarrow> x \\<notin> dom (C a) \\<Longrightarrow> C (list2FWpolicy (p @ [a])) x = C (list2FWpolicy p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (p @ [a])) x = C (list2FWpolicy p) x", "by (erule CConcStart,simp add: PLemmas)"], ["", "lemma CConcEnd1: \n  \"q @ p \\<noteq> [] \\<Longrightarrow> x \\<notin> dom (C a) \\<Longrightarrow> C (list2FWpolicy (q @ p @ [a])) x = C (list2FWpolicy (q @ p)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q @ p \\<noteq> []; x \\<notin> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (q @ p @ [a])) x =\n                      C (list2FWpolicy (q @ p)) x", "apply (subst lCdom2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q @ p \\<noteq> []; x \\<notin> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy ((q @ p) @ [a])) x =\n                      C (list2FWpolicy (q @ p)) x", "by (rule CConcStart2, simp_all)"], ["", "lemma CConcEnd2[rule_format]: \n  \"x \\<in> dom (C a) \\<longrightarrow> C (list2FWpolicy (xs @ [a])) x = C a x\"  (is \"?P xs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C a) \\<longrightarrow>\n    C (list2FWpolicy (xs @ [a])) x = C a x", "apply (rule_tac P = ?P in list2FWpolicy.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> dom (C a) \\<longrightarrow>\n    C (list2FWpolicy ([] @ [a])) x = C a x\n 2. \\<And>xa.\n       x \\<in> dom (C a) \\<longrightarrow>\n       C (list2FWpolicy ([xa] @ [a])) x = C a x\n 3. \\<And>xa v va.\n       x \\<in> dom (C a) \\<longrightarrow>\n       C (list2FWpolicy ((v # va) @ [a])) x = C a x \\<Longrightarrow>\n       x \\<in> dom (C a) \\<longrightarrow>\n       C (list2FWpolicy ((xa # v # va) @ [a])) x = C a x", "by (auto simp:C.simps)"], ["", "lemma bar3: \n   \"x \\<in> dom (C (list2FWpolicy (xs @ [xa]))) \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy xs)) \\<or> x \\<in> dom (C xa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C (list2FWpolicy (xs @ [xa]))) \\<Longrightarrow>\n    x \\<in> dom (C (list2FWpolicy xs)) \\<or> x \\<in> dom (C xa)", "by auto (metis CConcStart eq_Nil_appendI l2p_aux2 option.simps(3))"], ["", "lemma CeqEnd[rule_format,simp]: \n  \"a \\<noteq> [] \\<longrightarrow> x \\<in> dom (C (list2FWpolicy a)) \\<longrightarrow> C (list2FWpolicy(b@a)) x = (C (list2FWpolicy a)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy a)) \\<longrightarrow>\n    C (list2FWpolicy (b @ a)) x = C (list2FWpolicy a) x", "apply (rule rev_induct,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy xs)) \\<longrightarrow>\n       C (list2FWpolicy (b @ xs)) x =\n       C (list2FWpolicy xs) x \\<Longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (xs @ [xa]))) \\<longrightarrow>\n       C (list2FWpolicy (b @ xs @ [xa])) x = C (list2FWpolicy (xs @ [xa])) x", "subgoal for xa xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy xs)) \\<longrightarrow>\n    C (list2FWpolicy (b @ xs)) x = C (list2FWpolicy xs) x \\<Longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (xs @ [xa]))) \\<longrightarrow>\n    C (list2FWpolicy (b @ xs @ [xa])) x = C (list2FWpolicy (xs @ [xa])) x", "apply (case_tac \"xs \\<noteq> []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> dom (C (list2FWpolicy xs)) \\<longrightarrow>\n             C (list2FWpolicy (b @ xs)) x = C (list2FWpolicy xs) x;\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (xs @ [xa]))) \\<longrightarrow>\n                      C (list2FWpolicy (b @ xs @ [xa])) x =\n                      C (list2FWpolicy (xs @ [xa])) x\n 2. xs = [] \\<Longrightarrow>\n    x \\<in> dom (C xa) \\<longrightarrow>\n    C (list2FWpolicy (b @ [xa])) x = C xa x", "apply (case_tac \"x \\<in> dom (C xa)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> dom (C (list2FWpolicy xs)) \\<longrightarrow>\n             C (list2FWpolicy (b @ xs)) x = C (list2FWpolicy xs) x;\n     xs \\<noteq> []; x \\<in> dom (C xa)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (xs @ [xa]))) \\<longrightarrow>\n                      C (list2FWpolicy (b @ xs @ [xa])) x =\n                      C (list2FWpolicy (xs @ [xa])) x\n 2. \\<lbrakk>x \\<in> dom (C (list2FWpolicy xs)) \\<longrightarrow>\n             C (list2FWpolicy (b @ xs)) x = C (list2FWpolicy xs) x;\n     xs \\<noteq> []; x \\<notin> dom (C xa)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (xs @ [xa]))) \\<longrightarrow>\n                      C (list2FWpolicy (b @ xs @ [xa])) x =\n                      C (list2FWpolicy (xs @ [xa])) x\n 3. xs = [] \\<Longrightarrow>\n    x \\<in> dom (C xa) \\<longrightarrow>\n    C (list2FWpolicy (b @ [xa])) x = C xa x", "apply (metis CConcEnd2 MRList2 mr_is_C )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> dom (C (list2FWpolicy xs)) \\<longrightarrow>\n             C (list2FWpolicy (b @ xs)) x = C (list2FWpolicy xs) x;\n     xs \\<noteq> []; x \\<notin> dom (C xa)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (xs @ [xa]))) \\<longrightarrow>\n                      C (list2FWpolicy (b @ xs @ [xa])) x =\n                      C (list2FWpolicy (xs @ [xa])) x\n 2. xs = [] \\<Longrightarrow>\n    x \\<in> dom (C xa) \\<longrightarrow>\n    C (list2FWpolicy (b @ [xa])) x = C xa x", "apply (metis CConcEnd1 CConcStart2 Nil_is_append_conv bar3 )"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow>\n    x \\<in> dom (C xa) \\<longrightarrow>\n    C (list2FWpolicy (b @ [xa])) x = C xa x", "apply (metis MRList2 eq_Nil_appendI mr_is_C )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma CConcStartA[rule_format,simp]: \n  \"x \\<in> dom (C a) \\<longrightarrow> x \\<in> dom (C (list2FWpolicy (a # b)))\" (is \"?P b\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C a) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (a # b)))", "apply (rule_tac P = ?P in list2FWpolicy.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> dom (C a) \\<longrightarrow> x \\<in> dom (C (list2FWpolicy [a]))\n 2. \\<And>xa.\n       x \\<in> dom (C a) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy [a, xa]))\n 3. \\<And>xa v va.\n       x \\<in> dom (C a) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (a # v # va))) \\<Longrightarrow>\n       x \\<in> dom (C a) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (a # xa # v # va)))", "apply (simp_all add: C.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma domConc: \n  \"x \\<in> dom (C (list2FWpolicy b)) \\<Longrightarrow> b \\<noteq> [] \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy (a @ b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (C (list2FWpolicy b)); b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy (a @ b)))", "by (auto simp: PLemmas)"], ["", "lemma CeqStart[rule_format,simp]:\n  \"x\\<notin>dom(C(list2FWpolicy a)) \\<longrightarrow> a\\<noteq>[] \\<longrightarrow> b\\<noteq>[] \\<longrightarrow> C(list2FWpolicy(b@a)) x = (C(list2FWpolicy b)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom (C (list2FWpolicy a)) \\<longrightarrow>\n    a \\<noteq> [] \\<longrightarrow>\n    b \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (b @ a)) x = C (list2FWpolicy b) x", "apply (rule list2FWpolicy.induct,simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       x \\<notin> dom (C (list2FWpolicy a)) \\<longrightarrow>\n       a \\<noteq> [] \\<longrightarrow> C (list2FWpolicy (xa # a)) x = C xa x\n 2. \\<And>xa v va.\n       x \\<notin> dom (C (list2FWpolicy a)) \\<longrightarrow>\n       a \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (v # va @ a)) x =\n       C (list2FWpolicy (v # va)) x \\<Longrightarrow>\n       x \\<notin> dom (C (list2FWpolicy a)) \\<longrightarrow>\n       a \\<noteq> [] \\<longrightarrow>\n       C (xa \\<oplus> list2FWpolicy (v # va @ a)) x =\n       C (xa \\<oplus> list2FWpolicy (v # va)) x", "apply (auto simp: list2FWpolicyconc PLemmas)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_eq_if_mr_eq2: \n  \"applied_rule_rev C x a = \\<lfloor>r\\<rfloor> \\<Longrightarrow>\n   applied_rule_rev C x b = \\<lfloor>r\\<rfloor> \\<Longrightarrow> a \\<noteq> [] \\<Longrightarrow> b \\<noteq> [] \\<Longrightarrow> \n   C (list2FWpolicy a) x = C (list2FWpolicy b) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev C x a = \\<lfloor>r\\<rfloor>;\n     applied_rule_rev C x b = \\<lfloor>r\\<rfloor>; a \\<noteq> [];\n     b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy a) x = C (list2FWpolicy b) x", "by (metis mr_is_C)"], ["", "lemma nMRtoNone[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> applied_rule_rev C x p = None \\<longrightarrow> C (list2FWpolicy p) x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    applied_rule_rev C x p = \\<bottom> \\<longrightarrow>\n    C (list2FWpolicy p) x = \\<bottom>", "apply (rule rev_induct, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       applied_rule_rev C x xs = \\<bottom> \\<longrightarrow>\n       C (list2FWpolicy xs) x = \\<bottom> \\<Longrightarrow>\n       applied_rule_rev C x (xs @ [xa]) = \\<bottom> \\<longrightarrow>\n       C (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "subgoal for xa xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<longrightarrow>\n    applied_rule_rev C x xs = \\<bottom> \\<longrightarrow>\n    C (list2FWpolicy xs) x = \\<bottom> \\<Longrightarrow>\n    applied_rule_rev C x (xs @ [xa]) = \\<bottom> \\<longrightarrow>\n    C (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "apply (case_tac \"xs = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    applied_rule_rev C x [xa] = \\<bottom> \\<longrightarrow>\n    C xa x = \\<bottom>\n 2. \\<lbrakk>applied_rule_rev C x xs = \\<bottom> \\<longrightarrow>\n             C (list2FWpolicy xs) x = \\<bottom>;\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (xs @ [xa]) =\n                      \\<bottom> \\<longrightarrow>\n                      C (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "by (simp_all add: applied_rule_rev_def dom_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_eq_if_mr_eq: \n \"applied_rule_rev C x b = applied_rule_rev C x a \\<Longrightarrow> a \\<noteq> [] \\<Longrightarrow> b \\<noteq> [] \\<Longrightarrow> \n  C (list2FWpolicy a) x = C (list2FWpolicy b) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev C x b = applied_rule_rev C x a; a \\<noteq> [];\n     b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy a) x = C (list2FWpolicy b) x", "apply (cases \"applied_rule_rev C x a = None\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x b = \\<bottom>; a \\<noteq> [];\n     b \\<noteq> []; applied_rule_rev C x a = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy a) x = C (list2FWpolicy b) x\n 2. \\<lbrakk>applied_rule_rev C x b = applied_rule_rev C x a; a \\<noteq> [];\n     b \\<noteq> [];\n     \\<exists>y. applied_rule_rev C x a = \\<lfloor>y\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy a) x = C (list2FWpolicy b) x", "apply (subst nMRtoNone,simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x b = \\<bottom>; a \\<noteq> [];\n     b \\<noteq> []; applied_rule_rev C x a = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> \\<bottom> = C (list2FWpolicy b) x\n 2. \\<lbrakk>applied_rule_rev C x b = applied_rule_rev C x a; a \\<noteq> [];\n     b \\<noteq> [];\n     \\<exists>y. applied_rule_rev C x a = \\<lfloor>y\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy a) x = C (list2FWpolicy b) x", "apply (subst nMRtoNone, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev C x b = applied_rule_rev C x a; a \\<noteq> [];\n     b \\<noteq> [];\n     \\<exists>y. applied_rule_rev C x a = \\<lfloor>y\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy a) x = C (list2FWpolicy b) x", "by (auto intro: C_eq_if_mr_eq2)"], ["", "lemma notmatching_notdom: \"applied_rule_rev C x (p@[a]) \\<noteq> Some a \\<Longrightarrow> x \\<notin> dom (C a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x (p @ [a]) \\<noteq>\n    \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n    x \\<notin> dom (C a)", "by (simp add: applied_rule_rev_def split: if_splits)"], ["", "lemma foo3a[rule_format]: \n  \"applied_rule_rev C x (a@[b]@c) = Some b \\<longrightarrow>  r \\<in> set c \\<longrightarrow> b \\<notin> set c \\<longrightarrow> x \\<notin> dom (C r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x (a @ [b] @ c) =\n    \\<lfloor>b\\<rfloor> \\<longrightarrow>\n    r \\<in> set c \\<longrightarrow>\n    b \\<notin> set c \\<longrightarrow> x \\<notin> dom (C r)", "apply (rule rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. applied_rule_rev C x (a @ [b] @ []) =\n    \\<lfloor>b\\<rfloor> \\<longrightarrow>\n    r \\<in> set [] \\<longrightarrow>\n    b \\<notin> set [] \\<longrightarrow> x \\<notin> dom (C r)\n 2. \\<And>xa xs.\n       applied_rule_rev C x (a @ [b] @ xs) =\n       \\<lfloor>b\\<rfloor> \\<longrightarrow>\n       r \\<in> set xs \\<longrightarrow>\n       b \\<notin> set xs \\<longrightarrow>\n       x \\<notin> dom (C r) \\<Longrightarrow>\n       applied_rule_rev C x (a @ [b] @ xs @ [xa]) =\n       \\<lfloor>b\\<rfloor> \\<longrightarrow>\n       r \\<in> set (xs @ [xa]) \\<longrightarrow>\n       b \\<notin> set (xs @ [xa]) \\<longrightarrow> x \\<notin> dom (C r)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       applied_rule_rev C x (a @ b # xs) =\n       \\<lfloor>b\\<rfloor> \\<longrightarrow>\n       r \\<in> set xs \\<longrightarrow>\n       b \\<notin> set xs \\<longrightarrow>\n       x \\<notin> dom (C r) \\<Longrightarrow>\n       applied_rule_rev C x (a @ b # xs @ [xa]) =\n       \\<lfloor>b\\<rfloor> \\<longrightarrow>\n       (r = xa \\<longrightarrow>\n        b \\<noteq> xa \\<and> b \\<notin> set xs \\<longrightarrow>\n        x \\<notin> dom (C xa)) \\<and>\n       (r \\<in> set xs \\<longrightarrow>\n        b \\<noteq> xa \\<and> b \\<notin> set xs \\<longrightarrow>\n        x \\<notin> dom (C r))", "apply (intro impI conjI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xs.\n       \\<lbrakk>applied_rule_rev C x (a @ b # xs) =\n                \\<lfloor>b\\<rfloor> \\<longrightarrow>\n                xa \\<in> set xs \\<longrightarrow> x \\<notin> dom (C xa);\n        applied_rule_rev C x (a @ b # xs @ [xa]) = \\<lfloor>b\\<rfloor>;\n        r = xa; b \\<noteq> xa \\<and> b \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> dom (C xa)\n 2. \\<And>xa xs.\n       \\<lbrakk>applied_rule_rev C x (a @ b # xs) =\n                \\<lfloor>b\\<rfloor> \\<longrightarrow>\n                r \\<in> set xs \\<longrightarrow>\n                b \\<notin> set xs \\<longrightarrow> x \\<notin> dom (C r);\n        applied_rule_rev C x (a @ b # xs @ [xa]) = \\<lfloor>b\\<rfloor>;\n        r \\<in> set xs; b \\<noteq> xa \\<and> b \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> dom (C r)", "subgoal for xa xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev C x (a @ b # xs) =\n             \\<lfloor>b\\<rfloor> \\<longrightarrow>\n             xa \\<in> set xs \\<longrightarrow> x \\<notin> dom (C xa);\n     applied_rule_rev C x (a @ b # xs @ [xa]) = \\<lfloor>b\\<rfloor>; r = xa;\n     b \\<noteq> xa \\<and> b \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C xa)", "apply (rule_tac p = \"a @ b # xs\" in notmatching_notdom,simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>applied_rule_rev C x (a @ b # xs) =\n                \\<lfloor>b\\<rfloor> \\<longrightarrow>\n                r \\<in> set xs \\<longrightarrow>\n                b \\<notin> set xs \\<longrightarrow> x \\<notin> dom (C r);\n        applied_rule_rev C x (a @ b # xs @ [xa]) = \\<lfloor>b\\<rfloor>;\n        r \\<in> set xs; b \\<noteq> xa \\<and> b \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> dom (C r)", "by (metis MRList2 MRList3 append_Cons option.inject)"], ["", "lemma foo3D: \n  \"wellformed_policy1 p \\<Longrightarrow> p = DenyAll # ps \\<Longrightarrow> \n   applied_rule_rev C x p = \\<lfloor>DenyAll\\<rfloor> \\<Longrightarrow> r \\<in> set ps \\<Longrightarrow> x \\<notin> dom (C r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1 p; p = DenyAll # ps;\n     applied_rule_rev C x p = \\<lfloor>DenyAll\\<rfloor>;\n     r \\<in> set ps\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C r)", "by (rule_tac a = \"[]\" and b = \"DenyAll\" and c = \"ps\"  in foo3a, simp_all)"], ["", "lemma foo4[rule_format]: \n  \"set p = set s \\<and> (\\<forall> r. r \\<in> set p \\<longrightarrow> x \\<notin> dom (C r)) \\<longrightarrow>  (\\<forall> r .r \\<in> set s \\<longrightarrow> x \\<notin> dom (C r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set p = set s \\<and>\n    (\\<forall>r.\n        r \\<in> set p \\<longrightarrow>\n        x \\<notin> dom (C r)) \\<longrightarrow>\n    (\\<forall>r. r \\<in> set s \\<longrightarrow> x \\<notin> dom (C r))", "by simp"], ["", "lemma foo5b[rule_format]: \n  \"x \\<in> dom (C b) \\<longrightarrow> (\\<forall> r. r \\<in> set c \\<longrightarrow> x \\<notin> dom (C r)) \\<longrightarrow> applied_rule_rev C x (b#c) = Some b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C b) \\<longrightarrow>\n    (\\<forall>r.\n        r \\<in> set c \\<longrightarrow>\n        x \\<notin> dom (C r)) \\<longrightarrow>\n    applied_rule_rev C x (b # c) = \\<lfloor>b\\<rfloor>", "apply (simp add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C b) \\<longrightarrow>\n    (\\<forall>r.\n        r \\<in> set c \\<longrightarrow>\n        x \\<notin> dom (C r)) \\<longrightarrow>\n    applied_rule C x (rev c @ [b]) = \\<lfloor>b\\<rfloor>", "apply (rule_tac xs = c in rev_induct, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mr_first: \n  \"x \\<in> dom (C b) \\<Longrightarrow> \\<forall>r. r \\<in> set c \\<longrightarrow> x \\<notin> dom (C r) \\<Longrightarrow> s = b # c \\<Longrightarrow> applied_rule_rev C x s = \\<lfloor>b\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (C b);\n     \\<forall>r. r \\<in> set c \\<longrightarrow> x \\<notin> dom (C r);\n     s = b # c\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x s = \\<lfloor>b\\<rfloor>", "by (simp add: foo5b)"], ["", "lemma mr_charn[rule_format]: \n  \"a \\<in> set p \\<longrightarrow> (x \\<in> dom (C a)) \\<longrightarrow>   (\\<forall> r. r \\<in> set p \\<and> x \\<in> dom (C r) \\<longrightarrow> r = a) \\<longrightarrow>  \n   applied_rule_rev C x p = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set p \\<longrightarrow>\n    x \\<in> dom (C a) \\<longrightarrow>\n    (\\<forall>r.\n        r \\<in> set p \\<and> x \\<in> dom (C r) \\<longrightarrow>\n        r = a) \\<longrightarrow>\n    applied_rule_rev C x p = \\<lfloor>a\\<rfloor>", "unfolding applied_rule_rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set p \\<longrightarrow>\n    x \\<in> dom (C a) \\<longrightarrow>\n    (\\<forall>r.\n        r \\<in> set p \\<and> x \\<in> dom (C r) \\<longrightarrow>\n        r = a) \\<longrightarrow>\n    applied_rule C x (rev p) = \\<lfloor>a\\<rfloor>", "apply (rule_tac xs = p in rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<in> set [] \\<longrightarrow>\n    x \\<in> dom (C a) \\<longrightarrow>\n    (\\<forall>r.\n        r \\<in> set [] \\<and> x \\<in> dom (C r) \\<longrightarrow>\n        r = a) \\<longrightarrow>\n    applied_rule C x (rev []) = \\<lfloor>a\\<rfloor>\n 2. \\<And>xa xs.\n       a \\<in> set xs \\<longrightarrow>\n       x \\<in> dom (C a) \\<longrightarrow>\n       (\\<forall>r.\n           r \\<in> set xs \\<and> x \\<in> dom (C r) \\<longrightarrow>\n           r = a) \\<longrightarrow>\n       applied_rule C x (rev xs) = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       a \\<in> set (xs @ [xa]) \\<longrightarrow>\n       x \\<in> dom (C a) \\<longrightarrow>\n       (\\<forall>r.\n           r \\<in> set (xs @ [xa]) \\<and>\n           x \\<in> dom (C r) \\<longrightarrow>\n           r = a) \\<longrightarrow>\n       applied_rule C x (rev (xs @ [xa])) = \\<lfloor>a\\<rfloor>", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       a \\<in> set xs \\<longrightarrow>\n       x \\<in> dom (C a) \\<longrightarrow>\n       (\\<forall>r.\n           r \\<in> set xs \\<and> x \\<in> dom (C r) \\<longrightarrow>\n           r = a) \\<longrightarrow>\n       applied_rule C x (rev xs) = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       a \\<in> set (xs @ [xa]) \\<longrightarrow>\n       x \\<in> dom (C a) \\<longrightarrow>\n       (\\<forall>r.\n           r \\<in> set (xs @ [xa]) \\<and>\n           x \\<in> dom (C r) \\<longrightarrow>\n           r = a) \\<longrightarrow>\n       applied_rule C x (rev (xs @ [xa])) = \\<lfloor>a\\<rfloor>", "by(safe,auto)"], ["", "lemma foo8: \n  \"\\<forall>r. r \\<in> set p \\<and> x \\<in> dom (C r) \\<longrightarrow> r = a \\<Longrightarrow> set p = set s \\<Longrightarrow> \n   \\<forall>r. r \\<in> set s \\<and> x \\<in> dom (C r) \\<longrightarrow> r = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>r.\n                r \\<in> set p \\<and> x \\<in> dom (C r) \\<longrightarrow>\n                r = a;\n     set p = set s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>r.\n                         r \\<in> set s \\<and>\n                         x \\<in> dom (C r) \\<longrightarrow>\n                         r = a", "by auto"], ["", "lemma mrConcEnd[rule_format]: \n  \"applied_rule_rev C x (b # p) = Some a \\<longrightarrow> a \\<noteq> b \\<longrightarrow>  applied_rule_rev C x p = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x (b # p) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    a \\<noteq> b \\<longrightarrow>\n    applied_rule_rev C x p = \\<lfloor>a\\<rfloor>", "apply (simp add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule C x (rev p @ [b]) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    a \\<noteq> b \\<longrightarrow>\n    applied_rule C x (rev p) = \\<lfloor>a\\<rfloor>", "by (rule_tac xs = p in rev_induct,auto)"], ["", "lemma wp3tl[rule_format]: \"wellformed_policy3 p \\<longrightarrow> wellformed_policy3 (tl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy3 p \\<longrightarrow> wellformed_policy3 (tl p)", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       wellformed_policy3 p \\<longrightarrow>\n       wellformed_policy3 (tl p) \\<Longrightarrow>\n       wellformed_policy3 (a # p) \\<longrightarrow> wellformed_policy3 p", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy3 p \\<longrightarrow>\n    wellformed_policy3 (tl p) \\<Longrightarrow>\n    wellformed_policy3 (a # p) \\<longrightarrow> wellformed_policy3 p", "apply(case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wp3Conc[rule_format]: \"wellformed_policy3 (a#p) \\<longrightarrow> wellformed_policy3 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy3 (a # p) \\<longrightarrow> wellformed_policy3 p", "by (induct p, simp_all, case_tac a, simp_all)"], ["", "lemma foo98[rule_format]:\n  \"applied_rule_rev C x (aa # p) = Some a \\<longrightarrow> x \\<in> dom (C r) \\<longrightarrow>  r \\<in> set p \\<longrightarrow> a \\<in> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x (aa # p) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    x \\<in> dom (C r) \\<longrightarrow>\n    r \\<in> set p \\<longrightarrow> a \\<in> set p", "unfolding applied_rule_rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule C x (rev (aa # p)) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    x \\<in> dom (C r) \\<longrightarrow>\n    r \\<in> set p \\<longrightarrow> a \\<in> set p", "apply (rule rev_induct, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       applied_rule C x (rev xs @ [aa]) =\n       \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       x \\<in> dom (C r) \\<longrightarrow>\n       r \\<in> set xs \\<longrightarrow> a \\<in> set xs \\<Longrightarrow>\n       x \\<notin> dom (C xa) \\<longrightarrow>\n       applied_rule C x (rev xs @ [aa]) =\n       \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       x \\<in> dom (C r) \\<longrightarrow>\n       r = xa \\<longrightarrow> a = xa \\<or> a \\<in> set xs", "subgoal for xa xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule C x (rev xs @ [aa]) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    x \\<in> dom (C r) \\<longrightarrow>\n    r \\<in> set xs \\<longrightarrow> a \\<in> set xs \\<Longrightarrow>\n    x \\<notin> dom (C xa) \\<longrightarrow>\n    applied_rule C x (rev xs @ [aa]) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    x \\<in> dom (C r) \\<longrightarrow>\n    r = xa \\<longrightarrow> a = xa \\<or> a \\<in> set xs", "apply (case_tac \"r = xa\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mrMTNone[simp]: \"applied_rule_rev C x [] = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x [] = \\<bottom>", "by (simp add: applied_rule_rev_def)"], ["", "lemma DAAux[simp]: \"x \\<in> dom (C DenyAll)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C DenyAll)", "by (simp add: dom_def PolicyCombinators.PolicyCombinators C.simps)"], ["", "lemma mrSet[rule_format]: \"applied_rule_rev C x p = Some r \\<longrightarrow> r \\<in> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = \\<lfloor>r\\<rfloor> \\<longrightarrow>\n    r \\<in> set p", "unfolding applied_rule_rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule C x (rev p) = \\<lfloor>r\\<rfloor> \\<longrightarrow>\n    r \\<in> set p", "by (rule_tac xs=p in rev_induct, simp_all)"], ["", "lemma mr_not_Conc: \"singleCombinators p \\<Longrightarrow> applied_rule_rev C x p \\<noteq> Some (a\\<oplus>b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<Longrightarrow>\n    applied_rule_rev C x p \\<noteq> \\<lfloor>a \\<oplus> b\\<rfloor>", "apply (auto simp:  mrSet)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p;\n     applied_rule_rev C x p = \\<lfloor>a \\<oplus> b\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule mrSet)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; a \\<oplus> b \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule SCnotConc,simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foo25[rule_format]: \"wellformed_policy3 (p@[x]) \\<longrightarrow> wellformed_policy3 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy3 (p @ [x]) \\<longrightarrow> wellformed_policy3 p", "by (induct p, simp_all, case_tac a, simp_all)"], ["", "lemma mr_in_dom[rule_format]: \"applied_rule_rev C x p = Some a \\<longrightarrow> x \\<in> dom (C a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    x \\<in> dom (C a)", "apply (rule_tac xs = p in rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. applied_rule_rev C x [] = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    x \\<in> dom (C a)\n 2. \\<And>xa xs.\n       applied_rule_rev C x xs = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       x \\<in> dom (C a) \\<Longrightarrow>\n       applied_rule_rev C x (xs @ [xa]) =\n       \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       x \\<in> dom (C a)", "by (auto simp: applied_rule_rev_def)"], ["", "lemma wp3EndMT[rule_format]: \n  \"wellformed_policy3 (p@[xs]) \\<longrightarrow>  AllowPortFromTo a b po \\<in> set p \\<longrightarrow>\n   dom (C (AllowPortFromTo a b po)) \\<inter> dom (C xs) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy3 (p @ [xs]) \\<longrightarrow>\n    AllowPortFromTo a b po \\<in> set p \\<longrightarrow>\n    dom (C (AllowPortFromTo a b po)) \\<inter> dom (C xs) = {}", "apply (induct p,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       wellformed_policy3 (p @ [xs]) \\<longrightarrow>\n       AllowPortFromTo a b po \\<in> set p \\<longrightarrow>\n       dom (C (AllowPortFromTo a b po)) \\<inter> dom (C xs) =\n       {} \\<Longrightarrow>\n       wellformed_policy3 (aa # p @ [xs]) \\<longrightarrow>\n       (AllowPortFromTo a b po = aa \\<longrightarrow>\n        dom (C aa) \\<inter> dom (C xs) = {}) \\<and>\n       (AllowPortFromTo a b po \\<in> set p \\<longrightarrow>\n        dom (C (AllowPortFromTo a b po)) \\<inter> dom (C xs) = {})", "apply (intro impI,drule mp,erule wp3Conc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       \\<lbrakk>wellformed_policy3 (aa # p @ [xs]);\n        AllowPortFromTo a b po \\<in> set p \\<longrightarrow>\n        dom (C (AllowPortFromTo a b po)) \\<inter> dom (C xs) = {}\\<rbrakk>\n       \\<Longrightarrow> (AllowPortFromTo a b po = aa \\<longrightarrow>\n                          dom (C aa) \\<inter> dom (C xs) = {}) \\<and>\n                         (AllowPortFromTo a b po\n                          \\<in> set p \\<longrightarrow>\n                          dom (C (AllowPortFromTo a b po)) \\<inter>\n                          dom (C xs) =\n                          {})", "by clarify auto"], ["", "lemma foo29: \"\\<lbrakk>dom (C a) \\<noteq> {}; dom (C a) \\<inter> dom (C b) = {}\\<rbrakk> \\<Longrightarrow> a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom (C a) \\<noteq> {};\n     dom (C a) \\<inter> dom (C b) = {}\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b", "by auto"], ["", "lemma foo28:  \n  \"AllowPortFromTo a b po \\<in> set p \\<Longrightarrow> dom (C (AllowPortFromTo a b po)) \\<noteq> {} \\<Longrightarrow> \n   wellformed_policy3 (p @ [x])   \\<Longrightarrow> x \\<noteq> AllowPortFromTo a b po\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo a b po \\<in> set p;\n     dom (C (AllowPortFromTo a b po)) \\<noteq> {};\n     wellformed_policy3 (p @ [x])\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> AllowPortFromTo a b po", "by (metis foo29 C.simps(3) wp3EndMT)"], ["", "lemma foo28a[rule_format]: \"x \\<in> dom (C a) \\<Longrightarrow> dom (C a) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C a) \\<Longrightarrow> dom (C a) \\<noteq> {}", "by auto"], ["", "lemma allow_deny_dom[simp]: \n  \"dom (C (AllowPortFromTo a b po)) \\<subseteq> dom (C (DenyAllFromTo a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (C (AllowPortFromTo a b po)) \\<subseteq> dom (C (DenyAllFromTo a b))", "by (simp_all add: twoNetsDistinct_def netsDistinct_def PLemmas) auto"], ["", "lemma DenyAllowDisj: \n  \"dom (C (AllowPortFromTo a b p)) \\<noteq> {} \\<Longrightarrow> \n   dom (C (DenyAllFromTo a b)) \\<inter> dom (C (AllowPortFromTo a b p))  \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (C (AllowPortFromTo a b p)) \\<noteq> {} \\<Longrightarrow>\n    dom (C (DenyAllFromTo a b)) \\<inter>\n    dom (C (AllowPortFromTo a b p)) \\<noteq>\n    {}", "by (metis Int_absorb1 allow_deny_dom)"], ["", "lemma foo31: \n  \"\\<forall>r. r \\<in> set p \\<and> x \\<in> dom (C r) \\<longrightarrow> \n       r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll \\<Longrightarrow>\n   set p = set s \\<Longrightarrow> \n   \\<forall>r. r \\<in> set s \\<and> x \\<in> dom (C r) \\<longrightarrow> r=AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>r.\n                r \\<in> set p \\<and> x \\<in> dom (C r) \\<longrightarrow>\n                r = AllowPortFromTo a b po \\<or>\n                r = DenyAllFromTo a b \\<or> r = DenyAll;\n     set p = set s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>r.\n                         r \\<in> set s \\<and>\n                         x \\<in> dom (C r) \\<longrightarrow>\n                         r = AllowPortFromTo a b po \\<or>\n                         r = DenyAllFromTo a b \\<or> r = DenyAll", "by auto"], ["", "lemma wp1_auxa: \n  \"wellformed_policy1_strong p\\<Longrightarrow>(\\<exists> r. applied_rule_rev C x p = Some r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<Longrightarrow>\n    \\<exists>r. applied_rule_rev C x p = \\<lfloor>r\\<rfloor>", "apply (rule DAimpliesMR_E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<Longrightarrow> DenyAll \\<in> set p", "by (erule wp1_aux1aa)"], ["", "lemma deny_dom[simp]:  \n  \"twoNetsDistinct a b c d \\<Longrightarrow> dom (C (DenyAllFromTo a b)) \\<inter> dom (C (DenyAllFromTo c d)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. twoNetsDistinct a b c d \\<Longrightarrow>\n    dom (C (DenyAllFromTo a b)) \\<inter> dom (C (DenyAllFromTo c d)) = {}", "apply (simp add: C.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. twoNetsDistinct a b c d \\<Longrightarrow>\n    dom (deny_all_from_to a b) \\<inter> dom (deny_all_from_to c d) = {}", "by (erule aux6)"], ["", "lemma domTrans: \"dom a \\<subseteq> dom b \\<Longrightarrow> dom b \\<inter> dom c = {} \\<Longrightarrow> dom a \\<inter> dom c = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom a \\<subseteq> dom b; dom b \\<inter> dom c = {}\\<rbrakk>\n    \\<Longrightarrow> dom a \\<inter> dom c = {}", "by auto"], ["", "lemma DomInterAllowsMT:\n  \"twoNetsDistinct a b c d  \\<Longrightarrow> \ndom (C (AllowPortFromTo a b p)) \\<inter> dom (C (AllowPortFromTo c d po)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. twoNetsDistinct a b c d \\<Longrightarrow>\n    dom (C (AllowPortFromTo a b p)) \\<inter>\n    dom (C (AllowPortFromTo c d po)) =\n    {}", "apply (case_tac \"p = po\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>twoNetsDistinct a b c d; p = po\\<rbrakk>\n    \\<Longrightarrow> dom (C (AllowPortFromTo a b po)) \\<inter>\n                      dom (C (AllowPortFromTo c d po)) =\n                      {}\n 2. \\<lbrakk>twoNetsDistinct a b c d; p \\<noteq> po\\<rbrakk>\n    \\<Longrightarrow> dom (C (AllowPortFromTo a b p)) \\<inter>\n                      dom (C (AllowPortFromTo c d po)) =\n                      {}", "apply (rule_tac b = \"C (DenyAllFromTo a b)\" in domTrans, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>twoNetsDistinct a b c d; p = po\\<rbrakk>\n    \\<Longrightarrow> dom (C (DenyAllFromTo a b)) \\<inter>\n                      dom (C (AllowPortFromTo c d po)) =\n                      {}\n 2. \\<lbrakk>twoNetsDistinct a b c d; p \\<noteq> po\\<rbrakk>\n    \\<Longrightarrow> dom (C (AllowPortFromTo a b p)) \\<inter>\n                      dom (C (AllowPortFromTo c d po)) =\n                      {}", "apply (metis domComm aux26 tNDComm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>twoNetsDistinct a b c d; p \\<noteq> po\\<rbrakk>\n    \\<Longrightarrow> dom (C (AllowPortFromTo a b p)) \\<inter>\n                      dom (C (AllowPortFromTo c d po)) =\n                      {}", "by (simp add: twoNetsDistinct_def netsDistinct_def PLemmas) auto"], ["", "lemma DomInterAllowsMT_Ports: \n  \"p \\<noteq> po \\<Longrightarrow> dom (C (AllowPortFromTo a b p)) \\<inter> dom (C (AllowPortFromTo c d po)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> po \\<Longrightarrow>\n    dom (C (AllowPortFromTo a b p)) \\<inter>\n    dom (C (AllowPortFromTo c d po)) =\n    {}", "by (simp add: twoNetsDistinct_def netsDistinct_def PLemmas) auto"], ["", "lemma wellformed_policy3_charn[rule_format]: \n  \"singleCombinators p \\<longrightarrow> distinct p \\<longrightarrow> allNetsDistinct p \\<longrightarrow> \n   wellformed_policy1 p \\<longrightarrow> wellformed_policy2 p  \\<longrightarrow> wellformed_policy3 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<longrightarrow>\n    distinct p \\<longrightarrow>\n    allNetsDistinct p \\<longrightarrow>\n    wellformed_policy1 p \\<longrightarrow>\n    wellformed_policy2 p \\<longrightarrow> wellformed_policy3 p", "apply (induct_tac p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. singleCombinators [] \\<longrightarrow>\n    distinct [] \\<longrightarrow>\n    allNetsDistinct [] \\<longrightarrow>\n    wellformed_policy1 [] \\<longrightarrow>\n    wellformed_policy2 [] \\<longrightarrow> wellformed_policy3 []\n 2. \\<And>a list.\n       singleCombinators list \\<longrightarrow>\n       distinct list \\<longrightarrow>\n       allNetsDistinct list \\<longrightarrow>\n       wellformed_policy1 list \\<longrightarrow>\n       wellformed_policy2 list \\<longrightarrow>\n       wellformed_policy3 list \\<Longrightarrow>\n       singleCombinators (a # list) \\<longrightarrow>\n       distinct (a # list) \\<longrightarrow>\n       allNetsDistinct (a # list) \\<longrightarrow>\n       wellformed_policy1 (a # list) \\<longrightarrow>\n       wellformed_policy2 (a # list) \\<longrightarrow>\n       wellformed_policy3 (a # list)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       singleCombinators list \\<longrightarrow>\n       distinct list \\<longrightarrow>\n       allNetsDistinct list \\<longrightarrow>\n       wellformed_policy1 list \\<longrightarrow>\n       wellformed_policy2 list \\<longrightarrow>\n       wellformed_policy3 list \\<Longrightarrow>\n       singleCombinators (a # list) \\<longrightarrow>\n       a \\<notin> set list \\<and> distinct list \\<longrightarrow>\n       allNetsDistinct (a # list) \\<longrightarrow>\n       DenyAll \\<notin> set list \\<longrightarrow>\n       wellformed_policy2 (a # list) \\<longrightarrow>\n       wellformed_policy3 (a # list)", "apply (auto intro: singleCombinatorsConc ANDConc waux2 wp2Conc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>singleCombinators (a # list); a \\<notin> set list;\n        distinct list; allNetsDistinct (a # list);\n        DenyAll \\<notin> set list; wellformed_policy2 (a # list);\n        wellformed_policy3 list\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy3 (a # list)", "subgoal for a list"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators (a # list); a \\<notin> set list;\n     distinct list; allNetsDistinct (a # list); DenyAll \\<notin> set list;\n     wellformed_policy2 (a # list); wellformed_policy3 list\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy3 (a # list)", "apply (case_tac a, simp_all, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33 r.\n       \\<lbrakk>singleCombinators list;\n        AllowPortFromTo x31 x32 x33 \\<notin> set list; distinct list;\n        allNetsDistinct (AllowPortFromTo x31 x32 x33 # list);\n        DenyAll \\<notin> set list; wellformed_policy3 list;\n        a = AllowPortFromTo x31 x32 x33;\n        \\<forall>a b.\n           DenyAllFromTo a b \\<in> set list \\<longrightarrow>\n           dom (C (AllowPortFromTo x31 x32 x33)) \\<inter>\n           dom (C (DenyAllFromTo a b)) =\n           {};\n        wellformed_policy2 list; r \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> dom (C r) \\<inter>\n                         dom (C (AllowPortFromTo x31 x32 x33)) =\n                         {}", "apply (metis C.elims DomInterAllowsMT DomInterAllowsMT_Ports aux0_0 aux7aa inf_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "(* slow *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma DistinctNetsDenyAllow: \n \"DenyAllFromTo b c \\<in> set p \\<Longrightarrow>\n  AllowPortFromTo a d po \\<in> set p \\<Longrightarrow>\n  allNetsDistinct p \\<Longrightarrow> dom (C (DenyAllFromTo b c)) \\<inter> dom (C (AllowPortFromTo a d po)) \\<noteq> {} \\<Longrightarrow> \n  b = a \\<and> c = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAllFromTo b c \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p; allNetsDistinct p;\n     dom (C (DenyAllFromTo b c)) \\<inter>\n     dom (C (AllowPortFromTo a d po)) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d", "unfolding allNetsDistinct_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAllFromTo b c \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     \\<forall>a b.\n        a \\<noteq> b \\<and>\n        a \\<in> set (net_list p) \\<and>\n        b \\<in> set (net_list p) \\<longrightarrow>\n        netsDistinct a b;\n     dom (C (DenyAllFromTo b c)) \\<inter>\n     dom (C (AllowPortFromTo a d po)) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d", "apply (frule_tac x = \"b\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAllFromTo b c \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     \\<forall>a b.\n        a \\<noteq> b \\<and>\n        a \\<in> set (net_list p) \\<and>\n        b \\<in> set (net_list p) \\<longrightarrow>\n        netsDistinct a b;\n     dom (C (DenyAllFromTo b c)) \\<inter>\n     dom (C (AllowPortFromTo a d po)) \\<noteq>\n     {};\n     \\<forall>ba.\n        b \\<noteq> ba \\<and>\n        b \\<in> set (net_list p) \\<and>\n        ba \\<in> set (net_list p) \\<longrightarrow>\n        netsDistinct b ba\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d", "apply (drule_tac x = \"d\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAllFromTo b c \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     dom (C (DenyAllFromTo b c)) \\<inter>\n     dom (C (AllowPortFromTo a d po)) \\<noteq>\n     {};\n     \\<forall>ba.\n        b \\<noteq> ba \\<and>\n        b \\<in> set (net_list p) \\<and>\n        ba \\<in> set (net_list p) \\<longrightarrow>\n        netsDistinct b ba;\n     \\<forall>b.\n        d \\<noteq> b \\<and>\n        d \\<in> set (net_list p) \\<and>\n        b \\<in> set (net_list p) \\<longrightarrow>\n        netsDistinct d b\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d", "apply (drule_tac x = \"a\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAllFromTo b c \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     dom (C (DenyAllFromTo b c)) \\<inter>\n     dom (C (AllowPortFromTo a d po)) \\<noteq>\n     {};\n     \\<forall>b.\n        d \\<noteq> b \\<and>\n        d \\<in> set (net_list p) \\<and>\n        b \\<in> set (net_list p) \\<longrightarrow>\n        netsDistinct d b;\n     b \\<noteq> a \\<and>\n     b \\<in> set (net_list p) \\<and>\n     a \\<in> set (net_list p) \\<longrightarrow>\n     netsDistinct b a\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d", "apply (drule_tac x = \"c\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAllFromTo b c \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     dom (C (DenyAllFromTo b c)) \\<inter>\n     dom (C (AllowPortFromTo a d po)) \\<noteq>\n     {};\n     b \\<noteq> a \\<and>\n     b \\<in> set (net_list p) \\<and>\n     a \\<in> set (net_list p) \\<longrightarrow>\n     netsDistinct b a;\n     d \\<noteq> c \\<and>\n     d \\<in> set (net_list p) \\<and>\n     c \\<in> set (net_list p) \\<longrightarrow>\n     netsDistinct d c\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d", "apply (simp,metis Int_commute ND0aux1 ND0aux3 NDComm aux26 twoNetsDistinct_def ND0aux2 ND0aux4)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma DistinctNetsAllowAllow: \n \"AllowPortFromTo b c poo \\<in> set p \\<Longrightarrow>\n    AllowPortFromTo a d po \\<in> set p \\<Longrightarrow>\n    allNetsDistinct p \\<Longrightarrow> \n    dom (C (AllowPortFromTo b c poo)) \\<inter> dom (C (AllowPortFromTo a d po)) \\<noteq> {} \\<Longrightarrow> \n    b = a \\<and> c = d \\<and> poo = po\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo b c poo \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p; allNetsDistinct p;\n     dom (C (AllowPortFromTo b c poo)) \\<inter>\n     dom (C (AllowPortFromTo a d po)) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d \\<and> poo = po", "unfolding allNetsDistinct_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo b c poo \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     \\<forall>a b.\n        a \\<noteq> b \\<and>\n        a \\<in> set (net_list p) \\<and>\n        b \\<in> set (net_list p) \\<longrightarrow>\n        netsDistinct a b;\n     dom (C (AllowPortFromTo b c poo)) \\<inter>\n     dom (C (AllowPortFromTo a d po)) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d \\<and> poo = po", "apply (frule_tac x = \"b\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo b c poo \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     \\<forall>a b.\n        a \\<noteq> b \\<and>\n        a \\<in> set (net_list p) \\<and>\n        b \\<in> set (net_list p) \\<longrightarrow>\n        netsDistinct a b;\n     dom (C (AllowPortFromTo b c poo)) \\<inter>\n     dom (C (AllowPortFromTo a d po)) \\<noteq>\n     {};\n     \\<forall>ba.\n        b \\<noteq> ba \\<and>\n        b \\<in> set (net_list p) \\<and>\n        ba \\<in> set (net_list p) \\<longrightarrow>\n        netsDistinct b ba\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d \\<and> poo = po", "apply (drule_tac x = \"d\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo b c poo \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     dom (C (AllowPortFromTo b c poo)) \\<inter>\n     dom (C (AllowPortFromTo a d po)) \\<noteq>\n     {};\n     \\<forall>ba.\n        b \\<noteq> ba \\<and>\n        b \\<in> set (net_list p) \\<and>\n        ba \\<in> set (net_list p) \\<longrightarrow>\n        netsDistinct b ba;\n     \\<forall>b.\n        d \\<noteq> b \\<and>\n        d \\<in> set (net_list p) \\<and>\n        b \\<in> set (net_list p) \\<longrightarrow>\n        netsDistinct d b\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d \\<and> poo = po", "apply (drule_tac x = \"a\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo b c poo \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     dom (C (AllowPortFromTo b c poo)) \\<inter>\n     dom (C (AllowPortFromTo a d po)) \\<noteq>\n     {};\n     \\<forall>b.\n        d \\<noteq> b \\<and>\n        d \\<in> set (net_list p) \\<and>\n        b \\<in> set (net_list p) \\<longrightarrow>\n        netsDistinct d b;\n     b \\<noteq> a \\<and>\n     b \\<in> set (net_list p) \\<and>\n     a \\<in> set (net_list p) \\<longrightarrow>\n     netsDistinct b a\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d \\<and> poo = po", "apply (drule_tac x = \"c\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo b c poo \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     dom (C (AllowPortFromTo b c poo)) \\<inter>\n     dom (C (AllowPortFromTo a d po)) \\<noteq>\n     {};\n     b \\<noteq> a \\<and>\n     b \\<in> set (net_list p) \\<and>\n     a \\<in> set (net_list p) \\<longrightarrow>\n     netsDistinct b a;\n     d \\<noteq> c \\<and>\n     d \\<in> set (net_list p) \\<and>\n     c \\<in> set (net_list p) \\<longrightarrow>\n     netsDistinct d c\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d \\<and> poo = po", "apply (simp,metis DomInterAllowsMT DomInterAllowsMT_Ports ND0aux3 ND0aux4 NDComm \n    twoNetsDistinct_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WP2RS2[simp]: \n  \"singleCombinators p \\<Longrightarrow> distinct p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> \n   wellformed_policy2 (removeShadowRules2 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; distinct p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 p)", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>singleCombinators []; distinct []; allNetsDistinct []\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 [])\n 2. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>singleCombinators p; distinct p;\n                 allNetsDistinct p\\<rbrakk>\n                \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 p);\n        singleCombinators (a # p); distinct (a # p);\n        allNetsDistinct (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 (a # p))", "case Nil"], ["proof (state)\nthis:\n  singleCombinators []\n  distinct []\n  allNetsDistinct []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>singleCombinators []; distinct []; allNetsDistinct []\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 [])\n 2. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>singleCombinators p; distinct p;\n                 allNetsDistinct p\\<rbrakk>\n                \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 p);\n        singleCombinators (a # p); distinct (a # p);\n        allNetsDistinct (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 (a # p))", "thus ?case"], ["proof (prove)\nusing this:\n  singleCombinators []\n  distinct []\n  allNetsDistinct []\n\ngoal (1 subgoal):\n 1. wellformed_policy2 (removeShadowRules2 [])", "by simp"], ["proof (state)\nthis:\n  wellformed_policy2 (removeShadowRules2 [])\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>singleCombinators p; distinct p;\n                 allNetsDistinct p\\<rbrakk>\n                \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 p);\n        singleCombinators (a # p); distinct (a # p);\n        allNetsDistinct (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 (a # p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>singleCombinators p; distinct p;\n                 allNetsDistinct p\\<rbrakk>\n                \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 p);\n        singleCombinators (a # p); distinct (a # p);\n        allNetsDistinct (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 (a # p))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>singleCombinators xs; distinct xs; allNetsDistinct xs\\<rbrakk>\n  \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 xs)\n  singleCombinators (x # xs)\n  distinct (x # xs)\n  allNetsDistinct (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>singleCombinators p; distinct p;\n                 allNetsDistinct p\\<rbrakk>\n                \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 p);\n        singleCombinators (a # p); distinct (a # p);\n        allNetsDistinct (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 (a # p))", "have wp_xs: \"wellformed_policy2 (removeShadowRules2 xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy2 (removeShadowRules2 xs)", "by (metis Cons ANDConc distinct.simps(2) singleCombinatorsConc)"], ["proof (state)\nthis:\n  wellformed_policy2 (removeShadowRules2 xs)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>singleCombinators p; distinct p;\n                 allNetsDistinct p\\<rbrakk>\n                \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 p);\n        singleCombinators (a # p); distinct (a # p);\n        allNetsDistinct (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 (a # p))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy2 (removeShadowRules2 (x # xs))", "proof (cases x)"], ["proof (state)\ngoal (4 subgoals):\n 1. x = DenyAll \\<Longrightarrow>\n    wellformed_policy2 (removeShadowRules2 (x # xs))\n 2. \\<And>x21 x22.\n       x = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))\n 3. \\<And>x31 x32 x33.\n       x = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))\n 4. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))", "case DenyAll"], ["proof (state)\nthis:\n  x = DenyAll\n\ngoal (4 subgoals):\n 1. x = DenyAll \\<Longrightarrow>\n    wellformed_policy2 (removeShadowRules2 (x # xs))\n 2. \\<And>x21 x22.\n       x = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))\n 3. \\<And>x31 x32 x33.\n       x = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))\n 4. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = DenyAll\n\ngoal (1 subgoal):\n 1. wellformed_policy2 (removeShadowRules2 (x # xs))", "using wp_xs"], ["proof (prove)\nusing this:\n  x = DenyAll\n  wellformed_policy2 (removeShadowRules2 xs)\n\ngoal (1 subgoal):\n 1. wellformed_policy2 (removeShadowRules2 (x # xs))", "by simp"], ["proof (state)\nthis:\n  wellformed_policy2 (removeShadowRules2 (x # xs))\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       x = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))\n 2. \\<And>x31 x32 x33.\n       x = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))\n 3. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       x = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))\n 2. \\<And>x31 x32 x33.\n       x = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))\n 3. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))", "case (DenyAllFromTo a b)"], ["proof (state)\nthis:\n  x = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       x = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))\n 2. \\<And>x31 x32 x33.\n       x = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))\n 3. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = DenyAllFromTo a b\n\ngoal (1 subgoal):\n 1. wellformed_policy2 (removeShadowRules2 (x # xs))", "using wp_xs Cons"], ["proof (prove)\nusing this:\n  x = DenyAllFromTo a b\n  wellformed_policy2 (removeShadowRules2 xs)\n  \\<lbrakk>singleCombinators xs; distinct xs; allNetsDistinct xs\\<rbrakk>\n  \\<Longrightarrow> wellformed_policy2 (removeShadowRules2 xs)\n  singleCombinators (x # xs)\n  distinct (x # xs)\n  allNetsDistinct (x # xs)\n\ngoal (1 subgoal):\n 1. wellformed_policy2 (removeShadowRules2 (x # xs))", "by (simp,metis DenyAllFromTo aux aux7 tNDComm deny_dom)"], ["proof (state)\nthis:\n  wellformed_policy2 (removeShadowRules2 (x # xs))\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       x = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))\n 2. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       x = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))\n 2. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))", "case (AllowPortFromTo a b p)"], ["proof (state)\nthis:\n  x = AllowPortFromTo a b p\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       x = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))\n 2. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = AllowPortFromTo a b p\n\ngoal (1 subgoal):\n 1. wellformed_policy2 (removeShadowRules2 (x # xs))", "using  wp_xs"], ["proof (prove)\nusing this:\n  x = AllowPortFromTo a b p\n  wellformed_policy2 (removeShadowRules2 xs)\n\ngoal (1 subgoal):\n 1. wellformed_policy2 (removeShadowRules2 (x # xs))", "by (simp, metis aux26 AllowPortFromTo Cons(4) aux aux7a tNDComm)"], ["proof (state)\nthis:\n  wellformed_policy2 (removeShadowRules2 (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))", "case (Conc a b)"], ["proof (state)\nthis:\n  x = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2 (removeShadowRules2 (x # xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. wellformed_policy2 (removeShadowRules2 (x # xs))", "by (metis Conc Cons(2) singleCombinators.simps(2))"], ["proof (state)\nthis:\n  wellformed_policy2 (removeShadowRules2 (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wellformed_policy2 (removeShadowRules2 (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AD_aux: \n  \"AllowPortFromTo a b po \\<in> set p \\<Longrightarrow>  DenyAllFromTo c d \\<in> set p \\<Longrightarrow>\n   allNetsDistinct p \\<Longrightarrow>  singleCombinators p \\<Longrightarrow> a \\<noteq> c \\<or> b \\<noteq> d \\<Longrightarrow> \n   dom (C (AllowPortFromTo a b po)) \\<inter> dom (C (DenyAllFromTo c d)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo a b po \\<in> set p;\n     DenyAllFromTo c d \\<in> set p; allNetsDistinct p; singleCombinators p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> dom (C (AllowPortFromTo a b po)) \\<inter>\n                      dom (C (DenyAllFromTo c d)) =\n                      {}", "by (rule aux26,rule_tac x =\"AllowPortFromTo a b po\" and y = \"DenyAllFromTo c d\" in tND, auto)"], ["", "lemma sorted_WP2[rule_format]: \"sorted p l \\<longrightarrow> all_in_list p l \\<longrightarrow> distinct p \\<longrightarrow> \n            allNetsDistinct p \\<longrightarrow> singleCombinators p \\<longrightarrow> wellformed_policy2 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted p l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    distinct p \\<longrightarrow>\n    allNetsDistinct p \\<longrightarrow>\n    singleCombinators p \\<longrightarrow> wellformed_policy2 p", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. FWNormalisationCore.sorted [] l \\<longrightarrow>\n    all_in_list [] l \\<longrightarrow>\n    distinct [] \\<longrightarrow>\n    allNetsDistinct [] \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow> wellformed_policy2 []\n 2. \\<And>a p.\n       FWNormalisationCore.sorted p l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       wellformed_policy2 p \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n       all_in_list (a # p) l \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       wellformed_policy2 (a # p)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. FWNormalisationCore.sorted [] l \\<longrightarrow>\n    all_in_list [] l \\<longrightarrow>\n    distinct [] \\<longrightarrow>\n    allNetsDistinct [] \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow> wellformed_policy2 []\n 2. \\<And>a p.\n       FWNormalisationCore.sorted p l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       wellformed_policy2 p \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n       all_in_list (a # p) l \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       wellformed_policy2 (a # p)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted [] l \\<longrightarrow>\n    all_in_list [] l \\<longrightarrow>\n    distinct [] \\<longrightarrow>\n    allNetsDistinct [] \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow> wellformed_policy2 []", "by simp"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted [] l \\<longrightarrow>\n  all_in_list [] l \\<longrightarrow>\n  distinct [] \\<longrightarrow>\n  allNetsDistinct [] \\<longrightarrow>\n  singleCombinators [] \\<longrightarrow> wellformed_policy2 []\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       FWNormalisationCore.sorted p l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       wellformed_policy2 p \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n       all_in_list (a # p) l \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       wellformed_policy2 (a # p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       FWNormalisationCore.sorted p l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       wellformed_policy2 p \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n       all_in_list (a # p) l \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       wellformed_policy2 (a # p)", "case (Cons a p)"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted p l \\<longrightarrow>\n  all_in_list p l \\<longrightarrow>\n  distinct p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow>\n  singleCombinators p \\<longrightarrow> wellformed_policy2 p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       FWNormalisationCore.sorted p l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       wellformed_policy2 p \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n       all_in_list (a # p) l \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       wellformed_policy2 (a # p)", "thus ?case"], ["proof (prove)\nusing this:\n  FWNormalisationCore.sorted p l \\<longrightarrow>\n  all_in_list p l \\<longrightarrow>\n  distinct p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow>\n  singleCombinators p \\<longrightarrow> wellformed_policy2 p\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    all_in_list (a # p) l \\<longrightarrow>\n    distinct (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    singleCombinators (a # p) \\<longrightarrow> wellformed_policy2 (a # p)", "proof (cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n             all_in_list p l \\<longrightarrow>\n             distinct p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow>\n             singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n     a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n                      all_in_list (a # p) l \\<longrightarrow>\n                      distinct (a # p) \\<longrightarrow>\n                      allNetsDistinct (a # p) \\<longrightarrow>\n                      singleCombinators (a # p) \\<longrightarrow>\n                      wellformed_policy2 (a # p)\n 2. \\<And>x21 x22.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)\n 4. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)", "case DenyAll"], ["proof (state)\nthis:\n  a = DenyAll\n\ngoal (4 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n             all_in_list p l \\<longrightarrow>\n             distinct p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow>\n             singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n     a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n                      all_in_list (a # p) l \\<longrightarrow>\n                      distinct (a # p) \\<longrightarrow>\n                      allNetsDistinct (a # p) \\<longrightarrow>\n                      singleCombinators (a # p) \\<longrightarrow>\n                      wellformed_policy2 (a # p)\n 2. \\<And>x21 x22.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)\n 4. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = DenyAll\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    all_in_list (a # p) l \\<longrightarrow>\n    distinct (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    singleCombinators (a # p) \\<longrightarrow> wellformed_policy2 (a # p)", "using  Cons"], ["proof (prove)\nusing this:\n  a = DenyAll\n  FWNormalisationCore.sorted p l \\<longrightarrow>\n  all_in_list p l \\<longrightarrow>\n  distinct p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow>\n  singleCombinators p \\<longrightarrow> wellformed_policy2 p\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    all_in_list (a # p) l \\<longrightarrow>\n    distinct (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    singleCombinators (a # p) \\<longrightarrow> wellformed_policy2 (a # p)", "by (auto intro: ANDConc singleCombinatorsConc sortedConcEnd)"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n  all_in_list (a # p) l \\<longrightarrow>\n  distinct (a # p) \\<longrightarrow>\n  allNetsDistinct (a # p) \\<longrightarrow>\n  singleCombinators (a # p) \\<longrightarrow> wellformed_policy2 (a # p)\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)\n 3. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)\n 3. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)", "case (DenyAllFromTo c d)"], ["proof (state)\nthis:\n  a = DenyAllFromTo c d\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)\n 3. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = DenyAllFromTo c d\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    all_in_list (a # p) l \\<longrightarrow>\n    distinct (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    singleCombinators (a # p) \\<longrightarrow> wellformed_policy2 (a # p)", "using  Cons"], ["proof (prove)\nusing this:\n  a = DenyAllFromTo c d\n  FWNormalisationCore.sorted p l \\<longrightarrow>\n  all_in_list p l \\<longrightarrow>\n  distinct p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow>\n  singleCombinators p \\<longrightarrow> wellformed_policy2 p\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    all_in_list (a # p) l \\<longrightarrow>\n    distinct (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    singleCombinators (a # p) \\<longrightarrow> wellformed_policy2 (a # p)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = DenyAllFromTo c d;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     all_in_list p l \\<longrightarrow>\n     distinct p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow>\n     singleCombinators p \\<longrightarrow> wellformed_policy2 p\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted (DenyAllFromTo c d # p)\n                       l \\<longrightarrow>\n                      {c, d} \\<in> set l \\<and>\n                      all_in_list p l \\<longrightarrow>\n                      DenyAllFromTo c d \\<notin> set p \\<and>\n                      distinct p \\<longrightarrow>\n                      allNetsDistinct\n                       (DenyAllFromTo c d # p) \\<longrightarrow>\n                      singleCombinators p \\<longrightarrow>\n                      (\\<forall>a b.\n                          DenyAllFromTo a b \\<in> set p \\<longrightarrow>\n                          dom (C (DenyAllFromTo c d)) \\<inter>\n                          dom (C (DenyAllFromTo a b)) =\n                          {}) \\<and>\n                      wellformed_policy2 p", "apply (intro impI conjI allI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        all_in_list p l \\<longrightarrow>\n        distinct p \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow>\n        singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (DenyAllFromTo c d # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        DenyAllFromTo c d \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (DenyAllFromTo c d # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> dom (C (DenyAllFromTo c d)) \\<inter>\n                         dom (C (DenyAllFromTo aa b)) =\n                         {}\n 2. \\<lbrakk>a = DenyAllFromTo c d;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     all_in_list p l \\<longrightarrow>\n     distinct p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow>\n     singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n     FWNormalisationCore.sorted (DenyAllFromTo c d # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     DenyAllFromTo c d \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (DenyAllFromTo c d # p); singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2 p", "apply (rule deny_dom)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        all_in_list p l \\<longrightarrow>\n        distinct p \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow>\n        singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (DenyAllFromTo c d # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        DenyAllFromTo c d \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (DenyAllFromTo c d # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> twoNetsDistinct c d aa b\n 2. \\<lbrakk>a = DenyAllFromTo c d;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     all_in_list p l \\<longrightarrow>\n     distinct p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow>\n     singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n     FWNormalisationCore.sorted (DenyAllFromTo c d # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     DenyAllFromTo c d \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (DenyAllFromTo c d # p); singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2 p", "apply (auto intro:  aux7 tNDComm ANDConc singleCombinatorsConc sortedConcEnd)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n  all_in_list (a # p) l \\<longrightarrow>\n  distinct (a # p) \\<longrightarrow>\n  allNetsDistinct (a # p) \\<longrightarrow>\n  singleCombinators (a # p) \\<longrightarrow> wellformed_policy2 (a # p)\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)\n 2. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)\n 2. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)", "case (AllowPortFromTo c d e)"], ["proof (state)\nthis:\n  a = AllowPortFromTo c d e\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)\n 2. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = AllowPortFromTo c d e\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    all_in_list (a # p) l \\<longrightarrow>\n    distinct (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    singleCombinators (a # p) \\<longrightarrow> wellformed_policy2 (a # p)", "using Cons"], ["proof (prove)\nusing this:\n  a = AllowPortFromTo c d e\n  FWNormalisationCore.sorted p l \\<longrightarrow>\n  all_in_list p l \\<longrightarrow>\n  distinct p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow>\n  singleCombinators p \\<longrightarrow> wellformed_policy2 p\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    all_in_list (a # p) l \\<longrightarrow>\n    distinct (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    singleCombinators (a # p) \\<longrightarrow> wellformed_policy2 (a # p)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     all_in_list p l \\<longrightarrow>\n     distinct p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow>\n     singleCombinators p \\<longrightarrow> wellformed_policy2 p\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted (AllowPortFromTo c d e # p)\n                       l \\<longrightarrow>\n                      {c, d} \\<in> set l \\<and>\n                      all_in_list p l \\<longrightarrow>\n                      AllowPortFromTo c d e \\<notin> set p \\<and>\n                      distinct p \\<longrightarrow>\n                      allNetsDistinct\n                       (AllowPortFromTo c d e # p) \\<longrightarrow>\n                      singleCombinators p \\<longrightarrow>\n                      (\\<forall>a b.\n                          DenyAllFromTo a b \\<in> set p \\<longrightarrow>\n                          dom (C (AllowPortFromTo c d e)) \\<inter>\n                          dom (C (DenyAllFromTo a b)) =\n                          {}) \\<and>\n                      wellformed_policy2 p", "apply (intro impI  conjI allI aux26)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        all_in_list p l \\<longrightarrow>\n        distinct p \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow>\n        singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> twoNetsDistinct c d aa b\n 2. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     all_in_list p l \\<longrightarrow>\n     distinct p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow>\n     singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p);\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2 p", "apply (rule_tac x = \"AllowPortFromTo c d e\" and  y = \"DenyAllFromTo aa b\" in tND)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        all_in_list p l \\<longrightarrow>\n        distinct p \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow>\n        singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> allNetsDistinct (?p27 aa b)\n 2. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        all_in_list p l \\<longrightarrow>\n        distinct p \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow>\n        singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo c d e \\<in> set (?p27 aa b)\n 3. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        all_in_list p l \\<longrightarrow>\n        distinct p \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow>\n        singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> DenyAllFromTo aa b \\<in> set (?p27 aa b)\n 4. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        all_in_list p l \\<longrightarrow>\n        distinct p \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow>\n        singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> c = srcNet (AllowPortFromTo c d e)\n 5. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        all_in_list p l \\<longrightarrow>\n        distinct p \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow>\n        singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> d = destNet (AllowPortFromTo c d e)\n 6. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        all_in_list p l \\<longrightarrow>\n        distinct p \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow>\n        singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> aa = srcNet (DenyAllFromTo aa b)\n 7. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        all_in_list p l \\<longrightarrow>\n        distinct p \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow>\n        singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> b = destNet (DenyAllFromTo aa b)\n 8. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        all_in_list p l \\<longrightarrow>\n        distinct p \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow>\n        singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> c \\<noteq> aa \\<or> d \\<noteq> b\n 9. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        all_in_list p l \\<longrightarrow>\n        distinct p \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow>\n        singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [AllowPortFromTo c d e]\n 10. \\<And>aa b.\n        \\<lbrakk>a = AllowPortFromTo c d e;\n         FWNormalisationCore.sorted p l \\<longrightarrow>\n         all_in_list p l \\<longrightarrow>\n         distinct p \\<longrightarrow>\n         allNetsDistinct p \\<longrightarrow>\n         singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n         FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n         {c, d} \\<in> set l \\<and> all_in_list p l;\n         AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n         allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n         DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n        \\<Longrightarrow> AllowPortFromTo c d e \\<noteq> DenyAll\nA total of 13 subgoals...", "apply (assumption,simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> c = aa \\<longrightarrow> d \\<noteq> b\n 2. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> wellformed_policy2 p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p);\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2 p", "apply (subgoal_tac \"smaller (AllowPortFromTo c d e) (DenyAllFromTo aa b) l\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p;\n        smaller (AllowPortFromTo c d e) (DenyAllFromTo aa b) l\\<rbrakk>\n       \\<Longrightarrow> c = aa \\<longrightarrow> d \\<noteq> b\n 2. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo c d e)\n                          (DenyAllFromTo aa b) l\n 3. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> wellformed_policy2 p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p);\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2 p", "apply (simp split: if_splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p; {c, d} \\<noteq> {aa, b};\n        {c, d} \\<in> set l; all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p; distinct p;\n        position {c, d} l \\<le> position {aa, b} l\\<rbrakk>\n       \\<Longrightarrow> c = aa \\<longrightarrow> d \\<noteq> b\n 2. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo c d e)\n                          (DenyAllFromTo aa b) l\n 3. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> wellformed_policy2 p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p);\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2 p", "apply metis"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow> wellformed_policy2 p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo c d e)\n                          (DenyAllFromTo aa b) l\n 2. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> wellformed_policy2 p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p);\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2 p", "apply (erule sorted_is_smaller, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow> wellformed_policy2 p;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> {aa, b} \\<in> set l\n 2. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> wellformed_policy2 p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p);\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2 p", "apply (metis bothNet.simps(2) in_list.simps(2)  in_set_in_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> wellformed_policy2 p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p);\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2 p", "by (auto intro: aux7 tNDComm ANDConc singleCombinatorsConc sortedConcEnd)"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n  all_in_list (a # p) l \\<longrightarrow>\n  distinct (a # p) \\<longrightarrow>\n  allNetsDistinct (a # p) \\<longrightarrow>\n  singleCombinators (a # p) \\<longrightarrow> wellformed_policy2 (a # p)\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2 (a # p)", "case (Conc a b)"], ["proof (state)\nthis:\n  a__ = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow> wellformed_policy2 p;\n        a__ = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a__ # p)\n                          l \\<longrightarrow>\n                         all_in_list (a__ # p) l \\<longrightarrow>\n                         distinct (a__ # p) \\<longrightarrow>\n                         allNetsDistinct (a__ # p) \\<longrightarrow>\n                         singleCombinators (a__ # p) \\<longrightarrow>\n                         wellformed_policy2 (a__ # p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a__ = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a__ # p) l \\<longrightarrow>\n    all_in_list (a__ # p) l \\<longrightarrow>\n    distinct (a__ # p) \\<longrightarrow>\n    allNetsDistinct (a__ # p) \\<longrightarrow>\n    singleCombinators (a__ # p) \\<longrightarrow>\n    wellformed_policy2 (a__ # p)", "using Cons"], ["proof (prove)\nusing this:\n  a__ = a \\<oplus> b\n  FWNormalisationCore.sorted p l \\<longrightarrow>\n  all_in_list p l \\<longrightarrow>\n  distinct p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow>\n  singleCombinators p \\<longrightarrow> wellformed_policy2 p\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a__ # p) l \\<longrightarrow>\n    all_in_list (a__ # p) l \\<longrightarrow>\n    distinct (a__ # p) \\<longrightarrow>\n    allNetsDistinct (a__ # p) \\<longrightarrow>\n    singleCombinators (a__ # p) \\<longrightarrow>\n    wellformed_policy2 (a__ # p)", "by simp"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted (a__ # p) l \\<longrightarrow>\n  all_in_list (a__ # p) l \\<longrightarrow>\n  distinct (a__ # p) \\<longrightarrow>\n  allNetsDistinct (a__ # p) \\<longrightarrow>\n  singleCombinators (a__ # p) \\<longrightarrow> wellformed_policy2 (a__ # p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n  all_in_list (a # p) l \\<longrightarrow>\n  distinct (a # p) \\<longrightarrow>\n  allNetsDistinct (a # p) \\<longrightarrow>\n  singleCombinators (a # p) \\<longrightarrow> wellformed_policy2 (a # p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wellformed2_sorted[simp]: \n  \"all_in_list p l \\<Longrightarrow> distinct p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> \n   singleCombinators p \\<Longrightarrow> wellformed_policy2 (sort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_in_list p l; distinct p; allNetsDistinct p;\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2 (FWNormalisationCore.sort p l)", "apply (rule sorted_WP2,erule sort_is_sorted, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_in_list p l; distinct p; allNetsDistinct p;\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> all_in_list (FWNormalisationCore.sort p l) l", "apply (auto elim: all_in_listSubset intro: SC3 singleCombinatorsConc sorted_insort)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wellformed2_sortedQ[simp]: \"\\<lbrakk>all_in_list p l; distinct p; allNetsDistinct p;\n                         singleCombinators p\\<rbrakk> \\<Longrightarrow> wellformed_policy2 (qsort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_in_list p l; distinct p; allNetsDistinct p;\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2 (qsort p l)", "apply (rule sorted_WP2,erule sort_is_sortedQ, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>all_in_list p l; distinct p; allNetsDistinct p;\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> all_in_list (qsort p l) l\n 2. \\<lbrakk>all_in_list p l; distinct p; allNetsDistinct p;\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> distinct (qsort p l)", "apply (auto elim: all_in_listSubset intro: SC3Q singleCombinatorsConc distinct_sortQ)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_DenyAll[simp]: \"C (list2FWpolicy (xs @ [DenyAll])) x = Some (deny ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C (list2FWpolicy (xs @ [DenyAll])) x = \\<lfloor>deny ()\\<rfloor>", "by (auto simp: PLemmas)"], ["", "lemma C_eq_RS1n:\n  \"C(list2FWpolicy (removeShadowRules1_alternative p)) = C(list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C (list2FWpolicy (removeShadowRules1_alternative p)) =\n    C (list2FWpolicy p)", "proof (cases \"p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    C (list2FWpolicy (removeShadowRules1_alternative p)) =\n    C (list2FWpolicy p)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       C (list2FWpolicy (removeShadowRules1_alternative p)) =\n       C (list2FWpolicy p)", "print_cases"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    C (list2FWpolicy (removeShadowRules1_alternative p)) =\n    C (list2FWpolicy p)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       C (list2FWpolicy (removeShadowRules1_alternative p)) =\n       C (list2FWpolicy p)", "case Nil"], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    C (list2FWpolicy (removeShadowRules1_alternative p)) =\n    C (list2FWpolicy p)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       C (list2FWpolicy (removeShadowRules1_alternative p)) =\n       C (list2FWpolicy p)", "then"], ["proof (chain)\npicking this:\n  p = []", "show ?thesis"], ["proof (prove)\nusing this:\n  p = []\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy (removeShadowRules1_alternative p)) =\n    C (list2FWpolicy p)", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = [] \\<Longrightarrow>\n    C (list2FWpolicy (removeShadowRules1_alternative [])) = C undefined", "by (metis list2FWpolicy.simps(1) rSR1_eq removeShadowRules1.simps(2))"], ["proof (state)\nthis:\n  C (list2FWpolicy (removeShadowRules1_alternative p)) = C (list2FWpolicy p)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       C (list2FWpolicy (removeShadowRules1_alternative p)) =\n       C (list2FWpolicy p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       C (list2FWpolicy (removeShadowRules1_alternative p)) =\n       C (list2FWpolicy p)", "case (Cons x list)"], ["proof (state)\nthis:\n  p = x # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       C (list2FWpolicy (removeShadowRules1_alternative p)) =\n       C (list2FWpolicy p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. C (list2FWpolicy (removeShadowRules1_alternative p)) =\n    C (list2FWpolicy p)", "apply (rule rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. C (list2FWpolicy (removeShadowRules1_alternative [])) =\n    C (list2FWpolicy [])\n 2. \\<And>x xs.\n       C (list2FWpolicy (removeShadowRules1_alternative xs)) =\n       C (list2FWpolicy xs) \\<Longrightarrow>\n       C (list2FWpolicy (removeShadowRules1_alternative (xs @ [x]))) =\n       C (list2FWpolicy (xs @ [x]))", "apply (metis rSR1_eq removeShadowRules1.simps(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       C (list2FWpolicy (removeShadowRules1_alternative xs)) =\n       C (list2FWpolicy xs) \\<Longrightarrow>\n       C (list2FWpolicy (removeShadowRules1_alternative (xs @ [x]))) =\n       C (list2FWpolicy (xs @ [x]))", "subgoal for x xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. C (list2FWpolicy (removeShadowRules1_alternative xs)) =\n    C (list2FWpolicy xs) \\<Longrightarrow>\n    C (list2FWpolicy (removeShadowRules1_alternative (xs @ [x]))) =\n    C (list2FWpolicy (xs @ [x]))", "apply (case_tac \"xs = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy (removeShadowRules1_alternative [])) =\n             C undefined;\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (removeShadowRules1_alternative [x])) =\n                      C x\n 2. \\<lbrakk>C (list2FWpolicy (removeShadowRules1_alternative xs)) =\n             C (list2FWpolicy xs);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (removeShadowRules1_alternative (xs @ [x]))) =\n                      C (list2FWpolicy (xs @ [x]))", "unfolding removeShadowRules1_alternative_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy\n                 (rev (removeShadowRules1_alternative_rev (rev [])))) =\n             C undefined;\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (rev (removeShadowRules1_alternative_rev\n                                 (rev [x])))) =\n                      C x\n 2. \\<lbrakk>C (list2FWpolicy\n                 (rev (removeShadowRules1_alternative_rev (rev xs)))) =\n             C (list2FWpolicy xs);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (rev (removeShadowRules1_alternative_rev\n                                 (rev (xs @ [x]))))) =\n                      C (list2FWpolicy (xs @ [x]))", "apply (case_tac x, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C (list2FWpolicy\n                 (rev (removeShadowRules1_alternative_rev (rev xs)))) =\n             C (list2FWpolicy xs);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (rev (removeShadowRules1_alternative_rev\n                                 (x # rev xs)))) =\n                      C (list2FWpolicy (xs @ [x]))", "by (metis (no_types, hide_lams) CConcEnd2 CConcStart C_DenyAll RS1n_nMT aux114 \n          domIff removeShadowRules1_alternative_def \n          removeShadowRules1_alternative_rev.simps(2) rev.simps(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  C (list2FWpolicy (removeShadowRules1_alternative p)) = C (list2FWpolicy p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_RS1[simp]: \n  \"p \\<noteq> [] \\<Longrightarrow>  C(list2FWpolicy (removeShadowRules1 p)) = C(list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    C (list2FWpolicy (removeShadowRules1 p)) = C (list2FWpolicy p)", "by (metis rSR1_eq C_eq_RS1n)"], ["", "lemma EX_MR_aux[rule_format]: \n  \"applied_rule_rev C x (DenyAll # p) \\<noteq> Some DenyAll \\<longrightarrow> (\\<exists>y. applied_rule_rev C x p = Some y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x (DenyAll # p) \\<noteq>\n    \\<lfloor>DenyAll\\<rfloor> \\<longrightarrow>\n    (\\<exists>y. applied_rule_rev C x p = \\<lfloor>y\\<rfloor>)", "apply (simp add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule C x (rev p @ [DenyAll]) \\<noteq>\n    \\<lfloor>DenyAll\\<rfloor> \\<longrightarrow>\n    (\\<exists>y. applied_rule C x (rev p) = \\<lfloor>y\\<rfloor>)", "apply (rule_tac xs = p in rev_induct, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma EX_MR : \n  \"applied_rule_rev C x p \\<noteq> \\<lfloor>DenyAll\\<rfloor> \\<Longrightarrow> p = DenyAll # ps \\<Longrightarrow> \n applied_rule_rev C x p = applied_rule_rev C x ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev C x p \\<noteq> \\<lfloor>DenyAll\\<rfloor>;\n     p = DenyAll # ps\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x ps", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev C x (DenyAll # ps) \\<noteq>\n             \\<lfloor>DenyAll\\<rfloor>;\n     p = DenyAll # ps\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (DenyAll # ps) =\n                      applied_rule_rev C x ps", "apply (subgoal_tac \"applied_rule_rev C x (DenyAll#ps) \\<noteq> None\", auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>y \\<noteq> DenyAll; p = DenyAll # ps;\n        applied_rule_rev C x (DenyAll # ps) = \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>y\\<rfloor> = applied_rule_rev C x ps\n 2. \\<lbrakk>applied_rule_rev C x (DenyAll # ps) \\<noteq>\n             \\<lfloor>DenyAll\\<rfloor>;\n     p = DenyAll # ps\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         applied_rule_rev C x (DenyAll # ps) =\n                         \\<lfloor>y\\<rfloor>", "apply (metis mrConcEnd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev C x (DenyAll # ps) \\<noteq>\n             \\<lfloor>DenyAll\\<rfloor>;\n     p = DenyAll # ps\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         applied_rule_rev C x (DenyAll # ps) =\n                         \\<lfloor>y\\<rfloor>", "by (metis DAimpliesMR_E list.sel(1) hd_in_set list.simps(3) not_Some_eq)"], ["", "lemma mr_not_DA:\n  \"wellformed_policy1_strong s \\<Longrightarrow>\n   applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a ab\\<rfloor> \\<Longrightarrow> set p = set s \\<Longrightarrow>\n   applied_rule_rev C x s \\<noteq> \\<lfloor>DenyAll\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1_strong s;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a ab\\<rfloor>;\n     set p = set s\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x s \\<noteq>\n                      \\<lfloor>DenyAll\\<rfloor>", "apply (subst wp1n_tl, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1_strong s;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a ab\\<rfloor>;\n     set p = set s\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (DenyAll # tl s) \\<noteq>\n                      \\<lfloor>DenyAll\\<rfloor>", "apply (subgoal_tac \"x \\<in> dom (C (DenyAllFromTo a ab))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wellformed_policy1_strong s;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a ab\\<rfloor>;\n     set p = set s; x \\<in> dom (C (DenyAllFromTo a ab))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (DenyAll # tl s) \\<noteq>\n                      \\<lfloor>DenyAll\\<rfloor>\n 2. \\<lbrakk>wellformed_policy1_strong s;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a ab\\<rfloor>;\n     set p = set s\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo a ab))", "apply (subgoal_tac \"DenyAllFromTo a ab \\<in> set (tl s)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>wellformed_policy1_strong s;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a ab\\<rfloor>;\n     set p = set s; x \\<in> dom (C (DenyAllFromTo a ab));\n     DenyAllFromTo a ab \\<in> set (tl s)\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (DenyAll # tl s) \\<noteq>\n                      \\<lfloor>DenyAll\\<rfloor>\n 2. \\<lbrakk>wellformed_policy1_strong s;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a ab\\<rfloor>;\n     set p = set s; x \\<in> dom (C (DenyAllFromTo a ab))\\<rbrakk>\n    \\<Longrightarrow> DenyAllFromTo a ab \\<in> set (tl s)\n 3. \\<lbrakk>wellformed_policy1_strong s;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a ab\\<rfloor>;\n     set p = set s\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo a ab))", "apply (metis wp1n_tl foo98 wellformed_policy1_strong.simps(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wellformed_policy1_strong s;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a ab\\<rfloor>;\n     set p = set s; x \\<in> dom (C (DenyAllFromTo a ab))\\<rbrakk>\n    \\<Longrightarrow> DenyAllFromTo a ab \\<in> set (tl s)\n 2. \\<lbrakk>wellformed_policy1_strong s;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a ab\\<rfloor>;\n     set p = set s\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo a ab))", "using mrSet r_not_DA_in_tl"], ["proof (prove)\nusing this:\n  applied_rule_rev C ?x ?p = \\<lfloor>?r\\<rfloor> \\<Longrightarrow>\n  ?r \\<in> set ?p\n  \\<lbrakk>wellformed_policy1_strong ?p; ?a \\<in> set ?p;\n   ?a \\<noteq> DenyAll\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> set (tl ?p)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wellformed_policy1_strong s;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a ab\\<rfloor>;\n     set p = set s; x \\<in> dom (C (DenyAllFromTo a ab))\\<rbrakk>\n    \\<Longrightarrow> DenyAllFromTo a ab \\<in> set (tl s)\n 2. \\<lbrakk>wellformed_policy1_strong s;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a ab\\<rfloor>;\n     set p = set s\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo a ab))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1_strong s;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a ab\\<rfloor>;\n     set p = set s\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo a ab))", "by (simp add: mr_in_dom)"], ["", "lemma domsMT_notND_DD: \n  \"dom (C (DenyAllFromTo a b)) \\<inter> dom (C (DenyAllFromTo c d)) \\<noteq> {} \\<Longrightarrow> \\<not> netsDistinct a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (C (DenyAllFromTo a b)) \\<inter>\n    dom (C (DenyAllFromTo c d)) \\<noteq>\n    {} \\<Longrightarrow>\n    \\<not> netsDistinct a c", "using deny_dom twoNetsDistinct_def"], ["proof (prove)\nusing this:\n  twoNetsDistinct ?a ?b ?c ?d \\<Longrightarrow>\n  dom (C (DenyAllFromTo ?a ?b)) \\<inter> dom (C (DenyAllFromTo ?c ?d)) = {}\n  twoNetsDistinct ?a ?b ?c ?d =\n  (netsDistinct ?a ?c \\<or> netsDistinct ?b ?d)\n\ngoal (1 subgoal):\n 1. dom (C (DenyAllFromTo a b)) \\<inter>\n    dom (C (DenyAllFromTo c d)) \\<noteq>\n    {} \\<Longrightarrow>\n    \\<not> netsDistinct a c", "by blast"], ["", "lemma domsMT_notND_DD2: \n  \"dom (C (DenyAllFromTo a b)) \\<inter> dom (C (DenyAllFromTo c d)) \\<noteq> {} \\<Longrightarrow> \\<not> netsDistinct b d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (C (DenyAllFromTo a b)) \\<inter>\n    dom (C (DenyAllFromTo c d)) \\<noteq>\n    {} \\<Longrightarrow>\n    \\<not> netsDistinct b d", "using deny_dom twoNetsDistinct_def"], ["proof (prove)\nusing this:\n  twoNetsDistinct ?a ?b ?c ?d \\<Longrightarrow>\n  dom (C (DenyAllFromTo ?a ?b)) \\<inter> dom (C (DenyAllFromTo ?c ?d)) = {}\n  twoNetsDistinct ?a ?b ?c ?d =\n  (netsDistinct ?a ?c \\<or> netsDistinct ?b ?d)\n\ngoal (1 subgoal):\n 1. dom (C (DenyAllFromTo a b)) \\<inter>\n    dom (C (DenyAllFromTo c d)) \\<noteq>\n    {} \\<Longrightarrow>\n    \\<not> netsDistinct b d", "by blast"], ["", "lemma domsMT_notND_DD3: \n  \"x \\<in> dom (C (DenyAllFromTo a b)) \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo c d)) \\<Longrightarrow>  \\<not> netsDistinct a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (C (DenyAllFromTo a b));\n     x \\<in> dom (C (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> \\<not> netsDistinct a c", "by(auto intro!:domsMT_notND_DD)"], ["", "lemma domsMT_notND_DD4: \n  \"x \\<in> dom (C (DenyAllFromTo a b)) \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo c d)) \\<Longrightarrow> \\<not> netsDistinct b d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (C (DenyAllFromTo a b));\n     x \\<in> dom (C (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> \\<not> netsDistinct b d", "by(auto intro!:domsMT_notND_DD2)"], ["", "lemma NetsEq_if_sameP_DD: \n  \"allNetsDistinct p \\<Longrightarrow>  u \\<in> set p \\<Longrightarrow>  v \\<in> set p \\<Longrightarrow> u = DenyAllFromTo a b \\<Longrightarrow> \n   v = DenyAllFromTo c d \\<Longrightarrow> x \\<in> dom (C u) \\<Longrightarrow> x \\<in> dom (C v) \\<Longrightarrow> a = c \\<and> b = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allNetsDistinct p; u \\<in> set p; v \\<in> set p;\n     u = DenyAllFromTo a b; v = DenyAllFromTo c d; x \\<in> dom (C u);\n     x \\<in> dom (C v)\\<rbrakk>\n    \\<Longrightarrow> a = c \\<and> b = d", "apply (simp add: allNetsDistinct_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b.\n                a \\<noteq> b \\<and>\n                a \\<in> set (net_list_aux p) \\<and>\n                b \\<in> set (net_list_aux p) \\<longrightarrow>\n                netsDistinct a b;\n     DenyAllFromTo a b \\<in> set p; DenyAllFromTo c d \\<in> set p;\n     u = DenyAllFromTo a b; v = DenyAllFromTo c d;\n     x \\<in> dom (C (DenyAllFromTo a b));\n     x \\<in> dom (C (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> a = c \\<and> b = d", "by (metis ND0aux1 ND0aux2 domsMT_notND_DD3 domsMT_notND_DD4 )"], ["", "lemma rule_charn1: \n  assumes aND: \"allNetsDistinct p\"\n    and mr_is_allow: \"applied_rule_rev C x p = Some (AllowPortFromTo a b po)\"\n    and SC: \"singleCombinators p\"\n    and inp: \"r \\<in> set p\" \n    and inDom: \"x \\<in> dom (C r)\"\n  shows \"(r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll", "proof (cases r)"], ["proof (state)\ngoal (4 subgoals):\n 1. r = DenyAll \\<Longrightarrow>\n    r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll\n 2. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 3. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 4. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "case DenyAll"], ["proof (state)\nthis:\n  r = DenyAll\n\ngoal (4 subgoals):\n 1. r = DenyAll \\<Longrightarrow>\n    r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll\n 2. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 3. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 4. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll", "by (metis DenyAll)"], ["proof (state)\nthis:\n  r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 2. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 3. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 2. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 3. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "case (DenyAllFromTo x y)"], ["proof (state)\nthis:\n  r = DenyAllFromTo x y\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 2. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 3. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll", "by (metis AD_aux DenyAllFromTo SC aND domInterMT inDom inp mrSet mr_in_dom mr_is_allow)"], ["proof (state)\nthis:\n  r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 2. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 2. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "case (AllowPortFromTo x y b)"], ["proof (state)\nthis:\n  r = AllowPortFromTo x y b\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 2. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll", "by (metis (no_types, lifting) AllowPortFromTo DistinctNetsAllowAllow aND domInterMT \n        inDom inp  mrSet mr_in_dom mr_is_allow)"], ["proof (state)\nthis:\n  r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "case (Conc x y)"], ["proof (state)\nthis:\n  r = x \\<oplus> y\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = x \\<oplus> y\n\ngoal (1 subgoal):\n 1. r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll", "using assms"], ["proof (prove)\nusing this:\n  r = x \\<oplus> y\n  allNetsDistinct p\n  applied_rule_rev C x p = \\<lfloor>AllowPortFromTo a b po\\<rfloor>\n  singleCombinators p\n  r \\<in> set p\n  x \\<in> dom (C r)\n\ngoal (1 subgoal):\n 1. r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll", "by (metis aux0_0)"], ["proof (state)\nthis:\n  r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma none_MT_rulessubset[rule_format]: \n  \"none_MT_rules C a \\<longrightarrow> set b \\<subseteq> set a \\<longrightarrow> none_MT_rules C b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. none_MT_rules C a \\<longrightarrow>\n    set b \\<subseteq> set a \\<longrightarrow> none_MT_rules C b", "by (induct b,simp_all) (metis notMTnMT)"], ["", "lemma nMTSort: \"none_MT_rules C p \\<Longrightarrow> none_MT_rules C (sort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. none_MT_rules C p \\<Longrightarrow>\n    none_MT_rules C (FWNormalisationCore.sort p l)", "by (metis set_sort nMTeqSet)"], ["", "lemma nMTSortQ: \"none_MT_rules C p \\<Longrightarrow> none_MT_rules C (qsort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. none_MT_rules C p \\<Longrightarrow> none_MT_rules C (qsort p l)", "by (metis set_sortQ nMTeqSet)"], ["", "lemma wp3char[rule_format]: \n  \"none_MT_rules C xs \\<and> C (AllowPortFromTo a b po)=\\<emptyset> \\<and> wellformed_policy3(xs@[DenyAllFromTo a b]) \\<longrightarrow>\n AllowPortFromTo a b po \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. none_MT_rules C xs \\<and>\n    C (AllowPortFromTo a b po) = \\<emptyset> \\<and>\n    wellformed_policy3 (xs @ [DenyAllFromTo a b]) \\<longrightarrow>\n    AllowPortFromTo a b po \\<notin> set xs", "apply (induct xs,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       none_MT_rules C xs \\<and>\n       C (AllowPortFromTo a b po) = \\<emptyset> \\<and>\n       wellformed_policy3 (xs @ [DenyAllFromTo a b]) \\<longrightarrow>\n       AllowPortFromTo a b po \\<notin> set xs \\<Longrightarrow>\n       dom (C aa) \\<noteq> {} \\<and>\n       none_MT_rules C xs \\<and>\n       C (AllowPortFromTo a b po) = \\<emptyset> \\<and>\n       wellformed_policy3 (aa # xs @ [DenyAllFromTo a b]) \\<longrightarrow>\n       AllowPortFromTo a b po \\<noteq> aa \\<and>\n       AllowPortFromTo a b po \\<notin> set xs", "by (metis domNMT wp3Conc)"], ["", "lemma wp3charn[rule_format]: \n  assumes domAllow: \"dom (C (AllowPortFromTo a b po)) \\<noteq> {}\" \n    and     wp3:      \"wellformed_policy3 (xs @ [DenyAllFromTo a b])\"\n  shows             \"AllowPortFromTo a b po \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AllowPortFromTo a b po \\<notin> set xs", "apply (insert assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom (C (AllowPortFromTo a b po)) \\<noteq> {};\n     wellformed_policy3 (xs @ [DenyAllFromTo a b])\\<rbrakk>\n    \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>dom (C (AllowPortFromTo a b po)) \\<noteq> {};\n     wellformed_policy3 ([] @ [DenyAllFromTo a b])\\<rbrakk>\n    \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set []\n 2. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>dom (C (AllowPortFromTo a b po)) \\<noteq> {};\n                 wellformed_policy3 (xs @ [DenyAllFromTo a b])\\<rbrakk>\n                \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set xs;\n        dom (C (AllowPortFromTo a b po)) \\<noteq> {};\n        wellformed_policy3 ((aa # xs) @ [DenyAllFromTo a b])\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set (aa # xs)", "case Nil"], ["proof (state)\nthis:\n  dom (C (AllowPortFromTo a b po)) \\<noteq> {}\n  wellformed_policy3 ([] @ [DenyAllFromTo a b])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>dom (C (AllowPortFromTo a b po)) \\<noteq> {};\n     wellformed_policy3 ([] @ [DenyAllFromTo a b])\\<rbrakk>\n    \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set []\n 2. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>dom (C (AllowPortFromTo a b po)) \\<noteq> {};\n                 wellformed_policy3 (xs @ [DenyAllFromTo a b])\\<rbrakk>\n                \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set xs;\n        dom (C (AllowPortFromTo a b po)) \\<noteq> {};\n        wellformed_policy3 ((aa # xs) @ [DenyAllFromTo a b])\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set (aa # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. AllowPortFromTo a b po \\<notin> set []", "by simp"], ["proof (state)\nthis:\n  AllowPortFromTo a b po \\<notin> set []\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>dom (C (AllowPortFromTo a b po)) \\<noteq> {};\n                 wellformed_policy3 (xs @ [DenyAllFromTo a b])\\<rbrakk>\n                \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set xs;\n        dom (C (AllowPortFromTo a b po)) \\<noteq> {};\n        wellformed_policy3 ((aa # xs) @ [DenyAllFromTo a b])\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set (aa # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>dom (C (AllowPortFromTo a b po)) \\<noteq> {};\n                 wellformed_policy3 (xs @ [DenyAllFromTo a b])\\<rbrakk>\n                \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set xs;\n        dom (C (AllowPortFromTo a b po)) \\<noteq> {};\n        wellformed_policy3 ((aa # xs) @ [DenyAllFromTo a b])\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set (aa # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>dom (C (AllowPortFromTo a b po)) \\<noteq> {};\n   wellformed_policy3 (xs @ [DenyAllFromTo a b])\\<rbrakk>\n  \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set xs\n  dom (C (AllowPortFromTo a b po)) \\<noteq> {}\n  wellformed_policy3 ((x # xs) @ [DenyAllFromTo a b])\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>dom (C (AllowPortFromTo a b po)) \\<noteq> {};\n                 wellformed_policy3 (xs @ [DenyAllFromTo a b])\\<rbrakk>\n                \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set xs;\n        dom (C (AllowPortFromTo a b po)) \\<noteq> {};\n        wellformed_policy3 ((aa # xs) @ [DenyAllFromTo a b])\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set (aa # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. AllowPortFromTo a b po \\<notin> set (x # xs)", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>dom (C (AllowPortFromTo a b po)) \\<noteq> {};\n   wellformed_policy3 (xs @ [DenyAllFromTo a b])\\<rbrakk>\n  \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set xs\n  dom (C (AllowPortFromTo a b po)) \\<noteq> {}\n  wellformed_policy3 ((x # xs) @ [DenyAllFromTo a b])\n\ngoal (1 subgoal):\n 1. AllowPortFromTo a b po \\<notin> set (x # xs)", "by (simp,auto intro: wp3Conc) (auto simp: DenyAllowDisj domAllow)"], ["proof (state)\nthis:\n  AllowPortFromTo a b po \\<notin> set (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rule_charn2: \n  assumes aND: \"allNetsDistinct p\"\n    and wp1: \"wellformed_policy1 p\"\n    and SC: \"singleCombinators p\"\n    and wp3: \"wellformed_policy3 p\"\n    and allow_in_list: \"AllowPortFromTo c d po \\<in> set p\"\n    and x_in_dom_allow: \"x \\<in> dom (C (AllowPortFromTo c d po))\"\n  shows  \"applied_rule_rev C x p = Some (AllowPortFromTo c d po)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "proof  (insert assms, induct p rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>allNetsDistinct []; wellformed_policy1 [];\n     singleCombinators []; wellformed_policy3 [];\n     AllowPortFromTo c d po \\<in> set [];\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x [] =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct xs; wellformed_policy1 xs;\n                 singleCombinators xs; wellformed_policy3 xs;\n                 AllowPortFromTo c d po \\<in> set xs;\n                 x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev C x xs =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (xs @ [xa]); wellformed_policy1 (xs @ [xa]);\n        singleCombinators (xs @ [xa]); wellformed_policy3 (xs @ [xa]);\n        AllowPortFromTo c d po \\<in> set (xs @ [xa]);\n        x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (xs @ [xa]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "case Nil"], ["proof (state)\nthis:\n  allNetsDistinct []\n  wellformed_policy1 []\n  singleCombinators []\n  wellformed_policy3 []\n  AllowPortFromTo c d po \\<in> set []\n  x \\<in> dom (C (AllowPortFromTo c d po))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>allNetsDistinct []; wellformed_policy1 [];\n     singleCombinators []; wellformed_policy3 [];\n     AllowPortFromTo c d po \\<in> set [];\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x [] =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct xs; wellformed_policy1 xs;\n                 singleCombinators xs; wellformed_policy3 xs;\n                 AllowPortFromTo c d po \\<in> set xs;\n                 x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev C x xs =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (xs @ [xa]); wellformed_policy1 (xs @ [xa]);\n        singleCombinators (xs @ [xa]); wellformed_policy3 (xs @ [xa]);\n        AllowPortFromTo c d po \\<in> set (xs @ [xa]);\n        x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (xs @ [xa]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x [] = \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "using Nil"], ["proof (prove)\nusing this:\n  allNetsDistinct []\n  wellformed_policy1 []\n  singleCombinators []\n  wellformed_policy3 []\n  AllowPortFromTo c d po \\<in> set []\n  x \\<in> dom (C (AllowPortFromTo c d po))\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x [] = \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  applied_rule_rev C x [] = \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct xs; wellformed_policy1 xs;\n                 singleCombinators xs; wellformed_policy3 xs;\n                 AllowPortFromTo c d po \\<in> set xs;\n                 x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev C x xs =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (xs @ [xa]); wellformed_policy1 (xs @ [xa]);\n        singleCombinators (xs @ [xa]); wellformed_policy3 (xs @ [xa]);\n        AllowPortFromTo c d po \\<in> set (xs @ [xa]);\n        x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (xs @ [xa]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct xs; wellformed_policy1 xs;\n                 singleCombinators xs; wellformed_policy3 xs;\n                 AllowPortFromTo c d po \\<in> set xs;\n                 x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev C x xs =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (xs @ [xa]); wellformed_policy1 (xs @ [xa]);\n        singleCombinators (xs @ [xa]); wellformed_policy3 (xs @ [xa]);\n        AllowPortFromTo c d po \\<in> set (xs @ [xa]);\n        x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (xs @ [xa]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "case (snoc y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys; singleCombinators ys;\n   wellformed_policy3 ys; AllowPortFromTo c d po \\<in> set ys;\n   x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n  \\<Longrightarrow> applied_rule_rev C x ys =\n                    \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n  allNetsDistinct (ys @ [y])\n  wellformed_policy1 (ys @ [y])\n  singleCombinators (ys @ [y])\n  wellformed_policy3 (ys @ [y])\n  AllowPortFromTo c d po \\<in> set (ys @ [y])\n  x \\<in> dom (C (AllowPortFromTo c d po))\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct xs; wellformed_policy1 xs;\n                 singleCombinators xs; wellformed_policy3 xs;\n                 AllowPortFromTo c d po \\<in> set xs;\n                 x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev C x xs =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (xs @ [xa]); wellformed_policy1 (xs @ [xa]);\n        singleCombinators (xs @ [xa]); wellformed_policy3 (xs @ [xa]);\n        AllowPortFromTo c d po \\<in> set (xs @ [xa]);\n        x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (xs @ [xa]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "using snoc"], ["proof (prove)\nusing this:\n  \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys; singleCombinators ys;\n   wellformed_policy3 ys; AllowPortFromTo c d po \\<in> set ys;\n   x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n  \\<Longrightarrow> applied_rule_rev C x ys =\n                    \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n  allNetsDistinct (ys @ [y])\n  wellformed_policy1 (ys @ [y])\n  singleCombinators (ys @ [y])\n  wellformed_policy3 (ys @ [y])\n  AllowPortFromTo c d po \\<in> set (ys @ [y])\n  x \\<in> dom (C (AllowPortFromTo c d po))\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (case_tac \"y = (AllowPortFromTo c d po)\", simp_all )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>allNetsDistinct (ys @ [AllowPortFromTo c d po]);\n     wellformed_policy1 (ys @ [AllowPortFromTo c d po]);\n     singleCombinators (ys @ [AllowPortFromTo c d po]);\n     wellformed_policy3 (ys @ [AllowPortFromTo c d po]);\n     y = AllowPortFromTo c d po;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys;\n      AllowPortFromTo c d po \\<in> set ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (ys @ [AllowPortFromTo c d po]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n     y \\<noteq> AllowPortFromTo c d po;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (simp add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n     y \\<noteq> AllowPortFromTo c d po;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (subgoal_tac \"ys \\<noteq> []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n     y \\<noteq> AllowPortFromTo c d po;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n     x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n     y \\<noteq> AllowPortFromTo c d po;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> ys \\<noteq> []", "apply (subgoal_tac \"applied_rule_rev C x ys = Some (AllowPortFromTo c d po)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n     y \\<noteq> AllowPortFromTo c d po;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n     x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n     applied_rule_rev C x ys =\n     \\<lfloor>AllowPortFromTo c d po\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n     y \\<noteq> AllowPortFromTo c d po;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n     x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x ys =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 3. \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n     y \\<noteq> AllowPortFromTo c d po;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> ys \\<noteq> []", "defer 1"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n     y \\<noteq> AllowPortFromTo c d po;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n     x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x ys =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n     y \\<noteq> AllowPortFromTo c d po;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> ys \\<noteq> []\n 3. \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n     y \\<noteq> AllowPortFromTo c d po;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n     x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n     applied_rule_rev C x ys =\n     \\<lfloor>AllowPortFromTo c d po\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (metis ANDConcEnd SCConcEnd WP1ConcEnd foo25)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n     y \\<noteq> AllowPortFromTo c d po;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> ys \\<noteq> []\n 2. \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n     y \\<noteq> AllowPortFromTo c d po;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n     x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n     applied_rule_rev C x ys =\n     \\<lfloor>AllowPortFromTo c d po\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (metis inSet_not_MT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n     y \\<noteq> AllowPortFromTo c d po;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n     x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n     applied_rule_rev C x ys =\n     \\<lfloor>AllowPortFromTo c d po\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "proof (cases y)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n     y \\<noteq> AllowPortFromTo c d po;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n     x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n     applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>x21 x22.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 4. \\<And>x41 x42.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "case DenyAll"], ["proof (state)\nthis:\n  y = DenyAll\n\ngoal (4 subgoals):\n 1. \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n     y \\<noteq> AllowPortFromTo c d po;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n     x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n     applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>x21 x22.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 4. \\<And>x41 x42.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = DenyAll\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "using DenyAll snoc"], ["proof (prove)\nusing this:\n  y = DenyAll\n  y = DenyAll\n  \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys; singleCombinators ys;\n   wellformed_policy3 ys; AllowPortFromTo c d po \\<in> set ys;\n   x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n  \\<Longrightarrow> applied_rule_rev C x ys =\n                    \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n  allNetsDistinct (ys @ [y])\n  wellformed_policy1 (ys @ [y])\n  singleCombinators (ys @ [y])\n  wellformed_policy3 (ys @ [y])\n  AllowPortFromTo c d po \\<in> set (ys @ [y])\n  x \\<in> dom (C (AllowPortFromTo c d po))\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAll;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [DenyAll]); wellformed_policy1 (ys @ [DenyAll]);\n     singleCombinators (ys @ [DenyAll]);\n     wellformed_policy3 (ys @ [DenyAll]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (ys @ [DenyAll]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "by (metis DAnotTL DenyAll inSet_not_MT policy2list.simps(2))"], ["proof (state)\nthis:\n  applied_rule_rev C x (ys @ [y]) = \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 3. \\<And>x41 x42.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 3. \\<And>x41 x42.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "case (DenyAllFromTo a b)"], ["proof (state)\nthis:\n  y = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 3. \\<And>x41 x42.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "using snoc"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n  \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys; singleCombinators ys;\n   wellformed_policy3 ys; AllowPortFromTo c d po \\<in> set ys;\n   x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n  \\<Longrightarrow> applied_rule_rev C x ys =\n                    \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n  allNetsDistinct (ys @ [y])\n  wellformed_policy1 (ys @ [y])\n  singleCombinators (ys @ [y])\n  wellformed_policy3 (ys @ [y])\n  AllowPortFromTo c d po \\<in> set (ys @ [y])\n  x \\<in> dom (C (AllowPortFromTo c d po))\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [DenyAllFromTo a b]);\n     wellformed_policy1 (ys @ [DenyAllFromTo a b]);\n     singleCombinators (ys @ [DenyAllFromTo a b]);\n     wellformed_policy3 (ys @ [DenyAllFromTo a b]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (ys @ [DenyAllFromTo a b]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (simp_all add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule C x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [DenyAllFromTo a b]);\n     wellformed_policy1 (ys @ [DenyAllFromTo a b]);\n     singleCombinators (ys @ [DenyAllFromTo a b]);\n     wellformed_policy3 (ys @ [DenyAllFromTo a b]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (DenyAllFromTo a b)) \\<and>\n                      (x \\<notin> dom (C\n  (DenyAllFromTo a b)) \\<longrightarrow>\n                       applied_rule C x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule C x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [DenyAllFromTo a b]);\n     wellformed_policy1 (ys @ [DenyAllFromTo a b]);\n     singleCombinators (ys @ [DenyAllFromTo a b]);\n     wellformed_policy3 (ys @ [DenyAllFromTo a b]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (DenyAllFromTo a b))\n 2. \\<lbrakk>y = DenyAllFromTo a b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule C x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [DenyAllFromTo a b]);\n     wellformed_policy1 (ys @ [DenyAllFromTo a b]);\n     singleCombinators (ys @ [DenyAllFromTo a b]);\n     wellformed_policy3 (ys @ [DenyAllFromTo a b]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C\n (DenyAllFromTo a b)) \\<longrightarrow>\n                      applied_rule C x (rev ys) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (metis domInterMT  wp3EndMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule C x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [DenyAllFromTo a b]);\n     wellformed_policy1 (ys @ [DenyAllFromTo a b]);\n     singleCombinators (ys @ [DenyAllFromTo a b]);\n     wellformed_policy3 (ys @ [DenyAllFromTo a b]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C\n (DenyAllFromTo a b)) \\<longrightarrow>\n                      applied_rule C x (rev ys) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule C x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [DenyAllFromTo a b]);\n     wellformed_policy1 (ys @ [DenyAllFromTo a b]);\n     singleCombinators (ys @ [DenyAllFromTo a b]);\n     wellformed_policy3 (ys @ [DenyAllFromTo a b]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (C (AllowPortFromTo c d po));\n     x \\<notin> dom (C (DenyAllFromTo a b))\\<rbrakk>\n    \\<Longrightarrow> applied_rule C x (rev ys) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "by (metis ANDConcEnd DenyAllFromTo SCConcEnd WP1ConcEnd foo25)"], ["proof (state)\nthis:\n  applied_rule_rev C x (ys @ [y]) = \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>x41 x42.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>x41 x42.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "case (AllowPortFromTo a1 a2 b)"], ["proof (state)\nthis:\n  y = AllowPortFromTo a1 a2 b\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>x41 x42.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a1 a2 b\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "using AllowPortFromTo snoc"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a1 a2 b\n  y = AllowPortFromTo a1 a2 b\n  \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys; singleCombinators ys;\n   wellformed_policy3 ys; AllowPortFromTo c d po \\<in> set ys;\n   x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n  \\<Longrightarrow> applied_rule_rev C x ys =\n                    \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n  allNetsDistinct (ys @ [y])\n  wellformed_policy1 (ys @ [y])\n  singleCombinators (ys @ [y])\n  wellformed_policy3 (ys @ [y])\n  AllowPortFromTo c d po \\<in> set (ys @ [y])\n  x \\<in> dom (C (AllowPortFromTo c d po))\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a1 a2 b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys;\n      AllowPortFromTo c d po \\<in> set ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy1 (ys @ [AllowPortFromTo a1 a2 b]);\n     singleCombinators (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy3 (ys @ [AllowPortFromTo a1 a2 b]);\n     c = a1 \\<and> d = a2 \\<and> po = b \\<or>\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x\n                       (ys @ [AllowPortFromTo a1 a2 b]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (simp_all add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a1 a2 b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys;\n      AllowPortFromTo c d po \\<in> set ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule C x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy1 (ys @ [AllowPortFromTo a1 a2 b]);\n     singleCombinators (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy3 (ys @ [AllowPortFromTo a1 a2 b]);\n     c = a1 \\<and> d = a2 \\<and> po = b \\<or>\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> dom (C (AllowPortFromTo a1 a2\n  b)) \\<longrightarrow>\n                       a1 = c \\<and> a2 = d \\<and> b = po) \\<and>\n                      (x \\<notin> dom (C\n  (AllowPortFromTo a1 a2 b)) \\<longrightarrow>\n                       applied_rule C x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a1 a2 b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys;\n      AllowPortFromTo c d po \\<in> set ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule C x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy1 (ys @ [AllowPortFromTo a1 a2 b]);\n     singleCombinators (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy3 (ys @ [AllowPortFromTo a1 a2 b]);\n     c = a1 \\<and> d = a2 \\<and> po = b \\<or>\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (AllowPortFromTo a1 a2\n b)) \\<longrightarrow>\n                      a1 = c \\<and> a2 = d \\<and> b = po\n 2. \\<lbrakk>y = AllowPortFromTo a1 a2 b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys;\n      AllowPortFromTo c d po \\<in> set ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule C x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy1 (ys @ [AllowPortFromTo a1 a2 b]);\n     singleCombinators (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy3 (ys @ [AllowPortFromTo a1 a2 b]);\n     c = a1 \\<and> d = a2 \\<and> po = b \\<or>\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C\n (AllowPortFromTo a1 a2 b)) \\<longrightarrow>\n                      applied_rule C x (rev ys) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (metis domInterMT  wp3EndMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a1 a2 b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys;\n      AllowPortFromTo c d po \\<in> set ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule C x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy1 (ys @ [AllowPortFromTo a1 a2 b]);\n     singleCombinators (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy3 (ys @ [AllowPortFromTo a1 a2 b]);\n     c = a1 \\<and> d = a2 \\<and> po = b \\<or>\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C\n (AllowPortFromTo a1 a2 b)) \\<longrightarrow>\n                      applied_rule C x (rev ys) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "by (metis ANDConcEnd AllowPortFromTo SCConcEnd WP1ConcEnd foo25 x_in_dom_allow)"], ["proof (state)\nthis:\n  applied_rule_rev C x (ys @ [y]) = \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "case (Conc a b)"], ["proof (state)\nthis:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>AllowPortFromTo c d po \\<in> set ys;\n        y \\<noteq> AllowPortFromTo c d po;\n        \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n         singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n        \\<Longrightarrow> applied_rule_rev C x ys =\n                          \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3 (ys @ [y]);\n        x \\<in> dom (C (AllowPortFromTo c d po)); ys \\<noteq> [];\n        applied_rule_rev C x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "using Conc snoc"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n  y = a \\<oplus> b\n  \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys; singleCombinators ys;\n   wellformed_policy3 ys; AllowPortFromTo c d po \\<in> set ys;\n   x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n  \\<Longrightarrow> applied_rule_rev C x ys =\n                    \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n  allNetsDistinct (ys @ [y])\n  wellformed_policy1 (ys @ [y])\n  singleCombinators (ys @ [y])\n  wellformed_policy3 (ys @ [y])\n  AllowPortFromTo c d po \\<in> set (ys @ [y])\n  x \\<in> dom (C (AllowPortFromTo c d po))\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3 ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev C x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [a \\<oplus> b]);\n     wellformed_policy1 (ys @ [a \\<oplus> b]);\n     singleCombinators (ys @ [a \\<oplus> b]);\n     wellformed_policy3 (ys @ [a \\<oplus> b]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (C (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (ys @ [a \\<oplus> b]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "by (metis Conc aux0_0 in_set_conv_decomp)"], ["proof (state)\nthis:\n  applied_rule_rev C x (ys @ [y]) = \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  applied_rule_rev C x (ys @ [y]) = \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rule_charn3: \n  \" wellformed_policy1 p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> singleCombinators p \\<Longrightarrow>\n   wellformed_policy3 p \\<Longrightarrow> applied_rule_rev C x p = \\<lfloor>DenyAllFromTo c d\\<rfloor> \\<Longrightarrow> \n   AllowPortFromTo a b po \\<in> set p \\<Longrightarrow> x \\<notin> dom (C (AllowPortFromTo a b po))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1 p; allNetsDistinct p; singleCombinators p;\n     wellformed_policy3 p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo c d\\<rfloor>;\n     AllowPortFromTo a b po \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (AllowPortFromTo a b po))", "by (clarify, auto simp: rule_charn2 dom_def)"], ["", "lemma rule_charn4: \n  assumes wp1: \"wellformed_policy1 p\" \n    and aND: \"allNetsDistinct p\" \n    and SC: \"singleCombinators p\"\n    and wp3: \"wellformed_policy3 p\"  \n    and DA: \"DenyAll \\<notin> set p\" \n    and mr: \"applied_rule_rev C x p = Some (DenyAllFromTo a b)\"\n    and rinp: \"r \\<in> set p\"\n    and xindom: \"x \\<in> dom (C r)\"\n  shows \"r = DenyAllFromTo a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "proof (cases r)"], ["proof (state)\ngoal (4 subgoals):\n 1. r = DenyAll \\<Longrightarrow> r = DenyAllFromTo a b\n 2. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow> r = DenyAllFromTo a b\n 3. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = DenyAllFromTo a b\n 4. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "case DenyAll"], ["proof (state)\nthis:\n  r = DenyAll\n\ngoal (4 subgoals):\n 1. r = DenyAll \\<Longrightarrow> r = DenyAllFromTo a b\n 2. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow> r = DenyAllFromTo a b\n 3. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = DenyAllFromTo a b\n 4. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = DenyAll\n\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "using DenyAll assms"], ["proof (prove)\nusing this:\n  r = DenyAll\n  r = DenyAll\n  wellformed_policy1 p\n  allNetsDistinct p\n  singleCombinators p\n  wellformed_policy3 p\n  DenyAll \\<notin> set p\n  applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n  r \\<in> set p\n  x \\<in> dom (C r)\n\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "by simp"], ["proof (state)\nthis:\n  r = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow> r = DenyAllFromTo a b\n 2. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = DenyAllFromTo a b\n 3. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow> r = DenyAllFromTo a b\n 2. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = DenyAllFromTo a b\n 3. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "case (DenyAllFromTo c d)"], ["proof (state)\nthis:\n  r = DenyAllFromTo c d\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow> r = DenyAllFromTo a b\n 2. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = DenyAllFromTo a b\n 3. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = DenyAllFromTo c d\n\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "using assms"], ["proof (prove)\nusing this:\n  r = DenyAllFromTo c d\n  wellformed_policy1 p\n  allNetsDistinct p\n  singleCombinators p\n  wellformed_policy3 p\n  DenyAll \\<notin> set p\n  applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n  r \\<in> set p\n  x \\<in> dom (C r)\n\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = DenyAllFromTo c d; wellformed_policy1 p; allNetsDistinct p;\n     singleCombinators p; wellformed_policy3 p; DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     DenyAllFromTo c d \\<in> set p;\n     x \\<in> dom (C (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> c = a \\<and> d = b", "apply (erule_tac x = x and p = p and v = \"(DenyAllFromTo a b)\" and\n        u = \"(DenyAllFromTo c d)\"  in NetsEq_if_sameP_DD)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>r = DenyAllFromTo c d; wellformed_policy1 p;\n     singleCombinators p; wellformed_policy3 p; DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     DenyAllFromTo c d \\<in> set p;\n     x \\<in> dom (C (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> DenyAllFromTo c d \\<in> set p\n 2. \\<lbrakk>r = DenyAllFromTo c d; wellformed_policy1 p;\n     singleCombinators p; wellformed_policy3 p; DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     DenyAllFromTo c d \\<in> set p;\n     x \\<in> dom (C (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> DenyAllFromTo a b \\<in> set p\n 3. \\<lbrakk>r = DenyAllFromTo c d; wellformed_policy1 p;\n     singleCombinators p; wellformed_policy3 p; DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     DenyAllFromTo c d \\<in> set p;\n     x \\<in> dom (C (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> DenyAllFromTo c d = DenyAllFromTo c d\n 4. \\<lbrakk>r = DenyAllFromTo c d; wellformed_policy1 p;\n     singleCombinators p; wellformed_policy3 p; DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     DenyAllFromTo c d \\<in> set p;\n     x \\<in> dom (C (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> DenyAllFromTo a b = DenyAllFromTo a b\n 5. \\<lbrakk>r = DenyAllFromTo c d; wellformed_policy1 p;\n     singleCombinators p; wellformed_policy3 p; DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     DenyAllFromTo c d \\<in> set p;\n     x \\<in> dom (C (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo c d))\n 6. \\<lbrakk>r = DenyAllFromTo c d; wellformed_policy1 p;\n     singleCombinators p; wellformed_policy3 p; DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     DenyAllFromTo c d \\<in> set p;\n     x \\<in> dom (C (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo a b))", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = DenyAllFromTo c d; wellformed_policy1 p;\n     singleCombinators p; wellformed_policy3 p; DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     DenyAllFromTo c d \\<in> set p;\n     x \\<in> dom (C (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> DenyAllFromTo a b \\<in> set p\n 2. \\<lbrakk>r = DenyAllFromTo c d; wellformed_policy1 p;\n     singleCombinators p; wellformed_policy3 p; DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     DenyAllFromTo c d \\<in> set p;\n     x \\<in> dom (C (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo a b))", "apply (erule mrSet)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = DenyAllFromTo c d; wellformed_policy1 p;\n     singleCombinators p; wellformed_policy3 p; DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     DenyAllFromTo c d \\<in> set p;\n     x \\<in> dom (C (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo a b))", "by (erule mr_in_dom)"], ["proof (state)\nthis:\n  r = DenyAllFromTo a b\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = DenyAllFromTo a b\n 2. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = DenyAllFromTo a b\n 2. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "case (AllowPortFromTo c d e)"], ["proof (state)\nthis:\n  r = AllowPortFromTo c d e\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = DenyAllFromTo a b\n 2. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = AllowPortFromTo c d e\n\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "using assms"], ["proof (prove)\nusing this:\n  r = AllowPortFromTo c d e\n  wellformed_policy1 p\n  allNetsDistinct p\n  singleCombinators p\n  wellformed_policy3 p\n  DenyAll \\<notin> set p\n  applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n  r \\<in> set p\n  x \\<in> dom (C r)\n\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = AllowPortFromTo c d e; wellformed_policy1 p;\n     allNetsDistinct p; singleCombinators p; wellformed_policy3 p;\n     DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     AllowPortFromTo c d e \\<in> set p;\n     x \\<in> dom (C (AllowPortFromTo c d e))\\<rbrakk>\n    \\<Longrightarrow> False", "apply (subgoal_tac \"x \\<notin> dom (C  (AllowPortFromTo c d e))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = AllowPortFromTo c d e; wellformed_policy1 p;\n     allNetsDistinct p; singleCombinators p; wellformed_policy3 p;\n     DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     AllowPortFromTo c d e \\<in> set p;\n     x \\<in> dom (C (AllowPortFromTo c d e));\n     x \\<notin> dom (C (AllowPortFromTo c d e))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>r = AllowPortFromTo c d e; wellformed_policy1 p;\n     allNetsDistinct p; singleCombinators p; wellformed_policy3 p;\n     DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     AllowPortFromTo c d e \\<in> set p;\n     x \\<in> dom (C (AllowPortFromTo c d e))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (AllowPortFromTo c d e))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = AllowPortFromTo c d e; wellformed_policy1 p;\n     allNetsDistinct p; singleCombinators p; wellformed_policy3 p;\n     DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     AllowPortFromTo c d e \\<in> set p;\n     x \\<in> dom (C (AllowPortFromTo c d e))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (AllowPortFromTo c d e))", "apply (rule_tac p = p in rule_charn3)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>r = AllowPortFromTo c d e; wellformed_policy1 p;\n     allNetsDistinct p; singleCombinators p; wellformed_policy3 p;\n     DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     AllowPortFromTo c d e \\<in> set p;\n     x \\<in> dom (C (AllowPortFromTo c d e))\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 p\n 2. \\<lbrakk>r = AllowPortFromTo c d e; wellformed_policy1 p;\n     allNetsDistinct p; singleCombinators p; wellformed_policy3 p;\n     DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     AllowPortFromTo c d e \\<in> set p;\n     x \\<in> dom (C (AllowPortFromTo c d e))\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct p\n 3. \\<lbrakk>r = AllowPortFromTo c d e; wellformed_policy1 p;\n     allNetsDistinct p; singleCombinators p; wellformed_policy3 p;\n     DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     AllowPortFromTo c d e \\<in> set p;\n     x \\<in> dom (C (AllowPortFromTo c d e))\\<rbrakk>\n    \\<Longrightarrow> singleCombinators p\n 4. \\<lbrakk>r = AllowPortFromTo c d e; wellformed_policy1 p;\n     allNetsDistinct p; singleCombinators p; wellformed_policy3 p;\n     DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     AllowPortFromTo c d e \\<in> set p;\n     x \\<in> dom (C (AllowPortFromTo c d e))\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy3 p\n 5. \\<lbrakk>r = AllowPortFromTo c d e; wellformed_policy1 p;\n     allNetsDistinct p; singleCombinators p; wellformed_policy3 p;\n     DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     AllowPortFromTo c d e \\<in> set p;\n     x \\<in> dom (C (AllowPortFromTo c d e))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x p =\n                      \\<lfloor>DenyAllFromTo ?c10 ?d10\\<rfloor>\n 6. \\<lbrakk>r = AllowPortFromTo c d e; wellformed_policy1 p;\n     allNetsDistinct p; singleCombinators p; wellformed_policy3 p;\n     DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     AllowPortFromTo c d e \\<in> set p;\n     x \\<in> dom (C (AllowPortFromTo c d e))\\<rbrakk>\n    \\<Longrightarrow> AllowPortFromTo c d e \\<in> set p", "by (auto intro: SCnotConc)"], ["proof (state)\nthis:\n  r = DenyAllFromTo a b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "case (Conc a b)"], ["proof (state)\nthis:\n  r = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "using assms"], ["proof (prove)\nusing this:\n  r = a \\<oplus> b\n  wellformed_policy1 p\n  allNetsDistinct p\n  singleCombinators p\n  wellformed_policy3 p\n  DenyAll \\<notin> set p\n  applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n  r \\<in> set p\n  x \\<in> dom (C r)\n\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = a \\<oplus> b; wellformed_policy1 p; allNetsDistinct p;\n     singleCombinators p; wellformed_policy3 p; DenyAll \\<notin> set p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     a \\<oplus> b \\<in> set p; x \\<in> dom (C (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis Conc aux0_0)"], ["proof (state)\nthis:\n  r = DenyAllFromTo a b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foo31a: \n  \"\\<forall>r. r \\<in> set p \\<and> x \\<in> dom (C r) \\<longrightarrow> r=AllowPortFromTo a b po \\<or> r=DenyAllFromTo a b \\<or> r=DenyAll \\<Longrightarrow>\n    set p = set s \\<Longrightarrow> r \\<in> set s \\<Longrightarrow> x \\<in> dom (C r) \\<Longrightarrow> \n   r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>r.\n                r \\<in> set p \\<and> x \\<in> dom (C r) \\<longrightarrow>\n                r = AllowPortFromTo a b po \\<or>\n                r = DenyAllFromTo a b \\<or> r = DenyAll;\n     set p = set s; r \\<in> set s; x \\<in> dom (C r)\\<rbrakk>\n    \\<Longrightarrow> r = AllowPortFromTo a b po \\<or>\n                      r = DenyAllFromTo a b \\<or> r = DenyAll", "by auto"], ["", "lemma aux4[rule_format]: \n  \"applied_rule_rev C x (a#p) = Some a \\<longrightarrow> a \\<notin> set (p) \\<longrightarrow> applied_rule_rev C x p = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x (a # p) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    a \\<notin> set p \\<longrightarrow> applied_rule_rev C x p = \\<bottom>", "apply (rule rev_induct,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       applied_rule_rev C x (a # xs) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       a \\<notin> set xs \\<longrightarrow>\n       applied_rule_rev C x xs = \\<bottom> \\<Longrightarrow>\n       applied_rule_rev C x (a # xs @ [xa]) =\n       \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       a \\<noteq> xa \\<and> a \\<notin> set xs \\<longrightarrow>\n       applied_rule_rev C x (xs @ [xa]) = \\<bottom>", "by (metis aux0_4 empty_iff empty_set insert_iff list.simps(15) mrSet mreq_end3)"], ["", "lemma mrDA_tl: \n  assumes mr_DA: \"applied_rule_rev C x p = Some DenyAll\"\n    and     wp1n:  \"wellformed_policy1_strong p\"\n  shows          \"applied_rule_rev C x (tl p) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x (tl p) = \\<bottom>", "apply (rule aux4 [where a = DenyAll])"], ["proof (prove)\ngoal (2 subgoals):\n 1. applied_rule_rev C x (DenyAll # tl p) = \\<lfloor>DenyAll\\<rfloor>\n 2. DenyAll \\<notin> set (tl p)", "apply (metis wp1n_tl mr_DA wp1n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<notin> set (tl p)", "by (metis WP1n_DA_notinSet wp1n)"], ["", "lemma rule_charnDAFT: \n  \"wellformed_policy1_strong p \\<Longrightarrow>  allNetsDistinct p \\<Longrightarrow>  singleCombinators p \\<Longrightarrow>\n    wellformed_policy3 p \\<Longrightarrow> applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor> \\<Longrightarrow> r \\<in> set (tl p) \\<Longrightarrow> \n    x \\<in> dom (C r) \\<Longrightarrow> r = DenyAllFromTo a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1_strong p; allNetsDistinct p;\n     singleCombinators p; wellformed_policy3 p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     r \\<in> set (tl p); x \\<in> dom (C r)\\<rbrakk>\n    \\<Longrightarrow> r = DenyAllFromTo a b", "apply (subgoal_tac \"p = DenyAll#(tl p)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wellformed_policy1_strong p; allNetsDistinct p;\n     singleCombinators p; wellformed_policy3 p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     r \\<in> set (tl p); x \\<in> dom (C r); p = DenyAll # tl p\\<rbrakk>\n    \\<Longrightarrow> r = DenyAllFromTo a b\n 2. \\<lbrakk>wellformed_policy1_strong p; allNetsDistinct p;\n     singleCombinators p; wellformed_policy3 p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     r \\<in> set (tl p); x \\<in> dom (C r)\\<rbrakk>\n    \\<Longrightarrow> p = DenyAll # tl p", "apply (metis AND_tl Combinators.distinct(1) SC_tl list.sel(3) mrConcEnd rule_charn4 waux2 wellformed_policy1_charn wp1_aux1aa wp1_eq wp3tl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1_strong p; allNetsDistinct p;\n     singleCombinators p; wellformed_policy3 p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     r \\<in> set (tl p); x \\<in> dom (C r)\\<rbrakk>\n    \\<Longrightarrow> p = DenyAll # tl p", "using wp1n_tl"], ["proof (prove)\nusing this:\n  wellformed_policy1_strong ?p \\<Longrightarrow> ?p = DenyAll # tl ?p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1_strong p; allNetsDistinct p;\n     singleCombinators p; wellformed_policy3 p;\n     applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     r \\<in> set (tl p); x \\<in> dom (C r)\\<rbrakk>\n    \\<Longrightarrow> p = DenyAll # tl p", "by blast"], ["", "lemma mrDenyAll_is_unique: \n  \"\\<lbrakk>wellformed_policy1_strong p; applied_rule_rev C x p = Some DenyAll;\n   r \\<in> set (tl p)\\<rbrakk> \\<Longrightarrow> x \\<notin> dom (C r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1_strong p;\n     applied_rule_rev C x p = \\<lfloor>DenyAll\\<rfloor>;\n     r \\<in> set (tl p)\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C r)", "apply (rule_tac a = \"[]\" and b = \"DenyAll\" and c = \"tl p\"  in foo3a, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wellformed_policy1_strong p;\n     applied_rule_rev C x p = \\<lfloor>DenyAll\\<rfloor>;\n     r \\<in> set (tl p)\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (DenyAll # tl p) =\n                      \\<lfloor>DenyAll\\<rfloor>\n 2. \\<lbrakk>wellformed_policy1_strong p;\n     applied_rule_rev C x p = \\<lfloor>DenyAll\\<rfloor>;\n     r \\<in> set (tl p)\\<rbrakk>\n    \\<Longrightarrow> DenyAll \\<notin> set (tl p)", "apply (metis wp1n_tl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1_strong p;\n     applied_rule_rev C x p = \\<lfloor>DenyAll\\<rfloor>;\n     r \\<in> set (tl p)\\<rbrakk>\n    \\<Longrightarrow> DenyAll \\<notin> set (tl p)", "by (metis WP1n_DA_notinSet)"], ["", "theorem  C_eq_Sets_mr: \n  assumes sets_eq: \"set p = set s\"\n    and SC:          \"singleCombinators p\"\n    and wp1_p:       \"wellformed_policy1_strong p\"\n    and wp1_s:       \"wellformed_policy1_strong s\"\n    and wp3_p:       \"wellformed_policy3 p\"       \n    and wp3_s:       \"wellformed_policy3 s\"  \n    and aND:         \"allNetsDistinct p\"        \n  shows \"applied_rule_rev C x p = applied_rule_rev C x s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = applied_rule_rev C x s", "proof (cases \"applied_rule_rev C x p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. applied_rule_rev C x p = \\<bottom> \\<Longrightarrow>\n    applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>a.\n       applied_rule_rev C x p = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       applied_rule_rev C x p = applied_rule_rev C x s", "case None"], ["proof (state)\nthis:\n  applied_rule_rev C x p = \\<bottom>\n\ngoal (2 subgoals):\n 1. applied_rule_rev C x p = \\<bottom> \\<Longrightarrow>\n    applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>a.\n       applied_rule_rev C x p = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       applied_rule_rev C x p = applied_rule_rev C x s", "have DA: \"DenyAll \\<in> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set p", "using wp1_p"], ["proof (prove)\nusing this:\n  wellformed_policy1_strong p\n\ngoal (1 subgoal):\n 1. DenyAll \\<in> set p", "by (auto simp: wp1_aux1aa)"], ["proof (state)\nthis:\n  DenyAll \\<in> set p\n\ngoal (2 subgoals):\n 1. applied_rule_rev C x p = \\<bottom> \\<Longrightarrow>\n    applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>a.\n       applied_rule_rev C x p = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       applied_rule_rev C x p = applied_rule_rev C x s", "have notDA: \"DenyAll \\<notin> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<notin> set p", "using None"], ["proof (prove)\nusing this:\n  applied_rule_rev C x p = \\<bottom>\n\ngoal (1 subgoal):\n 1. DenyAll \\<notin> set p", "by (auto simp: DAimplieMR)"], ["proof (state)\nthis:\n  DenyAll \\<notin> set p\n\ngoal (2 subgoals):\n 1. applied_rule_rev C x p = \\<bottom> \\<Longrightarrow>\n    applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>a.\n       applied_rule_rev C x p = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       applied_rule_rev C x p = applied_rule_rev C x s", "thus ?thesis"], ["proof (prove)\nusing this:\n  DenyAll \\<notin> set p\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = applied_rule_rev C x s", "using DA"], ["proof (prove)\nusing this:\n  DenyAll \\<notin> set p\n  DenyAll \\<in> set p\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = applied_rule_rev C x s", "by (contradiction)"], ["proof (state)\nthis:\n  applied_rule_rev C x p = applied_rule_rev C x s\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       applied_rule_rev C x p = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       applied_rule_rev C x p = applied_rule_rev C x s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       applied_rule_rev C x p = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       applied_rule_rev C x p = applied_rule_rev C x s", "case (Some y)"], ["proof (state)\nthis:\n  applied_rule_rev C x p = \\<lfloor>y\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       applied_rule_rev C x p = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       applied_rule_rev C x p = applied_rule_rev C x s", "thus ?thesis"], ["proof (prove)\nusing this:\n  applied_rule_rev C x p = \\<lfloor>y\\<rfloor>\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = applied_rule_rev C x s", "proof (cases y)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "have tl_p: \"p = DenyAll#(tl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = DenyAll # tl p", "by (metis wp1_p wp1n_tl)"], ["proof (state)\nthis:\n  p = DenyAll # tl p\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "have tl_s: \"s = DenyAll#(tl s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = DenyAll # tl s", "by (metis wp1_s wp1n_tl)"], ["proof (state)\nthis:\n  s = DenyAll # tl s\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "have tl_eq: \"set (tl p) = set (tl s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (tl p) = set (tl s)", "by (metis list.sel(3) WP1n_DA_notinSet sets_eq foo2\n          wellformed_policy1_charn wp1_aux1aa wp1_eq wp1_p wp1_s)"], ["proof (state)\nthis:\n  set (tl p) = set (tl s)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "{"], ["proof (state)\nthis:\n  set (tl p) = set (tl s)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "case DenyAll"], ["proof (state)\nthis:\n  y = DenyAll\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "have mr_p_is_DenyAll: \"applied_rule_rev C x p = Some DenyAll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = \\<lfloor>DenyAll\\<rfloor>", "by (simp add: DenyAll Some)"], ["proof (state)\nthis:\n  applied_rule_rev C x p = \\<lfloor>DenyAll\\<rfloor>\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "hence x_notin_tl_p: \"\\<forall> r. r \\<in> set (tl p) \\<longrightarrow>  x \\<notin> dom (C r)\""], ["proof (prove)\nusing this:\n  applied_rule_rev C x p = \\<lfloor>DenyAll\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>r. r \\<in> set (tl p) \\<longrightarrow> x \\<notin> dom (C r)", "using wp1_p"], ["proof (prove)\nusing this:\n  applied_rule_rev C x p = \\<lfloor>DenyAll\\<rfloor>\n  wellformed_policy1_strong p\n\ngoal (1 subgoal):\n 1. \\<forall>r. r \\<in> set (tl p) \\<longrightarrow> x \\<notin> dom (C r)", "by (auto simp: mrDenyAll_is_unique)"], ["proof (state)\nthis:\n  \\<forall>r. r \\<in> set (tl p) \\<longrightarrow> x \\<notin> dom (C r)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "hence x_notin_tl_s: \"\\<forall> r. r \\<in> set (tl s) \\<longrightarrow>  x \\<notin> dom (C r)\""], ["proof (prove)\nusing this:\n  \\<forall>r. r \\<in> set (tl p) \\<longrightarrow> x \\<notin> dom (C r)\n\ngoal (1 subgoal):\n 1. \\<forall>r. r \\<in> set (tl s) \\<longrightarrow> x \\<notin> dom (C r)", "using tl_eq"], ["proof (prove)\nusing this:\n  \\<forall>r. r \\<in> set (tl p) \\<longrightarrow> x \\<notin> dom (C r)\n  set (tl p) = set (tl s)\n\ngoal (1 subgoal):\n 1. \\<forall>r. r \\<in> set (tl s) \\<longrightarrow> x \\<notin> dom (C r)", "by auto"], ["proof (state)\nthis:\n  \\<forall>r. r \\<in> set (tl s) \\<longrightarrow> x \\<notin> dom (C r)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "hence mr_s_is_DenyAll: \"applied_rule_rev C x s = Some DenyAll\""], ["proof (prove)\nusing this:\n  \\<forall>r. r \\<in> set (tl s) \\<longrightarrow> x \\<notin> dom (C r)\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x s = \\<lfloor>DenyAll\\<rfloor>", "using tl_s"], ["proof (prove)\nusing this:\n  \\<forall>r. r \\<in> set (tl s) \\<longrightarrow> x \\<notin> dom (C r)\n  s = DenyAll # tl s\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x s = \\<lfloor>DenyAll\\<rfloor>", "by (auto simp: mr_first)"], ["proof (state)\nthis:\n  applied_rule_rev C x s = \\<lfloor>DenyAll\\<rfloor>\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "thus ?thesis"], ["proof (prove)\nusing this:\n  applied_rule_rev C x s = \\<lfloor>DenyAll\\<rfloor>\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = applied_rule_rev C x s", "using mr_p_is_DenyAll"], ["proof (prove)\nusing this:\n  applied_rule_rev C x s = \\<lfloor>DenyAll\\<rfloor>\n  applied_rule_rev C x p = \\<lfloor>DenyAll\\<rfloor>\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = applied_rule_rev C x s", "by simp"], ["proof (state)\nthis:\n  applied_rule_rev C x p = applied_rule_rev C x s\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "}"], ["proof (state)\nthis:\n  y = DenyAll \\<Longrightarrow>\n  applied_rule_rev C x p = applied_rule_rev C x s\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "{"], ["proof (state)\nthis:\n  y = DenyAll \\<Longrightarrow>\n  applied_rule_rev C x p = applied_rule_rev C x s\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "case (DenyAllFromTo a b)"], ["proof (state)\nthis:\n  y = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "have mr_p_is_DAFT: \"applied_rule_rev C x p = Some (DenyAllFromTo a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>", "by (simp add: DenyAllFromTo Some)"], ["proof (state)\nthis:\n  applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "have DA_notin_tl: \"DenyAll \\<notin> set (tl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<notin> set (tl p)", "by (metis WP1n_DA_notinSet wp1_p)"], ["proof (state)\nthis:\n  DenyAll \\<notin> set (tl p)\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "have mr_tl_p: \"applied_rule_rev C x p = applied_rule_rev C x (tl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = applied_rule_rev C x (tl p)", "by (metis Combinators.simps(4) DenyAllFromTo Some mrConcEnd tl_p)"], ["proof (state)\nthis:\n  applied_rule_rev C x p = applied_rule_rev C x (tl p)\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "have dom_tl_p: \"\\<And> r. r \\<in> set (tl p) \\<and> x \\<in> dom (C r) \\<Longrightarrow> r = (DenyAllFromTo a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> set (tl p) \\<and> x \\<in> dom (C r) \\<Longrightarrow>\n       r = DenyAllFromTo a b", "using wp1_p aND SC wp3_p mr_p_is_DAFT"], ["proof (prove)\nusing this:\n  wellformed_policy1_strong p\n  allNetsDistinct p\n  singleCombinators p\n  wellformed_policy3 p\n  applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> set (tl p) \\<and> x \\<in> dom (C r) \\<Longrightarrow>\n       r = DenyAllFromTo a b", "by (auto simp: rule_charnDAFT)"], ["proof (state)\nthis:\n  ?r \\<in> set (tl p) \\<and> x \\<in> dom (C ?r) \\<Longrightarrow>\n  ?r = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "hence dom_tl_s: \"\\<And> r. r \\<in> set (tl s) \\<and> x \\<in> dom (C r) \\<Longrightarrow> r = (DenyAllFromTo a b)\""], ["proof (prove)\nusing this:\n  ?r \\<in> set (tl p) \\<and> x \\<in> dom (C ?r) \\<Longrightarrow>\n  ?r = DenyAllFromTo a b\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> set (tl s) \\<and> x \\<in> dom (C r) \\<Longrightarrow>\n       r = DenyAllFromTo a b", "using tl_eq"], ["proof (prove)\nusing this:\n  ?r \\<in> set (tl p) \\<and> x \\<in> dom (C ?r) \\<Longrightarrow>\n  ?r = DenyAllFromTo a b\n  set (tl p) = set (tl s)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> set (tl s) \\<and> x \\<in> dom (C r) \\<Longrightarrow>\n       r = DenyAllFromTo a b", "by auto"], ["proof (state)\nthis:\n  ?r \\<in> set (tl s) \\<and> x \\<in> dom (C ?r) \\<Longrightarrow>\n  ?r = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "have DAFT_in_tl_s: \"DenyAllFromTo a b \\<in> set (tl s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAllFromTo a b \\<in> set (tl s)", "using mr_tl_p"], ["proof (prove)\nusing this:\n  applied_rule_rev C x p = applied_rule_rev C x (tl p)\n\ngoal (1 subgoal):\n 1. DenyAllFromTo a b \\<in> set (tl s)", "by (metis DenyAllFromTo mrSet mr_p_is_DAFT tl_eq)"], ["proof (state)\nthis:\n  DenyAllFromTo a b \\<in> set (tl s)\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "have x_in_dom_DAFT: \"x \\<in> dom (C (DenyAllFromTo a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C (DenyAllFromTo a b))", "by (metis mr_p_is_DAFT DenyAllFromTo mr_in_dom)"], ["proof (state)\nthis:\n  x \\<in> dom (C (DenyAllFromTo a b))\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "hence mr_tl_s_is_DAFT: \"applied_rule_rev C x (tl s) = Some (DenyAllFromTo a b)\""], ["proof (prove)\nusing this:\n  x \\<in> dom (C (DenyAllFromTo a b))\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (tl s) = \\<lfloor>DenyAllFromTo a b\\<rfloor>", "using DAFT_in_tl_s dom_tl_s"], ["proof (prove)\nusing this:\n  x \\<in> dom (C (DenyAllFromTo a b))\n  DenyAllFromTo a b \\<in> set (tl s)\n  ?r \\<in> set (tl s) \\<and> x \\<in> dom (C ?r) \\<Longrightarrow>\n  ?r = DenyAllFromTo a b\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (tl s) = \\<lfloor>DenyAllFromTo a b\\<rfloor>", "by (metis  mr_charn)"], ["proof (state)\nthis:\n  applied_rule_rev C x (tl s) = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "hence mr_s_is_DAFT: \"applied_rule_rev C x s = Some (DenyAllFromTo a b)\""], ["proof (prove)\nusing this:\n  applied_rule_rev C x (tl s) = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x s = \\<lfloor>DenyAllFromTo a b\\<rfloor>", "using tl_s"], ["proof (prove)\nusing this:\n  applied_rule_rev C x (tl s) = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n  s = DenyAll # tl s\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x s = \\<lfloor>DenyAllFromTo a b\\<rfloor>", "by (metis  DA_notin_tl DenyAllFromTo EX_MR mrDA_tl \n            not_Some_eq tl_eq wellformed_policy1_strong.simps(2))"], ["proof (state)\nthis:\n  applied_rule_rev C x s = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "thus ?thesis"], ["proof (prove)\nusing this:\n  applied_rule_rev C x s = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = applied_rule_rev C x s", "using mr_p_is_DAFT"], ["proof (prove)\nusing this:\n  applied_rule_rev C x s = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n  applied_rule_rev C x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = applied_rule_rev C x s", "by simp"], ["proof (state)\nthis:\n  applied_rule_rev C x p = applied_rule_rev C x s\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "}"], ["proof (state)\nthis:\n  y = DenyAllFromTo ?a2 ?b2 \\<Longrightarrow>\n  applied_rule_rev C x p = applied_rule_rev C x s\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "{"], ["proof (state)\nthis:\n  y = DenyAllFromTo ?a2 ?b2 \\<Longrightarrow>\n  applied_rule_rev C x p = applied_rule_rev C x s\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "case (AllowPortFromTo a b c)"], ["proof (state)\nthis:\n  y = AllowPortFromTo a b c\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "have wp1s: \"wellformed_policy1 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1 s", "by (metis wp1_eq wp1_s)"], ["proof (state)\nthis:\n  wellformed_policy1 s\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "have mr_p_is_A: \"applied_rule_rev C x p = Some (AllowPortFromTo a b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = \\<lfloor>AllowPortFromTo a b c\\<rfloor>", "by (simp add: AllowPortFromTo Some)"], ["proof (state)\nthis:\n  applied_rule_rev C x p = \\<lfloor>AllowPortFromTo a b c\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "hence A_in_s: \"AllowPortFromTo a b c \\<in> set s\""], ["proof (prove)\nusing this:\n  applied_rule_rev C x p = \\<lfloor>AllowPortFromTo a b c\\<rfloor>\n\ngoal (1 subgoal):\n 1. AllowPortFromTo a b c \\<in> set s", "using sets_eq"], ["proof (prove)\nusing this:\n  applied_rule_rev C x p = \\<lfloor>AllowPortFromTo a b c\\<rfloor>\n  set p = set s\n\ngoal (1 subgoal):\n 1. AllowPortFromTo a b c \\<in> set s", "by (auto intro: mrSet)"], ["proof (state)\nthis:\n  AllowPortFromTo a b c \\<in> set s\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "have x_in_dom_A: \"x \\<in> dom (C (AllowPortFromTo a b c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C (AllowPortFromTo a b c))", "by (metis mr_p_is_A AllowPortFromTo mr_in_dom)"], ["proof (state)\nthis:\n  x \\<in> dom (C (AllowPortFromTo a b c))\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "have SCs: \"singleCombinators s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators s", "using SC sets_eq"], ["proof (prove)\nusing this:\n  singleCombinators p\n  set p = set s\n\ngoal (1 subgoal):\n 1. singleCombinators s", "by (auto intro: SCSubset)"], ["proof (state)\nthis:\n  singleCombinators s\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "hence ANDs: \"allNetsDistinct s\""], ["proof (prove)\nusing this:\n  singleCombinators s\n\ngoal (1 subgoal):\n 1. allNetsDistinct s", "using aND sets_eq SC"], ["proof (prove)\nusing this:\n  singleCombinators s\n  allNetsDistinct p\n  set p = set s\n  singleCombinators p\n\ngoal (1 subgoal):\n 1. allNetsDistinct s", "by (auto intro: aNDSetsEq)"], ["proof (state)\nthis:\n  allNetsDistinct s\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "hence mr_s_is_A: \"applied_rule_rev C x s = Some (AllowPortFromTo a b c)\""], ["proof (prove)\nusing this:\n  allNetsDistinct s\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x s = \\<lfloor>AllowPortFromTo a b c\\<rfloor>", "using A_in_s wp1s mr_p_is_A aND SCs wp3_s x_in_dom_A"], ["proof (prove)\nusing this:\n  allNetsDistinct s\n  AllowPortFromTo a b c \\<in> set s\n  wellformed_policy1 s\n  applied_rule_rev C x p = \\<lfloor>AllowPortFromTo a b c\\<rfloor>\n  allNetsDistinct p\n  singleCombinators s\n  wellformed_policy3 s\n  x \\<in> dom (C (AllowPortFromTo a b c))\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x s = \\<lfloor>AllowPortFromTo a b c\\<rfloor>", "by (simp add: rule_charn2)"], ["proof (state)\nthis:\n  applied_rule_rev C x s = \\<lfloor>AllowPortFromTo a b c\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "thus ?thesis"], ["proof (prove)\nusing this:\n  applied_rule_rev C x s = \\<lfloor>AllowPortFromTo a b c\\<rfloor>\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = applied_rule_rev C x s", "using mr_p_is_A"], ["proof (prove)\nusing this:\n  applied_rule_rev C x s = \\<lfloor>AllowPortFromTo a b c\\<rfloor>\n  applied_rule_rev C x p = \\<lfloor>AllowPortFromTo a b c\\<rfloor>\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = applied_rule_rev C x s", "by simp"], ["proof (state)\nthis:\n  applied_rule_rev C x p = applied_rule_rev C x s\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "}"], ["proof (state)\nthis:\n  y = AllowPortFromTo ?a2 ?b2 ?c2 \\<Longrightarrow>\n  applied_rule_rev C x p = applied_rule_rev C x s\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "case (Conc a b)"], ["proof (state)\nthis:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev C x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x p = applied_rule_rev C x s", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x p = applied_rule_rev C x s", "by (metis Some mr_not_Conc SC)"], ["proof (state)\nthis:\n  applied_rule_rev C x p = applied_rule_rev C x s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  applied_rule_rev C x p = applied_rule_rev C x s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_Sets: \n  \"singleCombinators p \\<Longrightarrow>  wellformed_policy1_strong p \\<Longrightarrow>  wellformed_policy1_strong s \\<Longrightarrow>\n   wellformed_policy3 p \\<Longrightarrow>  wellformed_policy3 s \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> set p = set s \\<Longrightarrow> \n   C (list2FWpolicy p) x = C (list2FWpolicy s) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; wellformed_policy1_strong p;\n     wellformed_policy1_strong s; wellformed_policy3 p;\n     wellformed_policy3 s; allNetsDistinct p; set p = set s\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy p) x = C (list2FWpolicy s) x", "by(auto intro: C_eq_if_mr_eq C_eq_Sets_mr [symmetric])"], ["", "lemma C_eq_sorted: \n  \"distinct p \\<Longrightarrow> all_in_list p l \\<Longrightarrow> singleCombinators p \\<Longrightarrow> wellformed_policy1_strong p \\<Longrightarrow>\n    wellformed_policy3 p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> \n   C (list2FWpolicy (FWNormalisationCore.sort p l)) = C (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct p; all_in_list p l; singleCombinators p;\n     wellformed_policy1_strong p; wellformed_policy3 p;\n     allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (FWNormalisationCore.sort p l)) =\n                      C (list2FWpolicy p)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>distinct p; all_in_list p l; singleCombinators p;\n        wellformed_policy1_strong p; wellformed_policy3 p;\n        allNetsDistinct p\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (FWNormalisationCore.sort p l))\n                          x =\n                         C (list2FWpolicy p) x", "by (auto intro: C_eq_Sets simp: nMTSort wellformed1_alternative_sorted \n      wellformed_policy3_charn  wp1_eq)"], ["", "lemma C_eq_sortedQ: \n  \"distinct p \\<Longrightarrow> all_in_list p l \\<Longrightarrow> singleCombinators p \\<Longrightarrow> wellformed_policy1_strong p \\<Longrightarrow>\n   wellformed_policy3 p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> \n   C (list2FWpolicy (qsort p l)) = C (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct p; all_in_list p l; singleCombinators p;\n     wellformed_policy1_strong p; wellformed_policy3 p;\n     allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (qsort p l)) = C (list2FWpolicy p)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>distinct p; all_in_list p l; singleCombinators p;\n        wellformed_policy1_strong p; wellformed_policy3 p;\n        allNetsDistinct p\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (qsort p l)) x =\n                         C (list2FWpolicy p) x", "apply (auto intro!: C_eq_Sets simp: nMTSortQ wellformed1_alternative_sorted distinct_sortQ\n      wellformed_policy3_charn wp1_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct p; all_in_list p l; singleCombinators p;\n     wellformed_policy1_strong p; wellformed_policy3 p;\n     allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1_strong (qsort p l)", "by (metis set_qsort wellformed1_sortedQ wellformed_eq wp1_aux1aa)"], ["", "lemma C_eq_RS2_mr: \"applied_rule_rev C x (removeShadowRules2 p)= applied_rule_rev C x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x (removeShadowRules2 p) = applied_rule_rev C x p", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. applied_rule_rev C x (removeShadowRules2 []) = applied_rule_rev C x []\n 2. \\<And>a p.\n       applied_rule_rev C x (removeShadowRules2 p) =\n       applied_rule_rev C x p \\<Longrightarrow>\n       applied_rule_rev C x (removeShadowRules2 (a # p)) =\n       applied_rule_rev C x (a # p)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. applied_rule_rev C x (removeShadowRules2 []) = applied_rule_rev C x []\n 2. \\<And>a p.\n       applied_rule_rev C x (removeShadowRules2 p) =\n       applied_rule_rev C x p \\<Longrightarrow>\n       applied_rule_rev C x (removeShadowRules2 (a # p)) =\n       applied_rule_rev C x (a # p)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev C x (removeShadowRules2 []) = applied_rule_rev C x []", "by simp"], ["proof (state)\nthis:\n  applied_rule_rev C x (removeShadowRules2 []) = applied_rule_rev C x []\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       applied_rule_rev C x (removeShadowRules2 p) =\n       applied_rule_rev C x p \\<Longrightarrow>\n       applied_rule_rev C x (removeShadowRules2 (a # p)) =\n       applied_rule_rev C x (a # p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       applied_rule_rev C x (removeShadowRules2 p) =\n       applied_rule_rev C x p \\<Longrightarrow>\n       applied_rule_rev C x (removeShadowRules2 (a # p)) =\n       applied_rule_rev C x (a # p)", "case (Cons y ys)"], ["proof (state)\nthis:\n  applied_rule_rev C x (removeShadowRules2 ys) = applied_rule_rev C x ys\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       applied_rule_rev C x (removeShadowRules2 p) =\n       applied_rule_rev C x p \\<Longrightarrow>\n       applied_rule_rev C x (removeShadowRules2 (a # p)) =\n       applied_rule_rev C x (a # p)", "thus ?case"], ["proof (prove)\nusing this:\n  applied_rule_rev C x (removeShadowRules2 ys) = applied_rule_rev C x ys\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev C x (y # ys)", "proof (cases \"ys = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x (removeShadowRules2 ys) =\n             applied_rule_rev C x ys;\n     ys = []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev C x (y # ys)\n 2. \\<lbrakk>applied_rule_rev C x (removeShadowRules2 ys) =\n             applied_rule_rev C x ys;\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev C x (y # ys)", "case True"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x (removeShadowRules2 ys) =\n             applied_rule_rev C x ys;\n     ys = []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev C x (y # ys)\n 2. \\<lbrakk>applied_rule_rev C x (removeShadowRules2 ys) =\n             applied_rule_rev C x ys;\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev C x (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys = []\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev C x (y # ys)", "by (cases y, simp_all)"], ["proof (state)\nthis:\n  applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev C x (y # ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev C x (removeShadowRules2 ys) =\n             applied_rule_rev C x ys;\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev C x (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev C x (removeShadowRules2 ys) =\n             applied_rule_rev C x ys;\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev C x (y # ys)", "case False"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev C x (removeShadowRules2 ys) =\n             applied_rule_rev C x ys;\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev C x (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev C x (y # ys)", "proof (cases y)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>ys \\<noteq> []; y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev C x (y # ys)\n 2. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> []; y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> []; y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)\n 4. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)", "case DenyAll"], ["proof (state)\nthis:\n  y = DenyAll\n\ngoal (4 subgoals):\n 1. \\<lbrakk>ys \\<noteq> []; y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev C x (y # ys)\n 2. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> []; y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> []; y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)\n 4. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = DenyAll\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev C x (y # ys)", "by (simp, metis Cons DenyAll mreq_end2)"], ["proof (state)\nthis:\n  applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev C x (y # ys)\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> []; y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> []; y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)\n 3. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> []; y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> []; y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)\n 3. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)", "case (DenyAllFromTo a b)"], ["proof (state)\nthis:\n  y = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> []; y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> []; y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)\n 3. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev C x (y # ys)", "by (simp, metis Cons DenyAllFromTo mreq_end2)"], ["proof (state)\nthis:\n  applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev C x (y # ys)\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> []; y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)\n 2. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> []; y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)\n 2. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)", "case (AllowPortFromTo a b p)"], ["proof (state)\nthis:\n  y = AllowPortFromTo a b p\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> []; y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)\n 2. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a b p\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev C x (y # ys)", "proof (cases \"DenyAllFromTo a b \\<in> set ys\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b p;\n     DenyAllFromTo a b \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev C x (y # ys)\n 2. \\<lbrakk>y = AllowPortFromTo a b p;\n     DenyAllFromTo a b \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev C x (y # ys)", "case True"], ["proof (state)\nthis:\n  DenyAllFromTo a b \\<in> set ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b p;\n     DenyAllFromTo a b \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev C x (y # ys)\n 2. \\<lbrakk>y = AllowPortFromTo a b p;\n     DenyAllFromTo a b \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev C x (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  DenyAllFromTo a b \\<in> set ys\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev C x (y # ys)", "using AllowPortFromTo Cons"], ["proof (prove)\nusing this:\n  DenyAllFromTo a b \\<in> set ys\n  y = AllowPortFromTo a b p\n  applied_rule_rev C x (removeShadowRules2 ys) = applied_rule_rev C x ys\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev C x (y # ys)", "apply (cases \"applied_rule_rev C x ys = None\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x ys = \\<bottom>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev C x (removeShadowRules2 ys) = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> \\<bottom> =\n                      applied_rule_rev C x (AllowPortFromTo a b p # ys)\n 2. \\<lbrakk>\\<exists>y. applied_rule_rev C x ys = \\<lfloor>y\\<rfloor>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev C x (removeShadowRules2 ys) =\n     applied_rule_rev C x ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x ys =\n                      applied_rule_rev C x (AllowPortFromTo a b p # ys)", "apply (subgoal_tac \"x \\<notin> dom (C (AllowPortFromTo a b p))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x ys = \\<bottom>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev C x (removeShadowRules2 ys) = \\<bottom>;\n     x \\<notin> dom (C (AllowPortFromTo a b p))\\<rbrakk>\n    \\<Longrightarrow> \\<bottom> =\n                      applied_rule_rev C x (AllowPortFromTo a b p # ys)\n 2. \\<lbrakk>applied_rule_rev C x ys = \\<bottom>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev C x (removeShadowRules2 ys) = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (AllowPortFromTo a b p))\n 3. \\<lbrakk>\\<exists>y. applied_rule_rev C x ys = \\<lfloor>y\\<rfloor>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev C x (removeShadowRules2 ys) =\n     applied_rule_rev C x ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x ys =\n                      applied_rule_rev C x (AllowPortFromTo a b p # ys)", "apply (subst mrconcNone, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x ys = \\<bottom>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev C x (removeShadowRules2 ys) = \\<bottom>;\n     x \\<notin> dom (C (AllowPortFromTo a b p))\\<rbrakk>\n    \\<Longrightarrow> \\<bottom> =\n                      applied_rule_rev C x [AllowPortFromTo a b p]\n 2. \\<lbrakk>applied_rule_rev C x ys = \\<bottom>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev C x (removeShadowRules2 ys) = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (AllowPortFromTo a b p))\n 3. \\<lbrakk>\\<exists>y. applied_rule_rev C x ys = \\<lfloor>y\\<rfloor>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev C x (removeShadowRules2 ys) =\n     applied_rule_rev C x ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x ys =\n                      applied_rule_rev C x (AllowPortFromTo a b p # ys)", "apply (simp add: applied_rule_rev_def )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x ys = \\<bottom>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev C x (removeShadowRules2 ys) = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (AllowPortFromTo a b p))\n 2. \\<lbrakk>\\<exists>y. applied_rule_rev C x ys = \\<lfloor>y\\<rfloor>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev C x (removeShadowRules2 ys) =\n     applied_rule_rev C x ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x ys =\n                      applied_rule_rev C x (AllowPortFromTo a b p # ys)", "apply (rule contra_subsetD [OF allow_deny_dom])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>applied_rule_rev C x ys = \\<bottom>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev C x (removeShadowRules2 ys) = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (DenyAllFromTo a b))\n 2. \\<lbrakk>\\<exists>y. applied_rule_rev C x ys = \\<lfloor>y\\<rfloor>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev C x (removeShadowRules2 ys) =\n     applied_rule_rev C x ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x ys =\n                      applied_rule_rev C x (AllowPortFromTo a b p # ys)", "apply (erule mrNoneMT,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>y. applied_rule_rev C x ys = \\<lfloor>y\\<rfloor>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev C x (removeShadowRules2 ys) =\n     applied_rule_rev C x ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x ys =\n                      applied_rule_rev C x (AllowPortFromTo a b p # ys)", "apply (metis AllowPortFromTo mrconc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev C x (y # ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b p;\n     DenyAllFromTo a b \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev C x (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b p;\n     DenyAllFromTo a b \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev C x (y # ys)", "case False"], ["proof (state)\nthis:\n  DenyAllFromTo a b \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b p;\n     DenyAllFromTo a b \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev C x (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  DenyAllFromTo a b \\<notin> set ys\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev C x (y # ys)", "using False Cons AllowPortFromTo"], ["proof (prove)\nusing this:\n  DenyAllFromTo a b \\<notin> set ys\n  DenyAllFromTo a b \\<notin> set ys\n  applied_rule_rev C x (removeShadowRules2 ys) = applied_rule_rev C x ys\n  y = AllowPortFromTo a b p\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev C x (y # ys)", "by (simp, metis AllowPortFromTo Cons mreq_end2)"], ["proof (state)\nthis:\n  applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev C x (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev C x (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)", "case (Conc a b)"], ["proof (state)\nthis:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev C x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev C x (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev C x (y # ys)", "by (metis Cons mreq_end2 removeShadowRules2.simps(4))"], ["proof (state)\nthis:\n  applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev C x (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev C x (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  applied_rule_rev C x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev C x (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_None[rule_format]: \n  \"p \\<noteq> []  --> applied_rule_rev C x p = None \\<longrightarrow>  C (list2FWpolicy p) x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    applied_rule_rev C x p = \\<bottom> \\<longrightarrow>\n    C (list2FWpolicy p) x = \\<bottom>", "apply (simp add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    applied_rule C x (rev p) = \\<bottom> \\<longrightarrow>\n    C (list2FWpolicy p) x = \\<bottom>", "apply (rule rev_induct, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       applied_rule C x (rev xs) = \\<bottom> \\<longrightarrow>\n       C (list2FWpolicy xs) x = \\<bottom> \\<Longrightarrow>\n       x \\<notin> dom (C xa) \\<longrightarrow>\n       applied_rule C x (rev xs) = \\<bottom> \\<longrightarrow>\n       C (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "apply (intro impI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>xs \\<noteq> [] \\<longrightarrow>\n                C (list2FWpolicy xs) x = \\<bottom>;\n        x \\<notin> dom (C xa);\n        applied_rule C x (rev xs) = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "subgoal for xa xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> [] \\<longrightarrow>\n             C (list2FWpolicy xs) x = \\<bottom>;\n     x \\<notin> dom (C xa); applied_rule C x (rev xs) = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "apply (case_tac \"xs \\<noteq> []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> [] \\<longrightarrow>\n             C (list2FWpolicy xs) x = \\<bottom>;\n     x \\<notin> dom (C xa); applied_rule C x (rev xs) = \\<bottom>;\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (xs @ [xa])) x = \\<bottom>\n 2. \\<lbrakk>xs \\<noteq> [] \\<longrightarrow>\n             C (list2FWpolicy xs) x = \\<bottom>;\n     x \\<notin> dom (C xa); applied_rule C x (rev xs) = \\<bottom>;\n     \\<not> xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "apply (simp_all add: dom_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_eq_None2:\n  \"a \\<noteq> [] \\<Longrightarrow> b \\<noteq> [] \\<Longrightarrow> applied_rule_rev C x a = \\<bottom> \\<Longrightarrow> applied_rule_rev C x b = \\<bottom> \\<Longrightarrow> \n   C (list2FWpolicy a) x = C (list2FWpolicy b) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> []; b \\<noteq> [];\n     applied_rule_rev C x a = \\<bottom>;\n     applied_rule_rev C x b = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy a) x = C (list2FWpolicy b) x", "by (auto simp: C_eq_None)"], ["", "lemma C_eq_RS2: \n  \"wellformed_policy1_strong p \\<Longrightarrow> C (list2FWpolicy (removeShadowRules2 p))= C (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<Longrightarrow>\n    C (list2FWpolicy (removeShadowRules2 p)) = C (list2FWpolicy p)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       wellformed_policy1_strong p \\<Longrightarrow>\n       C (list2FWpolicy (removeShadowRules2 p)) x = C (list2FWpolicy p) x", "by (metis C_eq_RS2_mr C_eq_if_mr_eq wellformed_policy1_strong.simps(1) wp1n_RS2)"], ["", "lemma none_MT_rulesRS2: \n  \"none_MT_rules C p \\<Longrightarrow> none_MT_rules C (removeShadowRules2 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. none_MT_rules C p \\<Longrightarrow>\n    none_MT_rules C (removeShadowRules2 p)", "by (auto simp: RS2Set none_MT_rulessubset)"], ["", "lemma CconcNone: \n  \"dom (C a) = {} \\<Longrightarrow> p \\<noteq> [] \\<Longrightarrow> C (list2FWpolicy (a # p)) x = C (list2FWpolicy p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom (C a) = {}; p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (a # p)) x = C (list2FWpolicy p) x", "apply (case_tac \"p = []\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom (C a) = {}; p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (a # p)) x = C (list2FWpolicy p) x", "apply (case_tac \"x\\<in> dom (C (list2FWpolicy(p)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>dom (C a) = {}; p \\<noteq> [];\n     x \\<in> dom (C (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (a # p)) x = C (list2FWpolicy p) x\n 2. \\<lbrakk>dom (C a) = {}; p \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (a # p)) x = C (list2FWpolicy p) x", "apply (metis Cdom2 list2FWpolicyconc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom (C a) = {}; p \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (a # p)) x = C (list2FWpolicy p) x", "apply (metis C.simps(4) map_add_dom_app_simps(2) inSet_not_MT list2FWpolicyconc set_empty2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma none_MT_rulesrd[rule_format]: \n  \"none_MT_rules C p \\<longrightarrow> none_MT_rules C (remdups p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. none_MT_rules C p \\<longrightarrow> none_MT_rules C (remdups p)", "by (induct p, simp_all)"], ["", "lemma DARS3[rule_format]:\n  \"DenyAll \\<notin> set p\\<longrightarrow>DenyAll \\<notin> set (rm_MT_rules C p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<notin> set p \\<longrightarrow>\n    DenyAll \\<notin> set (rm_MT_rules C p)", "by (induct p, simp_all)"], ["", "lemma DAnMT: \"dom (C DenyAll) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (C DenyAll) \\<noteq> {}", "by (simp add: dom_def C.simps PolicyCombinators.PolicyCombinators)"], ["", "lemma DAnMT2: \"C DenyAll \\<noteq> Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C DenyAll \\<noteq> \\<emptyset>", "by (metis DAAux dom_eq_empty_conv empty_iff)"], ["", "lemma wp1n_RS3[rule_format,simp]: \n  \"wellformed_policy1_strong p \\<longrightarrow>  wellformed_policy1_strong (rm_MT_rules C p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<longrightarrow>\n    wellformed_policy1_strong (rm_MT_rules C p)", "by (induct p, simp_all add: DARS3 DAnMT)"], ["", "lemma AILRS3[rule_format,simp]: \n  \"all_in_list p l \\<longrightarrow> all_in_list (rm_MT_rules C p) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list p l \\<longrightarrow> all_in_list (rm_MT_rules C p) l", "by (induct p, simp_all)"], ["", "lemma SCRS3[rule_format,simp]: \n  \"singleCombinators p \\<longrightarrow> singleCombinators(rm_MT_rules C p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<longrightarrow>\n    singleCombinators (rm_MT_rules C p)", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       singleCombinators p \\<longrightarrow>\n       singleCombinators (rm_MT_rules C p) \\<Longrightarrow>\n       (dom (C a) = {} \\<longrightarrow>\n        singleCombinators (a # p) \\<longrightarrow>\n        singleCombinators (rm_MT_rules C p)) \\<and>\n       (dom (C a) \\<noteq> {} \\<longrightarrow>\n        singleCombinators (a # p) \\<longrightarrow>\n        singleCombinators (a # rm_MT_rules C p))", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<longrightarrow>\n    singleCombinators (rm_MT_rules C p) \\<Longrightarrow>\n    (dom (C a) = {} \\<longrightarrow>\n     singleCombinators (a # p) \\<longrightarrow>\n     singleCombinators (rm_MT_rules C p)) \\<and>\n    (dom (C a) \\<noteq> {} \\<longrightarrow>\n     singleCombinators (a # p) \\<longrightarrow>\n     singleCombinators (a # rm_MT_rules C p))", "apply(case_tac \"a\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma RS3subset: \"set (rm_MT_rules C p)  \\<subseteq> set p \""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rm_MT_rules C p) \\<subseteq> set p", "by (induct p, auto)"], ["", "lemma ANDRS3[simp]: \n  \"singleCombinators p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> allNetsDistinct (rm_MT_rules C p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct (rm_MT_rules C p)", "using RS3subset SCRS3 aNDSubset"], ["proof (prove)\nusing this:\n  set (rm_MT_rules C ?p) \\<subseteq> set ?p\n  singleCombinators ?p \\<Longrightarrow>\n  singleCombinators (rm_MT_rules C ?p)\n  \\<lbrakk>singleCombinators ?a; set ?a \\<subseteq> set ?b;\n   allNetsDistinct ?b\\<rbrakk>\n  \\<Longrightarrow> allNetsDistinct ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct (rm_MT_rules C p)", "by blast"], ["", "lemma nlpaux: \"x \\<notin> dom (C b) \\<Longrightarrow> C (a \\<oplus> b) x = C a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom (C b) \\<Longrightarrow> C (a \\<oplus> b) x = C a x", "by (metis C.simps(4) map_add_dom_app_simps(3))"], ["", "lemma notindom[rule_format]: \n  \"a \\<in> set p \\<longrightarrow>  x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow>  x \\<notin> dom (C a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set p \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow>\n    x \\<notin> dom (C a)", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       a \\<in> set p \\<longrightarrow>\n       x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       x \\<notin> dom (C a) \\<Longrightarrow>\n       (a = aa \\<longrightarrow>\n        x \\<notin> dom (C (list2FWpolicy (aa # p))) \\<longrightarrow>\n        x \\<notin> dom (C aa)) \\<and>\n       (a \\<in> set p \\<longrightarrow>\n        x \\<notin> dom (C (list2FWpolicy (aa # p))) \\<longrightarrow>\n        x \\<notin> dom (C a))", "by (metis CConcStartA Cdom2 domIff empty_iff empty_set l2p_aux)"], ["", "lemma C_eq_rd[rule_format]: \n  \"p \\<noteq> [] \\<Longrightarrow> C (list2FWpolicy (remdups p)) = C (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    C (list2FWpolicy (remdups p)) = C (list2FWpolicy p)", "proof (rule ext,induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       [] \\<noteq> [] \\<Longrightarrow>\n       C (list2FWpolicy (remdups [])) x = C (list2FWpolicy []) x\n 2. \\<And>a p x.\n       \\<lbrakk>\\<And>x.\n                   p \\<noteq> [] \\<Longrightarrow>\n                   C (list2FWpolicy (remdups p)) x = C (list2FWpolicy p) x;\n        a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (remdups (a # p))) x =\n                         C (list2FWpolicy (a # p)) x", "case Nil"], ["proof (state)\nthis:\n  [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       [] \\<noteq> [] \\<Longrightarrow>\n       C (list2FWpolicy (remdups [])) x = C (list2FWpolicy []) x\n 2. \\<And>a p x.\n       \\<lbrakk>\\<And>x.\n                   p \\<noteq> [] \\<Longrightarrow>\n                   C (list2FWpolicy (remdups p)) x = C (list2FWpolicy p) x;\n        a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (remdups (a # p))) x =\n                         C (list2FWpolicy (a # p)) x", "thus ?case"], ["proof (prove)\nusing this:\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy (remdups [])) x = C (list2FWpolicy []) x", "by simp"], ["proof (state)\nthis:\n  C (list2FWpolicy (remdups [])) x = C (list2FWpolicy []) x\n\ngoal (1 subgoal):\n 1. \\<And>a p x.\n       \\<lbrakk>\\<And>x.\n                   p \\<noteq> [] \\<Longrightarrow>\n                   C (list2FWpolicy (remdups p)) x = C (list2FWpolicy p) x;\n        a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (remdups (a # p))) x =\n                         C (list2FWpolicy (a # p)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p x.\n       \\<lbrakk>\\<And>x.\n                   p \\<noteq> [] \\<Longrightarrow>\n                   C (list2FWpolicy (remdups p)) x = C (list2FWpolicy p) x;\n        a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (remdups (a # p))) x =\n                         C (list2FWpolicy (a # p)) x", "case (Cons y ys)"], ["proof (state)\nthis:\n  ys \\<noteq> [] \\<Longrightarrow>\n  C (list2FWpolicy (remdups ys)) ?x = C (list2FWpolicy ys) ?x\n  y # ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a p x.\n       \\<lbrakk>\\<And>x.\n                   p \\<noteq> [] \\<Longrightarrow>\n                   C (list2FWpolicy (remdups p)) x = C (list2FWpolicy p) x;\n        a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (remdups (a # p))) x =\n                         C (list2FWpolicy (a # p)) x", "thus ?case"], ["proof (prove)\nusing this:\n  ys \\<noteq> [] \\<Longrightarrow>\n  C (list2FWpolicy (remdups ys)) ?x = C (list2FWpolicy ys) ?x\n  y # ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy (remdups (y # ys))) x = C (list2FWpolicy (y # ys)) x", "proof (cases \"ys = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                ys \\<noteq> [] \\<Longrightarrow>\n                C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y # ys \\<noteq> []; ys = []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (remdups (y # ys))) x =\n                      C (list2FWpolicy (y # ys)) x\n 2. \\<lbrakk>\\<And>x.\n                ys \\<noteq> [] \\<Longrightarrow>\n                C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y # ys \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (remdups (y # ys))) x =\n                      C (list2FWpolicy (y # ys)) x", "case True"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                ys \\<noteq> [] \\<Longrightarrow>\n                C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y # ys \\<noteq> []; ys = []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (remdups (y # ys))) x =\n                      C (list2FWpolicy (y # ys)) x\n 2. \\<lbrakk>\\<And>x.\n                ys \\<noteq> [] \\<Longrightarrow>\n                C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y # ys \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (remdups (y # ys))) x =\n                      C (list2FWpolicy (y # ys)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys = []\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy (remdups (y # ys))) x = C (list2FWpolicy (y # ys)) x", "by simp"], ["proof (state)\nthis:\n  C (list2FWpolicy (remdups (y # ys))) x = C (list2FWpolicy (y # ys)) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                ys \\<noteq> [] \\<Longrightarrow>\n                C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y # ys \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (remdups (y # ys))) x =\n                      C (list2FWpolicy (y # ys)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                ys \\<noteq> [] \\<Longrightarrow>\n                C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y # ys \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (remdups (y # ys))) x =\n                      C (list2FWpolicy (y # ys)) x", "case False"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                ys \\<noteq> [] \\<Longrightarrow>\n                C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y # ys \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (remdups (y # ys))) x =\n                      C (list2FWpolicy (y # ys)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy (remdups (y # ys))) x = C (list2FWpolicy (y # ys)) x", "using Cons"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  ys \\<noteq> [] \\<Longrightarrow>\n  C (list2FWpolicy (remdups ys)) ?x = C (list2FWpolicy ys) ?x\n  y # ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy (remdups (y # ys))) x = C (list2FWpolicy (y # ys)) x", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x.\n        C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x\\<rbrakk>\n    \\<Longrightarrow> (y \\<in> set ys \\<longrightarrow>\n                       C (list2FWpolicy ys) x =\n                       C (list2FWpolicy (y # ys)) x) \\<and>\n                      (y \\<notin> set ys \\<longrightarrow>\n                       C (list2FWpolicy (y # remdups ys)) x =\n                       C (list2FWpolicy (y # ys)) x)", "apply (rule conjI, rule impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy ys) x = C (list2FWpolicy (y # ys)) x\n 2. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x.\n        C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x\\<rbrakk>\n    \\<Longrightarrow> y \\<notin> set ys \\<longrightarrow>\n                      C (list2FWpolicy (y # remdups ys)) x =\n                      C (list2FWpolicy (y # ys)) x", "apply (cases \"x \\<in> dom (C (list2FWpolicy ys))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y \\<in> set ys; x \\<in> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy ys) x = C (list2FWpolicy (y # ys)) x\n 2. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y \\<in> set ys; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy ys) x = C (list2FWpolicy (y # ys)) x\n 3. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x.\n        C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x\\<rbrakk>\n    \\<Longrightarrow> y \\<notin> set ys \\<longrightarrow>\n                      C (list2FWpolicy (y # remdups ys)) x =\n                      C (list2FWpolicy (y # ys)) x", "apply (metis Cdom2 False list2FWpolicyconc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y \\<in> set ys; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy ys) x = C (list2FWpolicy (y # ys)) x\n 2. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x.\n        C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x\\<rbrakk>\n    \\<Longrightarrow> y \\<notin> set ys \\<longrightarrow>\n                      C (list2FWpolicy (y # remdups ys)) x =\n                      C (list2FWpolicy (y # ys)) x", "apply (metis False domIff list2FWpolicyconc nlpaux notindom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x.\n        C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x\\<rbrakk>\n    \\<Longrightarrow> y \\<notin> set ys \\<longrightarrow>\n                      C (list2FWpolicy (y # remdups ys)) x =\n                      C (list2FWpolicy (y # ys)) x", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # remdups ys)) x =\n                      C (list2FWpolicy (y # ys)) x", "apply (cases \"x \\<in> dom (C (list2FWpolicy ys))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y \\<notin> set ys; x \\<in> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # remdups ys)) x =\n                      C (list2FWpolicy (y # ys)) x\n 2. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y \\<notin> set ys; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # remdups ys)) x =\n                      C (list2FWpolicy (y # ys)) x", "apply (subgoal_tac \"x \\<in> dom (C (list2FWpolicy (remdups ys)))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y \\<notin> set ys; x \\<in> dom (C (list2FWpolicy ys));\n     x \\<in> dom (C (list2FWpolicy (remdups ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # remdups ys)) x =\n                      C (list2FWpolicy (y # ys)) x\n 2. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y \\<notin> set ys; x \\<in> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy (remdups ys)))\n 3. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y \\<notin> set ys; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # remdups ys)) x =\n                      C (list2FWpolicy (y # ys)) x", "apply (metis Cdom2 False list2FWpolicyconc remdups_eq_nil_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y \\<notin> set ys; x \\<in> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy (remdups ys)))\n 2. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y \\<notin> set ys; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # remdups ys)) x =\n                      C (list2FWpolicy (y # ys)) x", "apply (metis domIff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y \\<notin> set ys; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # remdups ys)) x =\n                      C (list2FWpolicy (y # ys)) x", "apply (subgoal_tac \"x \\<notin> dom (C (list2FWpolicy (remdups ys)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y \\<notin> set ys; x \\<notin> dom (C (list2FWpolicy ys));\n     x \\<notin> dom (C (list2FWpolicy (remdups ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # remdups ys)) x =\n                      C (list2FWpolicy (y # ys)) x\n 2. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y \\<notin> set ys; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (list2FWpolicy (remdups ys)))", "apply (metis False list2FWpolicyconc nlpaux remdups_eq_nil_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. C (list2FWpolicy (remdups ys)) x = C (list2FWpolicy ys) x;\n     y \\<notin> set ys; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (list2FWpolicy (remdups ys)))", "apply (metis domIff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  C (list2FWpolicy (remdups (y # ys))) x = C (list2FWpolicy (y # ys)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C (list2FWpolicy (remdups (y # ys))) x = C (list2FWpolicy (y # ys)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nMT_domMT:\n  \"\\<not> not_MT C  p \\<Longrightarrow> p \\<noteq> [] \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> not_MT C p; p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy p))", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> not_MT C []; [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy []))\n 2. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>\\<not> not_MT C p; p \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy p));\n        \\<not> not_MT C (a # p); a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy (a # p)))", "case Nil"], ["proof (state)\nthis:\n  \\<not> not_MT C []\n  [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> not_MT C []; [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy []))\n 2. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>\\<not> not_MT C p; p \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy p));\n        \\<not> not_MT C (a # p); a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy (a # p)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> not_MT C []\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. r \\<notin> dom (C (list2FWpolicy []))", "by simp"], ["proof (state)\nthis:\n  r \\<notin> dom (C (list2FWpolicy []))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>\\<not> not_MT C p; p \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy p));\n        \\<not> not_MT C (a # p); a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy (a # p)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>\\<not> not_MT C p; p \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy p));\n        \\<not> not_MT C (a # p); a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy (a # p)))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> not_MT C xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy xs))\n  \\<not> not_MT C (x # xs)\n  x # xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>\\<not> not_MT C p; p \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy p));\n        \\<not> not_MT C (a # p); a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy (a # p)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> not_MT C xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy xs))\n  \\<not> not_MT C (x # xs)\n  x # xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. r \\<notin> dom (C (list2FWpolicy (x # xs)))", "apply (simp split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n             r \\<notin> dom (C (list2FWpolicy xs));\n     dom (C x) = {}; \\<not> not_MT C xs\\<rbrakk>\n    \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy (x # xs)))", "apply (cases \"xs = []\",simp_all )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<notin> dom (C (list2FWpolicy xs)); dom (C x) = {};\n     \\<not> not_MT C xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> r \\<notin> dom (C (list2FWpolicy (x # xs)))", "by (metis CconcNone domIff)"], ["proof (state)\nthis:\n  r \\<notin> dom (C (list2FWpolicy (x # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_RS3_aux[rule_format]: \n  \"not_MT C  p \\<Longrightarrow>  C (list2FWpolicy p) x = C (list2FWpolicy (rm_MT_rules C p)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_MT C p \\<Longrightarrow>\n    C (list2FWpolicy p) x = C (list2FWpolicy (rm_MT_rules C p)) x", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. not_MT C [] \\<Longrightarrow>\n    C (list2FWpolicy []) x = C (list2FWpolicy (rm_MT_rules C [])) x\n 2. \\<And>a p.\n       \\<lbrakk>not_MT C p \\<Longrightarrow>\n                C (list2FWpolicy p) x =\n                C (list2FWpolicy (rm_MT_rules C p)) x;\n        not_MT C (a # p)\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (a # p)) x =\n                         C (list2FWpolicy (rm_MT_rules C (a # p))) x", "case Nil"], ["proof (state)\nthis:\n  not_MT C []\n\ngoal (2 subgoals):\n 1. not_MT C [] \\<Longrightarrow>\n    C (list2FWpolicy []) x = C (list2FWpolicy (rm_MT_rules C [])) x\n 2. \\<And>a p.\n       \\<lbrakk>not_MT C p \\<Longrightarrow>\n                C (list2FWpolicy p) x =\n                C (list2FWpolicy (rm_MT_rules C p)) x;\n        not_MT C (a # p)\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (a # p)) x =\n                         C (list2FWpolicy (rm_MT_rules C (a # p))) x", "thus ?case"], ["proof (prove)\nusing this:\n  not_MT C []\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy []) x = C (list2FWpolicy (rm_MT_rules C [])) x", "by simp"], ["proof (state)\nthis:\n  C (list2FWpolicy []) x = C (list2FWpolicy (rm_MT_rules C [])) x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>not_MT C p \\<Longrightarrow>\n                C (list2FWpolicy p) x =\n                C (list2FWpolicy (rm_MT_rules C p)) x;\n        not_MT C (a # p)\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (a # p)) x =\n                         C (list2FWpolicy (rm_MT_rules C (a # p))) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>not_MT C p \\<Longrightarrow>\n                C (list2FWpolicy p) x =\n                C (list2FWpolicy (rm_MT_rules C p)) x;\n        not_MT C (a # p)\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (a # p)) x =\n                         C (list2FWpolicy (rm_MT_rules C (a # p))) x", "case (Cons y ys)"], ["proof (state)\nthis:\n  not_MT C ys \\<Longrightarrow>\n  C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x\n  not_MT C (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>not_MT C p \\<Longrightarrow>\n                C (list2FWpolicy p) x =\n                C (list2FWpolicy (rm_MT_rules C p)) x;\n        not_MT C (a # p)\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (a # p)) x =\n                         C (list2FWpolicy (rm_MT_rules C (a # p))) x", "thus ?case"], ["proof (prove)\nusing this:\n  not_MT C ys \\<Longrightarrow>\n  C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x\n  not_MT C (y # ys)\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy (y # ys)) x =\n    C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "proof (cases \"not_MT C  ys\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>not_MT C ys \\<Longrightarrow>\n             C (list2FWpolicy ys) x =\n             C (list2FWpolicy (rm_MT_rules C ys)) x;\n     not_MT C (y # ys); not_MT C ys\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (rm_MT_rules C (y # ys))) x\n 2. \\<lbrakk>not_MT C ys \\<Longrightarrow>\n             C (list2FWpolicy ys) x =\n             C (list2FWpolicy (rm_MT_rules C ys)) x;\n     not_MT C (y # ys); \\<not> not_MT C ys\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "case True"], ["proof (state)\nthis:\n  not_MT C ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>not_MT C ys \\<Longrightarrow>\n             C (list2FWpolicy ys) x =\n             C (list2FWpolicy (rm_MT_rules C ys)) x;\n     not_MT C (y # ys); not_MT C ys\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (rm_MT_rules C (y # ys))) x\n 2. \\<lbrakk>not_MT C ys \\<Longrightarrow>\n             C (list2FWpolicy ys) x =\n             C (list2FWpolicy (rm_MT_rules C ys)) x;\n     not_MT C (y # ys); \\<not> not_MT C ys\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  not_MT C ys\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy (y # ys)) x =\n    C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "using Cons"], ["proof (prove)\nusing this:\n  not_MT C ys\n  not_MT C ys \\<Longrightarrow>\n  C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x\n  not_MT C (y # ys)\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy (y # ys)) x =\n    C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>not_MT C ys;\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     if dom (C y) = {} then not_MT C ys else True\\<rbrakk>\n    \\<Longrightarrow> (dom (C y) = {} \\<longrightarrow>\n                       C (list2FWpolicy (y # ys)) x =\n                       C (list2FWpolicy (rm_MT_rules C ys)) x) \\<and>\n                      (dom (C y) \\<noteq> {} \\<longrightarrow>\n                       C (list2FWpolicy (y # ys)) x =\n                       C (list2FWpolicy (y # rm_MT_rules C ys)) x)", "apply(rule conjI, rule impI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy ys) x =\n             C (list2FWpolicy (rm_MT_rules C ys)) x;\n     not_MT C ys; dom (C y) = {}\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (rm_MT_rules C ys)) x\n 2. \\<lbrakk>not_MT C ys;\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     if dom (C y) = {} then not_MT C ys else True\\<rbrakk>\n    \\<Longrightarrow> dom (C y) \\<noteq> {} \\<longrightarrow>\n                      C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (y # rm_MT_rules C ys)) x", "apply (metis CconcNone True not_MTimpnotMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>not_MT C ys;\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     if dom (C y) = {} then not_MT C ys else True\\<rbrakk>\n    \\<Longrightarrow> dom (C y) \\<noteq> {} \\<longrightarrow>\n                      C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (y # rm_MT_rules C ys)) x", "apply (rule impI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>not_MT C ys;\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     dom (C y) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (y # rm_MT_rules C ys)) x", "apply (cases \"x \\<in> dom (C (list2FWpolicy ys))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>not_MT C ys;\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     dom (C y) \\<noteq> {}; x \\<in> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (y # rm_MT_rules C ys)) x\n 2. \\<lbrakk>not_MT C ys;\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     dom (C y) \\<noteq> {}; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (y # rm_MT_rules C ys)) x", "apply (subgoal_tac \"x \\<in> dom (C (list2FWpolicy (rm_MT_rules C ys)))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>not_MT C ys;\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     dom (C y) \\<noteq> {}; x \\<in> dom (C (list2FWpolicy ys));\n     x \\<in> dom (C (list2FWpolicy (rm_MT_rules C ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (y # rm_MT_rules C ys)) x\n 2. \\<lbrakk>not_MT C ys;\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     dom (C y) \\<noteq> {}; x \\<in> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy (rm_MT_rules C ys)))\n 3. \\<lbrakk>not_MT C ys;\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     dom (C y) \\<noteq> {}; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (y # rm_MT_rules C ys)) x", "apply (metis Cdom2 NMPrm l2p_aux not_MTimpnotMT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>not_MT C ys;\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     dom (C y) \\<noteq> {}; x \\<in> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy (rm_MT_rules C ys)))\n 2. \\<lbrakk>not_MT C ys;\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     dom (C y) \\<noteq> {}; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (y # rm_MT_rules C ys)) x", "apply (simp add: domIff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>not_MT C ys;\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     dom (C y) \\<noteq> {}; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (y # rm_MT_rules C ys)) x", "apply (subgoal_tac \"x \\<notin>  dom (C (list2FWpolicy (rm_MT_rules C ys)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>not_MT C ys;\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     dom (C y) \\<noteq> {}; x \\<notin> dom (C (list2FWpolicy ys));\n     x \\<notin> dom (C (list2FWpolicy (rm_MT_rules C ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (y # rm_MT_rules C ys)) x\n 2. \\<lbrakk>not_MT C ys;\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     dom (C y) \\<noteq> {}; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (list2FWpolicy (rm_MT_rules C ys)))", "apply (metis l2p_aux l2p_aux2 nlpaux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>not_MT C ys;\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     dom (C y) \\<noteq> {}; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (list2FWpolicy (rm_MT_rules C ys)))", "apply (metis domIff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  C (list2FWpolicy (y # ys)) x =\n  C (list2FWpolicy (rm_MT_rules C (y # ys))) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>not_MT C ys \\<Longrightarrow>\n             C (list2FWpolicy ys) x =\n             C (list2FWpolicy (rm_MT_rules C ys)) x;\n     not_MT C (y # ys); \\<not> not_MT C ys\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>not_MT C ys \\<Longrightarrow>\n             C (list2FWpolicy ys) x =\n             C (list2FWpolicy (rm_MT_rules C ys)) x;\n     not_MT C (y # ys); \\<not> not_MT C ys\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "case False"], ["proof (state)\nthis:\n  \\<not> not_MT C ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>not_MT C ys \\<Longrightarrow>\n             C (list2FWpolicy ys) x =\n             C (list2FWpolicy (rm_MT_rules C ys)) x;\n     not_MT C (y # ys); \\<not> not_MT C ys\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> not_MT C ys\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy (y # ys)) x =\n    C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "using Cons False"], ["proof (prove)\nusing this:\n  \\<not> not_MT C ys\n  not_MT C ys \\<Longrightarrow>\n  C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x\n  not_MT C (y # ys)\n  \\<not> not_MT C ys\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy (y # ys)) x =\n    C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "proof (cases \"ys = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> not_MT C ys;\n     not_MT C ys \\<Longrightarrow>\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     not_MT C (y # ys); \\<not> not_MT C ys; ys = []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (rm_MT_rules C (y # ys))) x\n 2. \\<lbrakk>\\<not> not_MT C ys;\n     not_MT C ys \\<Longrightarrow>\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     not_MT C (y # ys); \\<not> not_MT C ys; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "case True"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> not_MT C ys;\n     not_MT C ys \\<Longrightarrow>\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     not_MT C (y # ys); \\<not> not_MT C ys; ys = []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (rm_MT_rules C (y # ys))) x\n 2. \\<lbrakk>\\<not> not_MT C ys;\n     not_MT C ys \\<Longrightarrow>\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     not_MT C (y # ys); \\<not> not_MT C ys; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys = []\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy (y # ys)) x =\n    C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "using Cons"], ["proof (prove)\nusing this:\n  ys = []\n  not_MT C ys \\<Longrightarrow>\n  C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x\n  not_MT C (y # ys)\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy (y # ys)) x =\n    C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "by (simp) (rule impI, simp)"], ["proof (state)\nthis:\n  C (list2FWpolicy (y # ys)) x =\n  C (list2FWpolicy (rm_MT_rules C (y # ys))) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> not_MT C ys;\n     not_MT C ys \\<Longrightarrow>\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     not_MT C (y # ys); \\<not> not_MT C ys; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> not_MT C ys;\n     not_MT C ys \\<Longrightarrow>\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     not_MT C (y # ys); \\<not> not_MT C ys; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "case False"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> not_MT C ys;\n     not_MT C ys \\<Longrightarrow>\n     C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x;\n     not_MT C (y # ys); \\<not> not_MT C ys; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (y # ys)) x =\n                      C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy (y # ys)) x =\n    C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "using Cons False \\<open>\\<not> not_MT C ys\\<close>"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  not_MT C ys \\<Longrightarrow>\n  C (list2FWpolicy ys) x = C (list2FWpolicy (rm_MT_rules C ys)) x\n  not_MT C (y # ys)\n  ys \\<noteq> []\n  \\<not> not_MT C ys\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy (y # ys)) x =\n    C (list2FWpolicy (rm_MT_rules C (y # ys))) x", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if dom (C y) = {} then not_MT C ys else True; ys \\<noteq> [];\n     \\<not> not_MT C ys\\<rbrakk>\n    \\<Longrightarrow> (dom (C y) = {} \\<longrightarrow>\n                       C (list2FWpolicy (y # ys)) x =\n                       C (list2FWpolicy (rm_MT_rules C ys)) x) \\<and>\n                      (dom (C y) \\<noteq> {} \\<longrightarrow>\n                       C (list2FWpolicy (y # ys)) x =\n                       C (list2FWpolicy (y # rm_MT_rules C ys)) x)", "by (metis SR3nMT l2p_aux list2FWpolicy.simps(2) nMT_domMT nlpaux)"], ["proof (state)\nthis:\n  C (list2FWpolicy (y # ys)) x =\n  C (list2FWpolicy (rm_MT_rules C (y # ys))) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C (list2FWpolicy (y # ys)) x =\n  C (list2FWpolicy (rm_MT_rules C (y # ys))) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C (list2FWpolicy (y # ys)) x =\n  C (list2FWpolicy (rm_MT_rules C (y # ys))) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_id: \n  \"wellformed_policy1_strong p \\<Longrightarrow>  C(list2FWpolicy (insertDeny p)) = C (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<Longrightarrow>\n    C (list2FWpolicy (insertDeny p)) = C (list2FWpolicy p)", "by (rule ext) (auto intro: C_eq_if_mr_eq elim: mr_iD)"], ["", "lemma C_eq_RS3: \n  \"not_MT C  p \\<Longrightarrow> C(list2FWpolicy (rm_MT_rules C p)) = C (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_MT C p \\<Longrightarrow>\n    C (list2FWpolicy (rm_MT_rules C p)) = C (list2FWpolicy p)", "by (rule ext) (erule C_eq_RS3_aux[symmetric])"], ["", "lemma NMPrd[rule_format]:  \"not_MT C  p \\<longrightarrow> not_MT C  (remdups p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_MT C p \\<longrightarrow> not_MT C (remdups p)", "by (induct p) (auto simp: NMPcharn)"], ["", "lemma NMPDA[rule_format]: \"DenyAll \\<in> set p \\<longrightarrow> not_MT C  p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set p \\<longrightarrow> not_MT C p", "by (induct p, simp_all add: DAnMT)"], ["", "lemma NMPiD[rule_format]: \"not_MT C  (insertDeny p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_MT C (insertDeny p)", "by (simp add: DAiniD NMPDA)"], ["", "lemma list2FWpolicy2list[rule_format]: \"C (list2FWpolicy(policy2list p)) = (C p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C (list2FWpolicy (policy2list p)) = C p", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. C (list2FWpolicy (policy2list p)) x = C p x", "apply (induct_tac p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>C (list2FWpolicy (policy2list x1)) x = C x1 x;\n        C (list2FWpolicy (policy2list x2)) x = C x2 x\\<rbrakk>\n       \\<Longrightarrow> C (list2FWpolicy (policy2list x1 @ policy2list x2))\n                          x =\n                         C (x1 \\<oplus> x2) x", "by (metis (no_types, lifting) Cdom2 CeqEnd CeqStart domIff nlpaux p2lNmt)"], ["", "lemmas C_eq_Lemmas = none_MT_rulesRS2 none_MT_rulesrd  SCp2l  wp1n_RS2  wp1ID NMPiD wp1_eq\n                     wp1alternative_RS1 p2lNmt list2FWpolicy2list wellformed_policy3_charn waux2"], ["", "lemmas C_eq_subst_Lemmas = C_eq_sorted C_eq_sortedQ C_eq_RS2 C_eq_rd C_eq_RS3 C_eq_id"], ["", "lemma C_eq_All_untilSorted: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n    C (list2FWpolicy\n        (FWNormalisationCore.sort\n          (removeShadowRules2 (remdups (rm_MT_rules C \n             (insertDeny (removeShadowRules1 (policy2list p)))))) l)) =\n    C p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (FWNormalisationCore.sort\n                            (removeShadowRules2\n                              (remdups\n                                (rm_MT_rules C\n                                  (insertDeny\n                                    (removeShadowRules1 (policy2list p))))))\n                            l)) =\n                      C p", "apply (subst C_eq_sorted,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (removeShadowRules2\n                            (remdups\n                              (rm_MT_rules C\n                                (insertDeny\n                                  (removeShadowRules1\n                                    (policy2list p))))))) =\n                      C p", "apply (subst C_eq_RS2,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (remdups\n                            (rm_MT_rules C\n                              (insertDeny\n                                (removeShadowRules1 (policy2list p)))))) =\n                      C p", "apply (subst C_eq_rd,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (rm_MT_rules C\n                            (insertDeny\n                              (removeShadowRules1 (policy2list p))))) =\n                      C p", "apply (subst C_eq_RS3,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (insertDeny\n                            (removeShadowRules1 (policy2list p)))) =\n                      C p", "apply (subst C_eq_id,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_eq_All_untilSortedQ: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n    C (list2FWpolicy\n        (qsort (removeShadowRules2 (remdups (rm_MT_rules C \n             (insertDeny (removeShadowRules1 (policy2list p)))))) l)) =\n    C p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (qsort\n                            (removeShadowRules2\n                              (remdups\n                                (rm_MT_rules C\n                                  (insertDeny\n                                    (removeShadowRules1 (policy2list p))))))\n                            l)) =\n                      C p", "apply (subst C_eq_sortedQ,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (removeShadowRules2\n                            (remdups\n                              (rm_MT_rules C\n                                (insertDeny\n                                  (removeShadowRules1\n                                    (policy2list p))))))) =\n                      C p", "apply (subst C_eq_RS2,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (remdups\n                            (rm_MT_rules C\n                              (insertDeny\n                                (removeShadowRules1 (policy2list p)))))) =\n                      C p", "apply (subst C_eq_rd,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (rm_MT_rules C\n                            (insertDeny\n                              (removeShadowRules1 (policy2list p))))) =\n                      C p", "apply (subst C_eq_RS3,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (insertDeny\n                            (removeShadowRules1 (policy2list p)))) =\n                      C p", "apply (subst C_eq_id,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_eq_All_untilSorted_withSimps: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow>all_in_list(policy2list p) l \\<Longrightarrow> allNetsDistinct (policy2list p) \\<Longrightarrow>\n    C (list2FWpolicy\n        (FWNormalisationCore.sort\n          (removeShadowRules2 (remdups (rm_MT_rules C \n              (insertDeny (removeShadowRules1 (policy2list p)))))) l)) =\n    C p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (FWNormalisationCore.sort\n                            (removeShadowRules2\n                              (remdups\n                                (rm_MT_rules C\n                                  (insertDeny\n                                    (removeShadowRules1 (policy2list p))))))\n                            l)) =\n                      C p", "by (simp_all add: C_eq_Lemmas C_eq_subst_Lemmas)"], ["", "lemma C_eq_All_untilSorted_withSimpsQ: \n  \" DenyAll\\<in>set(policy2list p)\\<Longrightarrow>all_in_list(policy2list p) l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n    C (list2FWpolicy\n        (qsort (removeShadowRules2 (remdups (rm_MT_rules C \n             (insertDeny (removeShadowRules1 (policy2list p)))))) l)) =\n    C p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (qsort\n                            (removeShadowRules2\n                              (remdups\n                                (rm_MT_rules C\n                                  (insertDeny\n                                    (removeShadowRules1 (policy2list p))))))\n                            l)) =\n                      C p", "by (simp_all add: C_eq_Lemmas C_eq_subst_Lemmas)"], ["", "lemma InDomConc[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> x \\<in> dom (C (list2FWpolicy (p))) \\<longrightarrow> x \\<in>  dom (C (list2FWpolicy (a#p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (a # p)))", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (a # p))) \\<Longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (aa # p))) \\<longrightarrow>\n       x \\<in> dom (C (a \\<oplus> list2FWpolicy (aa # p)))", "subgoal for a' p"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (a # p))) \\<Longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (a' # p))) \\<longrightarrow>\n    x \\<in> dom (C (a \\<oplus> list2FWpolicy (a' # p)))", "apply  (case_tac \"p = []\", simp_all add: dom_def C.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_in_member[rule_format]: \"member a b \\<longrightarrow> x \\<notin> dom (C b) \\<longrightarrow> x \\<notin> dom (C a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member a b \\<longrightarrow>\n    x \\<notin> dom (C b) \\<longrightarrow> x \\<notin> dom (C a)", "by (induct b) (simp_all add: dom_def C.simps)"], ["", "lemma src_in_sdnets[rule_format]: \n  \"\\<not> member DenyAll x \\<longrightarrow> p \\<in> dom (C x) \\<longrightarrow> subnetsOfAdr (src p) \\<inter> (fst_set (sdnets x)) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> member DenyAll x \\<longrightarrow>\n    p \\<in> dom (C x) \\<longrightarrow>\n    subnetsOfAdr (src p) \\<inter> fst_set (sdnets x) \\<noteq> {}", "apply (induct rule: Combinators.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<not> member DenyAll DenyAll \\<longrightarrow>\n    p \\<in> dom (C DenyAll) \\<longrightarrow>\n    subnetsOfAdr (src p) \\<inter> fst_set (sdnets DenyAll) \\<noteq> {}\n 2. \\<And>x1 x2.\n       \\<not> member DenyAll (DenyAllFromTo x1 x2) \\<longrightarrow>\n       p \\<in> dom (C (DenyAllFromTo x1 x2)) \\<longrightarrow>\n       subnetsOfAdr (src p) \\<inter>\n       fst_set (sdnets (DenyAllFromTo x1 x2)) \\<noteq>\n       {}\n 3. \\<And>x1 x2 x3.\n       \\<not> member DenyAll (AllowPortFromTo x1 x2 x3) \\<longrightarrow>\n       p \\<in> dom (C (AllowPortFromTo x1 x2 x3)) \\<longrightarrow>\n       subnetsOfAdr (src p) \\<inter>\n       fst_set (sdnets (AllowPortFromTo x1 x2 x3)) \\<noteq>\n       {}\n 4. \\<And>x1 x2.\n       \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n                p \\<in> dom (C x1) \\<longrightarrow>\n                subnetsOfAdr (src p) \\<inter> fst_set (sdnets x1) \\<noteq>\n                {};\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        p \\<in> dom (C x2) \\<longrightarrow>\n        subnetsOfAdr (src p) \\<inter> fst_set (sdnets x2) \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> member DenyAll\n                                 (x1 \\<oplus> x2) \\<longrightarrow>\n                         p \\<in> dom (C (x1 \\<oplus> x2)) \\<longrightarrow>\n                         subnetsOfAdr (src p) \\<inter>\n                         fst_set (sdnets (x1 \\<oplus> x2)) \\<noteq>\n                         {}", "apply (simp_all add: fst_set_def subnetsOfAdr_def PLemmas fst_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n                (\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n                {};\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n        {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n        {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> member DenyAll x1 \\<and>\n                         \\<not> member DenyAll x2 \\<longrightarrow>\n                         (\\<exists>y.\n                             (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n                              | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                                  \\<lfloor>x\\<rfloor>) =\n                             \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                         {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                         {a. \\<exists>b.\n                                (a, b) \\<in> sdnets x1 \\<or>\n                                (a, b) \\<in> sdnets x2} \\<noteq>\n                         {}", "apply (intro impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n                (\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n                {};\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n        {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n        {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n        {};\n        \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n        \\<exists>y.\n           (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n            | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n           \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                         {a. \\<exists>b.\n                                (a, b) \\<in> sdnets x1 \\<or>\n                                (a, b) \\<in> sdnets x2} \\<noteq>\n                         {}", "subgoal for x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n             (\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n             {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n             {};\n     \\<not> member DenyAll x2 \\<longrightarrow>\n     (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n     {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                      {a. \\<exists>b.\n                             (a, b) \\<in> sdnets x1 \\<or>\n                             (a, b) \\<in> sdnets x2} \\<noteq>\n                      {}", "apply (case_tac \"p \\<in> dom (C x2)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n             (\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n             {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n             {};\n     \\<not> member DenyAll x2 \\<longrightarrow>\n     (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n     {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<in> dom (C x2)\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                      {a. \\<exists>b.\n                             (a, b) \\<in> sdnets x1 \\<or>\n                             (a, b) \\<in> sdnets x2} \\<noteq>\n                      {}\n 2. \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n             (\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n             {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n             {};\n     \\<not> member DenyAll x2 \\<longrightarrow>\n     (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n     {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<notin> dom (C x2)\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                      {a. \\<exists>b.\n                             (a, b) \\<in> sdnets x1 \\<or>\n                             (a, b) \\<in> sdnets x2} \\<noteq>\n                      {}", "apply (rule subnetAux)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n             (\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n             {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n             {};\n     \\<not> member DenyAll x2 \\<longrightarrow>\n     (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n     {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<in> dom (C x2)\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                      ?A1 \\<noteq>\n                      {}\n 2. \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n             (\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n             {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n             {};\n     \\<not> member DenyAll x2 \\<longrightarrow>\n     (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n     {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<in> dom (C x2)\\<rbrakk>\n    \\<Longrightarrow> ?A1\n                      \\<subseteq> {a. \\<exists>b.\n   (a, b) \\<in> sdnets x1 \\<or> (a, b) \\<in> sdnets x2}\n 3. \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n             (\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n             {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n             {};\n     \\<not> member DenyAll x2 \\<longrightarrow>\n     (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n     {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<notin> dom (C x2)\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                      {a. \\<exists>b.\n                             (a, b) \\<in> sdnets x1 \\<or>\n                             (a, b) \\<in> sdnets x2} \\<noteq>\n                      {}", "apply (auto simp: PLemmas fst_set_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dest_in_sdnets[rule_format]: \n  \"\\<not> member DenyAll x \\<longrightarrow> p \\<in> dom (C x) \\<longrightarrow>  subnetsOfAdr (dest p) \\<inter> (snd_set (sdnets x)) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> member DenyAll x \\<longrightarrow>\n    p \\<in> dom (C x) \\<longrightarrow>\n    subnetsOfAdr (dest p) \\<inter> snd_set (sdnets x) \\<noteq> {}", "apply (induct rule: Combinators.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<not> member DenyAll DenyAll \\<longrightarrow>\n    p \\<in> dom (C DenyAll) \\<longrightarrow>\n    subnetsOfAdr (dest p) \\<inter> snd_set (sdnets DenyAll) \\<noteq> {}\n 2. \\<And>x1 x2.\n       \\<not> member DenyAll (DenyAllFromTo x1 x2) \\<longrightarrow>\n       p \\<in> dom (C (DenyAllFromTo x1 x2)) \\<longrightarrow>\n       subnetsOfAdr (dest p) \\<inter>\n       snd_set (sdnets (DenyAllFromTo x1 x2)) \\<noteq>\n       {}\n 3. \\<And>x1 x2 x3.\n       \\<not> member DenyAll (AllowPortFromTo x1 x2 x3) \\<longrightarrow>\n       p \\<in> dom (C (AllowPortFromTo x1 x2 x3)) \\<longrightarrow>\n       subnetsOfAdr (dest p) \\<inter>\n       snd_set (sdnets (AllowPortFromTo x1 x2 x3)) \\<noteq>\n       {}\n 4. \\<And>x1 x2.\n       \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n                p \\<in> dom (C x1) \\<longrightarrow>\n                subnetsOfAdr (dest p) \\<inter> snd_set (sdnets x1) \\<noteq>\n                {};\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        p \\<in> dom (C x2) \\<longrightarrow>\n        subnetsOfAdr (dest p) \\<inter> snd_set (sdnets x2) \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> member DenyAll\n                                 (x1 \\<oplus> x2) \\<longrightarrow>\n                         p \\<in> dom (C (x1 \\<oplus> x2)) \\<longrightarrow>\n                         subnetsOfAdr (dest p) \\<inter>\n                         snd_set (sdnets (x1 \\<oplus> x2)) \\<noteq>\n                         {}", "apply (simp_all add: snd_set_def subnetsOfAdr_def PLemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n                (\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                {x. \\<exists>s\\<in>x. fst (snd (snd p)) \\<in> s} \\<inter>\n                {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n                {};\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n        {x. \\<exists>s\\<in>x. fst (snd (snd p)) \\<in> s} \\<inter>\n        {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> member DenyAll x1 \\<and>\n                         \\<not> member DenyAll x2 \\<longrightarrow>\n                         (\\<exists>y.\n                             (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n                              | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                                  \\<lfloor>x\\<rfloor>) =\n                             \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                         {x. \\<exists>s\\<in>x.\n                                fst (snd (snd p)) \\<in> s} \\<inter>\n                         {a. \\<exists>b.\n                                (b, a) \\<in> sdnets x1 \\<or>\n                                (b, a) \\<in> sdnets x2} \\<noteq>\n                         {}", "apply (intro impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n                (\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                {x. \\<exists>s\\<in>x. fst (snd (snd p)) \\<in> s} \\<inter>\n                {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n                {};\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n        {x. \\<exists>s\\<in>x. fst (snd (snd p)) \\<in> s} \\<inter>\n        {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n        {};\n        \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n        \\<exists>y.\n           (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n            | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n           \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> {x. \\<exists>s\\<in>x.\n                                fst (snd (snd p)) \\<in> s} \\<inter>\n                         {a. \\<exists>b.\n                                (b, a) \\<in> sdnets x1 \\<or>\n                                (b, a) \\<in> sdnets x2} \\<noteq>\n                         {}", "apply (simp add: snd_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n                {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n                {};\n        (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n        {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n        {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n        {};\n        \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n        \\<exists>y.\n           (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n            | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n           \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> {x. \\<exists>s\\<in>x.\n                                fst (snd (snd p)) \\<in> s} \\<inter>\n                         {a. \\<exists>b.\n                                (b, a) \\<in> sdnets x1 \\<or>\n                                (b, a) \\<in> sdnets x2} \\<noteq>\n                         {}", "subgoal for x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n             {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n     {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x.\n                             fst (snd (snd p)) \\<in> s} \\<inter>\n                      {a. \\<exists>b.\n                             (b, a) \\<in> sdnets x1 \\<or>\n                             (b, a) \\<in> sdnets x2} \\<noteq>\n                      {}", "apply (case_tac \"p \\<in> dom (C x2)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n             {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n     {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<in> dom (C x2)\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x.\n                             fst (snd (snd p)) \\<in> s} \\<inter>\n                      {a. \\<exists>b.\n                             (b, a) \\<in> sdnets x1 \\<or>\n                             (b, a) \\<in> sdnets x2} \\<noteq>\n                      {}\n 2. \\<lbrakk>(\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n             {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n     {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<notin> dom (C x2)\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x.\n                             fst (snd (snd p)) \\<in> s} \\<inter>\n                      {a. \\<exists>b.\n                             (b, a) \\<in> sdnets x1 \\<or>\n                             (b, a) \\<in> sdnets x2} \\<noteq>\n                      {}", "apply (rule subnetAux)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n             {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n     {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<in> dom (C x2)\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x.\n                             fst (snd (snd p)) \\<in> s} \\<inter>\n                      ?A1 \\<noteq>\n                      {}\n 2. \\<lbrakk>(\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n             {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n     {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<in> dom (C x2)\\<rbrakk>\n    \\<Longrightarrow> ?A1\n                      \\<subseteq> {a. \\<exists>b.\n   (b, a) \\<in> sdnets x1 \\<or> (b, a) \\<in> sdnets x2}\n 3. \\<lbrakk>(\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n             {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n     {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<notin> dom (C x2)\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x.\n                             fst (snd (snd p)) \\<in> s} \\<inter>\n                      {a. \\<exists>b.\n                             (b, a) \\<in> sdnets x1 \\<or>\n                             (b, a) \\<in> sdnets x2} \\<noteq>\n                      {}", "apply (auto simp: PLemmas)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sdnets_in_subnets[rule_format]: \n  \"p\\<in> dom (C x) \\<longrightarrow> \\<not> member DenyAll x \\<longrightarrow>\n        (\\<exists> (a,b)\\<in>sdnets x. a \\<in> subnetsOfAdr (src p) \\<and> b \\<in> subnetsOfAdr (dest p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> dom (C x) \\<longrightarrow>\n    \\<not> member DenyAll x \\<longrightarrow>\n    (\\<exists>(a, b)\\<in>sdnets x.\n        a \\<in> subnetsOfAdr (src p) \\<and> b \\<in> subnetsOfAdr (dest p))", "apply (rule Combinators.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. p \\<in> dom (C DenyAll) \\<longrightarrow>\n    \\<not> member DenyAll DenyAll \\<longrightarrow>\n    (\\<exists>a\\<in>sdnets DenyAll.\n        case a of\n        (a, b) \\<Rightarrow>\n          a \\<in> subnetsOfAdr (src p) \\<and> b \\<in> subnetsOfAdr (dest p))\n 2. \\<And>x1 x2.\n       p \\<in> dom (C (DenyAllFromTo x1 x2)) \\<longrightarrow>\n       \\<not> member DenyAll (DenyAllFromTo x1 x2) \\<longrightarrow>\n       (\\<exists>a\\<in>sdnets (DenyAllFromTo x1 x2).\n           case a of\n           (a, b) \\<Rightarrow>\n             a \\<in> subnetsOfAdr (src p) \\<and>\n             b \\<in> subnetsOfAdr (dest p))\n 3. \\<And>x1 x2 x3.\n       p \\<in> dom (C (AllowPortFromTo x1 x2 x3)) \\<longrightarrow>\n       \\<not> member DenyAll (AllowPortFromTo x1 x2 x3) \\<longrightarrow>\n       (\\<exists>a\\<in>sdnets (AllowPortFromTo x1 x2 x3).\n           case a of\n           (a, b) \\<Rightarrow>\n             a \\<in> subnetsOfAdr (src p) \\<and>\n             b \\<in> subnetsOfAdr (dest p))\n 4. \\<And>x1 x2.\n       \\<lbrakk>p \\<in> dom (C x1) \\<longrightarrow>\n                \\<not> member DenyAll x1 \\<longrightarrow>\n                (\\<exists>a\\<in>sdnets x1.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      a \\<in> subnetsOfAdr (src p) \\<and>\n                      b \\<in> subnetsOfAdr (dest p));\n        p \\<in> dom (C x2) \\<longrightarrow>\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        (\\<exists>a\\<in>sdnets x2.\n            case a of\n            (a, b) \\<Rightarrow>\n              a \\<in> subnetsOfAdr (src p) \\<and>\n              b \\<in> subnetsOfAdr (dest p))\\<rbrakk>\n       \\<Longrightarrow> p \\<in> dom (C (x1 \\<oplus> x2)) \\<longrightarrow>\n                         \\<not> member DenyAll\n                                 (x1 \\<oplus> x2) \\<longrightarrow>\n                         (\\<exists>a\\<in>sdnets (x1 \\<oplus> x2).\n                             case a of\n                             (a, b) \\<Rightarrow>\n                               a \\<in> subnetsOfAdr (src p) \\<and>\n                               b \\<in> subnetsOfAdr (dest p))", "apply (simp_all add: PLemmas subnetsOfAdr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                \\<not> member DenyAll x1 \\<longrightarrow>\n                (\\<exists>x\\<in>sdnets x1.\n                    case x of\n                    (a, b) \\<Rightarrow>\n                      (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                      (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n        (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        (\\<exists>x\\<in>sdnets x2.\n            case x of\n            (a, b) \\<Rightarrow>\n              (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n              (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y.\n                             (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n                              | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                                  \\<lfloor>x\\<rfloor>) =\n                             \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                         \\<not> member DenyAll x1 \\<and>\n                         \\<not> member DenyAll x2 \\<longrightarrow>\n                         (\\<exists>x\\<in>sdnets x1 \\<union> sdnets x2.\n                             case x of\n                             (a, b) \\<Rightarrow>\n                               (\\<exists>x\\<in>a.\n                                   fst (snd p) \\<in> x) \\<and>\n                               (\\<exists>x\\<in>b.\n                                   fst (snd (snd p)) \\<in> x))", "apply (intro impI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                (\\<exists>x\\<in>sdnets x1.\n                    case x of\n                    (a, b) \\<Rightarrow>\n                      (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                      (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n        (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n        (\\<exists>x\\<in>sdnets x2.\n            case x of\n            (a, b) \\<Rightarrow>\n              (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n              (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n        \\<exists>y.\n           (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n            | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n           \\<lfloor>y\\<rfloor>;\n        \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>sdnets x1 \\<union> sdnets x2.\n                            case x of\n                            (a, b) \\<Rightarrow>\n                              (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                              (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x)", "subgoal for x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             (\\<exists>x\\<in>sdnets x1.\n                 case x of\n                 (a, b) \\<Rightarrow>\n                   (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                   (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n     (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     (\\<exists>x\\<in>sdnets x2.\n         case x of\n         (a, b) \\<Rightarrow>\n           (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n           (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n     \\<exists>y.\n        (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>sdnets x1 \\<union> sdnets x2.\n                         case x of\n                         (a, b) \\<Rightarrow>\n                           (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                           (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x)", "apply (case_tac \"p \\<in> dom (C (x2))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             (\\<exists>x\\<in>sdnets x1.\n                 case x of\n                 (a, b) \\<Rightarrow>\n                   (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                   (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n     (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     (\\<exists>x\\<in>sdnets x2.\n         case x of\n         (a, b) \\<Rightarrow>\n           (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n           (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n     \\<exists>y.\n        (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     p \\<in> dom (C x2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>sdnets x1 \\<union> sdnets x2.\n                         case x of\n                         (a, b) \\<Rightarrow>\n                           (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                           (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x)\n 2. \\<lbrakk>(\\<exists>y. C x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             (\\<exists>x\\<in>sdnets x1.\n                 case x of\n                 (a, b) \\<Rightarrow>\n                   (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                   (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n     (\\<exists>y. C x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     (\\<exists>x\\<in>sdnets x2.\n         case x of\n         (a, b) \\<Rightarrow>\n           (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n           (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n     \\<exists>y.\n        (case C x2 p of \\<bottom> \\<Rightarrow> C x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     p \\<notin> dom (C x2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>sdnets x1 \\<union> sdnets x2.\n                         case x of\n                         (a, b) \\<Rightarrow>\n                           (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                           (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x)", "apply (auto simp: PLemmas subnetsOfAdr_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma disjSD_no_p_in_both[rule_format]:   \n  \"disjSD_2 x y \\<Longrightarrow> \\<not> member DenyAll x \\<Longrightarrow> \\<not> member DenyAll y \\<Longrightarrow> p \\<in> dom(C x) \\<Longrightarrow> p \\<in> dom(C y) \\<Longrightarrow> \n  False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>disjSD_2 x y; \\<not> member DenyAll x; \\<not> member DenyAll y;\n     p \\<in> dom (C x); p \\<in> dom (C y)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule_tac A = \"sdnets x\" and B = \"sdnets y\" and D = \"src p\" and F = \"dest p\" in tndFalse)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>disjSD_2 x y; \\<not> member DenyAll x; \\<not> member DenyAll y;\n     p \\<in> dom (C x); p \\<in> dom (C y)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b c d.\n                         (a, b) \\<in> sdnets x \\<and>\n                         (c, d) \\<in> sdnets y \\<longrightarrow>\n                         twoNetsDistinct a b c d\n 2. \\<lbrakk>disjSD_2 x y; \\<not> member DenyAll x; \\<not> member DenyAll y;\n     p \\<in> dom (C x); p \\<in> dom (C y)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(a, b)\\<in>sdnets x.\n                         a \\<in> subnetsOfAdr (src p) \\<and>\n                         b \\<in> subnetsOfAdr (dest p)\n 3. \\<lbrakk>disjSD_2 x y; \\<not> member DenyAll x; \\<not> member DenyAll y;\n     p \\<in> dom (C x); p \\<in> dom (C y)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(a, b)\\<in>sdnets y.\n                         a \\<in> subnetsOfAdr (src p) \\<and>\n                         b \\<in> subnetsOfAdr (dest p)", "by (auto simp: dest_in_sdnets src_in_sdnets sdnets_in_subnets disjSD_2_def)"], ["", "lemma list2FWpolicy_eq: \n  \"zs \\<noteq> [] \\<Longrightarrow>  C (list2FWpolicy (x \\<oplus> y # z)) p = C (x \\<oplus> list2FWpolicy (y # z)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zs \\<noteq> [] \\<Longrightarrow>\n    C (list2FWpolicy (x \\<oplus> y # z)) p =\n    C (x \\<oplus> list2FWpolicy (y # z)) p", "by (metis ConcAssoc l2p_aux list2FWpolicy.simps(2))"], ["", "lemma dom_sep[rule_format]: \n  \"x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow> x \\<in> dom (C (list2FWpolicy(separate p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (separate p)))", "proof (induct p rule: separate.induct, simp_all, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (DenyAllFromTo v va \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   (DenyAllFromTo v va \\<oplus> y # z))));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (DenyAllFromTo v va # separate (y # z)))))\n 2. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (AllowPortFromTo v va vb \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   (AllowPortFromTo v va vb \\<oplus> y #\n                                    z))));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy\n    (separate (AllowPortFromTo v va vb \\<oplus> y # z))))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (AllowPortFromTo v va vb # separate (y # z)))))\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 ((v \\<oplus> va) \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "case (1 v va y z)"], ["proof (state)\nthis:\n  {v, va} = first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (C (list2FWpolicy\n                   (DenyAllFromTo v va \\<oplus> y # z))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy\n                   (separate (DenyAllFromTo v va \\<oplus> y # z))))\n  {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (separate (y # z))))\n\ngoal (3 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (DenyAllFromTo v va \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   (DenyAllFromTo v va \\<oplus> y # z))));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (DenyAllFromTo v va # separate (y # z)))))\n 2. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (AllowPortFromTo v va vb \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   (AllowPortFromTo v va vb \\<oplus> y #\n                                    z))));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy\n    (separate (AllowPortFromTo v va vb \\<oplus> y # z))))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (AllowPortFromTo v va vb # separate (y # z)))))\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 ((v \\<oplus> va) \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "then"], ["proof (chain)\npicking this:\n  {v, va} = first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (C (list2FWpolicy\n                   (DenyAllFromTo v va \\<oplus> y # z))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy\n                   (separate (DenyAllFromTo v va \\<oplus> y # z))))\n  {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (separate (y # z))))", "show ?case"], ["proof (prove)\nusing this:\n  {v, va} = first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (C (list2FWpolicy\n                   (DenyAllFromTo v va \\<oplus> y # z))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy\n                   (separate (DenyAllFromTo v va \\<oplus> y # z))))\n  {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (separate (y # z))))\n\ngoal (1 subgoal):\n 1. ({v, va} = first_bothNet y \\<longrightarrow>\n     x \\<in> dom (C (DenyAllFromTo v va \\<oplus>\n                     list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (separate\n                        (DenyAllFromTo v va \\<oplus> y # z))))) \\<and>\n    ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n     x \\<in> dom (C (DenyAllFromTo v va \\<oplus>\n                     list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo v va # separate (y # z)))))", "apply (intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (DenyAllFromTo v va \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate\n                                (DenyAllFromTo v va \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     {v, va} = first_bothNet y;\n     x \\<in> dom (C (DenyAllFromTo v va \\<oplus>\n                     list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (separate (DenyAllFromTo v va \\<oplus> y # z))))\n 2. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (DenyAllFromTo v va \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate\n                                (DenyAllFromTo v va \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (C (DenyAllFromTo v va \\<oplus>\n                     list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (DenyAllFromTo v va # separate (y # z))))", "apply (simp,drule mp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (C (DenyAllFromTo v va \\<oplus>\n                     list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (DenyAllFromTo v va \\<oplus> y # z)))\n 2. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (C (list2FWpolicy\n                      (separate\n                        (DenyAllFromTo v va \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (separate (DenyAllFromTo v va \\<oplus> y # z))))\n 3. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (DenyAllFromTo v va \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate\n                                (DenyAllFromTo v va \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (C (DenyAllFromTo v va \\<oplus>\n                     list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (DenyAllFromTo v va # separate (y # z))))", "apply (case_tac \"x \\<in> dom (C (DenyAllFromTo v va))\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (C (DenyAllFromTo v va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (DenyAllFromTo v va \\<oplus> y # z)))\n 2. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (C (DenyAllFromTo v va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (DenyAllFromTo v va \\<oplus> y # z)))\n 3. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (C (list2FWpolicy\n                      (separate\n                        (DenyAllFromTo v va \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (separate (DenyAllFromTo v va \\<oplus> y # z))))\n 4. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (DenyAllFromTo v va \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate\n                                (DenyAllFromTo v va \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (C (DenyAllFromTo v va \\<oplus>\n                     list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (DenyAllFromTo v va # separate (y # z))))", "apply (metis CConcStartA domIff l2p_aux2 list2FWpolicyconc not_Cons_self )"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (C (DenyAllFromTo v va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (DenyAllFromTo v va \\<oplus> y # z)))\n 2. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (C (list2FWpolicy\n                      (separate\n                        (DenyAllFromTo v va \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (separate (DenyAllFromTo v va \\<oplus> y # z))))\n 3. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (DenyAllFromTo v va \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate\n                                (DenyAllFromTo v va \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (C (DenyAllFromTo v va \\<oplus>\n                     list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (DenyAllFromTo v va # separate (y # z))))", "apply (metis Conc_not_MT domIff list2FWpolicy_eq, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (DenyAllFromTo v va \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate\n                                (DenyAllFromTo v va \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (C (DenyAllFromTo v va \\<oplus>\n                     list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (DenyAllFromTo v va # separate (y # z))))", "by (metis InDomConc domIff list.simps(3) list2FWpolicyconc nlpaux sepnMT)"], ["proof (state)\nthis:\n  ({v, va} = first_bothNet y \\<longrightarrow>\n   x \\<in> dom (C (DenyAllFromTo v va \\<oplus>\n                   list2FWpolicy (y # z))) \\<longrightarrow>\n   x \\<in> dom (C (list2FWpolicy\n                    (separate (DenyAllFromTo v va \\<oplus> y # z))))) \\<and>\n  ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n   x \\<in> dom (C (DenyAllFromTo v va \\<oplus>\n                   list2FWpolicy (y # z))) \\<longrightarrow>\n   x \\<in> dom (C (list2FWpolicy (DenyAllFromTo v va # separate (y # z)))))\n\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (AllowPortFromTo v va vb \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   (AllowPortFromTo v va vb \\<oplus> y #\n                                    z))));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy\n    (separate (AllowPortFromTo v va vb \\<oplus> y # z))))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (AllowPortFromTo v va vb # separate (y # z)))))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 ((v \\<oplus> va) \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (AllowPortFromTo v va vb \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   (AllowPortFromTo v va vb \\<oplus> y #\n                                    z))));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy\n    (separate (AllowPortFromTo v va vb \\<oplus> y # z))))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (AllowPortFromTo v va vb # separate (y # z)))))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 ((v \\<oplus> va) \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "case (2 v va vb y z)"], ["proof (state)\nthis:\n  {v, va} = first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (C (list2FWpolicy\n                   (AllowPortFromTo v va vb \\<oplus> y #\n                    z))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy\n                   (separate (AllowPortFromTo v va vb \\<oplus> y # z))))\n  {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (separate (y # z))))\n\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (AllowPortFromTo v va vb \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   (AllowPortFromTo v va vb \\<oplus> y #\n                                    z))));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy\n    (separate (AllowPortFromTo v va vb \\<oplus> y # z))))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (AllowPortFromTo v va vb # separate (y # z)))))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 ((v \\<oplus> va) \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "assume * : \"{v, va} = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy (separate (AllowPortFromTo v va vb \\<oplus> y # z))))\"\n    and    **: \"{v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n              x \\<in> dom(C(list2FWpolicy(y#z))) \\<longrightarrow> x \\<in> dom (C(list2FWpolicy(separate(y#z))))\""], ["proof (state)\nthis:\n  {v, va} = first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (C (list2FWpolicy\n                   (AllowPortFromTo v va vb \\<oplus> y #\n                    z))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy\n                   (separate (AllowPortFromTo v va vb \\<oplus> y # z))))\n  {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (separate (y # z))))\n\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (AllowPortFromTo v va vb \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   (AllowPortFromTo v va vb \\<oplus> y #\n                                    z))));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy\n    (separate (AllowPortFromTo v va vb \\<oplus> y # z))))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (AllowPortFromTo v va vb # separate (y # z)))))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 ((v \\<oplus> va) \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({v, va} = first_bothNet y \\<longrightarrow>\n     x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\n                     list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (separate\n                        (AllowPortFromTo v va vb \\<oplus> y # z))))) \\<and>\n    ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n     x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\n                     list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (AllowPortFromTo v va vb # separate (y # z)))))", "apply (insert * **, rule impI | rule conjI)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (AllowPortFromTo v va vb \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate\n                                (AllowPortFromTo v va vb \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     {v, va} = first_bothNet y;\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (AllowPortFromTo v va vb \\<oplus> y #\n                       z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (separate (AllowPortFromTo v va vb \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\n                     list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (separate (AllowPortFromTo v va vb \\<oplus> y # z))))\n 2. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (AllowPortFromTo v va vb \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate\n                                (AllowPortFromTo v va vb \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (AllowPortFromTo v va vb \\<oplus> y #\n                       z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (separate (AllowPortFromTo v va vb \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n    \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                      x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\nlist2FWpolicy (y # z))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (AllowPortFromTo v va vb # separate (y # z))))", "apply (simp,case_tac \"x \\<in> dom (C (AllowPortFromTo v va vb))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (C (list2FWpolicy\n                      (AllowPortFromTo v va vb \\<oplus> y #\n                       z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (separate (AllowPortFromTo v va vb \\<oplus> y # z))));\n     x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\n                     list2FWpolicy (y # z)));\n     x \\<in> dom (C (AllowPortFromTo v va vb))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (separate (AllowPortFromTo v va vb \\<oplus> y # z))))\n 2. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (C (list2FWpolicy\n                      (AllowPortFromTo v va vb \\<oplus> y #\n                       z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (separate (AllowPortFromTo v va vb \\<oplus> y # z))));\n     x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\n                     list2FWpolicy (y # z)));\n     x \\<notin> dom (C (AllowPortFromTo v va vb))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (separate (AllowPortFromTo v va vb \\<oplus> y # z))))\n 3. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (AllowPortFromTo v va vb \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate\n                                (AllowPortFromTo v va vb \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (AllowPortFromTo v va vb \\<oplus> y #\n                       z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (separate (AllowPortFromTo v va vb \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n    \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                      x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\nlist2FWpolicy (y # z))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (AllowPortFromTo v va vb # separate (y # z))))", "apply (metis CConcStartA domIff  l2p_aux2 list2FWpolicyconc not_Cons_self )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (C (list2FWpolicy\n                      (AllowPortFromTo v va vb \\<oplus> y #\n                       z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (separate (AllowPortFromTo v va vb \\<oplus> y # z))));\n     x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\n                     list2FWpolicy (y # z)));\n     x \\<notin> dom (C (AllowPortFromTo v va vb))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (separate (AllowPortFromTo v va vb \\<oplus> y # z))))\n 2. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (AllowPortFromTo v va vb \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate\n                                (AllowPortFromTo v va vb \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (AllowPortFromTo v va vb \\<oplus> y #\n                       z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (separate (AllowPortFromTo v va vb \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n    \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                      x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\nlist2FWpolicy (y # z))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (AllowPortFromTo v va vb # separate (y # z))))", "apply (subgoal_tac \"x \\<in> dom (C (list2FWpolicy (y #z)))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (C (list2FWpolicy\n                      (AllowPortFromTo v va vb \\<oplus> y #\n                       z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (separate (AllowPortFromTo v va vb \\<oplus> y # z))));\n     x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\n                     list2FWpolicy (y # z)));\n     x \\<notin> dom (C (AllowPortFromTo v va vb));\n     x \\<in> dom (C (list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (separate (AllowPortFromTo v va vb \\<oplus> y # z))))\n 2. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (C (list2FWpolicy\n                      (AllowPortFromTo v va vb \\<oplus> y #\n                       z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (separate (AllowPortFromTo v va vb \\<oplus> y # z))));\n     x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\n                     list2FWpolicy (y # z)));\n     x \\<notin> dom (C (AllowPortFromTo v va vb))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy (y # z)))\n 3. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (AllowPortFromTo v va vb \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate\n                                (AllowPortFromTo v va vb \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (AllowPortFromTo v va vb \\<oplus> y #\n                       z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (separate (AllowPortFromTo v va vb \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n    \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                      x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\nlist2FWpolicy (y # z))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (AllowPortFromTo v va vb # separate (y # z))))", "apply (metis CConcStartA Cdom2 domIff l2p_aux2 list2FWpolicyconc nlpaux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (C (list2FWpolicy\n                      (AllowPortFromTo v va vb \\<oplus> y #\n                       z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (separate (AllowPortFromTo v va vb \\<oplus> y # z))));\n     x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\n                     list2FWpolicy (y # z)));\n     x \\<notin> dom (C (AllowPortFromTo v va vb))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy (y # z)))\n 2. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (AllowPortFromTo v va vb \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate\n                                (AllowPortFromTo v va vb \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (AllowPortFromTo v va vb \\<oplus> y #\n                       z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (separate (AllowPortFromTo v va vb \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n    \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                      x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\nlist2FWpolicy (y # z))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (AllowPortFromTo v va vb # separate (y # z))))", "apply (simp add: dom_def C.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (AllowPortFromTo v va vb \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate\n                                (AllowPortFromTo v va vb \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (AllowPortFromTo v va vb \\<oplus> y #\n                       z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (separate (AllowPortFromTo v va vb \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n    \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                      x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\nlist2FWpolicy (y # z))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (AllowPortFromTo v va vb # separate (y # z))))", "apply (intro impI, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\n                     list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (AllowPortFromTo v va vb # separate (y # z))))", "apply (case_tac \"x \\<in> dom (C (AllowPortFromTo v va vb))\",simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\n                     list2FWpolicy (y # z)));\n     x \\<notin> dom (C (AllowPortFromTo v va vb))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (AllowPortFromTo v va vb # separate (y # z))))", "by (metis Cdom2 domIff l2p_aux list2FWpolicy.simps(3) nlpaux sepnMT)"], ["proof (state)\nthis:\n  ({v, va} = first_bothNet y \\<longrightarrow>\n   x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\n                   list2FWpolicy (y # z))) \\<longrightarrow>\n   x \\<in> dom (C (list2FWpolicy\n                    (separate\n                      (AllowPortFromTo v va vb \\<oplus> y # z))))) \\<and>\n  ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n   x \\<in> dom (C (AllowPortFromTo v va vb \\<oplus>\n                   list2FWpolicy (y # z))) \\<longrightarrow>\n   x \\<in> dom (C (list2FWpolicy\n                    (AllowPortFromTo v va vb # separate (y # z)))))\n\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 ((v \\<oplus> va) \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 ((v \\<oplus> va) \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "case (3 v va y z)"], ["proof (state)\nthis:\n  first_bothNet v = first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (C (list2FWpolicy\n                   ((v \\<oplus> va) \\<oplus> y # z))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy\n                   (separate ((v \\<oplus> va) \\<oplus> y # z))))\n  first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (separate (y # z))))\n\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 ((v \\<oplus> va) \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "assume * : \"(first_bothNet v = first_bothNet y \\<Longrightarrow> \n                x \\<in> dom (C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z))) \\<longrightarrow> \n                x \\<in> dom (C (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z)))))\"\n    and  ** : \"(first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow> \n                x \\<in> dom(C(list2FWpolicy(y#z))) \\<longrightarrow> x \\<in> dom (C (list2FWpolicy (separate (y # z)))))\""], ["proof (state)\nthis:\n  first_bothNet v = first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (C (list2FWpolicy\n                   ((v \\<oplus> va) \\<oplus> y # z))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy\n                   (separate ((v \\<oplus> va) \\<oplus> y # z))))\n  first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (separate (y # z))))\n\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 ((v \\<oplus> va) \\<oplus> y #\n                                  z))) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (separate\n                                   ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (C\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (C\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (first_bothNet v = first_bothNet y \\<longrightarrow>\n     x \\<in> dom (C ((v \\<oplus> va) \\<oplus>\n                     list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n    (first_bothNet v \\<noteq> first_bothNet y \\<longrightarrow>\n     x \\<in> dom (C ((v \\<oplus> va) \\<oplus>\n                     list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "apply (insert * **, rule conjI | rule impI)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              ((v \\<oplus> va) \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate ((v \\<oplus> va) \\<oplus> y # z))));\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))));\n     first_bothNet v = first_bothNet y;\n     x \\<in> dom (C ((v \\<oplus> va) \\<oplus>\n                     list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (separate ((v \\<oplus> va) \\<oplus> y # z))))\n 2. \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              ((v \\<oplus> va) \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate ((v \\<oplus> va) \\<oplus> y # z))));\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n    \\<Longrightarrow> first_bothNet v \\<noteq>\n                      first_bothNet y \\<longrightarrow>\n                      x \\<in> dom (C ((v \\<oplus> va) \\<oplus>\nlist2FWpolicy (y # z))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (v \\<oplus> va # separate (y # z))))", "apply (simp,drule mp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (C ((v \\<oplus> va) \\<oplus>\n                     list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n ((v \\<oplus> va) \\<oplus> y # z)))\n 2. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (C (list2FWpolicy\n                      (separate ((v \\<oplus> va) \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (separate ((v \\<oplus> va) \\<oplus> y # z))))\n 3. \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              ((v \\<oplus> va) \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate ((v \\<oplus> va) \\<oplus> y # z))));\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n    \\<Longrightarrow> first_bothNet v \\<noteq>\n                      first_bothNet y \\<longrightarrow>\n                      x \\<in> dom (C ((v \\<oplus> va) \\<oplus>\nlist2FWpolicy (y # z))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (v \\<oplus> va # separate (y # z))))", "apply (case_tac \"x \\<in> dom (C ((v \\<oplus> va)))\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (C (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n ((v \\<oplus> va) \\<oplus> y # z)))\n 2. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (C (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n ((v \\<oplus> va) \\<oplus> y # z)))\n 3. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (C (list2FWpolicy\n                      (separate ((v \\<oplus> va) \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (separate ((v \\<oplus> va) \\<oplus> y # z))))\n 4. \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              ((v \\<oplus> va) \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate ((v \\<oplus> va) \\<oplus> y # z))));\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n    \\<Longrightarrow> first_bothNet v \\<noteq>\n                      first_bothNet y \\<longrightarrow>\n                      x \\<in> dom (C ((v \\<oplus> va) \\<oplus>\nlist2FWpolicy (y # z))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (v \\<oplus> va # separate (y # z))))", "apply (metis C.simps(4) CConcStartA ConcAssoc domIff list2FWpolicy2list list2FWpolicyconc  p2lNmt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (C (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n ((v \\<oplus> va) \\<oplus> y # z)))\n 2. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (C (list2FWpolicy\n                      (separate ((v \\<oplus> va) \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (separate ((v \\<oplus> va) \\<oplus> y # z))))\n 3. \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              ((v \\<oplus> va) \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate ((v \\<oplus> va) \\<oplus> y # z))));\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n    \\<Longrightarrow> first_bothNet v \\<noteq>\n                      first_bothNet y \\<longrightarrow>\n                      x \\<in> dom (C ((v \\<oplus> va) \\<oplus>\nlist2FWpolicy (y # z))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (v \\<oplus> va # separate (y # z))))", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (C (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n ((v \\<oplus> va) \\<oplus> y # z)))\n 2. \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              ((v \\<oplus> va) \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate ((v \\<oplus> va) \\<oplus> y # z))));\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n    \\<Longrightarrow> first_bothNet v \\<noteq>\n                      first_bothNet y \\<longrightarrow>\n                      x \\<in> dom (C ((v \\<oplus> va) \\<oplus>\nlist2FWpolicy (y # z))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (v \\<oplus> va # separate (y # z))))", "apply (metis Conc_not_MT domIff list2FWpolicy_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              ((v \\<oplus> va) \\<oplus> y #\n                               z))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (separate ((v \\<oplus> va) \\<oplus> y # z))));\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (separate (y # z))))\\<rbrakk>\n    \\<Longrightarrow> first_bothNet v \\<noteq>\n                      first_bothNet y \\<longrightarrow>\n                      x \\<in> dom (C ((v \\<oplus> va) \\<oplus>\nlist2FWpolicy (y # z))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (v \\<oplus> va # separate (y # z))))", "by (metis CConcStartA Conc_not_MT InDomConc domIff nlpaux sepnMT)"], ["proof (state)\nthis:\n  (first_bothNet v = first_bothNet y \\<longrightarrow>\n   x \\<in> dom (C ((v \\<oplus> va) \\<oplus>\n                   list2FWpolicy (y # z))) \\<longrightarrow>\n   x \\<in> dom (C (list2FWpolicy\n                    (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n  (first_bothNet v \\<noteq> first_bothNet y \\<longrightarrow>\n   x \\<in> dom (C ((v \\<oplus> va) \\<oplus>\n                   list2FWpolicy (y # z))) \\<longrightarrow>\n   x \\<in> dom (C (list2FWpolicy (v \\<oplus> va # separate (y # z)))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma domdConcStart[rule_format]: \n  \"x \\<in> dom (C (list2FWpolicy (a#b))) \\<longrightarrow> x \\<notin> dom (C (list2FWpolicy b)) \\<longrightarrow> x \\<in> dom (C (a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C (list2FWpolicy (a # b))) \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy b)) \\<longrightarrow> x \\<in> dom (C a)", "by (induct b, simp_all) (auto simp: PLemmas)"], ["", "lemma sep_dom2_aux: \n  \" x \\<in> dom (C (list2FWpolicy (a \\<oplus> y # z))) \\<Longrightarrow> x \\<in> dom (C (a \\<oplus> list2FWpolicy (y # z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C (list2FWpolicy (a \\<oplus> y # z))) \\<Longrightarrow>\n    x \\<in> dom (C (a \\<oplus> list2FWpolicy (y # z)))", "by (auto)[1] (metis list2FWpolicy_eq p2lNmt)"], ["", "lemma sep_dom2_aux2: \n  \"x \\<in> dom (C (list2FWpolicy (separate (y # z)))) \\<longrightarrow> x \\<in> dom (C (list2FWpolicy (y # z))) \\<Longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (a # separate (y # z)))) \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy (a \\<oplus> y # z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (C (list2FWpolicy\n                              (separate (y # z)))) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (y # z)));\n     x \\<in> dom (C (list2FWpolicy (a # separate (y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy (a \\<oplus> y # z)))", "by (metis CConcStartA InDomConc domdConcStart list.simps(2) list2FWpolicy.simps(2) list2FWpolicyconc)"], ["", "lemma sep_dom2[rule_format]: \n  \"x \\<in> dom (C (list2FWpolicy (separate p))) \\<longrightarrow> x \\<in> dom (C (list2FWpolicy( p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C (list2FWpolicy (separate p))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy p))", "by (rule separate.induct) (simp_all add: sep_dom2_aux sep_dom2_aux2)"], ["", "lemma sepDom: \"dom (C (list2FWpolicy p)) = dom (C (list2FWpolicy (separate p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (C (list2FWpolicy p)) = dom (C (list2FWpolicy (separate p)))", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dom (C (list2FWpolicy p))\n    \\<subseteq> dom (C (list2FWpolicy (separate p)))\n 2. dom (C (list2FWpolicy (separate p)))\n    \\<subseteq> dom (C (list2FWpolicy p))", "by (rule subsetI, (erule dom_sep|erule sep_dom2))+"], ["", "lemma C_eq_s_ext[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow>  C (list2FWpolicy (separate p)) a  = C (list2FWpolicy p) a \""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate p)) a = C (list2FWpolicy p) a", "proof (induct rule: separate.induct, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x.\n       x \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate x)) a =\n       C (list2FWpolicy x) a \\<Longrightarrow>\n       DenyAll # x \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate (DenyAll # x))) a =\n       C (list2FWpolicy (DenyAll # x)) a\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (DenyAllFromTo v va) =\n                first_bothNet y \\<Longrightarrow>\n                DenyAllFromTo v va \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate (DenyAllFromTo v va \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n        first_bothNet (DenyAllFromTo v va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> DenyAllFromTo v va # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (DenyAllFromTo v va # y # z)))\n                          a =\n                         C (list2FWpolicy (DenyAllFromTo v va # y # z)) a\n 3. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                AllowPortFromTo v va vb \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))\n                 a;\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo v va vb # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (AllowPortFromTo v va vb # y # z)))\n                          a =\n                         C (list2FWpolicy (AllowPortFromTo v va vb # y # z))\n                          a\n 4. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (v \\<oplus> va # y # z)))\n                          a =\n                         C (list2FWpolicy (v \\<oplus> va # y # z)) a\n 5. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [])) a = C (list2FWpolicy []) a\n 6. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 7. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 8. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "case (1 x)"], ["proof (state)\nthis:\n  x \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a\n\ngoal (8 subgoals):\n 1. \\<And>x.\n       x \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate x)) a =\n       C (list2FWpolicy x) a \\<Longrightarrow>\n       DenyAll # x \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate (DenyAll # x))) a =\n       C (list2FWpolicy (DenyAll # x)) a\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (DenyAllFromTo v va) =\n                first_bothNet y \\<Longrightarrow>\n                DenyAllFromTo v va \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate (DenyAllFromTo v va \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n        first_bothNet (DenyAllFromTo v va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> DenyAllFromTo v va # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (DenyAllFromTo v va # y # z)))\n                          a =\n                         C (list2FWpolicy (DenyAllFromTo v va # y # z)) a\n 3. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                AllowPortFromTo v va vb \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))\n                 a;\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo v va vb # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (AllowPortFromTo v va vb # y # z)))\n                          a =\n                         C (list2FWpolicy (AllowPortFromTo v va vb # y # z))\n                          a\n 4. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (v \\<oplus> va # y # z)))\n                          a =\n                         C (list2FWpolicy (v \\<oplus> va # y # z)) a\n 5. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [])) a = C (list2FWpolicy []) a\n 6. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 7. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 8. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a\n\ngoal (1 subgoal):\n 1. DenyAll # x \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate (DenyAll # x))) a =\n    C (list2FWpolicy (DenyAll # x)) a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate x)) a =\n    C (list2FWpolicy x) a \\<Longrightarrow>\n    C (list2FWpolicy (DenyAll # separate x)) a =\n    C (list2FWpolicy (DenyAll # x)) a", "apply (cases \"x = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> [] \\<longrightarrow>\n             C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x = []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (DenyAll # separate x)) a =\n                      C (list2FWpolicy (DenyAll # x)) a\n 2. \\<lbrakk>x \\<noteq> [] \\<longrightarrow>\n             C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (DenyAll # separate x)) a =\n                      C (list2FWpolicy (DenyAll # x)) a", "apply (metis l2p_aux2 separate.simps(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> [] \\<longrightarrow>\n             C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (DenyAll # separate x)) a =\n                      C (list2FWpolicy (DenyAll # x)) a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (DenyAll # separate x)) a =\n                      C (list2FWpolicy (DenyAll # x)) a", "apply (cases \"a \\<in> dom (C (list2FWpolicy x))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []; a \\<in> dom (C (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (DenyAll # separate x)) a =\n                      C (list2FWpolicy (DenyAll # x)) a\n 2. \\<lbrakk>C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []; a \\<notin> dom (C (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (DenyAll # separate x)) a =\n                      C (list2FWpolicy (DenyAll # x)) a", "apply (subgoal_tac \"a \\<in> dom (C (list2FWpolicy (separate x)))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []; a \\<in> dom (C (list2FWpolicy x));\n     a \\<in> dom (C (list2FWpolicy (separate x)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (DenyAll # separate x)) a =\n                      C (list2FWpolicy (DenyAll # x)) a\n 2. \\<lbrakk>C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []; a \\<in> dom (C (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> a \\<in> dom (C (list2FWpolicy (separate x)))\n 3. \\<lbrakk>C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []; a \\<notin> dom (C (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (DenyAll # separate x)) a =\n                      C (list2FWpolicy (DenyAll # x)) a", "apply (metis Cdom2 list2FWpolicyconc sepDom sepnMT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []; a \\<in> dom (C (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> a \\<in> dom (C (list2FWpolicy (separate x)))\n 2. \\<lbrakk>C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []; a \\<notin> dom (C (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (DenyAll # separate x)) a =\n                      C (list2FWpolicy (DenyAll # x)) a", "apply (metis sepDom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []; a \\<notin> dom (C (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (DenyAll # separate x)) a =\n                      C (list2FWpolicy (DenyAll # x)) a", "apply (subgoal_tac \"a \\<notin> dom (C (list2FWpolicy (separate x)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []; a \\<notin> dom (C (list2FWpolicy x));\n     a \\<notin> dom (C (list2FWpolicy (separate x)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (DenyAll # separate x)) a =\n                      C (list2FWpolicy (DenyAll # x)) a\n 2. \\<lbrakk>C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []; a \\<notin> dom (C (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> dom (C (list2FWpolicy (separate x)))", "apply (subst list2FWpolicyconc,simp add: sepnMT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []; a \\<notin> dom (C (list2FWpolicy x));\n     a \\<notin> dom (C (list2FWpolicy (separate x)))\\<rbrakk>\n    \\<Longrightarrow> C (DenyAll \\<oplus> list2FWpolicy (separate x)) a =\n                      C (list2FWpolicy (DenyAll # x)) a\n 2. \\<lbrakk>C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []; a \\<notin> dom (C (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> dom (C (list2FWpolicy (separate x)))", "apply (subst list2FWpolicyconc,simp add: sepnMT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []; a \\<notin> dom (C (list2FWpolicy x));\n     a \\<notin> dom (C (list2FWpolicy (separate x)))\\<rbrakk>\n    \\<Longrightarrow> C (DenyAll \\<oplus> list2FWpolicy (separate x)) a =\n                      C (DenyAll \\<oplus> list2FWpolicy x) a\n 2. \\<lbrakk>C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []; a \\<notin> dom (C (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> dom (C (list2FWpolicy (separate x)))", "apply (metis nlpaux sepDom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C (list2FWpolicy (separate x)) a = C (list2FWpolicy x) a;\n     x \\<noteq> []; a \\<notin> dom (C (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> dom (C (list2FWpolicy (separate x)))", "apply (metis sepDom)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  DenyAll # x \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate (DenyAll # x))) a =\n  C (list2FWpolicy (DenyAll # x)) a\n\ngoal (7 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (DenyAllFromTo v va) =\n                first_bothNet y \\<Longrightarrow>\n                DenyAllFromTo v va \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate (DenyAllFromTo v va \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n        first_bothNet (DenyAllFromTo v va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> DenyAllFromTo v va # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (DenyAllFromTo v va # y # z)))\n                          a =\n                         C (list2FWpolicy (DenyAllFromTo v va # y # z)) a\n 2. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                AllowPortFromTo v va vb \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))\n                 a;\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo v va vb # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (AllowPortFromTo v va vb # y # z)))\n                          a =\n                         C (list2FWpolicy (AllowPortFromTo v va vb # y # z))\n                          a\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (v \\<oplus> va # y # z)))\n                          a =\n                         C (list2FWpolicy (v \\<oplus> va # y # z)) a\n 4. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [])) a = C (list2FWpolicy []) a\n 5. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 6. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 7. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (DenyAllFromTo v va) =\n                first_bothNet y \\<Longrightarrow>\n                DenyAllFromTo v va \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate (DenyAllFromTo v va \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n        first_bothNet (DenyAllFromTo v va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> DenyAllFromTo v va # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (DenyAllFromTo v va # y # z)))\n                          a =\n                         C (list2FWpolicy (DenyAllFromTo v va # y # z)) a\n 2. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                AllowPortFromTo v va vb \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))\n                 a;\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo v va vb # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (AllowPortFromTo v va vb # y # z)))\n                          a =\n                         C (list2FWpolicy (AllowPortFromTo v va vb # y # z))\n                          a\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (v \\<oplus> va # y # z)))\n                          a =\n                         C (list2FWpolicy (v \\<oplus> va # y # z)) a\n 4. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [])) a = C (list2FWpolicy []) a\n 5. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 6. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 7. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "case (2 v va y z)"], ["proof (state)\nthis:\n  first_bothNet (DenyAllFromTo v va) = first_bothNet y \\<Longrightarrow>\n  DenyAllFromTo v va \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))) a =\n  C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a\n  first_bothNet (DenyAllFromTo v va) \\<noteq>\n  first_bothNet y \\<Longrightarrow>\n  y # z \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a\n\ngoal (7 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (DenyAllFromTo v va) =\n                first_bothNet y \\<Longrightarrow>\n                DenyAllFromTo v va \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate (DenyAllFromTo v va \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n        first_bothNet (DenyAllFromTo v va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> DenyAllFromTo v va # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (DenyAllFromTo v va # y # z)))\n                          a =\n                         C (list2FWpolicy (DenyAllFromTo v va # y # z)) a\n 2. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                AllowPortFromTo v va vb \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))\n                 a;\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo v va vb # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (AllowPortFromTo v va vb # y # z)))\n                          a =\n                         C (list2FWpolicy (AllowPortFromTo v va vb # y # z))\n                          a\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (v \\<oplus> va # y # z)))\n                          a =\n                         C (list2FWpolicy (v \\<oplus> va # y # z)) a\n 4. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [])) a = C (list2FWpolicy []) a\n 5. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 6. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 7. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "thus ?case"], ["proof (prove)\nusing this:\n  first_bothNet (DenyAllFromTo v va) = first_bothNet y \\<Longrightarrow>\n  DenyAllFromTo v va \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))) a =\n  C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a\n  first_bothNet (DenyAllFromTo v va) \\<noteq>\n  first_bothNet y \\<Longrightarrow>\n  y # z \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a\n\ngoal (1 subgoal):\n 1. DenyAllFromTo v va # y # z \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate (DenyAllFromTo v va # y # z))) a =\n    C (list2FWpolicy (DenyAllFromTo v va # y # z)) a", "apply (cases \"z = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n             C (list2FWpolicy (separate [y])) a = C y a;\n     z = []\\<rbrakk>\n    \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                      C (list2FWpolicy (DenyAllFromTo v va # separate [y]))\n                       a =\n                      C (DenyAllFromTo v va \\<oplus> y) a\n 2. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))) a =\n     C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z))\n                        a =\n                       C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))\n                        a) \\<and>\n                      ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy\n                           (DenyAllFromTo v va # separate (y # z)))\n                        a =\n                       C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))\n                        a)", "apply (rule conjI|rule impI|simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy (separate [y])) a = C y a; z = [];\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (DenyAllFromTo v va # separate [y]))\n                       a =\n                      C (DenyAllFromTo v va \\<oplus> y) a\n 2. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))) a =\n     C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z))\n                        a =\n                       C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))\n                        a) \\<and>\n                      ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy\n                           (DenyAllFromTo v va # separate (y # z)))\n                        a =\n                       C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))\n                        a)", "apply (subst list2FWpolicyconc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy (separate [y])) a = C y a; z = [];\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> separate [y] \\<noteq> []\n 2. \\<lbrakk>C (list2FWpolicy (separate [y])) a = C y a; z = [];\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo v va \\<oplus>\n                         list2FWpolicy (separate [y]))\n                       a =\n                      C (DenyAllFromTo v va \\<oplus> y) a\n 3. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))) a =\n     C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z))\n                        a =\n                       C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))\n                        a) \\<and>\n                      ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy\n                           (DenyAllFromTo v va # separate (y # z)))\n                        a =\n                       C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))\n                        a)", "apply (metis not_Cons_self sepnMT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy (separate [y])) a = C y a; z = [];\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo v va \\<oplus>\n                         list2FWpolicy (separate [y]))\n                       a =\n                      C (DenyAllFromTo v va \\<oplus> y) a\n 2. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))) a =\n     C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z))\n                        a =\n                       C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))\n                        a) \\<and>\n                      ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy\n                           (DenyAllFromTo v va # separate (y # z)))\n                        a =\n                       C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))\n                        a)", "apply (metis C.simps(4) CConcStartaux Cdom2 domIff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))) a =\n     C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z))\n                        a =\n                       C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))\n                        a) \\<and>\n                      ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy\n                           (DenyAllFromTo v va # separate (y # z)))\n                        a =\n                       C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))\n                        a)", "apply (rule conjI|rule impI|simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<noteq> [];\n     C (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))) a =\n     C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n     {v, va} = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z))\n                       a =\n                      C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))\n                       a\n 2. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))) a =\n     C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                      C (list2FWpolicy\n                          (DenyAllFromTo v va # separate (y # z)))\n                       a =\n                      C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))\n                       a", "apply (erule list2FWpolicy_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))) a =\n     C (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                      C (list2FWpolicy\n                          (DenyAllFromTo v va # separate (y # z)))\n                       a =\n                      C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))\n                       a", "apply (rule impI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<noteq> [];\n     C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a;\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo v va # separate (y # z)))\n                       a =\n                      C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))\n                       a", "apply (subst list2FWpolicyconc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<noteq> [];\n     C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a;\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> separate (y # z) \\<noteq> []\n 2. \\<lbrakk>z \\<noteq> [];\n     C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a;\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo v va \\<oplus>\n                         list2FWpolicy (separate (y # z)))\n                       a =\n                      C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))\n                       a", "apply (metis list.simps(2) sepnMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<noteq> [];\n     C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a;\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo v va \\<oplus>\n                         list2FWpolicy (separate (y # z)))\n                       a =\n                      C (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))\n                       a", "by (metis C.simps(4) CConcStartaux Cdom2 domIff)"], ["proof (state)\nthis:\n  DenyAllFromTo v va # y # z \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate (DenyAllFromTo v va # y # z))) a =\n  C (list2FWpolicy (DenyAllFromTo v va # y # z)) a\n\ngoal (6 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                AllowPortFromTo v va vb \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))\n                 a;\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo v va vb # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (AllowPortFromTo v va vb # y # z)))\n                          a =\n                         C (list2FWpolicy (AllowPortFromTo v va vb # y # z))\n                          a\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (v \\<oplus> va # y # z)))\n                          a =\n                         C (list2FWpolicy (v \\<oplus> va # y # z)) a\n 3. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [])) a = C (list2FWpolicy []) a\n 4. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 5. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 6. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                AllowPortFromTo v va vb \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))\n                 a;\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo v va vb # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (AllowPortFromTo v va vb # y # z)))\n                          a =\n                         C (list2FWpolicy (AllowPortFromTo v va vb # y # z))\n                          a\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (v \\<oplus> va # y # z)))\n                          a =\n                         C (list2FWpolicy (v \\<oplus> va # y # z)) a\n 3. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [])) a = C (list2FWpolicy []) a\n 4. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 5. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 6. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "case (3 v va vb y z)"], ["proof (state)\nthis:\n  first_bothNet (AllowPortFromTo v va vb) =\n  first_bothNet y \\<Longrightarrow>\n  AllowPortFromTo v va vb \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate (AllowPortFromTo v va vb \\<oplus> y # z))) a =\n  C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z)) a\n  first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n  first_bothNet y \\<Longrightarrow>\n  y # z \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a\n\ngoal (6 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                AllowPortFromTo v va vb \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))\n                 a;\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo v va vb # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (AllowPortFromTo v va vb # y # z)))\n                          a =\n                         C (list2FWpolicy (AllowPortFromTo v va vb # y # z))\n                          a\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (v \\<oplus> va # y # z)))\n                          a =\n                         C (list2FWpolicy (v \\<oplus> va # y # z)) a\n 3. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [])) a = C (list2FWpolicy []) a\n 4. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 5. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 6. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "thus ?case"], ["proof (prove)\nusing this:\n  first_bothNet (AllowPortFromTo v va vb) =\n  first_bothNet y \\<Longrightarrow>\n  AllowPortFromTo v va vb \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate (AllowPortFromTo v va vb \\<oplus> y # z))) a =\n  C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z)) a\n  first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n  first_bothNet y \\<Longrightarrow>\n  y # z \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a\n\ngoal (1 subgoal):\n 1. AllowPortFromTo v va vb # y # z \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate (AllowPortFromTo v va vb # y # z))) a =\n    C (list2FWpolicy (AllowPortFromTo v va vb # y # z)) a", "apply (cases \"z = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n             C (list2FWpolicy (separate [y])) a = C y a;\n     z = []\\<rbrakk>\n    \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                      C (list2FWpolicy\n                          (AllowPortFromTo v va vb # separate [y]))\n                       a =\n                      C (AllowPortFromTo v va vb \\<oplus> y) a\n 2. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n      a =\n     C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy\n                           (AllowPortFromTo v va vb \\<oplus> y # z))\n                        a =\n                       C (AllowPortFromTo v va vb \\<oplus>\n                          list2FWpolicy (y # z))\n                        a) \\<and>\n                      ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy\n                           (AllowPortFromTo v va vb # separate (y # z)))\n                        a =\n                       C (AllowPortFromTo v va vb \\<oplus>\n                          list2FWpolicy (y # z))\n                        a)", "apply (rule conjI|rule impI|simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy (separate [y])) a = C y a; z = [];\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (AllowPortFromTo v va vb # separate [y]))\n                       a =\n                      C (AllowPortFromTo v va vb \\<oplus> y) a\n 2. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n      a =\n     C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy\n                           (AllowPortFromTo v va vb \\<oplus> y # z))\n                        a =\n                       C (AllowPortFromTo v va vb \\<oplus>\n                          list2FWpolicy (y # z))\n                        a) \\<and>\n                      ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy\n                           (AllowPortFromTo v va vb # separate (y # z)))\n                        a =\n                       C (AllowPortFromTo v va vb \\<oplus>\n                          list2FWpolicy (y # z))\n                        a)", "apply (subst list2FWpolicyconc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy (separate [y])) a = C y a; z = [];\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> separate [y] \\<noteq> []\n 2. \\<lbrakk>C (list2FWpolicy (separate [y])) a = C y a; z = [];\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (AllowPortFromTo v va vb \\<oplus>\n                         list2FWpolicy (separate [y]))\n                       a =\n                      C (AllowPortFromTo v va vb \\<oplus> y) a\n 3. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n      a =\n     C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy\n                           (AllowPortFromTo v va vb \\<oplus> y # z))\n                        a =\n                       C (AllowPortFromTo v va vb \\<oplus>\n                          list2FWpolicy (y # z))\n                        a) \\<and>\n                      ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy\n                           (AllowPortFromTo v va vb # separate (y # z)))\n                        a =\n                       C (AllowPortFromTo v va vb \\<oplus>\n                          list2FWpolicy (y # z))\n                        a)", "apply (metis not_Cons_self sepnMT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy (separate [y])) a = C y a; z = [];\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (AllowPortFromTo v va vb \\<oplus>\n                         list2FWpolicy (separate [y]))\n                       a =\n                      C (AllowPortFromTo v va vb \\<oplus> y) a\n 2. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n      a =\n     C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy\n                           (AllowPortFromTo v va vb \\<oplus> y # z))\n                        a =\n                       C (AllowPortFromTo v va vb \\<oplus>\n                          list2FWpolicy (y # z))\n                        a) \\<and>\n                      ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy\n                           (AllowPortFromTo v va vb # separate (y # z)))\n                        a =\n                       C (AllowPortFromTo v va vb \\<oplus>\n                          list2FWpolicy (y # z))\n                        a)", "apply (metis C.simps(4) CConcStartaux Cdom2 domIff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n      a =\n     C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy\n                           (AllowPortFromTo v va vb \\<oplus> y # z))\n                        a =\n                       C (AllowPortFromTo v va vb \\<oplus>\n                          list2FWpolicy (y # z))\n                        a) \\<and>\n                      ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy\n                           (AllowPortFromTo v va vb # separate (y # z)))\n                        a =\n                       C (AllowPortFromTo v va vb \\<oplus>\n                          list2FWpolicy (y # z))\n                        a)", "apply (rule conjI|rule impI|simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<noteq> [];\n     C (list2FWpolicy (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n      a =\n     C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z)) a;\n     {v, va} = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (AllowPortFromTo v va vb \\<oplus> y # z))\n                       a =\n                      C (AllowPortFromTo v va vb \\<oplus>\n                         list2FWpolicy (y # z))\n                       a\n 2. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n      a =\n     C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                      C (list2FWpolicy\n                          (AllowPortFromTo v va vb # separate (y # z)))\n                       a =\n                      C (AllowPortFromTo v va vb \\<oplus>\n                         list2FWpolicy (y # z))\n                       a", "apply (erule list2FWpolicy_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n      a =\n     C (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                      C (list2FWpolicy\n                          (AllowPortFromTo v va vb # separate (y # z)))\n                       a =\n                      C (AllowPortFromTo v va vb \\<oplus>\n                         list2FWpolicy (y # z))\n                       a", "apply (rule impI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<noteq> [];\n     C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a;\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (AllowPortFromTo v va vb # separate (y # z)))\n                       a =\n                      C (AllowPortFromTo v va vb \\<oplus>\n                         list2FWpolicy (y # z))\n                       a", "apply (subst list2FWpolicyconc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<noteq> [];\n     C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a;\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> separate (y # z) \\<noteq> []\n 2. \\<lbrakk>z \\<noteq> [];\n     C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a;\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (AllowPortFromTo v va vb \\<oplus>\n                         list2FWpolicy (separate (y # z)))\n                       a =\n                      C (AllowPortFromTo v va vb \\<oplus>\n                         list2FWpolicy (y # z))\n                       a", "apply (metis list.simps(2) sepnMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<noteq> [];\n     C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a;\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (AllowPortFromTo v va vb \\<oplus>\n                         list2FWpolicy (separate (y # z)))\n                       a =\n                      C (AllowPortFromTo v va vb \\<oplus>\n                         list2FWpolicy (y # z))\n                       a", "by (metis C.simps(4) CConcStartaux Cdom2 domIff)"], ["proof (state)\nthis:\n  AllowPortFromTo v va vb # y # z \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate (AllowPortFromTo v va vb # y # z))) a =\n  C (list2FWpolicy (AllowPortFromTo v va vb # y # z)) a\n\ngoal (5 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (v \\<oplus> va # y # z)))\n                          a =\n                         C (list2FWpolicy (v \\<oplus> va # y # z)) a\n 2. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [])) a = C (list2FWpolicy []) a\n 3. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 4. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 5. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (v \\<oplus> va # y # z)))\n                          a =\n                         C (list2FWpolicy (v \\<oplus> va # y # z)) a\n 2. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [])) a = C (list2FWpolicy []) a\n 3. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 4. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 5. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "case (4 v va y z)"], ["proof (state)\nthis:\n  first_bothNet (v \\<oplus> va) = first_bothNet y \\<Longrightarrow>\n  (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))) a =\n  C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a\n  first_bothNet (v \\<oplus> va) \\<noteq> first_bothNet y \\<Longrightarrow>\n  y # z \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a\n\ngoal (5 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                C (list2FWpolicy\n                    (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        C (list2FWpolicy (separate (y # z))) a =\n        C (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         C (list2FWpolicy\n                             (separate (v \\<oplus> va # y # z)))\n                          a =\n                         C (list2FWpolicy (v \\<oplus> va # y # z)) a\n 2. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [])) a = C (list2FWpolicy []) a\n 3. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 4. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 5. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "thus ?case"], ["proof (prove)\nusing this:\n  first_bothNet (v \\<oplus> va) = first_bothNet y \\<Longrightarrow>\n  (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))) a =\n  C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a\n  first_bothNet (v \\<oplus> va) \\<noteq> first_bothNet y \\<Longrightarrow>\n  y # z \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a\n\ngoal (1 subgoal):\n 1. v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate (v \\<oplus> va # y # z))) a =\n    C (list2FWpolicy (v \\<oplus> va # y # z)) a", "apply (cases \"z = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n             C (list2FWpolicy (separate [y])) a = C y a;\n     z = []\\<rbrakk>\n    \\<Longrightarrow> first_bothNet v \\<noteq>\n                      first_bothNet y \\<longrightarrow>\n                      C (list2FWpolicy (v \\<oplus> va # separate [y])) a =\n                      C ((v \\<oplus> va) \\<oplus> y) a\n 2. \\<lbrakk>z \\<noteq> [];\n     first_bothNet v = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))) a =\n     C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> (first_bothNet v = first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z))\n                        a =\n                       C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))\n                        a) \\<and>\n                      (first_bothNet v \\<noteq>\n                       first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy (v \\<oplus> va # separate (y # z)))\n                        a =\n                       C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)) a)", "apply (rule conjI|rule impI|simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy (separate [y])) a = C y a; z = [];\n     first_bothNet v \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (v \\<oplus> va # separate [y])) a =\n                      C ((v \\<oplus> va) \\<oplus> y) a\n 2. \\<lbrakk>z \\<noteq> [];\n     first_bothNet v = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))) a =\n     C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> (first_bothNet v = first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z))\n                        a =\n                       C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))\n                        a) \\<and>\n                      (first_bothNet v \\<noteq>\n                       first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy (v \\<oplus> va # separate (y # z)))\n                        a =\n                       C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)) a)", "apply (subst list2FWpolicyconc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy (separate [y])) a = C y a; z = [];\n     first_bothNet v \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> separate [y] \\<noteq> []\n 2. \\<lbrakk>C (list2FWpolicy (separate [y])) a = C y a; z = [];\n     first_bothNet v \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C ((v \\<oplus> va) \\<oplus>\n                         list2FWpolicy (separate [y]))\n                       a =\n                      C ((v \\<oplus> va) \\<oplus> y) a\n 3. \\<lbrakk>z \\<noteq> [];\n     first_bothNet v = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))) a =\n     C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> (first_bothNet v = first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z))\n                        a =\n                       C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))\n                        a) \\<and>\n                      (first_bothNet v \\<noteq>\n                       first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy (v \\<oplus> va # separate (y # z)))\n                        a =\n                       C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)) a)", "apply (metis not_Cons_self sepnMT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C (list2FWpolicy (separate [y])) a = C y a; z = [];\n     first_bothNet v \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C ((v \\<oplus> va) \\<oplus>\n                         list2FWpolicy (separate [y]))\n                       a =\n                      C ((v \\<oplus> va) \\<oplus> y) a\n 2. \\<lbrakk>z \\<noteq> [];\n     first_bothNet v = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))) a =\n     C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> (first_bothNet v = first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z))\n                        a =\n                       C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))\n                        a) \\<and>\n                      (first_bothNet v \\<noteq>\n                       first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy (v \\<oplus> va # separate (y # z)))\n                        a =\n                       C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)) a)", "apply (metis C.simps(4) CConcStartaux Cdom2 domIff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<noteq> [];\n     first_bothNet v = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))) a =\n     C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> (first_bothNet v = first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z))\n                        a =\n                       C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))\n                        a) \\<and>\n                      (first_bothNet v \\<noteq>\n                       first_bothNet y \\<longrightarrow>\n                       C (list2FWpolicy (v \\<oplus> va # separate (y # z)))\n                        a =\n                       C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)) a)", "apply (rule conjI|rule impI|simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<noteq> [];\n     C (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))) a =\n     C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n     first_bothNet v = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a =\n                      C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)) a\n 2. \\<lbrakk>z \\<noteq> [];\n     first_bothNet v = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))) a =\n     C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> first_bothNet v \\<noteq>\n                      first_bothNet y \\<longrightarrow>\n                      C (list2FWpolicy (v \\<oplus> va # separate (y # z)))\n                       a =\n                      C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)) a", "apply (erule list2FWpolicy_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<noteq> [];\n     first_bothNet v = first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))) a =\n     C (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     C (list2FWpolicy (separate (y # z))) a =\n     C (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> first_bothNet v \\<noteq>\n                      first_bothNet y \\<longrightarrow>\n                      C (list2FWpolicy (v \\<oplus> va # separate (y # z)))\n                       a =\n                      C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)) a", "apply (rule impI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<noteq> [];\n     C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a;\n     first_bothNet v \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (v \\<oplus> va # separate (y # z)))\n                       a =\n                      C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)) a", "apply (subst list2FWpolicyconc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<noteq> [];\n     C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a;\n     first_bothNet v \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> separate (y # z) \\<noteq> []\n 2. \\<lbrakk>z \\<noteq> [];\n     C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a;\n     first_bothNet v \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C ((v \\<oplus> va) \\<oplus>\n                         list2FWpolicy (separate (y # z)))\n                       a =\n                      C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)) a", "apply (metis list.simps(2) sepnMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<noteq> [];\n     C (list2FWpolicy (separate (y # z))) a = C (list2FWpolicy (y # z)) a;\n     first_bothNet v \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> C ((v \\<oplus> va) \\<oplus>\n                         list2FWpolicy (separate (y # z)))\n                       a =\n                      C ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)) a", "by (metis C.simps(4) CConcStartaux Cdom2 domIff)"], ["proof (state)\nthis:\n  v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate (v \\<oplus> va # y # z))) a =\n  C (list2FWpolicy (v \\<oplus> va # y # z)) a\n\ngoal (4 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [])) a = C (list2FWpolicy []) a\n 2. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 3. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 4. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [])) a = C (list2FWpolicy []) a\n 2. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 3. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 4. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "case 5"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [])) a = C (list2FWpolicy []) a\n 2. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 3. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 4. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [])) a = C (list2FWpolicy []) a", "by simp"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate [])) a = C (list2FWpolicy []) a\n\ngoal (3 subgoals):\n 1. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 2. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 3. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 2. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 3. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "case 6"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       C (list2FWpolicy [DenyAllFromTo vb vc]) a\n 2. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 3. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [DenyAllFromTo vb_ vc_] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [DenyAllFromTo vb_ vc_])) a =\n    C (list2FWpolicy [DenyAllFromTo vb_ vc_]) a", "by simp"], ["proof (state)\nthis:\n  [DenyAllFromTo vb_ vc_] \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate [DenyAllFromTo vb_ vc_])) a =\n  C (list2FWpolicy [DenyAllFromTo vb_ vc_]) a\n\ngoal (2 subgoals):\n 1. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 2. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 2. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "case 7"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       C (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 2. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [AllowPortFromTo vb_ vc_ vd_] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [AllowPortFromTo vb_ vc_ vd_])) a =\n    C (list2FWpolicy [AllowPortFromTo vb_ vc_ vd_]) a", "by simp"], ["proof (state)\nthis:\n  [AllowPortFromTo vb_ vc_ vd_] \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate [AllowPortFromTo vb_ vc_ vd_])) a =\n  C (list2FWpolicy [AllowPortFromTo vb_ vc_ vd_]) a\n\ngoal (1 subgoal):\n 1. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "case 8"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       C (list2FWpolicy [vb \\<oplus> vc]) a", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [vb_ \\<oplus> vc_] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (separate [vb_ \\<oplus> vc_])) a =\n    C (list2FWpolicy [vb_ \\<oplus> vc_]) a", "by simp"], ["proof (state)\nthis:\n  [vb_ \\<oplus> vc_] \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (separate [vb_ \\<oplus> vc_])) a =\n  C (list2FWpolicy [vb_ \\<oplus> vc_]) a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_s: \n  \"p \\<noteq> [] \\<Longrightarrow> C (list2FWpolicy (separate p)) = C (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    C (list2FWpolicy (separate p)) = C (list2FWpolicy p)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       p \\<noteq> [] \\<Longrightarrow>\n       C (list2FWpolicy (separate p)) x = C (list2FWpolicy p) x", "using C_eq_s_ext"], ["proof (prove)\nusing this:\n  ?p \\<noteq> [] \\<Longrightarrow>\n  C (list2FWpolicy (separate ?p)) ?a = C (list2FWpolicy ?p) ?a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       p \\<noteq> [] \\<Longrightarrow>\n       C (list2FWpolicy (separate p)) x = C (list2FWpolicy p) x", "by blast"], ["", "lemma sortnMTQ: \"p \\<noteq> [] \\<Longrightarrow> qsort p l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> qsort p l \\<noteq> []", "by (metis set_sortQ setnMT)"], ["", "lemmas C_eq_Lemmas_sep =\n       C_eq_Lemmas sortnMT sortnMTQ RS2_NMT NMPrd not_MTimpnotMT"], ["", "lemma C_eq_until_separated:\n  \" DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p)l \\<Longrightarrow> allNetsDistinct (policy2list p) \\<Longrightarrow>\n    C (list2FWpolicy\n        (separate\n          (FWNormalisationCore.sort\n            (removeShadowRules2 (remdups (rm_MT_rules C \n               (insertDeny (removeShadowRules1 (policy2list p)))))) l))) =\n    C p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (separate\n                            (FWNormalisationCore.sort\n                              (removeShadowRules2\n                                (remdups\n                                  (rm_MT_rules C\n                                    (insertDeny\n(removeShadowRules1 (policy2list p))))))\n                              l))) =\n                      C p", "by (simp add: C_eq_All_untilSorted_withSimps C_eq_s wellformed1_alternative_sorted wp1ID wp1n_RS2)"], ["", "lemma C_eq_until_separatedQ:\n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p)l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n    C (list2FWpolicy\n        (separate (qsort (removeShadowRules2 (remdups (rm_MT_rules C \n             (insertDeny (removeShadowRules1 (policy2list p)))))) l))) =\n    C p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (separate\n                            (qsort\n                              (removeShadowRules2\n                                (remdups\n                                  (rm_MT_rules C\n                                    (insertDeny\n(removeShadowRules1 (policy2list p))))))\n                              l))) =\n                      C p", "by (simp add: C_eq_All_untilSorted_withSimpsQ C_eq_s sortnMTQ wp1ID wp1n_RS2)"], ["", "lemma domID[rule_format]: \"p \\<noteq> [] \\<and> x \\<in> dom(C(list2FWpolicy p)) \\<longrightarrow>\n                           x \\<in> dom (C(list2FWpolicy(insertDenies p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (insertDenies p)))", "proof(induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<and>\n    x \\<in> dom (C (list2FWpolicy [])) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (insertDenies [])))\n 2. \\<And>a p.\n       p \\<noteq> [] \\<and>\n       x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<and>\n       x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<and>\n    x \\<in> dom (C (list2FWpolicy [])) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (insertDenies [])))\n 2. \\<And>a p.\n       p \\<noteq> [] \\<and>\n       x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<and>\n       x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<and>\n    x \\<in> dom (C (list2FWpolicy [])) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (insertDenies [])))", "by simp"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy [])) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies [])))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<and>\n       x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<and>\n       x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<and>\n       x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<and>\n       x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "case (Cons a p)"], ["proof (state)\nthis:\n  p \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<and>\n       x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<and>\n       x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. a # p \\<noteq> [] \\<and>\n    x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "proof(cases \"p=[]\",goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n     p = []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (C (list2FWpolicy\n (a # p))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))\n 2. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (C (list2FWpolicy\n (a # p))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "case 1"], ["proof (state)\nthis:\n  p \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n  p = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n     p = []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (C (list2FWpolicy\n (a # p))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))\n 2. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (C (list2FWpolicy\n (a # p))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n  p = []", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n  p = []\n\ngoal (1 subgoal):\n 1. a # p \\<noteq> [] \\<and>\n    x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = [] \\<Longrightarrow>\n    x \\<in> dom (C a) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy\n                     (case a of\n                      DenyAll \\<Rightarrow> DenyAll # insertDenies []\n                      | _ \\<Rightarrow>\n                          DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a #\n                          insertDenies [])))", "apply(rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = []; x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies []\n  | _ \\<Rightarrow>\n      DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n      DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n      insertDenies [])))", "apply (cases a, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>p = []; x \\<in> dom (C (DenyAllFromTo x21 x22));\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (DenyAllFromTo x21 x22 \\<oplus>\n  DenyAllFromTo x22 x21 \\<oplus> DenyAllFromTo x21 x22))\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>p = []; x \\<in> dom (C (AllowPortFromTo x31 x32 x33));\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (DenyAllFromTo x31 x32 \\<oplus>\n  DenyAllFromTo x32 x31 \\<oplus> AllowPortFromTo x31 x32 x33))\n 3. \\<And>x41 x42.\n       \\<lbrakk>p = []; x \\<in> dom (C (x41 \\<oplus> x42));\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (DenyAllFromTo (first_srcNet x41) (first_destNet x41) \\<oplus>\n  DenyAllFromTo (first_destNet x41) (first_srcNet x41) \\<oplus>\n  x41 \\<oplus> x42))", "apply (simp_all add: C.simps dom_def)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>p = [];\n        (\\<exists>y. C x42 x = \\<lfloor>y\\<rfloor>) \\<or>\n        (\\<exists>y. C x41 x = \\<lfloor>y\\<rfloor>);\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y. C x42 x = \\<lfloor>y\\<rfloor>) \\<or>\n                         (\\<exists>y. C x41 x = \\<lfloor>y\\<rfloor>) \\<or>\n                         (\\<exists>y.\n                             deny_all_from_to (first_destNet x41)\n                              (first_srcNet x41) x =\n                             \\<lfloor>y\\<rfloor>) \\<or>\n                         (\\<exists>y.\n                             deny_all_from_to (first_srcNet x41)\n                              (first_destNet x41) x =\n                             \\<lfloor>y\\<rfloor>)", "by auto"], ["proof (state)\nthis:\n  a # p \\<noteq> [] \\<and>\n  x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (C (list2FWpolicy\n (a # p))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (C (list2FWpolicy\n (a # p))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "case 2"], ["proof (state)\nthis:\n  p \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (C (list2FWpolicy\n (a # p))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. a # p \\<noteq> [] \\<and>\n    x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "proof(cases \"x \\<in> dom(C(list2FWpolicy p))\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<in> dom (C (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (C (list2FWpolicy\n (a # p))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))\n 2. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (C (list2FWpolicy\n (a # p))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "case 1"], ["proof (state)\nthis:\n  p \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []\n  x \\<in> dom (C (list2FWpolicy p))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<in> dom (C (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (C (list2FWpolicy\n (a # p))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))\n 2. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (C (list2FWpolicy\n (a # p))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []\n  x \\<in> dom (C (list2FWpolicy p))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []\n  x \\<in> dom (C (list2FWpolicy p))\n\ngoal (1 subgoal):\n 1. a # p \\<noteq> [] \\<and>\n    x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<in> dom (C (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (a # p))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n  | _ \\<Rightarrow>\n      DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n      DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n      insertDenies p)))", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<in> dom (C (list2FWpolicy p));\n     x \\<in> dom (C (list2FWpolicy (a # p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n  | _ \\<Rightarrow>\n      DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n      DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n      insertDenies p)))", "apply (cases a, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n        p \\<noteq> []; x \\<in> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (DenyAllFromTo x21 x22 # p)));\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (DenyAllFromTo x21 x22 \\<oplus>\n    DenyAllFromTo x22 x21 \\<oplus> DenyAllFromTo x21 x22 #\n    insertDenies p)))\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n        p \\<noteq> []; x \\<in> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x31 x32 x33 # p)));\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (DenyAllFromTo x31 x32 \\<oplus>\n    DenyAllFromTo x32 x31 \\<oplus> AllowPortFromTo x31 x32 x33 #\n    insertDenies p)))\n 3. \\<And>x41 x42.\n       \\<lbrakk>x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n        p \\<noteq> []; x \\<in> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (x41 \\<oplus> x42 # p)));\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (DenyAllFromTo (first_srcNet x41) (first_destNet x41) \\<oplus>\n    DenyAllFromTo (first_destNet x41) (first_srcNet x41) \\<oplus>\n    x41 \\<oplus> x42 #\n    insertDenies p)))", "using InDomConc idNMT"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> []; ?x \\<in> dom (C (list2FWpolicy ?p))\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> dom (C (list2FWpolicy (?a # ?p)))\n  ?p \\<noteq> [] \\<Longrightarrow> insertDenies ?p \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n        p \\<noteq> []; x \\<in> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (DenyAllFromTo x21 x22 # p)));\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (DenyAllFromTo x21 x22 \\<oplus>\n    DenyAllFromTo x22 x21 \\<oplus> DenyAllFromTo x21 x22 #\n    insertDenies p)))\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n        p \\<noteq> []; x \\<in> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x31 x32 x33 # p)));\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (DenyAllFromTo x31 x32 \\<oplus>\n    DenyAllFromTo x32 x31 \\<oplus> AllowPortFromTo x31 x32 x33 #\n    insertDenies p)))\n 3. \\<And>x41 x42.\n       \\<lbrakk>x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n        p \\<noteq> []; x \\<in> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (x41 \\<oplus> x42 # p)));\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (DenyAllFromTo (first_srcNet x41) (first_destNet x41) \\<oplus>\n    DenyAllFromTo (first_destNet x41) (first_srcNet x41) \\<oplus>\n    x41 \\<oplus> x42 #\n    insertDenies p)))", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n        p \\<noteq> []; x \\<in> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x31 x32 x33 # p)));\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (DenyAllFromTo x31 x32 \\<oplus>\n    DenyAllFromTo x32 x31 \\<oplus> AllowPortFromTo x31 x32 x33 #\n    insertDenies p)))\n 2. \\<And>x41 x42.\n       \\<lbrakk>x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n        p \\<noteq> []; x \\<in> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (x41 \\<oplus> x42 # p)));\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (DenyAllFromTo (first_srcNet x41) (first_destNet x41) \\<oplus>\n    DenyAllFromTo (first_destNet x41) (first_srcNet x41) \\<oplus>\n    x41 \\<oplus> x42 #\n    insertDenies p)))", "apply (rule InDomConc, simp_all add: idNMT)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a # p \\<noteq> [] \\<and>\n  x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (C (list2FWpolicy\n (a # p))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (C (list2FWpolicy\n (a # p))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "case 2"], ["proof (state)\nthis:\n  p \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (C (list2FWpolicy\n (a # p))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<and> x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n\ngoal (1 subgoal):\n 1. a # p \\<noteq> [] \\<and>\n    x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (a # p))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n  | _ \\<Rightarrow>\n      DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n      DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n      insertDenies p)))", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C (list2FWpolicy (a # p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n  | _ \\<Rightarrow>\n      DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n      DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n      insertDenies p)))", "proof(cases \"x \\<in> dom (C (list2FWpolicy (insertDenies p)))\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C (list2FWpolicy (a # p)));\n     x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n  | _ \\<Rightarrow>\n      DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n      DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n      insertDenies p)))\n 2. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C (list2FWpolicy (a # p)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n  | _ \\<Rightarrow>\n      DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n      DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n      insertDenies p)))", "case 1"], ["proof (state)\nthis:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (a # p)))\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C (list2FWpolicy (a # p)));\n     x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n  | _ \\<Rightarrow>\n      DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n      DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n      insertDenies p)))\n 2. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C (list2FWpolicy (a # p)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n  | _ \\<Rightarrow>\n      DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n      DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n      insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (a # p)))\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (a # p)))\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (C (list2FWpolicy\n                     (case a of\n                      DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                      | _ \\<Rightarrow>\n                          DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a #\n                          insertDenies p)))", "proof(induct a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C (list2FWpolicy (DenyAll # p)));\n     x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (case DenyAll of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n  | _ \\<Rightarrow>\n      DenyAllFromTo (first_srcNet DenyAll) (first_destNet DenyAll) \\<oplus>\n      DenyAllFromTo (first_destNet DenyAll) (first_srcNet DenyAll) \\<oplus>\n      DenyAll #\n      insertDenies p)))\n 2. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 3. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "case DenyAll"], ["proof (state)\nthis:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (DenyAll # p)))\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C (list2FWpolicy (DenyAll # p)));\n     x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (case DenyAll of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n  | _ \\<Rightarrow>\n      DenyAllFromTo (first_srcNet DenyAll) (first_destNet DenyAll) \\<oplus>\n      DenyAllFromTo (first_destNet DenyAll) (first_srcNet DenyAll) \\<oplus>\n      DenyAll #\n      insertDenies p)))\n 2. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 3. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (DenyAll # p)))\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (DenyAll # p)))\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (C (list2FWpolicy\n                     (case DenyAll of\n                      DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                      | _ \\<Rightarrow>\n                          DenyAllFromTo (first_srcNet DenyAll)\n                           (first_destNet DenyAll) \\<oplus>\n                          DenyAllFromTo (first_destNet DenyAll)\n                           (first_srcNet DenyAll) \\<oplus>\n                          DenyAll #\n                          insertDenies p)))", "by simp"], ["proof (state)\nthis:\n  x \\<in> dom (C (list2FWpolicy\n                   (case DenyAll of\n                    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                    | _ \\<Rightarrow>\n                        DenyAllFromTo (first_srcNet DenyAll)\n                         (first_destNet DenyAll) \\<oplus>\n                        DenyAllFromTo (first_destNet DenyAll)\n                         (first_srcNet DenyAll) \\<oplus>\n                        DenyAll #\n                        insertDenies p)))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "case (DenyAllFromTo src dest)"], ["proof (state)\nthis:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (DenyAllFromTo src dest # p)))\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (DenyAllFromTo src dest # p)))\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (DenyAllFromTo src dest # p)))\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (C (list2FWpolicy\n                     (case DenyAllFromTo src dest of\n                      DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                      | _ \\<Rightarrow>\n                          DenyAllFromTo\n                           (first_srcNet (DenyAllFromTo src dest))\n                           (first_destNet (DenyAllFromTo src dest)) \\<oplus>\n                          DenyAllFromTo\n                           (first_destNet (DenyAllFromTo src dest))\n                           (first_srcNet (DenyAllFromTo src dest)) \\<oplus>\n                          DenyAllFromTo src dest #\n                          insertDenies p)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C (list2FWpolicy (DenyAllFromTo src dest # p)));\n     x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (DenyAllFromTo src dest \\<oplus>\n  DenyAllFromTo dest src \\<oplus> DenyAllFromTo src dest #\n  insertDenies p)))", "by( rule InDomConc, simp add: idNMT)"], ["proof (state)\nthis:\n  x \\<in> dom (C (list2FWpolicy\n                   (case DenyAllFromTo src dest of\n                    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                    | _ \\<Rightarrow>\n                        DenyAllFromTo\n                         (first_srcNet (DenyAllFromTo src dest))\n                         (first_destNet (DenyAllFromTo src dest)) \\<oplus>\n                        DenyAllFromTo\n                         (first_destNet (DenyAllFromTo src dest))\n                         (first_srcNet (DenyAllFromTo src dest)) \\<oplus>\n                        DenyAllFromTo src dest #\n                        insertDenies p)))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "case (AllowPortFromTo src dest port)"], ["proof (state)\nthis:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (AllowPortFromTo src dest port # p)))\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (AllowPortFromTo src dest port # p)))\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (AllowPortFromTo src dest port # p)))\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (C (list2FWpolicy\n                     (case AllowPortFromTo src dest port of\n                      DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                      | _ \\<Rightarrow>\n                          DenyAllFromTo\n                           (first_srcNet (AllowPortFromTo src dest port))\n                           (first_destNet\n                             (AllowPortFromTo src dest port)) \\<oplus>\n                          DenyAllFromTo\n                           (first_destNet (AllowPortFromTo src dest port))\n                           (first_srcNet\n                             (AllowPortFromTo src dest port)) \\<oplus>\n                          AllowPortFromTo src dest port #\n                          insertDenies p)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C (list2FWpolicy (AllowPortFromTo src dest port # p)));\n     x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (DenyAllFromTo src dest \\<oplus>\n  DenyAllFromTo dest src \\<oplus> AllowPortFromTo src dest port #\n  insertDenies p)))", "by(rule InDomConc, simp  add: idNMT)"], ["proof (state)\nthis:\n  x \\<in> dom (C (list2FWpolicy\n                   (case AllowPortFromTo src dest port of\n                    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                    | _ \\<Rightarrow>\n                        DenyAllFromTo\n                         (first_srcNet (AllowPortFromTo src dest port))\n                         (first_destNet\n                           (AllowPortFromTo src dest port)) \\<oplus>\n                        DenyAllFromTo\n                         (first_destNet (AllowPortFromTo src dest port))\n                         (first_srcNet\n                           (AllowPortFromTo src dest port)) \\<oplus>\n                        AllowPortFromTo src dest port #\n                        insertDenies p)))\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "case (Conc _ _)"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n   x \\<in> dom (C (list2FWpolicy (a1_ # p)));\n   x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n                                     (case a1_ of\nDenyAll \\<Rightarrow> DenyAll # insertDenies p\n| _ \\<Rightarrow>\n    DenyAllFromTo (first_srcNet a1_) (first_destNet a1_) \\<oplus>\n    DenyAllFromTo (first_destNet a1_) (first_srcNet a1_) \\<oplus> a1_ #\n    insertDenies p)))\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n   x \\<in> dom (C (list2FWpolicy (a2_ # p)));\n   x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n                                     (case a2_ of\nDenyAll \\<Rightarrow> DenyAll # insertDenies p\n| _ \\<Rightarrow>\n    DenyAllFromTo (first_srcNet a2_) (first_destNet a2_) \\<oplus>\n    DenyAllFromTo (first_destNet a2_) (first_srcNet a2_) \\<oplus> a2_ #\n    insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (a1_ \\<oplus> a2_ # p)))\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n   x \\<in> dom (C (list2FWpolicy (a1_ # p)));\n   x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n                                     (case a1_ of\nDenyAll \\<Rightarrow> DenyAll # insertDenies p\n| _ \\<Rightarrow>\n    DenyAllFromTo (first_srcNet a1_) (first_destNet a1_) \\<oplus>\n    DenyAllFromTo (first_destNet a1_) (first_srcNet a1_) \\<oplus> a1_ #\n    insertDenies p)))\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n   x \\<in> dom (C (list2FWpolicy (a2_ # p)));\n   x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n                                     (case a2_ of\nDenyAll \\<Rightarrow> DenyAll # insertDenies p\n| _ \\<Rightarrow>\n    DenyAllFromTo (first_srcNet a2_) (first_destNet a2_) \\<oplus>\n    DenyAllFromTo (first_destNet a2_) (first_srcNet a2_) \\<oplus> a2_ #\n    insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (a1_ \\<oplus> a2_ # p)))\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n   x \\<in> dom (C (list2FWpolicy (a1_ # p)));\n   x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n                                     (case a1_ of\nDenyAll \\<Rightarrow> DenyAll # insertDenies p\n| _ \\<Rightarrow>\n    DenyAllFromTo (first_srcNet a1_) (first_destNet a1_) \\<oplus>\n    DenyAllFromTo (first_destNet a1_) (first_srcNet a1_) \\<oplus> a1_ #\n    insertDenies p)))\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n   x \\<in> dom (C (list2FWpolicy (a2_ # p)));\n   x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n                                     (case a2_ of\nDenyAll \\<Rightarrow> DenyAll # insertDenies p\n| _ \\<Rightarrow>\n    DenyAllFromTo (first_srcNet a2_) (first_destNet a2_) \\<oplus>\n    DenyAllFromTo (first_destNet a2_) (first_srcNet a2_) \\<oplus> a2_ #\n    insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (a1_ \\<oplus> a2_ # p)))\n  x \\<in> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (C (list2FWpolicy\n                     (case a1_ \\<oplus> a2_ of\n                      DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                      | _ \\<Rightarrow>\n                          DenyAllFromTo (first_srcNet (a1_ \\<oplus> a2_))\n                           (first_destNet (a1_ \\<oplus> a2_)) \\<oplus>\n                          DenyAllFromTo (first_destNet (a1_ \\<oplus> a2_))\n                           (first_srcNet (a1_ \\<oplus> a2_)) \\<oplus>\n                          a1_ \\<oplus> a2_ #\n                          insertDenies p)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (C (list2FWpolicy (a1_ # p))) \\<Longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (case a1_ of\n                               DenyAll \\<Rightarrow>\n                                 DenyAll # insertDenies p\n                               | _ \\<Rightarrow>\n                                   DenyAllFromTo (first_srcNet a1_)\n                                    (first_destNet a1_) \\<oplus>\n                                   DenyAllFromTo (first_destNet a1_)\n                                    (first_srcNet a1_) \\<oplus>\n                                   a1_ #\n                                   insertDenies p)));\n     x \\<in> dom (C (list2FWpolicy (a2_ # p))) \\<Longrightarrow>\n     x \\<in> dom (C (list2FWpolicy\n                      (case a2_ of\n                       DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                       | _ \\<Rightarrow>\n                           DenyAllFromTo (first_srcNet a2_)\n                            (first_destNet a2_) \\<oplus>\n                           DenyAllFromTo (first_destNet a2_)\n                            (first_srcNet a2_) \\<oplus>\n                           a2_ #\n                           insertDenies p)));\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C (list2FWpolicy (a1_ \\<oplus> a2_ # p)));\n     x \\<in> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (DenyAllFromTo (first_srcNet a1_) (first_destNet a1_) \\<oplus>\n  DenyAllFromTo (first_destNet a1_) (first_srcNet a1_) \\<oplus>\n  a1_ \\<oplus> a2_ #\n  insertDenies p)))", "by(rule InDomConc, simp add: idNMT)"], ["proof (state)\nthis:\n  x \\<in> dom (C (list2FWpolicy\n                   (case a1_ \\<oplus> a2_ of\n                    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                    | _ \\<Rightarrow>\n                        DenyAllFromTo (first_srcNet (a1_ \\<oplus> a2_))\n                         (first_destNet (a1_ \\<oplus> a2_)) \\<oplus>\n                        DenyAllFromTo (first_destNet (a1_ \\<oplus> a2_))\n                         (first_srcNet (a1_ \\<oplus> a2_)) \\<oplus>\n                        a1_ \\<oplus> a2_ #\n                        insertDenies p)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> dom (C (list2FWpolicy\n                   (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                    | _ \\<Rightarrow>\n                        DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a #\n                        insertDenies p)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C (list2FWpolicy (a # p)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n  | _ \\<Rightarrow>\n      DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n      DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n      insertDenies p)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C (list2FWpolicy (a # p)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n  | _ \\<Rightarrow>\n      DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n      DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n      insertDenies p)))", "case 2"], ["proof (state)\nthis:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (a # p)))\n  x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C (list2FWpolicy (a # p)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n  | _ \\<Rightarrow>\n      DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n      DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n      insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (a # p)))\n  x \\<notin> dom (C (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (a # p)))\n  x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (C (list2FWpolicy\n                     (case a of\n                      DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                      | _ \\<Rightarrow>\n                          DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a #\n                          insertDenies p)))", "proof (induct a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C (list2FWpolicy (DenyAll # p)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (case DenyAll of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n  | _ \\<Rightarrow>\n      DenyAllFromTo (first_srcNet DenyAll) (first_destNet DenyAll) \\<oplus>\n      DenyAllFromTo (first_destNet DenyAll) (first_srcNet DenyAll) \\<oplus>\n      DenyAll #\n      insertDenies p)))\n 2. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 3. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (C (list2FWpolicy\n                                     (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "case DenyAll"], ["proof (state)\nthis:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (DenyAll # p)))\n  x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C (list2FWpolicy (DenyAll # p)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n (case DenyAll of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n  | _ \\<Rightarrow>\n      DenyAllFromTo (first_srcNet DenyAll) (first_destNet DenyAll) \\<oplus>\n      DenyAllFromTo (first_destNet DenyAll) (first_srcNet DenyAll) \\<oplus>\n      DenyAll #\n      insertDenies p)))\n 2. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 3. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (C (list2FWpolicy\n                                     (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (DenyAll # p)))\n  x \\<notin> dom (C (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (DenyAll # p)))\n  x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (C (list2FWpolicy\n                     (case DenyAll of\n                      DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                      | _ \\<Rightarrow>\n                          DenyAllFromTo (first_srcNet DenyAll)\n                           (first_destNet DenyAll) \\<oplus>\n                          DenyAllFromTo (first_destNet DenyAll)\n                           (first_srcNet DenyAll) \\<oplus>\n                          DenyAll #\n                          insertDenies p)))", "by simp"], ["proof (state)\nthis:\n  x \\<in> dom (C (list2FWpolicy\n                   (case DenyAll of\n                    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                    | _ \\<Rightarrow>\n                        DenyAllFromTo (first_srcNet DenyAll)\n                         (first_destNet DenyAll) \\<oplus>\n                        DenyAllFromTo (first_destNet DenyAll)\n                         (first_srcNet DenyAll) \\<oplus>\n                        DenyAll #\n                        insertDenies p)))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (C (list2FWpolicy\n                                     (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (C (list2FWpolicy\n                                     (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "case (DenyAllFromTo src dest)"], ["proof (state)\nthis:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (DenyAllFromTo src dest # p)))\n  x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (C (list2FWpolicy\n                                     (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (DenyAllFromTo src dest # p)))\n  x \\<notin> dom (C (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (DenyAllFromTo src dest # p)))\n  x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (C (list2FWpolicy\n                     (case DenyAllFromTo src dest of\n                      DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                      | _ \\<Rightarrow>\n                          DenyAllFromTo\n                           (first_srcNet (DenyAllFromTo src dest))\n                           (first_destNet (DenyAllFromTo src dest)) \\<oplus>\n                          DenyAllFromTo\n                           (first_destNet (DenyAllFromTo src dest))\n                           (first_srcNet (DenyAllFromTo src dest)) \\<oplus>\n                          DenyAllFromTo src dest #\n                          insertDenies p)))", "by(simp,metis domIff CConcStartA list2FWpolicyconc nlpaux Cdom2)"], ["proof (state)\nthis:\n  x \\<in> dom (C (list2FWpolicy\n                   (case DenyAllFromTo src dest of\n                    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                    | _ \\<Rightarrow>\n                        DenyAllFromTo\n                         (first_srcNet (DenyAllFromTo src dest))\n                         (first_destNet (DenyAllFromTo src dest)) \\<oplus>\n                        DenyAllFromTo\n                         (first_destNet (DenyAllFromTo src dest))\n                         (first_srcNet (DenyAllFromTo src dest)) \\<oplus>\n                        DenyAllFromTo src dest #\n                        insertDenies p)))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (C (list2FWpolicy\n                                     (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (C (list2FWpolicy\n                                     (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "case (AllowPortFromTo src dest port)"], ["proof (state)\nthis:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (AllowPortFromTo src dest port # p)))\n  x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (C (list2FWpolicy\n                                     (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (AllowPortFromTo src dest port # p)))\n  x \\<notin> dom (C (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (AllowPortFromTo src dest port # p)))\n  x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (C (list2FWpolicy\n                     (case AllowPortFromTo src dest port of\n                      DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                      | _ \\<Rightarrow>\n                          DenyAllFromTo\n                           (first_srcNet (AllowPortFromTo src dest port))\n                           (first_destNet\n                             (AllowPortFromTo src dest port)) \\<oplus>\n                          DenyAllFromTo\n                           (first_destNet (AllowPortFromTo src dest port))\n                           (first_srcNet\n                             (AllowPortFromTo src dest port)) \\<oplus>\n                          AllowPortFromTo src dest port #\n                          insertDenies p)))", "by(simp,metis domIff CConcStartA list2FWpolicyconc nlpaux Cdom2)"], ["proof (state)\nthis:\n  x \\<in> dom (C (list2FWpolicy\n                   (case AllowPortFromTo src dest port of\n                    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                    | _ \\<Rightarrow>\n                        DenyAllFromTo\n                         (first_srcNet (AllowPortFromTo src dest port))\n                         (first_destNet\n                           (AllowPortFromTo src dest port)) \\<oplus>\n                        DenyAllFromTo\n                         (first_destNet (AllowPortFromTo src dest port))\n                         (first_srcNet\n                           (AllowPortFromTo src dest port)) \\<oplus>\n                        AllowPortFromTo src dest port #\n                        insertDenies p)))\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (C (list2FWpolicy\n                                     (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (C (list2FWpolicy\n                                     (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "case (Conc _ _)"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n   x \\<in> dom (C (list2FWpolicy (a1_ # p)));\n   x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n                                     (case a1_ of\nDenyAll \\<Rightarrow> DenyAll # insertDenies p\n| _ \\<Rightarrow>\n    DenyAllFromTo (first_srcNet a1_) (first_destNet a1_) \\<oplus>\n    DenyAllFromTo (first_destNet a1_) (first_srcNet a1_) \\<oplus> a1_ #\n    insertDenies p)))\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n   x \\<in> dom (C (list2FWpolicy (a2_ # p)));\n   x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n                                     (case a2_ of\nDenyAll \\<Rightarrow> DenyAll # insertDenies p\n| _ \\<Rightarrow>\n    DenyAllFromTo (first_srcNet a2_) (first_destNet a2_) \\<oplus>\n    DenyAllFromTo (first_destNet a2_) (first_srcNet a2_) \\<oplus> a2_ #\n    insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (a1_ \\<oplus> a2_ # p)))\n  x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (C (list2FWpolicy p));\n                 x \\<in> dom (C (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (C (list2FWpolicy\n                                     (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (C (list2FWpolicy\n          (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n           | _ \\<Rightarrow>\n               DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n               DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n               a1 #\n               insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n         x \\<in> dom (C (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (C\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n        x \\<in> dom (C (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (C\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n   x \\<in> dom (C (list2FWpolicy (a1_ # p)));\n   x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n                                     (case a1_ of\nDenyAll \\<Rightarrow> DenyAll # insertDenies p\n| _ \\<Rightarrow>\n    DenyAllFromTo (first_srcNet a1_) (first_destNet a1_) \\<oplus>\n    DenyAllFromTo (first_destNet a1_) (first_srcNet a1_) \\<oplus> a1_ #\n    insertDenies p)))\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n   x \\<in> dom (C (list2FWpolicy (a2_ # p)));\n   x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n                                     (case a2_ of\nDenyAll \\<Rightarrow> DenyAll # insertDenies p\n| _ \\<Rightarrow>\n    DenyAllFromTo (first_srcNet a2_) (first_destNet a2_) \\<oplus>\n    DenyAllFromTo (first_destNet a2_) (first_srcNet a2_) \\<oplus> a2_ #\n    insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (a1_ \\<oplus> a2_ # p)))\n  x \\<notin> dom (C (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n   x \\<in> dom (C (list2FWpolicy (a1_ # p)));\n   x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n                                     (case a1_ of\nDenyAll \\<Rightarrow> DenyAll # insertDenies p\n| _ \\<Rightarrow>\n    DenyAllFromTo (first_srcNet a1_) (first_destNet a1_) \\<oplus>\n    DenyAllFromTo (first_destNet a1_) (first_srcNet a1_) \\<oplus> a1_ #\n    insertDenies p)))\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n   x \\<in> dom (C (list2FWpolicy (a2_ # p)));\n   x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (C (list2FWpolicy\n                                     (case a2_ of\nDenyAll \\<Rightarrow> DenyAll # insertDenies p\n| _ \\<Rightarrow>\n    DenyAllFromTo (first_srcNet a2_) (first_destNet a2_) \\<oplus>\n    DenyAllFromTo (first_destNet a2_) (first_srcNet a2_) \\<oplus> a2_ #\n    insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (C (list2FWpolicy p))\n  x \\<in> dom (C (list2FWpolicy (a1_ \\<oplus> a2_ # p)))\n  x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (C (list2FWpolicy\n                     (case a1_ \\<oplus> a2_ of\n                      DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                      | _ \\<Rightarrow>\n                          DenyAllFromTo (first_srcNet (a1_ \\<oplus> a2_))\n                           (first_destNet (a1_ \\<oplus> a2_)) \\<oplus>\n                          DenyAllFromTo (first_destNet (a1_ \\<oplus> a2_))\n                           (first_srcNet (a1_ \\<oplus> a2_)) \\<oplus>\n                          a1_ \\<oplus> a2_ #\n                          insertDenies p)))", "by (simp,metis CConcStartA Cdom2 domIff domdConcStart)"], ["proof (state)\nthis:\n  x \\<in> dom (C (list2FWpolicy\n                   (case a1_ \\<oplus> a2_ of\n                    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                    | _ \\<Rightarrow>\n                        DenyAllFromTo (first_srcNet (a1_ \\<oplus> a2_))\n                         (first_destNet (a1_ \\<oplus> a2_)) \\<oplus>\n                        DenyAllFromTo (first_destNet (a1_ \\<oplus> a2_))\n                         (first_srcNet (a1_ \\<oplus> a2_)) \\<oplus>\n                        a1_ \\<oplus> a2_ #\n                        insertDenies p)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> dom (C (list2FWpolicy\n                   (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                    | _ \\<Rightarrow>\n                        DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a #\n                        insertDenies p)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a # p \\<noteq> [] \\<and>\n  x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a # p \\<noteq> [] \\<and>\n  x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a # p \\<noteq> [] \\<and>\n  x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies (a # p))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma DA_is_deny: \n  \"x \\<in> dom (C (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)) \\<Longrightarrow>\n   C (DenyAllFromTo a b\\<oplus>DenyAllFromTo b a \\<oplus> DenyAllFromTo a b) x = Some (deny ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (C (DenyAllFromTo a b \\<oplus>\n                    DenyAllFromTo b a \\<oplus>\n                    DenyAllFromTo a b)) \\<Longrightarrow>\n    C (DenyAllFromTo a b \\<oplus>\n       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n     x =\n    \\<lfloor>deny ()\\<rfloor>", "apply (case_tac \"x \\<in> dom (C (DenyAllFromTo a b))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> dom (C (DenyAllFromTo a b \\<oplus>\n                             DenyAllFromTo b a \\<oplus> DenyAllFromTo a b));\n     x \\<in> dom (C (DenyAllFromTo a b))\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo a b \\<oplus>\n                         DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>x \\<in> dom (C (DenyAllFromTo a b \\<oplus>\n                             DenyAllFromTo b a \\<oplus> DenyAllFromTo a b));\n     x \\<notin> dom (C (DenyAllFromTo a b))\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo a b \\<oplus>\n                         DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (simp_all add: PLemmas)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>y.\n                (case case if (\\<exists>xa\\<in>a.\n                                  fst (snd x) \\<in> xa) \\<and>\n                              (\\<exists>xa\\<in>b.\n                                  fst (snd (snd x)) \\<in> xa)\n                           then D\\<^sub>U x else \\<bottom> of\n                      \\<bottom> \\<Rightarrow>\n                        if Bex b ((\\<in>) (fst (snd x))) \\<and>\n                           Bex a ((\\<in>) (fst (snd (snd x))))\n                        then D\\<^sub>U x else \\<bottom>\n                      | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                          \\<lfloor>x\\<rfloor> of\n                 \\<bottom> \\<Rightarrow>\n                   if Bex a ((\\<in>) (fst (snd x))) \\<and>\n                      Bex b ((\\<in>) (fst (snd (snd x))))\n                   then D\\<^sub>U x else \\<bottom>\n                 | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n                \\<lfloor>y\\<rfloor>;\n     \\<exists>y.\n        (if (\\<exists>xa\\<in>a. fst (snd x) \\<in> xa) \\<and>\n            (\\<exists>xa\\<in>b. fst (snd (snd x)) \\<in> xa)\n         then D\\<^sub>U x else \\<bottom>) =\n        \\<lfloor>y\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> ((\\<forall>xa\\<in>b.\n                           fst (snd x) \\<notin> xa) \\<longrightarrow>\n                       Bex a ((\\<in>) (fst (snd x))) \\<and>\n                       Bex b ((\\<in>) (fst (snd (snd x))))) \\<and>\n                      ((\\<forall>xa\\<in>a.\n                           fst (snd (snd x)) \\<notin> xa) \\<longrightarrow>\n                       Bex a ((\\<in>) (fst (snd x))) \\<and>\n                       Bex b ((\\<in>) (fst (snd (snd x)))))\n 2. \\<lbrakk>\\<exists>y.\n                (case if (\\<exists>xa\\<in>b. fst (snd x) \\<in> xa) \\<and>\n                         (\\<exists>xa\\<in>a. fst (snd (snd x)) \\<in> xa)\n                      then D\\<^sub>U x else \\<bottom> of\n                 \\<bottom> \\<Rightarrow>\n                   if Bex a ((\\<in>) (fst (snd x))) \\<and>\n                      Bex b ((\\<in>) (fst (snd (snd x))))\n                   then D\\<^sub>U x else \\<bottom>\n                 | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n                \\<lfloor>y\\<rfloor>;\n     (if (\\<exists>xa\\<in>a. fst (snd x) \\<in> xa) \\<and>\n         (\\<exists>xa\\<in>b. fst (snd (snd x)) \\<in> xa)\n      then D\\<^sub>U x else \\<bottom>) =\n     \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> Bex b ((\\<in>) (fst (snd x))) \\<and>\n                      Bex a ((\\<in>) (fst (snd (snd x))))", "apply (simp_all split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iDdomAux[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow>\n   x \\<in> dom (C (list2FWpolicy (insertDenies p))) \\<longrightarrow>\n   C (list2FWpolicy (insertDenies p)) x = Some (deny ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (insertDenies p))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies p)) x = \\<lfloor>deny ()\\<rfloor>", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy [])) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (insertDenies []))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies [])) x = \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (insertDenies p))) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies p)) x =\n       \\<lfloor>deny ()\\<rfloor> \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy\n                        (insertDenies (a # p)))) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies (a # p))) x =\n       \\<lfloor>deny ()\\<rfloor>", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy [])) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (insertDenies []))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies [])) x = \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (insertDenies p))) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies p)) x =\n       \\<lfloor>deny ()\\<rfloor> \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy\n                        (insertDenies (a # p)))) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies (a # p))) x =\n       \\<lfloor>deny ()\\<rfloor>", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy [])) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (insertDenies []))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies [])) x = \\<lfloor>deny ()\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy [])) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies []))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies [])) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (insertDenies p))) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies p)) x =\n       \\<lfloor>deny ()\\<rfloor> \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy\n                        (insertDenies (a # p)))) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies (a # p))) x =\n       \\<lfloor>deny ()\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (insertDenies p))) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies p)) x =\n       \\<lfloor>deny ()\\<rfloor> \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy\n                        (insertDenies (a # p)))) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies (a # p))) x =\n       \\<lfloor>deny ()\\<rfloor>", "case (Cons y ys)"], ["proof (state)\nthis:\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (insertDenies p))) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies p)) x =\n       \\<lfloor>deny ()\\<rfloor> \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy\n                        (insertDenies (a # p)))) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies (a # p))) x =\n       \\<lfloor>deny ()\\<rfloor>", "thus ?case"], ["proof (prove)\nusing this:\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy\n                     (insertDenies (y # ys)))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "proof (cases y)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n             x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (insertDenies ys))) \\<longrightarrow>\n             C (list2FWpolicy (insertDenies ys)) x =\n             \\<lfloor>deny ()\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (insertDenies (y # ys)))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 4. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "case DenyAll"], ["proof (state)\nthis:\n  y = DenyAll\n\ngoal (4 subgoals):\n 1. \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n             x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (insertDenies ys))) \\<longrightarrow>\n             C (list2FWpolicy (insertDenies ys)) x =\n             \\<lfloor>deny ()\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (insertDenies (y # ys)))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 4. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = DenyAll", "show ?thesis"], ["proof (prove)\nusing this:\n  y = DenyAll\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy\n                     (insertDenies (y # ys)))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 3. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 3. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "case (DenyAllFromTo a b)"], ["proof (state)\nthis:\n  y = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 3. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = DenyAllFromTo a b", "show ?thesis"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy\n                     (insertDenies (y # ys)))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "using DenyAllFromTo Cons"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n  y = DenyAllFromTo a b\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy\n                     (insertDenies (y # ys)))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x =\n     \\<lfloor>deny ()\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C\n (list2FWpolicy (DenyAllFromTo a b # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n  insertDenies ys))) \\<longrightarrow>\n                      C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (intro impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "proof (cases \"ys = []\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys = []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "case 1"], ["proof (state)\nthis:\n  y = DenyAllFromTo a b\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)))\n  x \\<in> dom (C (list2FWpolicy\n                   (DenyAllFromTo a b \\<oplus>\n                    DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                    insertDenies ys)))\n  ys = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys = []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = DenyAllFromTo a b\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)))\n  x \\<in> dom (C (list2FWpolicy\n                   (DenyAllFromTo a b \\<oplus>\n                    DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                    insertDenies ys)))\n  ys = []", "show ?case"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)))\n  x \\<in> dom (C (list2FWpolicy\n                   (DenyAllFromTo a b \\<oplus>\n                    DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                    insertDenies ys)))\n  ys = []\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy\n        (DenyAllFromTo a b \\<oplus>\n         DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n         insertDenies ys))\n     x =\n    \\<lfloor>deny ()\\<rfloor>", "by (simp add: DA_is_deny)"], ["proof (state)\nthis:\n  C (list2FWpolicy\n      (DenyAllFromTo a b \\<oplus>\n       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n       insertDenies ys))\n   x =\n  \\<lfloor>deny ()\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "case 2"], ["proof (state)\nthis:\n  y = DenyAllFromTo a b\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)))\n  x \\<in> dom (C (list2FWpolicy\n                   (DenyAllFromTo a b \\<oplus>\n                    DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                    insertDenies ys)))\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = DenyAllFromTo a b\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)))\n  x \\<in> dom (C (list2FWpolicy\n                   (DenyAllFromTo a b \\<oplus>\n                    DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                    insertDenies ys)))\n  ys \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)))\n  x \\<in> dom (C (list2FWpolicy\n                   (DenyAllFromTo a b \\<oplus>\n                    DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                    insertDenies ys)))\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. C (list2FWpolicy\n        (DenyAllFromTo a b \\<oplus>\n         DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n         insertDenies ys))\n     x =\n    \\<lfloor>deny ()\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (drule mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (list2FWpolicy ys))\n 2. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> [];\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x =\n     \\<lfloor>deny ()\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (metis DenyAllFromTo InDomConc )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> [];\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x =\n     \\<lfloor>deny ()\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (cases \"x \\<in> dom (C (list2FWpolicy (insertDenies ys)))\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> [];\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (metis Cdom2 DenyAllFromTo  idNMT list2FWpolicyconc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (subgoal_tac \"C (list2FWpolicy (DenyAllFromTo a b \\<oplus>\n                                DenyAllFromTo b a \\<oplus> DenyAllFromTo a b#insertDenies ys)) x =\n                                C ((DenyAllFromTo a b \\<oplus> DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)) x \")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> []; x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo a b \\<oplus>\n          DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo a b \\<oplus>\n        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n      x\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      C (DenyAllFromTo a b \\<oplus>\n                         DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n                       x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> []; x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo a b \\<oplus>\n          DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo a b \\<oplus>\n        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n      x\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo a b \\<oplus>\n                         DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      C (DenyAllFromTo a b \\<oplus>\n                         DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n                       x", "apply (rule DA_is_deny)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> []; x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo a b \\<oplus>\n          DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo a b \\<oplus>\n        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n      x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo a b \\<oplus>\nDenyAllFromTo b a \\<oplus> DenyAllFromTo a b))\n 2. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      C (DenyAllFromTo a b \\<oplus>\n                         DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n                       x", "apply (metis DenyAllFromTo domdConcStart)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                       insertDenies ys)));\n     ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      C (DenyAllFromTo a b \\<oplus>\n                         DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n                       x", "apply (metis DenyAllFromTo l2p_aux2 list2FWpolicyconc nlpaux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  C (list2FWpolicy\n      (DenyAllFromTo a b \\<oplus>\n       DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n       insertDenies ys))\n   x =\n  \\<lfloor>deny ()\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "case (AllowPortFromTo a b c)"], ["proof (state)\nthis:\n  y = AllowPortFromTo a b c\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = AllowPortFromTo a b c", "show ?thesis"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a b c\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy\n                     (insertDenies (y # ys)))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "using Cons AllowPortFromTo"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a b c\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  y = AllowPortFromTo a b c\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy\n                     (insertDenies (y # ys)))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "proof (cases \"ys = []\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys = []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (insertDenies (y # ys)))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (insertDenies (y # ys)))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "case 1"], ["proof (state)\nthis:\n  y = AllowPortFromTo a b c\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  y = AllowPortFromTo a b c\n  ys = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys = []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (insertDenies (y # ys)))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (insertDenies (y # ys)))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = AllowPortFromTo a b c\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  y = AllowPortFromTo a b c\n  ys = []", "show ?case"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a b c\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  y = AllowPortFromTo a b c\n  ys = []\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy\n                     (insertDenies (y # ys)))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys = []\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C\n (AllowPortFromTo a b c)) \\<longrightarrow>\n                      x \\<in> dom (C (DenyAllFromTo a b \\<oplus>\nDenyAllFromTo b a \\<oplus> AllowPortFromTo a b c)) \\<longrightarrow>\n                      C (DenyAllFromTo a b \\<oplus>\n                         DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (intro impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys = [];\n     x \\<notin> dom (C (AllowPortFromTo a b c));\n     x \\<in> dom (C (DenyAllFromTo a b \\<oplus>\n                     DenyAllFromTo b a \\<oplus>\n                     AllowPortFromTo a b c))\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo a b \\<oplus>\n                         DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (subgoal_tac \"x \\<in> dom (C (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys = [];\n     x \\<notin> dom (C (AllowPortFromTo a b c));\n     x \\<in> dom (C (DenyAllFromTo a b \\<oplus>\n                     DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c));\n     x \\<in> dom (C (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a))\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo a b \\<oplus>\n                         DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = AllowPortFromTo a b c; ys = [];\n     x \\<notin> dom (C (AllowPortFromTo a b c));\n     x \\<in> dom (C (DenyAllFromTo a b \\<oplus>\n                     DenyAllFromTo b a \\<oplus>\n                     AllowPortFromTo a b c))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo a b \\<oplus>\nDenyAllFromTo b a))", "apply (simp_all add: PLemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys = [];\n     (if dest_port x = c\n      then if Bex a ((\\<in>) (fst (snd x))) \\<and>\n              Bex b ((\\<in>) (fst (snd (snd x))))\n           then A\\<^sub>U x else \\<bottom>\n      else \\<bottom>) =\n     \\<bottom>;\n     \\<exists>y.\n        (case if (\\<exists>xa\\<in>b. fst (snd x) \\<in> xa) \\<and>\n                 (\\<exists>xa\\<in>a. fst (snd (snd x)) \\<in> xa)\n              then D\\<^sub>U x else \\<bottom> of\n         \\<bottom> \\<Rightarrow>\n           if Bex a ((\\<in>) (fst (snd x))) \\<and>\n              Bex b ((\\<in>) (fst (snd (snd x))))\n           then D\\<^sub>U x else \\<bottom>\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> ((\\<forall>xa\\<in>a.\n                           fst (snd x) \\<notin> xa) \\<longrightarrow>\n                       Bex b ((\\<in>) (fst (snd x))) \\<and>\n                       Bex a ((\\<in>) (fst (snd (snd x))))) \\<and>\n                      ((\\<forall>xa\\<in>b.\n                           fst (snd (snd x)) \\<notin> xa) \\<longrightarrow>\n                       Bex b ((\\<in>) (fst (snd x))) \\<and>\n                       Bex a ((\\<in>) (fst (snd (snd x)))))", "apply (simp split: if_splits, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (insertDenies (y # ys)))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (insertDenies (y # ys)))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "case 2"], ["proof (state)\nthis:\n  y = AllowPortFromTo a b c\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  y = AllowPortFromTo a b c\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (insertDenies (y # ys)))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = AllowPortFromTo a b c\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  y = AllowPortFromTo a b c\n  ys \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a b c\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  y = AllowPortFromTo a b c\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy\n                     (insertDenies (y # ys)))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (insertDenies ys))) \\<longrightarrow>\n             C (list2FWpolicy (insertDenies ys)) x =\n             \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C\n (list2FWpolicy (AllowPortFromTo a b c # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (DenyAllFromTo a b \\<oplus>\n  DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n  insertDenies ys))) \\<longrightarrow>\n                      C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (intro impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy\n                              (insertDenies ys))) \\<longrightarrow>\n             C (list2FWpolicy (insertDenies ys)) x =\n             \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                       insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (drule mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                       insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (list2FWpolicy ys))\n 2. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                       insertDenies ys)));\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x =\n     \\<lfloor>deny ()\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (metis AllowPortFromTo InDomConc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                       insertDenies ys)));\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x =\n     \\<lfloor>deny ()\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (cases \"x \\<in> dom (C (list2FWpolicy (insertDenies ys)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                       insertDenies ys)));\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                       insertDenies ys)));\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                       insertDenies ys)));\n     C (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (metis AllowPortFromTo Cdom2 idNMT list2FWpolicyconc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (subgoal_tac \"C (list2FWpolicy (DenyAllFromTo a b \\<oplus>\n                                DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c#insertDenies ys)) x =\n                                C ((DenyAllFromTo a b \\<oplus> DenyAllFromTo b a)) x \")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo a b \\<oplus>\n          DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a) x\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      C (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a) x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo a b \\<oplus>\n          DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a) x\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a) x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      C (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a) x", "defer 1"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      C (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a) x\n 2. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo a b \\<oplus>\n          DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a) x\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a) x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (metis AllowPortFromTo CConcStartA ConcAssoc idNMT  list2FWpolicyconc nlpaux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo a b \\<oplus>\n                       DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo a b \\<oplus>\n          DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a) x\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a) x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (simp add: PLemmas, simp split: if_splits, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "case (Conc a b)"], ["proof (state)\nthis:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy\n                                 (insertDenies ys))) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (C\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = a \\<oplus> b", "show ?thesis"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy\n                     (insertDenies (y # ys)))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "proof (cases \"ys = []\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys = []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (insertDenies (y # ys)))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (insertDenies (y # ys)))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "case 1"], ["proof (state)\nthis:\n  y = a \\<oplus> b\n  ys = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys = []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (insertDenies (y # ys)))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (insertDenies (y # ys)))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = a \\<oplus> b\n  ys = []", "show ?case"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n  ys = []\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy\n                     (insertDenies (y # ys)))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys = []\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (a \\<oplus> b)) \\<longrightarrow>\n                      x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n (first_destNet a) \\<oplus>\nDenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\na \\<oplus> b)) \\<longrightarrow>\n                      C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<oplus> b)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (rule impI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys = []; x \\<notin> dom (C (a \\<oplus> b));\n     x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n                      (first_destNet a) \\<oplus>\n                     DenyAllFromTo (first_destNet a)\n                      (first_srcNet a) \\<oplus>\n                     a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<oplus> b)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (subgoal_tac \"x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n                                (first_destNet a) \\<oplus> DenyAllFromTo (first_destNet a) (first_srcNet a)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys = []; x \\<notin> dom (C (a \\<oplus> b));\n     x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n                      (first_destNet a) \\<oplus>\n                     DenyAllFromTo (first_destNet a)\n                      (first_srcNet a) \\<oplus>\n                     a \\<oplus> b));\n     x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n                      (first_destNet a) \\<oplus>\n                     DenyAllFromTo (first_destNet a)\n                      (first_srcNet a)))\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<oplus> b)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = a \\<oplus> b; ys = []; x \\<notin> dom (C (a \\<oplus> b));\n     x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n                      (first_destNet a) \\<oplus>\n                     DenyAllFromTo (first_destNet a)\n                      (first_srcNet a) \\<oplus>\n                     a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n (first_destNet a) \\<oplus>\nDenyAllFromTo (first_destNet a) (first_srcNet a)))", "apply (simp_all add: PLemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys = [];\n     (case C b x of \\<bottom> \\<Rightarrow> C a x\n      | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n     \\<bottom>;\n     \\<exists>y.\n        (case if (\\<exists>xa\\<in>first_destNet a.\n                     fst (snd x) \\<in> xa) \\<and>\n                 (\\<exists>xa\\<in>first_srcNet a.\n                     fst (snd (snd x)) \\<in> xa)\n              then D\\<^sub>U x else \\<bottom> of\n         \\<bottom> \\<Rightarrow>\n           if Bex (first_srcNet a) ((\\<in>) (fst (snd x))) \\<and>\n              Bex (first_destNet a) ((\\<in>) (fst (snd (snd x))))\n           then D\\<^sub>U x else \\<bottom>\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> ((\\<forall>xa\\<in>first_srcNet a.\n                           fst (snd x) \\<notin> xa) \\<longrightarrow>\n                       Bex (first_destNet a) ((\\<in>) (fst (snd x))) \\<and>\n                       Bex (first_srcNet a)\n                        ((\\<in>) (fst (snd (snd x))))) \\<and>\n                      ((\\<forall>xa\\<in>first_destNet a.\n                           fst (snd (snd x)) \\<notin> xa) \\<longrightarrow>\n                       Bex (first_destNet a) ((\\<in>) (fst (snd x))) \\<and>\n                       Bex (first_srcNet a) ((\\<in>) (fst (snd (snd x)))))", "apply (simp split: if_splits, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (insertDenies (y # ys)))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (insertDenies (y # ys)))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "case 2"], ["proof (state)\nthis:\n  y = a \\<oplus> b\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (insertDenies (y # ys)))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = a \\<oplus> b\n  ys \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy\n                     (insertDenies (y # ys)))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C\n (list2FWpolicy (a \\<oplus> b # ys))) \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n  DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a \\<oplus> b #\n  insertDenies ys))) \\<longrightarrow>\n                      C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (intro impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (cases \"x \\<in> dom (C (list2FWpolicy (insertDenies ys)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (metis Cdom2 Conc Cons InDomConc idNMT list2FWpolicyconc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (subgoal_tac \"C (list2FWpolicy (DenyAllFromTo (first_srcNet a) \n                                   (first_destNet a) \\<oplus> DenyAllFromTo(first_destNet a)(first_srcNet a)\n                                   \\<oplus> a \\<oplus> b#insertDenies ys)) x =\n                                 C ((DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n                                   DenyAllFromTo (first_destNet a)  (first_srcNet a) \\<oplus> a \\<oplus> b)) x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n          DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n          a \\<oplus> b #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n        a \\<oplus> b)\n      x\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<oplus> b)\n                       x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n          DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n          a \\<oplus> b #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n        a \\<oplus> b)\n      x\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<oplus> b)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<oplus> b)\n                       x", "defer 1"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<oplus> b)\n                       x\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n          DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n          a \\<oplus> b #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n        a \\<oplus> b)\n      x\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<oplus> b)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (metis Conc l2p_aux2 list2FWpolicyconc nlpaux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n          DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n          a \\<oplus> b #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n        a \\<oplus> b)\n      x\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<oplus> b)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (subgoal_tac \"C((DenyAllFromTo (first_srcNet a)\n                                  (first_destNet a) \\<oplus> DenyAllFromTo (first_destNet a)\n                                  (first_srcNet a) \\<oplus> a \\<oplus> b)) x = \n                                 C((DenyAllFromTo (first_srcNet a)(first_destNet a) \\<oplus> \n                                   DenyAllFromTo(first_destNet a)(first_srcNet a))) x \")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n          DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n          a \\<oplus> b #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n        a \\<oplus> b)\n      x;\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n        a \\<oplus> b)\n      x =\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a))\n      x\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<oplus> b)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n          DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n          a \\<oplus> b #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n        a \\<oplus> b)\n      x\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<oplus> b)\n                       x =\n                      C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a) (first_srcNet a))\n                       x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n          DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n          a \\<oplus> b #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a))\n      x;\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n        a \\<oplus> b)\n      x =\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a))\n      x\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a) (first_srcNet a))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n          DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n          a \\<oplus> b #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n        a \\<oplus> b)\n      x\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<oplus> b)\n                       x =\n                      C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a) (first_srcNet a))\n                       x", "defer 1"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n          DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n          a \\<oplus> b #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n        a \\<oplus> b)\n      x\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<oplus> b)\n                       x =\n                      C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a) (first_srcNet a))\n                       x\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n          DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n          a \\<oplus> b #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a))\n      x;\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n        a \\<oplus> b)\n      x =\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a))\n      x\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a) (first_srcNet a))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (metis CConcStartA Conc ConcAssoc nlpaux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (C (list2FWpolicy\n                      (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<oplus> b #\n                       insertDenies ys)));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)));\n     C (list2FWpolicy\n         (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n          DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n          a \\<oplus> b #\n          insertDenies ys))\n      x =\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a))\n      x;\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n        a \\<oplus> b)\n      x =\n     C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a))\n      x\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a) (first_srcNet a))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (simp add: PLemmas, simp split: if_splits, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iD_isD[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow> \n   C (DenyAll \\<oplus> list2FWpolicy (insertDenies p)) x = C DenyAll x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow>\n    C (DenyAll \\<oplus> list2FWpolicy (insertDenies p)) x = C DenyAll x", "apply (case_tac \"x \\<in> dom (C (list2FWpolicy (insertDenies p)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> dom (C (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n    p \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow>\n    C (DenyAll \\<oplus> list2FWpolicy (insertDenies p)) x = C DenyAll x\n 2. x \\<notin> dom (C (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n    p \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow>\n    C (DenyAll \\<oplus> list2FWpolicy (insertDenies p)) x = C DenyAll x", "apply (simp add: Cdom2 PLemmas(1) deny_all_def iDdomAux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom (C (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n    p \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy p)) \\<longrightarrow>\n    C (DenyAll \\<oplus> list2FWpolicy (insertDenies p)) x = C DenyAll x", "by (simp add: nlpaux)"], ["", "lemma inDomConc:\"\\<lbrakk> x\\<notin>dom (C a); x\\<notin>dom (C (list2FWpolicy p))\\<rbrakk> \\<Longrightarrow>\n                 x \\<notin> dom (C (list2FWpolicy(a#p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> dom (C a);\n     x \\<notin> dom (C (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (list2FWpolicy (a # p)))", "by (metis domdConcStart)"], ["", "lemma domsdisj[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> (\\<forall> x s. s \\<in> set p \\<and> x \\<in> dom (C A) \\<longrightarrow>  x \\<notin> dom (C s)) \\<longrightarrow> y \\<in> dom (C A) \\<longrightarrow>\n   y \\<notin> dom (C (list2FWpolicy p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x s.\n        s \\<in> set p \\<and> x \\<in> dom (C A) \\<longrightarrow>\n        x \\<notin> dom (C s)) \\<longrightarrow>\n    y \\<in> dom (C A) \\<longrightarrow> y \\<notin> dom (C (list2FWpolicy p))", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x s.\n        s \\<in> set [] \\<and> x \\<in> dom (C A) \\<longrightarrow>\n        x \\<notin> dom (C s)) \\<longrightarrow>\n    y \\<in> dom (C A) \\<longrightarrow>\n    y \\<notin> dom (C (list2FWpolicy []))\n 2. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set p \\<and> x \\<in> dom (C A) \\<longrightarrow>\n           x \\<notin> dom (C s)) \\<longrightarrow>\n       y \\<in> dom (C A) \\<longrightarrow>\n       y \\<notin> dom (C (list2FWpolicy p)) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set (a # p) \\<and> x \\<in> dom (C A) \\<longrightarrow>\n           x \\<notin> dom (C s)) \\<longrightarrow>\n       y \\<in> dom (C A) \\<longrightarrow>\n       y \\<notin> dom (C (list2FWpolicy (a # p)))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x s.\n        s \\<in> set [] \\<and> x \\<in> dom (C A) \\<longrightarrow>\n        x \\<notin> dom (C s)) \\<longrightarrow>\n    y \\<in> dom (C A) \\<longrightarrow>\n    y \\<notin> dom (C (list2FWpolicy []))\n 2. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set p \\<and> x \\<in> dom (C A) \\<longrightarrow>\n           x \\<notin> dom (C s)) \\<longrightarrow>\n       y \\<in> dom (C A) \\<longrightarrow>\n       y \\<notin> dom (C (list2FWpolicy p)) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set (a # p) \\<and> x \\<in> dom (C A) \\<longrightarrow>\n           x \\<notin> dom (C s)) \\<longrightarrow>\n       y \\<in> dom (C A) \\<longrightarrow>\n       y \\<notin> dom (C (list2FWpolicy (a # p)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x s.\n        s \\<in> set [] \\<and> x \\<in> dom (C A) \\<longrightarrow>\n        x \\<notin> dom (C s)) \\<longrightarrow>\n    y \\<in> dom (C A) \\<longrightarrow>\n    y \\<notin> dom (C (list2FWpolicy []))", "by simp"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  (\\<forall>x s.\n      s \\<in> set [] \\<and> x \\<in> dom (C A) \\<longrightarrow>\n      x \\<notin> dom (C s)) \\<longrightarrow>\n  y \\<in> dom (C A) \\<longrightarrow> y \\<notin> dom (C (list2FWpolicy []))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set p \\<and> x \\<in> dom (C A) \\<longrightarrow>\n           x \\<notin> dom (C s)) \\<longrightarrow>\n       y \\<in> dom (C A) \\<longrightarrow>\n       y \\<notin> dom (C (list2FWpolicy p)) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set (a # p) \\<and> x \\<in> dom (C A) \\<longrightarrow>\n           x \\<notin> dom (C s)) \\<longrightarrow>\n       y \\<in> dom (C A) \\<longrightarrow>\n       y \\<notin> dom (C (list2FWpolicy (a # p)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set p \\<and> x \\<in> dom (C A) \\<longrightarrow>\n           x \\<notin> dom (C s)) \\<longrightarrow>\n       y \\<in> dom (C A) \\<longrightarrow>\n       y \\<notin> dom (C (list2FWpolicy p)) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set (a # p) \\<and> x \\<in> dom (C A) \\<longrightarrow>\n           x \\<notin> dom (C s)) \\<longrightarrow>\n       y \\<in> dom (C A) \\<longrightarrow>\n       y \\<notin> dom (C (list2FWpolicy (a # p)))", "case (Cons a p)"], ["proof (state)\nthis:\n  p \\<noteq> [] \\<longrightarrow>\n  (\\<forall>x s.\n      s \\<in> set p \\<and> x \\<in> dom (C A) \\<longrightarrow>\n      x \\<notin> dom (C s)) \\<longrightarrow>\n  y \\<in> dom (C A) \\<longrightarrow> y \\<notin> dom (C (list2FWpolicy p))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set p \\<and> x \\<in> dom (C A) \\<longrightarrow>\n           x \\<notin> dom (C s)) \\<longrightarrow>\n       y \\<in> dom (C A) \\<longrightarrow>\n       y \\<notin> dom (C (list2FWpolicy p)) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set (a # p) \\<and> x \\<in> dom (C A) \\<longrightarrow>\n           x \\<notin> dom (C s)) \\<longrightarrow>\n       y \\<in> dom (C A) \\<longrightarrow>\n       y \\<notin> dom (C (list2FWpolicy (a # p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> [] \\<longrightarrow>\n  (\\<forall>x s.\n      s \\<in> set p \\<and> x \\<in> dom (C A) \\<longrightarrow>\n      x \\<notin> dom (C s)) \\<longrightarrow>\n  y \\<in> dom (C A) \\<longrightarrow> y \\<notin> dom (C (list2FWpolicy p))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<longrightarrow>\n  (\\<forall>x s.\n      s \\<in> set p \\<and> x \\<in> dom (C A) \\<longrightarrow>\n      x \\<notin> dom (C s)) \\<longrightarrow>\n  y \\<in> dom (C A) \\<longrightarrow> y \\<notin> dom (C (list2FWpolicy p))\n\ngoal (1 subgoal):\n 1. a # p \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x s.\n        s \\<in> set (a # p) \\<and> x \\<in> dom (C A) \\<longrightarrow>\n        x \\<notin> dom (C s)) \\<longrightarrow>\n    y \\<in> dom (C A) \\<longrightarrow>\n    y \\<notin> dom (C (list2FWpolicy (a # p)))", "apply (case_tac \"p = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> [] \\<longrightarrow>\n             (\\<forall>x s.\n                 s \\<in> set p \\<and> x \\<in> dom (C A) \\<longrightarrow>\n                 x \\<notin> dom (C s)) \\<longrightarrow>\n             y \\<in> dom (C A) \\<longrightarrow>\n             y \\<notin> dom (C (list2FWpolicy p));\n     p = []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<longrightarrow>\n                      (\\<forall>x s.\n                          s \\<in> set (a # p) \\<and>\n                          x \\<in> dom (C A) \\<longrightarrow>\n                          x \\<notin> dom (C s)) \\<longrightarrow>\n                      y \\<in> dom (C A) \\<longrightarrow>\n                      y \\<notin> dom (C (list2FWpolicy (a # p)))\n 2. \\<lbrakk>p \\<noteq> [] \\<longrightarrow>\n             (\\<forall>x s.\n                 s \\<in> set p \\<and> x \\<in> dom (C A) \\<longrightarrow>\n                 x \\<notin> dom (C s)) \\<longrightarrow>\n             y \\<in> dom (C A) \\<longrightarrow>\n             y \\<notin> dom (C (list2FWpolicy p));\n     p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<longrightarrow>\n                      (\\<forall>x s.\n                          s \\<in> set (a # p) \\<and>\n                          x \\<in> dom (C A) \\<longrightarrow>\n                          x \\<notin> dom (C s)) \\<longrightarrow>\n                      y \\<in> dom (C A) \\<longrightarrow>\n                      y \\<notin> dom (C (list2FWpolicy (a # p)))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> [] \\<longrightarrow>\n             (\\<forall>x s.\n                 s \\<in> set p \\<and> x \\<in> dom (C A) \\<longrightarrow>\n                 x \\<notin> dom (C s)) \\<longrightarrow>\n             y \\<in> dom (C A) \\<longrightarrow>\n             y \\<notin> dom (C (list2FWpolicy p));\n     p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<longrightarrow>\n                      (\\<forall>x s.\n                          s \\<in> set (a # p) \\<and>\n                          x \\<in> dom (C A) \\<longrightarrow>\n                          x \\<notin> dom (C s)) \\<longrightarrow>\n                      y \\<in> dom (C A) \\<longrightarrow>\n                      y \\<notin> dom (C (list2FWpolicy (a # p)))", "by (meson domdConcStart list.set_intros(1) list.set_intros(2))"], ["proof (state)\nthis:\n  a # p \\<noteq> [] \\<longrightarrow>\n  (\\<forall>x s.\n      s \\<in> set (a # p) \\<and> x \\<in> dom (C A) \\<longrightarrow>\n      x \\<notin> dom (C s)) \\<longrightarrow>\n  y \\<in> dom (C A) \\<longrightarrow>\n  y \\<notin> dom (C (list2FWpolicy (a # p)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isSepaux:\n  \" p \\<noteq> [] \\<Longrightarrow> noDenyAll (a # p) \\<Longrightarrow> separated (a # p) \\<Longrightarrow>\n    x \\<in> dom (C (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus> \n                DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a)) \\<Longrightarrow>\n    x \\<notin> dom (C (list2FWpolicy p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; noDenyAll (a # p); separated (a # p);\n     x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n                      (first_destNet a) \\<oplus>\n                     DenyAllFromTo (first_destNet a)\n                      (first_srcNet a) \\<oplus>\n                     a))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (list2FWpolicy p))", "apply (rule_tac A = \"(DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n                     DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a)\" in domsdisj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; noDenyAll (a # p); separated (a # p);\n     x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n                      (first_destNet a) \\<oplus>\n                     DenyAllFromTo (first_destNet a)\n                      (first_srcNet a) \\<oplus>\n                     a))\\<rbrakk>\n    \\<Longrightarrow> p \\<noteq> []\n 2. \\<And>xa s.\n       \\<lbrakk>p \\<noteq> []; noDenyAll (a # p); separated (a # p);\n        x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a));\n        s \\<in> set p \\<and>\n        xa \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a))\\<rbrakk>\n       \\<Longrightarrow> xa \\<notin> dom (C s)\n 3. \\<lbrakk>p \\<noteq> []; noDenyAll (a # p); separated (a # p);\n     x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n                      (first_destNet a) \\<oplus>\n                     DenyAllFromTo (first_destNet a)\n                      (first_srcNet a) \\<oplus>\n                     a))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n (first_destNet a) \\<oplus>\nDenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa s.\n       \\<lbrakk>p \\<noteq> []; \\<not> member DenyAll a \\<and> noDenyAll p;\n        (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n        separated p;\n        x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a));\n        s \\<in> set p \\<and>\n        xa \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a))\\<rbrakk>\n       \\<Longrightarrow> xa \\<notin> dom (C s)", "by (metis Combinators.distinct(1) FWNormalisationCore.member.simps(1) \n      FWNormalisationCore.member.simps(3) disjSD2aux disjSD_no_p_in_both noDA)"], ["", "lemma none_MT_rulessep[rule_format]: \"none_MT_rules C p \\<longrightarrow> none_MT_rules C (separate p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. none_MT_rules C p \\<longrightarrow> none_MT_rules C (separate p)", "apply(induct p rule: separate.induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x.\n       none_MT_rules C x \\<longrightarrow>\n       none_MT_rules C (separate x) \\<Longrightarrow>\n       none_MT_rules C (DenyAll # x) \\<longrightarrow>\n       none_MT_rules C (separate (DenyAll # x))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (DenyAllFromTo v va) =\n                first_bothNet y \\<Longrightarrow>\n                none_MT_rules C\n                 (DenyAllFromTo v va \\<oplus> y # z) \\<longrightarrow>\n                none_MT_rules C\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        first_bothNet (DenyAllFromTo v va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        none_MT_rules C (y # z) \\<longrightarrow>\n        none_MT_rules C (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> none_MT_rules C\n                          (DenyAllFromTo v va # y # z) \\<longrightarrow>\n                         none_MT_rules C\n                          (separate (DenyAllFromTo v va # y # z))\n 3. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                none_MT_rules C\n                 (AllowPortFromTo v va vb \\<oplus> y # z) \\<longrightarrow>\n                none_MT_rules C\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        none_MT_rules C (y # z) \\<longrightarrow>\n        none_MT_rules C (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> none_MT_rules C\n                          (AllowPortFromTo v va vb #\n                           y # z) \\<longrightarrow>\n                         none_MT_rules C\n                          (separate (AllowPortFromTo v va vb # y # z))\n 4. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                none_MT_rules C\n                 ((v \\<oplus> va) \\<oplus> y # z) \\<longrightarrow>\n                none_MT_rules C (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        none_MT_rules C (y # z) \\<longrightarrow>\n        none_MT_rules C (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> none_MT_rules C\n                          (v \\<oplus> va # y # z) \\<longrightarrow>\n                         none_MT_rules C (separate (v \\<oplus> va # y # z))\n 5. none_MT_rules C [] \\<longrightarrow> none_MT_rules C (separate [])\n 6. \\<And>vb vc.\n       none_MT_rules C [DenyAllFromTo vb vc] \\<longrightarrow>\n       none_MT_rules C (separate [DenyAllFromTo vb vc])\n 7. \\<And>vb vc vd.\n       none_MT_rules C [AllowPortFromTo vb vc vd] \\<longrightarrow>\n       none_MT_rules C (separate [AllowPortFromTo vb vc vd])\n 8. \\<And>vb vc.\n       none_MT_rules C [vb \\<oplus> vc] \\<longrightarrow>\n       none_MT_rules C (separate [vb \\<oplus> vc])", "by (simp_all add: C.simps map_add_le_mapE map_le_antisym)"], ["", "lemma dom_id: \n  \"noDenyAll(a#p) \\<Longrightarrow> separated(a#p) \\<Longrightarrow> p \\<noteq> [] \\<Longrightarrow> x\\<notin>dom(C(list2FWpolicy p)) \\<Longrightarrow> x\\<in>dom (C a) \\<Longrightarrow> \n   x \\<notin> dom (C (list2FWpolicy (insertDenies p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll (a # p); separated (a # p); p \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy p)); x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (C (list2FWpolicy (insertDenies p)))", "apply (rule_tac a = a in isSepaux, simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> insertDenies p \\<noteq> []\n 2. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll (insertDenies p)\n 3. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set (insertDenies p) \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated (insertDenies p)\n 4. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n (first_destNet a) \\<oplus>\nDenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a))", "using idNMT"], ["proof (prove)\nusing this:\n  ?p \\<noteq> [] \\<Longrightarrow> insertDenies ?p \\<noteq> []\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> insertDenies p \\<noteq> []\n 2. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll (insertDenies p)\n 3. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set (insertDenies p) \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated (insertDenies p)\n 4. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n (first_destNet a) \\<oplus>\nDenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a))", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll (insertDenies p)\n 2. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set (insertDenies p) \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated (insertDenies p)\n 3. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n (first_destNet a) \\<oplus>\nDenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a))", "using noDAID"], ["proof (prove)\nusing this:\n  noDenyAll ?p \\<Longrightarrow> noDenyAll (insertDenies ?p)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll (insertDenies p)\n 2. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set (insertDenies p) \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated (insertDenies p)\n 3. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n (first_destNet a) \\<oplus>\nDenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a))", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set (insertDenies p) \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated (insertDenies p)\n 2. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n (first_destNet a) \\<oplus>\nDenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a))", "using id_aux4 noDA1eq sepNetsID"], ["proof (prove)\nusing this:\n  \\<lbrakk>noDenyAll ?p;\n   \\<And>s. s \\<in> set ?p \\<Longrightarrow> disjSD_2 ?a s;\n   ?s \\<in> set (insertDenies ?p); \\<not> member DenyAll ?a\\<rbrakk>\n  \\<Longrightarrow> disjSD_2 ?a ?s\n  noDenyAll ?p \\<Longrightarrow> noDenyAll1 ?p\n  \\<lbrakk>noDenyAll1 ?p; separated ?p\\<rbrakk>\n  \\<Longrightarrow> separated (insertDenies ?p)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set (insertDenies p) \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated (insertDenies p)\n 2. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n (first_destNet a) \\<oplus>\nDenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p));\n     x \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (C (DenyAllFromTo (first_srcNet a)\n (first_destNet a) \\<oplus>\nDenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a))", "by (metis list.set_intros(1) list.set_intros(2) list2FWpolicy.simps(2) list2FWpolicy.simps(3) notindom)"], ["", "lemma C_eq_iD_aux2[rule_format]: \n  \"noDenyAll1 p \\<longrightarrow> separated p\\<longrightarrow> p \\<noteq> []\\<longrightarrow> x \\<in> dom (C (list2FWpolicy p))\\<longrightarrow>\n  C(list2FWpolicy (insertDenies p)) x = C(list2FWpolicy p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 p \\<longrightarrow>\n    separated p \\<longrightarrow>\n    p \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies p)) x = C (list2FWpolicy p) x", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. noDenyAll1 [] \\<longrightarrow>\n    separated [] \\<longrightarrow>\n    [] \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy [])) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies [])) x = C (list2FWpolicy []) x\n 2. \\<And>a p.\n       noDenyAll1 p \\<longrightarrow>\n       separated p \\<longrightarrow>\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies p)) x =\n       C (list2FWpolicy p) x \\<Longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       separated (a # p) \\<longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies (a # p))) x =\n       C (list2FWpolicy (a # p)) x", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. noDenyAll1 [] \\<longrightarrow>\n    separated [] \\<longrightarrow>\n    [] \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy [])) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies [])) x = C (list2FWpolicy []) x\n 2. \\<And>a p.\n       noDenyAll1 p \\<longrightarrow>\n       separated p \\<longrightarrow>\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies p)) x =\n       C (list2FWpolicy p) x \\<Longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       separated (a # p) \\<longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies (a # p))) x =\n       C (list2FWpolicy (a # p)) x", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 [] \\<longrightarrow>\n    separated [] \\<longrightarrow>\n    [] \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy [])) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies [])) x = C (list2FWpolicy []) x", "by simp"], ["proof (state)\nthis:\n  noDenyAll1 [] \\<longrightarrow>\n  separated [] \\<longrightarrow>\n  [] \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy [])) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies [])) x = C (list2FWpolicy []) x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       noDenyAll1 p \\<longrightarrow>\n       separated p \\<longrightarrow>\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies p)) x =\n       C (list2FWpolicy p) x \\<Longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       separated (a # p) \\<longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies (a # p))) x =\n       C (list2FWpolicy (a # p)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       noDenyAll1 p \\<longrightarrow>\n       separated p \\<longrightarrow>\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies p)) x =\n       C (list2FWpolicy p) x \\<Longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       separated (a # p) \\<longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies (a # p))) x =\n       C (list2FWpolicy (a # p)) x", "case (Cons y ys)"], ["proof (state)\nthis:\n  noDenyAll1 ys \\<longrightarrow>\n  separated ys \\<longrightarrow>\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       noDenyAll1 p \\<longrightarrow>\n       separated p \\<longrightarrow>\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy p)) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies p)) x =\n       C (list2FWpolicy p) x \\<Longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       separated (a # p) \\<longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (C (list2FWpolicy (a # p))) \\<longrightarrow>\n       C (list2FWpolicy (insertDenies (a # p))) x =\n       C (list2FWpolicy (a # p)) x", "thus ?case"], ["proof (prove)\nusing this:\n  noDenyAll1 ys \\<longrightarrow>\n  separated ys \\<longrightarrow>\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x =\n    C (list2FWpolicy (y # ys)) x", "using Cons"], ["proof (prove)\nusing this:\n  noDenyAll1 ys \\<longrightarrow>\n  separated ys \\<longrightarrow>\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x\n  noDenyAll1 ys \\<longrightarrow>\n  separated ys \\<longrightarrow>\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x =\n    C (list2FWpolicy (y # ys)) x", "proof (cases y)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             separated ys \\<longrightarrow>\n             ys \\<noteq> [] \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n             C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     noDenyAll1 ys \\<longrightarrow>\n     separated ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                      separated (y # ys) \\<longrightarrow>\n                      y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (y # ys))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      C (list2FWpolicy (y # ys)) x\n 2. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x\n 4. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x", "case DenyAll"], ["proof (state)\nthis:\n  y = DenyAll\n\ngoal (4 subgoals):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             separated ys \\<longrightarrow>\n             ys \\<noteq> [] \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n             C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     noDenyAll1 ys \\<longrightarrow>\n     separated ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                      separated (y # ys) \\<longrightarrow>\n                      y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (y # ys))) \\<longrightarrow>\n                      C (list2FWpolicy (insertDenies (y # ys))) x =\n                      C (list2FWpolicy (y # ys)) x\n 2. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x\n 4. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = DenyAll\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x =\n    C (list2FWpolicy (y # ys)) x", "using Cons DenyAll"], ["proof (prove)\nusing this:\n  y = DenyAll\n  noDenyAll1 ys \\<longrightarrow>\n  separated ys \\<longrightarrow>\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x\n  y = DenyAll\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x =\n    C (list2FWpolicy (y # ys)) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             separated ys \\<longrightarrow>\n             ys \\<noteq> [] \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n             C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll ys \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set ys \\<longrightarrow>\n                          disjSD_2 DenyAll s) \\<and>\n                      separated ys \\<longrightarrow>\n                      C (list2FWpolicy (DenyAll # insertDenies ys)) x =\n                      C (list2FWpolicy (DenyAll # ys)) x", "apply (case_tac \"ys = []\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             separated ys \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n             C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     y = DenyAll; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> noDenyAll ys \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set ys \\<longrightarrow>\n                          disjSD_2 DenyAll s) \\<and>\n                      separated ys \\<longrightarrow>\n                      C (list2FWpolicy (DenyAll # insertDenies ys)) x =\n                      C (list2FWpolicy (DenyAll # ys)) x", "apply (case_tac \"x \\<in> dom (C (list2FWpolicy ys))\",simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             separated ys \\<longrightarrow>\n             C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     y = DenyAll; ys \\<noteq> [];\n     x \\<in> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> noDenyAll ys \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set ys \\<longrightarrow>\n                          disjSD_2 DenyAll s) \\<and>\n                      separated ys \\<longrightarrow>\n                      C (list2FWpolicy (DenyAll # insertDenies ys)) x =\n                      C (list2FWpolicy (DenyAll # ys)) x\n 2. \\<lbrakk>y = DenyAll; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> noDenyAll ys \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set ys \\<longrightarrow>\n                          disjSD_2 DenyAll s) \\<and>\n                      separated ys \\<longrightarrow>\n                      C (list2FWpolicy (DenyAll # insertDenies ys)) x =\n                      C (list2FWpolicy (DenyAll # ys)) x", "apply (metis Cdom2 domID idNMT list2FWpolicyconc noDA1eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAll; ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> noDenyAll ys \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set ys \\<longrightarrow>\n                          disjSD_2 DenyAll s) \\<and>\n                      separated ys \\<longrightarrow>\n                      C (list2FWpolicy (DenyAll # insertDenies ys)) x =\n                      C (list2FWpolicy (DenyAll # ys)) x", "apply (metis DenyAll iD_isD idNMT list2FWpolicyconc nlpaux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  noDenyAll1 (y # ys) \\<longrightarrow>\n  separated (y # ys) \\<longrightarrow>\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies (y # ys))) x = C (list2FWpolicy (y # ys)) x\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x\n 3. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x\n 3. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x", "case (DenyAllFromTo a b)"], ["proof (state)\nthis:\n  y = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x\n 3. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x =\n    C (list2FWpolicy (y # ys)) x", "using Cons"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n  noDenyAll1 ys \\<longrightarrow>\n  separated ys \\<longrightarrow>\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x =\n    C (list2FWpolicy (y # ys)) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     noDenyAll1 ys \\<longrightarrow>\n     separated ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x\\<rbrakk>\n    \\<Longrightarrow> noDenyAll ys \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set ys \\<longrightarrow>\n                          disjSD_2 (DenyAllFromTo a b) s) \\<and>\n                      separated ys \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (DenyAllFromTo a b # ys))) \\<longrightarrow>\n                      C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (rule impI|rule allI|rule conjI|simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     noDenyAll1 ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (case_tac \"ys = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b; x \\<in> dom (C (DenyAllFromTo a b));\n     ys = []\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo a b \\<oplus>\n                         DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n                       x =\n                      C (DenyAllFromTo a b) x\n 2. \\<lbrakk>y = DenyAllFromTo a b;\n     noDenyAll1 ys \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (metis Cdom2 ConcAssoc DenyAllFromTo)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     noDenyAll1 ys \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (case_tac \"x \\<in> dom (C (list2FWpolicy ys))\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     noDenyAll1 ys \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<in> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (DenyAllFromTo a b # ys)) x\n 2. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (simp add: Cdom2 domID idNMT l2p_aux noDA1eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (case_tac \"x \\<in> dom (C (list2FWpolicy (insertDenies ys)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (C (list2FWpolicy ys));\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (DenyAllFromTo a b # ys)) x\n 2. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (C (list2FWpolicy ys));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (meson Combinators.distinct(1) FWNormalisationCore.member.simps(3) dom_id domdConcStart\n          noDenyAll.simps(1) separated.simps(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (C (list2FWpolicy ys));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (DenyAllFromTo a b # ys)) x", "by (metis Cdom2 DenyAllFromTo domIff dom_def domdConcStart l2p_aux l2p_aux2 nlpaux)"], ["proof (state)\nthis:\n  noDenyAll1 (y # ys) \\<longrightarrow>\n  separated (y # ys) \\<longrightarrow>\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies (y # ys))) x = C (list2FWpolicy (y # ys)) x\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x\n 2. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x\n 2. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x", "case (AllowPortFromTo a b c)"], ["proof (state)\nthis:\n  y = AllowPortFromTo a b c\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x\n 2. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a b c\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x =\n    C (list2FWpolicy (y # ys)) x", "using AllowPortFromTo Cons"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a b c\n  y = AllowPortFromTo a b c\n  noDenyAll1 ys \\<longrightarrow>\n  separated ys \\<longrightarrow>\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x =\n    C (list2FWpolicy (y # ys)) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     noDenyAll1 ys \\<longrightarrow>\n     separated ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x\\<rbrakk>\n    \\<Longrightarrow> noDenyAll ys \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set ys \\<longrightarrow>\n                          disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n                      separated ys \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (AllowPortFromTo a b c # ys))) \\<longrightarrow>\n                      C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (rule impI|rule allI|rule conjI|simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     noDenyAll1 ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (case_tac \"ys = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     x \\<in> dom (C (AllowPortFromTo a b c)); ys = []\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo a b \\<oplus>\n                         DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c)\n                       x =\n                      C (AllowPortFromTo a b c) x\n 2. \\<lbrakk>y = AllowPortFromTo a b c;\n     noDenyAll1 ys \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (metis Cdom2 ConcAssoc AllowPortFromTo)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     noDenyAll1 ys \\<longrightarrow>\n     x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (case_tac \"x \\<in> dom (C (list2FWpolicy ys))\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     noDenyAll1 ys \\<longrightarrow>\n     C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<in> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (AllowPortFromTo a b c # ys)) x\n 2. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (simp add: Cdom2 domID idNMT list2FWpolicyconc noDA1eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (case_tac \"x \\<in> dom (C (list2FWpolicy (insertDenies ys)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<notin> dom (C (list2FWpolicy ys));\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (AllowPortFromTo a b c # ys)) x\n 2. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<notin> dom (C (list2FWpolicy ys));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (meson Combinators.distinct(3) FWNormalisationCore.member.simps(4) dom_id domdConcStart noDenyAll.simps(1) separated.simps(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<notin> dom (C (list2FWpolicy ys));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo a b \\<oplus>\n                           DenyAllFromTo b a \\<oplus>\n                           AllowPortFromTo a b c #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "by (metis Cdom2 ConcAssoc l2p_aux list2FWpolicy.simps(2) nlpaux)"], ["proof (state)\nthis:\n  noDenyAll1 (y # ys) \\<longrightarrow>\n  separated (y # ys) \\<longrightarrow>\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies (y # ys))) x = C (list2FWpolicy (y # ys)) x\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x", "case (Conc a b)"], ["proof (state)\nthis:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n                C (list2FWpolicy (insertDenies ys)) x =\n                C (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n        C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (C\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         C (list2FWpolicy (insertDenies (y # ys))) x =\n                         C (list2FWpolicy (y # ys)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x =\n    C (list2FWpolicy (y # ys)) x", "using Cons Conc"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n  noDenyAll1 ys \\<longrightarrow>\n  separated ys \\<longrightarrow>\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n    C (list2FWpolicy (insertDenies (y # ys))) x =\n    C (list2FWpolicy (y # ys)) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             separated ys \\<longrightarrow>\n             ys \\<noteq> [] \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n             C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     y = a \\<oplus> b\\<rbrakk>\n    \\<Longrightarrow> \\<not> member DenyAll a \\<and>\n                      \\<not> member DenyAll b \\<and>\n                      noDenyAll ys \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set ys \\<longrightarrow>\n                          disjSD_2 (a \\<oplus> b) s) \\<and>\n                      separated ys \\<longrightarrow>\n                      x \\<in> dom (C (list2FWpolicy\n (a \\<oplus> b # ys))) \\<longrightarrow>\n                      C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (rule impI|rule allI|rule conjI|simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             ys \\<noteq> [] \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n             C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (a \\<oplus> b # ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (case_tac \"ys = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and> \\<not> member DenyAll b;\n     x \\<in> dom (C (a \\<oplus> b)); ys = []\\<rbrakk>\n    \\<Longrightarrow> C (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<oplus> b)\n                       x =\n                      C (a \\<oplus> b) x\n 2. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n             C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (metis Cdom2 ConcAssoc Conc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             x \\<in> dom (C (list2FWpolicy ys)) \\<longrightarrow>\n             C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (a \\<oplus> b # ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (case_tac \"x \\<in> dom (C (list2FWpolicy ys))\",simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             C (list2FWpolicy (insertDenies ys)) x = C (list2FWpolicy ys) x;\n     y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<in> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (a \\<oplus> b # ys)) x\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (simp add: Cdom2 domID idNMT list2FWpolicyconc noDA1eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (case_tac \"x \\<in> dom (C (a \\<oplus> b))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy ys));\n     x \\<in> dom (C (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (a \\<oplus> b # ys)) x\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy ys));\n     x \\<notin> dom (C (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (case_tac \"x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\",simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<notin> dom (C (list2FWpolicy ys));\n     x \\<in> dom (C (a \\<oplus> b));\n     x \\<notin> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (a \\<oplus> b # ys)) x\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<notin> dom (C (list2FWpolicy ys));\n     x \\<in> dom (C (a \\<oplus> b));\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (a \\<oplus> b # ys)) x\n 3. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy ys));\n     x \\<notin> dom (C (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (simp add: Cdom2 domIff idNMT list2FWpolicyconc nlpaux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<notin> dom (C (list2FWpolicy ys));\n     x \\<in> dom (C (a \\<oplus> b));\n     x \\<in> dom (C (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (a \\<oplus> b # ys)) x\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy ys));\n     x \\<notin> dom (C (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (metis FWNormalisationCore.member.simps(1) dom_id noDenyAll.simps(1) separated.simps(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (C (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (C (list2FWpolicy ys));\n     x \\<notin> dom (C (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b #\n                           insertDenies ys))\n                       x =\n                      C (list2FWpolicy (a \\<oplus> b # ys)) x", "by (simp add: inDomConc)"], ["proof (state)\nthis:\n  noDenyAll1 (y # ys) \\<longrightarrow>\n  separated (y # ys) \\<longrightarrow>\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies (y # ys))) x = C (list2FWpolicy (y # ys)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  noDenyAll1 (y # ys) \\<longrightarrow>\n  separated (y # ys) \\<longrightarrow>\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (C (list2FWpolicy (y # ys))) \\<longrightarrow>\n  C (list2FWpolicy (insertDenies (y # ys))) x = C (list2FWpolicy (y # ys)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_iD: \n  \"separated p \\<Longrightarrow> noDenyAll1 p \\<Longrightarrow> wellformed_policy1_strong p \\<Longrightarrow> \n   C (list2FWpolicy (insertDenies p)) = C (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>separated p; noDenyAll1 p; wellformed_policy1_strong p\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (insertDenies p)) =\n                      C (list2FWpolicy p)", "by (rule ext) (metis CConcStartA C_eq_iD_aux2 DAAux wp1_alternative_not_mt wp1n_tl)"], ["", "lemma noDAsortQ[rule_format]: \"noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)", "apply (case_tac \"p\",simp_all, rename_tac a list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       noDenyAll1 (a # list) \\<longrightarrow>\n       noDenyAll1\n        (qsort (filter (\\<lambda>y. \\<not> smaller a y l) list) l @\n         a # qsort (filter (\\<lambda>y. smaller a y l) list) l)", "subgoal for a list"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = a # list \\<Longrightarrow>\n    noDenyAll1 (a # list) \\<longrightarrow>\n    noDenyAll1\n     (qsort (filter (\\<lambda>y. \\<not> smaller a y l) list) l @\n      a # qsort (filter (\\<lambda>y. smaller a y l) list) l)", "apply (case_tac \"a = DenyAll\",simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = DenyAll # list; a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll list \\<longrightarrow>\n                      noDenyAll (qsort list l)\n 2. \\<lbrakk>p = a # list; a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (a # list) \\<longrightarrow>\n                      noDenyAll1\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)", "using nDAeqSet set_sortQ"], ["proof (prove)\nusing this:\n  set ?p = set ?s \\<Longrightarrow> noDenyAll ?p = noDenyAll ?s\n  set (qsort ?xs ?l) = set ?xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p = DenyAll # list; a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll list \\<longrightarrow>\n                      noDenyAll (qsort list l)\n 2. \\<lbrakk>p = a # list; a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (a # list) \\<longrightarrow>\n                      noDenyAll1\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a # list; a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (a # list) \\<longrightarrow>\n                      noDenyAll1\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)", "apply (rule impI,rule noDA1eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a # list; a \\<noteq> DenyAll;\n     noDenyAll1 (a # list)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)", "apply (subgoal_tac \"noDenyAll (a#list)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = a # list; a \\<noteq> DenyAll; noDenyAll1 (a # list);\n     noDenyAll (a # list)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)\n 2. \\<lbrakk>p = a # list; a \\<noteq> DenyAll;\n     noDenyAll1 (a # list)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll (a # list)", "apply (metis append_Cons append_Nil nDAeqSet qsort.simps(2) set_sortQ)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a # list; a \\<noteq> DenyAll;\n     noDenyAll1 (a # list)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll (a # list)", "by (case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma NetsCollectedSortQ: \n  \"distinct p \\<Longrightarrow>noDenyAll1 p \\<Longrightarrow> all_in_list p l \\<Longrightarrow>  singleCombinators p \\<Longrightarrow> \n   NetsCollected (qsort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct p; noDenyAll1 p; all_in_list p l;\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> NetsCollected (qsort p l)", "by (metis NetsCollectedSorted SC3Q all_in_list.elims(2) all_in_list.simps(1) all_in_list.simps(2) \n      all_in_listAppend all_in_list_sublist noDAsortQ qsort.simps(1) qsort.simps(2) \n      singleCombinatorsConc sort_is_sortedQ)"], ["", "lemmas CLemmas =  nMTSort nMTSortQ none_MT_rulesRS2 none_MT_rulesrd\n                  noDAsort noDAsortQ nDASC wp1_eq  wp1ID  \n                  SCp2l ANDSep   wp1n_RS2 \n                  OTNSEp OTNSC noDA1sep wp1_alternativesep wellformed_eq \n                  wellformed1_alternative_sorted"], ["", "lemmas C_eqLemmas_id = CLemmas  NC2Sep NetsCollectedSep \n                       NetsCollectedSort NetsCollectedSortQ separatedNC"], ["", "lemma C_eq_Until_InsertDenies: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p)l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n   C (list2FWpolicy\n        (insertDenies\n          (separate\n            (FWNormalisationCore.sort\n              (removeShadowRules2 (remdups (rm_MT_rules C \n                  (insertDeny (removeShadowRules1 (policy2list p)))))) l)))) =\n    C p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (insertDenies\n                            (separate\n                              (FWNormalisationCore.sort\n                                (removeShadowRules2\n                                  (remdups\n                                    (rm_MT_rules C\n(insertDeny (removeShadowRules1 (policy2list p))))))\n                                l)))) =\n                      C p", "apply (subst C_eq_iD,simp_all add: C_eqLemmas_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (separate\n                            (FWNormalisationCore.sort\n                              (removeShadowRules2\n                                (remdups\n                                  (rm_MT_rules C\n                                    (insertDeny\n(removeShadowRules1 (policy2list p))))))\n                              l))) =\n                      C p", "apply (rule C_eq_until_separated, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_eq_Until_InsertDeniesQ: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p)l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n   C(list2FWpolicy\n       (insertDenies\n          (separate (qsort (removeShadowRules2 (remdups (rm_MT_rules C \n              (insertDeny (removeShadowRules1 (policy2list p)))))) l)))) =\n    C p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (insertDenies\n                            (separate\n                              (qsort\n                                (removeShadowRules2\n                                  (remdups\n                                    (rm_MT_rules C\n(insertDeny (removeShadowRules1 (policy2list p))))))\n                                l)))) =\n                      C p", "apply (subst C_eq_iD,simp_all add: C_eqLemmas_id)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1_strong\n                       (separate\n                         (qsort\n                           (removeShadowRules2\n                             (remdups\n                               (rm_MT_rules C\n                                 (insertDeny\n                                   (removeShadowRules1 (policy2list p))))))\n                           l))\n 2. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (separate\n                            (qsort\n                              (removeShadowRules2\n                                (remdups\n                                  (rm_MT_rules C\n                                    (insertDeny\n(removeShadowRules1 (policy2list p))))))\n                              l))) =\n                      C p", "apply (metis WP1rd set_qsort wellformed1_sortedQ wellformed_eq wp1ID wp1_alternativesep wp1_aux1aa wp1n_RS2 wp1n_RS3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (separate\n                            (qsort\n                              (removeShadowRules2\n                                (remdups\n                                  (rm_MT_rules C\n                                    (insertDeny\n(removeShadowRules1 (policy2list p))))))\n                              l))) =\n                      C p", "by (rule C_eq_until_separatedQ, simp_all)"], ["", "lemma C_eq_RD_aux[rule_format]: \"C (p) x = C (removeDuplicates p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C p x = C (removeDuplicates p) x", "apply (induct p,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>C p1 x = C (removeDuplicates p1) x;\n        C p2 x = C (removeDuplicates p2) x\\<rbrakk>\n       \\<Longrightarrow> (member p1 p2 \\<longrightarrow>\n                          C (p1 \\<oplus> p2) x =\n                          C (removeDuplicates p2) x) \\<and>\n                         (\\<not> member p1 p2 \\<longrightarrow>\n                          C (p1 \\<oplus> p2) x =\n                          C (p1 \\<oplus> removeDuplicates p2) x)", "by (metis Cdom2 domIff nlpaux not_in_member)"], ["", "lemma C_eq_RAD_aux[rule_format]: \n  \"p \\<noteq> []  \\<longrightarrow> C (list2FWpolicy p) x = C (list2FWpolicy (removeAllDuplicates p)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy p) x = C (list2FWpolicy (removeAllDuplicates p)) x", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy []) x = C (list2FWpolicy (removeAllDuplicates [])) x\n 2. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy p) x =\n       C (list2FWpolicy (removeAllDuplicates p)) x \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (a # p)) x =\n       C (list2FWpolicy (removeAllDuplicates (a # p))) x", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy []) x = C (list2FWpolicy (removeAllDuplicates [])) x\n 2. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy p) x =\n       C (list2FWpolicy (removeAllDuplicates p)) x \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (a # p)) x =\n       C (list2FWpolicy (removeAllDuplicates (a # p))) x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy []) x = C (list2FWpolicy (removeAllDuplicates [])) x", "by simp"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy []) x = C (list2FWpolicy (removeAllDuplicates [])) x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy p) x =\n       C (list2FWpolicy (removeAllDuplicates p)) x \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (a # p)) x =\n       C (list2FWpolicy (removeAllDuplicates (a # p))) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy p) x =\n       C (list2FWpolicy (removeAllDuplicates p)) x \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (a # p)) x =\n       C (list2FWpolicy (removeAllDuplicates (a # p))) x", "case (Cons a p)"], ["proof (state)\nthis:\n  p \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy p) x = C (list2FWpolicy (removeAllDuplicates p)) x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy p) x =\n       C (list2FWpolicy (removeAllDuplicates p)) x \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       C (list2FWpolicy (a # p)) x =\n       C (list2FWpolicy (removeAllDuplicates (a # p))) x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a # p \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (a # p)) x =\n    C (list2FWpolicy (removeAllDuplicates (a # p))) x", "apply (case_tac \"p = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> C a x = C (removeDuplicates a) x\n 2. p \\<noteq> [] \\<Longrightarrow>\n    C (list2FWpolicy (a # p)) x =\n    C (list2FWpolicy (removeDuplicates a # removeAllDuplicates p)) x", "apply (metis C_eq_RD_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    C (list2FWpolicy (a # p)) x =\n    C (list2FWpolicy (removeDuplicates a # removeAllDuplicates p)) x", "apply (subst list2FWpolicyconc,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    C (a \\<oplus> list2FWpolicy p) x =\n    C (list2FWpolicy (removeDuplicates a # removeAllDuplicates p)) x", "apply (case_tac \"x \\<in> dom (C (list2FWpolicy p))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; x \\<in> dom (C (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> C (a \\<oplus> list2FWpolicy p) x =\n                      C (list2FWpolicy\n                          (removeDuplicates a # removeAllDuplicates p))\n                       x\n 2. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> C (a \\<oplus> list2FWpolicy p) x =\n                      C (list2FWpolicy\n                          (removeDuplicates a # removeAllDuplicates p))\n                       x", "apply (simp add: Cdom2 Cons.hyps domIff l2p_aux rADnMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (C (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> C (a \\<oplus> list2FWpolicy p) x =\n                      C (list2FWpolicy\n                          (removeDuplicates a # removeAllDuplicates p))\n                       x", "by (metis C_eq_RD_aux Cons.hyps domIff list2FWpolicyconc nlpaux rADnMT)"], ["proof (state)\nthis:\n  a # p \\<noteq> [] \\<longrightarrow>\n  C (list2FWpolicy (a # p)) x =\n  C (list2FWpolicy (removeAllDuplicates (a # p))) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_RAD: \n  \"p \\<noteq> []  \\<Longrightarrow> C (list2FWpolicy p) = C (list2FWpolicy (removeAllDuplicates p)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    C (list2FWpolicy p) = C (list2FWpolicy (removeAllDuplicates p))", "by (rule ext,erule C_eq_RAD_aux)"], ["", "lemma C_eq_compile: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p)l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n    C (list2FWpolicy\n        (removeAllDuplicates\n          (insertDenies\n            (separate\n              (FWNormalisationCore.sort\n                (removeShadowRules2 (remdups (rm_MT_rules C \n                    (insertDeny (removeShadowRules1 (policy2list p)))))) l))))) =\n    C p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (removeAllDuplicates\n                            (insertDenies\n                              (separate\n                                (FWNormalisationCore.sort\n                                  (removeShadowRules2\n                                    (remdups\n(rm_MT_rules C (insertDeny (removeShadowRules1 (policy2list p))))))\n                                  l))))) =\n                      C p", "apply (subst C_eq_RAD[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> insertDenies\n                       (separate\n                         (FWNormalisationCore.sort\n                           (removeShadowRules2\n                             (remdups\n                               (rm_MT_rules C\n                                 (insertDeny\n                                   (removeShadowRules1 (policy2list p))))))\n                           l)) \\<noteq>\n                      []\n 2. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (insertDenies\n                            (separate\n                              (FWNormalisationCore.sort\n                                (removeShadowRules2\n                                  (remdups\n                                    (rm_MT_rules C\n(insertDeny (removeShadowRules1 (policy2list p))))))\n                                l)))) =\n                      C p", "apply (rule idNMT,simp add: C_eqLemmas_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (insertDenies\n                            (separate\n                              (FWNormalisationCore.sort\n                                (removeShadowRules2\n                                  (remdups\n                                    (rm_MT_rules C\n(insertDeny (removeShadowRules1 (policy2list p))))))\n                                l)))) =\n                      C p", "by (rule C_eq_Until_InsertDenies, simp_all)"], ["", "lemma C_eq_compileQ: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p)l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n   C (list2FWpolicy\n       (removeAllDuplicates\n         (insertDenies\n           (separate\n             (qsort (removeShadowRules2 (remdups (rm_MT_rules C \n                  (insertDeny (removeShadowRules1 (policy2list p)))))) l))))) =\n    C p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (removeAllDuplicates\n                            (insertDenies\n                              (separate\n                                (qsort\n                                  (removeShadowRules2\n                                    (remdups\n(rm_MT_rules C (insertDeny (removeShadowRules1 (policy2list p))))))\n                                  l))))) =\n                      C p", "apply (subst C_eq_RAD[symmetric],rule idNMT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> separate\n                       (qsort\n                         (removeShadowRules2\n                           (remdups\n                             (rm_MT_rules C\n                               (insertDeny\n                                 (removeShadowRules1 (policy2list p))))))\n                         l) \\<noteq>\n                      []\n 2. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (insertDenies\n                            (separate\n                              (qsort\n                                (removeShadowRules2\n                                  (remdups\n                                    (rm_MT_rules C\n(insertDeny (removeShadowRules1 (policy2list p))))))\n                                l)))) =\n                      C p", "apply (metis WP1rd sepnMT sortnMTQ wellformed_policy1_strong.simps(1) wp1ID wp1n_RS2 wp1n_RS3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (insertDenies\n                            (separate\n                              (qsort\n                                (removeShadowRules2\n                                  (remdups\n                                    (rm_MT_rules C\n(insertDeny (removeShadowRules1 (policy2list p))))))\n                                l)))) =\n                      C p", "by (rule C_eq_Until_InsertDeniesQ, simp_all)"], ["", "lemma C_eq_normalize: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> allNetsDistinct (policy2list p) \\<Longrightarrow>\n all_in_list(policy2list p)(Nets_List p) \\<Longrightarrow> \n C (list2FWpolicy (normalize p)) = C p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     allNetsDistinct (policy2list p);\n     all_in_list (policy2list p) (Nets_List p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (FWNormalisationCore.normalize p)) =\n                      C p", "unfolding normalize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     allNetsDistinct (policy2list p);\n     all_in_list (policy2list p) (Nets_List p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (removeAllDuplicates\n                            (insertDenies\n                              (separate\n                                (FWNormalisationCore.sort\n                                  (removeShadowRules2\n                                    (remdups\n(rm_MT_rules C (insertDeny (removeShadowRules1 (policy2list p))))))\n                                  (Nets_List p)))))) =\n                      C p", "by (simp add: C_eq_compile)"], ["", "lemma C_eq_normalizeQ: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> allNetsDistinct (policy2list p) \\<Longrightarrow> \n   all_in_list (policy2list p) (Nets_List p) \\<Longrightarrow> \n   C (list2FWpolicy (normalizeQ p)) = C p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     allNetsDistinct (policy2list p);\n     all_in_list (policy2list p) (Nets_List p)\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (normalizeQ p)) = C p", "by (simp add: normalizeQ_def C_eq_compileQ)"], ["", "lemma domSubset3: \"dom (C (DenyAll \\<oplus> x)) = dom (C (DenyAll))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (C (DenyAll \\<oplus> x)) = dom (C DenyAll)", "by (simp add: PLemmas split_tupled_all split: option.splits)"], ["", "lemma domSubset4: \n  \"dom (C (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x \\<oplus> AllowPortFromTo x y dn)) = \n   dom (C (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (C (DenyAllFromTo x y \\<oplus>\n            DenyAllFromTo y x \\<oplus> AllowPortFromTo x y dn)) =\n    dom (C (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x))", "by (auto simp: PLemmas split: option.splits decision.splits )"], ["", "lemma domSubset5: \n  \"dom (C (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x \\<oplus> AllowPortFromTo y x dn)) = \n  dom (C (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (C (DenyAllFromTo x y \\<oplus>\n            DenyAllFromTo y x \\<oplus> AllowPortFromTo y x dn)) =\n    dom (C (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x))", "by (auto simp: PLemmas split: option.splits decision.splits )"], ["", "lemma domSubset1: \n  \"dom (C (DenyAllFromTo one two \\<oplus> DenyAllFromTo two one \\<oplus> AllowPortFromTo one two dn \\<oplus> x)) = \n   dom (C (DenyAllFromTo one two \\<oplus> DenyAllFromTo two one \\<oplus> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (C (DenyAllFromTo one two \\<oplus>\n            DenyAllFromTo two one \\<oplus>\n            AllowPortFromTo one two dn \\<oplus> x)) =\n    dom (C (DenyAllFromTo one two \\<oplus>\n            DenyAllFromTo two one \\<oplus> x))", "by (simp add: PLemmas split: option.splits decision.splits) (auto simp: allow_all_def deny_all_def)"], ["", "lemma domSubset2: \n  \"dom (C (DenyAllFromTo one two \\<oplus> DenyAllFromTo two one \\<oplus> AllowPortFromTo two one dn \\<oplus> x)) = \n  dom (C (DenyAllFromTo one two \\<oplus> DenyAllFromTo two one \\<oplus> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (C (DenyAllFromTo one two \\<oplus>\n            DenyAllFromTo two one \\<oplus>\n            AllowPortFromTo two one dn \\<oplus> x)) =\n    dom (C (DenyAllFromTo one two \\<oplus>\n            DenyAllFromTo two one \\<oplus> x))", "by (simp add: PLemmas split: option.splits decision.splits) (auto simp: allow_all_def deny_all_def)"], ["", "lemma ConcAssoc2: \"C (X \\<oplus> Y \\<oplus> ((A \\<oplus> B) \\<oplus> D)) = C (X \\<oplus> Y \\<oplus> A \\<oplus> B \\<oplus> D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C (X \\<oplus> Y \\<oplus> (A \\<oplus> B) \\<oplus> D) =\n    C (X \\<oplus> Y \\<oplus> A \\<oplus> B \\<oplus> D)", "by (simp add: C.simps)"], ["", "lemma ConcAssoc3: \"C (X \\<oplus> ((Y \\<oplus> A) \\<oplus> D)) = C (X \\<oplus> Y \\<oplus> A \\<oplus> D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C (X \\<oplus> (Y \\<oplus> A) \\<oplus> D) =\n    C (X \\<oplus> Y \\<oplus> A \\<oplus> D)", "by (simp add: C.simps)"], ["", "lemma RS3_NMT[rule_format]: \n  \"DenyAll \\<in> set p \\<longrightarrow> rm_MT_rules C p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set p \\<longrightarrow> rm_MT_rules C p \\<noteq> []", "by (induct_tac p) (simp_all add: PLemmas)"], ["", "lemma norm_notMT: \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> normalize p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set (policy2list p) \\<Longrightarrow>\n    FWNormalisationCore.normalize p \\<noteq> []", "by (simp add: DAiniD RS2_NMT RS3_NMT idNMT normalize_def rADnMT sepnMT sortnMT)"], ["", "lemma norm_notMTQ: \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> normalizeQ p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set (policy2list p) \\<Longrightarrow>\n    normalizeQ p \\<noteq> []", "by (simp add: DAiniD RS2_NMT RS3_NMT idNMT normalizeQ_def rADnMT sepnMT sortnMTQ)"], ["", "lemmas domDA = NormalisationIntegerPortProof.domSubset3"], ["", "(* legacy *)"], ["", "lemmas domain_reasoning = domDA ConcAssoc2 domSubset1 domSubset2 \n                          domSubset3 domSubset4  domSubset5 domSubsetDistr1\n                          domSubsetDistr2 domSubsetDistrA domSubsetDistrD coerc_assoc ConcAssoc \n                          ConcAssoc3"], ["", "text \\<open>The following lemmas help with the normalisation\\<close>"], ["", "lemma list2policyR_Start[rule_format]: \"p \\<in> dom (C a) \\<longrightarrow>\n                 C (list2policyR (a # list)) p = C a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> dom (C a) \\<longrightarrow>\n    C (list2policyR (a # list)) p = C a p", "by (induct \"a # list\" rule:list2policyR.induct) (auto simp: C.simps dom_def map_add_def)"], ["", "lemma list2policyR_End: \"p \\<notin> dom (C a) \\<Longrightarrow>\n        C (list2policyR (a # list)) p = (C a \\<Oplus> list2policy (map C list)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<notin> dom (C a) \\<Longrightarrow>\n    C (list2policyR (a # list)) p =\n    (C a \\<Oplus> list2policy (map C list)) p", "by (rule list2policyR.induct)\n    (simp_all add: C.simps dom_def map_add_def list2policy_def split: option.splits)"], ["", "lemma l2polR_eq_el[rule_format]: \n  \"N \\<noteq> [] \\<longrightarrow> C(list2policyR N) p =  (list2policy (map C N)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<noteq> [] \\<longrightarrow>\n    C (list2policyR N) p = list2policy (map C N) p", "proof (induct N)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    C (list2policyR []) p = list2policy (map C []) p\n 2. \\<And>a N.\n       N \\<noteq> [] \\<longrightarrow>\n       C (list2policyR N) p = list2policy (map C N) p \\<Longrightarrow>\n       a # N \\<noteq> [] \\<longrightarrow>\n       C (list2policyR (a # N)) p = list2policy (map C (a # N)) p", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    C (list2policyR []) p = list2policy (map C []) p\n 2. \\<And>a N.\n       N \\<noteq> [] \\<longrightarrow>\n       C (list2policyR N) p = list2policy (map C N) p \\<Longrightarrow>\n       a # N \\<noteq> [] \\<longrightarrow>\n       C (list2policyR (a # N)) p = list2policy (map C (a # N)) p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    C (list2policyR []) p = list2policy (map C []) p", "by (simp_all add: list2policy_def)"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  C (list2policyR []) p = list2policy (map C []) p\n\ngoal (1 subgoal):\n 1. \\<And>a N.\n       N \\<noteq> [] \\<longrightarrow>\n       C (list2policyR N) p = list2policy (map C N) p \\<Longrightarrow>\n       a # N \\<noteq> [] \\<longrightarrow>\n       C (list2policyR (a # N)) p = list2policy (map C (a # N)) p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a N.\n       N \\<noteq> [] \\<longrightarrow>\n       C (list2policyR N) p = list2policy (map C N) p \\<Longrightarrow>\n       a # N \\<noteq> [] \\<longrightarrow>\n       C (list2policyR (a # N)) p = list2policy (map C (a # N)) p", "case (Cons a N)"], ["proof (state)\nthis:\n  N \\<noteq> [] \\<longrightarrow>\n  C (list2policyR N) p = list2policy (map C N) p\n\ngoal (1 subgoal):\n 1. \\<And>a N.\n       N \\<noteq> [] \\<longrightarrow>\n       C (list2policyR N) p = list2policy (map C N) p \\<Longrightarrow>\n       a # N \\<noteq> [] \\<longrightarrow>\n       C (list2policyR (a # N)) p = list2policy (map C (a # N)) p", "then"], ["proof (chain)\npicking this:\n  N \\<noteq> [] \\<longrightarrow>\n  C (list2policyR N) p = list2policy (map C N) p", "show ?case"], ["proof (prove)\nusing this:\n  N \\<noteq> [] \\<longrightarrow>\n  C (list2policyR N) p = list2policy (map C N) p\n\ngoal (1 subgoal):\n 1. a # N \\<noteq> [] \\<longrightarrow>\n    C (list2policyR (a # N)) p = list2policy (map C (a # N)) p", "apply (case_tac \"p \\<in> dom (C a)\",simp_all add: domStart list2policy_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<in> dom (C a);\n     N \\<noteq> [] \\<longrightarrow>\n     C (list2policyR N) p =\n     foldr (\\<lambda>x y. x \\<Oplus> y) (map C N) \\<emptyset> p\\<rbrakk>\n    \\<Longrightarrow> C (list2policyR (a # N)) p = C a p\n 2. \\<lbrakk>p \\<notin> dom (C a);\n     N \\<noteq> [] \\<longrightarrow>\n     C (list2policyR N) p =\n     foldr (\\<lambda>x y. x \\<Oplus> y) (map C N) \\<emptyset> p\\<rbrakk>\n    \\<Longrightarrow> C (list2policyR (a # N)) p =\n                      (C a \\<Oplus>\n                       foldr (\\<lambda>x y. x \\<Oplus> y) (map C N)\n                        \\<emptyset>)\n                       p", "apply (rule list2policyR_Start, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<notin> dom (C a);\n     N \\<noteq> [] \\<longrightarrow>\n     C (list2policyR N) p =\n     foldr (\\<lambda>x y. x \\<Oplus> y) (map C N) \\<emptyset> p\\<rbrakk>\n    \\<Longrightarrow> C (list2policyR (a # N)) p =\n                      (C a \\<Oplus>\n                       foldr (\\<lambda>x y. x \\<Oplus> y) (map C N)\n                        \\<emptyset>)\n                       p", "apply (rule list2policyR.induct, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>p \\<notin> dom (C a);\n        N \\<noteq> [] \\<longrightarrow>\n        C (list2policyR N) p =\n        foldr (\\<lambda>x y. x \\<Oplus> y) (map C N) \\<emptyset> p\\<rbrakk>\n       \\<Longrightarrow> C (x \\<oplus> a) p = (C a \\<Oplus> C x) p\n 2. \\<And>x v va.\n       \\<lbrakk>p \\<notin> dom (C a);\n        N \\<noteq> [] \\<longrightarrow>\n        C (list2policyR N) p =\n        foldr (\\<lambda>x y. x \\<Oplus> y) (map C N) \\<emptyset> p;\n        C (list2policyR (v # va) \\<oplus> a) p =\n        (C a \\<Oplus>\n         (C v \\<Oplus>\n          foldr (\\<lambda>x y. x \\<Oplus> y) (map C va) \\<emptyset>))\n         p\\<rbrakk>\n       \\<Longrightarrow> C ((list2policyR (v # va) \\<oplus> x) \\<oplus> a)\n                          p =\n                         (C a \\<Oplus>\n                          (C x \\<Oplus>\n                           (C v \\<Oplus>\n                            foldr (\\<lambda>x y. x \\<Oplus> y) (map C va)\n                             \\<emptyset>)))\n                          p", "apply (simp_all add: C.simps dom_def map_add_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x v va.\n       \\<lbrakk>C a p = \\<bottom>;\n        N \\<noteq> [] \\<longrightarrow>\n        C (list2policyR N) p =\n        foldr\n         (\\<lambda>x y xa.\n             case x xa of \\<bottom> \\<Rightarrow> y xa\n             | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>y\\<rfloor>)\n         (map C N) \\<emptyset> p;\n        C (list2policyR (v # va)) p =\n        (case C v p of\n         \\<bottom> \\<Rightarrow>\n           foldr\n            (\\<lambda>x y xa.\n                case x xa of \\<bottom> \\<Rightarrow> y xa\n                | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>)\n            (map C va) \\<emptyset> p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> (case C x p of\n                          \\<bottom> \\<Rightarrow>\n                            C (list2policyR (v # va)) p\n                          | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                              \\<lfloor>x\\<rfloor>) =\n                         (case C x p of\n                          \\<bottom> \\<Rightarrow>\n                            case C v p of\n                            \\<bottom> \\<Rightarrow>\n                              foldr\n                               (\\<lambda>x y xa.\n                                   case x xa of \\<bottom> \\<Rightarrow> y xa\n                                   | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n \\<lfloor>x\\<rfloor>)\n                               (map C va) \\<emptyset> p\n                            | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                                \\<lfloor>x\\<rfloor>\n                          | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                              \\<lfloor>x\\<rfloor>)", "apply (simp split: option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a # N \\<noteq> [] \\<longrightarrow>\n  C (list2policyR (a # N)) p = list2policy (map C (a # N)) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma l2polR_eq: \n  \"N \\<noteq> [] \\<Longrightarrow> C( list2policyR N) =  (list2policy (map C N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<noteq> [] \\<Longrightarrow>\n    C (list2policyR N) = list2policy (map C N)", "by (auto simp: list2policy_def l2polR_eq_el )"], ["", "lemma list2FWpolicys_eq_el[rule_format]: \n  \"Filter \\<noteq> []  \\<longrightarrow>  C (list2policyR Filter) p =  C (list2FWpolicy (rev Filter)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filter \\<noteq> [] \\<longrightarrow>\n    C (list2policyR Filter) p = C (list2FWpolicy (rev Filter)) p", "proof (induct Filter)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    C (list2policyR []) p = C (list2FWpolicy (rev [])) p\n 2. \\<And>a Filter.\n       Filter \\<noteq> [] \\<longrightarrow>\n       C (list2policyR Filter) p =\n       C (list2FWpolicy (rev Filter)) p \\<Longrightarrow>\n       a # Filter \\<noteq> [] \\<longrightarrow>\n       C (list2policyR (a # Filter)) p =\n       C (list2FWpolicy (rev (a # Filter))) p", "print_cases"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    C (list2policyR []) p = C (list2FWpolicy (rev [])) p\n 2. \\<And>a Filter.\n       Filter \\<noteq> [] \\<longrightarrow>\n       C (list2policyR Filter) p =\n       C (list2FWpolicy (rev Filter)) p \\<Longrightarrow>\n       a # Filter \\<noteq> [] \\<longrightarrow>\n       C (list2policyR (a # Filter)) p =\n       C (list2FWpolicy (rev (a # Filter))) p", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    C (list2policyR []) p = C (list2FWpolicy (rev [])) p\n 2. \\<And>a Filter.\n       Filter \\<noteq> [] \\<longrightarrow>\n       C (list2policyR Filter) p =\n       C (list2FWpolicy (rev Filter)) p \\<Longrightarrow>\n       a # Filter \\<noteq> [] \\<longrightarrow>\n       C (list2policyR (a # Filter)) p =\n       C (list2FWpolicy (rev (a # Filter))) p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    C (list2policyR []) p = C (list2FWpolicy (rev [])) p", "by (simp)"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  C (list2policyR []) p = C (list2FWpolicy (rev [])) p\n\ngoal (1 subgoal):\n 1. \\<And>a Filter.\n       Filter \\<noteq> [] \\<longrightarrow>\n       C (list2policyR Filter) p =\n       C (list2FWpolicy (rev Filter)) p \\<Longrightarrow>\n       a # Filter \\<noteq> [] \\<longrightarrow>\n       C (list2policyR (a # Filter)) p =\n       C (list2FWpolicy (rev (a # Filter))) p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Filter.\n       Filter \\<noteq> [] \\<longrightarrow>\n       C (list2policyR Filter) p =\n       C (list2FWpolicy (rev Filter)) p \\<Longrightarrow>\n       a # Filter \\<noteq> [] \\<longrightarrow>\n       C (list2policyR (a # Filter)) p =\n       C (list2FWpolicy (rev (a # Filter))) p", "case (Cons a list)"], ["proof (state)\nthis:\n  list \\<noteq> [] \\<longrightarrow>\n  C (list2policyR list) p = C (list2FWpolicy (rev list)) p\n\ngoal (1 subgoal):\n 1. \\<And>a Filter.\n       Filter \\<noteq> [] \\<longrightarrow>\n       C (list2policyR Filter) p =\n       C (list2FWpolicy (rev Filter)) p \\<Longrightarrow>\n       a # Filter \\<noteq> [] \\<longrightarrow>\n       C (list2policyR (a # Filter)) p =\n       C (list2FWpolicy (rev (a # Filter))) p", "then"], ["proof (chain)\npicking this:\n  list \\<noteq> [] \\<longrightarrow>\n  C (list2policyR list) p = C (list2FWpolicy (rev list)) p", "show ?case"], ["proof (prove)\nusing this:\n  list \\<noteq> [] \\<longrightarrow>\n  C (list2policyR list) p = C (list2FWpolicy (rev list)) p\n\ngoal (1 subgoal):\n 1. a # list \\<noteq> [] \\<longrightarrow>\n    C (list2policyR (a # list)) p = C (list2FWpolicy (rev (a # list))) p", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. list \\<noteq> [] \\<longrightarrow>\n    C (list2policyR list) p =\n    C (list2FWpolicy (rev list)) p \\<Longrightarrow>\n    C (list2policyR (a # list)) p = C (list2FWpolicy (rev list @ [a])) p", "apply (case_tac \"list = []\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C (list2policyR list) p = C (list2FWpolicy (rev list)) p;\n     list \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (list2policyR (a # list)) p =\n                      C (list2FWpolicy (rev list @ [a])) p", "apply (case_tac \"p \\<in> dom (C a)\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C (list2policyR list) p = C (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<in> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> C (list2policyR (a # list)) p = C a p\n 2. \\<lbrakk>C (list2policyR list) p = C (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> C (list2policyR (a # list)) p =\n                      C (list2FWpolicy (rev list)) p", "apply (rule list2policyR_Start, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C (list2policyR list) p = C (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (C a)\\<rbrakk>\n    \\<Longrightarrow> C (list2policyR (a # list)) p =\n                      C (list2FWpolicy (rev list)) p", "by (metis C.simps(4) l2polR_eq list2policyR_End nlpaux)"], ["proof (state)\nthis:\n  a # list \\<noteq> [] \\<longrightarrow>\n  C (list2policyR (a # list)) p = C (list2FWpolicy (rev (a # list))) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list2FWpolicys_eq: \n  \"Filter \\<noteq> []  \\<Longrightarrow> C (list2policyR Filter) =  C (list2FWpolicy (rev Filter))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filter \\<noteq> [] \\<Longrightarrow>\n    C (list2policyR Filter) = C (list2FWpolicy (rev Filter))", "by (rule ext, erule list2FWpolicys_eq_el)"], ["", "lemma list2FWpolicys_eq_sym: \n  \"Filter \\<noteq> [] \\<Longrightarrow>C (list2policyR (rev Filter)) =  C (list2FWpolicy Filter)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filter \\<noteq> [] \\<Longrightarrow>\n    C (list2policyR (rev Filter)) = C (list2FWpolicy Filter)", "by (metis list2FWpolicys_eq rev_is_Nil_conv rev_rev_ident)"], ["", "lemma p_eq[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow>  list2policy (map C (rev p)) = C (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    list2policy (map C (rev p)) = C (list2FWpolicy p)", "by (metis l2polR_eq list2FWpolicys_eq_sym rev.simps(1) rev_rev_ident)"], ["", "lemma p_eq2[rule_format]: \n  \"normalize x \\<noteq> [] \\<longrightarrow> C(list2FWpolicy(normalize x)) = C x \\<longrightarrow> \n   list2policy(map C (rev(normalize x))) = C x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.normalize x \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (FWNormalisationCore.normalize x)) =\n    C x \\<longrightarrow>\n    list2policy (map C (rev (FWNormalisationCore.normalize x))) = C x", "by (simp add: p_eq)"], ["", "lemma p_eq2Q[rule_format]: \n  \"normalizeQ x \\<noteq> [] \\<longrightarrow>  C (list2FWpolicy (normalizeQ x)) = C x \\<longrightarrow>\n   list2policy (map C (rev (normalizeQ x))) = C x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalizeQ x \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (normalizeQ x)) = C x \\<longrightarrow>\n    list2policy (map C (rev (normalizeQ x))) = C x", "by (simp add: p_eq)"], ["", "lemma list2listNMT[rule_format]: \"x \\<noteq> [] \\<longrightarrow>map sem x \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<longrightarrow> map sem x \\<noteq> []", "by (case_tac x) simp_all"], ["", "lemma Norm_Distr2: \n  \"r o_f ((P \\<Otimes>\\<^sub>2 (list2policy Q)) o d) = (list2policy ((P \\<Otimes>\\<^sub>L Q) (\\<Otimes>\\<^sub>2) r d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r o\\<^sub>f (P \\<Otimes>\\<^sub>2 list2policy Q \\<circ> d) =\n    list2policy ((P \\<Otimes>\\<^sub>L Q) (\\<Otimes>\\<^sub>2) r d)", "by (rule ext, rule Norm_Distr_2)"], ["", "lemma NATDistr: \n  \"N \\<noteq> [] \\<Longrightarrow> F = C (list2policyR N) \\<Longrightarrow>\n    (\\<lambda>(x, y). x) o\\<^sub>f (NAT \\<Otimes>\\<^sub>2 F \\<circ> (\\<lambda>x. (x, x))) = \n    list2policy ((NAT \\<Otimes>\\<^sub>L map C N) (\\<Otimes>\\<^sub>2) (\\<lambda>(x, y). x) (\\<lambda>x. (x, x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>N \\<noteq> []; F = C (list2policyR N)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>(x, y). x) o\\<^sub>f\n                      (NAT \\<Otimes>\\<^sub>2 F \\<circ>\n                       (\\<lambda>x. (x, x))) =\n                      list2policy\n                       ((NAT \\<Otimes>\\<^sub>L map C N) (\\<Otimes>\\<^sub>2)\n                         (\\<lambda>(x, y). x) (\\<lambda>x. (x, x)))", "apply (simp add: l2polR_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>N \\<noteq> []; F = list2policy (map C N)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>(x, y). x) o\\<^sub>f\n                      (NAT \\<Otimes>\\<^sub>2 list2policy (map C N) \\<circ>\n                       (\\<lambda>x. (x, x))) =\n                      list2policy\n                       ((NAT \\<Otimes>\\<^sub>L map C N) (\\<Otimes>\\<^sub>2)\n                         (\\<lambda>(x, y). x) (\\<lambda>x. (x, x)))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>N \\<noteq> []; F = list2policy (map C N)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(x, y). x) o\\<^sub>f\n                          (NAT \\<Otimes>\\<^sub>2\n                           list2policy (map C N) \\<circ>\n                           (\\<lambda>x. (x, x))))\n                          x =\n                         list2policy\n                          ((NAT \\<Otimes>\\<^sub>L map C N)\n                            (\\<Otimes>\\<^sub>2) (\\<lambda>(x, y). x)\n                            (\\<lambda>x. (x, x)))\n                          x", "apply (rule Norm_Distr_2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_eq_normalize_manual: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow> \n C (list2FWpolicy (normalize_manual_order p l)) = C p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     allNetsDistinct (policy2list p); all_in_list (policy2list p) l\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (normalize_manual_order p l)) = C p", "by (simp add: normalize_manual_order_def C_eq_compile)"], ["", "lemma p_eq2_manualQ[rule_format]: \n  \"normalize_manual_orderQ x l \\<noteq> [] \\<longrightarrow> C(list2FWpolicy (normalize_manual_orderQ x l)) = C x \\<longrightarrow>\n   list2policy (map C (rev (normalize_manual_orderQ x l))) = C x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize_manual_orderQ x l \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (normalize_manual_orderQ x l)) = C x \\<longrightarrow>\n    list2policy (map C (rev (normalize_manual_orderQ x l))) = C x", "by (simp add: p_eq)"], ["", "lemma norm_notMT_manualQ: \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> normalize_manual_orderQ p l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set (policy2list p) \\<Longrightarrow>\n    normalize_manual_orderQ p l \\<noteq> []", "by (simp add: DAiniD RS2_NMT RS3_NMT idNMT normalize_manual_orderQ_def rADnMT sepnMT sortnMTQ)"], ["", "lemma C_eq_normalize_manualQ: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow> \n   C (list2FWpolicy (normalize_manual_orderQ p l)) = C p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     allNetsDistinct (policy2list p); all_in_list (policy2list p) l\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy (normalize_manual_orderQ p l)) = C p", "by (simp add: normalize_manual_orderQ_def C_eq_compileQ)"], ["", "lemma p_eq2_manual[rule_format]: \n  \"normalize_manual_order x l \\<noteq> [] \\<longrightarrow> C (list2FWpolicy (normalize_manual_order x l)) = C x \\<longrightarrow>\n   list2policy (map C (rev (normalize_manual_order x l))) = C x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize_manual_order x l \\<noteq> [] \\<longrightarrow>\n    C (list2FWpolicy (normalize_manual_order x l)) = C x \\<longrightarrow>\n    list2policy (map C (rev (normalize_manual_order x l))) = C x", "by (simp add: p_eq)"], ["", "lemma norm_notMT_manual: \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> normalize_manual_order p l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set (policy2list p) \\<Longrightarrow>\n    normalize_manual_order p l \\<noteq> []", "by (simp add: RS2_NMT idNMT normalize_manual_order_def rADnMT sepnMT sortnMT wp1ID)"], ["", "text\\<open>\n  As an example, how this theorems can be used for a concrete normalisation instantiation. \n\\<close>"], ["", "lemma normalizeNAT: \n  \"DenyAll \\<in> set (policy2list Filter) \\<Longrightarrow> allNetsDistinct (policy2list Filter) \\<Longrightarrow>\n   all_in_list (policy2list Filter) (Nets_List Filter) \\<Longrightarrow>\n   (\\<lambda>(x, y). x) o\\<^sub>f (NAT \\<Otimes>\\<^sub>2 C Filter \\<circ> (\\<lambda>x. (x, x))) =\n   list2policy ((NAT \\<Otimes>\\<^sub>L map C (rev (FWNormalisationCore.normalize Filter))) (\\<Otimes>\\<^sub>2) \n       (\\<lambda>(x, y). x) (\\<lambda>x. (x, x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list Filter);\n     allNetsDistinct (policy2list Filter);\n     all_in_list (policy2list Filter) (Nets_List Filter)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>(x, y). x) o\\<^sub>f\n                      (NAT \\<Otimes>\\<^sub>2 C Filter \\<circ>\n                       (\\<lambda>x. (x, x))) =\n                      list2policy\n                       ((NAT \\<Otimes>\\<^sub>L\n                         map C (rev (FWNormalisationCore.normalize Filter)))\n                         (\\<Otimes>\\<^sub>2) (\\<lambda>(x, y). x)\n                         (\\<lambda>x. (x, x)))", "by (simp add: C_eq_normalize NATDistr list2FWpolicys_eq_sym norm_notMT)"], ["", "lemma domSimpl[simp]: \"dom (C (A \\<oplus> DenyAll)) = dom (C (DenyAll))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (C (A \\<oplus> DenyAll)) = dom (C DenyAll)", "by (simp add: PLemmas)"], ["", "text \\<open>\n  The followin theorems can be applied when prepending the usual normalisation with an \n  additional step and using another semantical interpretation function. This is a general recipe \n  which can be applied whenever one nees to combine several normalisation strategies. \n\\<close>"], ["", "lemma CRotate_eq_rotateC: \"CRotate p = C (rotatePolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CRotate p = C (rotatePolicy p)", "by (induct p rule: rotatePolicy.induct) (simp_all add: C.simps map_add_def)"], ["", "lemma DAinRotate: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> DenyAll \\<in> set (policy2list (rotatePolicy p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set (policy2list p) \\<Longrightarrow>\n    DenyAll \\<in> set (policy2list (rotatePolicy p))", "apply (induct p,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>DenyAll \\<in> set (policy2list p1) \\<Longrightarrow>\n                DenyAll \\<in> set (policy2list (rotatePolicy p1));\n        DenyAll \\<in> set (policy2list p2) \\<Longrightarrow>\n        DenyAll \\<in> set (policy2list (rotatePolicy p2));\n        DenyAll \\<in> set (policy2list p1) \\<or>\n        DenyAll \\<in> set (policy2list p2)\\<rbrakk>\n       \\<Longrightarrow> DenyAll\n                         \\<in> set (policy2list (rotatePolicy p2)) \\<or>\n                         DenyAll \\<in> set (policy2list (rotatePolicy p1))", "subgoal for p1 p2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p1) \\<Longrightarrow>\n             DenyAll \\<in> set (policy2list (rotatePolicy p1));\n     DenyAll \\<in> set (policy2list p2) \\<Longrightarrow>\n     DenyAll \\<in> set (policy2list (rotatePolicy p2));\n     DenyAll \\<in> set (policy2list p1) \\<or>\n     DenyAll \\<in> set (policy2list p2)\\<rbrakk>\n    \\<Longrightarrow> DenyAll\n                      \\<in> set (policy2list (rotatePolicy p2)) \\<or>\n                      DenyAll \\<in> set (policy2list (rotatePolicy p1))", "apply (case_tac \"DenyAll \\<in> set (policy2list p1)\",simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma DAUniv: \"dom (CRotate (P \\<oplus> DenyAll)) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (CRotate (P \\<oplus> DenyAll)) = UNIV", "by (metis CRotate.simps(1) CRotate.simps(4) CRotate_eq_rotateC DAAux PLemmas(4) UNIV_eq_I domSubset3)"], ["", "lemma p_eq2R[rule_format]: \n  \"normalize (rotatePolicy x) \\<noteq> [] \\<longrightarrow> C(list2FWpolicy(normalize (rotatePolicy x))) = CRotate x \\<longrightarrow>\n   list2policy (map C (rev (normalize (rotatePolicy x)))) = CRotate x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.normalize (rotatePolicy x) \\<noteq>\n    [] \\<longrightarrow>\n    C (list2FWpolicy (FWNormalisationCore.normalize (rotatePolicy x))) =\n    CRotate x \\<longrightarrow>\n    list2policy\n     (map C (rev (FWNormalisationCore.normalize (rotatePolicy x)))) =\n    CRotate x", "by (simp add: p_eq)"], ["", "lemma C_eq_normalizeRotate: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> allNetsDistinct (policy2list (rotatePolicy p)) \\<Longrightarrow>\n   all_in_list (policy2list (rotatePolicy p)) (Nets_List (rotatePolicy p)) \\<Longrightarrow>\n   C (list2FWpolicy\n        (removeAllDuplicates\n          (insertDenies\n            (separate\n              (sort(removeShadowRules2(remdups(rm_MT_rules C \n                        (insertDeny(removeShadowRules1(policy2list(rotatePolicy p)))))))\n                (Nets_List (rotatePolicy p))))))) =\n   CRotate p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     allNetsDistinct (policy2list (rotatePolicy p));\n     all_in_list (policy2list (rotatePolicy p))\n      (Nets_List (rotatePolicy p))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (removeAllDuplicates\n                            (insertDenies\n                              (separate\n                                (FWNormalisationCore.sort\n                                  (removeShadowRules2\n                                    (remdups\n(rm_MT_rules C\n  (insertDeny (removeShadowRules1 (policy2list (rotatePolicy p)))))))\n                                  (Nets_List (rotatePolicy p))))))) =\n                      CRotate p", "by (simp add: CRotate_eq_rotateC C_eq_compile DAinRotate)"], ["", "lemma C_eq_normalizeRotate2:\n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow>\n   allNetsDistinct (policy2list (rotatePolicy p)) \\<Longrightarrow>\n   all_in_list (policy2list (rotatePolicy p)) (Nets_List (rotatePolicy p)) \\<Longrightarrow>\n   C (list2FWpolicy (FWNormalisationCore.normalize (rotatePolicy p))) = CRotate p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     allNetsDistinct (policy2list (rotatePolicy p));\n     all_in_list (policy2list (rotatePolicy p))\n      (Nets_List (rotatePolicy p))\\<rbrakk>\n    \\<Longrightarrow> C (list2FWpolicy\n                          (FWNormalisationCore.normalize\n                            (rotatePolicy p))) =\n                      CRotate p", "by (simp add: normalize_def, erule C_eq_normalizeRotate,simp_all)"], ["", "end"]]}