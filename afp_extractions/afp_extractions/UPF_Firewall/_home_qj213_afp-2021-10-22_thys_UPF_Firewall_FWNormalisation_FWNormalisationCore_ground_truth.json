{"file_name": "/home/qj213/afp-2021-10-22/thys/UPF_Firewall/FWNormalisation/FWNormalisationCore.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UPF_Firewall", "problem_names": ["lemma qsort_permutes:\n  \"set (qsort xs l) = set xs\"", "lemma set_qsort [simp]: \"set (qsort xs l)  = set xs\"", "lemma check: \"rev (policy2list (rotatePolicy p)) = policy2list p\"", "lemma \"normalize = normalize'\"", "lemma \"normalizePr = normalizePr'\"", "lemmas PLemmas = C.simps Cp.simps dom_def PolicyCombinators.PolicyCombinators\n                 PortCombinators.PortCombinatorsCore aux\n                 ProtocolPortCombinators.ProtocolCombinatorsCore src_def dest_def in_subnet_def\n                 adr\\<^sub>i\\<^sub>p\\<^sub>pLemmas adr\\<^sub>i\\<^sub>p\\<^sub>pLemmas", "lemma aux: \"\\<lbrakk>x \\<noteq> a; y\\<noteq>b; (x \\<noteq> y \\<and> x \\<noteq> b) \\<or>  (a \\<noteq> b \\<and> a \\<noteq> y)\\<rbrakk> \\<Longrightarrow> {x,a} \\<noteq> {y,b}\"", "lemma aux2: \"{a,b} = {b,a}\""], "translations": [["", "lemma qsort_permutes:\n  \"set (qsort xs l) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (qsort xs l) = set xs", "apply (induct \"xs\" \"l\" rule: qsort.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l. set (qsort [] l) = set []\n 2. \\<And>x xs l.\n       \\<lbrakk>set (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                      l) =\n                set (filter (\\<lambda>y. \\<not> smaller x y l) xs);\n        set (qsort (filter (\\<lambda>y. smaller x y l) xs) l) =\n        set (filter (\\<lambda>y. smaller x y l) xs)\\<rbrakk>\n       \\<Longrightarrow> set (qsort (x # xs) l) = set (x # xs)", "by (auto)"], ["", "lemma set_qsort [simp]: \"set (qsort xs l)  = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (qsort xs l) = set xs", "by (simp add: qsort_permutes)"], ["", "fun insort where\n\t  \"insort a [] l = [a]\"\n\t| \"insort a (x#xs) l = (if (smaller a x l) then a#x#xs else x#(insort a xs l))\""], ["", "fun sort where\n  \"sort [] l = []\"\n| \"sort (x#xs) l = insort x (sort xs l) l\""], ["", "fun sorted  where\n  \"sorted [] l = True\"\n| \"sorted [x] l = True\"\n| \"sorted (x#y#zs) l = (smaller x y l \\<and> sorted (y#zs) l)\""], ["", "fun separate where\n \"separate (DenyAll#x) = DenyAll#(separate x)\"\n| \"separate (x#y#z) = (if (first_bothNet x = first_bothNet y) \n                   then (separate ((x\\<oplus>y)#z))\n                   else (x#(separate(y#z))))\"\n|\"separate x = x\""], ["", "text \\<open>\n  Insert the DenyAllFromTo rules, such that traffic between two networks can be tested \n  individually.\n\\<close>"], ["", "fun  insertDenies where\n \"insertDenies (x#xs) = (case x of DenyAll \\<Rightarrow> (DenyAll#(insertDenies xs))\n                    | _  \\<Rightarrow> (DenyAllFromTo (first_srcNet x) (first_destNet x) \\<oplus> \n                       (DenyAllFromTo (first_destNet x) (first_srcNet x)) \\<oplus> x)#\n                                (insertDenies xs))\"\n| \"insertDenies [] = []\""], ["", "text\\<open>\n  Remove duplicate rules. This is especially necessary as insertDenies might have inserted \n  duplicate rules. The second function is supposed to work on a list of policies. Only\n  rules which are duplicated within the same policy are removed.  \n\\<close>"], ["", "fun removeDuplicates where\n  \"removeDuplicates (x\\<oplus>xs) = (if member x xs then (removeDuplicates xs)\n                              else x\\<oplus>(removeDuplicates xs))\"\n| \"removeDuplicates x = x\""], ["", "fun removeAllDuplicates where \n \"removeAllDuplicates (x#xs) = ((removeDuplicates (x))#(removeAllDuplicates xs))\"\n|\"removeAllDuplicates x = x\""], ["", "text \\<open>Insert a DenyAll at the beginning of a policy.\\<close>"], ["", "fun insertDeny where \n \"insertDeny (DenyAll#xs) = DenyAll#xs\"\n|\"insertDeny xs = DenyAll#xs\""], ["", "definition \"sort' p l = sort l p\""], ["", "definition \"qsort' p l = qsort l p\""], ["", "declare dom_eq_empty_conv [simp del]"], ["", "fun list2policyR::\"(('\\<alpha>, '\\<beta>) Combinators) list \\<Rightarrow>\n                   (('\\<alpha>, '\\<beta>) Combinators)\" where\n \"list2policyR (x#[]) = x\"\n|\"list2policyR (x#y) = (list2policyR y) \\<oplus> x\"\n|\"list2policyR [] = undefined \""], ["", "text\\<open>\n  We provide the definitions for two address representations. \n\\<close>"], ["", "subsubsection\\<open>IntPort\\<close>"], ["", "fun C :: \"(adr\\<^sub>i\\<^sub>p net, port) Combinators \\<Rightarrow> (adr\\<^sub>i\\<^sub>p,DummyContent) packet \\<mapsto> unit\"\nwhere\n\" C DenyAll = deny_all\" \n|\"C (DenyAllFromTo x y) = deny_all_from_to x y\"\n|\"C (AllowPortFromTo x y p) = allow_from_to_port p x y\"\n|\"C  (x \\<oplus> y) =  C x ++ C y\""], ["", "fun CRotate :: \"(adr\\<^sub>i\\<^sub>p net, port) Combinators \\<Rightarrow> (adr\\<^sub>i\\<^sub>p,DummyContent) packet \\<mapsto> unit\"\nwhere\n\" CRotate DenyAll = C DenyAll\" \n|\"CRotate (DenyAllFromTo x y) = C (DenyAllFromTo x y)\"\n|\"CRotate (AllowPortFromTo x y p) = C (AllowPortFromTo x y p)\"\n|\"CRotate (x \\<oplus> y) = ((CRotate y) ++ ((CRotate x)))\""], ["", "fun rotatePolicy where\n  \"rotatePolicy DenyAll = DenyAll\" \n| \"rotatePolicy (DenyAllFromTo a b) = DenyAllFromTo a b\"\n| \"rotatePolicy (AllowPortFromTo a b p) = AllowPortFromTo a b p\"\n| \"rotatePolicy (a\\<oplus>b) = (rotatePolicy b) \\<oplus> (rotatePolicy a)\""], ["", "lemma check: \"rev (policy2list (rotatePolicy p)) = policy2list p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (policy2list (rotatePolicy p)) = policy2list p", "apply (induct \"p\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. rev (policy2list (rotatePolicy DenyAll)) = policy2list DenyAll\n 2. \\<And>x1 x2.\n       rev (policy2list (rotatePolicy (DenyAllFromTo x1 x2))) =\n       policy2list (DenyAllFromTo x1 x2)\n 3. \\<And>x1 x2 x3.\n       rev (policy2list (rotatePolicy (AllowPortFromTo x1 x2 x3))) =\n       policy2list (AllowPortFromTo x1 x2 x3)\n 4. \\<And>p1 p2.\n       \\<lbrakk>rev (policy2list (rotatePolicy p1)) = policy2list p1;\n        rev (policy2list (rotatePolicy p2)) = policy2list p2\\<rbrakk>\n       \\<Longrightarrow> rev (policy2list (rotatePolicy (p1 \\<oplus> p2))) =\n                         policy2list (p1 \\<oplus> p2)", "by (simp_all)"], ["", "text\\<open>\n  All rules appearing at the left of a DenyAllFromTo, have disjunct domains from it \n  (except DenyAll). \n\\<close>"], ["", "fun (sequential) wellformed_policy2 where\n  \"wellformed_policy2 [] = True\"\n| \"wellformed_policy2 (DenyAll#xs) = wellformed_policy2 xs\"\n| \"wellformed_policy2 (x#xs) = ((\\<forall> c a b. c = DenyAllFromTo a b \\<and> c \\<in> set xs \\<longrightarrow>\n                 Map.dom (C x) \\<inter> Map.dom (C c) = {}) \\<and> wellformed_policy2 xs)\""], ["", "text\\<open>\n  An allow rule is disjunct with all rules appearing at the right of it. This invariant is not \n  necessary as it is a consequence from others, but facilitates some proofs. \n\\<close>"], ["", "fun (sequential) wellformed_policy3::\"((adr\\<^sub>i\\<^sub>p net,port) Combinators) list \\<Rightarrow> bool\" where\n  \"wellformed_policy3 [] = True\"\n| \"wellformed_policy3 ((AllowPortFromTo a b p)#xs) = ((\\<forall> r. r \\<in> set xs \\<longrightarrow>\n      dom (C r) \\<inter> dom (C (AllowPortFromTo a b p)) = {}) \\<and> wellformed_policy3 xs)\"\n| \"wellformed_policy3 (x#xs) = wellformed_policy3 xs\""], ["", "definition \n  \"normalize' p  = (removeAllDuplicates o insertDenies o separate o\n                   (sort' (Nets_List p))  o removeShadowRules2 o remdups o\n                   (rm_MT_rules C) o insertDeny o removeShadowRules1 o\n                   policy2list) p\""], ["", "definition \n  \"normalizeQ' p  = (removeAllDuplicates o insertDenies o separate o\n                   (qsort' (Nets_List p))  o removeShadowRules2 o remdups o\n                   (rm_MT_rules C) o insertDeny o removeShadowRules1 o\n                   policy2list) p\""], ["", "definition normalize :: \n  \"(adr\\<^sub>i\\<^sub>p net, port) Combinators \\<Rightarrow> \n   (adr\\<^sub>i\\<^sub>p net, port) Combinators list\" \nwhere\n   \"normalize p = (removeAllDuplicates (insertDenies (separate (sort\n                   (removeShadowRules2 (remdups ((rm_MT_rules C) (insertDeny\n                  (removeShadowRules1 (policy2list p)))))) ((Nets_List p))))))\""], ["", "definition\n   \"normalize_manual_order p l = removeAllDuplicates (insertDenies (separate\n    (sort (removeShadowRules2 (remdups ((rm_MT_rules C) (insertDeny\n    (removeShadowRules1 (policy2list p)))))) ((l)))))\""], ["", "definition normalizeQ :: \n  \"(adr\\<^sub>i\\<^sub>p net, port) Combinators \\<Rightarrow> \n   (adr\\<^sub>i\\<^sub>p net, port) Combinators list\" \nwhere\n   \"normalizeQ p = (removeAllDuplicates (insertDenies (separate (qsort\n                   (removeShadowRules2 (remdups ((rm_MT_rules C) (insertDeny\n                  (removeShadowRules1 (policy2list p)))))) ((Nets_List p))))))\""], ["", "definition\n   \"normalize_manual_orderQ p l = removeAllDuplicates (insertDenies (separate\n    (qsort (removeShadowRules2 (remdups ((rm_MT_rules C) (insertDeny\n    (removeShadowRules1 (policy2list p)))))) ((l)))))\""], ["", "text\\<open>\n  Of course, normalize is equal to normalize', the latter looks nicer though. \n\\<close>"], ["", "lemma \"normalize = normalize'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.normalize = normalize'", "by (rule ext, simp add: normalize_def normalize'_def sort'_def)"], ["", "declare C.simps [simp del]"], ["", "subsubsection\\<open>TCP\\_UDP\\_IntegerPort\\<close>"], ["", "fun Cp :: \"(adr\\<^sub>i\\<^sub>p\\<^sub>p net, protocol \\<times> port) Combinators \\<Rightarrow> \n          (adr\\<^sub>i\\<^sub>p\\<^sub>p,DummyContent) packet \\<mapsto> unit\"\nwhere\n \" Cp DenyAll = deny_all\"  \n|\"Cp (DenyAllFromTo x y) = deny_all_from_to x y\"\n|\"Cp (AllowPortFromTo x y p) = allow_from_to_port_prot (fst p) (snd p) x y\"\n|\"Cp  (x \\<oplus> y) =  Cp x ++ Cp y\""], ["", "fun Dp :: \"(adr\\<^sub>i\\<^sub>p\\<^sub>p net, protocol \\<times> port) Combinators \\<Rightarrow> \n          (adr\\<^sub>i\\<^sub>p\\<^sub>p,DummyContent) packet \\<mapsto> unit\"\nwhere\n\" Dp DenyAll = Cp DenyAll\" \n|\"Dp (DenyAllFromTo x y) = Cp (DenyAllFromTo x y)\"\n|\"Dp (AllowPortFromTo x y p) = Cp (AllowPortFromTo x y p)\"\n|\"Dp  (x \\<oplus> y) =  Cp (y \\<oplus> x)\""], ["", "text\\<open>\n  All rules appearing at the left of a DenyAllFromTo, have disjunct domains from it \n  (except DenyAll). \n\\<close>"], ["", "fun (sequential) wellformed_policy2Pr where\n  \"wellformed_policy2Pr [] = True\"\n| \"wellformed_policy2Pr (DenyAll#xs) = wellformed_policy2Pr xs\"\n| \"wellformed_policy2Pr (x#xs) = ((\\<forall> c a b. c = DenyAllFromTo a b \\<and> c \\<in> set xs \\<longrightarrow>\n                 Map.dom (Cp x) \\<inter> Map.dom (Cp c) = {}) \\<and> wellformed_policy2Pr xs)\""], ["", "text\\<open>\n  An allow rule is disjunct with all rules appearing at the right of it. This invariant is not\n  necessary as it is a consequence from others, but facilitates some proofs. \n\\<close>"], ["", "fun (sequential) wellformed_policy3Pr::\"((adr\\<^sub>i\\<^sub>p\\<^sub>p net, protocol \\<times> port) Combinators) list \\<Rightarrow> bool\" where\n  \"wellformed_policy3Pr [] = True\"\n| \"wellformed_policy3Pr ((AllowPortFromTo a b p)#xs) = ((\\<forall> r. r \\<in> set xs \\<longrightarrow>\n      dom (Cp r) \\<inter> dom (Cp (AllowPortFromTo a b p)) = {}) \\<and> wellformed_policy3Pr xs)\"\n| \"wellformed_policy3Pr (x#xs) = wellformed_policy3Pr xs\""], ["", "definition \n normalizePr' :: \"(adr\\<^sub>i\\<^sub>p\\<^sub>p net, protocol \\<times> port) Combinators\n  \\<Rightarrow> (adr\\<^sub>i\\<^sub>p\\<^sub>p net, protocol \\<times> port) Combinators list\" where \n \"normalizePr' p = (removeAllDuplicates o insertDenies o separate o\n                   (sort' (Nets_List p))  o removeShadowRules2 o remdups o\n                   (rm_MT_rules Cp) o insertDeny o removeShadowRules1 o\n                   policy2list) p\""], ["", "definition normalizePr :: \n\"(adr\\<^sub>i\\<^sub>p\\<^sub>p net, protocol \\<times> port) Combinators\n  \\<Rightarrow> (adr\\<^sub>i\\<^sub>p\\<^sub>p net, protocol \\<times> port) Combinators list\" where\n   \"normalizePr p = (removeAllDuplicates (insertDenies (separate (sort\n                   (removeShadowRules2 (remdups ((rm_MT_rules Cp) (insertDeny\n                  (removeShadowRules1 (policy2list p)))))) ((Nets_List p))))))\""], ["", "definition\n   \"normalize_manual_orderPr p l = removeAllDuplicates (insertDenies (separate\n    (sort (removeShadowRules2 (remdups ((rm_MT_rules Cp) (insertDeny\n    (removeShadowRules1 (policy2list p)))))) ((l)))))\""], ["", "definition \n normalizePrQ' :: \"(adr\\<^sub>i\\<^sub>p\\<^sub>p net, protocol \\<times> port) Combinators\n  \\<Rightarrow> (adr\\<^sub>i\\<^sub>p\\<^sub>p net, protocol \\<times> port) Combinators list\" where \n \"normalizePrQ' p = (removeAllDuplicates o insertDenies o separate o\n                   (qsort' (Nets_List p))  o removeShadowRules2 o remdups o\n                   (rm_MT_rules Cp) o insertDeny o removeShadowRules1 o\n                   policy2list) p\""], ["", "definition normalizePrQ :: \n\"(adr\\<^sub>i\\<^sub>p\\<^sub>p net, protocol \\<times> port) Combinators\n  \\<Rightarrow> (adr\\<^sub>i\\<^sub>p\\<^sub>p net, protocol \\<times> port) Combinators list\" where\n   \"normalizePrQ p = (removeAllDuplicates (insertDenies (separate (qsort\n                   (removeShadowRules2 (remdups ((rm_MT_rules Cp) (insertDeny\n                  (removeShadowRules1 (policy2list p)))))) ((Nets_List p))))))\""], ["", "definition\n   \"normalize_manual_orderPrQ p l = removeAllDuplicates (insertDenies (separate\n    (qsort (removeShadowRules2 (remdups ((rm_MT_rules Cp) (insertDeny\n    (removeShadowRules1 (policy2list p)))))) ((l)))))\""], ["", "text\\<open>\n  Of course, normalize is equal to normalize', the latter looks nicer though. \n\\<close>"], ["", "lemma \"normalizePr = normalizePr'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalizePr = normalizePr'", "by (rule ext, simp add: normalizePr_def normalizePr'_def sort'_def)"], ["", "text\\<open>\n  The following definition helps in creating the test specification for the individual parts \n  of a normalized policy. \n\\<close>"], ["", "definition makeFUTPr where \n   \"makeFUTPr FUT p x n = \n     (packet_Nets x (fst (normBothNets (bothNets p)!n))  \n                     (snd(normBothNets (bothNets p)!n)) \\<longrightarrow> \n    FUT x = Cp ((normalizePr p)!Suc n) x)\""], ["", "declare Cp.simps [simp del]"], ["", "lemmas PLemmas = C.simps Cp.simps dom_def PolicyCombinators.PolicyCombinators\n                 PortCombinators.PortCombinatorsCore aux\n                 ProtocolPortCombinators.ProtocolCombinatorsCore src_def dest_def in_subnet_def\n                 adr\\<^sub>i\\<^sub>p\\<^sub>pLemmas adr\\<^sub>i\\<^sub>p\\<^sub>pLemmas"], ["", "lemma aux: \"\\<lbrakk>x \\<noteq> a; y\\<noteq>b; (x \\<noteq> y \\<and> x \\<noteq> b) \\<or>  (a \\<noteq> b \\<and> a \\<noteq> y)\\<rbrakk> \\<Longrightarrow> {x,a} \\<noteq> {y,b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> a; y \\<noteq> b;\n     x \\<noteq> y \\<and> x \\<noteq> b \\<or>\n     a \\<noteq> b \\<and> a \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> {x, a} \\<noteq> {y, b}", "by (auto)"], ["", "lemma aux2: \"{a,b} = {b,a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a, b} = {b, a}", "by auto"], ["", "end"]]}