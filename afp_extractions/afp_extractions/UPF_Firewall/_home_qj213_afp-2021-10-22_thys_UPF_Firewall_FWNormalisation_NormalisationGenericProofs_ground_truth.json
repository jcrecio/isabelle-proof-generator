{"file_name": "/home/qj213/afp-2021-10-22/thys/UPF_Firewall/FWNormalisation/NormalisationGenericProofs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UPF_Firewall", "problem_names": ["lemma domNMT: \"dom X \\<noteq> {} \\<Longrightarrow> X \\<noteq> \\<emptyset>\"", "lemma denyNMT: \"deny_all \\<noteq>  \\<emptyset>\"", "lemma wellformed_policy1_charn[rule_format]: \n\"wellformed_policy1 p \\<longrightarrow> DenyAll \\<in> set p \\<longrightarrow> (\\<exists> p'. p = DenyAll # p' \\<and> DenyAll \\<notin> set p')\"", "lemma singleCombinatorsConc: \"singleCombinators (x#xs) \\<Longrightarrow> singleCombinators xs\"", "lemma aux0_0: \"singleCombinators x \\<Longrightarrow> \\<not> (\\<exists> a b. (a\\<oplus>b) \\<in> set x)\"", "lemma aux0_4: \"(a \\<in> set x \\<or> a \\<in> set y) = (a \\<in> set (x@y))\"", "lemma aux0_1: \"\\<lbrakk>singleCombinators xs; singleCombinators [x]\\<rbrakk> \\<Longrightarrow>\n               singleCombinators (x#xs)\"", "lemma aux0_6: \"\\<lbrakk>singleCombinators xs; \\<not> (\\<exists> a b. x = a \\<oplus> b)\\<rbrakk> \\<Longrightarrow>\n               singleCombinators(x#xs)\"", "lemma aux0_5: \" \\<not> (\\<exists> a b. (a\\<oplus>b) \\<in> set x) \\<Longrightarrow> singleCombinators x\"", "lemma ANDConc[rule_format]: \"allNetsDistinct (a#p) \\<longrightarrow> allNetsDistinct (p)\"", "lemma aux6: \"twoNetsDistinct a1 a2 a b \\<Longrightarrow>\n            dom (deny_all_from_to a1 a2) \\<inter> dom (deny_all_from_to a b) = {}\"", "lemma aux5[rule_format]: \"(DenyAllFromTo a b) \\<in> set p \\<longrightarrow> a \\<in> set (net_list p)\"", "lemma aux5a[rule_format]: \"(DenyAllFromTo b a) \\<in> set p \\<longrightarrow> a \\<in> set (net_list p)\"", "lemma aux5c[rule_format]:\n  \"(AllowPortFromTo a b po) \\<in> set p \\<longrightarrow> a \\<in> set (net_list p)\"", "lemma aux5d[rule_format]:\n  \"(AllowPortFromTo b a po) \\<in> set p \\<longrightarrow> a \\<in> set (net_list p)\"", "lemma aux10[rule_format]: \"a \\<in> set (net_list p) \\<longrightarrow> a \\<in> set (net_list_aux p)\"", "lemma srcInNetListaux[simp]: \n  \"\\<lbrakk>x \\<in> set p; singleCombinators[x]; x \\<noteq> DenyAll\\<rbrakk> \\<Longrightarrow> srcNet x \\<in> set (net_list_aux p)\"", "lemma destInNetListaux[simp]: \n  \"\\<lbrakk>x \\<in> set p; singleCombinators[x]; x \\<noteq> DenyAll\\<rbrakk> \\<Longrightarrow> destNet x \\<in> set (net_list_aux p)\"", "lemma tND1: \"\\<lbrakk>allNetsDistinct p; x \\<in> set p; y \\<in> set p; a = srcNet x;\n             b = destNet x; c = srcNet y; d = destNet y; a \\<noteq> c;\n             singleCombinators[x]; x \\<noteq> DenyAll; singleCombinators[y];\n             y \\<noteq> DenyAll\\<rbrakk> \\<Longrightarrow> twoNetsDistinct a b c d\"", "lemma tND2: \"\\<lbrakk>allNetsDistinct p; x \\<in> set p; y \\<in> set p; a = srcNet x;\n             b = destNet x; c = srcNet y; d = destNet y; b \\<noteq> d;\n             singleCombinators[x]; x \\<noteq> DenyAll; singleCombinators[y];\n             y \\<noteq> DenyAll\\<rbrakk> \\<Longrightarrow> twoNetsDistinct a b c d\"", "lemma tND: \"\\<lbrakk>allNetsDistinct p; x \\<in> set p; y \\<in> set p; a = srcNet x;\n            b = destNet x; c = srcNet y; d = destNet y; a \\<noteq> c \\<or> b \\<noteq> d;\n            singleCombinators[x]; x \\<noteq> DenyAll; singleCombinators[y]; y \\<noteq> DenyAll\\<rbrakk>\n            \\<Longrightarrow> twoNetsDistinct a b c d\"", "lemma aux7: \"\\<lbrakk>DenyAllFromTo a b \\<in> set p; allNetsDistinct ((DenyAllFromTo c d)#p);\n             a\\<noteq> c\\<or> b\\<noteq> d\\<rbrakk> \\<Longrightarrow> twoNetsDistinct a b c d\"", "lemma aux7a: \"\\<lbrakk>DenyAllFromTo a b  \\<in> set p;\n              allNetsDistinct ((AllowPortFromTo c d po)#p); a \\<noteq> c\\<or> b \\<noteq> d\\<rbrakk> \\<Longrightarrow> \n              twoNetsDistinct a b c d\"", "lemma nDComm: assumes ab: \"netsDistinct a b\" shows ba: \"netsDistinct b a\"", "lemma tNDComm: \n  assumes abcd: \"twoNetsDistinct a b c d\" shows \"twoNetsDistinct c d a b\"", "lemma aux[rule_format]: \"a \\<in> set (removeShadowRules2 p) \\<longrightarrow> a \\<in> set p\"", "lemma aux12: \"\\<lbrakk>a \\<in> x; b \\<notin> x\\<rbrakk> \\<Longrightarrow> a \\<noteq> b\"", "lemma ND0aux1[rule_format]: \"DenyAllFromTo x y \\<in> set b \\<Longrightarrow>  \n                             x \\<in> set (net_list_aux b)\"", "lemma ND0aux2[rule_format]: \"DenyAllFromTo x y \\<in> set b \\<Longrightarrow>  \n                             y \\<in> set (net_list_aux b)\"", "lemma ND0aux3[rule_format]: \"AllowPortFromTo x y p \\<in> set b \\<Longrightarrow>  \n                             x \\<in> set (net_list_aux b)\"", "lemma ND0aux4[rule_format]: \"AllowPortFromTo x y p \\<in> set b \\<Longrightarrow>  \n                             y \\<in> set (net_list_aux b)\"", "lemma aNDSubsetaux[rule_format]: \"singleCombinators a  \\<longrightarrow> set a \\<subseteq> set b \\<longrightarrow> \n                                  set (net_list_aux a) \\<subseteq> set (net_list_aux b)\"", "lemma aNDSetsEqaux[rule_format]: \"singleCombinators a \\<longrightarrow> singleCombinators b \\<longrightarrow> \n                 set a = set b \\<longrightarrow> set (net_list_aux a) = set (net_list_aux b)\"", "lemma aNDSubset: \"\\<lbrakk>singleCombinators a;set a \\<subseteq> set b; allNetsDistinct b\\<rbrakk> \\<Longrightarrow> \n                  allNetsDistinct a\"", "lemma aNDSetsEq: \"\\<lbrakk>singleCombinators a; singleCombinators b; set a = set b; \n                  allNetsDistinct b\\<rbrakk> \\<Longrightarrow> allNetsDistinct a\"", "lemma SCConca: \"\\<lbrakk>singleCombinators p; singleCombinators [a]\\<rbrakk> \\<Longrightarrow> \n                singleCombinators (a#p)\"", "lemma aux3[simp]: \"\\<lbrakk>singleCombinators p; singleCombinators [a];  \n                     allNetsDistinct (a#p)\\<rbrakk> \\<Longrightarrow> allNetsDistinct (a#a#p)\"", "lemma wp1_aux1a[rule_format]: \"xs \\<noteq> [] \\<longrightarrow> wellformed_policy1_strong (xs @ [x]) \\<longrightarrow> \n                               wellformed_policy1_strong xs\"", "lemma wp1alternative_RS1[rule_format]: \"DenyAll \\<in> set p \\<longrightarrow> \n                              wellformed_policy1_strong (removeShadowRules1 p)\"", "lemma wellformed_eq: \"DenyAll \\<in> set p \\<longrightarrow> \n                      ((wellformed_policy1 p) = (wellformed_policy1_strong p))\"", "lemma set_insort: \"set(insort x xs l) = insert x (set xs)\"", "lemma set_sort[simp]: \"set(sort xs l) = set xs\"", "lemma set_sortQ: \"set(qsort xs l) = set xs\"", "lemma aux79[rule_format]: \"y \\<in> set (insort x a l) \\<longrightarrow>  y \\<noteq> x \\<longrightarrow> y \\<in> set a\"", "lemma aux80: \"\\<lbrakk>y \\<notin> set p; y \\<noteq> x\\<rbrakk> \\<Longrightarrow> y \\<notin> set (insort x (sort p l) l)\"", "lemma WP1Conca: \"DenyAll \\<notin> set p \\<Longrightarrow> wellformed_policy1 (a#p)\"", "lemma saux[simp]: \"(insort DenyAll p l) = DenyAll#p\"", "lemma saux3[rule_format]: \"DenyAllFromTo a b \\<in> set list \\<longrightarrow> \n                          DenyAllFromTo c d \\<notin> set list \\<longrightarrow> (a \\<noteq> c) \\<or> (b \\<noteq> d)\"", "lemma waux2[rule_format]: \" (DenyAll \\<notin> set xs) \\<longrightarrow> wellformed_policy1 xs\"", "lemma waux3[rule_format]: \"\\<lbrakk>x \\<noteq> a;  x \\<notin> set p\\<rbrakk> \\<Longrightarrow> x \\<notin> set (insort a p l)\"", "lemma wellformed1_sorted_aux[rule_format]: \"wellformed_policy1 (x#p) \\<Longrightarrow> \n                                            wellformed_policy1 (insort x p l)\"", "lemma wellformed1_sorted_auxQ[rule_format]: \"wellformed_policy1 (p) \\<Longrightarrow> \n                                            wellformed_policy1 (qsort p l)\"", "lemma SR1Subset: \"set (removeShadowRules1 p) \\<subseteq> set p\"", "lemma SCSubset[rule_format]: \" singleCombinators b \\<longrightarrow> set a \\<subseteq> set b \\<longrightarrow>\n                              singleCombinators a\"", "lemma setInsert[simp]: \"set list \\<subseteq> insert a (set list)\"", "lemma SC_RS1[rule_format,simp]: \"singleCombinators p \\<longrightarrow> allNetsDistinct p \\<longrightarrow>\n    singleCombinators (removeShadowRules1 p)\"", "lemma RS2Set[rule_format]: \"set (removeShadowRules2 p) \\<subseteq> set p\"", "lemma WP1: \"a \\<notin> set list \\<Longrightarrow> a \\<notin> set (removeShadowRules2 list)\"", "lemma denyAllDom[simp]: \"x \\<in> dom (deny_all)\"", "lemma lCdom2: \"(list2FWpolicy (a @ (b @ c))) = (list2FWpolicy ((a@b)@c))\"", "lemma SCConcEnd: \"singleCombinators (xs @ [xa]) \\<Longrightarrow> singleCombinators xs\"", "lemma list2FWpolicyconc[rule_format]: \"a \\<noteq> [] \\<longrightarrow>\n                               (list2FWpolicy (xa # a)) = (xa) \\<oplus> (list2FWpolicy a)\"", "lemma wp1n_tl [rule_format]: \"wellformed_policy1_strong p \\<longrightarrow>\n                              p = (DenyAll#(tl p))\"", "lemma foo2: \"a \\<notin> set ps \\<Longrightarrow> \n             a \\<notin> set ss \\<Longrightarrow>\n             set p = set s \\<Longrightarrow> \n             p = (a#(ps)) \\<Longrightarrow> \n             s = (a#ss) \\<Longrightarrow> \n             set (ps) = set (ss)\"", "lemma SCnotConc[rule_format,simp]: \"a\\<oplus>b \\<in> set p \\<longrightarrow> singleCombinators p \\<longrightarrow>False\"", "lemma auxx8: \"removeShadowRules1_alternative_rev [x] = [x]\"", "lemma RS1End[rule_format]: \"x \\<noteq> DenyAll \\<longrightarrow> removeShadowRules1 (xs @ [x]) = \n                            (removeShadowRules1 xs)@[x]\"", "lemma aux114: \"x \\<noteq> DenyAll \\<Longrightarrow> removeShadowRules1_alternative_rev (x#xs) = \n               x#(removeShadowRules1_alternative_rev xs)\"", "lemma aux115[rule_format]: \"x \\<noteq> DenyAll\\<Longrightarrow>removeShadowRules1_alternative (xs@[x]) \n                            = (removeShadowRules1_alternative xs)@[x]\"", "lemma RS1_DA[simp]: \"removeShadowRules1 (xs @ [DenyAll]) = [DenyAll]\"", "lemma rSR1_eq: \"removeShadowRules1_alternative = removeShadowRules1\"", "lemma domInterMT[rule_format]: \"\\<lbrakk>dom a \\<inter> dom b = {}; x \\<in> dom a\\<rbrakk> \\<Longrightarrow> x \\<notin> dom b\"", "lemma domComm: \"dom a \\<inter> dom b = dom b \\<inter> dom a\"", "lemma r_not_DA_in_tl[rule_format]: \n  \"wellformed_policy1_strong p \\<longrightarrow>  a \\<in> set p\\<longrightarrow> a \\<noteq> DenyAll \\<longrightarrow> a \\<in> set (tl p)\"", "lemma wp1_aux1aa[rule_format]: \"wellformed_policy1_strong p \\<longrightarrow> DenyAll \\<in> set p\"", "lemma mauxa: \"(\\<exists> r. a b = \\<lfloor>r\\<rfloor>) = (a b \\<noteq> \\<bottom>)\"", "lemma l2p_aux[rule_format]: \"list \\<noteq> [] \\<longrightarrow>\n                             list2FWpolicy (a # list) = a \\<oplus>(list2FWpolicy list)\"", "lemma l2p_aux2[rule_format]: \"list = [] \\<Longrightarrow> list2FWpolicy (a # list) = a\"", "lemma aux7aa: \n  assumes 1 : \"AllowPortFromTo a b poo \\<in> set p\" \n    and    2 : \"allNetsDistinct ((AllowPortFromTo c d po) # p)\"\n    and    3 : \"a \\<noteq> c \\<or> b \\<noteq> d\"\n  shows       \"twoNetsDistinct a b c d\" (is \"?H\")", "lemma ANDConcEnd: \"\\<lbrakk> allNetsDistinct (xs @ [xa]); singleCombinators xs\\<rbrakk> \\<Longrightarrow> \n                   allNetsDistinct xs\"", "lemma WP1ConcEnd[rule_format]: \n  \"wellformed_policy1 (xs@[xa]) \\<longrightarrow> wellformed_policy1 xs\"", "lemma NDComm: \"netsDistinct a b = netsDistinct b a\"", "lemma wellformed1_sorted[simp]: \n  assumes wp1: \"wellformed_policy1 p\" \n  shows        \"wellformed_policy1 (sort p l)\"", "lemma wellformed1_sortedQ[simp]: \n  assumes wp1: \"wellformed_policy1 p\" \n  shows        \"wellformed_policy1 (qsort p l)\"", "lemma SC1[simp]: \"singleCombinators p \\<Longrightarrow>singleCombinators (removeShadowRules1 p)\"", "lemma SC2[simp]: \"singleCombinators p \\<Longrightarrow>singleCombinators (removeShadowRules2 p)\"", "lemma SC3[simp]: \"singleCombinators p \\<Longrightarrow> singleCombinators (sort p l)\"", "lemma SC3Q[simp]: \"singleCombinators p \\<Longrightarrow> singleCombinators (qsort p l)\"", "lemma aND_RS1[simp]: \"\\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk> \\<Longrightarrow> \n                      allNetsDistinct (removeShadowRules1 p)\"", "lemma aND_RS2[simp]: \"\\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk> \\<Longrightarrow> \n                      allNetsDistinct (removeShadowRules2 p)\"", "lemma aND_sort[simp]: \"\\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk> \\<Longrightarrow>  \n                       allNetsDistinct (sort p l)\"", "lemma aND_sortQ[simp]: \"\\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk> \\<Longrightarrow>  \n                       allNetsDistinct (qsort p l)\"", "lemma inRS2[rule_format,simp]: \"x \\<notin> set p \\<longrightarrow> x \\<notin> set (removeShadowRules2 p)\"", "lemma distinct_RS2[rule_format,simp]: \"distinct p \\<longrightarrow> \n                                       distinct (removeShadowRules2 p)\"", "lemma setPaireq: \" {x, y} = {a, b} \\<Longrightarrow> x = a \\<and> y = b \\<or> x = b \\<and> y = a\"", "lemma position_positive[rule_format]: \"a \\<in> set l \\<longrightarrow> position a l > 0\"", "lemma pos_noteq[rule_format]: \n  \"a \\<in> set l \\<longrightarrow> b \\<in> set l \\<longrightarrow> c \\<in> set l \\<longrightarrow> \n   a \\<noteq> b \\<longrightarrow> position a l \\<le> position b l \\<longrightarrow> position b l \\<le> position c l \\<longrightarrow> \n   a \\<noteq> c\"", "lemma setPair_noteq: \"{a,b} \\<noteq> {c,d} \\<Longrightarrow> \\<not> ((a = c) \\<and> (b = d))\"", "lemma setPair_noteq_allow: \"{a,b} \\<noteq> {c,d} \\<Longrightarrow> \\<not> ((a = c) \\<and> (b = d) \\<and> P)\"", "lemma order_trans:  \n  \"\\<lbrakk>in_list x l; in_list y l; in_list z l; singleCombinators [x]; \n  singleCombinators [y]; singleCombinators [z]; smaller x y l; smaller y z l\\<rbrakk> \\<Longrightarrow> \n  smaller x z l\"", "lemma sortedConcStart[rule_format]: \n  \"sorted (a # aa # p) l \\<longrightarrow> in_list a l \\<longrightarrow> in_list aa l \\<longrightarrow> all_in_list p l\\<longrightarrow> \n  singleCombinators [a] \\<longrightarrow> singleCombinators [aa] \\<longrightarrow> singleCombinators p \\<longrightarrow> \n  sorted (a#p) l\"", "lemma singleCombinatorsStart[simp]: \"singleCombinators (x#xs) \\<Longrightarrow> \n                                     singleCombinators [x]\"", "lemma sorted_is_smaller[rule_format]: \n  \"sorted (a # p) l \\<longrightarrow> in_list a l \\<longrightarrow> in_list b l \\<longrightarrow> all_in_list p l \\<longrightarrow>  \n  singleCombinators [a] \\<longrightarrow> singleCombinators p \\<longrightarrow> b \\<in> set p \\<longrightarrow> smaller a b l\"", "lemma sortedConcEnd[rule_format]: \"sorted (a # p) l \\<longrightarrow> in_list a l \\<longrightarrow> \n                                   all_in_list p l \\<longrightarrow> singleCombinators [a] \\<longrightarrow> \n                                   singleCombinators p  \\<longrightarrow> sorted p l\"", "lemma in_set_in_list[rule_format]: \"a \\<in> set p \\<longrightarrow> all_in_list p l\\<longrightarrow> in_list a l\"", "lemma sorted_Consb[rule_format]: \n  \"all_in_list (x#xs) l \\<longrightarrow> singleCombinators (x#xs) \\<longrightarrow> \n    (sorted xs l & (\\<forall>y\\<in>set xs. smaller x y l)) \\<longrightarrow>  (sorted (x#xs) l) \"", "lemma sorted_Cons: \"\\<lbrakk>all_in_list (x#xs) l; singleCombinators (x#xs)\\<rbrakk> \\<Longrightarrow> \n              (sorted xs l & (\\<forall>y\\<in>set xs. smaller x y l)) =  (sorted (x#xs) l)\"", "lemma smaller_antisym: \"\\<lbrakk>\\<not> smaller a b l; in_list a l; in_list b l; \n                        singleCombinators[a]; singleCombinators [b]\\<rbrakk> \\<Longrightarrow>  \n                        smaller b a l\"", "lemma set_insort_insert: \"set (insort x xs l) \\<subseteq> insert x (set xs)\"", "lemma all_in_listSubset[rule_format]: \"all_in_list b l \\<longrightarrow>singleCombinators a \\<longrightarrow> \n                                      set a \\<subseteq> set b \\<longrightarrow> all_in_list a l\"", "lemma singleCombinators_insort: \"\\<lbrakk>singleCombinators [x]; singleCombinators xs\\<rbrakk> \\<Longrightarrow> \n                                 singleCombinators (insort x xs l)\"", "lemma all_in_list_insort: \"\\<lbrakk>all_in_list xs l; singleCombinators (x#xs); \n                           in_list x l\\<rbrakk> \\<Longrightarrow>  all_in_list (insort x xs l) l\"", "lemma sorted_ConsA:\"\\<lbrakk>all_in_list (x#xs) l; singleCombinators (x#xs)\\<rbrakk> \\<Longrightarrow> \n              (sorted (x#xs) l)  = (sorted xs l & (\\<forall>y\\<in>set xs. smaller x y l))\"", "lemma is_in_insort: \"y \\<in> set xs \\<Longrightarrow> y \\<in> set (insort x xs l)\"", "lemma sorted_insorta[rule_format]:\n  assumes 1 : \"sorted (insort x xs l) l\"\n    and   2 : \"all_in_list (x#xs) l\" \n    and   3 : \"all_in_list (x#xs) l\"\n    and   4 : \"distinct (x#xs)\"\n    and   5 : \"singleCombinators [x]\"\n    and   6 : \"singleCombinators xs\"\n  shows       \"sorted xs l\"", "lemma sorted_insortb[rule_format]: \n  \"sorted xs l \\<longrightarrow> all_in_list (x#xs) l \\<longrightarrow> distinct (x#xs) \\<longrightarrow> \n   singleCombinators [x] \\<longrightarrow> singleCombinators xs \\<longrightarrow> sorted (insort x xs l) l\"", "lemma sorted_insort: \n  \"\\<lbrakk>all_in_list (x#xs) l; distinct(x#xs); singleCombinators [x];\n                     singleCombinators xs\\<rbrakk> \\<Longrightarrow>\n                  sorted (insort x xs l) l = sorted xs l\"", "lemma distinct_insort: \"distinct (insort x xs l) = (x \\<notin> set xs \\<and> distinct xs)\"", "lemma distinct_sort[simp]: \"distinct (sort xs l) = distinct xs\"", "lemma sort_is_sorted[rule_format]: \n  \"all_in_list p l \\<longrightarrow> distinct p \\<longrightarrow> singleCombinators p \\<longrightarrow> sorted (sort p l) l\"", "lemma smaller_sym[rule_format]: \"all_in_list [a] l \\<longrightarrow> smaller a a l\"", "lemma SC_sublist[rule_format]: \n  \"singleCombinators xs \\<Longrightarrow> singleCombinators (qsort [y\\<leftarrow>xs. P y] l)\"", "lemma all_in_list_sublist[rule_format]: \n  \"singleCombinators xs \\<longrightarrow> all_in_list xs l \\<longrightarrow> all_in_list (qsort [y\\<leftarrow>xs. P y] l) l\"", "lemma SC_sublist2[rule_format]: \n  \"singleCombinators xs \\<longrightarrow> singleCombinators ([y\\<leftarrow>xs. P y])\"", "lemma all_in_list_sublist2[rule_format]: \n  \"singleCombinators xs \\<longrightarrow> all_in_list xs l \\<longrightarrow> all_in_list ( [y\\<leftarrow>xs. P y]) l\"", "lemma all_in_listAppend[rule_format]: \n  \"all_in_list (xs) l \\<longrightarrow> all_in_list (ys) l \\<longrightarrow> all_in_list (xs @ ys) l\"", "lemma distinct_sortQ[rule_format]: \n  \"singleCombinators xs \\<longrightarrow> all_in_list xs l \\<longrightarrow> distinct xs \\<longrightarrow> distinct (qsort xs l)\"", "lemma singleCombinatorsAppend[rule_format]: \n  \"singleCombinators (xs) \\<longrightarrow> singleCombinators (ys) \\<longrightarrow> singleCombinators (xs @ ys)\"", "lemma sorted_append1[rule_format]:\n  \"all_in_list xs l  \\<longrightarrow> singleCombinators xs \\<longrightarrow>\n   all_in_list ys l  \\<longrightarrow> singleCombinators ys \\<longrightarrow> \n  (sorted (xs@ys) l \\<longrightarrow> \n  (sorted xs l & sorted ys l & (\\<forall>x \\<in> set xs. \\<forall>y \\<in> set ys. smaller x y l)))\"", "lemma sorted_append2[rule_format]:\n  \"all_in_list xs l\\<longrightarrow> singleCombinators xs \\<longrightarrow>\n   all_in_list ys l \\<longrightarrow> singleCombinators ys \\<longrightarrow> \n   (sorted xs l & sorted ys l & (\\<forall>x \\<in> set xs. \\<forall>y \\<in> set ys. smaller x y l)) \\<longrightarrow> \n  (sorted (xs@ys) l)\"", "lemma sorted_append[rule_format]:\n  \"all_in_list xs l \\<longrightarrow> singleCombinators xs \\<longrightarrow>\n   all_in_list ys l \\<longrightarrow> singleCombinators ys \\<longrightarrow> \n   (sorted (xs@ys) l) =\n   (sorted xs l & sorted ys l & (\\<forall>x \\<in> set xs. \\<forall>y \\<in> set ys. smaller x y l))\"", "lemma sort_is_sortedQ[rule_format]: \n  \"all_in_list p l  \\<longrightarrow> singleCombinators p \\<longrightarrow> sorted (qsort p l) l\"", "lemma inSet_not_MT: \"a \\<in> set p \\<Longrightarrow> p \\<noteq> []\"", "lemma RS1n_assoc: \n  \"x \\<noteq> DenyAll \\<Longrightarrow>  removeShadowRules1_alternative xs @ [x] =\n                  removeShadowRules1_alternative (xs @ [x])\"", "lemma RS1n_nMT[rule_format,simp]: \"p \\<noteq> []\\<longrightarrow> removeShadowRules1_alternative p \\<noteq> []\"", "lemma RS1N_DA[simp]: \"removeShadowRules1_alternative (a@[DenyAll]) = [DenyAll]\"", "lemma WP1n_DA_notinSet[rule_format]: \"wellformed_policy1_strong p \\<longrightarrow>\n                                     DenyAll \\<notin> set (tl p)\"", "lemma mt_sym: \"dom a \\<inter> dom b = {} \\<Longrightarrow> dom b \\<inter> dom a = {}\"", "lemma DAnotTL[rule_format]: \n  \"xs \\<noteq> [] \\<longrightarrow> wellformed_policy1 (xs @ [DenyAll]) \\<longrightarrow> False\"", "lemma AND_tl[rule_format]: \"allNetsDistinct ( p) \\<longrightarrow> allNetsDistinct (tl p)\"", "lemma distinct_tl[rule_format]: \"distinct p \\<longrightarrow> distinct (tl p)\"", "lemma SC_tl[rule_format]: \"singleCombinators ( p) \\<longrightarrow> singleCombinators (tl p)\"", "lemma Conc_not_MT: \"p = x#xs \\<Longrightarrow> p \\<noteq> []\"", "lemma wp1_tl[rule_format]: \n  \"p \\<noteq> [] \\<and> wellformed_policy1 p \\<longrightarrow> wellformed_policy1 (tl p)\"", "lemma wp1_eq[rule_format]: \n  \"wellformed_policy1_strong p \\<Longrightarrow> wellformed_policy1 p\"", "lemma wellformed1_alternative_sorted: \n  \"wellformed_policy1_strong p \\<Longrightarrow> wellformed_policy1_strong (sort p l)\"", "lemma wp1n_RS2[rule_format]: \n  \"wellformed_policy1_strong p \\<longrightarrow> wellformed_policy1_strong (removeShadowRules2 p)\"", "lemma RS2_NMT[rule_format]: \"p \\<noteq> [] \\<longrightarrow> removeShadowRules2 p \\<noteq> []\"", "lemma wp1_alternative_not_mt[simp]: \"wellformed_policy1_strong p \\<Longrightarrow> p \\<noteq> []\"", "lemma AIL1[rule_format,simp]: \"all_in_list p l \\<longrightarrow>\n                               all_in_list (removeShadowRules1 p) l\"", "lemma wp1ID: \"wellformed_policy1_strong (insertDeny (removeShadowRules1 p))\"", "lemma dRD[simp]: \"distinct (remdups p)\"", "lemma AILrd[rule_format,simp]: \"all_in_list p l \\<longrightarrow> all_in_list (remdups p) l\"", "lemma AILiD[rule_format,simp]: \"all_in_list p l \\<longrightarrow> all_in_list (insertDeny p) l\"", "lemma SCrd[rule_format,simp]:\"singleCombinators p\\<longrightarrow> singleCombinators(remdups p)\"", "lemma SCRiD[rule_format,simp]: \"singleCombinators p \\<longrightarrow>\n                                singleCombinators(insertDeny p)\"", "lemma WP1rd[rule_format,simp]: \n  \"wellformed_policy1_strong p \\<longrightarrow> wellformed_policy1_strong (remdups p)\"", "lemma ANDrd[rule_format,simp]: \n  \"singleCombinators p \\<longrightarrow> allNetsDistinct p \\<longrightarrow> allNetsDistinct (remdups p)\"", "lemma ANDiD[rule_format,simp]: \n  \"allNetsDistinct p \\<longrightarrow>  allNetsDistinct (insertDeny p)\"", "lemma mr_iD[rule_format]: \n  \"wellformed_policy1_strong p  \\<longrightarrow> matching_rule x p = matching_rule x (insertDeny p)\"", "lemma WP1iD[rule_format,simp]: \"wellformed_policy1_strong p \\<longrightarrow>\n                                wellformed_policy1_strong (insertDeny p)\"", "lemma DAiniD: \"DenyAll \\<in> set (insertDeny p)\"", "lemma p2lNmt: \"policy2list p \\<noteq> []\"", "lemma AIL2[rule_format,simp]: \n  \"all_in_list p l \\<longrightarrow> all_in_list (removeShadowRules2 p) l\"", "lemma SCConc: \"singleCombinators x \\<Longrightarrow>  singleCombinators y \\<Longrightarrow> singleCombinators (x@y)\"", "lemma SCp2l: \"singleCombinators (policy2list p)\"", "lemma subnetAux: \"Dd \\<inter> A \\<noteq> {} \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow>  Dd \\<inter> B \\<noteq> {}\"", "lemma soadisj: \"x \\<in> subnetsOfAdr a \\<Longrightarrow> y \\<in> subnetsOfAdr a \\<Longrightarrow> \\<not> netsDistinct x y\"", "lemma not_member: \"\\<not> member a (x\\<oplus>y) \\<Longrightarrow> \\<not> member a x\"", "lemma soadisj2: \"(\\<forall> a x y. x \\<in> subnetsOfAdr a \\<and> y \\<in> subnetsOfAdr a \\<longrightarrow> \\<not> netsDistinct x y)\"", "lemma ndFalse1: \n  \"(\\<forall>a b c d. (a,b)\\<in>A  \\<and> (c,d)\\<in>B \\<longrightarrow> netsDistinct a c) \\<Longrightarrow>\n   \\<exists>(a, b)\\<in>A. a \\<in> subnetsOfAdr D \\<Longrightarrow> \n   \\<exists>(a, b)\\<in>B. a \\<in> subnetsOfAdr D \\<Longrightarrow> False\"", "lemma ndFalse2: \"(\\<forall>a b c d. (a,b)\\<in>A  \\<and> (c,d)\\<in>B \\<longrightarrow> netsDistinct b d) \\<Longrightarrow>\n                 \\<exists>(a, b)\\<in>A. b \\<in> subnetsOfAdr D \\<Longrightarrow>\n                 \\<exists>(a, b)\\<in>B. b \\<in> subnetsOfAdr D \\<Longrightarrow> False\"", "lemma tndFalse: \"(\\<forall>a b c d. (a,b)\\<in>A  \\<and> (c,d)\\<in>B \\<longrightarrow> twoNetsDistinct a b c d) \\<Longrightarrow>\n        \\<exists>(a, b)\\<in>A. a \\<in> subnetsOfAdr (D::('a::adr)) \\<and> b \\<in> subnetsOfAdr (F::'a) \\<Longrightarrow> \n        \\<exists>(a, b)\\<in>B. a \\<in> subnetsOfAdr D\\<and> b\\<in> subnetsOfAdr F \n    \\<Longrightarrow> False\"", "lemma sepnMT[rule_format]: \"p \\<noteq> [] \\<longrightarrow> (separate p) \\<noteq> []\"", "lemma sepDA[rule_format]: \"DenyAll \\<notin> set p \\<longrightarrow> DenyAll \\<notin> set (separate p)\"", "lemma setnMT: \"set a = set b \\<Longrightarrow> a \\<noteq> [] \\<Longrightarrow> b \\<noteq> []\"", "lemma sortnMT: \"p \\<noteq> [] \\<Longrightarrow> sort p l \\<noteq> []\"", "lemma idNMT[rule_format]: \"p \\<noteq> [] \\<longrightarrow> insertDenies p \\<noteq> []\"", "lemma OTNoTN[rule_format]: \" OnlyTwoNets p \\<longrightarrow> x \\<noteq> DenyAll \\<longrightarrow> x \\<in> set p \\<longrightarrow>  onlyTwoNets x\"", "lemma first_isIn[rule_format]:  \"\\<not> member DenyAll x \\<longrightarrow> (first_srcNet x,first_destNet x) \\<in> sdnets x\"", "lemma sdnets2: \n  \"\\<exists>a b. sdnets x = {(a, b), (b, a)} \\<Longrightarrow> \\<not> member DenyAll x \\<Longrightarrow>\n   sdnets x = {(first_srcNet x, first_destNet x),  (first_destNet x, first_srcNet x)}\"", "lemma alternativelistconc1[rule_format]: \n  \"a \\<in> set (net_list_aux [x]) \\<longrightarrow>  a \\<in> set (net_list_aux [x,y])\"", "lemma alternativelistconc2[rule_format]: \n  \"a \\<in> set (net_list_aux [x]) \\<longrightarrow> a \\<in> set (net_list_aux [y,x])\"", "lemma noDA[rule_format]:\n  \"noDenyAll xs \\<longrightarrow> s \\<in> set xs \\<longrightarrow> \\<not> member DenyAll s\"", "lemma isInAlternativeList:\n  \"(aa \\<in> set (net_list_aux [a]) \\<or> aa \\<in> set (net_list_aux p)) \\<Longrightarrow> aa \\<in> set (net_list_aux (a # p))\"", "lemma netlistaux: \n  \"x \\<in> set (net_list_aux (a # p))\\<Longrightarrow>  x \\<in> set (net_list_aux ([a])) \\<or> x \\<in> set (net_list_aux (p))\"", "lemma firstInNet[rule_format]: \n  \"\\<not> member DenyAll a \\<longrightarrow>  first_destNet a \\<in> set (net_list_aux (a # p))\"", "lemma firstInNeta[rule_format]: \n  \"\\<not> member DenyAll a \\<longrightarrow>  first_srcNet a \\<in> set (net_list_aux (a # p))\"", "lemma disjComm: \"disjSD_2 a b \\<Longrightarrow> disjSD_2 b a\"", "lemma disjSD2aux:\n  \"disjSD_2 a b \\<Longrightarrow> \\<not> member DenyAll a \\<Longrightarrow> \\<not> member DenyAll b \\<Longrightarrow>\n  disjSD_2 (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n            DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a)\n           b\"", "lemma noDA1eq[rule_format]: \"noDenyAll p \\<longrightarrow> noDenyAll1 p\"", "lemma noDA1C[rule_format]: \"noDenyAll1 (a#p) \\<longrightarrow> noDenyAll1 p\"", "lemma disjSD_2IDa: \n  \"disjSD_2 x y \\<Longrightarrow>\n   \\<not> member DenyAll x \\<Longrightarrow>\n   \\<not> member DenyAll y \\<Longrightarrow> \n   a = first_srcNet x \\<Longrightarrow> \n   b = first_destNet x \\<Longrightarrow> \n   disjSD_2 (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a \\<oplus> x) y\"", "lemma noDAID[rule_format]: \"noDenyAll p \\<longrightarrow> noDenyAll (insertDenies p)\"", "lemma isInIDo[rule_format]:  \n  \"noDenyAll p  \\<longrightarrow> s \\<in> set (insertDenies p) \\<longrightarrow> \n   (\\<exists>! a. s = (DenyAllFromTo (first_srcNet a) (first_destNet a)) \\<oplus>\n   (DenyAllFromTo (first_destNet a) (first_srcNet a)) \\<oplus> a \\<and> a \\<in> set p)\"", "lemma id_aux1[rule_format]: \"DenyAllFromTo (first_srcNet s) (first_destNet s) \\<oplus>\n      DenyAllFromTo (first_destNet s) (first_srcNet s) \\<oplus> s\\<in> set (insertDenies p)\n    \\<longrightarrow> s \\<in> set p\"", "lemma id_aux2:\n  \"noDenyAll p \\<Longrightarrow>\n   \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s \\<Longrightarrow>\n   \\<not> member DenyAll a \\<Longrightarrow>\n   DenyAllFromTo (first_srcNet s) (first_destNet s) \\<oplus> \n   DenyAllFromTo (first_destNet s) (first_srcNet s) \\<oplus> s \\<in> set (insertDenies p) \\<Longrightarrow>\n   disjSD_2 a (DenyAllFromTo (first_srcNet s) (first_destNet s) \\<oplus> \n   DenyAllFromTo (first_destNet s) (first_srcNet s) \\<oplus> s)\"", "lemma id_aux4[rule_format]: \n  \"noDenyAll p \\<Longrightarrow> \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s \\<Longrightarrow> \n   s \\<in> set (insertDenies p) \\<Longrightarrow> \\<not> member DenyAll a \\<Longrightarrow> \n   disjSD_2 a s\"", "lemma sepNetsID[rule_format]: \n  \"noDenyAll1 p \\<longrightarrow> separated p \\<longrightarrow> separated (insertDenies p)\"", "lemma aNDDA[rule_format]: \"allNetsDistinct p \\<longrightarrow> allNetsDistinct(DenyAll#p)\"", "lemma OTNConc[rule_format]: \"OnlyTwoNets (y # z) \\<longrightarrow>  OnlyTwoNets z\"", "lemma first_bothNetsd: \"\\<not> member DenyAll x \\<Longrightarrow> first_bothNet x = {first_srcNet x, first_destNet x}\"", "lemma bNaux:\n  \"\\<not> member DenyAll x \\<Longrightarrow> \\<not> member DenyAll y \\<Longrightarrow>\n   first_bothNet x = first_bothNet y \\<Longrightarrow>\n   {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y}\"", "lemma setPair: \"{a,b} = {a,d} \\<Longrightarrow> b = d\"", "lemma setPair1: \"{a,b} = {d,a} \\<Longrightarrow> b = d\"", "lemma setPair4: \"{a,b} = {c,d} \\<Longrightarrow> a \\<noteq> c \\<Longrightarrow> a = d\"", "lemma otnaux1: \" {x, y, x, y} = {x,y}\"", "lemma OTNIDaux4: \"{x,y,x} = {y,x}\"", "lemma setPair5: \"{a,b} = {c,d} \\<Longrightarrow> a \\<noteq> c \\<Longrightarrow> a = d\"", "lemma otnaux: \"   \n  \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x; \\<not> member DenyAll y; \n   onlyTwoNets y; onlyTwoNets x\\<rbrakk> \\<Longrightarrow> \n   onlyTwoNets (x \\<oplus> y)\"", "lemma OTNSepaux: \n  \"onlyTwoNets (a \\<oplus> y) \\<and> OnlyTwoNets z \\<longrightarrow> OnlyTwoNets (separate (a \\<oplus> y # z)) \\<Longrightarrow>\n    \\<not> member DenyAll a \\<Longrightarrow>  \\<not> member DenyAll y \\<Longrightarrow>\n    noDenyAll z \\<Longrightarrow> onlyTwoNets a \\<Longrightarrow> OnlyTwoNets (y # z) \\<Longrightarrow> first_bothNet a = first_bothNet y \\<Longrightarrow> \n    OnlyTwoNets (separate (a \\<oplus> y # z))\"", "lemma OTNSEp[rule_format]: \n  \"noDenyAll1 p \\<longrightarrow> OnlyTwoNets p  \\<longrightarrow>  OnlyTwoNets (separate p)\"", "lemma nda[rule_format]: \n  \"singleCombinators (a#p) \\<longrightarrow> noDenyAll p \\<longrightarrow> noDenyAll1 (a # p)\"", "lemma nDAcharn[rule_format]: \"noDenyAll p = (\\<forall> r \\<in> set p. \\<not> member DenyAll r)\"", "lemma nDAeqSet: \"set p = set s \\<Longrightarrow> noDenyAll p = noDenyAll s\"", "lemma nDASCaux[rule_format]: \n  \"DenyAll \\<notin> set p \\<longrightarrow> singleCombinators p \\<longrightarrow>  r \\<in> set p \\<longrightarrow>  \\<not> member DenyAll r\"", "lemma nDASC[rule_format]: \n  \"wellformed_policy1 p \\<longrightarrow> singleCombinators p \\<longrightarrow>  noDenyAll1 p\"", "lemma noDAAll[rule_format]: \"noDenyAll p = (\\<not> memberP DenyAll p)\"", "lemma memberPsep[symmetric]: \"memberP x p = memberP x (separate p)\"", "lemma noDAsep[rule_format]: \"noDenyAll p \\<Longrightarrow> noDenyAll (separate p)\"", "lemma noDA1sep[rule_format]: \"noDenyAll1 p \\<longrightarrow> noDenyAll1 (separate p)\"", "lemma isInAlternativeLista: \n  \"(aa \\<in> set (net_list_aux [a]))\\<Longrightarrow>  aa \\<in> set (net_list_aux (a # p))\"", "lemma isInAlternativeListb: \n  \"(aa \\<in> set (net_list_aux p))\\<Longrightarrow>  aa \\<in> set (net_list_aux (a # p))\"", "lemma ANDSepaux: \"allNetsDistinct (x # y # z) \\<Longrightarrow> allNetsDistinct (x \\<oplus> y # z)\"", "lemma netlistalternativeSeparateaux:\n  \"net_list_aux [y] @ net_list_aux z = net_list_aux (y # z)\"", "lemma netlistalternativeSeparate: \"net_list_aux p = net_list_aux (separate p)\"", "lemma  ANDSepaux2: \n  \"allNetsDistinct(x#y#z) \\<Longrightarrow> allNetsDistinct(separate(y#z)) \\<Longrightarrow> allNetsDistinct(x#separate(y#z))\"", "lemma ANDSep[rule_format]: \"allNetsDistinct p \\<longrightarrow> allNetsDistinct(separate p)\"", "lemma wp1_alternativesep[rule_format]: \n  \"wellformed_policy1_strong p \\<longrightarrow> wellformed_policy1_strong (separate p)\"", "lemma noDAsort[rule_format]: \"noDenyAll1 p \\<longrightarrow> noDenyAll1 (sort p l)\"", "lemma OTNSC[rule_format]: \"singleCombinators p \\<longrightarrow> OnlyTwoNets p\"", "lemma fMTaux: \"\\<not> member DenyAll x \\<Longrightarrow> first_bothNet x \\<noteq> {}\"", "lemma fl2[rule_format]: \"firstList (separate p) = firstList p\"", "lemma fl3[rule_format]: \"NetsCollected p \\<longrightarrow> (first_bothNet x \\<noteq> firstList p \\<longrightarrow>\n          (\\<forall>a\\<in>set p. first_bothNet x \\<noteq> first_bothNet a))\\<longrightarrow> NetsCollected (x#p)\"", "lemma sortedConc[rule_format]: \" sorted (a # p) l \\<longrightarrow>  sorted p l\"", "lemma smalleraux2: \n  \"{a,b} \\<in> set l \\<Longrightarrow> {c,d} \\<in> set l \\<Longrightarrow> {a,b} \\<noteq> {c,d} \\<Longrightarrow> \n   smaller (DenyAllFromTo a b) (DenyAllFromTo c d) l \\<Longrightarrow> \n  \\<not> smaller (DenyAllFromTo c d) (DenyAllFromTo a b) l\"", "lemma smalleraux2a: \n  \"{a,b} \\<in> set l \\<Longrightarrow> {c,d} \\<in> set l \\<Longrightarrow> {a,b} \\<noteq> {c,d} \\<Longrightarrow> \n   smaller (DenyAllFromTo a b) (AllowPortFromTo c d p) l \\<Longrightarrow> \n  \\<not> smaller (AllowPortFromTo c d p) (DenyAllFromTo a b) l\"", "lemma smalleraux2b: \n  \"{a,b} \\<in> set l \\<Longrightarrow> {c,d} \\<in> set l \\<Longrightarrow> {a,b} \\<noteq> {c,d} \\<Longrightarrow> y = DenyAllFromTo a b \\<Longrightarrow>\n   smaller (AllowPortFromTo  c d p) y l \\<Longrightarrow> \n  \\<not> smaller y (AllowPortFromTo  c d p) l\"", "lemma smalleraux2c: \n  \"{a,b} \\<in> set l\\<Longrightarrow>{c,d}\\<in>set l\\<Longrightarrow>{a,b} \\<noteq> {c,d} \\<Longrightarrow> y = AllowPortFromTo a b q \\<Longrightarrow> \n    smaller (AllowPortFromTo  c d p) y l \\<Longrightarrow> \\<not> smaller y (AllowPortFromTo  c d p) l\"", "lemma smalleraux3: \n  assumes \"x \\<in> set l\" and \" y \\<in> set l\" and \"x \\<noteq> y\" and \"x = bothNet a\" and \"y = bothNet b\"\n    and \"smaller a b l\" and \"singleCombinators [a]\" and \"singleCombinators [b]\"  \n  shows \"\\<not> smaller b a l\"", "lemma smalleraux3a: \n  \"a \\<noteq> DenyAll \\<Longrightarrow> b \\<noteq> DenyAll \\<Longrightarrow> in_list b l \\<Longrightarrow> in_list a l \\<Longrightarrow>  \n   bothNet a \\<noteq> bothNet b \\<Longrightarrow> smaller a b l \\<Longrightarrow> singleCombinators [a] \\<Longrightarrow>\n    singleCombinators [b] \\<Longrightarrow> \\<not> smaller b a l\"", "lemma posaux[rule_format]: \"position a l < position b l \\<longrightarrow> a \\<noteq> b\"", "lemma posaux6[rule_format]: \n  \"a \\<in> set l \\<longrightarrow> b \\<in> set l \\<longrightarrow> a \\<noteq> b \\<longrightarrow> position a l \\<noteq>  position b l\"", "lemma notSmallerTransaux[rule_format]: \n  \"x \\<noteq> DenyAll \\<Longrightarrow> r \\<noteq> DenyAll \\<Longrightarrow>\n  singleCombinators [x] \\<Longrightarrow>  singleCombinators [y] \\<Longrightarrow>  singleCombinators [r] \\<Longrightarrow>\n  \\<not> smaller y x l \\<Longrightarrow> smaller x y l \\<Longrightarrow> smaller x r l \\<Longrightarrow> smaller y r l \\<Longrightarrow> \n   in_list x l \\<Longrightarrow> in_list y l \\<Longrightarrow> in_list r l \\<Longrightarrow> \\<not> smaller r x l\"", "lemma notSmallerTrans[rule_format]: \n  \"x \\<noteq> DenyAll \\<longrightarrow> r \\<noteq> DenyAll \\<longrightarrow> singleCombinators (x#y#z) \\<longrightarrow> \n  \\<not> smaller y x l \\<longrightarrow> sorted (x#y#z) l \\<longrightarrow> r \\<in> set z \\<longrightarrow> \n  all_in_list (x#y#z) l \\<longrightarrow> \\<not> smaller r x l\"", "lemma  NCSaux1[rule_format]:\n  \"noDenyAll p \\<longrightarrow> {x, y} \\<in> set l \\<longrightarrow>  all_in_list p l\\<longrightarrow> singleCombinators p \\<longrightarrow> \n  sorted (DenyAllFromTo x y # p) l \\<longrightarrow> {x, y} \\<noteq> firstList p \\<longrightarrow>\n  DenyAllFromTo u v \\<in> set p \\<longrightarrow> {x, y} \\<noteq> {u, v}\"", "lemma posaux3[rule_format]:\"a \\<in> set l \\<longrightarrow> b \\<in> set l \\<longrightarrow> a \\<noteq> b \\<longrightarrow> position a l \\<noteq> position b l\"", "lemma posaux4[rule_format]: \n  \"singleCombinators [a] \\<longrightarrow> a\\<noteq> DenyAll \\<longrightarrow> b \\<noteq> DenyAll \\<longrightarrow> in_list a l \\<longrightarrow>in_list b l \\<longrightarrow>\n    smaller a b  l\\<longrightarrow> x = (bothNet a) \\<longrightarrow>  y = (bothNet b) \\<longrightarrow> \n    position x l <= position y l\"", "lemma  NCSaux2[rule_format]:\n  \"noDenyAll p \\<longrightarrow> {a, b} \\<in> set l \\<longrightarrow> all_in_list p l \\<longrightarrow>singleCombinators p \\<longrightarrow>\n   sorted (DenyAllFromTo a b # p) l \\<longrightarrow> {a, b} \\<noteq> firstList p \\<longrightarrow>\n   AllowPortFromTo u v w \\<in> set p \\<longrightarrow>  {a, b} \\<noteq> {u, v}\"", "lemma  NCSaux3[rule_format]:\n  \"noDenyAll p \\<longrightarrow> {a, b} \\<in> set l \\<longrightarrow>  all_in_list p l \\<longrightarrow>singleCombinators p \\<longrightarrow> \n  sorted (AllowPortFromTo a b w # p) l \\<longrightarrow> {a, b} \\<noteq> firstList p \\<longrightarrow>\n  DenyAllFromTo u v \\<in> set p \\<longrightarrow> {a, b} \\<noteq> {u, v}\"", "lemma  NCSaux4[rule_format]:\n  \"noDenyAll p \\<longrightarrow> {a, b} \\<in> set l \\<longrightarrow>  all_in_list p l \\<longrightarrow> singleCombinators p \\<longrightarrow> \n sorted (AllowPortFromTo a b c # p) l \\<longrightarrow> {a, b} \\<noteq> firstList p \\<longrightarrow>\n AllowPortFromTo u v w \\<in> set p \\<longrightarrow> {a, b} \\<noteq> {u, v}\"", "lemma NetsCollectedSorted[rule_format]: \n  \"noDenyAll1 p \\<longrightarrow> all_in_list p l \\<longrightarrow> singleCombinators p \\<longrightarrow> sorted p l \\<longrightarrow>  NetsCollected p\"", "lemma NetsCollectedSort: \"distinct p \\<Longrightarrow>noDenyAll1 p \\<Longrightarrow> all_in_list p l \\<Longrightarrow>\n                          singleCombinators p \\<Longrightarrow> NetsCollected (sort p l)\"", "lemma fBNsep[rule_format]: \"(\\<forall>a\\<in>set z. {b,c} \\<noteq> first_bothNet a) \\<longrightarrow>\n                           (\\<forall>a\\<in>set (separate z). {b,c} \\<noteq> first_bothNet a)\"", "lemma fBNsep1[rule_format]: \" (\\<forall>a\\<in>set z. first_bothNet x \\<noteq> first_bothNet a) \\<longrightarrow>\n                        (\\<forall>a\\<in>set (separate z). first_bothNet x \\<noteq> first_bothNet a)\"", "lemma NetsCollectedSepauxa:\n  \"{b,c}\\<noteq>firstList z \\<Longrightarrow>  noDenyAll1 z \\<Longrightarrow> \\<forall>a\\<in>set z. {b,c}\\<noteq>first_bothNet a \\<Longrightarrow> NetsCollected z \\<Longrightarrow>  \n   NetsCollected (separate z) \\<Longrightarrow> {b, c} \\<noteq> firstList (separate z) \\<Longrightarrow>   a \\<in> set (separate z) \\<Longrightarrow> \n   {b, c} \\<noteq> first_bothNet a\"", "lemma NetsCollectedSepaux:\n  \"first_bothNet (x::('a,'b)Combinators) \\<noteq> first_bothNet y \\<Longrightarrow> \\<not> member DenyAll y \\<and> noDenyAll z \\<Longrightarrow>  \n   (\\<forall>a\\<in>set z. first_bothNet x \\<noteq> first_bothNet a) \\<and> NetsCollected (y # z) \\<Longrightarrow>\n   NetsCollected (separate (y # z)) \\<Longrightarrow> first_bothNet x \\<noteq> firstList (separate (y # z)) \\<Longrightarrow>\n   a \\<in> set (separate (y # z)) \\<Longrightarrow>\n   first_bothNet (x::('a,'b)Combinators) \\<noteq> first_bothNet (a::('a,'b)Combinators)\"", "lemma NetsCollectedSep[rule_format]: \n  \"noDenyAll1 p \\<longrightarrow> NetsCollected p \\<longrightarrow>  NetsCollected (separate p)\"", "lemma OTNaux: \n  \"onlyTwoNets a \\<Longrightarrow> \\<not> member DenyAll a \\<Longrightarrow> (x,y) \\<in> sdnets a \\<Longrightarrow> \n   (x = first_srcNet a \\<and> y = first_destNet a) \\<or>   (x = first_destNet a \\<and> y = first_srcNet a)\"", "lemma sdnets_charn: \"onlyTwoNets a \\<Longrightarrow> \\<not> member DenyAll a \\<Longrightarrow>\nsdnets a = {(first_srcNet a,first_destNet a)} \\<or> \nsdnets a = {(first_srcNet a, first_destNet a),(first_destNet a, first_srcNet a)}\"", "lemma first_bothNet_charn[rule_format]: \n  \"\\<not> member DenyAll a \\<longrightarrow> first_bothNet a = {first_srcNet a, first_destNet a}\"", "lemma sdnets_noteq:\n  \"onlyTwoNets a \\<Longrightarrow> onlyTwoNets aa \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa \\<Longrightarrow> \n   \\<not> member DenyAll a \\<Longrightarrow> \\<not> member DenyAll aa \\<Longrightarrow> sdnets a \\<noteq> sdnets aa\"", "lemma fbn_noteq: \n  \"onlyTwoNets a \\<Longrightarrow>  onlyTwoNets aa \\<Longrightarrow>  first_bothNet a \\<noteq> first_bothNet aa \\<Longrightarrow>\n    \\<not> member DenyAll a \\<Longrightarrow>  \\<not> member DenyAll aa \\<Longrightarrow>  allNetsDistinct [a, aa] \\<Longrightarrow>\n    first_srcNet a \\<noteq> first_srcNet aa \\<or> first_srcNet a \\<noteq> first_destNet aa \\<or> \n    first_destNet a \\<noteq> first_srcNet aa \\<or> first_destNet a \\<noteq> first_destNet aa\"", "lemma NCisSD2aux: \n  assumes 1: \"onlyTwoNets a\" and 2 : \"onlyTwoNets aa\" and 3 : \"first_bothNet a \\<noteq> first_bothNet aa\"\n    and   4: \"\\<not> member DenyAll a\" and 5: \"\\<not> member DenyAll aa\" and 6:\" allNetsDistinct [a, aa]\"\n  shows   \"disjSD_2 a aa\"", "lemma ANDaux3[rule_format]: \n  \"y \\<in> set xs \\<longrightarrow> a \\<in> set (net_list_aux [y]) \\<longrightarrow>  a \\<in> set (net_list_aux xs)\"", "lemma ANDaux2: \n  \"allNetsDistinct (x # xs) \\<Longrightarrow> y \\<in> set xs \\<Longrightarrow> allNetsDistinct [x,y]\"", "lemma NCisSD2[rule_format]: \n  \"\\<not> member DenyAll a     \\<Longrightarrow>  OnlyTwoNets (a#p) \\<Longrightarrow> \n  NetsCollected2 (a # p) \\<Longrightarrow> NetsCollected (a#p) \\<Longrightarrow>\n  noDenyAll ( p) \\<Longrightarrow> allNetsDistinct (a # p) \\<Longrightarrow> s \\<in> set p \\<Longrightarrow>\n  disjSD_2 a s\"", "lemma separatedNC[rule_format]: \n  \"OnlyTwoNets p \\<longrightarrow> NetsCollected2 p \\<longrightarrow> NetsCollected p \\<longrightarrow> noDenyAll1 p \\<longrightarrow>  \n   allNetsDistinct p  \\<longrightarrow> separated p\"", "lemma separatedNC'[rule_format]: \n  \"OnlyTwoNets p \\<longrightarrow> NetsCollected2 p \\<longrightarrow> NetsCollected p \\<longrightarrow> noDenyAll1 p \\<longrightarrow>  \n   allNetsDistinct p  \\<longrightarrow> separated p\"", "lemma NC2Sep[rule_format]: \"noDenyAll1 p \\<longrightarrow> NetsCollected2 (separate p)\"", "lemma separatedSep[rule_format]: \n  \"OnlyTwoNets p \\<longrightarrow> NetsCollected2 p   \\<longrightarrow> NetsCollected p \\<longrightarrow> \n   noDenyAll1 p  \\<longrightarrow> allNetsDistinct p  \\<longrightarrow> separated (separate p)\"", "lemma rADnMT[rule_format]: \"p \\<noteq> []  \\<longrightarrow> removeAllDuplicates p \\<noteq> []\"", "lemma remDupsNMT[rule_format]: \"p \\<noteq> [] \\<longrightarrow> remdups p \\<noteq> []\"", "lemma sets_distinct1: \"(n::int) \\<noteq> m \\<Longrightarrow> {(a,b). a = n} \\<noteq> {(a,b). a = m}\"", "lemma sets_distinct2: \"(m::int) \\<noteq> n \\<Longrightarrow> {(a,b). a = n} \\<noteq> {(a,b). a = m}\"", "lemma sets_distinct5: \"(n::int) < m \\<Longrightarrow> {(a,b). a = n} \\<noteq> {(a,b). a = m}\"", "lemma sets_distinct6: \"(m::int) < n \\<Longrightarrow> {(a,b). a = n} \\<noteq> {(a,b). a = m}\""], "translations": [["", "lemma domNMT: \"dom X \\<noteq> {} \\<Longrightarrow> X \\<noteq> \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom X \\<noteq> {} \\<Longrightarrow> X \\<noteq> \\<emptyset>", "by auto"], ["", "lemma denyNMT: \"deny_all \\<noteq>  \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D\\<^sub>U \\<noteq> \\<emptyset>", "apply (rule domNMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom D\\<^sub>U \\<noteq> {}", "by (simp add: deny_all_def dom_def)"], ["", "lemma wellformed_policy1_charn[rule_format]: \n\"wellformed_policy1 p \\<longrightarrow> DenyAll \\<in> set p \\<longrightarrow> (\\<exists> p'. p = DenyAll # p' \\<and> DenyAll \\<notin> set p')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1 p \\<longrightarrow>\n    DenyAll \\<in> set p \\<longrightarrow>\n    (\\<exists>p'. p = DenyAll # p' \\<and> DenyAll \\<notin> set p')", "by(induct \"p\",simp_all)"], ["", "lemma singleCombinatorsConc: \"singleCombinators (x#xs) \\<Longrightarrow> singleCombinators xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators (x # xs) \\<Longrightarrow> singleCombinators xs", "by (case_tac x,simp_all)"], ["", "lemma aux0_0: \"singleCombinators x \\<Longrightarrow> \\<not> (\\<exists> a b. (a\\<oplus>b) \\<in> set x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators x \\<Longrightarrow>\n    \\<nexists>a b. a \\<oplus> b \\<in> set x", "apply (induct \"x\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>singleCombinators x \\<Longrightarrow>\n                \\<forall>a b. a \\<oplus> b \\<notin> set x;\n        singleCombinators (a # x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa b.\n                            aa \\<oplus> b \\<noteq> a \\<and>\n                            aa \\<oplus> b \\<notin> set x", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators b \\<Longrightarrow>\n             \\<forall>a ba. a \\<oplus> ba \\<notin> set b;\n     singleCombinators (a # b)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aa ba.\n                         aa \\<oplus> ba \\<noteq> a \\<and>\n                         aa \\<oplus> ba \\<notin> set b", "by (case_tac \"a\",simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aux0_4: \"(a \\<in> set x \\<or> a \\<in> set y) = (a \\<in> set (x@y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in> set x \\<or> a \\<in> set y) = (a \\<in> set (x @ y))", "by auto"], ["", "lemma aux0_1: \"\\<lbrakk>singleCombinators xs; singleCombinators [x]\\<rbrakk> \\<Longrightarrow>\n               singleCombinators (x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators xs; singleCombinators [x]\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (x # xs)", "by (case_tac \"x\",simp_all)"], ["", "lemma aux0_6: \"\\<lbrakk>singleCombinators xs; \\<not> (\\<exists> a b. x = a \\<oplus> b)\\<rbrakk> \\<Longrightarrow>\n               singleCombinators(x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators xs; \\<nexists>a b. x = a \\<oplus> b\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (x # xs)", "apply (rule aux0_1,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators xs;\n     \\<forall>a b. x \\<noteq> a \\<oplus> b\\<rbrakk>\n    \\<Longrightarrow> singleCombinators [x]", "apply (case_tac \"x\",simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aux0_5: \" \\<not> (\\<exists> a b. (a\\<oplus>b) \\<in> set x) \\<Longrightarrow> singleCombinators x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>a b. a \\<oplus> b \\<in> set x \\<Longrightarrow>\n    singleCombinators x", "apply (induct \"x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<nexists>a b. a \\<oplus> b \\<in> set [] \\<Longrightarrow>\n    singleCombinators []\n 2. \\<And>a x.\n       \\<lbrakk>\\<nexists>a b. a \\<oplus> b \\<in> set x \\<Longrightarrow>\n                singleCombinators x;\n        \\<nexists>aa b. aa \\<oplus> b \\<in> set (a # x)\\<rbrakk>\n       \\<Longrightarrow> singleCombinators (a # x)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>singleCombinators x;\n        \\<forall>aa b.\n           aa \\<oplus> b \\<noteq> a \\<and>\n           aa \\<oplus> b \\<notin> set x\\<rbrakk>\n       \\<Longrightarrow> singleCombinators (a # x)", "by (metis aux0_6)"], ["", "lemma ANDConc[rule_format]: \"allNetsDistinct (a#p) \\<longrightarrow> allNetsDistinct (p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allNetsDistinct (a # p) \\<longrightarrow> allNetsDistinct p", "apply (simp add: allNetsDistinct_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>aa b.\n        aa \\<noteq> b \\<and>\n        aa \\<in> set (net_list_aux (a # p)) \\<and>\n        b \\<in> set (net_list_aux (a # p)) \\<longrightarrow>\n        netsDistinct aa b) \\<longrightarrow>\n    (\\<forall>a b.\n        a \\<noteq> b \\<and>\n        a \\<in> set (net_list_aux p) \\<and>\n        b \\<in> set (net_list_aux p) \\<longrightarrow>\n        netsDistinct a b)", "apply (case_tac \"a\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. a = DenyAll \\<Longrightarrow>\n    (\\<forall>aa b.\n        aa \\<noteq> b \\<and>\n        aa \\<in> set (net_list_aux (a # p)) \\<and>\n        b \\<in> set (net_list_aux (a # p)) \\<longrightarrow>\n        netsDistinct aa b) \\<longrightarrow>\n    (\\<forall>a b.\n        a \\<noteq> b \\<and>\n        a \\<in> set (net_list_aux p) \\<and>\n        b \\<in> set (net_list_aux p) \\<longrightarrow>\n        netsDistinct a b)\n 2. \\<And>x21 x22.\n       a = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       (\\<forall>aa b.\n           aa \\<noteq> b \\<and>\n           aa \\<in> set (net_list_aux (a # p)) \\<and>\n           b \\<in> set (net_list_aux (a # p)) \\<longrightarrow>\n           netsDistinct aa b) \\<longrightarrow>\n       (\\<forall>a b.\n           a \\<noteq> b \\<and>\n           a \\<in> set (net_list_aux p) \\<and>\n           b \\<in> set (net_list_aux p) \\<longrightarrow>\n           netsDistinct a b)\n 3. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       (\\<forall>aa b.\n           aa \\<noteq> b \\<and>\n           aa \\<in> set (net_list_aux (a # p)) \\<and>\n           b \\<in> set (net_list_aux (a # p)) \\<longrightarrow>\n           netsDistinct aa b) \\<longrightarrow>\n       (\\<forall>a b.\n           a \\<noteq> b \\<and>\n           a \\<in> set (net_list_aux p) \\<and>\n           b \\<in> set (net_list_aux p) \\<longrightarrow>\n           netsDistinct a b)\n 4. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow>\n       (\\<forall>aa b.\n           aa \\<noteq> b \\<and>\n           aa \\<in> set (net_list_aux (a # p)) \\<and>\n           b \\<in> set (net_list_aux (a # p)) \\<longrightarrow>\n           netsDistinct aa b) \\<longrightarrow>\n       (\\<forall>a b.\n           a \\<noteq> b \\<and>\n           a \\<in> set (net_list_aux p) \\<and>\n           b \\<in> set (net_list_aux p) \\<longrightarrow>\n           netsDistinct a b)", "by simp_all"], ["", "lemma aux6: \"twoNetsDistinct a1 a2 a b \\<Longrightarrow>\n            dom (deny_all_from_to a1 a2) \\<inter> dom (deny_all_from_to a b) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. twoNetsDistinct a1 a2 a b \\<Longrightarrow>\n    dom (deny_all_from_to a1 a2) \\<inter> dom (deny_all_from_to a b) = {}", "by (auto simp: twoNetsDistinct_def netsDistinct_def src_def dest_def \n      in_subnet_def PolicyCombinators.PolicyCombinators dom_def)"], ["", "lemma aux5[rule_format]: \"(DenyAllFromTo a b) \\<in> set p \\<longrightarrow> a \\<in> set (net_list p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAllFromTo a b \\<in> set p \\<longrightarrow> a \\<in> set (net_list p)", "by (rule net_list_aux.induct,simp_all)"], ["", "lemma aux5a[rule_format]: \"(DenyAllFromTo b a) \\<in> set p \\<longrightarrow> a \\<in> set (net_list p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAllFromTo b a \\<in> set p \\<longrightarrow> a \\<in> set (net_list p)", "by (rule net_list_aux.induct,simp_all)"], ["", "lemma aux5c[rule_format]:\n  \"(AllowPortFromTo a b po) \\<in> set p \\<longrightarrow> a \\<in> set (net_list p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AllowPortFromTo a b po \\<in> set p \\<longrightarrow>\n    a \\<in> set (net_list p)", "by (rule net_list_aux.induct,simp_all)"], ["", "lemma aux5d[rule_format]:\n  \"(AllowPortFromTo b a po) \\<in> set p \\<longrightarrow> a \\<in> set (net_list p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AllowPortFromTo b a po \\<in> set p \\<longrightarrow>\n    a \\<in> set (net_list p)", "by (rule net_list_aux.induct,simp_all)"], ["", "lemma aux10[rule_format]: \"a \\<in> set (net_list p) \\<longrightarrow> a \\<in> set (net_list_aux p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (net_list p) \\<longrightarrow> a \\<in> set (net_list_aux p)", "by simp"], ["", "lemma srcInNetListaux[simp]: \n  \"\\<lbrakk>x \\<in> set p; singleCombinators[x]; x \\<noteq> DenyAll\\<rbrakk> \\<Longrightarrow> srcNet x \\<in> set (net_list_aux p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set p; singleCombinators [x];\n     x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> srcNet x \\<in> set (net_list_aux p)", "apply (induct \"p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set []; singleCombinators [x];\n     x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> srcNet x \\<in> set (net_list_aux [])\n 2. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>x \\<in> set p; singleCombinators [x];\n                 x \\<noteq> DenyAll\\<rbrakk>\n                \\<Longrightarrow> srcNet x \\<in> set (net_list_aux p);\n        x \\<in> set (a # p); singleCombinators [x];\n        x \\<noteq> DenyAll\\<rbrakk>\n       \\<Longrightarrow> srcNet x \\<in> set (net_list_aux (a # p))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>x \\<in> set p \\<Longrightarrow>\n                srcNet x \\<in> set (net_list_aux p);\n        x = a \\<or> x \\<in> set p; singleCombinators [x];\n        x \\<noteq> DenyAll\\<rbrakk>\n       \\<Longrightarrow> srcNet x \\<in> set (net_list_aux (a # p))", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set p \\<Longrightarrow>\n             srcNet x \\<in> set (net_list_aux p);\n     x = a \\<or> x \\<in> set p; singleCombinators [x];\n     x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> srcNet x \\<in> set (net_list_aux (a # p))", "apply (case_tac \"x = a\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> set p \\<Longrightarrow>\n             srcNet a \\<in> set (net_list_aux p);\n     singleCombinators [a]; a \\<noteq> DenyAll; x = a\\<rbrakk>\n    \\<Longrightarrow> srcNet a \\<in> set (net_list_aux (a # p))\n 2. \\<lbrakk>srcNet x \\<in> set (net_list_aux p); x \\<in> set p;\n     singleCombinators [x]; x \\<noteq> DenyAll; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> srcNet x \\<in> set (net_list_aux (a # p))", "apply (case_tac a, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>srcNet x \\<in> set (net_list_aux p); x \\<in> set p;\n     singleCombinators [x]; x \\<noteq> DenyAll; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> srcNet x \\<in> set (net_list_aux (a # p))", "apply (case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma destInNetListaux[simp]: \n  \"\\<lbrakk>x \\<in> set p; singleCombinators[x]; x \\<noteq> DenyAll\\<rbrakk> \\<Longrightarrow> destNet x \\<in> set (net_list_aux p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set p; singleCombinators [x];\n     x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> destNet x \\<in> set (net_list_aux p)", "apply (induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set []; singleCombinators [x];\n     x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> destNet x \\<in> set (net_list_aux [])\n 2. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>x \\<in> set p; singleCombinators [x];\n                 x \\<noteq> DenyAll\\<rbrakk>\n                \\<Longrightarrow> destNet x \\<in> set (net_list_aux p);\n        x \\<in> set (a # p); singleCombinators [x];\n        x \\<noteq> DenyAll\\<rbrakk>\n       \\<Longrightarrow> destNet x \\<in> set (net_list_aux (a # p))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>x \\<in> set p \\<Longrightarrow>\n                destNet x \\<in> set (net_list_aux p);\n        x = a \\<or> x \\<in> set p; singleCombinators [x];\n        x \\<noteq> DenyAll\\<rbrakk>\n       \\<Longrightarrow> destNet x \\<in> set (net_list_aux (a # p))", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set p \\<Longrightarrow>\n             destNet x \\<in> set (net_list_aux p);\n     x = a \\<or> x \\<in> set p; singleCombinators [x];\n     x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> destNet x \\<in> set (net_list_aux (a # p))", "apply (case_tac \"x = a\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> set p \\<Longrightarrow>\n             destNet a \\<in> set (net_list_aux p);\n     singleCombinators [a]; a \\<noteq> DenyAll; x = a\\<rbrakk>\n    \\<Longrightarrow> destNet a \\<in> set (net_list_aux (a # p))\n 2. \\<lbrakk>destNet x \\<in> set (net_list_aux p); x \\<in> set p;\n     singleCombinators [x]; x \\<noteq> DenyAll; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> destNet x \\<in> set (net_list_aux (a # p))", "apply (case_tac \"a\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>destNet x \\<in> set (net_list_aux p); x \\<in> set p;\n     singleCombinators [x]; x \\<noteq> DenyAll; x \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> destNet x \\<in> set (net_list_aux (a # p))", "apply (case_tac \"a\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tND1: \"\\<lbrakk>allNetsDistinct p; x \\<in> set p; y \\<in> set p; a = srcNet x;\n             b = destNet x; c = srcNet y; d = destNet y; a \\<noteq> c;\n             singleCombinators[x]; x \\<noteq> DenyAll; singleCombinators[y];\n             y \\<noteq> DenyAll\\<rbrakk> \\<Longrightarrow> twoNetsDistinct a b c d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allNetsDistinct p; x \\<in> set p; y \\<in> set p; a = srcNet x;\n     b = destNet x; c = srcNet y; d = destNet y; a \\<noteq> c;\n     singleCombinators [x]; x \\<noteq> DenyAll; singleCombinators [y];\n     y \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> twoNetsDistinct a b c d", "by (simp add: allNetsDistinct_def twoNetsDistinct_def)"], ["", "lemma tND2: \"\\<lbrakk>allNetsDistinct p; x \\<in> set p; y \\<in> set p; a = srcNet x;\n             b = destNet x; c = srcNet y; d = destNet y; b \\<noteq> d;\n             singleCombinators[x]; x \\<noteq> DenyAll; singleCombinators[y];\n             y \\<noteq> DenyAll\\<rbrakk> \\<Longrightarrow> twoNetsDistinct a b c d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allNetsDistinct p; x \\<in> set p; y \\<in> set p; a = srcNet x;\n     b = destNet x; c = srcNet y; d = destNet y; b \\<noteq> d;\n     singleCombinators [x]; x \\<noteq> DenyAll; singleCombinators [y];\n     y \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> twoNetsDistinct a b c d", "by (simp add: allNetsDistinct_def twoNetsDistinct_def)"], ["", "lemma tND: \"\\<lbrakk>allNetsDistinct p; x \\<in> set p; y \\<in> set p; a = srcNet x;\n            b = destNet x; c = srcNet y; d = destNet y; a \\<noteq> c \\<or> b \\<noteq> d;\n            singleCombinators[x]; x \\<noteq> DenyAll; singleCombinators[y]; y \\<noteq> DenyAll\\<rbrakk>\n            \\<Longrightarrow> twoNetsDistinct a b c d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allNetsDistinct p; x \\<in> set p; y \\<in> set p; a = srcNet x;\n     b = destNet x; c = srcNet y; d = destNet y;\n     a \\<noteq> c \\<or> b \\<noteq> d; singleCombinators [x];\n     x \\<noteq> DenyAll; singleCombinators [y]; y \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> twoNetsDistinct a b c d", "apply (case_tac \"a \\<noteq> c\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>allNetsDistinct p; x \\<in> set p; y \\<in> set p; a = srcNet x;\n     b = destNet x; c = srcNet y; d = destNet y; singleCombinators [x];\n     x \\<noteq> DenyAll; singleCombinators [y]; y \\<noteq> DenyAll;\n     srcNet x \\<noteq> srcNet y\\<rbrakk>\n    \\<Longrightarrow> twoNetsDistinct (srcNet x) (destNet x) (srcNet y)\n                       (destNet y)\n 2. \\<lbrakk>allNetsDistinct p; x \\<in> set p; y \\<in> set p; a = srcNet y;\n     b = destNet x; c = srcNet y; d = destNet y;\n     destNet x \\<noteq> destNet y; singleCombinators [x];\n     x \\<noteq> DenyAll; singleCombinators [y]; y \\<noteq> DenyAll;\n     srcNet x = srcNet y\\<rbrakk>\n    \\<Longrightarrow> twoNetsDistinct (srcNet y) (destNet x) (srcNet y)\n                       (destNet y)", "apply (erule_tac x = x and y =y in tND1, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allNetsDistinct p; x \\<in> set p; y \\<in> set p; a = srcNet y;\n     b = destNet x; c = srcNet y; d = destNet y;\n     destNet x \\<noteq> destNet y; singleCombinators [x];\n     x \\<noteq> DenyAll; singleCombinators [y]; y \\<noteq> DenyAll;\n     srcNet x = srcNet y\\<rbrakk>\n    \\<Longrightarrow> twoNetsDistinct (srcNet y) (destNet x) (srcNet y)\n                       (destNet y)", "apply (erule_tac x = x and y =y in tND2, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aux7: \"\\<lbrakk>DenyAllFromTo a b \\<in> set p; allNetsDistinct ((DenyAllFromTo c d)#p);\n             a\\<noteq> c\\<or> b\\<noteq> d\\<rbrakk> \\<Longrightarrow> twoNetsDistinct a b c d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     allNetsDistinct (DenyAllFromTo c d # p);\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> twoNetsDistinct a b c d", "apply (erule_tac x = \"DenyAllFromTo a b\" and y = \"DenyAllFromTo c d\" in tND)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> DenyAllFromTo a b \\<in> set (DenyAllFromTo c d # p)\n 2. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> DenyAllFromTo c d \\<in> set (DenyAllFromTo c d # p)\n 3. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> a = srcNet (DenyAllFromTo a b)\n 4. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> b = destNet (DenyAllFromTo a b)\n 5. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> c = srcNet (DenyAllFromTo c d)\n 6. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> d = destNet (DenyAllFromTo c d)\n 7. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> c \\<or> b \\<noteq> d\n 8. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> singleCombinators [DenyAllFromTo a b]\n 9. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> DenyAllFromTo a b \\<noteq> DenyAll\n 10. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n      a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n     \\<Longrightarrow> singleCombinators [DenyAllFromTo c d]\nA total of 11 subgoals...", "by simp_all"], ["", "lemma aux7a: \"\\<lbrakk>DenyAllFromTo a b  \\<in> set p;\n              allNetsDistinct ((AllowPortFromTo c d po)#p); a \\<noteq> c\\<or> b \\<noteq> d\\<rbrakk> \\<Longrightarrow> \n              twoNetsDistinct a b c d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     allNetsDistinct (AllowPortFromTo c d po # p);\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> twoNetsDistinct a b c d", "apply (erule_tac x = \"DenyAllFromTo a b\" and\n      y = \"AllowPortFromTo  c d po\" in tND)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> DenyAllFromTo a b\n                      \\<in> set (AllowPortFromTo c d po # p)\n 2. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> AllowPortFromTo c d po\n                      \\<in> set (AllowPortFromTo c d po # p)\n 3. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> a = srcNet (DenyAllFromTo a b)\n 4. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> b = destNet (DenyAllFromTo a b)\n 5. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> c = srcNet (AllowPortFromTo c d po)\n 6. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> d = destNet (AllowPortFromTo c d po)\n 7. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> c \\<or> b \\<noteq> d\n 8. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> singleCombinators [DenyAllFromTo a b]\n 9. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> DenyAllFromTo a b \\<noteq> DenyAll\n 10. \\<lbrakk>DenyAllFromTo a b \\<in> set p;\n      a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n     \\<Longrightarrow> singleCombinators [AllowPortFromTo c d po]\nA total of 11 subgoals...", "by simp_all"], ["", "lemma nDComm: assumes ab: \"netsDistinct a b\" shows ba: \"netsDistinct b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. netsDistinct b a", "apply (insert ab)"], ["proof (prove)\ngoal (1 subgoal):\n 1. netsDistinct a b \\<Longrightarrow> netsDistinct b a", "by (auto simp: netsDistinct_def  in_subnet_def)"], ["", "lemma tNDComm: \n  assumes abcd: \"twoNetsDistinct a b c d\" shows \"twoNetsDistinct c d a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. twoNetsDistinct c d a b", "apply (insert abcd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. twoNetsDistinct a b c d \\<Longrightarrow> twoNetsDistinct c d a b", "by (metis twoNetsDistinct_def nDComm)"], ["", "lemma aux[rule_format]: \"a \\<in> set (removeShadowRules2 p) \\<longrightarrow> a \\<in> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (removeShadowRules2 p) \\<longrightarrow> a \\<in> set p", "apply (case_tac a)"], ["proof (prove)\ngoal (4 subgoals):\n 1. a = DenyAll \\<Longrightarrow>\n    a \\<in> set (removeShadowRules2 p) \\<longrightarrow> a \\<in> set p\n 2. \\<And>x21 x22.\n       a = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       a \\<in> set (removeShadowRules2 p) \\<longrightarrow> a \\<in> set p\n 3. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       a \\<in> set (removeShadowRules2 p) \\<longrightarrow> a \\<in> set p\n 4. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow>\n       a \\<in> set (removeShadowRules2 p) \\<longrightarrow> a \\<in> set p", "by (rule removeShadowRules2.induct, simp_all)+"], ["", "lemma aux12: \"\\<lbrakk>a \\<in> x; b \\<notin> x\\<rbrakk> \\<Longrightarrow> a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> x; b \\<notin> x\\<rbrakk> \\<Longrightarrow> a \\<noteq> b", "by auto"], ["", "lemma ND0aux1[rule_format]: \"DenyAllFromTo x y \\<in> set b \\<Longrightarrow>  \n                             x \\<in> set (net_list_aux b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAllFromTo x y \\<in> set b \\<Longrightarrow>\n    x \\<in> set (net_list_aux b)", "by (metis aux5 net_list.simps set_remdups)"], ["", "lemma ND0aux2[rule_format]: \"DenyAllFromTo x y \\<in> set b \\<Longrightarrow>  \n                             y \\<in> set (net_list_aux b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAllFromTo x y \\<in> set b \\<Longrightarrow>\n    y \\<in> set (net_list_aux b)", "by (metis aux5a net_list.simps set_remdups)"], ["", "lemma ND0aux3[rule_format]: \"AllowPortFromTo x y p \\<in> set b \\<Longrightarrow>  \n                             x \\<in> set (net_list_aux b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AllowPortFromTo x y p \\<in> set b \\<Longrightarrow>\n    x \\<in> set (net_list_aux b)", "by (metis aux5c net_list.simps set_remdups)"], ["", "lemma ND0aux4[rule_format]: \"AllowPortFromTo x y p \\<in> set b \\<Longrightarrow>  \n                             y \\<in> set (net_list_aux b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AllowPortFromTo x y p \\<in> set b \\<Longrightarrow>\n    y \\<in> set (net_list_aux b)", "by (metis aux5d net_list.simps set_remdups)"], ["", "lemma aNDSubsetaux[rule_format]: \"singleCombinators a  \\<longrightarrow> set a \\<subseteq> set b \\<longrightarrow> \n                                  set (net_list_aux a) \\<subseteq> set (net_list_aux b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators a \\<longrightarrow>\n    set a \\<subseteq> set b \\<longrightarrow>\n    set (net_list_aux a) \\<subseteq> set (net_list_aux b)", "apply (induct a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. singleCombinators [] \\<longrightarrow>\n    set [] \\<subseteq> set b \\<longrightarrow>\n    set (net_list_aux []) \\<subseteq> set (net_list_aux b)\n 2. \\<And>a1 a2.\n       singleCombinators a2 \\<longrightarrow>\n       set a2 \\<subseteq> set b \\<longrightarrow>\n       set (net_list_aux a2)\n       \\<subseteq> set (net_list_aux b) \\<Longrightarrow>\n       singleCombinators (a1 # a2) \\<longrightarrow>\n       set (a1 # a2) \\<subseteq> set b \\<longrightarrow>\n       set (net_list_aux (a1 # a2)) \\<subseteq> set (net_list_aux b)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       singleCombinators a2 \\<longrightarrow>\n       set a2 \\<subseteq> set b \\<longrightarrow>\n       set (net_list_aux a2)\n       \\<subseteq> set (net_list_aux b) \\<Longrightarrow>\n       singleCombinators (a1 # a2) \\<longrightarrow>\n       a1 \\<in> set b \\<and> set a2 \\<subseteq> set b \\<longrightarrow>\n       set (net_list_aux (a1 # a2)) \\<subseteq> set (net_list_aux b)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2 x.\n       \\<lbrakk>singleCombinators a2 \\<longrightarrow>\n                set a2 \\<subseteq> set b \\<longrightarrow>\n                set (net_list_aux a2) \\<subseteq> set (net_list_aux b);\n        singleCombinators (a1 # a2); x \\<in> set (net_list_aux (a1 # a2));\n        a1 \\<in> set b; set a2 \\<subseteq> set b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (net_list_aux b)", "apply (drule mp, erule singleCombinatorsConc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2 x.\n       \\<lbrakk>singleCombinators (a1 # a2);\n        x \\<in> set (net_list_aux (a1 # a2)); a1 \\<in> set b;\n        set a2 \\<subseteq> set b;\n        set a2 \\<subseteq> set b \\<longrightarrow>\n        set (net_list_aux a2) \\<subseteq> set (net_list_aux b)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (net_list_aux b)", "subgoal for a a' x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators (a # a');\n     x \\<in> set (net_list_aux (a # a')); a \\<in> set b;\n     set a' \\<subseteq> set b;\n     set a' \\<subseteq> set b \\<longrightarrow>\n     set (net_list_aux a') \\<subseteq> set (net_list_aux b)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (net_list_aux b)", "apply (case_tac \"a\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>singleCombinators (a # a');\n     x \\<in> set (net_list_aux (a # a')); a \\<in> set b;\n     set a' \\<subseteq> set b;\n     set a' \\<subseteq> set b \\<longrightarrow>\n     set (net_list_aux a') \\<subseteq> set (net_list_aux b);\n     a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (net_list_aux b)\n 2. \\<And>x21 x22.\n       \\<lbrakk>singleCombinators (a # a');\n        x \\<in> set (net_list_aux (a # a')); a \\<in> set b;\n        set a' \\<subseteq> set b;\n        set a' \\<subseteq> set b \\<longrightarrow>\n        set (net_list_aux a') \\<subseteq> set (net_list_aux b);\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (net_list_aux b)\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>singleCombinators (a # a');\n        x \\<in> set (net_list_aux (a # a')); a \\<in> set b;\n        set a' \\<subseteq> set b;\n        set a' \\<subseteq> set b \\<longrightarrow>\n        set (net_list_aux a') \\<subseteq> set (net_list_aux b);\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (net_list_aux b)\n 4. \\<And>x41 x42.\n       \\<lbrakk>singleCombinators (a # a');\n        x \\<in> set (net_list_aux (a # a')); a \\<in> set b;\n        set a' \\<subseteq> set b;\n        set a' \\<subseteq> set b \\<longrightarrow>\n        set (net_list_aux a') \\<subseteq> set (net_list_aux b);\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (net_list_aux b)", "apply (simp_all add: contra_subsetD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>singleCombinators a'; x \\<in> set (net_list_aux a');\n     DenyAll \\<in> set b; set a' \\<subseteq> set b;\n     set (net_list_aux a') \\<subseteq> set (net_list_aux b);\n     a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (net_list_aux b)\n 2. \\<And>x21 x22.\n       \\<lbrakk>singleCombinators a';\n        x = x21 \\<or> x = x22 \\<or> x \\<in> set (net_list_aux a');\n        DenyAllFromTo x21 x22 \\<in> set b; set a' \\<subseteq> set b;\n        set (net_list_aux a') \\<subseteq> set (net_list_aux b);\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (net_list_aux b)\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>singleCombinators a';\n        x = x31 \\<or> x = x32 \\<or> x \\<in> set (net_list_aux a');\n        AllowPortFromTo x31 x32 x33 \\<in> set b; set a' \\<subseteq> set b;\n        set (net_list_aux a') \\<subseteq> set (net_list_aux b);\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (net_list_aux b)", "apply (metis contra_subsetD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>singleCombinators a';\n        x = x21 \\<or> x = x22 \\<or> x \\<in> set (net_list_aux a');\n        DenyAllFromTo x21 x22 \\<in> set b; set a' \\<subseteq> set b;\n        set (net_list_aux a') \\<subseteq> set (net_list_aux b);\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (net_list_aux b)\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>singleCombinators a';\n        x = x31 \\<or> x = x32 \\<or> x \\<in> set (net_list_aux a');\n        AllowPortFromTo x31 x32 x33 \\<in> set b; set a' \\<subseteq> set b;\n        set (net_list_aux a') \\<subseteq> set (net_list_aux b);\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (net_list_aux b)", "apply (metis ND0aux1 ND0aux2 contra_subsetD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>singleCombinators a';\n        x = x31 \\<or> x = x32 \\<or> x \\<in> set (net_list_aux a');\n        AllowPortFromTo x31 x32 x33 \\<in> set b; set a' \\<subseteq> set b;\n        set (net_list_aux a') \\<subseteq> set (net_list_aux b);\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (net_list_aux b)", "apply (metis ND0aux3 ND0aux4 contra_subsetD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aNDSetsEqaux[rule_format]: \"singleCombinators a \\<longrightarrow> singleCombinators b \\<longrightarrow> \n                 set a = set b \\<longrightarrow> set (net_list_aux a) = set (net_list_aux b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators a \\<longrightarrow>\n    singleCombinators b \\<longrightarrow>\n    set a = set b \\<longrightarrow>\n    set (net_list_aux a) = set (net_list_aux b)", "apply (rule impI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators a; singleCombinators b;\n     set a = set b\\<rbrakk>\n    \\<Longrightarrow> set (net_list_aux a) = set (net_list_aux b)", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>singleCombinators a; singleCombinators b;\n     set a = set b\\<rbrakk>\n    \\<Longrightarrow> set (net_list_aux a) \\<subseteq> set (net_list_aux b)\n 2. \\<lbrakk>singleCombinators a; singleCombinators b;\n     set a = set b\\<rbrakk>\n    \\<Longrightarrow> set (net_list_aux b) \\<subseteq> set (net_list_aux a)", "apply (rule aNDSubsetaux, simp_all)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aNDSubset: \"\\<lbrakk>singleCombinators a;set a \\<subseteq> set b; allNetsDistinct b\\<rbrakk> \\<Longrightarrow> \n                  allNetsDistinct a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators a; set a \\<subseteq> set b;\n     allNetsDistinct b\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct a", "apply (simp add: allNetsDistinct_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators a; set a \\<subseteq> set b;\n     \\<forall>a ba.\n        a \\<noteq> ba \\<and>\n        a \\<in> set (net_list_aux b) \\<and>\n        ba \\<in> set (net_list_aux b) \\<longrightarrow>\n        netsDistinct a ba\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aa b.\n                         aa \\<noteq> b \\<and>\n                         aa \\<in> set (net_list_aux a) \\<and>\n                         b \\<in> set (net_list_aux a) \\<longrightarrow>\n                         netsDistinct aa b", "apply (rule allI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>singleCombinators a; set a \\<subseteq> set b;\n        \\<forall>a ba.\n           a \\<noteq> ba \\<and>\n           a \\<in> set (net_list_aux b) \\<and>\n           ba \\<in> set (net_list_aux b) \\<longrightarrow>\n           netsDistinct a ba\\<rbrakk>\n       \\<Longrightarrow> aa \\<noteq> ba \\<and>\n                         aa \\<in> set (net_list_aux a) \\<and>\n                         ba \\<in> set (net_list_aux a) \\<longrightarrow>\n                         netsDistinct aa ba", "apply (rule impI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>singleCombinators a; set a \\<subseteq> set b;\n        \\<forall>a ba.\n           a \\<noteq> ba \\<and>\n           a \\<in> set (net_list_aux b) \\<and>\n           ba \\<in> set (net_list_aux b) \\<longrightarrow>\n           netsDistinct a ba;\n        aa \\<noteq> ba \\<and>\n        aa \\<in> set (net_list_aux a) \\<and>\n        ba \\<in> set (net_list_aux a)\\<rbrakk>\n       \\<Longrightarrow> netsDistinct aa ba", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators a; set a \\<subseteq> set b;\n     \\<forall>a ba.\n        a \\<noteq> ba \\<and>\n        a \\<in> set (net_list_aux b) \\<and>\n        ba \\<in> set (net_list_aux b) \\<longrightarrow>\n        netsDistinct a ba;\n     x \\<noteq> y \\<and>\n     x \\<in> set (net_list_aux a) \\<and>\n     y \\<in> set (net_list_aux a)\\<rbrakk>\n    \\<Longrightarrow> netsDistinct x y", "apply (drule_tac x = \"x\" in spec, drule_tac x = \"y\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators a; set a \\<subseteq> set b;\n     x \\<noteq> y \\<and>\n     x \\<in> set (net_list_aux a) \\<and> y \\<in> set (net_list_aux a);\n     x \\<noteq> y \\<and>\n     x \\<in> set (net_list_aux b) \\<and>\n     y \\<in> set (net_list_aux b) \\<longrightarrow>\n     netsDistinct x y\\<rbrakk>\n    \\<Longrightarrow> netsDistinct x y", "using aNDSubsetaux"], ["proof (prove)\nusing this:\n  \\<lbrakk>singleCombinators ?a; set ?a \\<subseteq> set ?b\\<rbrakk>\n  \\<Longrightarrow> set (net_list_aux ?a) \\<subseteq> set (net_list_aux ?b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators a; set a \\<subseteq> set b;\n     x \\<noteq> y \\<and>\n     x \\<in> set (net_list_aux a) \\<and> y \\<in> set (net_list_aux a);\n     x \\<noteq> y \\<and>\n     x \\<in> set (net_list_aux b) \\<and>\n     y \\<in> set (net_list_aux b) \\<longrightarrow>\n     netsDistinct x y\\<rbrakk>\n    \\<Longrightarrow> netsDistinct x y", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aNDSetsEq: \"\\<lbrakk>singleCombinators a; singleCombinators b; set a = set b; \n                  allNetsDistinct b\\<rbrakk> \\<Longrightarrow> allNetsDistinct a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators a; singleCombinators b; set a = set b;\n     allNetsDistinct b\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct a", "apply (simp add: allNetsDistinct_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators a; singleCombinators b; set a = set b;\n     \\<forall>a ba.\n        a \\<noteq> ba \\<and>\n        a \\<in> set (net_list_aux b) \\<and>\n        ba \\<in> set (net_list_aux b) \\<longrightarrow>\n        netsDistinct a ba\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aa b.\n                         aa \\<noteq> b \\<and>\n                         aa \\<in> set (net_list_aux a) \\<and>\n                         b \\<in> set (net_list_aux a) \\<longrightarrow>\n                         netsDistinct aa b", "apply (rule allI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>singleCombinators a; singleCombinators b; set a = set b;\n        \\<forall>a ba.\n           a \\<noteq> ba \\<and>\n           a \\<in> set (net_list_aux b) \\<and>\n           ba \\<in> set (net_list_aux b) \\<longrightarrow>\n           netsDistinct a ba\\<rbrakk>\n       \\<Longrightarrow> aa \\<noteq> ba \\<and>\n                         aa \\<in> set (net_list_aux a) \\<and>\n                         ba \\<in> set (net_list_aux a) \\<longrightarrow>\n                         netsDistinct aa ba", "apply (rule impI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>singleCombinators a; singleCombinators b; set a = set b;\n        \\<forall>a ba.\n           a \\<noteq> ba \\<and>\n           a \\<in> set (net_list_aux b) \\<and>\n           ba \\<in> set (net_list_aux b) \\<longrightarrow>\n           netsDistinct a ba;\n        aa \\<noteq> ba \\<and>\n        aa \\<in> set (net_list_aux a) \\<and>\n        ba \\<in> set (net_list_aux a)\\<rbrakk>\n       \\<Longrightarrow> netsDistinct aa ba", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators a; singleCombinators b; set a = set b;\n     \\<forall>a ba.\n        a \\<noteq> ba \\<and>\n        a \\<in> set (net_list_aux b) \\<and>\n        ba \\<in> set (net_list_aux b) \\<longrightarrow>\n        netsDistinct a ba;\n     x \\<noteq> y \\<and>\n     x \\<in> set (net_list_aux a) \\<and>\n     y \\<in> set (net_list_aux a)\\<rbrakk>\n    \\<Longrightarrow> netsDistinct x y", "apply (drule_tac x = \"x\" in spec, drule_tac x = \"y\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators a; singleCombinators b; set a = set b;\n     x \\<noteq> y \\<and>\n     x \\<in> set (net_list_aux a) \\<and> y \\<in> set (net_list_aux a);\n     x \\<noteq> y \\<and>\n     x \\<in> set (net_list_aux b) \\<and>\n     y \\<in> set (net_list_aux b) \\<longrightarrow>\n     netsDistinct x y\\<rbrakk>\n    \\<Longrightarrow> netsDistinct x y", "using aNDSetsEqaux"], ["proof (prove)\nusing this:\n  \\<lbrakk>singleCombinators ?a; singleCombinators ?b;\n   set ?a = set ?b\\<rbrakk>\n  \\<Longrightarrow> set (net_list_aux ?a) = set (net_list_aux ?b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators a; singleCombinators b; set a = set b;\n     x \\<noteq> y \\<and>\n     x \\<in> set (net_list_aux a) \\<and> y \\<in> set (net_list_aux a);\n     x \\<noteq> y \\<and>\n     x \\<in> set (net_list_aux b) \\<and>\n     y \\<in> set (net_list_aux b) \\<longrightarrow>\n     netsDistinct x y\\<rbrakk>\n    \\<Longrightarrow> netsDistinct x y", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SCConca: \"\\<lbrakk>singleCombinators p; singleCombinators [a]\\<rbrakk> \\<Longrightarrow> \n                singleCombinators (a#p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; singleCombinators [a]\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (a # p)", "by(metis aux0_1)"], ["", "lemma aux3[simp]: \"\\<lbrakk>singleCombinators p; singleCombinators [a];  \n                     allNetsDistinct (a#p)\\<rbrakk> \\<Longrightarrow> allNetsDistinct (a#a#p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; singleCombinators [a];\n     allNetsDistinct (a # p)\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct (a # a # p)", "by (metis aNDSetsEq aux0_1 insert_absorb2 list.set(2))"], ["", "lemma wp1_aux1a[rule_format]: \"xs \\<noteq> [] \\<longrightarrow> wellformed_policy1_strong (xs @ [x]) \\<longrightarrow> \n                               wellformed_policy1_strong xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<longrightarrow>\n    wellformed_policy1_strong (xs @ [x]) \\<longrightarrow>\n    wellformed_policy1_strong xs", "by (induct xs,simp_all)"], ["", "lemma wp1alternative_RS1[rule_format]: \"DenyAll \\<in> set p \\<longrightarrow> \n                              wellformed_policy1_strong (removeShadowRules1 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set p \\<longrightarrow>\n    wellformed_policy1_strong (removeShadowRules1 p)", "by (induct p,simp_all)"], ["", "lemma wellformed_eq: \"DenyAll \\<in> set p \\<longrightarrow> \n                      ((wellformed_policy1 p) = (wellformed_policy1_strong p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set p \\<longrightarrow>\n    wellformed_policy1 p = wellformed_policy1_strong p", "by (induct p,simp_all)"], ["", "lemma set_insort: \"set(insort x xs l) = insert x (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (FWNormalisationCore.insort x xs l) = insert x (set xs)", "by (induct xs) auto"], ["", "lemma set_sort[simp]: \"set(sort xs l) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (FWNormalisationCore.sort xs l) = set xs", "by (induct xs) (simp_all add:set_insort)"], ["", "lemma set_sortQ: \"set(qsort xs l) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (qsort xs l) = set xs", "by simp"], ["", "lemma aux79[rule_format]: \"y \\<in> set (insort x a l) \\<longrightarrow>  y \\<noteq> x \\<longrightarrow> y \\<in> set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set (FWNormalisationCore.insort x a l) \\<longrightarrow>\n    y \\<noteq> x \\<longrightarrow> y \\<in> set a", "apply (induct a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y \\<in> set (FWNormalisationCore.insort x [] l) \\<longrightarrow>\n    y \\<noteq> x \\<longrightarrow> y \\<in> set []\n 2. \\<And>a1 a2.\n       y \\<in> set (FWNormalisationCore.insort x a2 l) \\<longrightarrow>\n       y \\<noteq> x \\<longrightarrow> y \\<in> set a2 \\<Longrightarrow>\n       y \\<in> set (FWNormalisationCore.insort x (a1 # a2)\n                     l) \\<longrightarrow>\n       y \\<noteq> x \\<longrightarrow> y \\<in> set (a1 # a2)", "by auto"], ["", "lemma aux80: \"\\<lbrakk>y \\<notin> set p; y \\<noteq> x\\<rbrakk> \\<Longrightarrow> y \\<notin> set (insort x (sort p l) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<notin> set p; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> y \\<notin> set (FWNormalisationCore.insort x\n (FWNormalisationCore.sort p l) l)", "apply (metis aux79 set_sort)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WP1Conca: \"DenyAll \\<notin> set p \\<Longrightarrow> wellformed_policy1 (a#p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<notin> set p \\<Longrightarrow> wellformed_policy1 (a # p)", "by (case_tac a,simp_all)"], ["", "lemma saux[simp]: \"(insort DenyAll p l) = DenyAll#p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.insort DenyAll p l = DenyAll # p", "by (induct_tac p,simp_all)"], ["", "lemma saux3[rule_format]: \"DenyAllFromTo a b \\<in> set list \\<longrightarrow> \n                          DenyAllFromTo c d \\<notin> set list \\<longrightarrow> (a \\<noteq> c) \\<or> (b \\<noteq> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAllFromTo a b \\<in> set list \\<longrightarrow>\n    DenyAllFromTo c d \\<notin> set list \\<longrightarrow>\n    a \\<noteq> c \\<or> b \\<noteq> d", "by blast"], ["", "lemma waux2[rule_format]: \" (DenyAll \\<notin> set xs) \\<longrightarrow> wellformed_policy1 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<notin> set xs \\<longrightarrow> wellformed_policy1 xs", "by (induct_tac xs,simp_all)"], ["", "lemma waux3[rule_format]: \"\\<lbrakk>x \\<noteq> a;  x \\<notin> set p\\<rbrakk> \\<Longrightarrow> x \\<notin> set (insort a p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> a; x \\<notin> set p\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (FWNormalisationCore.insort a p l)", "by (metis aux79)"], ["", "lemma wellformed1_sorted_aux[rule_format]: \"wellformed_policy1 (x#p) \\<Longrightarrow> \n                                            wellformed_policy1 (insort x p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1 (x # p) \\<Longrightarrow>\n    wellformed_policy1 (FWNormalisationCore.insort x p l)", "by (metis NormalisationGenericProofs.set_insort list.set(2) saux waux2 wellformed_eq \n            wellformed_policy1_strong.simps(2))"], ["", "lemma wellformed1_sorted_auxQ[rule_format]: \"wellformed_policy1 (p) \\<Longrightarrow> \n                                            wellformed_policy1 (qsort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1 p \\<Longrightarrow> wellformed_policy1 (qsort p l)", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. wellformed_policy1 [] \\<Longrightarrow> wellformed_policy1 (qsort [] l)\n 2. \\<And>a p.\n       \\<lbrakk>wellformed_policy1 p \\<Longrightarrow>\n                wellformed_policy1 (qsort p l);\n        wellformed_policy1 (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy1 (qsort (a # p) l)", "case Nil"], ["proof (state)\nthis:\n  wellformed_policy1 []\n\ngoal (2 subgoals):\n 1. wellformed_policy1 [] \\<Longrightarrow> wellformed_policy1 (qsort [] l)\n 2. \\<And>a p.\n       \\<lbrakk>wellformed_policy1 p \\<Longrightarrow>\n                wellformed_policy1 (qsort p l);\n        wellformed_policy1 (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy1 (qsort (a # p) l)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1 (qsort [] l)", "by simp"], ["proof (state)\nthis:\n  wellformed_policy1 (qsort [] l)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>wellformed_policy1 p \\<Longrightarrow>\n                wellformed_policy1 (qsort p l);\n        wellformed_policy1 (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy1 (qsort (a # p) l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>wellformed_policy1 p \\<Longrightarrow>\n                wellformed_policy1 (qsort p l);\n        wellformed_policy1 (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy1 (qsort (a # p) l)", "case (Cons a S)"], ["proof (state)\nthis:\n  wellformed_policy1 S \\<Longrightarrow> wellformed_policy1 (qsort S l)\n  wellformed_policy1 (a # S)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>wellformed_policy1 p \\<Longrightarrow>\n                wellformed_policy1 (qsort p l);\n        wellformed_policy1 (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy1 (qsort (a # p) l)", "then"], ["proof (chain)\npicking this:\n  wellformed_policy1 S \\<Longrightarrow> wellformed_policy1 (qsort S l)\n  wellformed_policy1 (a # S)", "show ?case"], ["proof (prove)\nusing this:\n  wellformed_policy1 S \\<Longrightarrow> wellformed_policy1 (qsort S l)\n  wellformed_policy1 (a # S)\n\ngoal (1 subgoal):\n 1. wellformed_policy1 (qsort (a # S) l)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1 S \\<Longrightarrow>\n             wellformed_policy1 (qsort S l);\n     DenyAll \\<notin> set S\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1\n                       (qsort (filter (\\<lambda>y. \\<not> smaller a y l) S)\n                         l @\n                        a # qsort (filter (\\<lambda>y. smaller a y l) S) l)", "apply (cases a,simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>wellformed_policy1 S \\<Longrightarrow>\n                wellformed_policy1 (qsort S l);\n        DenyAll \\<notin> set S; a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy1\n                          (qsort\n                            (filter\n                              (\\<lambda>y.\n                                  \\<not> smaller (DenyAllFromTo x21 x22) y\n    l)\n                              S)\n                            l @\n                           DenyAllFromTo x21 x22 #\n                           qsort\n                            (filter\n                              (\\<lambda>y.\n                                  smaller (DenyAllFromTo x21 x22) y l)\n                              S)\n                            l)\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>wellformed_policy1 S \\<Longrightarrow>\n                wellformed_policy1 (qsort S l);\n        DenyAll \\<notin> set S; a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy1\n                          (qsort\n                            (filter\n                              (\\<lambda>y.\n                                  \\<not> smaller\n    (AllowPortFromTo x31 x32 x33) y l)\n                              S)\n                            l @\n                           AllowPortFromTo x31 x32 x33 #\n                           qsort\n                            (filter\n                              (\\<lambda>y.\n                                  smaller (AllowPortFromTo x31 x32 x33) y l)\n                              S)\n                            l)\n 3. \\<And>x41 x42.\n       \\<lbrakk>wellformed_policy1 S \\<Longrightarrow>\n                wellformed_policy1 (qsort S l);\n        DenyAll \\<notin> set S; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy1\n                          (qsort\n                            (filter\n                              (\\<lambda>y.\n                                  \\<not> smaller (x41 \\<oplus> x42) y l)\n                              S)\n                            l @\n                           x41 \\<oplus> x42 #\n                           qsort\n                            (filter\n                              (\\<lambda>y. smaller (x41 \\<oplus> x42) y l)\n                              S)\n                            l)", "by  (metis Combinators.simps append_Cons append_Nil qsort.simps(2) set_ConsD set_qsort waux2)+"], ["proof (state)\nthis:\n  wellformed_policy1 (qsort (a # S) l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SR1Subset: \"set (removeShadowRules1 p) \\<subseteq> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (removeShadowRules1 p) \\<subseteq> set p", "apply (induct_tac p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       set (removeShadowRules1 list) \\<subseteq> set list \\<Longrightarrow>\n       DenyAll \\<in> set list \\<longrightarrow>\n       set (removeShadowRules1 list) \\<subseteq> insert a (set list)", "subgoal for x xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (removeShadowRules1 xs) \\<subseteq> set xs \\<Longrightarrow>\n    DenyAll \\<in> set xs \\<longrightarrow>\n    set (removeShadowRules1 xs) \\<subseteq> insert x (set xs)", "apply (case_tac \"x\", simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>set (removeShadowRules1 xs) \\<subseteq> set xs;\n     x = DenyAll\\<rbrakk>\n    \\<Longrightarrow> DenyAll \\<in> set xs \\<longrightarrow>\n                      set (removeShadowRules1 xs)\n                      \\<subseteq> insert DenyAll (set xs)\n 2. \\<And>x21 x22.\n       \\<lbrakk>set (removeShadowRules1 xs) \\<subseteq> set xs;\n        x = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> DenyAll \\<in> set xs \\<longrightarrow>\n                         set (removeShadowRules1 xs)\n                         \\<subseteq> insert (DenyAllFromTo x21 x22) (set xs)\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>set (removeShadowRules1 xs) \\<subseteq> set xs;\n        x = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> DenyAll \\<in> set xs \\<longrightarrow>\n                         set (removeShadowRules1 xs)\n                         \\<subseteq> insert (AllowPortFromTo x31 x32 x33)\n(set xs)\n 4. \\<And>x41 x42.\n       \\<lbrakk>set (removeShadowRules1 xs) \\<subseteq> set xs;\n        x = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> DenyAll \\<in> set xs \\<longrightarrow>\n                         set (removeShadowRules1 xs)\n                         \\<subseteq> insert (x41 \\<oplus> x42) (set xs)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SCSubset[rule_format]: \" singleCombinators b \\<longrightarrow> set a \\<subseteq> set b \\<longrightarrow>\n                              singleCombinators a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators b \\<longrightarrow>\n    set a \\<subseteq> set b \\<longrightarrow> singleCombinators a", "proof (induct a)"], ["proof (state)\ngoal (2 subgoals):\n 1. singleCombinators b \\<longrightarrow>\n    set [] \\<subseteq> set b \\<longrightarrow> singleCombinators []\n 2. \\<And>a1 a2.\n       singleCombinators b \\<longrightarrow>\n       set a2 \\<subseteq> set b \\<longrightarrow>\n       singleCombinators a2 \\<Longrightarrow>\n       singleCombinators b \\<longrightarrow>\n       set (a1 # a2) \\<subseteq> set b \\<longrightarrow>\n       singleCombinators (a1 # a2)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. singleCombinators b \\<longrightarrow>\n    set [] \\<subseteq> set b \\<longrightarrow> singleCombinators []\n 2. \\<And>a1 a2.\n       singleCombinators b \\<longrightarrow>\n       set a2 \\<subseteq> set b \\<longrightarrow>\n       singleCombinators a2 \\<Longrightarrow>\n       singleCombinators b \\<longrightarrow>\n       set (a1 # a2) \\<subseteq> set b \\<longrightarrow>\n       singleCombinators (a1 # a2)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators b \\<longrightarrow>\n    set [] \\<subseteq> set b \\<longrightarrow> singleCombinators []", "by simp"], ["proof (state)\nthis:\n  singleCombinators b \\<longrightarrow>\n  set [] \\<subseteq> set b \\<longrightarrow> singleCombinators []\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       singleCombinators b \\<longrightarrow>\n       set a2 \\<subseteq> set b \\<longrightarrow>\n       singleCombinators a2 \\<Longrightarrow>\n       singleCombinators b \\<longrightarrow>\n       set (a1 # a2) \\<subseteq> set b \\<longrightarrow>\n       singleCombinators (a1 # a2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       singleCombinators b \\<longrightarrow>\n       set a2 \\<subseteq> set b \\<longrightarrow>\n       singleCombinators a2 \\<Longrightarrow>\n       singleCombinators b \\<longrightarrow>\n       set (a1 # a2) \\<subseteq> set b \\<longrightarrow>\n       singleCombinators (a1 # a2)", "case (Cons x xs)"], ["proof (state)\nthis:\n  singleCombinators b \\<longrightarrow>\n  set xs \\<subseteq> set b \\<longrightarrow> singleCombinators xs\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       singleCombinators b \\<longrightarrow>\n       set a2 \\<subseteq> set b \\<longrightarrow>\n       singleCombinators a2 \\<Longrightarrow>\n       singleCombinators b \\<longrightarrow>\n       set (a1 # a2) \\<subseteq> set b \\<longrightarrow>\n       singleCombinators (a1 # a2)", "thus ?case"], ["proof (prove)\nusing this:\n  singleCombinators b \\<longrightarrow>\n  set xs \\<subseteq> set b \\<longrightarrow> singleCombinators xs\n\ngoal (1 subgoal):\n 1. singleCombinators b \\<longrightarrow>\n    set (x # xs) \\<subseteq> set b \\<longrightarrow>\n    singleCombinators (x # xs)", "by (meson aux0_0 aux0_5 subsetCE)"], ["proof (state)\nthis:\n  singleCombinators b \\<longrightarrow>\n  set (x # xs) \\<subseteq> set b \\<longrightarrow>\n  singleCombinators (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma setInsert[simp]: \"set list \\<subseteq> insert a (set list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set list \\<subseteq> insert a (set list)", "by auto"], ["", "lemma SC_RS1[rule_format,simp]: \"singleCombinators p \\<longrightarrow> allNetsDistinct p \\<longrightarrow>\n    singleCombinators (removeShadowRules1 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<longrightarrow>\n    allNetsDistinct p \\<longrightarrow>\n    singleCombinators (removeShadowRules1 p)", "apply (induct_tac p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. singleCombinators [] \\<longrightarrow>\n    allNetsDistinct [] \\<longrightarrow>\n    singleCombinators (removeShadowRules1 [])\n 2. \\<And>a list.\n       singleCombinators list \\<longrightarrow>\n       allNetsDistinct list \\<longrightarrow>\n       singleCombinators (removeShadowRules1 list) \\<Longrightarrow>\n       singleCombinators (a # list) \\<longrightarrow>\n       allNetsDistinct (a # list) \\<longrightarrow>\n       singleCombinators (removeShadowRules1 (a # list))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       singleCombinators list \\<longrightarrow>\n       allNetsDistinct list \\<longrightarrow>\n       singleCombinators (removeShadowRules1 list) \\<Longrightarrow>\n       DenyAll \\<in> set list \\<longrightarrow>\n       singleCombinators (a # list) \\<longrightarrow>\n       allNetsDistinct (a # list) \\<longrightarrow>\n       singleCombinators (removeShadowRules1 list)", "using ANDConc singleCombinatorsConc"], ["proof (prove)\nusing this:\n  allNetsDistinct (?a # ?p) \\<Longrightarrow> allNetsDistinct ?p\n  singleCombinators (?x # ?xs) \\<Longrightarrow> singleCombinators ?xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       singleCombinators list \\<longrightarrow>\n       allNetsDistinct list \\<longrightarrow>\n       singleCombinators (removeShadowRules1 list) \\<Longrightarrow>\n       DenyAll \\<in> set list \\<longrightarrow>\n       singleCombinators (a # list) \\<longrightarrow>\n       allNetsDistinct (a # list) \\<longrightarrow>\n       singleCombinators (removeShadowRules1 list)", "by blast"], ["", "lemma RS2Set[rule_format]: \"set (removeShadowRules2 p) \\<subseteq> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (removeShadowRules2 p) \\<subseteq> set p", "apply(induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       set (removeShadowRules2 p) \\<subseteq> set p \\<Longrightarrow>\n       set (removeShadowRules2 (a # p)) \\<subseteq> insert a (set p)", "subgoal for a as"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (removeShadowRules2 as) \\<subseteq> set as \\<Longrightarrow>\n    set (removeShadowRules2 (a # as)) \\<subseteq> insert a (set as)", "apply(case_tac a)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>set (removeShadowRules2 as) \\<subseteq> set as;\n     a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> set (removeShadowRules2 (a # as))\n                      \\<subseteq> insert a (set as)\n 2. \\<And>x21 x22.\n       \\<lbrakk>set (removeShadowRules2 as) \\<subseteq> set as;\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> set (removeShadowRules2 (a # as))\n                         \\<subseteq> insert a (set as)\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>set (removeShadowRules2 as) \\<subseteq> set as;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> set (removeShadowRules2 (a # as))\n                         \\<subseteq> insert a (set as)\n 4. \\<And>x41 x42.\n       \\<lbrakk>set (removeShadowRules2 as) \\<subseteq> set as;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> set (removeShadowRules2 (a # as))\n                         \\<subseteq> insert a (set as)", "by(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WP1: \"a \\<notin> set list \\<Longrightarrow> a \\<notin> set (removeShadowRules2 list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> set list \\<Longrightarrow>\n    a \\<notin> set (removeShadowRules2 list)", "using RS2Set [of list]"], ["proof (prove)\nusing this:\n  set (removeShadowRules2 list) \\<subseteq> set list\n\ngoal (1 subgoal):\n 1. a \\<notin> set list \\<Longrightarrow>\n    a \\<notin> set (removeShadowRules2 list)", "by blast"], ["", "lemma denyAllDom[simp]: \"x \\<in> dom (deny_all)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom D\\<^sub>U", "by (simp add: UPFDefs(24) domI)"], ["", "lemma lCdom2: \"(list2FWpolicy (a @ (b @ c))) = (list2FWpolicy ((a@b)@c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list2FWpolicy (a @ b @ c) = list2FWpolicy ((a @ b) @ c)", "by auto"], ["", "lemma SCConcEnd: \"singleCombinators (xs @ [xa]) \\<Longrightarrow> singleCombinators xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators (xs @ [xa]) \\<Longrightarrow> singleCombinators xs", "apply (induct \"xs\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>singleCombinators (xs @ [xa]) \\<Longrightarrow>\n                singleCombinators xs;\n        singleCombinators (a # xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> singleCombinators (a # xs)", "subgoal for a as"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators (as @ [xa]) \\<Longrightarrow>\n             singleCombinators as;\n     singleCombinators (a # as @ [xa])\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (a # as)", "by  (case_tac \"a\" , simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list2FWpolicyconc[rule_format]: \"a \\<noteq> [] \\<longrightarrow>\n                               (list2FWpolicy (xa # a)) = (xa) \\<oplus> (list2FWpolicy a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> [] \\<longrightarrow>\n    list2FWpolicy (xa # a) = xa \\<oplus> list2FWpolicy a", "by (induct a,simp_all)"], ["", "lemma wp1n_tl [rule_format]: \"wellformed_policy1_strong p \\<longrightarrow>\n                              p = (DenyAll#(tl p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<longrightarrow> p = DenyAll # tl p", "by (induct p, simp_all)"], ["", "lemma foo2: \"a \\<notin> set ps \\<Longrightarrow> \n             a \\<notin> set ss \\<Longrightarrow>\n             set p = set s \\<Longrightarrow> \n             p = (a#(ps)) \\<Longrightarrow> \n             s = (a#ss) \\<Longrightarrow> \n             set (ps) = set (ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<notin> set ps; a \\<notin> set ss; set p = set s;\n     p = a # ps; s = a # ss\\<rbrakk>\n    \\<Longrightarrow> set ps = set ss", "by auto"], ["", "lemma SCnotConc[rule_format,simp]: \"a\\<oplus>b \\<in> set p \\<longrightarrow> singleCombinators p \\<longrightarrow>False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<oplus> b \\<in> set p \\<longrightarrow>\n    singleCombinators p \\<longrightarrow> False", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       a \\<oplus> b \\<in> set p \\<longrightarrow>\n       \\<not> singleCombinators p \\<Longrightarrow>\n       (a \\<oplus> b = aa \\<longrightarrow>\n        \\<not> singleCombinators (aa # p)) \\<and>\n       (a \\<oplus> b \\<in> set p \\<longrightarrow>\n        \\<not> singleCombinators (aa # p))", "subgoal for p ps"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<oplus> b \\<in> set ps \\<longrightarrow>\n    \\<not> singleCombinators ps \\<Longrightarrow>\n    (a \\<oplus> b = p \\<longrightarrow>\n     \\<not> singleCombinators (p # ps)) \\<and>\n    (a \\<oplus> b \\<in> set ps \\<longrightarrow>\n     \\<not> singleCombinators (p # ps))", "by(case_tac p, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma auxx8: \"removeShadowRules1_alternative_rev [x] = [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeShadowRules1_alternative_rev [x] = [x]", "by (case_tac \"x\", simp_all)"], ["", "lemma RS1End[rule_format]: \"x \\<noteq> DenyAll \\<longrightarrow> removeShadowRules1 (xs @ [x]) = \n                            (removeShadowRules1 xs)@[x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> DenyAll \\<longrightarrow>\n    removeShadowRules1 (xs @ [x]) = removeShadowRules1 xs @ [x]", "by (induct_tac xs, simp_all)"], ["", "lemma aux114: \"x \\<noteq> DenyAll \\<Longrightarrow> removeShadowRules1_alternative_rev (x#xs) = \n               x#(removeShadowRules1_alternative_rev xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> DenyAll \\<Longrightarrow>\n    removeShadowRules1_alternative_rev (x # xs) =\n    x # removeShadowRules1_alternative_rev xs", "apply (induct_tac xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<noteq> DenyAll \\<Longrightarrow>\n    removeShadowRules1_alternative_rev [x] =\n    x # removeShadowRules1_alternative_rev []\n 2. \\<And>a list.\n       \\<lbrakk>x \\<noteq> DenyAll;\n        removeShadowRules1_alternative_rev (x # list) =\n        x # removeShadowRules1_alternative_rev list\\<rbrakk>\n       \\<Longrightarrow> removeShadowRules1_alternative_rev (x # a # list) =\n                         x # removeShadowRules1_alternative_rev (a # list)", "apply (auto simp: auxx8)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>x \\<noteq> DenyAll;\n        removeShadowRules1_alternative_rev (x # list) =\n        x # removeShadowRules1_alternative_rev list\\<rbrakk>\n       \\<Longrightarrow> removeShadowRules1_alternative_rev (x # a # list) =\n                         x # removeShadowRules1_alternative_rev (a # list)", "by (case_tac \"x\", simp_all)"], ["", "lemma aux115[rule_format]: \"x \\<noteq> DenyAll\\<Longrightarrow>removeShadowRules1_alternative (xs@[x]) \n                            = (removeShadowRules1_alternative xs)@[x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> DenyAll \\<Longrightarrow>\n    removeShadowRules1_alternative (xs @ [x]) =\n    removeShadowRules1_alternative xs @ [x]", "apply (simp add: removeShadowRules1_alternative_def aux114)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma RS1_DA[simp]: \"removeShadowRules1 (xs @ [DenyAll]) = [DenyAll]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeShadowRules1 (xs @ [DenyAll]) = [DenyAll]", "by (induct_tac xs, simp_all)"], ["", "lemma rSR1_eq: \"removeShadowRules1_alternative = removeShadowRules1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeShadowRules1_alternative = removeShadowRules1", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. removeShadowRules1_alternative x = removeShadowRules1 x", "apply (simp add: removeShadowRules1_alternative_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rev (removeShadowRules1_alternative_rev (rev x)) =\n       removeShadowRules1 x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (removeShadowRules1_alternative_rev (rev x)) = removeShadowRules1 x", "apply (rule_tac xs = x in rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rev (removeShadowRules1_alternative_rev (rev [])) =\n    removeShadowRules1 []\n 2. \\<And>x xs.\n       rev (removeShadowRules1_alternative_rev (rev xs)) =\n       removeShadowRules1 xs \\<Longrightarrow>\n       rev (removeShadowRules1_alternative_rev (rev (xs @ [x]))) =\n       removeShadowRules1 (xs @ [x])", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       rev (removeShadowRules1_alternative_rev (rev xs)) =\n       removeShadowRules1 xs \\<Longrightarrow>\n       rev (removeShadowRules1_alternative_rev (x # rev xs)) =\n       removeShadowRules1 (xs @ [x])", "subgoal for x xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (removeShadowRules1_alternative_rev (rev xs)) =\n    removeShadowRules1 xs \\<Longrightarrow>\n    rev (removeShadowRules1_alternative_rev (x # rev xs)) =\n    removeShadowRules1 (xs @ [x])", "apply (case_tac \"x = DenyAll\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rev (removeShadowRules1_alternative_rev (rev xs)) =\n             removeShadowRules1 xs;\n     x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> rev (removeShadowRules1_alternative_rev\n                            (x # rev xs)) =\n                      removeShadowRules1 (xs @ [x])", "apply (metis RS1End aux114 rev.simps(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma domInterMT[rule_format]: \"\\<lbrakk>dom a \\<inter> dom b = {}; x \\<in> dom a\\<rbrakk> \\<Longrightarrow> x \\<notin> dom b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom a \\<inter> dom b = {}; x \\<in> dom a\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom b", "by auto"], ["", "lemma domComm: \"dom a \\<inter> dom b = dom b \\<inter> dom a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom a \\<inter> dom b = dom b \\<inter> dom a", "by auto"], ["", "lemma r_not_DA_in_tl[rule_format]: \n  \"wellformed_policy1_strong p \\<longrightarrow>  a \\<in> set p\\<longrightarrow> a \\<noteq> DenyAll \\<longrightarrow> a \\<in> set (tl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<longrightarrow>\n    a \\<in> set p \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow> a \\<in> set (tl p)", "by (induct p,simp_all)"], ["", "lemma wp1_aux1aa[rule_format]: \"wellformed_policy1_strong p \\<longrightarrow> DenyAll \\<in> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<longrightarrow> DenyAll \\<in> set p", "by (induct p,simp_all)"], ["", "lemma mauxa: \"(\\<exists> r. a b = \\<lfloor>r\\<rfloor>) = (a b \\<noteq> \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>r. a b = \\<lfloor>r\\<rfloor>) = (a b \\<noteq> \\<bottom>)", "by auto"], ["", "lemma l2p_aux[rule_format]: \"list \\<noteq> [] \\<longrightarrow>\n                             list2FWpolicy (a # list) = a \\<oplus>(list2FWpolicy list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list \\<noteq> [] \\<longrightarrow>\n    list2FWpolicy (a # list) = a \\<oplus> list2FWpolicy list", "by (induct \"list\", simp_all)"], ["", "lemma l2p_aux2[rule_format]: \"list = [] \\<Longrightarrow> list2FWpolicy (a # list) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list = [] \\<Longrightarrow> list2FWpolicy (a # list) = a", "by simp"], ["", "lemma aux7aa: \n  assumes 1 : \"AllowPortFromTo a b poo \\<in> set p\" \n    and    2 : \"allNetsDistinct ((AllowPortFromTo c d po) # p)\"\n    and    3 : \"a \\<noteq> c \\<or> b \\<noteq> d\"\n  shows       \"twoNetsDistinct a b c d\" (is \"?H\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. twoNetsDistinct a b c d", "proof(cases \"a \\<noteq> c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<noteq> c \\<Longrightarrow> twoNetsDistinct a b c d\n 2. \\<not> a \\<noteq> c \\<Longrightarrow> twoNetsDistinct a b c d", "print_cases"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<noteq> c \\<Longrightarrow> twoNetsDistinct a b c d\n 2. \\<not> a \\<noteq> c \\<Longrightarrow> twoNetsDistinct a b c d", "case True"], ["proof (state)\nthis:\n  a \\<noteq> c\n\ngoal (2 subgoals):\n 1. a \\<noteq> c \\<Longrightarrow> twoNetsDistinct a b c d\n 2. \\<not> a \\<noteq> c \\<Longrightarrow> twoNetsDistinct a b c d", "assume *:\"a \\<noteq> c\""], ["proof (state)\nthis:\n  a \\<noteq> c\n\ngoal (2 subgoals):\n 1. a \\<noteq> c \\<Longrightarrow> twoNetsDistinct a b c d\n 2. \\<not> a \\<noteq> c \\<Longrightarrow> twoNetsDistinct a b c d", "show ?H"], ["proof (prove)\ngoal (1 subgoal):\n 1. twoNetsDistinct a b c d", "by (meson \"1\" \"2\" True allNetsDistinct_def aux5c list.set_intros(1) \n        list.set_intros(2) twoNetsDistinct_def)"], ["proof (state)\nthis:\n  twoNetsDistinct a b c d\n\ngoal (1 subgoal):\n 1. \\<not> a \\<noteq> c \\<Longrightarrow> twoNetsDistinct a b c d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a \\<noteq> c \\<Longrightarrow> twoNetsDistinct a b c d", "case False"], ["proof (state)\nthis:\n  \\<not> a \\<noteq> c\n\ngoal (1 subgoal):\n 1. \\<not> a \\<noteq> c \\<Longrightarrow> twoNetsDistinct a b c d", "assume *:\"\\<not>(a \\<noteq> c)\""], ["proof (state)\nthis:\n  \\<not> a \\<noteq> c\n\ngoal (1 subgoal):\n 1. \\<not> a \\<noteq> c \\<Longrightarrow> twoNetsDistinct a b c d", "show \"twoNetsDistinct a b c d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. twoNetsDistinct a b c d", "by (meson \"1\" \"2\" \"3\" False allNetsDistinct_def aux5d list.set_intros(1) \n        list.set_intros(2) twoNetsDistinct_def)"], ["proof (state)\nthis:\n  twoNetsDistinct a b c d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ANDConcEnd: \"\\<lbrakk> allNetsDistinct (xs @ [xa]); singleCombinators xs\\<rbrakk> \\<Longrightarrow> \n                   allNetsDistinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allNetsDistinct (xs @ [xa]); singleCombinators xs\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct xs", "by (rule aNDSubset, auto)"], ["", "lemma WP1ConcEnd[rule_format]: \n  \"wellformed_policy1 (xs@[xa]) \\<longrightarrow> wellformed_policy1 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1 (xs @ [xa]) \\<longrightarrow> wellformed_policy1 xs", "by (induct xs, simp_all)"], ["", "lemma NDComm: \"netsDistinct a b = netsDistinct b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. netsDistinct a b = netsDistinct b a", "by (auto simp: netsDistinct_def in_subnet_def)"], ["", "lemma wellformed1_sorted[simp]: \n  assumes wp1: \"wellformed_policy1 p\" \n  shows        \"wellformed_policy1 (sort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1 (FWNormalisationCore.sort p l)", "proof (cases p)"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    wellformed_policy1 (FWNormalisationCore.sort p l)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       wellformed_policy1 (FWNormalisationCore.sort p l)", "case Nil"], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    wellformed_policy1 (FWNormalisationCore.sort p l)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       wellformed_policy1 (FWNormalisationCore.sort p l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = []\n\ngoal (1 subgoal):\n 1. wellformed_policy1 (FWNormalisationCore.sort p l)", "by simp"], ["proof (state)\nthis:\n  wellformed_policy1 (FWNormalisationCore.sort p l)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       wellformed_policy1 (FWNormalisationCore.sort p l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       wellformed_policy1 (FWNormalisationCore.sort p l)", "case (Cons x xs)"], ["proof (state)\nthis:\n  p = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       wellformed_policy1 (FWNormalisationCore.sort p l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = x # xs\n\ngoal (1 subgoal):\n 1. wellformed_policy1 (FWNormalisationCore.sort p l)", "proof (cases \"x = DenyAll\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = x # xs; x = DenyAll\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 (FWNormalisationCore.sort p l)\n 2. \\<lbrakk>p = x # xs; x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 (FWNormalisationCore.sort p l)", "case True"], ["proof (state)\nthis:\n  x = DenyAll\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p = x # xs; x = DenyAll\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 (FWNormalisationCore.sort p l)\n 2. \\<lbrakk>p = x # xs; x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 (FWNormalisationCore.sort p l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = DenyAll\n\ngoal (1 subgoal):\n 1. wellformed_policy1 (FWNormalisationCore.sort p l)", "using assms Cons"], ["proof (prove)\nusing this:\n  x = DenyAll\n  wellformed_policy1 p\n  p = x # xs\n\ngoal (1 subgoal):\n 1. wellformed_policy1 (FWNormalisationCore.sort p l)", "by simp"], ["proof (state)\nthis:\n  wellformed_policy1 (FWNormalisationCore.sort p l)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = x # xs; x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 (FWNormalisationCore.sort p l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = x # xs; x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 (FWNormalisationCore.sort p l)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> DenyAll\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = x # xs; x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 (FWNormalisationCore.sort p l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> DenyAll\n\ngoal (1 subgoal):\n 1. wellformed_policy1 (FWNormalisationCore.sort p l)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> DenyAll\n  wellformed_policy1 p\n\ngoal (1 subgoal):\n 1. wellformed_policy1 (FWNormalisationCore.sort p l)", "by (metis Cons set_sort False waux2 wellformed_eq \n          wellformed_policy1_strong.simps(2))"], ["proof (state)\nthis:\n  wellformed_policy1 (FWNormalisationCore.sort p l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wellformed_policy1 (FWNormalisationCore.sort p l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wellformed1_sortedQ[simp]: \n  assumes wp1: \"wellformed_policy1 p\" \n  shows        \"wellformed_policy1 (qsort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1 (qsort p l)", "proof (cases p)"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> wellformed_policy1 (qsort p l)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow> wellformed_policy1 (qsort p l)", "case Nil"], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> wellformed_policy1 (qsort p l)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow> wellformed_policy1 (qsort p l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = []\n\ngoal (1 subgoal):\n 1. wellformed_policy1 (qsort p l)", "by simp"], ["proof (state)\nthis:\n  wellformed_policy1 (qsort p l)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow> wellformed_policy1 (qsort p l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow> wellformed_policy1 (qsort p l)", "case (Cons x xs)"], ["proof (state)\nthis:\n  p = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow> wellformed_policy1 (qsort p l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = x # xs\n\ngoal (1 subgoal):\n 1. wellformed_policy1 (qsort p l)", "proof (cases \"x = DenyAll\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = x # xs; x = DenyAll\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 (qsort p l)\n 2. \\<lbrakk>p = x # xs; x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 (qsort p l)", "case True"], ["proof (state)\nthis:\n  x = DenyAll\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p = x # xs; x = DenyAll\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 (qsort p l)\n 2. \\<lbrakk>p = x # xs; x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 (qsort p l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = DenyAll\n\ngoal (1 subgoal):\n 1. wellformed_policy1 (qsort p l)", "using assms Cons"], ["proof (prove)\nusing this:\n  x = DenyAll\n  wellformed_policy1 p\n  p = x # xs\n\ngoal (1 subgoal):\n 1. wellformed_policy1 (qsort p l)", "by simp"], ["proof (state)\nthis:\n  wellformed_policy1 (qsort p l)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = x # xs; x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 (qsort p l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = x # xs; x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 (qsort p l)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> DenyAll\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = x # xs; x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 (qsort p l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> DenyAll\n\ngoal (1 subgoal):\n 1. wellformed_policy1 (qsort p l)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> DenyAll\n  wellformed_policy1 p\n\ngoal (1 subgoal):\n 1. wellformed_policy1 (qsort p l)", "by (metis Cons set_qsort False waux2 wellformed_eq \n          wellformed_policy1_strong.simps(2))"], ["proof (state)\nthis:\n  wellformed_policy1 (qsort p l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wellformed_policy1 (qsort p l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SC1[simp]: \"singleCombinators p \\<Longrightarrow>singleCombinators (removeShadowRules1 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<Longrightarrow>\n    singleCombinators (removeShadowRules1 p)", "by (erule SCSubset) (rule SR1Subset)"], ["", "lemma SC2[simp]: \"singleCombinators p \\<Longrightarrow>singleCombinators (removeShadowRules2 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<Longrightarrow>\n    singleCombinators (removeShadowRules2 p)", "by (erule SCSubset) (rule RS2Set)"], ["", "lemma SC3[simp]: \"singleCombinators p \\<Longrightarrow> singleCombinators (sort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<Longrightarrow>\n    singleCombinators (FWNormalisationCore.sort p l)", "by (erule SCSubset) simp"], ["", "lemma SC3Q[simp]: \"singleCombinators p \\<Longrightarrow> singleCombinators (qsort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<Longrightarrow> singleCombinators (qsort p l)", "by (erule SCSubset) simp"], ["", "lemma aND_RS1[simp]: \"\\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk> \\<Longrightarrow> \n                      allNetsDistinct (removeShadowRules1 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct (removeShadowRules1 p)", "apply (rule aNDSubset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (removeShadowRules1 p)\n 2. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> set (removeShadowRules1 p) \\<subseteq> set ?b\n 3. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct ?b", "apply (erule SC_RS1, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> set (removeShadowRules1 p) \\<subseteq> set p", "apply (rule SR1Subset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aND_RS2[simp]: \"\\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk> \\<Longrightarrow> \n                      allNetsDistinct (removeShadowRules2 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct (removeShadowRules2 p)", "apply (rule aNDSubset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (removeShadowRules2 p)\n 2. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> set (removeShadowRules2 p) \\<subseteq> set ?b\n 3. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct ?b", "apply (erule SC2, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> set (removeShadowRules2 p) \\<subseteq> set p", "apply (rule RS2Set)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aND_sort[simp]: \"\\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk> \\<Longrightarrow>  \n                       allNetsDistinct (sort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct (FWNormalisationCore.sort p l)", "apply (rule aNDSubset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (FWNormalisationCore.sort p l)\n 2. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> set (FWNormalisationCore.sort p l) \\<subseteq> set ?b\n 3. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct ?b", "by (erule SC3, simp_all)"], ["", "lemma aND_sortQ[simp]: \"\\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk> \\<Longrightarrow>  \n                       allNetsDistinct (qsort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct (qsort p l)", "apply (rule aNDSubset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (qsort p l)\n 2. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> set (qsort p l) \\<subseteq> set ?b\n 3. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct ?b", "by (erule SC3Q, simp_all)"], ["", "lemma inRS2[rule_format,simp]: \"x \\<notin> set p \\<longrightarrow> x \\<notin> set (removeShadowRules2 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set p \\<longrightarrow> x \\<notin> set (removeShadowRules2 p)", "apply (insert RS2Set [of p])"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (removeShadowRules2 p) \\<subseteq> set p \\<Longrightarrow>\n    x \\<notin> set p \\<longrightarrow> x \\<notin> set (removeShadowRules2 p)", "by blast"], ["", "lemma distinct_RS2[rule_format,simp]: \"distinct p \\<longrightarrow> \n                                       distinct (removeShadowRules2 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct p \\<longrightarrow> distinct (removeShadowRules2 p)", "apply (induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct [] \\<longrightarrow> distinct (removeShadowRules2 [])\n 2. \\<And>a p.\n       distinct p \\<longrightarrow>\n       distinct (removeShadowRules2 p) \\<Longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       distinct (removeShadowRules2 (a # p))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       distinct p \\<longrightarrow>\n       distinct (removeShadowRules2 p) \\<Longrightarrow>\n       a \\<notin> set p \\<and> distinct p \\<longrightarrow>\n       distinct (removeShadowRules2 (a # p))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<notin> set p; distinct p;\n        distinct (removeShadowRules2 p)\\<rbrakk>\n       \\<Longrightarrow> distinct (removeShadowRules2 (a # p))", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<notin> set p; distinct p;\n     distinct (removeShadowRules2 p)\\<rbrakk>\n    \\<Longrightarrow> distinct (removeShadowRules2 (a # p))", "apply (case_tac \"a\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>a \\<notin> set p; distinct p; distinct (removeShadowRules2 p);\n     a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> distinct (removeShadowRules2 (a # p))\n 2. \\<And>x21 x22.\n       \\<lbrakk>a \\<notin> set p; distinct p;\n        distinct (removeShadowRules2 p); a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> distinct (removeShadowRules2 (a # p))\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>a \\<notin> set p; distinct p;\n        distinct (removeShadowRules2 p);\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> distinct (removeShadowRules2 (a # p))\n 4. \\<And>x41 x42.\n       \\<lbrakk>a \\<notin> set p; distinct p;\n        distinct (removeShadowRules2 p); a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> distinct (removeShadowRules2 (a # p))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma setPaireq: \" {x, y} = {a, b} \\<Longrightarrow> x = a \\<and> y = b \\<or> x = b \\<and> y = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} = {a, b} \\<Longrightarrow>\n    x = a \\<and> y = b \\<or> x = b \\<and> y = a", "by (metis  doubleton_eq_iff)"], ["", "lemma position_positive[rule_format]: \"a \\<in> set l \\<longrightarrow> position a l > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set l \\<longrightarrow> 0 < position a l", "by (induct l, simp_all)"], ["", "lemma pos_noteq[rule_format]: \n  \"a \\<in> set l \\<longrightarrow> b \\<in> set l \\<longrightarrow> c \\<in> set l \\<longrightarrow> \n   a \\<noteq> b \\<longrightarrow> position a l \\<le> position b l \\<longrightarrow> position b l \\<le> position c l \\<longrightarrow> \n   a \\<noteq> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set l \\<longrightarrow>\n    b \\<in> set l \\<longrightarrow>\n    c \\<in> set l \\<longrightarrow>\n    a \\<noteq> b \\<longrightarrow>\n    position a l \\<le> position b l \\<longrightarrow>\n    position b l \\<le> position c l \\<longrightarrow> a \\<noteq> c", "proof(induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> set [] \\<longrightarrow>\n    b \\<in> set [] \\<longrightarrow>\n    c \\<in> set [] \\<longrightarrow>\n    a \\<noteq> b \\<longrightarrow>\n    position a [] \\<le> position b [] \\<longrightarrow>\n    position b [] \\<le> position c [] \\<longrightarrow> a \\<noteq> c\n 2. \\<And>aa l.\n       a \\<in> set l \\<longrightarrow>\n       b \\<in> set l \\<longrightarrow>\n       c \\<in> set l \\<longrightarrow>\n       a \\<noteq> b \\<longrightarrow>\n       position a l \\<le> position b l \\<longrightarrow>\n       position b l \\<le> position c l \\<longrightarrow>\n       a \\<noteq> c \\<Longrightarrow>\n       a \\<in> set (aa # l) \\<longrightarrow>\n       b \\<in> set (aa # l) \\<longrightarrow>\n       c \\<in> set (aa # l) \\<longrightarrow>\n       a \\<noteq> b \\<longrightarrow>\n       position a (aa # l) \\<le> position b (aa # l) \\<longrightarrow>\n       position b (aa # l) \\<le> position c (aa # l) \\<longrightarrow>\n       a \\<noteq> c", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. a \\<in> set [] \\<longrightarrow>\n    b \\<in> set [] \\<longrightarrow>\n    c \\<in> set [] \\<longrightarrow>\n    a \\<noteq> b \\<longrightarrow>\n    position a [] \\<le> position b [] \\<longrightarrow>\n    position b [] \\<le> position c [] \\<longrightarrow> a \\<noteq> c\n 2. \\<And>aa l.\n       a \\<in> set l \\<longrightarrow>\n       b \\<in> set l \\<longrightarrow>\n       c \\<in> set l \\<longrightarrow>\n       a \\<noteq> b \\<longrightarrow>\n       position a l \\<le> position b l \\<longrightarrow>\n       position b l \\<le> position c l \\<longrightarrow>\n       a \\<noteq> c \\<Longrightarrow>\n       a \\<in> set (aa # l) \\<longrightarrow>\n       b \\<in> set (aa # l) \\<longrightarrow>\n       c \\<in> set (aa # l) \\<longrightarrow>\n       a \\<noteq> b \\<longrightarrow>\n       position a (aa # l) \\<le> position b (aa # l) \\<longrightarrow>\n       position b (aa # l) \\<le> position c (aa # l) \\<longrightarrow>\n       a \\<noteq> c", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set [] \\<longrightarrow>\n    b \\<in> set [] \\<longrightarrow>\n    c \\<in> set [] \\<longrightarrow>\n    a \\<noteq> b \\<longrightarrow>\n    position a [] \\<le> position b [] \\<longrightarrow>\n    position b [] \\<le> position c [] \\<longrightarrow> a \\<noteq> c", "by simp"], ["proof (state)\nthis:\n  a \\<in> set [] \\<longrightarrow>\n  b \\<in> set [] \\<longrightarrow>\n  c \\<in> set [] \\<longrightarrow>\n  a \\<noteq> b \\<longrightarrow>\n  position a [] \\<le> position b [] \\<longrightarrow>\n  position b [] \\<le> position c [] \\<longrightarrow> a \\<noteq> c\n\ngoal (1 subgoal):\n 1. \\<And>aa l.\n       a \\<in> set l \\<longrightarrow>\n       b \\<in> set l \\<longrightarrow>\n       c \\<in> set l \\<longrightarrow>\n       a \\<noteq> b \\<longrightarrow>\n       position a l \\<le> position b l \\<longrightarrow>\n       position b l \\<le> position c l \\<longrightarrow>\n       a \\<noteq> c \\<Longrightarrow>\n       a \\<in> set (aa # l) \\<longrightarrow>\n       b \\<in> set (aa # l) \\<longrightarrow>\n       c \\<in> set (aa # l) \\<longrightarrow>\n       a \\<noteq> b \\<longrightarrow>\n       position a (aa # l) \\<le> position b (aa # l) \\<longrightarrow>\n       position b (aa # l) \\<le> position c (aa # l) \\<longrightarrow>\n       a \\<noteq> c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa l.\n       a \\<in> set l \\<longrightarrow>\n       b \\<in> set l \\<longrightarrow>\n       c \\<in> set l \\<longrightarrow>\n       a \\<noteq> b \\<longrightarrow>\n       position a l \\<le> position b l \\<longrightarrow>\n       position b l \\<le> position c l \\<longrightarrow>\n       a \\<noteq> c \\<Longrightarrow>\n       a \\<in> set (aa # l) \\<longrightarrow>\n       b \\<in> set (aa # l) \\<longrightarrow>\n       c \\<in> set (aa # l) \\<longrightarrow>\n       a \\<noteq> b \\<longrightarrow>\n       position a (aa # l) \\<le> position b (aa # l) \\<longrightarrow>\n       position b (aa # l) \\<le> position c (aa # l) \\<longrightarrow>\n       a \\<noteq> c", "case (Cons a R)"], ["proof (state)\nthis:\n  a \\<in> set R \\<longrightarrow>\n  b \\<in> set R \\<longrightarrow>\n  c \\<in> set R \\<longrightarrow>\n  a \\<noteq> b \\<longrightarrow>\n  position a R \\<le> position b R \\<longrightarrow>\n  position b R \\<le> position c R \\<longrightarrow> a \\<noteq> c\n\ngoal (1 subgoal):\n 1. \\<And>aa l.\n       a \\<in> set l \\<longrightarrow>\n       b \\<in> set l \\<longrightarrow>\n       c \\<in> set l \\<longrightarrow>\n       a \\<noteq> b \\<longrightarrow>\n       position a l \\<le> position b l \\<longrightarrow>\n       position b l \\<le> position c l \\<longrightarrow>\n       a \\<noteq> c \\<Longrightarrow>\n       a \\<in> set (aa # l) \\<longrightarrow>\n       b \\<in> set (aa # l) \\<longrightarrow>\n       c \\<in> set (aa # l) \\<longrightarrow>\n       a \\<noteq> b \\<longrightarrow>\n       position a (aa # l) \\<le> position b (aa # l) \\<longrightarrow>\n       position b (aa # l) \\<le> position c (aa # l) \\<longrightarrow>\n       a \\<noteq> c", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (a # R) \\<longrightarrow>\n    b \\<in> set (a # R) \\<longrightarrow>\n    c \\<in> set (a # R) \\<longrightarrow>\n    a \\<noteq> b \\<longrightarrow>\n    position a (a # R) \\<le> position b (a # R) \\<longrightarrow>\n    position b (a # R) \\<le> position c (a # R) \\<longrightarrow>\n    a \\<noteq> c", "by (metis (no_types, lifting) Cons.hyps One_nat_def Suc_le_mono le_antisym \n        length_greater_0_conv list.size(3) nat.inject position.simps(2) \n        position_positive set_ConsD)"], ["proof (state)\nthis:\n  a \\<in> set (a # R) \\<longrightarrow>\n  b \\<in> set (a # R) \\<longrightarrow>\n  c \\<in> set (a # R) \\<longrightarrow>\n  a \\<noteq> b \\<longrightarrow>\n  position a (a # R) \\<le> position b (a # R) \\<longrightarrow>\n  position b (a # R) \\<le> position c (a # R) \\<longrightarrow> a \\<noteq> c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma setPair_noteq: \"{a,b} \\<noteq> {c,d} \\<Longrightarrow> \\<not> ((a = c) \\<and> (b = d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a, b} \\<noteq> {c, d} \\<Longrightarrow> \\<not> (a = c \\<and> b = d)", "by auto"], ["", "lemma setPair_noteq_allow: \"{a,b} \\<noteq> {c,d} \\<Longrightarrow> \\<not> ((a = c) \\<and> (b = d) \\<and> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a, b} \\<noteq> {c, d} \\<Longrightarrow>\n    \\<not> (a = c \\<and> b = d \\<and> P)", "by auto"], ["", "lemma order_trans:  \n  \"\\<lbrakk>in_list x l; in_list y l; in_list z l; singleCombinators [x]; \n  singleCombinators [y]; singleCombinators [z]; smaller x y l; smaller y z l\\<rbrakk> \\<Longrightarrow> \n  smaller x z l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>in_list x l; in_list y l; in_list z l; singleCombinators [x];\n     singleCombinators [y]; singleCombinators [z]; smaller x y l;\n     smaller y z l\\<rbrakk>\n    \\<Longrightarrow> smaller x z l", "apply (case_tac x, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>{x21, x22} \\<in> set l; in_list y l; in_list z l;\n        singleCombinators [y]; singleCombinators [z];\n        smaller (DenyAllFromTo x21 x22) y l; smaller y z l;\n        x = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> smaller (DenyAllFromTo x21 x22) z l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l; in_list z l;\n        singleCombinators [y]; singleCombinators [z];\n        smaller (AllowPortFromTo x31 x32 x33) y l; smaller y z l;\n        x = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33) z l", "apply (case_tac z, simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>{x21, x22} \\<in> set l; in_list y l; singleCombinators [y];\n        smaller (DenyAllFromTo x21 x22) y l; smaller y DenyAll l;\n        x = DenyAllFromTo x21 x22; z = DenyAll\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>{x21, x22} \\<in> set l; in_list y l;\n        {x21a, x22a} \\<in> set l; singleCombinators [y];\n        smaller (DenyAllFromTo x21 x22) y l;\n        smaller y (DenyAllFromTo x21a x22a) l; x = DenyAllFromTo x21 x22;\n        z = DenyAllFromTo x21a x22a\\<rbrakk>\n       \\<Longrightarrow> ({x21, x22} = {x21a, x22a} \\<longrightarrow>\n                          x21 = x21a \\<and> x22 = x22a \\<or>\n                          x21 = x22a \\<and> x22 = x21a) \\<and>\n                         ({x21, x22} \\<noteq> {x21a, x22a} \\<longrightarrow>\n                          x21 = x21a \\<and> x22 = x22a \\<or>\n                          position {x21, x22} l\n                          \\<le> position {x21a, x22a} l)\n 3. \\<And>x21 x22 x31 x32 x33.\n       \\<lbrakk>{x21, x22} \\<in> set l; in_list y l; {x31, x32} \\<in> set l;\n        singleCombinators [y]; smaller (DenyAllFromTo x21 x22) y l;\n        smaller y (AllowPortFromTo x31 x32 x33) l;\n        x = DenyAllFromTo x21 x22; z = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> {x31, x32} \\<longrightarrow>\n                         position {x21, x22} l \\<le> position {x31, x32} l\n 4. \\<And>x31 x32 x33.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l; in_list z l;\n        singleCombinators [y]; singleCombinators [z];\n        smaller (AllowPortFromTo x31 x32 x33) y l; smaller y z l;\n        x = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33) z l", "apply (case_tac y, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>{x21, x22} \\<in> set l; in_list y l;\n        {x21a, x22a} \\<in> set l; singleCombinators [y];\n        smaller (DenyAllFromTo x21 x22) y l;\n        smaller y (DenyAllFromTo x21a x22a) l; x = DenyAllFromTo x21 x22;\n        z = DenyAllFromTo x21a x22a\\<rbrakk>\n       \\<Longrightarrow> ({x21, x22} = {x21a, x22a} \\<longrightarrow>\n                          x21 = x21a \\<and> x22 = x22a \\<or>\n                          x21 = x22a \\<and> x22 = x21a) \\<and>\n                         ({x21, x22} \\<noteq> {x21a, x22a} \\<longrightarrow>\n                          x21 = x21a \\<and> x22 = x22a \\<or>\n                          position {x21, x22} l\n                          \\<le> position {x21a, x22a} l)\n 2. \\<And>x21 x22 x31 x32 x33.\n       \\<lbrakk>{x21, x22} \\<in> set l; in_list y l; {x31, x32} \\<in> set l;\n        singleCombinators [y]; smaller (DenyAllFromTo x21 x22) y l;\n        smaller y (AllowPortFromTo x31 x32 x33) l;\n        x = DenyAllFromTo x21 x22; z = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> {x31, x32} \\<longrightarrow>\n                         position {x21, x22} l \\<le> position {x31, x32} l\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l; in_list z l;\n        singleCombinators [y]; singleCombinators [z];\n        smaller (AllowPortFromTo x31 x32 x33) y l; smaller y z l;\n        x = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33) z l", "apply (case_tac y, simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x21a x22a x21b x22b.\n       \\<lbrakk>{x21, x22} \\<in> set l; {x21b, x22b} \\<in> set l;\n        {x21a, x22a} \\<in> set l;\n        x21 = x21b \\<and> x22 = x22b \\<or>\n        (if {x21, x22} = {x21b, x22b}\n         then case DenyAllFromTo x21b x22b of\n              DenyAllFromTo a b \\<Rightarrow>\n                DenyAllFromTo x21 x22 = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (DenyAllFromTo x21 x22)) l\n              \\<le> position (bothNet (DenyAllFromTo x21b x22b)) l);\n        x21b = x21a \\<and> x22b = x22a \\<or>\n        (if {x21b, x22b} = {x21a, x22a}\n         then case DenyAllFromTo x21a x22a of\n              DenyAllFromTo a b \\<Rightarrow>\n                DenyAllFromTo x21b x22b = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (DenyAllFromTo x21b x22b)) l\n              \\<le> position (bothNet (DenyAllFromTo x21a x22a)) l);\n        x = DenyAllFromTo x21 x22; z = DenyAllFromTo x21a x22a;\n        y = DenyAllFromTo x21b x22b\\<rbrakk>\n       \\<Longrightarrow> ({x21, x22} = {x21a, x22a} \\<longrightarrow>\n                          x21 = x21a \\<and> x22 = x22a \\<or>\n                          x21 = x22a \\<and> x22 = x21a) \\<and>\n                         ({x21, x22} \\<noteq> {x21a, x22a} \\<longrightarrow>\n                          x21 = x21a \\<and> x22 = x22a \\<or>\n                          position {x21, x22} l\n                          \\<le> position {x21a, x22a} l)\n 2. \\<And>x21 x22 x21a x22a x31 x32 x33.\n       \\<lbrakk>{x21, x22} \\<in> set l; {x31, x32} \\<in> set l;\n        {x21a, x22a} \\<in> set l;\n        if {x21, x22} = {x31, x32}\n        then case AllowPortFromTo x31 x32 x33 of\n             DenyAllFromTo a b \\<Rightarrow>\n               DenyAllFromTo x21 x22 = DenyAllFromTo b a\n             | _ \\<Rightarrow> True\n        else position (bothNet (DenyAllFromTo x21 x22)) l\n             \\<le> position (bothNet (AllowPortFromTo x31 x32 x33)) l;\n        if {x31, x32} = {x21a, x22a}\n        then case DenyAllFromTo x21a x22a of\n             DenyAllFromTo a b \\<Rightarrow>\n               AllowPortFromTo x31 x32 x33 = DenyAllFromTo b a\n             | _ \\<Rightarrow> True\n        else position (bothNet (AllowPortFromTo x31 x32 x33)) l\n             \\<le> position (bothNet (DenyAllFromTo x21a x22a)) l;\n        x = DenyAllFromTo x21 x22; z = DenyAllFromTo x21a x22a;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> ({x21, x22} = {x21a, x22a} \\<longrightarrow>\n                          x21 = x21a \\<and> x22 = x22a \\<or>\n                          x21 = x22a \\<and> x22 = x21a) \\<and>\n                         ({x21, x22} \\<noteq> {x21a, x22a} \\<longrightarrow>\n                          x21 = x21a \\<and> x22 = x22a \\<or>\n                          position {x21, x22} l\n                          \\<le> position {x21a, x22a} l)\n 3. \\<And>x21 x22 x31 x32 x33.\n       \\<lbrakk>{x21, x22} \\<in> set l; in_list y l; {x31, x32} \\<in> set l;\n        singleCombinators [y]; smaller (DenyAllFromTo x21 x22) y l;\n        smaller y (AllowPortFromTo x31 x32 x33) l;\n        x = DenyAllFromTo x21 x22; z = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> {x31, x32} \\<longrightarrow>\n                         position {x21, x22} l \\<le> position {x31, x32} l\n 4. \\<And>x31 x32 x33.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l; in_list z l;\n        singleCombinators [y]; singleCombinators [z];\n        smaller (AllowPortFromTo x31 x32 x33) y l; smaller y z l;\n        x = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33) z l", "apply (rule conjI|rule impI)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x21 x22 x21a x22a x21b x22b.\n       \\<lbrakk>{x21, x22} \\<in> set l; {x21b, x22b} \\<in> set l;\n        {x21a, x22a} \\<in> set l;\n        x21 = x21b \\<and> x22 = x22b \\<or>\n        (if {x21, x22} = {x21b, x22b}\n         then case DenyAllFromTo x21b x22b of\n              DenyAllFromTo a b \\<Rightarrow>\n                DenyAllFromTo x21 x22 = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (DenyAllFromTo x21 x22)) l\n              \\<le> position (bothNet (DenyAllFromTo x21b x22b)) l);\n        x21b = x21a \\<and> x22b = x22a \\<or>\n        (if {x21b, x22b} = {x21a, x22a}\n         then case DenyAllFromTo x21a x22a of\n              DenyAllFromTo a b \\<Rightarrow>\n                DenyAllFromTo x21b x22b = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (DenyAllFromTo x21b x22b)) l\n              \\<le> position (bothNet (DenyAllFromTo x21a x22a)) l);\n        x = DenyAllFromTo x21 x22; z = DenyAllFromTo x21a x22a;\n        y = DenyAllFromTo x21b x22b; {x21, x22} = {x21a, x22a}\\<rbrakk>\n       \\<Longrightarrow> x21 = x21a \\<and> x22 = x22a \\<or>\n                         x21 = x22a \\<and> x22 = x21a\n 2. \\<And>x21 x22 x21a x22a x21b x22b.\n       \\<lbrakk>{x21, x22} \\<in> set l; {x21b, x22b} \\<in> set l;\n        {x21a, x22a} \\<in> set l;\n        x21 = x21b \\<and> x22 = x22b \\<or>\n        (if {x21, x22} = {x21b, x22b}\n         then case DenyAllFromTo x21b x22b of\n              DenyAllFromTo a b \\<Rightarrow>\n                DenyAllFromTo x21 x22 = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (DenyAllFromTo x21 x22)) l\n              \\<le> position (bothNet (DenyAllFromTo x21b x22b)) l);\n        x21b = x21a \\<and> x22b = x22a \\<or>\n        (if {x21b, x22b} = {x21a, x22a}\n         then case DenyAllFromTo x21a x22a of\n              DenyAllFromTo a b \\<Rightarrow>\n                DenyAllFromTo x21b x22b = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (DenyAllFromTo x21b x22b)) l\n              \\<le> position (bothNet (DenyAllFromTo x21a x22a)) l);\n        x = DenyAllFromTo x21 x22; z = DenyAllFromTo x21a x22a;\n        y = DenyAllFromTo x21b x22b\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> {x21a, x22a} \\<longrightarrow>\n                         x21 = x21a \\<and> x22 = x22a \\<or>\n                         position {x21, x22} l \\<le> position {x21a, x22a} l\n 3. \\<And>x21 x22 x21a x22a x31 x32 x33.\n       \\<lbrakk>{x21, x22} \\<in> set l; {x31, x32} \\<in> set l;\n        {x21a, x22a} \\<in> set l;\n        if {x21, x22} = {x31, x32}\n        then case AllowPortFromTo x31 x32 x33 of\n             DenyAllFromTo a b \\<Rightarrow>\n               DenyAllFromTo x21 x22 = DenyAllFromTo b a\n             | _ \\<Rightarrow> True\n        else position (bothNet (DenyAllFromTo x21 x22)) l\n             \\<le> position (bothNet (AllowPortFromTo x31 x32 x33)) l;\n        if {x31, x32} = {x21a, x22a}\n        then case DenyAllFromTo x21a x22a of\n             DenyAllFromTo a b \\<Rightarrow>\n               AllowPortFromTo x31 x32 x33 = DenyAllFromTo b a\n             | _ \\<Rightarrow> True\n        else position (bothNet (AllowPortFromTo x31 x32 x33)) l\n             \\<le> position (bothNet (DenyAllFromTo x21a x22a)) l;\n        x = DenyAllFromTo x21 x22; z = DenyAllFromTo x21a x22a;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> ({x21, x22} = {x21a, x22a} \\<longrightarrow>\n                          x21 = x21a \\<and> x22 = x22a \\<or>\n                          x21 = x22a \\<and> x22 = x21a) \\<and>\n                         ({x21, x22} \\<noteq> {x21a, x22a} \\<longrightarrow>\n                          x21 = x21a \\<and> x22 = x22a \\<or>\n                          position {x21, x22} l\n                          \\<le> position {x21a, x22a} l)\n 4. \\<And>x21 x22 x31 x32 x33.\n       \\<lbrakk>{x21, x22} \\<in> set l; in_list y l; {x31, x32} \\<in> set l;\n        singleCombinators [y]; smaller (DenyAllFromTo x21 x22) y l;\n        smaller y (AllowPortFromTo x31 x32 x33) l;\n        x = DenyAllFromTo x21 x22; z = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> {x31, x32} \\<longrightarrow>\n                         position {x21, x22} l \\<le> position {x31, x32} l\n 5. \\<And>x31 x32 x33.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l; in_list z l;\n        singleCombinators [y]; singleCombinators [z];\n        smaller (AllowPortFromTo x31 x32 x33) y l; smaller y z l;\n        x = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33) z l", "apply (simp add: setPaireq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x21a x22a x21b x22b.\n       \\<lbrakk>{x21, x22} \\<in> set l; {x21b, x22b} \\<in> set l;\n        {x21a, x22a} \\<in> set l;\n        x21 = x21b \\<and> x22 = x22b \\<or>\n        (if {x21, x22} = {x21b, x22b}\n         then case DenyAllFromTo x21b x22b of\n              DenyAllFromTo a b \\<Rightarrow>\n                DenyAllFromTo x21 x22 = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (DenyAllFromTo x21 x22)) l\n              \\<le> position (bothNet (DenyAllFromTo x21b x22b)) l);\n        x21b = x21a \\<and> x22b = x22a \\<or>\n        (if {x21b, x22b} = {x21a, x22a}\n         then case DenyAllFromTo x21a x22a of\n              DenyAllFromTo a b \\<Rightarrow>\n                DenyAllFromTo x21b x22b = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (DenyAllFromTo x21b x22b)) l\n              \\<le> position (bothNet (DenyAllFromTo x21a x22a)) l);\n        x = DenyAllFromTo x21 x22; z = DenyAllFromTo x21a x22a;\n        y = DenyAllFromTo x21b x22b\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> {x21a, x22a} \\<longrightarrow>\n                         x21 = x21a \\<and> x22 = x22a \\<or>\n                         position {x21, x22} l \\<le> position {x21a, x22a} l\n 2. \\<And>x21 x22 x21a x22a x31 x32 x33.\n       \\<lbrakk>{x21, x22} \\<in> set l; {x31, x32} \\<in> set l;\n        {x21a, x22a} \\<in> set l;\n        if {x21, x22} = {x31, x32}\n        then case AllowPortFromTo x31 x32 x33 of\n             DenyAllFromTo a b \\<Rightarrow>\n               DenyAllFromTo x21 x22 = DenyAllFromTo b a\n             | _ \\<Rightarrow> True\n        else position (bothNet (DenyAllFromTo x21 x22)) l\n             \\<le> position (bothNet (AllowPortFromTo x31 x32 x33)) l;\n        if {x31, x32} = {x21a, x22a}\n        then case DenyAllFromTo x21a x22a of\n             DenyAllFromTo a b \\<Rightarrow>\n               AllowPortFromTo x31 x32 x33 = DenyAllFromTo b a\n             | _ \\<Rightarrow> True\n        else position (bothNet (AllowPortFromTo x31 x32 x33)) l\n             \\<le> position (bothNet (DenyAllFromTo x21a x22a)) l;\n        x = DenyAllFromTo x21 x22; z = DenyAllFromTo x21a x22a;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> ({x21, x22} = {x21a, x22a} \\<longrightarrow>\n                          x21 = x21a \\<and> x22 = x22a \\<or>\n                          x21 = x22a \\<and> x22 = x21a) \\<and>\n                         ({x21, x22} \\<noteq> {x21a, x22a} \\<longrightarrow>\n                          x21 = x21a \\<and> x22 = x22a \\<or>\n                          position {x21, x22} l\n                          \\<le> position {x21a, x22a} l)\n 3. \\<And>x21 x22 x31 x32 x33.\n       \\<lbrakk>{x21, x22} \\<in> set l; in_list y l; {x31, x32} \\<in> set l;\n        singleCombinators [y]; smaller (DenyAllFromTo x21 x22) y l;\n        smaller y (AllowPortFromTo x31 x32 x33) l;\n        x = DenyAllFromTo x21 x22; z = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> {x31, x32} \\<longrightarrow>\n                         position {x21, x22} l \\<le> position {x31, x32} l\n 4. \\<And>x31 x32 x33.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l; in_list z l;\n        singleCombinators [y]; singleCombinators [z];\n        smaller (AllowPortFromTo x31 x32 x33) y l; smaller y z l;\n        x = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33) z l", "apply (rule conjI|rule impI)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x21a x22a x21b x22b.\n       \\<lbrakk>{x21, x22} \\<in> set l; {x21b, x22b} \\<in> set l;\n        {x21a, x22a} \\<in> set l;\n        x21 = x21b \\<and> x22 = x22b \\<or>\n        (if {x21, x22} = {x21b, x22b}\n         then case DenyAllFromTo x21b x22b of\n              DenyAllFromTo a b \\<Rightarrow>\n                DenyAllFromTo x21 x22 = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (DenyAllFromTo x21 x22)) l\n              \\<le> position (bothNet (DenyAllFromTo x21b x22b)) l);\n        x21b = x21a \\<and> x22b = x22a \\<or>\n        (if {x21b, x22b} = {x21a, x22a}\n         then case DenyAllFromTo x21a x22a of\n              DenyAllFromTo a b \\<Rightarrow>\n                DenyAllFromTo x21b x22b = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (DenyAllFromTo x21b x22b)) l\n              \\<le> position (bothNet (DenyAllFromTo x21a x22a)) l);\n        x = DenyAllFromTo x21 x22; z = DenyAllFromTo x21a x22a;\n        y = DenyAllFromTo x21b x22b;\n        {x21, x22} \\<noteq> {x21a, x22a}\\<rbrakk>\n       \\<Longrightarrow> x21 = x21a \\<and> x22 = x22a \\<or>\n                         position {x21, x22} l \\<le> position {x21a, x22a} l\n 2. \\<And>x21 x22 x21a x22a x31 x32 x33.\n       \\<lbrakk>{x21, x22} \\<in> set l; {x31, x32} \\<in> set l;\n        {x21a, x22a} \\<in> set l;\n        if {x21, x22} = {x31, x32}\n        then case AllowPortFromTo x31 x32 x33 of\n             DenyAllFromTo a b \\<Rightarrow>\n               DenyAllFromTo x21 x22 = DenyAllFromTo b a\n             | _ \\<Rightarrow> True\n        else position (bothNet (DenyAllFromTo x21 x22)) l\n             \\<le> position (bothNet (AllowPortFromTo x31 x32 x33)) l;\n        if {x31, x32} = {x21a, x22a}\n        then case DenyAllFromTo x21a x22a of\n             DenyAllFromTo a b \\<Rightarrow>\n               AllowPortFromTo x31 x32 x33 = DenyAllFromTo b a\n             | _ \\<Rightarrow> True\n        else position (bothNet (AllowPortFromTo x31 x32 x33)) l\n             \\<le> position (bothNet (DenyAllFromTo x21a x22a)) l;\n        x = DenyAllFromTo x21 x22; z = DenyAllFromTo x21a x22a;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> ({x21, x22} = {x21a, x22a} \\<longrightarrow>\n                          x21 = x21a \\<and> x22 = x22a \\<or>\n                          x21 = x22a \\<and> x22 = x21a) \\<and>\n                         ({x21, x22} \\<noteq> {x21a, x22a} \\<longrightarrow>\n                          x21 = x21a \\<and> x22 = x22a \\<or>\n                          position {x21, x22} l\n                          \\<le> position {x21a, x22a} l)\n 3. \\<And>x21 x22 x31 x32 x33.\n       \\<lbrakk>{x21, x22} \\<in> set l; in_list y l; {x31, x32} \\<in> set l;\n        singleCombinators [y]; smaller (DenyAllFromTo x21 x22) y l;\n        smaller y (AllowPortFromTo x31 x32 x33) l;\n        x = DenyAllFromTo x21 x22; z = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> {x31, x32} \\<longrightarrow>\n                         position {x21, x22} l \\<le> position {x31, x32} l\n 4. \\<And>x31 x32 x33.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l; in_list z l;\n        singleCombinators [y]; singleCombinators [z];\n        smaller (AllowPortFromTo x31 x32 x33) y l; smaller y z l;\n        x = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33) z l", "apply (simp_all split: if_splits)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x21 x22 x21a x22a x21b x22b.\n       \\<lbrakk>x21b = x21a \\<and> x22b = x22a \\<or>\n                position {x21b, x22b} l \\<le> position {x21a, x22a} l;\n        x = DenyAllFromTo x21 x22; z = DenyAllFromTo x21a x22a;\n        y = DenyAllFromTo x21b x22b; {x21b, x22b} \\<noteq> {x21a, x22a};\n        {x21b, x22b} \\<in> set l; {x21a, x22a} \\<in> set l;\n        {x21, x22} = {x21b, x22b};\n        x21 = x21b \\<and> x22 = x22b \\<or>\n        x21 = x22b \\<and> x22 = x21b\\<rbrakk>\n       \\<Longrightarrow> x21 = x21a \\<and> x22 = x22a \\<or>\n                         position {x21b, x22b} l\n                         \\<le> position {x21a, x22a} l\n 2. \\<And>x21 x22 x21a x22a x21b x22b.\n       \\<lbrakk>x = DenyAllFromTo x21 x22; z = DenyAllFromTo x21a x22a;\n        y = DenyAllFromTo x21b x22b; {x21, x22} \\<noteq> {x21a, x22a};\n        {x21, x22} \\<in> set l; {x21a, x22a} \\<in> set l;\n        x21 = x21b \\<and> x22 = x22b \\<or>\n        position {x21, x22} l \\<le> position {x21a, x22a} l;\n        {x21b, x22b} = {x21a, x22a};\n        x21b = x21a \\<and> x22b = x22a \\<or>\n        x21b = x22a \\<and> x22b = x21a\\<rbrakk>\n       \\<Longrightarrow> x21 = x21a \\<and> x22 = x22a \\<or>\n                         position {x21, x22} l \\<le> position {x21a, x22a} l\n 3. \\<And>x21 x22 x21a x22a x21b x22b.\n       \\<lbrakk>x = DenyAllFromTo x21 x22; z = DenyAllFromTo x21a x22a;\n        y = DenyAllFromTo x21b x22b; {x21, x22} \\<noteq> {x21a, x22a};\n        {x21, x22} \\<in> set l; {x21b, x22b} \\<in> set l;\n        {x21a, x22a} \\<in> set l; {x21, x22} \\<noteq> {x21b, x22b};\n        x21 = x21b \\<and> x22 = x22b \\<or>\n        position {x21, x22} l \\<le> position {x21b, x22b} l;\n        {x21b, x22b} \\<noteq> {x21a, x22a};\n        x21b = x21a \\<and> x22b = x22a \\<or>\n        position {x21b, x22b} l \\<le> position {x21a, x22a} l\\<rbrakk>\n       \\<Longrightarrow> x21 = x21a \\<and> x22 = x22a \\<or>\n                         position {x21, x22} l \\<le> position {x21a, x22a} l\n 4. \\<And>x21 x22 x21a x22a x31 x32 x33.\n       \\<lbrakk>x = DenyAllFromTo x21 x22; z = DenyAllFromTo x21a x22a;\n        y = AllowPortFromTo x31 x32 x33; {x21, x22} \\<in> set l;\n        {x31, x32} \\<in> set l; {x21a, x22a} \\<in> set l;\n        {x21, x22} \\<noteq> {x31, x32};\n        position {x21, x22} l \\<le> position {x31, x32} l;\n        {x31, x32} \\<noteq> {x21a, x22a};\n        position {x31, x32} l \\<le> position {x21a, x22a} l\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} = {x21a, x22a} \\<longrightarrow>\n                         x21 = x21a \\<and> x22 = x22a \\<or>\n                         x21 = x22a \\<and> x22 = x21a\n 5. \\<And>x21 x22 x31 x32 x33.\n       \\<lbrakk>{x21, x22} \\<in> set l; in_list y l; {x31, x32} \\<in> set l;\n        singleCombinators [y]; smaller (DenyAllFromTo x21 x22) y l;\n        smaller y (AllowPortFromTo x31 x32 x33) l;\n        x = DenyAllFromTo x21 x22; z = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> {x31, x32} \\<longrightarrow>\n                         position {x21, x22} l \\<le> position {x31, x32} l\n 6. \\<And>x31 x32 x33.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l; in_list z l;\n        singleCombinators [y]; singleCombinators [z];\n        smaller (AllowPortFromTo x31 x32 x33) y l; smaller y z l;\n        x = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33) z l", "apply metis+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x21a x22a x21b x22b.\n       \\<lbrakk>x = DenyAllFromTo x21 x22; z = DenyAllFromTo x21a x22a;\n        y = DenyAllFromTo x21b x22b; {x21, x22} \\<noteq> {x21a, x22a};\n        {x21, x22} \\<in> set l; {x21b, x22b} \\<in> set l;\n        {x21a, x22a} \\<in> set l; {x21, x22} \\<noteq> {x21b, x22b};\n        x21 = x21b \\<and> x22 = x22b \\<or>\n        position {x21, x22} l \\<le> position {x21b, x22b} l;\n        {x21b, x22b} \\<noteq> {x21a, x22a};\n        x21b = x21a \\<and> x22b = x22a \\<or>\n        position {x21b, x22b} l \\<le> position {x21a, x22a} l\\<rbrakk>\n       \\<Longrightarrow> x21 = x21a \\<and> x22 = x22a \\<or>\n                         position {x21, x22} l \\<le> position {x21a, x22a} l\n 2. \\<And>x21 x22 x21a x22a x31 x32 x33.\n       \\<lbrakk>x = DenyAllFromTo x21 x22; z = DenyAllFromTo x21a x22a;\n        y = AllowPortFromTo x31 x32 x33; {x21, x22} \\<in> set l;\n        {x31, x32} \\<in> set l; {x21a, x22a} \\<in> set l;\n        {x21, x22} \\<noteq> {x31, x32};\n        position {x21, x22} l \\<le> position {x31, x32} l;\n        {x31, x32} \\<noteq> {x21a, x22a};\n        position {x31, x32} l \\<le> position {x21a, x22a} l\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} = {x21a, x22a} \\<longrightarrow>\n                         x21 = x21a \\<and> x22 = x22a \\<or>\n                         x21 = x22a \\<and> x22 = x21a\n 3. \\<And>x21 x22 x31 x32 x33.\n       \\<lbrakk>{x21, x22} \\<in> set l; in_list y l; {x31, x32} \\<in> set l;\n        singleCombinators [y]; smaller (DenyAllFromTo x21 x22) y l;\n        smaller y (AllowPortFromTo x31 x32 x33) l;\n        x = DenyAllFromTo x21 x22; z = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> {x31, x32} \\<longrightarrow>\n                         position {x21, x22} l \\<le> position {x31, x32} l\n 4. \\<And>x31 x32 x33.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l; in_list z l;\n        singleCombinators [y]; singleCombinators [z];\n        smaller (AllowPortFromTo x31 x32 x33) y l; smaller y z l;\n        x = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33) z l", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22 x21a x22a x31 x32 x33.\n       \\<lbrakk>x = DenyAllFromTo x21 x22; z = DenyAllFromTo x21a x22a;\n        y = AllowPortFromTo x31 x32 x33; {x21, x22} \\<in> set l;\n        {x31, x32} \\<in> set l; {x21a, x22a} \\<in> set l;\n        {x21, x22} \\<noteq> {x31, x32};\n        position {x21, x22} l \\<le> position {x31, x32} l;\n        {x31, x32} \\<noteq> {x21a, x22a};\n        position {x31, x32} l \\<le> position {x21a, x22a} l\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} = {x21a, x22a} \\<longrightarrow>\n                         x21 = x21a \\<and> x22 = x22a \\<or>\n                         x21 = x22a \\<and> x22 = x21a\n 2. \\<And>x21 x22 x31 x32 x33.\n       \\<lbrakk>{x21, x22} \\<in> set l; in_list y l; {x31, x32} \\<in> set l;\n        singleCombinators [y]; smaller (DenyAllFromTo x21 x22) y l;\n        smaller y (AllowPortFromTo x31 x32 x33) l;\n        x = DenyAllFromTo x21 x22; z = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> {x31, x32} \\<longrightarrow>\n                         position {x21, x22} l \\<le> position {x31, x32} l\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l; in_list z l;\n        singleCombinators [y]; singleCombinators [z];\n        smaller (AllowPortFromTo x31 x32 x33) y l; smaller y z l;\n        x = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33) z l", "apply (simp add: setPaireq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x31 x32 x33.\n       \\<lbrakk>{x21, x22} \\<in> set l; in_list y l; {x31, x32} \\<in> set l;\n        singleCombinators [y]; smaller (DenyAllFromTo x21 x22) y l;\n        smaller y (AllowPortFromTo x31 x32 x33) l;\n        x = DenyAllFromTo x21 x22; z = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> {x31, x32} \\<longrightarrow>\n                         position {x21, x22} l \\<le> position {x31, x32} l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l; in_list z l;\n        singleCombinators [y]; singleCombinators [z];\n        smaller (AllowPortFromTo x31 x32 x33) y l; smaller y z l;\n        x = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33) z l", "apply (rule impI,case_tac y, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22 x31 x32 x33 x21a x22a.\n       \\<lbrakk>{x21, x22} \\<in> set l; {x21a, x22a} \\<in> set l;\n        {x31, x32} \\<in> set l;\n        x21 = x21a \\<and> x22 = x22a \\<or>\n        (if {x21, x22} = {x21a, x22a}\n         then case DenyAllFromTo x21a x22a of\n              DenyAllFromTo a b \\<Rightarrow>\n                DenyAllFromTo x21 x22 = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (DenyAllFromTo x21 x22)) l\n              \\<le> position (bothNet (DenyAllFromTo x21a x22a)) l);\n        if {x21a, x22a} = {x31, x32}\n        then case AllowPortFromTo x31 x32 x33 of\n             DenyAllFromTo a b \\<Rightarrow>\n               DenyAllFromTo x21a x22a = DenyAllFromTo b a\n             | _ \\<Rightarrow> True\n        else position (bothNet (DenyAllFromTo x21a x22a)) l\n             \\<le> position (bothNet (AllowPortFromTo x31 x32 x33)) l;\n        x = DenyAllFromTo x21 x22; z = AllowPortFromTo x31 x32 x33;\n        {x21, x22} \\<noteq> {x31, x32}; y = DenyAllFromTo x21a x22a\\<rbrakk>\n       \\<Longrightarrow> position {x21, x22} l \\<le> position {x31, x32} l\n 2. \\<And>x21 x22 x31 x32 x33 x31a x32a x33a.\n       \\<lbrakk>{x21, x22} \\<in> set l; {x31a, x32a} \\<in> set l;\n        {x31, x32} \\<in> set l;\n        if {x21, x22} = {x31a, x32a}\n        then case AllowPortFromTo x31a x32a x33a of\n             DenyAllFromTo a b \\<Rightarrow>\n               DenyAllFromTo x21 x22 = DenyAllFromTo b a\n             | _ \\<Rightarrow> True\n        else position (bothNet (DenyAllFromTo x21 x22)) l\n             \\<le> position (bothNet (AllowPortFromTo x31a x32a x33a)) l;\n        x31a = x31 \\<and> x32a = x32 \\<and> x33a = x33 \\<or>\n        (if {x31a, x32a} = {x31, x32}\n         then case AllowPortFromTo x31 x32 x33 of\n              DenyAllFromTo a b \\<Rightarrow>\n                AllowPortFromTo x31a x32a x33a = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (AllowPortFromTo x31a x32a x33a)) l\n              \\<le> position (bothNet (AllowPortFromTo x31 x32 x33)) l);\n        x = DenyAllFromTo x21 x22; z = AllowPortFromTo x31 x32 x33;\n        {x21, x22} \\<noteq> {x31, x32};\n        y = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> position {x21, x22} l \\<le> position {x31, x32} l\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l; in_list z l;\n        singleCombinators [y]; singleCombinators [z];\n        smaller (AllowPortFromTo x31 x32 x33) y l; smaller y z l;\n        x = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33) z l", "apply (simp_all split: if_splits, metis,simp_all add: setPair_noteq setPair_noteq_allow)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l; in_list z l;\n        singleCombinators [y]; singleCombinators [z];\n        smaller (AllowPortFromTo x31 x32 x33) y l; smaller y z l;\n        x = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33) z l", "apply (case_tac z, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l; singleCombinators [y];\n        smaller (AllowPortFromTo x31 x32 x33) y l; smaller y DenyAll l;\n        x = AllowPortFromTo x31 x32 x33; z = DenyAll\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x31 x32 x33 x21 x22.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l; {x21, x22} \\<in> set l;\n        singleCombinators [y]; smaller (AllowPortFromTo x31 x32 x33) y l;\n        smaller y (DenyAllFromTo x21 x22) l;\n        x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22} \\<and>\n                         ({x31, x32} \\<noteq> {x21, x22} \\<longrightarrow>\n                          position {x31, x32} l \\<le> position {x21, x22} l)\n 3. \\<And>x31 x32 x33 x31a x32a x33a.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l;\n        {x31a, x32a} \\<in> set l; singleCombinators [y];\n        smaller (AllowPortFromTo x31 x32 x33) y l;\n        smaller y (AllowPortFromTo x31a x32a x33a) l;\n        x = AllowPortFromTo x31 x32 x33;\n        z = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x31a, x32a} \\<longrightarrow>\n                         x31 = x31a \\<and>\n                         x32 = x32a \\<and> x33 = x33a \\<or>\n                         position {x31, x32} l \\<le> position {x31a, x32a} l", "apply (case_tac y, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x21 x22.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l; {x21, x22} \\<in> set l;\n        singleCombinators [y]; smaller (AllowPortFromTo x31 x32 x33) y l;\n        smaller y (DenyAllFromTo x21 x22) l;\n        x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22} \\<and>\n                         ({x31, x32} \\<noteq> {x21, x22} \\<longrightarrow>\n                          position {x31, x32} l \\<le> position {x21, x22} l)\n 2. \\<And>x31 x32 x33 x31a x32a x33a.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l;\n        {x31a, x32a} \\<in> set l; singleCombinators [y];\n        smaller (AllowPortFromTo x31 x32 x33) y l;\n        smaller y (AllowPortFromTo x31a x32a x33a) l;\n        x = AllowPortFromTo x31 x32 x33;\n        z = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x31a, x32a} \\<longrightarrow>\n                         x31 = x31a \\<and>\n                         x32 = x32a \\<and> x33 = x33a \\<or>\n                         position {x31, x32} l \\<le> position {x31a, x32a} l", "apply (case_tac y, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x31 x32 x33 x21 x22 x21a x22a.\n       \\<lbrakk>{x31, x32} \\<in> set l; {x21a, x22a} \\<in> set l;\n        {x21, x22} \\<in> set l;\n        if {x31, x32} = {x21a, x22a}\n        then case DenyAllFromTo x21a x22a of\n             DenyAllFromTo a b \\<Rightarrow>\n               AllowPortFromTo x31 x32 x33 = DenyAllFromTo b a\n             | _ \\<Rightarrow> True\n        else position (bothNet (AllowPortFromTo x31 x32 x33)) l\n             \\<le> position (bothNet (DenyAllFromTo x21a x22a)) l;\n        x21a = x21 \\<and> x22a = x22 \\<or>\n        (if {x21a, x22a} = {x21, x22}\n         then case DenyAllFromTo x21 x22 of\n              DenyAllFromTo a b \\<Rightarrow>\n                DenyAllFromTo x21a x22a = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (DenyAllFromTo x21a x22a)) l\n              \\<le> position (bothNet (DenyAllFromTo x21 x22)) l);\n        x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = DenyAllFromTo x21a x22a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22} \\<and>\n                         ({x31, x32} \\<noteq> {x21, x22} \\<longrightarrow>\n                          position {x31, x32} l \\<le> position {x21, x22} l)\n 2. \\<And>x31 x32 x33 x21 x22 x31a x32a x33a.\n       \\<lbrakk>{x31, x32} \\<in> set l; {x31a, x32a} \\<in> set l;\n        {x21, x22} \\<in> set l;\n        x31 = x31a \\<and> x32 = x32a \\<and> x33 = x33a \\<or>\n        (if {x31, x32} = {x31a, x32a}\n         then case AllowPortFromTo x31a x32a x33a of\n              DenyAllFromTo a b \\<Rightarrow>\n                AllowPortFromTo x31 x32 x33 = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (AllowPortFromTo x31 x32 x33)) l\n              \\<le> position (bothNet (AllowPortFromTo x31a x32a x33a)) l);\n        if {x31a, x32a} = {x21, x22}\n        then case DenyAllFromTo x21 x22 of\n             DenyAllFromTo a b \\<Rightarrow>\n               AllowPortFromTo x31a x32a x33a = DenyAllFromTo b a\n             | _ \\<Rightarrow> True\n        else position (bothNet (AllowPortFromTo x31a x32a x33a)) l\n             \\<le> position (bothNet (DenyAllFromTo x21 x22)) l;\n        x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22} \\<and>\n                         ({x31, x32} \\<noteq> {x21, x22} \\<longrightarrow>\n                          position {x31, x32} l \\<le> position {x21, x22} l)\n 3. \\<And>x31 x32 x33 x31a x32a x33a.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l;\n        {x31a, x32a} \\<in> set l; singleCombinators [y];\n        smaller (AllowPortFromTo x31 x32 x33) y l;\n        smaller y (AllowPortFromTo x31a x32a x33a) l;\n        x = AllowPortFromTo x31 x32 x33;\n        z = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x31a, x32a} \\<longrightarrow>\n                         x31 = x31a \\<and>\n                         x32 = x32a \\<and> x33 = x33a \\<or>\n                         position {x31, x32} l \\<le> position {x31a, x32a} l", "apply (intro impI|rule conjI)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x31 x32 x33 x21 x22 x21a x22a.\n       \\<lbrakk>{x31, x32} \\<in> set l; {x21a, x22a} \\<in> set l;\n        {x21, x22} \\<in> set l;\n        if {x31, x32} = {x21a, x22a}\n        then case DenyAllFromTo x21a x22a of\n             DenyAllFromTo a b \\<Rightarrow>\n               AllowPortFromTo x31 x32 x33 = DenyAllFromTo b a\n             | _ \\<Rightarrow> True\n        else position (bothNet (AllowPortFromTo x31 x32 x33)) l\n             \\<le> position (bothNet (DenyAllFromTo x21a x22a)) l;\n        x21a = x21 \\<and> x22a = x22 \\<or>\n        (if {x21a, x22a} = {x21, x22}\n         then case DenyAllFromTo x21 x22 of\n              DenyAllFromTo a b \\<Rightarrow>\n                DenyAllFromTo x21a x22a = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (DenyAllFromTo x21a x22a)) l\n              \\<le> position (bothNet (DenyAllFromTo x21 x22)) l);\n        x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = DenyAllFromTo x21a x22a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22}\n 2. \\<And>x31 x32 x33 x21 x22 x21a x22a.\n       \\<lbrakk>{x31, x32} \\<in> set l; {x21a, x22a} \\<in> set l;\n        {x21, x22} \\<in> set l;\n        if {x31, x32} = {x21a, x22a}\n        then case DenyAllFromTo x21a x22a of\n             DenyAllFromTo a b \\<Rightarrow>\n               AllowPortFromTo x31 x32 x33 = DenyAllFromTo b a\n             | _ \\<Rightarrow> True\n        else position (bothNet (AllowPortFromTo x31 x32 x33)) l\n             \\<le> position (bothNet (DenyAllFromTo x21a x22a)) l;\n        x21a = x21 \\<and> x22a = x22 \\<or>\n        (if {x21a, x22a} = {x21, x22}\n         then case DenyAllFromTo x21 x22 of\n              DenyAllFromTo a b \\<Rightarrow>\n                DenyAllFromTo x21a x22a = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (DenyAllFromTo x21a x22a)) l\n              \\<le> position (bothNet (DenyAllFromTo x21 x22)) l);\n        x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = DenyAllFromTo x21a x22a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22} \\<longrightarrow>\n                         position {x31, x32} l \\<le> position {x21, x22} l\n 3. \\<And>x31 x32 x33 x21 x22 x31a x32a x33a.\n       \\<lbrakk>{x31, x32} \\<in> set l; {x31a, x32a} \\<in> set l;\n        {x21, x22} \\<in> set l;\n        x31 = x31a \\<and> x32 = x32a \\<and> x33 = x33a \\<or>\n        (if {x31, x32} = {x31a, x32a}\n         then case AllowPortFromTo x31a x32a x33a of\n              DenyAllFromTo a b \\<Rightarrow>\n                AllowPortFromTo x31 x32 x33 = DenyAllFromTo b a\n              | _ \\<Rightarrow> True\n         else position (bothNet (AllowPortFromTo x31 x32 x33)) l\n              \\<le> position (bothNet (AllowPortFromTo x31a x32a x33a)) l);\n        if {x31a, x32a} = {x21, x22}\n        then case DenyAllFromTo x21 x22 of\n             DenyAllFromTo a b \\<Rightarrow>\n               AllowPortFromTo x31a x32a x33a = DenyAllFromTo b a\n             | _ \\<Rightarrow> True\n        else position (bothNet (AllowPortFromTo x31a x32a x33a)) l\n             \\<le> position (bothNet (DenyAllFromTo x21 x22)) l;\n        x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22} \\<and>\n                         ({x31, x32} \\<noteq> {x21, x22} \\<longrightarrow>\n                          position {x31, x32} l \\<le> position {x21, x22} l)\n 4. \\<And>x31 x32 x33 x31a x32a x33a.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l;\n        {x31a, x32a} \\<in> set l; singleCombinators [y];\n        smaller (AllowPortFromTo x31 x32 x33) y l;\n        smaller y (AllowPortFromTo x31a x32a x33a) l;\n        x = AllowPortFromTo x31 x32 x33;\n        z = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x31a, x32a} \\<longrightarrow>\n                         x31 = x31a \\<and>\n                         x32 = x32a \\<and> x33 = x33a \\<or>\n                         position {x31, x32} l \\<le> position {x31a, x32a} l", "apply (simp_all split: if_splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x31 x32 x33 x21 x22 x21a x22a.\n       \\<lbrakk>x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = DenyAllFromTo x21a x22a; {x31, x32} \\<in> set l;\n        {x21a, x22a} \\<in> set l; {x21, x22} \\<in> set l;\n        {x31, x32} \\<noteq> {x21a, x22a};\n        position {x31, x32} l \\<le> position {x21a, x22a} l;\n        {x21a, x22a} \\<noteq> {x21, x22};\n        x21a = x21 \\<and> x22a = x22 \\<or>\n        position {x21a, x22a} l \\<le> position {x21, x22} l\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22}\n 2. \\<And>x31 x32 x33 x21 x22 x21a x22a.\n       \\<lbrakk>x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = DenyAllFromTo x21a x22a; {x31, x32} \\<in> set l;\n        {x21a, x22a} \\<in> set l; {x21, x22} \\<in> set l;\n        {x31, x32} \\<noteq> {x21a, x22a};\n        position {x31, x32} l \\<le> position {x21a, x22a} l;\n        {x21a, x22a} \\<noteq> {x21, x22};\n        x21a = x21 \\<and> x22a = x22 \\<or>\n        position {x21a, x22a} l \\<le> position {x21, x22} l\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22} \\<longrightarrow>\n                         position {x31, x32} l \\<le> position {x21, x22} l\n 3. \\<And>x31 x32 x33 x21 x22 x31a x32a x33a.\n       \\<lbrakk>x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = AllowPortFromTo x31a x32a x33a; {x31, x32} \\<in> set l;\n        {x31a, x32a} \\<in> set l; {x21, x22} \\<in> set l;\n        {x31, x32} \\<noteq> {x31a, x32a};\n        x31 = x31a \\<and> x32 = x32a \\<and> x33 = x33a \\<or>\n        position {x31, x32} l \\<le> position {x31a, x32a} l;\n        {x31a, x32a} \\<noteq> {x21, x22};\n        position {x31a, x32a} l \\<le> position {x21, x22} l\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22} \\<and>\n                         ({x31, x32} \\<noteq> {x21, x22} \\<longrightarrow>\n                          position {x31, x32} l \\<le> position {x21, x22} l)\n 4. \\<And>x31 x32 x33 x31a x32a x33a.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l;\n        {x31a, x32a} \\<in> set l; singleCombinators [y];\n        smaller (AllowPortFromTo x31 x32 x33) y l;\n        smaller y (AllowPortFromTo x31a x32a x33a) l;\n        x = AllowPortFromTo x31 x32 x33;\n        z = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x31a, x32a} \\<longrightarrow>\n                         x31 = x31a \\<and>\n                         x32 = x32a \\<and> x33 = x33a \\<or>\n                         position {x31, x32} l \\<le> position {x31a, x32a} l", "apply (simp add: setPair_noteq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x31 x32 x33 x21 x22 x21a x22a.\n       \\<lbrakk>x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = DenyAllFromTo x21a x22a; {x31, x32} \\<in> set l;\n        {x21a, x22a} \\<in> set l; {x21, x22} \\<in> set l;\n        {x31, x32} \\<noteq> {x21a, x22a};\n        position {x31, x32} l \\<le> position {x21a, x22a} l;\n        {x21a, x22a} \\<noteq> {x21, x22};\n        position {x21a, x22a} l \\<le> position {x21, x22} l\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22}\n 2. \\<And>x31 x32 x33 x21 x22 x21a x22a.\n       \\<lbrakk>x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = DenyAllFromTo x21a x22a; {x31, x32} \\<in> set l;\n        {x21a, x22a} \\<in> set l; {x21, x22} \\<in> set l;\n        {x31, x32} \\<noteq> {x21a, x22a};\n        position {x31, x32} l \\<le> position {x21a, x22a} l;\n        {x21a, x22a} \\<noteq> {x21, x22};\n        x21a = x21 \\<and> x22a = x22 \\<or>\n        position {x21a, x22a} l \\<le> position {x21, x22} l\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22} \\<longrightarrow>\n                         position {x31, x32} l \\<le> position {x21, x22} l\n 3. \\<And>x31 x32 x33 x21 x22 x31a x32a x33a.\n       \\<lbrakk>x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = AllowPortFromTo x31a x32a x33a; {x31, x32} \\<in> set l;\n        {x31a, x32a} \\<in> set l; {x21, x22} \\<in> set l;\n        {x31, x32} \\<noteq> {x31a, x32a};\n        x31 = x31a \\<and> x32 = x32a \\<and> x33 = x33a \\<or>\n        position {x31, x32} l \\<le> position {x31a, x32a} l;\n        {x31a, x32a} \\<noteq> {x21, x22};\n        position {x31a, x32a} l \\<le> position {x21, x22} l\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22} \\<and>\n                         ({x31, x32} \\<noteq> {x21, x22} \\<longrightarrow>\n                          position {x31, x32} l \\<le> position {x21, x22} l)\n 4. \\<And>x31 x32 x33 x31a x32a x33a.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l;\n        {x31a, x32a} \\<in> set l; singleCombinators [y];\n        smaller (AllowPortFromTo x31 x32 x33) y l;\n        smaller y (AllowPortFromTo x31a x32a x33a) l;\n        x = AllowPortFromTo x31 x32 x33;\n        z = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x31a, x32a} \\<longrightarrow>\n                         x31 = x31a \\<and>\n                         x32 = x32a \\<and> x33 = x33a \\<or>\n                         position {x31, x32} l \\<le> position {x31a, x32a} l", "apply (erule pos_noteq, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x31 x32 x33 x21 x22 x21a x22a.\n       \\<lbrakk>x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = DenyAllFromTo x21a x22a; {x31, x32} \\<in> set l;\n        {x21a, x22a} \\<in> set l; {x21, x22} \\<in> set l;\n        {x31, x32} \\<noteq> {x21a, x22a};\n        position {x31, x32} l \\<le> position {x21a, x22a} l;\n        {x21a, x22a} \\<noteq> {x21, x22};\n        x21a = x21 \\<and> x22a = x22 \\<or>\n        position {x21a, x22a} l \\<le> position {x21, x22} l\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22} \\<longrightarrow>\n                         position {x31, x32} l \\<le> position {x21, x22} l\n 2. \\<And>x31 x32 x33 x21 x22 x31a x32a x33a.\n       \\<lbrakk>x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = AllowPortFromTo x31a x32a x33a; {x31, x32} \\<in> set l;\n        {x31a, x32a} \\<in> set l; {x21, x22} \\<in> set l;\n        {x31, x32} \\<noteq> {x31a, x32a};\n        x31 = x31a \\<and> x32 = x32a \\<and> x33 = x33a \\<or>\n        position {x31, x32} l \\<le> position {x31a, x32a} l;\n        {x31a, x32a} \\<noteq> {x21, x22};\n        position {x31a, x32a} l \\<le> position {x21, x22} l\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22} \\<and>\n                         ({x31, x32} \\<noteq> {x21, x22} \\<longrightarrow>\n                          position {x31, x32} l \\<le> position {x21, x22} l)\n 3. \\<And>x31 x32 x33 x31a x32a x33a.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l;\n        {x31a, x32a} \\<in> set l; singleCombinators [y];\n        smaller (AllowPortFromTo x31 x32 x33) y l;\n        smaller y (AllowPortFromTo x31a x32a x33a) l;\n        x = AllowPortFromTo x31 x32 x33;\n        z = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x31a, x32a} \\<longrightarrow>\n                         x31 = x31a \\<and>\n                         x32 = x32a \\<and> x33 = x33a \\<or>\n                         position {x31, x32} l \\<le> position {x31a, x32a} l", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x21 x22 x31a x32a x33a.\n       \\<lbrakk>x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = AllowPortFromTo x31a x32a x33a; {x31, x32} \\<in> set l;\n        {x31a, x32a} \\<in> set l; {x21, x22} \\<in> set l;\n        {x31, x32} \\<noteq> {x31a, x32a};\n        x31 = x31a \\<and> x32 = x32a \\<and> x33 = x33a \\<or>\n        position {x31, x32} l \\<le> position {x31a, x32a} l;\n        {x31a, x32a} \\<noteq> {x21, x22};\n        position {x31a, x32a} l \\<le> position {x21, x22} l\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22} \\<and>\n                         ({x31, x32} \\<noteq> {x21, x22} \\<longrightarrow>\n                          position {x31, x32} l \\<le> position {x21, x22} l)\n 2. \\<And>x31 x32 x33 x31a x32a x33a.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l;\n        {x31a, x32a} \\<in> set l; singleCombinators [y];\n        smaller (AllowPortFromTo x31 x32 x33) y l;\n        smaller y (AllowPortFromTo x31a x32a x33a) l;\n        x = AllowPortFromTo x31 x32 x33;\n        z = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x31a, x32a} \\<longrightarrow>\n                         x31 = x31a \\<and>\n                         x32 = x32a \\<and> x33 = x33a \\<or>\n                         position {x31, x32} l \\<le> position {x31a, x32a} l", "apply (rule conjI,simp add: setPair_noteq_allow)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x31 x32 x33 x21 x22 x31a x32a x33a.\n       \\<lbrakk>x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = AllowPortFromTo x31a x32a x33a; {x31, x32} \\<in> set l;\n        {x31a, x32a} \\<in> set l; {x21, x22} \\<in> set l;\n        {x31, x32} \\<noteq> {x31a, x32a};\n        position {x31, x32} l \\<le> position {x31a, x32a} l;\n        {x31a, x32a} \\<noteq> {x21, x22};\n        position {x31a, x32a} l \\<le> position {x21, x22} l\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22}\n 2. \\<And>x31 x32 x33 x21 x22 x31a x32a x33a.\n       \\<lbrakk>x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = AllowPortFromTo x31a x32a x33a; {x31, x32} \\<in> set l;\n        {x31a, x32a} \\<in> set l; {x21, x22} \\<in> set l;\n        {x31, x32} \\<noteq> {x31a, x32a};\n        x31 = x31a \\<and> x32 = x32a \\<and> x33 = x33a \\<or>\n        position {x31, x32} l \\<le> position {x31a, x32a} l;\n        {x31a, x32a} \\<noteq> {x21, x22};\n        position {x31a, x32a} l \\<le> position {x21, x22} l\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22} \\<longrightarrow>\n                         position {x31, x32} l \\<le> position {x21, x22} l\n 3. \\<And>x31 x32 x33 x31a x32a x33a.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l;\n        {x31a, x32a} \\<in> set l; singleCombinators [y];\n        smaller (AllowPortFromTo x31 x32 x33) y l;\n        smaller y (AllowPortFromTo x31a x32a x33a) l;\n        x = AllowPortFromTo x31 x32 x33;\n        z = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x31a, x32a} \\<longrightarrow>\n                         x31 = x31a \\<and>\n                         x32 = x32a \\<and> x33 = x33a \\<or>\n                         position {x31, x32} l \\<le> position {x31a, x32a} l", "apply (erule pos_noteq, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x21 x22 x31a x32a x33a.\n       \\<lbrakk>x = AllowPortFromTo x31 x32 x33; z = DenyAllFromTo x21 x22;\n        y = AllowPortFromTo x31a x32a x33a; {x31, x32} \\<in> set l;\n        {x31a, x32a} \\<in> set l; {x21, x22} \\<in> set l;\n        {x31, x32} \\<noteq> {x31a, x32a};\n        x31 = x31a \\<and> x32 = x32a \\<and> x33 = x33a \\<or>\n        position {x31, x32} l \\<le> position {x31a, x32a} l;\n        {x31a, x32a} \\<noteq> {x21, x22};\n        position {x31a, x32a} l \\<le> position {x21, x22} l\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22} \\<longrightarrow>\n                         position {x31, x32} l \\<le> position {x21, x22} l\n 2. \\<And>x31 x32 x33 x31a x32a x33a.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l;\n        {x31a, x32a} \\<in> set l; singleCombinators [y];\n        smaller (AllowPortFromTo x31 x32 x33) y l;\n        smaller y (AllowPortFromTo x31a x32a x33a) l;\n        x = AllowPortFromTo x31 x32 x33;\n        z = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x31a, x32a} \\<longrightarrow>\n                         x31 = x31a \\<and>\n                         x32 = x32a \\<and> x33 = x33a \\<or>\n                         position {x31, x32} l \\<le> position {x31a, x32a} l", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33 x31a x32a x33a.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l;\n        {x31a, x32a} \\<in> set l; singleCombinators [y];\n        smaller (AllowPortFromTo x31 x32 x33) y l;\n        smaller y (AllowPortFromTo x31a x32a x33a) l;\n        x = AllowPortFromTo x31 x32 x33;\n        z = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x31a, x32a} \\<longrightarrow>\n                         x31 = x31a \\<and>\n                         x32 = x32a \\<and> x33 = x33a \\<or>\n                         position {x31, x32} l \\<le> position {x31a, x32a} l", "apply (rule impI,rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33 x31a x32a x33a.\n       \\<lbrakk>{x31, x32} \\<in> set l; in_list y l;\n        {x31a, x32a} \\<in> set l; singleCombinators [y];\n        smaller (AllowPortFromTo x31 x32 x33) y l;\n        smaller y (AllowPortFromTo x31a x32a x33a) l;\n        x = AllowPortFromTo x31 x32 x33; z = AllowPortFromTo x31a x32a x33a;\n        {x31, x32} \\<noteq> {x31a, x32a}\\<rbrakk>\n       \\<Longrightarrow> position {x31, x32} l \\<le> position {x31a, x32a} l", "apply (case_tac y, simp_all split: if_splits )"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x31 x32 x33 x31a x32a x33a x31b x32b x33b.\n       \\<lbrakk>x31b = x31a \\<and> x32b = x32a \\<and> x33b = x33a \\<or>\n                position {x31b, x32b} l \\<le> position {x31a, x32a} l;\n        x = AllowPortFromTo x31 x32 x33; z = AllowPortFromTo x31a x32a x33a;\n        {x31b, x32b} \\<noteq> {x31a, x32a};\n        y = AllowPortFromTo x31b x32b x33b; {x31b, x32b} \\<in> set l;\n        {x31a, x32a} \\<in> set l; {x31, x32} = {x31b, x32b}\\<rbrakk>\n       \\<Longrightarrow> position {x31b, x32b} l\n                         \\<le> position {x31a, x32a} l\n 2. \\<And>x31 x32 x33 x31a x32a x33a x31b x32b x33b.\n       \\<lbrakk>x = AllowPortFromTo x31 x32 x33;\n        z = AllowPortFromTo x31a x32a x33a;\n        {x31, x32} \\<noteq> {x31a, x32a};\n        y = AllowPortFromTo x31b x32b x33b; {x31, x32} \\<in> set l;\n        {x31a, x32a} \\<in> set l;\n        x31 = x31b \\<and> x32 = x32b \\<and> x33 = x33b \\<or>\n        position {x31, x32} l \\<le> position {x31a, x32a} l;\n        {x31b, x32b} = {x31a, x32a}\\<rbrakk>\n       \\<Longrightarrow> position {x31, x32} l \\<le> position {x31a, x32a} l\n 3. \\<And>x31 x32 x33 x31a x32a x33a x31b x32b x33b.\n       \\<lbrakk>x = AllowPortFromTo x31 x32 x33;\n        z = AllowPortFromTo x31a x32a x33a;\n        {x31, x32} \\<noteq> {x31a, x32a};\n        y = AllowPortFromTo x31b x32b x33b; {x31, x32} \\<in> set l;\n        {x31b, x32b} \\<in> set l; {x31a, x32a} \\<in> set l;\n        {x31, x32} \\<noteq> {x31b, x32b};\n        x31 = x31b \\<and> x32 = x32b \\<and> x33 = x33b \\<or>\n        position {x31, x32} l \\<le> position {x31b, x32b} l;\n        {x31b, x32b} \\<noteq> {x31a, x32a};\n        x31b = x31a \\<and> x32b = x32a \\<and> x33b = x33a \\<or>\n        position {x31b, x32b} l \\<le> position {x31a, x32a} l\\<rbrakk>\n       \\<Longrightarrow> position {x31, x32} l \\<le> position {x31a, x32a} l", "apply metis"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x31a x32a x33a x31b x32b x33b.\n       \\<lbrakk>x = AllowPortFromTo x31 x32 x33;\n        z = AllowPortFromTo x31a x32a x33a;\n        {x31, x32} \\<noteq> {x31a, x32a};\n        y = AllowPortFromTo x31b x32b x33b; {x31, x32} \\<in> set l;\n        {x31a, x32a} \\<in> set l;\n        x31 = x31b \\<and> x32 = x32b \\<and> x33 = x33b \\<or>\n        position {x31, x32} l \\<le> position {x31a, x32a} l;\n        {x31b, x32b} = {x31a, x32a}\\<rbrakk>\n       \\<Longrightarrow> position {x31, x32} l \\<le> position {x31a, x32a} l\n 2. \\<And>x31 x32 x33 x31a x32a x33a x31b x32b x33b.\n       \\<lbrakk>x = AllowPortFromTo x31 x32 x33;\n        z = AllowPortFromTo x31a x32a x33a;\n        {x31, x32} \\<noteq> {x31a, x32a};\n        y = AllowPortFromTo x31b x32b x33b; {x31, x32} \\<in> set l;\n        {x31b, x32b} \\<in> set l; {x31a, x32a} \\<in> set l;\n        {x31, x32} \\<noteq> {x31b, x32b};\n        x31 = x31b \\<and> x32 = x32b \\<and> x33 = x33b \\<or>\n        position {x31, x32} l \\<le> position {x31b, x32b} l;\n        {x31b, x32b} \\<noteq> {x31a, x32a};\n        x31b = x31a \\<and> x32b = x32a \\<and> x33b = x33a \\<or>\n        position {x31b, x32b} l \\<le> position {x31a, x32a} l\\<rbrakk>\n       \\<Longrightarrow> position {x31, x32} l \\<le> position {x31a, x32a} l", "apply (simp_all add: setPair_noteq_allow)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sortedConcStart[rule_format]: \n  \"sorted (a # aa # p) l \\<longrightarrow> in_list a l \\<longrightarrow> in_list aa l \\<longrightarrow> all_in_list p l\\<longrightarrow> \n  singleCombinators [a] \\<longrightarrow> singleCombinators [aa] \\<longrightarrow> singleCombinators p \\<longrightarrow> \n  sorted (a#p) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # aa # p) l \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list aa l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    singleCombinators [a] \\<longrightarrow>\n    singleCombinators [aa] \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    FWNormalisationCore.sorted (a # p) l", "apply (induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. FWNormalisationCore.sorted [a, aa] l \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list aa l \\<longrightarrow>\n    all_in_list [] l \\<longrightarrow>\n    singleCombinators [a] \\<longrightarrow>\n    singleCombinators [aa] \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow> FWNormalisationCore.sorted [a] l\n 2. \\<And>ab p.\n       FWNormalisationCore.sorted (a # aa # p) l \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list aa l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       singleCombinators [aa] \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (a # p) l \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # aa # ab # p) l \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list aa l \\<longrightarrow>\n       all_in_list (ab # p) l \\<longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       singleCombinators [aa] \\<longrightarrow>\n       singleCombinators (ab # p) \\<longrightarrow>\n       FWNormalisationCore.sorted (a # ab # p) l", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab p.\n       smaller a aa l \\<and>\n       FWNormalisationCore.sorted (aa # p) l \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list aa l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       singleCombinators [aa] \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (a # p) l \\<Longrightarrow>\n       smaller a aa l \\<and>\n       smaller aa ab l \\<and>\n       FWNormalisationCore.sorted (ab # p) l \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list aa l \\<longrightarrow>\n       in_list ab l \\<and> all_in_list p l \\<longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       singleCombinators [aa] \\<longrightarrow>\n       singleCombinators (ab # p) \\<longrightarrow> smaller a ab l", "apply (rule impI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab p.\n       \\<lbrakk>smaller a aa l \\<and>\n                FWNormalisationCore.sorted (aa # p) l \\<longrightarrow>\n                in_list a l \\<longrightarrow>\n                in_list aa l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                singleCombinators [a] \\<longrightarrow>\n                singleCombinators [aa] \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                FWNormalisationCore.sorted (a # p) l;\n        smaller a aa l \\<and>\n        smaller aa ab l \\<and> FWNormalisationCore.sorted (ab # p) l;\n        in_list a l; in_list aa l; in_list ab l \\<and> all_in_list p l;\n        singleCombinators [a]; singleCombinators [aa];\n        singleCombinators (ab # p)\\<rbrakk>\n       \\<Longrightarrow> smaller a ab l", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab p.\n       \\<lbrakk>FWNormalisationCore.sorted (aa # p) l \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                FWNormalisationCore.sorted (a # p) l;\n        smaller a aa l \\<and>\n        smaller aa ab l \\<and> FWNormalisationCore.sorted (ab # p) l;\n        in_list a l; in_list aa l; in_list ab l \\<and> all_in_list p l;\n        singleCombinators [a]; singleCombinators [aa];\n        singleCombinators (ab # p)\\<rbrakk>\n       \\<Longrightarrow> smaller a ab l", "apply (rule_tac y = \"aa\" in order_trans)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>ab p.\n       \\<lbrakk>FWNormalisationCore.sorted (aa # p) l \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                FWNormalisationCore.sorted (a # p) l;\n        smaller a aa l \\<and>\n        smaller aa ab l \\<and> FWNormalisationCore.sorted (ab # p) l;\n        in_list a l; in_list aa l; in_list ab l \\<and> all_in_list p l;\n        singleCombinators [a]; singleCombinators [aa];\n        singleCombinators (ab # p)\\<rbrakk>\n       \\<Longrightarrow> in_list a l\n 2. \\<And>ab p.\n       \\<lbrakk>FWNormalisationCore.sorted (aa # p) l \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                FWNormalisationCore.sorted (a # p) l;\n        smaller a aa l \\<and>\n        smaller aa ab l \\<and> FWNormalisationCore.sorted (ab # p) l;\n        in_list a l; in_list aa l; in_list ab l \\<and> all_in_list p l;\n        singleCombinators [a]; singleCombinators [aa];\n        singleCombinators (ab # p)\\<rbrakk>\n       \\<Longrightarrow> in_list aa l\n 3. \\<And>ab p.\n       \\<lbrakk>FWNormalisationCore.sorted (aa # p) l \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                FWNormalisationCore.sorted (a # p) l;\n        smaller a aa l \\<and>\n        smaller aa ab l \\<and> FWNormalisationCore.sorted (ab # p) l;\n        in_list a l; in_list aa l; in_list ab l \\<and> all_in_list p l;\n        singleCombinators [a]; singleCombinators [aa];\n        singleCombinators (ab # p)\\<rbrakk>\n       \\<Longrightarrow> in_list ab l\n 4. \\<And>ab p.\n       \\<lbrakk>FWNormalisationCore.sorted (aa # p) l \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                FWNormalisationCore.sorted (a # p) l;\n        smaller a aa l \\<and>\n        smaller aa ab l \\<and> FWNormalisationCore.sorted (ab # p) l;\n        in_list a l; in_list aa l; in_list ab l \\<and> all_in_list p l;\n        singleCombinators [a]; singleCombinators [aa];\n        singleCombinators (ab # p)\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a]\n 5. \\<And>ab p.\n       \\<lbrakk>FWNormalisationCore.sorted (aa # p) l \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                FWNormalisationCore.sorted (a # p) l;\n        smaller a aa l \\<and>\n        smaller aa ab l \\<and> FWNormalisationCore.sorted (ab # p) l;\n        in_list a l; in_list aa l; in_list ab l \\<and> all_in_list p l;\n        singleCombinators [a]; singleCombinators [aa];\n        singleCombinators (ab # p)\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [aa]\n 6. \\<And>ab p.\n       \\<lbrakk>FWNormalisationCore.sorted (aa # p) l \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                FWNormalisationCore.sorted (a # p) l;\n        smaller a aa l \\<and>\n        smaller aa ab l \\<and> FWNormalisationCore.sorted (ab # p) l;\n        in_list a l; in_list aa l; in_list ab l \\<and> all_in_list p l;\n        singleCombinators [a]; singleCombinators [aa];\n        singleCombinators (ab # p)\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [ab]\n 7. \\<And>ab p.\n       \\<lbrakk>FWNormalisationCore.sorted (aa # p) l \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                FWNormalisationCore.sorted (a # p) l;\n        smaller a aa l \\<and>\n        smaller aa ab l \\<and> FWNormalisationCore.sorted (ab # p) l;\n        in_list a l; in_list aa l; in_list ab l \\<and> all_in_list p l;\n        singleCombinators [a]; singleCombinators [aa];\n        singleCombinators (ab # p)\\<rbrakk>\n       \\<Longrightarrow> smaller a aa l\n 8. \\<And>ab p.\n       \\<lbrakk>FWNormalisationCore.sorted (aa # p) l \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                FWNormalisationCore.sorted (a # p) l;\n        smaller a aa l \\<and>\n        smaller aa ab l \\<and> FWNormalisationCore.sorted (ab # p) l;\n        in_list a l; in_list aa l; in_list ab l \\<and> all_in_list p l;\n        singleCombinators [a]; singleCombinators [aa];\n        singleCombinators (ab # p)\\<rbrakk>\n       \\<Longrightarrow> smaller aa ab l", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab p.\n       \\<lbrakk>FWNormalisationCore.sorted (aa # p) l \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                FWNormalisationCore.sorted (a # p) l;\n        smaller a aa l \\<and>\n        smaller aa ab l \\<and> FWNormalisationCore.sorted (ab # p) l;\n        in_list a l; in_list aa l; in_list ab l \\<and> all_in_list p l;\n        singleCombinators [a]; singleCombinators [aa];\n        singleCombinators (ab # p)\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [ab]", "subgoal for p ps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FWNormalisationCore.sorted (aa # ps) l \\<longrightarrow>\n             singleCombinators ps \\<longrightarrow>\n             FWNormalisationCore.sorted (a # ps) l;\n     smaller a aa l \\<and>\n     smaller aa p l \\<and> FWNormalisationCore.sorted (p # ps) l;\n     in_list a l; in_list aa l; in_list p l \\<and> all_in_list ps l;\n     singleCombinators [a]; singleCombinators [aa];\n     singleCombinators (p # ps)\\<rbrakk>\n    \\<Longrightarrow> singleCombinators [p]", "apply (case_tac \"p\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma singleCombinatorsStart[simp]: \"singleCombinators (x#xs) \\<Longrightarrow> \n                                     singleCombinators [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators (x # xs) \\<Longrightarrow> singleCombinators [x]", "by (case_tac x, simp_all)"], ["", "lemma sorted_is_smaller[rule_format]: \n  \"sorted (a # p) l \\<longrightarrow> in_list a l \\<longrightarrow> in_list b l \\<longrightarrow> all_in_list p l \\<longrightarrow>  \n  singleCombinators [a] \\<longrightarrow> singleCombinators p \\<longrightarrow> b \\<in> set p \\<longrightarrow> smaller a b l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    singleCombinators [a] \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    b \\<in> set p \\<longrightarrow> smaller a b l", "apply (induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. FWNormalisationCore.sorted [a] l \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    all_in_list [] l \\<longrightarrow>\n    singleCombinators [a] \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow>\n    b \\<in> set [] \\<longrightarrow> smaller a b l\n 2. \\<And>aa p.\n       FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       b \\<in> set p \\<longrightarrow> smaller a b l \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # aa # p) l \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       all_in_list (aa # p) l \\<longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       singleCombinators (aa # p) \\<longrightarrow>\n       b \\<in> set (aa # p) \\<longrightarrow> smaller a b l", "apply (auto intro: singleCombinatorsConc sortedConcStart)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sortedConcEnd[rule_format]: \"sorted (a # p) l \\<longrightarrow> in_list a l \\<longrightarrow> \n                                   all_in_list p l \\<longrightarrow> singleCombinators [a] \\<longrightarrow> \n                                   singleCombinators p  \\<longrightarrow> sorted p l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    singleCombinators [a] \\<longrightarrow>\n    singleCombinators p \\<longrightarrow> FWNormalisationCore.sorted p l", "apply (induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. FWNormalisationCore.sorted [a] l \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    all_in_list [] l \\<longrightarrow>\n    singleCombinators [a] \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow> FWNormalisationCore.sorted [] l\n 2. \\<And>aa p.\n       FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted p l \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # aa # p) l \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       all_in_list (aa # p) l \\<longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       singleCombinators (aa # p) \\<longrightarrow>\n       FWNormalisationCore.sorted (aa # p) l", "apply (auto intro: singleCombinatorsConc sortedConcStart)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma in_set_in_list[rule_format]: \"a \\<in> set p \\<longrightarrow> all_in_list p l\\<longrightarrow> in_list a l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set p \\<longrightarrow>\n    all_in_list p l \\<longrightarrow> in_list a l", "by (induct p) auto"], ["", "lemma sorted_Consb[rule_format]: \n  \"all_in_list (x#xs) l \\<longrightarrow> singleCombinators (x#xs) \\<longrightarrow> \n    (sorted xs l & (\\<forall>y\\<in>set xs. smaller x y l)) \\<longrightarrow>  (sorted (x#xs) l) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list (x # xs) l \\<longrightarrow>\n    singleCombinators (x # xs) \\<longrightarrow>\n    FWNormalisationCore.sorted xs l \\<and>\n    (\\<forall>y\\<in>set xs. smaller x y l) \\<longrightarrow>\n    FWNormalisationCore.sorted (x # xs) l", "apply(induct xs arbitrary: x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       all_in_list [x] l \\<longrightarrow>\n       singleCombinators [x] \\<longrightarrow>\n       FWNormalisationCore.sorted [] l \\<and>\n       (\\<forall>y\\<in>set []. smaller x y l) \\<longrightarrow>\n       FWNormalisationCore.sorted [x] l\n 2. \\<And>a xs x.\n       (\\<And>x.\n           all_in_list (x # xs) l \\<longrightarrow>\n           singleCombinators (x # xs) \\<longrightarrow>\n           FWNormalisationCore.sorted xs l \\<and>\n           (\\<forall>y\\<in>set xs. smaller x y l) \\<longrightarrow>\n           FWNormalisationCore.sorted (x # xs) l) \\<Longrightarrow>\n       all_in_list (x # a # xs) l \\<longrightarrow>\n       singleCombinators (x # a # xs) \\<longrightarrow>\n       FWNormalisationCore.sorted (a # xs) l \\<and>\n       (\\<forall>y\\<in>set (a # xs). smaller x y l) \\<longrightarrow>\n       FWNormalisationCore.sorted (x # a # xs) l", "apply (auto simp: order_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sorted_Cons: \"\\<lbrakk>all_in_list (x#xs) l; singleCombinators (x#xs)\\<rbrakk> \\<Longrightarrow> \n              (sorted xs l & (\\<forall>y\\<in>set xs. smaller x y l)) =  (sorted (x#xs) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_in_list (x # xs) l; singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> (FWNormalisationCore.sorted xs l \\<and>\n                       (\\<forall>y\\<in>set xs. smaller x y l)) =\n                      FWNormalisationCore.sorted (x # xs) l", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>singleCombinators (x # xs); in_list x l; all_in_list xs l;\n     FWNormalisationCore.sorted xs l;\n     \\<forall>y\\<in>set xs. smaller x y l\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted (x # xs) l\n 2. \\<lbrakk>singleCombinators (x # xs); in_list x l; all_in_list xs l;\n     FWNormalisationCore.sorted (x # xs) l\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted xs l\n 3. \\<And>y.\n       \\<lbrakk>singleCombinators (x # xs); in_list x l; all_in_list xs l;\n        FWNormalisationCore.sorted (x # xs) l; y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> smaller x y l", "apply (rule sorted_Consb, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>singleCombinators (x # xs); in_list x l; all_in_list xs l;\n     FWNormalisationCore.sorted (x # xs) l\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted xs l\n 2. \\<And>y.\n       \\<lbrakk>singleCombinators (x # xs); in_list x l; all_in_list xs l;\n        FWNormalisationCore.sorted (x # xs) l; y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> smaller x y l", "apply (metis singleCombinatorsConc singleCombinatorsStart sortedConcEnd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>singleCombinators (x # xs); in_list x l; all_in_list xs l;\n        FWNormalisationCore.sorted (x # xs) l; y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> smaller x y l", "apply (erule sorted_is_smaller)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>singleCombinators (x # xs); in_list x l; all_in_list xs l;\n        y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> in_list x l\n 2. \\<And>y.\n       \\<lbrakk>singleCombinators (x # xs); in_list x l; all_in_list xs l;\n        y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> in_list y l\n 3. \\<And>y.\n       \\<lbrakk>singleCombinators (x # xs); in_list x l; all_in_list xs l;\n        y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> all_in_list xs l\n 4. \\<And>y.\n       \\<lbrakk>singleCombinators (x # xs); in_list x l; all_in_list xs l;\n        y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [x]\n 5. \\<And>y.\n       \\<lbrakk>singleCombinators (x # xs); in_list x l; all_in_list xs l;\n        y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> singleCombinators xs\n 6. \\<And>y.\n       \\<lbrakk>singleCombinators (x # xs); in_list x l; all_in_list xs l;\n        y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> y \\<in> set xs", "apply (auto intro: singleCombinatorsConc singleCombinatorsStart in_set_in_list)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma smaller_antisym: \"\\<lbrakk>\\<not> smaller a b l; in_list a l; in_list b l; \n                        singleCombinators[a]; singleCombinators [b]\\<rbrakk> \\<Longrightarrow>  \n                        smaller b a l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> smaller a b l; in_list a l; in_list b l;\n     singleCombinators [a]; singleCombinators [b]\\<rbrakk>\n    \\<Longrightarrow> smaller b a l", "apply (case_tac a)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> smaller a b l; in_list a l; in_list b l;\n     singleCombinators [a]; singleCombinators [b]; a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> smaller b a l\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<not> smaller a b l; in_list a l; in_list b l;\n        singleCombinators [a]; singleCombinators [b];\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> smaller b a l\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>\\<not> smaller a b l; in_list a l; in_list b l;\n        singleCombinators [a]; singleCombinators [b];\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller b a l\n 4. \\<And>x41 x42.\n       \\<lbrakk>\\<not> smaller a b l; in_list a l; in_list b l;\n        singleCombinators [a]; singleCombinators [b];\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> smaller b a l", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> smaller (DenyAllFromTo x21 x22) b l;\n        {x21, x22} \\<in> set l; in_list b l; singleCombinators [b];\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> smaller b (DenyAllFromTo x21 x22) l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>\\<not> smaller (AllowPortFromTo x31 x32 x33) b l;\n        {x31, x32} \\<in> set l; in_list b l; singleCombinators [b];\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller b (AllowPortFromTo x31 x32 x33) l", "apply (case_tac b)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> smaller (DenyAllFromTo x21 x22) b l;\n        {x21, x22} \\<in> set l; in_list b l; singleCombinators [b];\n        a = DenyAllFromTo x21 x22; b = DenyAll\\<rbrakk>\n       \\<Longrightarrow> smaller b (DenyAllFromTo x21 x22) l\n 2. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>\\<not> smaller (DenyAllFromTo x21 x22) b l;\n        {x21, x22} \\<in> set l; in_list b l; singleCombinators [b];\n        a = DenyAllFromTo x21 x22; b = DenyAllFromTo x21a x22a\\<rbrakk>\n       \\<Longrightarrow> smaller b (DenyAllFromTo x21 x22) l\n 3. \\<And>x21 x22 x31 x32 x33.\n       \\<lbrakk>\\<not> smaller (DenyAllFromTo x21 x22) b l;\n        {x21, x22} \\<in> set l; in_list b l; singleCombinators [b];\n        a = DenyAllFromTo x21 x22; b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller b (DenyAllFromTo x21 x22) l\n 4. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>\\<not> smaller (DenyAllFromTo x21 x22) b l;\n        {x21, x22} \\<in> set l; in_list b l; singleCombinators [b];\n        a = DenyAllFromTo x21 x22; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> smaller b (DenyAllFromTo x21 x22) l\n 5. \\<And>x31 x32 x33.\n       \\<lbrakk>\\<not> smaller (AllowPortFromTo x31 x32 x33) b l;\n        {x31, x32} \\<in> set l; in_list b l; singleCombinators [b];\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller b (AllowPortFromTo x31 x32 x33) l", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>(x21 = x21a \\<longrightarrow> x22 \\<noteq> x22a) \\<and>\n                \\<not> (if {x21, x22} = {x21a, x22a}\n                        then case DenyAllFromTo x21a x22a of\n                             DenyAllFromTo a b \\<Rightarrow>\n                               DenyAllFromTo x21 x22 = DenyAllFromTo b a\n                             | _ \\<Rightarrow> True\n                        else position (bothNet (DenyAllFromTo x21 x22)) l\n                             \\<le> position\n                                    (bothNet (DenyAllFromTo x21a x22a)) l);\n        {x21, x22} \\<in> set l; {x21a, x22a} \\<in> set l;\n        a = DenyAllFromTo x21 x22; b = DenyAllFromTo x21a x22a\\<rbrakk>\n       \\<Longrightarrow> ({x21a, x22a} = {x21, x22} \\<longrightarrow>\n                          x21a = x21 \\<and> x22a = x22 \\<or>\n                          x21a = x22 \\<and> x22a = x21) \\<and>\n                         ({x21a, x22a} \\<noteq> {x21, x22} \\<longrightarrow>\n                          x21a = x21 \\<and> x22a = x22 \\<or>\n                          position {x21a, x22a} l\n                          \\<le> position {x21, x22} l)\n 2. \\<And>x21 x22 x31 x32 x33.\n       \\<lbrakk>\\<not> (if {x21, x22} = {x31, x32}\n                        then case AllowPortFromTo x31 x32 x33 of\n                             DenyAllFromTo a b \\<Rightarrow>\n                               DenyAllFromTo x21 x22 = DenyAllFromTo b a\n                             | _ \\<Rightarrow> True\n                        else position (bothNet (DenyAllFromTo x21 x22)) l\n                             \\<le> position\n                                    (bothNet (AllowPortFromTo x31 x32 x33))\n                                    l);\n        {x21, x22} \\<in> set l; {x31, x32} \\<in> set l;\n        a = DenyAllFromTo x21 x22; b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22} \\<and>\n                         ({x31, x32} \\<noteq> {x21, x22} \\<longrightarrow>\n                          position {x31, x32} l \\<le> position {x21, x22} l)\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>\\<not> smaller (AllowPortFromTo x31 x32 x33) b l;\n        {x31, x32} \\<in> set l; in_list b l; singleCombinators [b];\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller b (AllowPortFromTo x31 x32 x33) l", "apply (simp_all split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>{x21a, x22a} \\<in> set l; a = DenyAllFromTo x21 x22;\n        b = DenyAllFromTo x21a x22a; {x21, x22} = {x21a, x22a};\n        (x21 = x21a \\<longrightarrow> x22 \\<noteq> x22a) \\<and>\n        (x21 = x22a \\<longrightarrow> x22 \\<noteq> x21a)\\<rbrakk>\n       \\<Longrightarrow> x21a = x21 \\<and> x22a = x22 \\<or>\n                         x21a = x22 \\<and> x22a = x21\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>\\<not> smaller (AllowPortFromTo x31 x32 x33) b l;\n        {x31, x32} \\<in> set l; in_list b l; singleCombinators [b];\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller b (AllowPortFromTo x31 x32 x33) l", "apply (rule setPaireq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>{x21a, x22a} \\<in> set l; a = DenyAllFromTo x21 x22;\n        b = DenyAllFromTo x21a x22a; {x21, x22} = {x21a, x22a};\n        (x21 = x21a \\<longrightarrow> x22 \\<noteq> x22a) \\<and>\n        (x21 = x22a \\<longrightarrow> x22 \\<noteq> x21a)\\<rbrakk>\n       \\<Longrightarrow> {x21a, x22a} = {x21, x22}\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>\\<not> smaller (AllowPortFromTo x31 x32 x33) b l;\n        {x31, x32} \\<in> set l; in_list b l; singleCombinators [b];\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller b (AllowPortFromTo x31 x32 x33) l", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>\\<not> smaller (AllowPortFromTo x31 x32 x33) b l;\n        {x31, x32} \\<in> set l; in_list b l; singleCombinators [b];\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller b (AllowPortFromTo x31 x32 x33) l", "apply (case_tac b)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>\\<not> smaller (AllowPortFromTo x31 x32 x33) b l;\n        {x31, x32} \\<in> set l; in_list b l; singleCombinators [b];\n        a = AllowPortFromTo x31 x32 x33; b = DenyAll\\<rbrakk>\n       \\<Longrightarrow> smaller b (AllowPortFromTo x31 x32 x33) l\n 2. \\<And>x31 x32 x33 x21 x22.\n       \\<lbrakk>\\<not> smaller (AllowPortFromTo x31 x32 x33) b l;\n        {x31, x32} \\<in> set l; in_list b l; singleCombinators [b];\n        a = AllowPortFromTo x31 x32 x33; b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> smaller b (AllowPortFromTo x31 x32 x33) l\n 3. \\<And>x31 x32 x33 x31a x32a x33a.\n       \\<lbrakk>\\<not> smaller (AllowPortFromTo x31 x32 x33) b l;\n        {x31, x32} \\<in> set l; in_list b l; singleCombinators [b];\n        a = AllowPortFromTo x31 x32 x33;\n        b = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> smaller b (AllowPortFromTo x31 x32 x33) l\n 4. \\<And>x31 x32 x33 x41 x42.\n       \\<lbrakk>\\<not> smaller (AllowPortFromTo x31 x32 x33) b l;\n        {x31, x32} \\<in> set l; in_list b l; singleCombinators [b];\n        a = AllowPortFromTo x31 x32 x33; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> smaller b (AllowPortFromTo x31 x32 x33) l", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x21 x22.\n       \\<lbrakk>\\<not> (if {x31, x32} = {x21, x22}\n                        then case DenyAllFromTo x21 x22 of\n                             DenyAllFromTo a b \\<Rightarrow>\n                               AllowPortFromTo x31 x32 x33 =\n                               DenyAllFromTo b a\n                             | _ \\<Rightarrow> True\n                        else position\n                              (bothNet (AllowPortFromTo x31 x32 x33)) l\n                             \\<le> position\n                                    (bothNet (DenyAllFromTo x21 x22)) l);\n        {x31, x32} \\<in> set l; {x21, x22} \\<in> set l;\n        a = AllowPortFromTo x31 x32 x33; b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> {x31, x32} \\<longrightarrow>\n                         position {x21, x22} l \\<le> position {x31, x32} l\n 2. \\<And>x31 x32 x33 x31a x32a x33a.\n       \\<lbrakk>(x32 = x32a \\<longrightarrow>\n                 x31 = x31a \\<longrightarrow> x33 \\<noteq> x33a) \\<and>\n                \\<not> (if {x31, x32} = {x31a, x32a}\n                        then case AllowPortFromTo x31a x32a x33a of\n                             DenyAllFromTo a b \\<Rightarrow>\n                               AllowPortFromTo x31 x32 x33 =\n                               DenyAllFromTo b a\n                             | _ \\<Rightarrow> True\n                        else position\n                              (bothNet (AllowPortFromTo x31 x32 x33)) l\n                             \\<le> position\n                                    (bothNet\n(AllowPortFromTo x31a x32a x33a))\n                                    l);\n        {x31, x32} \\<in> set l; {x31a, x32a} \\<in> set l;\n        a = AllowPortFromTo x31 x32 x33;\n        b = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> {x31a, x32a} \\<noteq> {x31, x32} \\<longrightarrow>\n                         x31a = x31 \\<and>\n                         x32a = x32 \\<and> x33a = x33 \\<or>\n                         position {x31a, x32a} l \\<le> position {x31, x32} l", "apply (simp_all split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_insort_insert: \"set (insort x xs l) \\<subseteq> insert x (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (FWNormalisationCore.insort x xs l) \\<subseteq> insert x (set xs)", "by (induct xs) auto"], ["", "lemma all_in_listSubset[rule_format]: \"all_in_list b l \\<longrightarrow>singleCombinators a \\<longrightarrow> \n                                      set a \\<subseteq> set b \\<longrightarrow> all_in_list a l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list b l \\<longrightarrow>\n    singleCombinators a \\<longrightarrow>\n    set a \\<subseteq> set b \\<longrightarrow> all_in_list a l", "by (induct_tac a) (auto intro: in_set_in_list singleCombinatorsConc)"], ["", "lemma singleCombinators_insort: \"\\<lbrakk>singleCombinators [x]; singleCombinators xs\\<rbrakk> \\<Longrightarrow> \n                                 singleCombinators (insort x xs l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators [x]; singleCombinators xs\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (FWNormalisationCore.insort x xs l)", "by (metis NormalisationGenericProofs.set_insort aux0_0 aux0_1 aux0_5 list.simps(15))"], ["", "lemma all_in_list_insort: \"\\<lbrakk>all_in_list xs l; singleCombinators (x#xs); \n                           in_list x l\\<rbrakk> \\<Longrightarrow>  all_in_list (insort x xs l) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_in_list xs l; singleCombinators (x # xs);\n     in_list x l\\<rbrakk>\n    \\<Longrightarrow> all_in_list (FWNormalisationCore.insort x xs l) l", "apply (rule_tac b = \"x#xs\" in all_in_listSubset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>all_in_list xs l; singleCombinators (x # xs);\n     in_list x l\\<rbrakk>\n    \\<Longrightarrow> all_in_list (x # xs) l\n 2. \\<lbrakk>all_in_list xs l; singleCombinators (x # xs);\n     in_list x l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (FWNormalisationCore.insort x xs l)\n 3. \\<lbrakk>all_in_list xs l; singleCombinators (x # xs);\n     in_list x l\\<rbrakk>\n    \\<Longrightarrow> set (FWNormalisationCore.insort x xs l)\n                      \\<subseteq> set (x # xs)", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>all_in_list xs l; singleCombinators (x # xs);\n     in_list x l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (FWNormalisationCore.insort x xs l)\n 2. \\<lbrakk>all_in_list xs l; singleCombinators (x # xs);\n     in_list x l\\<rbrakk>\n    \\<Longrightarrow> set (FWNormalisationCore.insort x xs l)\n                      \\<subseteq> insert x (set xs)", "apply (metis singleCombinatorsConc singleCombinatorsStart\n      singleCombinators_insort)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_in_list xs l; singleCombinators (x # xs);\n     in_list x l\\<rbrakk>\n    \\<Longrightarrow> set (FWNormalisationCore.insort x xs l)\n                      \\<subseteq> insert x (set xs)", "apply (rule set_insort_insert)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sorted_ConsA:\"\\<lbrakk>all_in_list (x#xs) l; singleCombinators (x#xs)\\<rbrakk> \\<Longrightarrow> \n              (sorted (x#xs) l)  = (sorted xs l & (\\<forall>y\\<in>set xs. smaller x y l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_in_list (x # xs) l; singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted (x # xs) l =\n                      (FWNormalisationCore.sorted xs l \\<and>\n                       (\\<forall>y\\<in>set xs. smaller x y l))", "by (metis sorted_Cons)"], ["", "lemma is_in_insort: \"y \\<in> set xs \\<Longrightarrow> y \\<in> set (insort x xs l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set xs \\<Longrightarrow>\n    y \\<in> set (FWNormalisationCore.insort x xs l)", "by (simp add: NormalisationGenericProofs.set_insort)"], ["", "lemma sorted_insorta[rule_format]:\n  assumes 1 : \"sorted (insort x xs l) l\"\n    and   2 : \"all_in_list (x#xs) l\" \n    and   3 : \"all_in_list (x#xs) l\"\n    and   4 : \"distinct (x#xs)\"\n    and   5 : \"singleCombinators [x]\"\n    and   6 : \"singleCombinators xs\"\n  shows       \"sorted xs l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted xs l", "proof (insert 1 2 3 4 5 6, induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted (FWNormalisationCore.insort x [] l)\n              l;\n     all_in_list [x] l; all_in_list [x] l; distinct [x];\n     singleCombinators [x]; singleCombinators []\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted [] l\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>FWNormalisationCore.sorted\n                          (FWNormalisationCore.insort x xs l) l;\n                 all_in_list (x # xs) l; all_in_list (x # xs) l;\n                 distinct (x # xs); singleCombinators [x];\n                 singleCombinators xs\\<rbrakk>\n                \\<Longrightarrow> FWNormalisationCore.sorted xs l;\n        FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l)\n         l;\n        all_in_list (x # a # xs) l; all_in_list (x # a # xs) l;\n        distinct (x # a # xs); singleCombinators [x];\n        singleCombinators (a # xs)\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # xs) l", "case Nil"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted (FWNormalisationCore.insort x [] l) l\n  all_in_list [x] l\n  all_in_list [x] l\n  distinct [x]\n  singleCombinators [x]\n  singleCombinators []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted (FWNormalisationCore.insort x [] l)\n              l;\n     all_in_list [x] l; all_in_list [x] l; distinct [x];\n     singleCombinators [x]; singleCombinators []\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted [] l\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>FWNormalisationCore.sorted\n                          (FWNormalisationCore.insort x xs l) l;\n                 all_in_list (x # xs) l; all_in_list (x # xs) l;\n                 distinct (x # xs); singleCombinators [x];\n                 singleCombinators xs\\<rbrakk>\n                \\<Longrightarrow> FWNormalisationCore.sorted xs l;\n        FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l)\n         l;\n        all_in_list (x # a # xs) l; all_in_list (x # a # xs) l;\n        distinct (x # a # xs); singleCombinators [x];\n        singleCombinators (a # xs)\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # xs) l", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted [] l", "by simp"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted [] l\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>FWNormalisationCore.sorted\n                          (FWNormalisationCore.insort x xs l) l;\n                 all_in_list (x # xs) l; all_in_list (x # xs) l;\n                 distinct (x # xs); singleCombinators [x];\n                 singleCombinators xs\\<rbrakk>\n                \\<Longrightarrow> FWNormalisationCore.sorted xs l;\n        FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l)\n         l;\n        all_in_list (x # a # xs) l; all_in_list (x # a # xs) l;\n        distinct (x # a # xs); singleCombinators [x];\n        singleCombinators (a # xs)\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # xs) l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>FWNormalisationCore.sorted\n                          (FWNormalisationCore.insort x xs l) l;\n                 all_in_list (x # xs) l; all_in_list (x # xs) l;\n                 distinct (x # xs); singleCombinators [x];\n                 singleCombinators xs\\<rbrakk>\n                \\<Longrightarrow> FWNormalisationCore.sorted xs l;\n        FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l)\n         l;\n        all_in_list (x # a # xs) l; all_in_list (x # a # xs) l;\n        distinct (x # a # xs); singleCombinators [x];\n        singleCombinators (a # xs)\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # xs) l", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n   all_in_list (x # xs) l; all_in_list (x # xs) l; distinct (x # xs);\n   singleCombinators [x]; singleCombinators xs\\<rbrakk>\n  \\<Longrightarrow> FWNormalisationCore.sorted xs l\n  FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l) l\n  all_in_list (x # a # xs) l\n  all_in_list (x # a # xs) l\n  distinct (x # a # xs)\n  singleCombinators [x]\n  singleCombinators (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>FWNormalisationCore.sorted\n                          (FWNormalisationCore.insort x xs l) l;\n                 all_in_list (x # xs) l; all_in_list (x # xs) l;\n                 distinct (x # xs); singleCombinators [x];\n                 singleCombinators xs\\<rbrakk>\n                \\<Longrightarrow> FWNormalisationCore.sorted xs l;\n        FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l)\n         l;\n        all_in_list (x # a # xs) l; all_in_list (x # a # xs) l;\n        distinct (x # a # xs); singleCombinators [x];\n        singleCombinators (a # xs)\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # xs) l", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n   all_in_list (x # xs) l; all_in_list (x # xs) l; distinct (x # xs);\n   singleCombinators [x]; singleCombinators xs\\<rbrakk>\n  \\<Longrightarrow> FWNormalisationCore.sorted xs l\n  FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l) l\n  all_in_list (x # a # xs) l\n  all_in_list (x # a # xs) l\n  distinct (x # a # xs)\n  singleCombinators [x]\n  singleCombinators (a # xs)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n   all_in_list (x # xs) l; all_in_list (x # xs) l; distinct (x # xs);\n   singleCombinators [x]; singleCombinators xs\\<rbrakk>\n  \\<Longrightarrow> FWNormalisationCore.sorted xs l\n  FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l) l\n  all_in_list (x # a # xs) l\n  all_in_list (x # a # xs) l\n  distinct (x # a # xs)\n  singleCombinators [x]\n  singleCombinators (a # xs)\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # xs) l", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>FWNormalisationCore.sorted\n                       (FWNormalisationCore.insort x xs l) l;\n              singleCombinators xs\\<rbrakk>\n             \\<Longrightarrow> FWNormalisationCore.sorted xs l;\n     FWNormalisationCore.sorted\n      (if smaller x a l then x # a # xs\n       else a # FWNormalisationCore.insort x xs l)\n      l;\n     in_list x l \\<and> in_list a l \\<and> all_in_list xs l;\n     x \\<noteq> a \\<and>\n     x \\<notin> set xs \\<and> a \\<notin> set xs \\<and> distinct xs;\n     singleCombinators [x]; singleCombinators (a # xs)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted (a # xs) l", "apply (auto intro: is_in_insort sorted_ConsA set_insort singleCombinators_insort \n        singleCombinatorsConc sortedConcEnd all_in_list_insort) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>FWNormalisationCore.sorted\n                       (FWNormalisationCore.insort x xs l) l;\n              singleCombinators xs\\<rbrakk>\n             \\<Longrightarrow> FWNormalisationCore.sorted xs l;\n     FWNormalisationCore.sorted\n      (if smaller x a l then x # a # xs\n       else a # FWNormalisationCore.insort x xs l)\n      l;\n     singleCombinators [x]; singleCombinators (a # xs); in_list x l;\n     x \\<noteq> a; in_list a l; all_in_list xs l; x \\<notin> set xs;\n     a \\<notin> set xs; distinct xs\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted (a # xs) l", "apply(cases \"smaller x a l\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>FWNormalisationCore.sorted\n                       (FWNormalisationCore.insort x xs l) l;\n              singleCombinators xs\\<rbrakk>\n             \\<Longrightarrow> FWNormalisationCore.sorted xs l;\n     FWNormalisationCore.sorted (a # FWNormalisationCore.insort x xs l) l;\n     singleCombinators [x]; singleCombinators (a # xs); in_list x l;\n     x \\<noteq> a; in_list a l; all_in_list xs l; x \\<notin> set xs;\n     a \\<notin> set xs; distinct xs; \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted (a # xs) l", "by (metis NormalisationGenericProofs.set_insort NormalisationGenericProofs.sorted_Cons \n        all_in_list.simps(2) all_in_list_insort aux0_1 insert_iff singleCombinatorsConc \n        singleCombinatorsStart singleCombinators_insort)"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted (a # xs) l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_insortb[rule_format]: \n  \"sorted xs l \\<longrightarrow> all_in_list (x#xs) l \\<longrightarrow> distinct (x#xs) \\<longrightarrow> \n   singleCombinators [x] \\<longrightarrow> singleCombinators xs \\<longrightarrow> sorted (insort x xs l) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted xs l \\<longrightarrow>\n    all_in_list (x # xs) l \\<longrightarrow>\n    distinct (x # xs) \\<longrightarrow>\n    singleCombinators [x] \\<longrightarrow>\n    singleCombinators xs \\<longrightarrow>\n    FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. FWNormalisationCore.sorted [] l \\<longrightarrow>\n    all_in_list [x] l \\<longrightarrow>\n    distinct [x] \\<longrightarrow>\n    singleCombinators [x] \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow>\n    FWNormalisationCore.sorted (FWNormalisationCore.insort x [] l) l\n 2. \\<And>a xs.\n       FWNormalisationCore.sorted xs l \\<longrightarrow>\n       all_in_list (x # xs) l \\<longrightarrow>\n       distinct (x # xs) \\<longrightarrow>\n       singleCombinators [x] \\<longrightarrow>\n       singleCombinators xs \\<longrightarrow>\n       FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l)\n        l \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # xs) l \\<longrightarrow>\n       all_in_list (x # a # xs) l \\<longrightarrow>\n       distinct (x # a # xs) \\<longrightarrow>\n       singleCombinators [x] \\<longrightarrow>\n       singleCombinators (a # xs) \\<longrightarrow>\n       FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l)\n        l", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. FWNormalisationCore.sorted [] l \\<longrightarrow>\n    all_in_list [x] l \\<longrightarrow>\n    distinct [x] \\<longrightarrow>\n    singleCombinators [x] \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow>\n    FWNormalisationCore.sorted (FWNormalisationCore.insort x [] l) l\n 2. \\<And>a xs.\n       FWNormalisationCore.sorted xs l \\<longrightarrow>\n       all_in_list (x # xs) l \\<longrightarrow>\n       distinct (x # xs) \\<longrightarrow>\n       singleCombinators [x] \\<longrightarrow>\n       singleCombinators xs \\<longrightarrow>\n       FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l)\n        l \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # xs) l \\<longrightarrow>\n       all_in_list (x # a # xs) l \\<longrightarrow>\n       distinct (x # a # xs) \\<longrightarrow>\n       singleCombinators [x] \\<longrightarrow>\n       singleCombinators (a # xs) \\<longrightarrow>\n       FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l)\n        l", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted [] l \\<longrightarrow>\n    all_in_list [x] l \\<longrightarrow>\n    distinct [x] \\<longrightarrow>\n    singleCombinators [x] \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow>\n    FWNormalisationCore.sorted (FWNormalisationCore.insort x [] l) l", "by simp_all"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted [] l \\<longrightarrow>\n  all_in_list [x] l \\<longrightarrow>\n  distinct [x] \\<longrightarrow>\n  singleCombinators [x] \\<longrightarrow>\n  singleCombinators [] \\<longrightarrow>\n  FWNormalisationCore.sorted (FWNormalisationCore.insort x [] l) l\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       FWNormalisationCore.sorted xs l \\<longrightarrow>\n       all_in_list (x # xs) l \\<longrightarrow>\n       distinct (x # xs) \\<longrightarrow>\n       singleCombinators [x] \\<longrightarrow>\n       singleCombinators xs \\<longrightarrow>\n       FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l)\n        l \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # xs) l \\<longrightarrow>\n       all_in_list (x # a # xs) l \\<longrightarrow>\n       distinct (x # a # xs) \\<longrightarrow>\n       singleCombinators [x] \\<longrightarrow>\n       singleCombinators (a # xs) \\<longrightarrow>\n       FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l)\n        l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       FWNormalisationCore.sorted xs l \\<longrightarrow>\n       all_in_list (x # xs) l \\<longrightarrow>\n       distinct (x # xs) \\<longrightarrow>\n       singleCombinators [x] \\<longrightarrow>\n       singleCombinators xs \\<longrightarrow>\n       FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l)\n        l \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # xs) l \\<longrightarrow>\n       all_in_list (x # a # xs) l \\<longrightarrow>\n       distinct (x # a # xs) \\<longrightarrow>\n       singleCombinators [x] \\<longrightarrow>\n       singleCombinators (a # xs) \\<longrightarrow>\n       FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l)\n        l", "case (Cons a xs)"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted xs l \\<longrightarrow>\n  all_in_list (x # xs) l \\<longrightarrow>\n  distinct (x # xs) \\<longrightarrow>\n  singleCombinators [x] \\<longrightarrow>\n  singleCombinators xs \\<longrightarrow>\n  FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       FWNormalisationCore.sorted xs l \\<longrightarrow>\n       all_in_list (x # xs) l \\<longrightarrow>\n       distinct (x # xs) \\<longrightarrow>\n       singleCombinators [x] \\<longrightarrow>\n       singleCombinators xs \\<longrightarrow>\n       FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l)\n        l \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # xs) l \\<longrightarrow>\n       all_in_list (x # a # xs) l \\<longrightarrow>\n       distinct (x # a # xs) \\<longrightarrow>\n       singleCombinators [x] \\<longrightarrow>\n       singleCombinators (a # xs) \\<longrightarrow>\n       FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l)\n        l", "have * : \"sorted (a # xs) l \\<Longrightarrow>      all_in_list (x # a # xs) l \\<Longrightarrow>\n              distinct (x # a # xs) \\<Longrightarrow>  singleCombinators [x] \\<Longrightarrow>\n              singleCombinators (a # xs) \\<Longrightarrow> sorted (insort x xs l) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l;\n     all_in_list (x # a # xs) l; distinct (x # a # xs);\n     singleCombinators [x]; singleCombinators (a # xs)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (FWNormalisationCore.insort x xs l) l", "apply(insert Cons.hyps, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l;\n     in_list x l \\<and> in_list a l \\<and> all_in_list xs l;\n     x \\<noteq> a \\<and>\n     x \\<notin> set xs \\<and> a \\<notin> set xs \\<and> distinct xs;\n     singleCombinators [x]; singleCombinators (a # xs);\n     FWNormalisationCore.sorted xs l \\<longrightarrow>\n     singleCombinators xs \\<longrightarrow>\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l)\n      l\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (FWNormalisationCore.insort x xs l) l", "apply(metis sorted_Cons all_in_list.simps(2)  singleCombinatorsConc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>FWNormalisationCore.sorted (a # xs) l;\n   all_in_list (x # a # xs) l; distinct (x # a # xs); singleCombinators [x];\n   singleCombinators (a # xs)\\<rbrakk>\n  \\<Longrightarrow> FWNormalisationCore.sorted\n                     (FWNormalisationCore.insort x xs l) l\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       FWNormalisationCore.sorted xs l \\<longrightarrow>\n       all_in_list (x # xs) l \\<longrightarrow>\n       distinct (x # xs) \\<longrightarrow>\n       singleCombinators [x] \\<longrightarrow>\n       singleCombinators xs \\<longrightarrow>\n       FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l)\n        l \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # xs) l \\<longrightarrow>\n       all_in_list (x # a # xs) l \\<longrightarrow>\n       distinct (x # a # xs) \\<longrightarrow>\n       singleCombinators [x] \\<longrightarrow>\n       singleCombinators (a # xs) \\<longrightarrow>\n       FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l)\n        l", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # xs) l \\<longrightarrow>\n    all_in_list (x # a # xs) l \\<longrightarrow>\n    distinct (x # a # xs) \\<longrightarrow>\n    singleCombinators [x] \\<longrightarrow>\n    singleCombinators (a # xs) \\<longrightarrow>\n    FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l) l", "apply (insert Cons.hyps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted xs l \\<longrightarrow>\n    all_in_list (x # xs) l \\<longrightarrow>\n    distinct (x # xs) \\<longrightarrow>\n    singleCombinators [x] \\<longrightarrow>\n    singleCombinators xs \\<longrightarrow>\n    FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l)\n     l \\<Longrightarrow>\n    FWNormalisationCore.sorted (a # xs) l \\<longrightarrow>\n    all_in_list (x # a # xs) l \\<longrightarrow>\n    distinct (x # a # xs) \\<longrightarrow>\n    singleCombinators [x] \\<longrightarrow>\n    singleCombinators (a # xs) \\<longrightarrow>\n    FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l) l", "apply (rule impI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FWNormalisationCore.sorted xs l \\<longrightarrow>\n             all_in_list (x # xs) l \\<longrightarrow>\n             distinct (x # xs) \\<longrightarrow>\n             singleCombinators [x] \\<longrightarrow>\n             singleCombinators xs \\<longrightarrow>\n             FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l)\n              l;\n     FWNormalisationCore.sorted (a # xs) l; all_in_list (x # a # xs) l;\n     distinct (x # a # xs); singleCombinators [x];\n     singleCombinators (a # xs)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (FWNormalisationCore.insort x (a # xs) l) l", "apply (insert *, auto intro!: sorted_Consb)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> all_in_list (FWNormalisationCore.insort x xs l) l\n 2. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (a # FWNormalisationCore.insort x xs l)\n 3. \\<And>y.\n       \\<lbrakk>FWNormalisationCore.sorted (a # xs) l;\n        singleCombinators [x]; singleCombinators (a # xs);\n        FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n        in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n        x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n        \\<not> smaller x a l;\n        y \\<in> set (FWNormalisationCore.insort x xs l)\\<rbrakk>\n       \\<Longrightarrow> smaller a y l", "proof (rule_tac b = \"x#xs\" in all_in_listSubset)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> all_in_list (x # xs) l\n 2. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (FWNormalisationCore.insort x xs l)\n 3. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> set (FWNormalisationCore.insort x xs l)\n                      \\<subseteq> set (x # xs)\n 4. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (a # FWNormalisationCore.insort x xs l)\n 5. \\<And>y.\n       \\<lbrakk>FWNormalisationCore.sorted (a # xs) l;\n        singleCombinators [x]; singleCombinators (a # xs);\n        FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n        in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n        x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n        \\<not> smaller x a l;\n        y \\<in> set (FWNormalisationCore.insort x xs l)\\<rbrakk>\n       \\<Longrightarrow> smaller a y l", "show \"in_list x l \\<Longrightarrow> all_in_list xs l \\<Longrightarrow> all_in_list (x # xs) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>in_list x l; all_in_list xs l\\<rbrakk>\n    \\<Longrightarrow> all_in_list (x # xs) l", "by simp_all"], ["proof (state)\nthis:\n  \\<lbrakk>in_list x l; all_in_list xs l\\<rbrakk>\n  \\<Longrightarrow> all_in_list (x # xs) l\n\ngoal (4 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (FWNormalisationCore.insort x xs l)\n 2. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> set (FWNormalisationCore.insort x xs l)\n                      \\<subseteq> set (x # xs)\n 3. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (a # FWNormalisationCore.insort x xs l)\n 4. \\<And>y.\n       \\<lbrakk>FWNormalisationCore.sorted (a # xs) l;\n        singleCombinators [x]; singleCombinators (a # xs);\n        FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n        in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n        x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n        \\<not> smaller x a l;\n        y \\<in> set (FWNormalisationCore.insort x xs l)\\<rbrakk>\n       \\<Longrightarrow> smaller a y l", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (FWNormalisationCore.insort x xs l)\n 2. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> set (FWNormalisationCore.insort x xs l)\n                      \\<subseteq> set (x # xs)\n 3. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (a # FWNormalisationCore.insort x xs l)\n 4. \\<And>y.\n       \\<lbrakk>FWNormalisationCore.sorted (a # xs) l;\n        singleCombinators [x]; singleCombinators (a # xs);\n        FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n        in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n        x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n        \\<not> smaller x a l;\n        y \\<in> set (FWNormalisationCore.insort x xs l)\\<rbrakk>\n       \\<Longrightarrow> smaller a y l", "show \"singleCombinators [x] \\<Longrightarrow>\n                       singleCombinators (a # xs) \\<Longrightarrow>\n                       FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l \\<Longrightarrow>\n                       singleCombinators (FWNormalisationCore.insort x xs l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators [x]; singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l)\n      l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (FWNormalisationCore.insort x xs l)", "apply (rule singleCombinators_insort, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators [x]; singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l)\n      l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators xs", "by (erule singleCombinatorsConc)"], ["proof (state)\nthis:\n  \\<lbrakk>singleCombinators [x]; singleCombinators (a # xs);\n   FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l\\<rbrakk>\n  \\<Longrightarrow> singleCombinators (FWNormalisationCore.insort x xs l)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> set (FWNormalisationCore.insort x xs l)\n                      \\<subseteq> set (x # xs)\n 2. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (a # FWNormalisationCore.insort x xs l)\n 3. \\<And>y.\n       \\<lbrakk>FWNormalisationCore.sorted (a # xs) l;\n        singleCombinators [x]; singleCombinators (a # xs);\n        FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n        in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n        x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n        \\<not> smaller x a l;\n        y \\<in> set (FWNormalisationCore.insort x xs l)\\<rbrakk>\n       \\<Longrightarrow> smaller a y l", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> set (FWNormalisationCore.insort x xs l)\n                      \\<subseteq> set (x # xs)\n 2. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (a # FWNormalisationCore.insort x xs l)\n 3. \\<And>y.\n       \\<lbrakk>FWNormalisationCore.sorted (a # xs) l;\n        singleCombinators [x]; singleCombinators (a # xs);\n        FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n        in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n        x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n        \\<not> smaller x a l;\n        y \\<in> set (FWNormalisationCore.insort x xs l)\\<rbrakk>\n       \\<Longrightarrow> smaller a y l", "show \"set (FWNormalisationCore.insort x xs l) \\<subseteq> set (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (FWNormalisationCore.insort x xs l) \\<subseteq> set (x # xs)", "using NormalisationGenericProofs.set_insort_insert"], ["proof (prove)\nusing this:\n  set (FWNormalisationCore.insort ?x ?xs ?l) \\<subseteq> insert ?x (set ?xs)\n\ngoal (1 subgoal):\n 1. set (FWNormalisationCore.insort x xs l) \\<subseteq> set (x # xs)", "by auto"], ["proof (state)\nthis:\n  set (FWNormalisationCore.insort x xs l) \\<subseteq> set (x # xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (a # FWNormalisationCore.insort x xs l)\n 2. \\<And>y.\n       \\<lbrakk>FWNormalisationCore.sorted (a # xs) l;\n        singleCombinators [x]; singleCombinators (a # xs);\n        FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n        in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n        x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n        \\<not> smaller x a l;\n        y \\<in> set (FWNormalisationCore.insort x xs l)\\<rbrakk>\n       \\<Longrightarrow> smaller a y l", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs);\n     FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n     in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n     x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n     \\<not> smaller x a l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (a # FWNormalisationCore.insort x xs l)\n 2. \\<And>y.\n       \\<lbrakk>FWNormalisationCore.sorted (a # xs) l;\n        singleCombinators [x]; singleCombinators (a # xs);\n        FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n        in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n        x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n        \\<not> smaller x a l;\n        y \\<in> set (FWNormalisationCore.insort x xs l)\\<rbrakk>\n       \\<Longrightarrow> smaller a y l", "show \"singleCombinators [x] \\<Longrightarrow>\n                       singleCombinators (a # xs) \\<Longrightarrow>\n                      singleCombinators (a # FWNormalisationCore.insort x xs l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators [x]; singleCombinators (a # xs)\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (a # FWNormalisationCore.insort x xs l)", "by (metis SCConca singleCombinatorsConc singleCombinatorsStart  \n          singleCombinators_insort)"], ["proof (state)\nthis:\n  \\<lbrakk>singleCombinators [x]; singleCombinators (a # xs)\\<rbrakk>\n  \\<Longrightarrow> singleCombinators\n                     (a # FWNormalisationCore.insort x xs l)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>FWNormalisationCore.sorted (a # xs) l;\n        singleCombinators [x]; singleCombinators (a # xs);\n        FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n        in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n        x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n        \\<not> smaller x a l;\n        y \\<in> set (FWNormalisationCore.insort x xs l)\\<rbrakk>\n       \\<Longrightarrow> smaller a y l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>FWNormalisationCore.sorted (a # xs) l;\n        singleCombinators [x]; singleCombinators (a # xs);\n        FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n        in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n        x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n        \\<not> smaller x a l;\n        y \\<in> set (FWNormalisationCore.insort x xs l)\\<rbrakk>\n       \\<Longrightarrow> smaller a y l", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>FWNormalisationCore.sorted (a # xs) l;\n        singleCombinators [x]; singleCombinators (a # xs);\n        FWNormalisationCore.sorted (FWNormalisationCore.insort x xs l) l;\n        in_list x l; x \\<noteq> a; in_list a l; all_in_list xs l;\n        x \\<notin> set xs; a \\<notin> set xs; distinct xs;\n        \\<not> smaller x a l;\n        y \\<in> set (FWNormalisationCore.insort x xs l)\\<rbrakk>\n       \\<Longrightarrow> smaller a y l", "show \"FWNormalisationCore.sorted (a # xs) l \\<Longrightarrow>\n                       singleCombinators [x] \\<Longrightarrow>  singleCombinators (a # xs) \\<Longrightarrow>\n                       in_list x l \\<Longrightarrow>  in_list a l \\<Longrightarrow> all_in_list xs l \\<Longrightarrow>\n                       \\<not> smaller x a l \\<Longrightarrow> y \\<in> set (FWNormalisationCore.insort x xs l) \\<Longrightarrow> \n                      smaller a y l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n     singleCombinators (a # xs); in_list x l; in_list a l; all_in_list xs l;\n     \\<not> smaller x a l;\n     y \\<in> set (FWNormalisationCore.insort x xs l)\\<rbrakk>\n    \\<Longrightarrow> smaller a y l", "by (metis NormalisationGenericProofs.set_insort in_set_in_list insert_iff \n          singleCombinatorsConc singleCombinatorsStart smaller_antisym \n          sorted_is_smaller)"], ["proof (state)\nthis:\n  \\<lbrakk>FWNormalisationCore.sorted (a # xs) l; singleCombinators [x];\n   singleCombinators (a # xs); in_list x l; in_list a l; all_in_list xs l;\n   \\<not> smaller x a l;\n   y \\<in> set (FWNormalisationCore.insort x xs l)\\<rbrakk>\n  \\<Longrightarrow> smaller a y l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted (a # xs) l \\<longrightarrow>\n  all_in_list (x # a # xs) l \\<longrightarrow>\n  distinct (x # a # xs) \\<longrightarrow>\n  singleCombinators [x] \\<longrightarrow>\n  singleCombinators (a # xs) \\<longrightarrow>\n  FWNormalisationCore.sorted (FWNormalisationCore.insort x (a # xs) l) l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_insort: \n  \"\\<lbrakk>all_in_list (x#xs) l; distinct(x#xs); singleCombinators [x];\n                     singleCombinators xs\\<rbrakk> \\<Longrightarrow>\n                  sorted (insort x xs l) l = sorted xs l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_in_list (x # xs) l; distinct (x # xs);\n     singleCombinators [x]; singleCombinators xs\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (FWNormalisationCore.insort x xs l) l =\n                      FWNormalisationCore.sorted xs l", "by (auto intro: sorted_insorta sorted_insortb)"], ["", "lemma distinct_insort: \"distinct (insort x xs l) = (x \\<notin> set xs \\<and> distinct xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (FWNormalisationCore.insort x xs l) =\n    (x \\<notin> set xs \\<and> distinct xs)", "by(induct xs)(auto simp:set_insort)"], ["", "lemma distinct_sort[simp]: \"distinct (sort xs l) = distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (FWNormalisationCore.sort xs l) = distinct xs", "by(induct xs)(simp_all add:distinct_insort)"], ["", "lemma sort_is_sorted[rule_format]: \n  \"all_in_list p l \\<longrightarrow> distinct p \\<longrightarrow> singleCombinators p \\<longrightarrow> sorted (sort p l) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list p l \\<longrightarrow>\n    distinct p \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    FWNormalisationCore.sorted (FWNormalisationCore.sort p l) l", "apply (induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. all_in_list [] l \\<longrightarrow>\n    distinct [] \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow>\n    FWNormalisationCore.sorted (FWNormalisationCore.sort [] l) l\n 2. \\<And>a p.\n       all_in_list p l \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (FWNormalisationCore.sort p l)\n        l \\<Longrightarrow>\n       all_in_list (a # p) l \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       FWNormalisationCore.sorted (FWNormalisationCore.sort (a # p) l) l", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       all_in_list p l \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (FWNormalisationCore.sort p l)\n        l \\<Longrightarrow>\n       all_in_list (a # p) l \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       FWNormalisationCore.sorted (FWNormalisationCore.sort (a # p) l) l", "by (metis (no_types, lifting) NormalisationGenericProofs.distinct_sort \n      NormalisationGenericProofs.set_sort SC3 all_in_list.simps(2) all_in_listSubset \n      distinct.simps(2) set_subset_Cons singleCombinatorsConc singleCombinatorsStart \n      sort.simps(2) sorted_insortb)"], ["", "lemma smaller_sym[rule_format]: \"all_in_list [a] l \\<longrightarrow> smaller a a l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list [a] l \\<longrightarrow> smaller a a l", "by (case_tac a,simp_all)"], ["", "lemma SC_sublist[rule_format]: \n  \"singleCombinators xs \\<Longrightarrow> singleCombinators (qsort [y\\<leftarrow>xs. P y] l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators xs \\<Longrightarrow>\n    singleCombinators (qsort (filter P xs) l)", "by (auto intro: SCSubset)"], ["", "lemma all_in_list_sublist[rule_format]: \n  \"singleCombinators xs \\<longrightarrow> all_in_list xs l \\<longrightarrow> all_in_list (qsort [y\\<leftarrow>xs. P y] l) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators xs \\<longrightarrow>\n    all_in_list xs l \\<longrightarrow> all_in_list (qsort (filter P xs) l) l", "by (auto intro: all_in_listSubset SC_sublist)"], ["", "lemma SC_sublist2[rule_format]: \n  \"singleCombinators xs \\<longrightarrow> singleCombinators ([y\\<leftarrow>xs. P y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators xs \\<longrightarrow> singleCombinators (filter P xs)", "by (auto intro: SCSubset)"], ["", "lemma all_in_list_sublist2[rule_format]: \n  \"singleCombinators xs \\<longrightarrow> all_in_list xs l \\<longrightarrow> all_in_list ( [y\\<leftarrow>xs. P y]) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators xs \\<longrightarrow>\n    all_in_list xs l \\<longrightarrow> all_in_list (filter P xs) l", "by (auto intro: all_in_listSubset SC_sublist2)"], ["", "lemma all_in_listAppend[rule_format]: \n  \"all_in_list (xs) l \\<longrightarrow> all_in_list (ys) l \\<longrightarrow> all_in_list (xs @ ys) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list xs l \\<longrightarrow>\n    all_in_list ys l \\<longrightarrow> all_in_list (xs @ ys) l", "by (induct xs) simp_all"], ["", "lemma distinct_sortQ[rule_format]: \n  \"singleCombinators xs \\<longrightarrow> all_in_list xs l \\<longrightarrow> distinct xs \\<longrightarrow> distinct (qsort xs l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators xs \\<longrightarrow>\n    all_in_list xs l \\<longrightarrow>\n    distinct xs \\<longrightarrow> distinct (qsort xs l)", "apply (induct xs l rule: qsort.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       singleCombinators [] \\<longrightarrow>\n       all_in_list [] l \\<longrightarrow>\n       distinct [] \\<longrightarrow> distinct (qsort [] l)\n 2. \\<And>x xs l.\n       \\<lbrakk>singleCombinators\n                 (filter (\\<lambda>y. \\<not> smaller x y l)\n                   xs) \\<longrightarrow>\n                all_in_list (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                 l \\<longrightarrow>\n                distinct\n                 (filter (\\<lambda>y. \\<not> smaller x y l)\n                   xs) \\<longrightarrow>\n                distinct\n                 (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l);\n        singleCombinators\n         (filter (\\<lambda>y. smaller x y l) xs) \\<longrightarrow>\n        all_in_list (filter (\\<lambda>y. smaller x y l) xs)\n         l \\<longrightarrow>\n        distinct (filter (\\<lambda>y. smaller x y l) xs) \\<longrightarrow>\n        distinct (qsort (filter (\\<lambda>y. smaller x y l) xs) l)\\<rbrakk>\n       \\<Longrightarrow> singleCombinators (x # xs) \\<longrightarrow>\n                         all_in_list (x # xs) l \\<longrightarrow>\n                         distinct (x # xs) \\<longrightarrow>\n                         distinct (qsort (x # xs) l)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs l.\n       \\<lbrakk>singleCombinators\n                 (filter (\\<lambda>y. \\<not> smaller x y l)\n                   xs) \\<longrightarrow>\n                all_in_list (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                 l \\<longrightarrow>\n                distinct\n                 (filter (\\<lambda>y. \\<not> smaller x y l)\n                   xs) \\<longrightarrow>\n                distinct\n                 (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l);\n        singleCombinators\n         (filter (\\<lambda>y. smaller x y l) xs) \\<longrightarrow>\n        all_in_list (filter (\\<lambda>y. smaller x y l) xs)\n         l \\<longrightarrow>\n        distinct (filter (\\<lambda>y. smaller x y l) xs) \\<longrightarrow>\n        distinct (qsort (filter (\\<lambda>y. smaller x y l) xs) l)\\<rbrakk>\n       \\<Longrightarrow> singleCombinators (x # xs) \\<longrightarrow>\n                         all_in_list (x # xs) l \\<longrightarrow>\n                         distinct (x # xs) \\<longrightarrow>\n                         distinct (qsort (x # xs) l)", "apply (auto simp: SC_sublist2 singleCombinatorsConc all_in_list_sublist2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma singleCombinatorsAppend[rule_format]: \n  \"singleCombinators (xs) \\<longrightarrow> singleCombinators (ys) \\<longrightarrow> singleCombinators (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators xs \\<longrightarrow>\n    singleCombinators ys \\<longrightarrow> singleCombinators (xs @ ys)", "apply (induct xs, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs.\n       \\<lbrakk>singleCombinators (a # xs); singleCombinators ys;\n        \\<not> singleCombinators xs\\<rbrakk>\n       \\<Longrightarrow> singleCombinators (a # xs @ ys)\n 2. \\<And>a xs.\n       \\<lbrakk>singleCombinators (a # xs); singleCombinators ys;\n        singleCombinators (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> singleCombinators (a # xs @ ys)", "subgoal for a as"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators (a # as); singleCombinators ys;\n     \\<not> singleCombinators as\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (a # as @ ys)", "apply (case_tac a,simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>singleCombinators (a # xs); singleCombinators ys;\n        singleCombinators (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> singleCombinators (a # xs @ ys)", "subgoal for a as"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators (a # as); singleCombinators ys;\n     singleCombinators (as @ ys)\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (a # as @ ys)", "apply (case_tac a,simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sorted_append1[rule_format]:\n  \"all_in_list xs l  \\<longrightarrow> singleCombinators xs \\<longrightarrow>\n   all_in_list ys l  \\<longrightarrow> singleCombinators ys \\<longrightarrow> \n  (sorted (xs@ys) l \\<longrightarrow> \n  (sorted xs l & sorted ys l & (\\<forall>x \\<in> set xs. \\<forall>y \\<in> set ys. smaller x y l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list xs l \\<longrightarrow>\n    singleCombinators xs \\<longrightarrow>\n    all_in_list ys l \\<longrightarrow>\n    singleCombinators ys \\<longrightarrow>\n    FWNormalisationCore.sorted (xs @ ys) l \\<longrightarrow>\n    FWNormalisationCore.sorted xs l \\<and>\n    FWNormalisationCore.sorted ys l \\<and>\n    (\\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. smaller x y l)", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. all_in_list [] l \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow>\n    all_in_list ys l \\<longrightarrow>\n    singleCombinators ys \\<longrightarrow>\n    FWNormalisationCore.sorted ([] @ ys) l \\<longrightarrow>\n    FWNormalisationCore.sorted [] l \\<and>\n    FWNormalisationCore.sorted ys l \\<and>\n    (\\<forall>x\\<in>set []. \\<forall>y\\<in>set ys. smaller x y l)\n 2. \\<And>a xs.\n       all_in_list xs l \\<longrightarrow>\n       singleCombinators xs \\<longrightarrow>\n       all_in_list ys l \\<longrightarrow>\n       singleCombinators ys \\<longrightarrow>\n       FWNormalisationCore.sorted (xs @ ys) l \\<longrightarrow>\n       FWNormalisationCore.sorted xs l \\<and>\n       FWNormalisationCore.sorted ys l \\<and>\n       (\\<forall>x\\<in>set xs.\n           \\<forall>y\\<in>set ys. smaller x y l) \\<Longrightarrow>\n       all_in_list (a # xs) l \\<longrightarrow>\n       singleCombinators (a # xs) \\<longrightarrow>\n       all_in_list ys l \\<longrightarrow>\n       singleCombinators ys \\<longrightarrow>\n       FWNormalisationCore.sorted ((a # xs) @ ys) l \\<longrightarrow>\n       FWNormalisationCore.sorted (a # xs) l \\<and>\n       FWNormalisationCore.sorted ys l \\<and>\n       (\\<forall>x\\<in>set (a # xs). \\<forall>y\\<in>set ys. smaller x y l)", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       all_in_list xs l \\<longrightarrow>\n       singleCombinators xs \\<longrightarrow>\n       all_in_list ys l \\<longrightarrow>\n       singleCombinators ys \\<longrightarrow>\n       FWNormalisationCore.sorted (xs @ ys) l \\<longrightarrow>\n       FWNormalisationCore.sorted xs l \\<and>\n       FWNormalisationCore.sorted ys l \\<and>\n       (\\<forall>x\\<in>set xs.\n           \\<forall>y\\<in>set ys. smaller x y l) \\<Longrightarrow>\n       in_list a l \\<and> all_in_list xs l \\<longrightarrow>\n       singleCombinators (a # xs) \\<longrightarrow>\n       all_in_list ys l \\<longrightarrow>\n       singleCombinators ys \\<longrightarrow>\n       FWNormalisationCore.sorted (a # xs @ ys) l \\<longrightarrow>\n       FWNormalisationCore.sorted (a # xs) l \\<and>\n       FWNormalisationCore.sorted ys l \\<and>\n       (\\<forall>y\\<in>set ys. smaller a y l) \\<and>\n       (\\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. smaller x y l)", "by (metis NormalisationGenericProofs.sorted_Cons all_in_list.simps(2) all_in_listAppend aux0_1 \n      aux0_4 singleCombinatorsAppend singleCombinatorsConc singleCombinatorsStart)"], ["", "lemma sorted_append2[rule_format]:\n  \"all_in_list xs l\\<longrightarrow> singleCombinators xs \\<longrightarrow>\n   all_in_list ys l \\<longrightarrow> singleCombinators ys \\<longrightarrow> \n   (sorted xs l & sorted ys l & (\\<forall>x \\<in> set xs. \\<forall>y \\<in> set ys. smaller x y l)) \\<longrightarrow> \n  (sorted (xs@ys) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list xs l \\<longrightarrow>\n    singleCombinators xs \\<longrightarrow>\n    all_in_list ys l \\<longrightarrow>\n    singleCombinators ys \\<longrightarrow>\n    FWNormalisationCore.sorted xs l \\<and>\n    FWNormalisationCore.sorted ys l \\<and>\n    (\\<forall>x\\<in>set xs.\n        \\<forall>y\\<in>set ys. smaller x y l) \\<longrightarrow>\n    FWNormalisationCore.sorted (xs @ ys) l", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. all_in_list [] l \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow>\n    all_in_list ys l \\<longrightarrow>\n    singleCombinators ys \\<longrightarrow>\n    FWNormalisationCore.sorted [] l \\<and>\n    FWNormalisationCore.sorted ys l \\<and>\n    (\\<forall>x\\<in>set [].\n        \\<forall>y\\<in>set ys. smaller x y l) \\<longrightarrow>\n    FWNormalisationCore.sorted ([] @ ys) l\n 2. \\<And>a xs.\n       all_in_list xs l \\<longrightarrow>\n       singleCombinators xs \\<longrightarrow>\n       all_in_list ys l \\<longrightarrow>\n       singleCombinators ys \\<longrightarrow>\n       FWNormalisationCore.sorted xs l \\<and>\n       FWNormalisationCore.sorted ys l \\<and>\n       (\\<forall>x\\<in>set xs.\n           \\<forall>y\\<in>set ys. smaller x y l) \\<longrightarrow>\n       FWNormalisationCore.sorted (xs @ ys) l \\<Longrightarrow>\n       all_in_list (a # xs) l \\<longrightarrow>\n       singleCombinators (a # xs) \\<longrightarrow>\n       all_in_list ys l \\<longrightarrow>\n       singleCombinators ys \\<longrightarrow>\n       FWNormalisationCore.sorted (a # xs) l \\<and>\n       FWNormalisationCore.sorted ys l \\<and>\n       (\\<forall>x\\<in>set (a # xs).\n           \\<forall>y\\<in>set ys. smaller x y l) \\<longrightarrow>\n       FWNormalisationCore.sorted ((a # xs) @ ys) l", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       all_in_list xs l \\<longrightarrow>\n       singleCombinators xs \\<longrightarrow>\n       all_in_list ys l \\<longrightarrow>\n       singleCombinators ys \\<longrightarrow>\n       FWNormalisationCore.sorted xs l \\<and>\n       FWNormalisationCore.sorted ys l \\<and>\n       (\\<forall>x\\<in>set xs.\n           \\<forall>y\\<in>set ys. smaller x y l) \\<longrightarrow>\n       FWNormalisationCore.sorted (xs @ ys) l \\<Longrightarrow>\n       in_list a l \\<and> all_in_list xs l \\<longrightarrow>\n       singleCombinators (a # xs) \\<longrightarrow>\n       all_in_list ys l \\<longrightarrow>\n       singleCombinators ys \\<longrightarrow>\n       FWNormalisationCore.sorted (a # xs) l \\<and>\n       FWNormalisationCore.sorted ys l \\<and>\n       (\\<forall>y\\<in>set ys. smaller a y l) \\<and>\n       (\\<forall>x\\<in>set xs.\n           \\<forall>y\\<in>set ys. smaller x y l) \\<longrightarrow>\n       FWNormalisationCore.sorted (a # xs @ ys) l", "by (metis NormalisationGenericProofs.sorted_Cons all_in_list.simps(2) all_in_listAppend aux0_1 \n      aux0_4 singleCombinatorsAppend singleCombinatorsConc singleCombinatorsStart)"], ["", "lemma sorted_append[rule_format]:\n  \"all_in_list xs l \\<longrightarrow> singleCombinators xs \\<longrightarrow>\n   all_in_list ys l \\<longrightarrow> singleCombinators ys \\<longrightarrow> \n   (sorted (xs@ys) l) =\n   (sorted xs l & sorted ys l & (\\<forall>x \\<in> set xs. \\<forall>y \\<in> set ys. smaller x y l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list xs l \\<longrightarrow>\n    singleCombinators xs \\<longrightarrow>\n    all_in_list ys l \\<longrightarrow>\n    singleCombinators ys \\<longrightarrow>\n    FWNormalisationCore.sorted (xs @ ys) l =\n    (FWNormalisationCore.sorted xs l \\<and>\n     FWNormalisationCore.sorted ys l \\<and>\n     (\\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. smaller x y l))", "apply (rule impI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_in_list xs l; singleCombinators xs; all_in_list ys l;\n     singleCombinators ys\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted (xs @ ys) l =\n                      (FWNormalisationCore.sorted xs l \\<and>\n                       FWNormalisationCore.sorted ys l \\<and>\n                       (\\<forall>x\\<in>set xs.\n                           \\<forall>y\\<in>set ys. smaller x y l))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>all_in_list xs l; singleCombinators xs; all_in_list ys l;\n     singleCombinators ys; FWNormalisationCore.sorted (xs @ ys) l\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted xs l \\<and>\n                      FWNormalisationCore.sorted ys l \\<and>\n                      (\\<forall>x\\<in>set xs.\n                          \\<forall>y\\<in>set ys. smaller x y l)\n 2. \\<lbrakk>all_in_list xs l; singleCombinators xs; all_in_list ys l;\n     singleCombinators ys;\n     FWNormalisationCore.sorted xs l \\<and>\n     FWNormalisationCore.sorted ys l \\<and>\n     (\\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. smaller x y l)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted (xs @ ys) l", "apply (rule sorted_append1,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_in_list xs l; singleCombinators xs; all_in_list ys l;\n     singleCombinators ys;\n     FWNormalisationCore.sorted xs l \\<and>\n     FWNormalisationCore.sorted ys l \\<and>\n     (\\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. smaller x y l)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted (xs @ ys) l", "apply (rule sorted_append2,simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sort_is_sortedQ[rule_format]: \n  \"all_in_list p l  \\<longrightarrow> singleCombinators p \\<longrightarrow> sorted (qsort p l) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list p l \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    FWNormalisationCore.sorted (qsort p l) l", "proof (induct p l rule: qsort.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       all_in_list [] l \\<longrightarrow>\n       singleCombinators [] \\<longrightarrow>\n       FWNormalisationCore.sorted (qsort [] l) l\n 2. \\<And>x xs l.\n       \\<lbrakk>all_in_list (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                 l \\<longrightarrow>\n                singleCombinators\n                 (filter (\\<lambda>y. \\<not> smaller x y l)\n                   xs) \\<longrightarrow>\n                FWNormalisationCore.sorted\n                 (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n        all_in_list (filter (\\<lambda>y. smaller x y l) xs)\n         l \\<longrightarrow>\n        singleCombinators\n         (filter (\\<lambda>y. smaller x y l) xs) \\<longrightarrow>\n        FWNormalisationCore.sorted\n         (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l\\<rbrakk>\n       \\<Longrightarrow> all_in_list (x # xs) l \\<longrightarrow>\n                         singleCombinators (x # xs) \\<longrightarrow>\n                         FWNormalisationCore.sorted (qsort (x # xs) l) l", "print_cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       all_in_list [] l \\<longrightarrow>\n       singleCombinators [] \\<longrightarrow>\n       FWNormalisationCore.sorted (qsort [] l) l\n 2. \\<And>x xs l.\n       \\<lbrakk>all_in_list (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                 l \\<longrightarrow>\n                singleCombinators\n                 (filter (\\<lambda>y. \\<not> smaller x y l)\n                   xs) \\<longrightarrow>\n                FWNormalisationCore.sorted\n                 (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n        all_in_list (filter (\\<lambda>y. smaller x y l) xs)\n         l \\<longrightarrow>\n        singleCombinators\n         (filter (\\<lambda>y. smaller x y l) xs) \\<longrightarrow>\n        FWNormalisationCore.sorted\n         (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l\\<rbrakk>\n       \\<Longrightarrow> all_in_list (x # xs) l \\<longrightarrow>\n                         singleCombinators (x # xs) \\<longrightarrow>\n                         FWNormalisationCore.sorted (qsort (x # xs) l) l", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>l.\n       all_in_list [] l \\<longrightarrow>\n       singleCombinators [] \\<longrightarrow>\n       FWNormalisationCore.sorted (qsort [] l) l\n 2. \\<And>x xs l.\n       \\<lbrakk>all_in_list (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                 l \\<longrightarrow>\n                singleCombinators\n                 (filter (\\<lambda>y. \\<not> smaller x y l)\n                   xs) \\<longrightarrow>\n                FWNormalisationCore.sorted\n                 (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n        all_in_list (filter (\\<lambda>y. smaller x y l) xs)\n         l \\<longrightarrow>\n        singleCombinators\n         (filter (\\<lambda>y. smaller x y l) xs) \\<longrightarrow>\n        FWNormalisationCore.sorted\n         (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l\\<rbrakk>\n       \\<Longrightarrow> all_in_list (x # xs) l \\<longrightarrow>\n                         singleCombinators (x # xs) \\<longrightarrow>\n                         FWNormalisationCore.sorted (qsort (x # xs) l) l", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list [] l_ \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow>\n    FWNormalisationCore.sorted (qsort [] l_) l_", "by simp"], ["proof (state)\nthis:\n  all_in_list [] l_ \\<longrightarrow>\n  singleCombinators [] \\<longrightarrow>\n  FWNormalisationCore.sorted (qsort [] l_) l_\n\ngoal (1 subgoal):\n 1. \\<And>x xs l.\n       \\<lbrakk>all_in_list (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                 l \\<longrightarrow>\n                singleCombinators\n                 (filter (\\<lambda>y. \\<not> smaller x y l)\n                   xs) \\<longrightarrow>\n                FWNormalisationCore.sorted\n                 (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n        all_in_list (filter (\\<lambda>y. smaller x y l) xs)\n         l \\<longrightarrow>\n        singleCombinators\n         (filter (\\<lambda>y. smaller x y l) xs) \\<longrightarrow>\n        FWNormalisationCore.sorted\n         (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l\\<rbrakk>\n       \\<Longrightarrow> all_in_list (x # xs) l \\<longrightarrow>\n                         singleCombinators (x # xs) \\<longrightarrow>\n                         FWNormalisationCore.sorted (qsort (x # xs) l) l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs l.\n       \\<lbrakk>all_in_list (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                 l \\<longrightarrow>\n                singleCombinators\n                 (filter (\\<lambda>y. \\<not> smaller x y l)\n                   xs) \\<longrightarrow>\n                FWNormalisationCore.sorted\n                 (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n        all_in_list (filter (\\<lambda>y. smaller x y l) xs)\n         l \\<longrightarrow>\n        singleCombinators\n         (filter (\\<lambda>y. smaller x y l) xs) \\<longrightarrow>\n        FWNormalisationCore.sorted\n         (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l\\<rbrakk>\n       \\<Longrightarrow> all_in_list (x # xs) l \\<longrightarrow>\n                         singleCombinators (x # xs) \\<longrightarrow>\n                         FWNormalisationCore.sorted (qsort (x # xs) l) l", "case 2"], ["proof (state)\nthis:\n  all_in_list (filter (\\<lambda>y. \\<not> smaller x_ y l_) xs_)\n   l_ \\<longrightarrow>\n  singleCombinators\n   (filter (\\<lambda>y. \\<not> smaller x_ y l_) xs_) \\<longrightarrow>\n  FWNormalisationCore.sorted\n   (qsort (filter (\\<lambda>y. \\<not> smaller x_ y l_) xs_) l_) l_\n  all_in_list (filter (\\<lambda>y. smaller x_ y l_) xs_)\n   l_ \\<longrightarrow>\n  singleCombinators\n   (filter (\\<lambda>y. smaller x_ y l_) xs_) \\<longrightarrow>\n  FWNormalisationCore.sorted\n   (qsort (filter (\\<lambda>y. smaller x_ y l_) xs_) l_) l_\n\ngoal (1 subgoal):\n 1. \\<And>x xs l.\n       \\<lbrakk>all_in_list (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                 l \\<longrightarrow>\n                singleCombinators\n                 (filter (\\<lambda>y. \\<not> smaller x y l)\n                   xs) \\<longrightarrow>\n                FWNormalisationCore.sorted\n                 (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n        all_in_list (filter (\\<lambda>y. smaller x y l) xs)\n         l \\<longrightarrow>\n        singleCombinators\n         (filter (\\<lambda>y. smaller x y l) xs) \\<longrightarrow>\n        FWNormalisationCore.sorted\n         (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l\\<rbrakk>\n       \\<Longrightarrow> all_in_list (x # xs) l \\<longrightarrow>\n                         singleCombinators (x # xs) \\<longrightarrow>\n                         FWNormalisationCore.sorted (qsort (x # xs) l) l", "fix x::\"('a,'b) Combinators\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs l.\n       \\<lbrakk>all_in_list (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                 l \\<longrightarrow>\n                singleCombinators\n                 (filter (\\<lambda>y. \\<not> smaller x y l)\n                   xs) \\<longrightarrow>\n                FWNormalisationCore.sorted\n                 (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n        all_in_list (filter (\\<lambda>y. smaller x y l) xs)\n         l \\<longrightarrow>\n        singleCombinators\n         (filter (\\<lambda>y. smaller x y l) xs) \\<longrightarrow>\n        FWNormalisationCore.sorted\n         (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l\\<rbrakk>\n       \\<Longrightarrow> all_in_list (x # xs) l \\<longrightarrow>\n                         singleCombinators (x # xs) \\<longrightarrow>\n                         FWNormalisationCore.sorted (qsort (x # xs) l) l", "fix xs::\"('a,'b) Combinators list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs l.\n       \\<lbrakk>all_in_list (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                 l \\<longrightarrow>\n                singleCombinators\n                 (filter (\\<lambda>y. \\<not> smaller x y l)\n                   xs) \\<longrightarrow>\n                FWNormalisationCore.sorted\n                 (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n        all_in_list (filter (\\<lambda>y. smaller x y l) xs)\n         l \\<longrightarrow>\n        singleCombinators\n         (filter (\\<lambda>y. smaller x y l) xs) \\<longrightarrow>\n        FWNormalisationCore.sorted\n         (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l\\<rbrakk>\n       \\<Longrightarrow> all_in_list (x # xs) l \\<longrightarrow>\n                         singleCombinators (x # xs) \\<longrightarrow>\n                         FWNormalisationCore.sorted (qsort (x # xs) l) l", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs l.\n       \\<lbrakk>all_in_list (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                 l \\<longrightarrow>\n                singleCombinators\n                 (filter (\\<lambda>y. \\<not> smaller x y l)\n                   xs) \\<longrightarrow>\n                FWNormalisationCore.sorted\n                 (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n        all_in_list (filter (\\<lambda>y. smaller x y l) xs)\n         l \\<longrightarrow>\n        singleCombinators\n         (filter (\\<lambda>y. smaller x y l) xs) \\<longrightarrow>\n        FWNormalisationCore.sorted\n         (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l\\<rbrakk>\n       \\<Longrightarrow> all_in_list (x # xs) l \\<longrightarrow>\n                         singleCombinators (x # xs) \\<longrightarrow>\n                         FWNormalisationCore.sorted (qsort (x # xs) l) l", "show \"all_in_list [y\\<leftarrow>xs . \\<not> smaller x y l] l \\<longrightarrow>\n                 singleCombinators [y\\<leftarrow>xs . \\<not> smaller x y l] \\<longrightarrow> \n                 sorted (qsort [y\\<leftarrow>xs . \\<not> smaller x y l] l) l \\<Longrightarrow>\n                 all_in_list [y\\<leftarrow>xs . smaller x y l] l \\<longrightarrow>\n                 singleCombinators [y\\<leftarrow>xs . smaller x y l] \\<longrightarrow> \n                 sorted (qsort [y\\<leftarrow>xs . smaller x y l] l) l \\<Longrightarrow>\n                 all_in_list(x#xs) l \\<longrightarrow>  singleCombinators(x#xs) \\<longrightarrow> sorted (qsort(x#xs) l) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_in_list (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n              l \\<longrightarrow>\n             singleCombinators\n              (filter (\\<lambda>y. \\<not> smaller x y l)\n                xs) \\<longrightarrow>\n             FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     all_in_list (filter (\\<lambda>y. smaller x y l) xs) l \\<longrightarrow>\n     singleCombinators\n      (filter (\\<lambda>y. smaller x y l) xs) \\<longrightarrow>\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l\\<rbrakk>\n    \\<Longrightarrow> all_in_list (x # xs) l \\<longrightarrow>\n                      singleCombinators (x # xs) \\<longrightarrow>\n                      FWNormalisationCore.sorted (qsort (x # xs) l) l", "apply (intro impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_in_list (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n              l \\<longrightarrow>\n             singleCombinators\n              (filter (\\<lambda>y. \\<not> smaller x y l)\n                xs) \\<longrightarrow>\n             FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     all_in_list (filter (\\<lambda>y. smaller x y l) xs) l \\<longrightarrow>\n     singleCombinators\n      (filter (\\<lambda>y. smaller x y l) xs) \\<longrightarrow>\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     all_in_list (x # xs) l; singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted (qsort (x # xs) l) l", "apply (simp_all add: SC_sublist all_in_list_sublist all_in_list_sublist2 \n        singleCombinatorsConc SC_sublist2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l @\n                        x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l", "proof (subst sorted_append)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> all_in_list\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)\n                       l\n 2. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)\n 3. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> all_in_list\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l\n 4. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n 5. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)\n                       l \\<and>\n                      FWNormalisationCore.sorted\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l \\<and>\n                      (\\<forall>x\\<in>set\n (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l).\n                          \\<forall>y\\<in>set\n    (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l).\n                             smaller x y l)", "show \"in_list x l \\<and> all_in_list xs l \\<Longrightarrow> \n                       singleCombinators (x # xs) \\<Longrightarrow> \n                       all_in_list (qsort [y\\<leftarrow>xs . \\<not> smaller x y l] l) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> all_in_list\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)\n                       l", "by (metis all_in_list_sublist singleCombinatorsConc)"], ["proof (state)\nthis:\n  \\<lbrakk>in_list x l \\<and> all_in_list xs l;\n   singleCombinators (x # xs)\\<rbrakk>\n  \\<Longrightarrow> all_in_list\n                     (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                       l)\n                     l\n\ngoal (4 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)\n 2. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> all_in_list\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l\n 3. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n 4. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)\n                       l \\<and>\n                      FWNormalisationCore.sorted\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l \\<and>\n                      (\\<forall>x\\<in>set\n (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l).\n                          \\<forall>y\\<in>set\n    (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l).\n                             smaller x y l)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)\n 2. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> all_in_list\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l\n 3. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n 4. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)\n                       l \\<and>\n                      FWNormalisationCore.sorted\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l \\<and>\n                      (\\<forall>x\\<in>set\n (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l).\n                          \\<forall>y\\<in>set\n    (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l).\n                             smaller x y l)", "show \"in_list x l \\<and> all_in_list xs l \\<Longrightarrow> \n                       singleCombinators (x # xs) \\<Longrightarrow> \n                       singleCombinators (qsort [y\\<leftarrow>xs . \\<not> smaller x y l] l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)", "apply (auto simp: SC_sublist all_in_list_sublist SC_sublist2\n          all_in_list_sublist2 sorted_Cons sorted_append not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators (x # xs); in_list x l;\n     all_in_list xs l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)", "apply (metis SC3Q SC_sublist2 singleCombinatorsConc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>in_list x l \\<and> all_in_list xs l;\n   singleCombinators (x # xs)\\<rbrakk>\n  \\<Longrightarrow> singleCombinators\n                     (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                       l)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> all_in_list\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l\n 2. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n 3. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)\n                       l \\<and>\n                      FWNormalisationCore.sorted\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l \\<and>\n                      (\\<forall>x\\<in>set\n (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l).\n                          \\<forall>y\\<in>set\n    (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l).\n                             smaller x y l)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> all_in_list\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l\n 2. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n 3. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)\n                       l \\<and>\n                      FWNormalisationCore.sorted\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l \\<and>\n                      (\\<forall>x\\<in>set\n (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l).\n                          \\<forall>y\\<in>set\n    (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l).\n                             smaller x y l)", "show \"sorted (qsort [y\\<leftarrow>xs . \\<not> smaller x y l] l) l \\<Longrightarrow>\n                       sorted (qsort [y\\<leftarrow>xs . smaller x y l] l) l \\<Longrightarrow>\n                       in_list x l \\<and> all_in_list xs l \\<Longrightarrow> singleCombinators (x # xs) \\<Longrightarrow> \n                       all_in_list (x # qsort [y\\<leftarrow>xs . smaller x y l] l) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> all_in_list\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l", "using all_in_list.simps(2) all_in_list_sublist singleCombinatorsConc"], ["proof (prove)\nusing this:\n  all_in_list (?x # ?xs) ?l = (in_list ?x ?l \\<and> all_in_list ?xs ?l)\n  \\<lbrakk>singleCombinators ?xs; all_in_list ?xs ?l\\<rbrakk>\n  \\<Longrightarrow> all_in_list (qsort (filter ?P ?xs) ?l) ?l\n  singleCombinators (?x # ?xs) \\<Longrightarrow> singleCombinators ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> all_in_list\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>FWNormalisationCore.sorted\n            (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n   FWNormalisationCore.sorted\n    (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n   in_list x l \\<and> all_in_list xs l; singleCombinators (x # xs)\\<rbrakk>\n  \\<Longrightarrow> all_in_list\n                     (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l) l\n\ngoal (2 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n 2. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)\n                       l \\<and>\n                      FWNormalisationCore.sorted\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l \\<and>\n                      (\\<forall>x\\<in>set\n (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l).\n                          \\<forall>y\\<in>set\n    (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l).\n                             smaller x y l)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n 2. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)\n                       l \\<and>\n                      FWNormalisationCore.sorted\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l \\<and>\n                      (\\<forall>x\\<in>set\n (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l).\n                          \\<forall>y\\<in>set\n    (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l).\n                             smaller x y l)", "show \"sorted (qsort [y\\<leftarrow>xs . smaller x y l] l) l \\<Longrightarrow>\n                       in_list x l \\<and> all_in_list xs l \\<Longrightarrow> singleCombinators (x # xs) \\<Longrightarrow> \n                       singleCombinators (x # qsort [y\\<leftarrow>xs . smaller x y l] l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)", "using SC_sublist aux0_1 singleCombinatorsConc singleCombinatorsStart"], ["proof (prove)\nusing this:\n  singleCombinators ?xs \\<Longrightarrow>\n  singleCombinators (qsort (filter ?P ?xs) ?l)\n  \\<lbrakk>singleCombinators ?xs; singleCombinators [?x]\\<rbrakk>\n  \\<Longrightarrow> singleCombinators (?x # ?xs)\n  singleCombinators (?x # ?xs) \\<Longrightarrow> singleCombinators ?xs\n  singleCombinators (?x # ?xs) \\<Longrightarrow> singleCombinators [?x]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> singleCombinators\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>FWNormalisationCore.sorted\n            (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n   in_list x l \\<and> all_in_list xs l; singleCombinators (x # xs)\\<rbrakk>\n  \\<Longrightarrow> singleCombinators\n                     (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)\n                       l \\<and>\n                      FWNormalisationCore.sorted\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l \\<and>\n                      (\\<forall>x\\<in>set\n (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l).\n                          \\<forall>y\\<in>set\n    (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l).\n                             smaller x y l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)\n                       l \\<and>\n                      FWNormalisationCore.sorted\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l \\<and>\n                      (\\<forall>x\\<in>set\n (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l).\n                          \\<forall>y\\<in>set\n    (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l).\n                             smaller x y l)", "show \"sorted (qsort [y\\<leftarrow>xs . \\<not> smaller x y l] l) l \\<Longrightarrow>\n                       sorted (qsort [y\\<leftarrow>xs . smaller x y l] l) l \\<Longrightarrow>\n                       in_list x l \\<and> all_in_list xs l \\<Longrightarrow>\n                       singleCombinators (x # xs) \\<Longrightarrow>\n                       FWNormalisationCore.sorted (qsort [y\\<leftarrow>xs . \\<not> smaller x y l] l) l \\<and>\n                       FWNormalisationCore.sorted (x # qsort [y\\<leftarrow>xs . smaller x y l] l) l \\<and>\n                       (\\<forall>x'\\<in>set (qsort [y\\<leftarrow>xs . \\<not> smaller x y l] l). \n                                \\<forall>y\\<in>set (x # qsort [y\\<leftarrow>xs . smaller x y l] l). smaller x' y l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     in_list x l \\<and> all_in_list xs l;\n     singleCombinators (x # xs)\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                         l)\n                       l \\<and>\n                      FWNormalisationCore.sorted\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l \\<and>\n                      (\\<forall>x'\\<in>set\n  (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l).\n                          \\<forall>y\\<in>set\n    (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l).\n                             smaller x' y l)", "apply(auto)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted\n              (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n     FWNormalisationCore.sorted\n      (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n     singleCombinators (x # xs); in_list x l; all_in_list xs l\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                       l\n 2. \\<And>x'.\n       \\<lbrakk>FWNormalisationCore.sorted\n                 (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n        FWNormalisationCore.sorted\n         (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n        singleCombinators (x # xs); in_list x l; all_in_list xs l;\n        x' \\<in> set xs; \\<not> smaller x x' l\\<rbrakk>\n       \\<Longrightarrow> smaller x' x l\n 3. \\<And>x' y.\n       \\<lbrakk>FWNormalisationCore.sorted\n                 (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n        FWNormalisationCore.sorted\n         (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n        singleCombinators (x # xs); in_list x l; all_in_list xs l;\n        x' \\<in> set xs; \\<not> smaller x x' l; y \\<in> set xs;\n        smaller x y l\\<rbrakk>\n       \\<Longrightarrow> smaller x' y l", "apply (metis (mono_tags, lifting) SC_sublist all_in_list.simps(2) \n          all_in_list_sublist aux0_1 mem_Collect_eq set_filter set_qsort \n          singleCombinatorsConc singleCombinatorsStart sorted_Consb)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>FWNormalisationCore.sorted\n                 (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n        FWNormalisationCore.sorted\n         (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n        singleCombinators (x # xs); in_list x l; all_in_list xs l;\n        x' \\<in> set xs; \\<not> smaller x x' l\\<rbrakk>\n       \\<Longrightarrow> smaller x' x l\n 2. \\<And>x' y.\n       \\<lbrakk>FWNormalisationCore.sorted\n                 (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n        FWNormalisationCore.sorted\n         (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n        singleCombinators (x # xs); in_list x l; all_in_list xs l;\n        x' \\<in> set xs; \\<not> smaller x x' l; y \\<in> set xs;\n        smaller x y l\\<rbrakk>\n       \\<Longrightarrow> smaller x' y l", "apply (metis aux0_0 aux0_6 in_set_in_list singleCombinatorsConc \n          singleCombinatorsStart smaller_antisym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x' y.\n       \\<lbrakk>FWNormalisationCore.sorted\n                 (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n        FWNormalisationCore.sorted\n         (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n        singleCombinators (x # xs); in_list x l; all_in_list xs l;\n        x' \\<in> set xs; \\<not> smaller x x' l; y \\<in> set xs;\n        smaller x y l\\<rbrakk>\n       \\<Longrightarrow> smaller x' y l", "by (metis (no_types, lifting) NormalisationGenericProofs.order_trans aux0_0 \n          aux0_6 in_set_in_list \n          singleCombinatorsConc singleCombinatorsStart smaller_antisym)"], ["proof (state)\nthis:\n  \\<lbrakk>FWNormalisationCore.sorted\n            (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n   FWNormalisationCore.sorted\n    (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l;\n   in_list x l \\<and> all_in_list xs l; singleCombinators (x # xs)\\<rbrakk>\n  \\<Longrightarrow> FWNormalisationCore.sorted\n                     (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n                       l)\n                     l \\<and>\n                    FWNormalisationCore.sorted\n                     (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l)\n                     l \\<and>\n                    (\\<forall>x'\\<in>set\n(qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l).\n                        \\<forall>y\\<in>set\n  (x # qsort (filter (\\<lambda>y. smaller x y l) xs) l).\n                           smaller x' y l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>all_in_list (filter (\\<lambda>y. \\<not> smaller x y l) xs)\n            l \\<longrightarrow>\n           singleCombinators\n            (filter (\\<lambda>y. \\<not> smaller x y l) xs) \\<longrightarrow>\n           FWNormalisationCore.sorted\n            (qsort (filter (\\<lambda>y. \\<not> smaller x y l) xs) l) l;\n   all_in_list (filter (\\<lambda>y. smaller x y l) xs) l \\<longrightarrow>\n   singleCombinators\n    (filter (\\<lambda>y. smaller x y l) xs) \\<longrightarrow>\n   FWNormalisationCore.sorted\n    (qsort (filter (\\<lambda>y. smaller x y l) xs) l) l\\<rbrakk>\n  \\<Longrightarrow> all_in_list (x # xs) l \\<longrightarrow>\n                    singleCombinators (x # xs) \\<longrightarrow>\n                    FWNormalisationCore.sorted (qsort (x # xs) l) l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inSet_not_MT: \"a \\<in> set p \\<Longrightarrow> p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set p \\<Longrightarrow> p \\<noteq> []", "by auto"], ["", "lemma RS1n_assoc: \n  \"x \\<noteq> DenyAll \\<Longrightarrow>  removeShadowRules1_alternative xs @ [x] =\n                  removeShadowRules1_alternative (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> DenyAll \\<Longrightarrow>\n    removeShadowRules1_alternative xs @ [x] =\n    removeShadowRules1_alternative (xs @ [x])", "by (simp add: removeShadowRules1_alternative_def aux114)"], ["", "lemma RS1n_nMT[rule_format,simp]: \"p \\<noteq> []\\<longrightarrow> removeShadowRules1_alternative p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    removeShadowRules1_alternative p \\<noteq> []", "apply (simp add: removeShadowRules1_alternative_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    removeShadowRules1_alternative_rev (rev p) \\<noteq> []", "apply (rule_tac xs = p in rev_induct, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       removeShadowRules1_alternative_rev (rev xs) \\<noteq>\n       [] \\<Longrightarrow>\n       removeShadowRules1_alternative_rev (x # rev xs) \\<noteq> []", "subgoal for x xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<longrightarrow>\n    removeShadowRules1_alternative_rev (rev xs) \\<noteq>\n    [] \\<Longrightarrow>\n    removeShadowRules1_alternative_rev (x # rev xs) \\<noteq> []", "apply (case_tac \"xs = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    removeShadowRules1_alternative_rev [x] \\<noteq> []\n 2. \\<lbrakk>removeShadowRules1_alternative_rev (rev xs) \\<noteq> [];\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> removeShadowRules1_alternative_rev\n                       (x # rev xs) \\<noteq>\n                      []", "apply (case_tac x, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>removeShadowRules1_alternative_rev (rev xs) \\<noteq> [];\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> removeShadowRules1_alternative_rev\n                       (x # rev xs) \\<noteq>\n                      []", "apply (rule_tac xs = \"xs\" in rev_induct, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>removeShadowRules1_alternative_rev (rev xs) \\<noteq> [];\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> removeShadowRules1_alternative_rev [x] \\<noteq> []\n 2. \\<And>xa xsa.\n       \\<lbrakk>removeShadowRules1_alternative_rev (rev xs) \\<noteq> [];\n        xs \\<noteq> [];\n        removeShadowRules1_alternative_rev (x # rev xsa) \\<noteq>\n        []\\<rbrakk>\n       \\<Longrightarrow> removeShadowRules1_alternative_rev\n                          (x # xa # rev xsa) \\<noteq>\n                         []", "apply (case_tac x, simp_all)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma RS1N_DA[simp]: \"removeShadowRules1_alternative (a@[DenyAll]) = [DenyAll]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeShadowRules1_alternative (a @ [DenyAll]) = [DenyAll]", "by (simp add: removeShadowRules1_alternative_def)"], ["", "lemma WP1n_DA_notinSet[rule_format]: \"wellformed_policy1_strong p \\<longrightarrow>\n                                     DenyAll \\<notin> set (tl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<longrightarrow>\n    DenyAll \\<notin> set (tl p)", "by (induct p) (simp_all)"], ["", "lemma mt_sym: \"dom a \\<inter> dom b = {} \\<Longrightarrow> dom b \\<inter> dom a = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom a \\<inter> dom b = {} \\<Longrightarrow> dom b \\<inter> dom a = {}", "by auto"], ["", "lemma DAnotTL[rule_format]: \n  \"xs \\<noteq> [] \\<longrightarrow> wellformed_policy1 (xs @ [DenyAll]) \\<longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<longrightarrow>\n    wellformed_policy1 (xs @ [DenyAll]) \\<longrightarrow> False", "by (induct xs, simp_all)"], ["", "lemma AND_tl[rule_format]: \"allNetsDistinct ( p) \\<longrightarrow> allNetsDistinct (tl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allNetsDistinct p \\<longrightarrow> allNetsDistinct (tl p)", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       allNetsDistinct p \\<longrightarrow>\n       allNetsDistinct (tl p) \\<Longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow> allNetsDistinct p", "by (auto intro: ANDConc)"], ["", "lemma distinct_tl[rule_format]: \"distinct p \\<longrightarrow> distinct (tl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct p \\<longrightarrow> distinct (tl p)", "by (induct p, simp_all)"], ["", "lemma SC_tl[rule_format]: \"singleCombinators ( p) \\<longrightarrow> singleCombinators (tl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<longrightarrow> singleCombinators (tl p)", "by (induct p, simp_all) (auto intro: singleCombinatorsConc)"], ["", "lemma Conc_not_MT: \"p = x#xs \\<Longrightarrow> p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = x # xs \\<Longrightarrow> p \\<noteq> []", "by auto"], ["", "lemma wp1_tl[rule_format]: \n  \"p \\<noteq> [] \\<and> wellformed_policy1 p \\<longrightarrow> wellformed_policy1 (tl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<and> wellformed_policy1 p \\<longrightarrow>\n    wellformed_policy1 (tl p)", "by (induct p) (auto intro: waux2)"], ["", "lemma wp1_eq[rule_format]: \n  \"wellformed_policy1_strong p \\<Longrightarrow> wellformed_policy1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<Longrightarrow> wellformed_policy1 p", "apply (case_tac \"DenyAll \\<in> set p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wellformed_policy1_strong p; DenyAll \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 p\n 2. \\<lbrakk>wellformed_policy1_strong p; DenyAll \\<notin> set p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 p", "apply (subst wellformed_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>wellformed_policy1_strong p; DenyAll \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> DenyAll \\<in> set p\n 2. \\<lbrakk>wellformed_policy1_strong p; DenyAll \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1_strong p\n 3. \\<lbrakk>wellformed_policy1_strong p; DenyAll \\<notin> set p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1 p", "apply (auto elim: waux2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wellformed1_alternative_sorted: \n  \"wellformed_policy1_strong p \\<Longrightarrow> wellformed_policy1_strong (sort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<Longrightarrow>\n    wellformed_policy1_strong (FWNormalisationCore.sort p l)", "by (case_tac \"p\", simp_all)"], ["", "lemma wp1n_RS2[rule_format]: \n  \"wellformed_policy1_strong p \\<longrightarrow> wellformed_policy1_strong (removeShadowRules2 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<longrightarrow>\n    wellformed_policy1_strong (removeShadowRules2 p)", "by (induct p, simp_all)"], ["", "lemma RS2_NMT[rule_format]: \"p \\<noteq> [] \\<longrightarrow> removeShadowRules2 p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow> removeShadowRules2 p \\<noteq> []", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       removeShadowRules2 p \\<noteq> [] \\<Longrightarrow>\n       removeShadowRules2 (a # p) \\<noteq> []", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    removeShadowRules2 p \\<noteq> [] \\<Longrightarrow>\n    removeShadowRules2 (a # p) \\<noteq> []", "apply (case_tac \"p \\<noteq> []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>removeShadowRules2 p \\<noteq> []; p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> removeShadowRules2 (a # p) \\<noteq> []\n 2. p = [] \\<Longrightarrow> removeShadowRules2 [a] \\<noteq> []", "apply (case_tac \"a\", simp_all)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wp1_alternative_not_mt[simp]: \"wellformed_policy1_strong p \\<Longrightarrow> p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<Longrightarrow> p \\<noteq> []", "by auto"], ["", "lemma AIL1[rule_format,simp]: \"all_in_list p l \\<longrightarrow>\n                               all_in_list (removeShadowRules1 p) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list p l \\<longrightarrow> all_in_list (removeShadowRules1 p) l", "by (induct_tac p, simp_all)"], ["", "lemma wp1ID: \"wellformed_policy1_strong (insertDeny (removeShadowRules1 p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong (insertDeny (removeShadowRules1 p))", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       wellformed_policy1_strong\n        (insertDeny (removeShadowRules1 p)) \\<Longrightarrow>\n       DenyAll \\<notin> set p \\<longrightarrow>\n       wellformed_policy1_strong (insertDeny (a # p))", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong\n     (insertDeny (removeShadowRules1 p)) \\<Longrightarrow>\n    DenyAll \\<notin> set p \\<longrightarrow>\n    wellformed_policy1_strong (insertDeny (a # p))", "apply (case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dRD[simp]: \"distinct (remdups p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (remdups p)", "by simp"], ["", "lemma AILrd[rule_format,simp]: \"all_in_list p l \\<longrightarrow> all_in_list (remdups p) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list p l \\<longrightarrow> all_in_list (remdups p) l", "by (induct p, simp_all)"], ["", "lemma AILiD[rule_format,simp]: \"all_in_list p l \\<longrightarrow> all_in_list (insertDeny p) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list p l \\<longrightarrow> all_in_list (insertDeny p) l", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       all_in_list p l \\<longrightarrow>\n       all_in_list (insertDeny p) l \\<Longrightarrow>\n       in_list a l \\<and> all_in_list p l \\<longrightarrow>\n       all_in_list (insertDeny (a # p)) l", "apply (rule impI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>all_in_list (insertDeny p) l;\n        in_list a l \\<and> all_in_list p l\\<rbrakk>\n       \\<Longrightarrow> all_in_list (insertDeny (a # p)) l", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_in_list (insertDeny p) l;\n     in_list a l \\<and> all_in_list p l\\<rbrakk>\n    \\<Longrightarrow> all_in_list (insertDeny (a # p)) l", "apply (case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SCrd[rule_format,simp]:\"singleCombinators p\\<longrightarrow> singleCombinators(remdups p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<longrightarrow> singleCombinators (remdups p)", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       singleCombinators p \\<longrightarrow>\n       singleCombinators (remdups p) \\<Longrightarrow>\n       (a \\<in> set p \\<longrightarrow>\n        singleCombinators (a # p) \\<longrightarrow>\n        singleCombinators (remdups p)) \\<and>\n       (a \\<notin> set p \\<longrightarrow>\n        singleCombinators (a # p) \\<longrightarrow>\n        singleCombinators (a # remdups p))", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<longrightarrow>\n    singleCombinators (remdups p) \\<Longrightarrow>\n    (a \\<in> set p \\<longrightarrow>\n     singleCombinators (a # p) \\<longrightarrow>\n     singleCombinators (remdups p)) \\<and>\n    (a \\<notin> set p \\<longrightarrow>\n     singleCombinators (a # p) \\<longrightarrow>\n     singleCombinators (a # remdups p))", "apply (case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SCRiD[rule_format,simp]: \"singleCombinators p \\<longrightarrow>\n                                singleCombinators(insertDeny p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<longrightarrow> singleCombinators (insertDeny p)", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       singleCombinators p \\<longrightarrow>\n       singleCombinators (insertDeny p) \\<Longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       singleCombinators (insertDeny (a # p))", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<longrightarrow>\n    singleCombinators (insertDeny p) \\<Longrightarrow>\n    singleCombinators (a # p) \\<longrightarrow>\n    singleCombinators (insertDeny (a # p))", "apply (case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WP1rd[rule_format,simp]: \n  \"wellformed_policy1_strong p \\<longrightarrow> wellformed_policy1_strong (remdups p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<longrightarrow>\n    wellformed_policy1_strong (remdups p)", "by (induct p, simp_all)"], ["", "lemma ANDrd[rule_format,simp]: \n  \"singleCombinators p \\<longrightarrow> allNetsDistinct p \\<longrightarrow> allNetsDistinct (remdups p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<longrightarrow>\n    allNetsDistinct p \\<longrightarrow> allNetsDistinct (remdups p)", "apply (rule impI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct (remdups p)", "apply (rule_tac b = p in aNDSubset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (remdups p)\n 2. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> set (remdups p) \\<subseteq> set p\n 3. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct p", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ANDiD[rule_format,simp]: \n  \"allNetsDistinct p \\<longrightarrow>  allNetsDistinct (insertDeny p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allNetsDistinct p \\<longrightarrow> allNetsDistinct (insertDeny p)", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. allNetsDistinct [] \\<longrightarrow> allNetsDistinct [DenyAll]\n 2. \\<And>a p.\n       allNetsDistinct p \\<longrightarrow>\n       allNetsDistinct (insertDeny p) \\<Longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       allNetsDistinct (insertDeny (a # p))", "apply (simp add: allNetsDistinct_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       allNetsDistinct p \\<longrightarrow>\n       allNetsDistinct (insertDeny p) \\<Longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       allNetsDistinct (insertDeny (a # p))", "apply (auto intro: ANDConc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>allNetsDistinct (a # p);\n        allNetsDistinct (insertDeny p)\\<rbrakk>\n       \\<Longrightarrow> allNetsDistinct (insertDeny (a # p))", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allNetsDistinct (a # p);\n     allNetsDistinct (insertDeny p)\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct (insertDeny (a # p))", "apply (case_tac \"a\",simp_all add: allNetsDistinct_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mr_iD[rule_format]: \n  \"wellformed_policy1_strong p  \\<longrightarrow> matching_rule x p = matching_rule x (insertDeny p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<longrightarrow>\n    matching_rule x p = matching_rule x (insertDeny p)", "by (induct p, simp_all)"], ["", "lemma WP1iD[rule_format,simp]: \"wellformed_policy1_strong p \\<longrightarrow>\n                                wellformed_policy1_strong (insertDeny p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<longrightarrow>\n    wellformed_policy1_strong (insertDeny p)", "by (induct p, simp_all)"], ["", "lemma DAiniD: \"DenyAll \\<in> set (insertDeny p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set (insertDeny p)", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       DenyAll \\<in> set (insertDeny p) \\<Longrightarrow>\n       DenyAll \\<in> set (insertDeny (a # p))", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set (insertDeny p) \\<Longrightarrow>\n    DenyAll \\<in> set (insertDeny (a # p))", "apply(case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma p2lNmt: \"policy2list p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. policy2list p \\<noteq> []", "by (rule policy2list.induct, simp_all)"], ["", "lemma AIL2[rule_format,simp]: \n  \"all_in_list p l \\<longrightarrow> all_in_list (removeShadowRules2 p) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list p l \\<longrightarrow> all_in_list (removeShadowRules2 p) l", "apply (induct_tac p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       all_in_list list l \\<longrightarrow>\n       all_in_list (removeShadowRules2 list) l \\<Longrightarrow>\n       in_list a l \\<and> all_in_list list l \\<longrightarrow>\n       all_in_list (removeShadowRules2 (a # list)) l", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list p l \\<longrightarrow>\n    all_in_list (removeShadowRules2 p) l \\<Longrightarrow>\n    in_list a l \\<and> all_in_list p l \\<longrightarrow>\n    all_in_list (removeShadowRules2 (a # p)) l", "apply(case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SCConc: \"singleCombinators x \\<Longrightarrow>  singleCombinators y \\<Longrightarrow> singleCombinators (x@y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators x; singleCombinators y\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (x @ y)", "apply (rule aux0_5)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators x; singleCombinators y\\<rbrakk>\n    \\<Longrightarrow> \\<nexists>a b. a \\<oplus> b \\<in> set (x @ y)", "apply (metis aux0_0 aux0_4)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SCp2l: \"singleCombinators (policy2list p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators (policy2list p)", "by (induct_tac p) (auto intro: SCConc)"], ["", "lemma subnetAux: \"Dd \\<inter> A \\<noteq> {} \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow>  Dd \\<inter> B \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Dd \\<inter> A \\<noteq> {}; A \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> Dd \\<inter> B \\<noteq> {}", "by auto"], ["", "lemma soadisj: \"x \\<in> subnetsOfAdr a \\<Longrightarrow> y \\<in> subnetsOfAdr a \\<Longrightarrow> \\<not> netsDistinct x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> subnetsOfAdr a; y \\<in> subnetsOfAdr a\\<rbrakk>\n    \\<Longrightarrow> \\<not> netsDistinct x y", "by(simp add: subnetsOfAdr_def netsDistinct_def,auto)"], ["", "lemma not_member: \"\\<not> member a (x\\<oplus>y) \\<Longrightarrow> \\<not> member a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> member a (x \\<oplus> y) \\<Longrightarrow> \\<not> member a x", "by auto"], ["", "lemma soadisj2: \"(\\<forall> a x y. x \\<in> subnetsOfAdr a \\<and> y \\<in> subnetsOfAdr a \\<longrightarrow> \\<not> netsDistinct x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a x y.\n       x \\<in> subnetsOfAdr a \\<and>\n       y \\<in> subnetsOfAdr a \\<longrightarrow>\n       \\<not> netsDistinct x y", "by (simp add: subnetsOfAdr_def netsDistinct_def, auto)"], ["", "lemma ndFalse1: \n  \"(\\<forall>a b c d. (a,b)\\<in>A  \\<and> (c,d)\\<in>B \\<longrightarrow> netsDistinct a c) \\<Longrightarrow>\n   \\<exists>(a, b)\\<in>A. a \\<in> subnetsOfAdr D \\<Longrightarrow> \n   \\<exists>(a, b)\\<in>B. a \\<in> subnetsOfAdr D \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b c d.\n                (a, b) \\<in> A \\<and> (c, d) \\<in> B \\<longrightarrow>\n                netsDistinct a c;\n     \\<exists>(a, b)\\<in>A. a \\<in> subnetsOfAdr D;\n     \\<exists>(a, b)\\<in>B. a \\<in> subnetsOfAdr D\\<rbrakk>\n    \\<Longrightarrow> False", "apply (auto simp: soadisj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<forall>a b c.\n                   (a, b) \\<in> A \\<and>\n                   (\\<exists>d. (c, d) \\<in> B) \\<longrightarrow>\n                   netsDistinct a c;\n        (a, b) \\<in> A; a \\<in> subnetsOfAdr D; (aa, ba) \\<in> B;\n        aa \\<in> subnetsOfAdr D\\<rbrakk>\n       \\<Longrightarrow> False", "using soadisj2"], ["proof (prove)\nusing this:\n  \\<forall>a x y.\n     x \\<in> subnetsOfAdr a \\<and> y \\<in> subnetsOfAdr a \\<longrightarrow>\n     \\<not> netsDistinct x y\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<forall>a b c.\n                   (a, b) \\<in> A \\<and>\n                   (\\<exists>d. (c, d) \\<in> B) \\<longrightarrow>\n                   netsDistinct a c;\n        (a, b) \\<in> A; a \\<in> subnetsOfAdr D; (aa, ba) \\<in> B;\n        aa \\<in> subnetsOfAdr D\\<rbrakk>\n       \\<Longrightarrow> False", "by blast"], ["", "lemma ndFalse2: \"(\\<forall>a b c d. (a,b)\\<in>A  \\<and> (c,d)\\<in>B \\<longrightarrow> netsDistinct b d) \\<Longrightarrow>\n                 \\<exists>(a, b)\\<in>A. b \\<in> subnetsOfAdr D \\<Longrightarrow>\n                 \\<exists>(a, b)\\<in>B. b \\<in> subnetsOfAdr D \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b c d.\n                (a, b) \\<in> A \\<and> (c, d) \\<in> B \\<longrightarrow>\n                netsDistinct b d;\n     \\<exists>(a, b)\\<in>A. b \\<in> subnetsOfAdr D;\n     \\<exists>(a, b)\\<in>B. b \\<in> subnetsOfAdr D\\<rbrakk>\n    \\<Longrightarrow> False", "apply (auto simp: soadisj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<forall>a b c d.\n                   (a, b) \\<in> A \\<and> (c, d) \\<in> B \\<longrightarrow>\n                   netsDistinct b d;\n        (a, b) \\<in> A; b \\<in> subnetsOfAdr D; (aa, ba) \\<in> B;\n        ba \\<in> subnetsOfAdr D\\<rbrakk>\n       \\<Longrightarrow> False", "using soadisj2"], ["proof (prove)\nusing this:\n  \\<forall>a x y.\n     x \\<in> subnetsOfAdr a \\<and> y \\<in> subnetsOfAdr a \\<longrightarrow>\n     \\<not> netsDistinct x y\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<forall>a b c d.\n                   (a, b) \\<in> A \\<and> (c, d) \\<in> B \\<longrightarrow>\n                   netsDistinct b d;\n        (a, b) \\<in> A; b \\<in> subnetsOfAdr D; (aa, ba) \\<in> B;\n        ba \\<in> subnetsOfAdr D\\<rbrakk>\n       \\<Longrightarrow> False", "by blast"], ["", "lemma tndFalse: \"(\\<forall>a b c d. (a,b)\\<in>A  \\<and> (c,d)\\<in>B \\<longrightarrow> twoNetsDistinct a b c d) \\<Longrightarrow>\n        \\<exists>(a, b)\\<in>A. a \\<in> subnetsOfAdr (D::('a::adr)) \\<and> b \\<in> subnetsOfAdr (F::'a) \\<Longrightarrow> \n        \\<exists>(a, b)\\<in>B. a \\<in> subnetsOfAdr D\\<and> b\\<in> subnetsOfAdr F \n    \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b c d.\n                (a, b) \\<in> A \\<and> (c, d) \\<in> B \\<longrightarrow>\n                twoNetsDistinct a b c d;\n     \\<exists>(a, b)\\<in>A.\n        a \\<in> subnetsOfAdr D \\<and> b \\<in> subnetsOfAdr F;\n     \\<exists>(a, b)\\<in>B.\n        a \\<in> subnetsOfAdr D \\<and> b \\<in> subnetsOfAdr F\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: twoNetsDistinct_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b c d.\n                (a, b) \\<in> A \\<and> (c, d) \\<in> B \\<longrightarrow>\n                netsDistinct a c \\<or> netsDistinct b d;\n     \\<exists>x\\<in>A.\n        case x of\n        (a, b) \\<Rightarrow>\n          a \\<in> subnetsOfAdr D \\<and> b \\<in> subnetsOfAdr F;\n     \\<exists>x\\<in>B.\n        case x of\n        (a, b) \\<Rightarrow>\n          a \\<in> subnetsOfAdr D \\<and> b \\<in> subnetsOfAdr F\\<rbrakk>\n    \\<Longrightarrow> False", "apply (auto simp: ndFalse1 ndFalse2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<forall>a b c d.\n                   (a, b) \\<in> A \\<and> (c, d) \\<in> B \\<longrightarrow>\n                   netsDistinct a c \\<or> netsDistinct b d;\n        (a, b) \\<in> A; (aa, ba) \\<in> B; a \\<in> subnetsOfAdr D;\n        b \\<in> subnetsOfAdr F; aa \\<in> subnetsOfAdr D;\n        ba \\<in> subnetsOfAdr F\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis soadisj)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sepnMT[rule_format]: \"p \\<noteq> [] \\<longrightarrow> (separate p) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow> separate p \\<noteq> []", "by (induct p rule: separate.induct)  simp_all"], ["", "lemma sepDA[rule_format]: \"DenyAll \\<notin> set p \\<longrightarrow> DenyAll \\<notin> set (separate p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<notin> set p \\<longrightarrow>\n    DenyAll \\<notin> set (separate p)", "by (induct p rule: separate.induct)  simp_all"], ["", "lemma setnMT: \"set a = set b \\<Longrightarrow> a \\<noteq> [] \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set a = set b; a \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> b \\<noteq> []", "by auto"], ["", "lemma sortnMT: \"p \\<noteq> [] \\<Longrightarrow> sort p l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> FWNormalisationCore.sort p l \\<noteq> []", "by (metis set_sort setnMT)"], ["", "lemma idNMT[rule_format]: \"p \\<noteq> [] \\<longrightarrow> insertDenies p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow> insertDenies p \\<noteq> []", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       insertDenies p \\<noteq> [] \\<Longrightarrow>\n       (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n        | _ \\<Rightarrow>\n            DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n            DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n            insertDenies p) \\<noteq>\n       []", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    insertDenies p \\<noteq> [] \\<Longrightarrow>\n    (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n         insertDenies p) \\<noteq>\n    []", "apply(case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OTNoTN[rule_format]: \" OnlyTwoNets p \\<longrightarrow> x \\<noteq> DenyAll \\<longrightarrow> x \\<in> set p \\<longrightarrow>  onlyTwoNets x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OnlyTwoNets p \\<longrightarrow>\n    x \\<noteq> DenyAll \\<longrightarrow>\n    x \\<in> set p \\<longrightarrow> onlyTwoNets x", "apply (induct p, simp_all, rename_tac a p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       OnlyTwoNets p \\<longrightarrow>\n       x \\<noteq> DenyAll \\<longrightarrow>\n       x \\<in> set p \\<longrightarrow> onlyTwoNets x \\<Longrightarrow>\n       OnlyTwoNets (a # p) \\<longrightarrow>\n       x \\<noteq> DenyAll \\<longrightarrow>\n       (x = a \\<longrightarrow> onlyTwoNets a) \\<and>\n       (x \\<in> set p \\<longrightarrow> onlyTwoNets x)", "apply (intro impI  conjI,  simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n                a \\<in> set p \\<longrightarrow> onlyTwoNets a;\n        OnlyTwoNets (a # p); a \\<noteq> DenyAll; x = a\\<rbrakk>\n       \\<Longrightarrow> onlyTwoNets a\n 2. \\<And>a p.\n       \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n                x \\<noteq> DenyAll \\<longrightarrow>\n                x \\<in> set p \\<longrightarrow> onlyTwoNets x;\n        OnlyTwoNets (a # p); x \\<noteq> DenyAll; x \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> onlyTwoNets x", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n             a \\<in> set p \\<longrightarrow> onlyTwoNets a;\n     OnlyTwoNets (a # p); a \\<noteq> DenyAll; x = a\\<rbrakk>\n    \\<Longrightarrow> onlyTwoNets a", "apply(case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n                x \\<noteq> DenyAll \\<longrightarrow>\n                x \\<in> set p \\<longrightarrow> onlyTwoNets x;\n        OnlyTwoNets (a # p); x \\<noteq> DenyAll; x \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> onlyTwoNets x", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n             x \\<noteq> DenyAll \\<longrightarrow>\n             x \\<in> set p \\<longrightarrow> onlyTwoNets x;\n     OnlyTwoNets (a # p); x \\<noteq> DenyAll; x \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> onlyTwoNets x", "apply(case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma first_isIn[rule_format]:  \"\\<not> member DenyAll x \\<longrightarrow> (first_srcNet x,first_destNet x) \\<in> sdnets x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> member DenyAll x \\<longrightarrow>\n    (first_srcNet x, first_destNet x) \\<in> sdnets x", "by (induct x,case_tac x, simp_all)"], ["", "lemma sdnets2: \n  \"\\<exists>a b. sdnets x = {(a, b), (b, a)} \\<Longrightarrow> \\<not> member DenyAll x \\<Longrightarrow>\n   sdnets x = {(first_srcNet x, first_destNet x),  (first_destNet x, first_srcNet x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>a b. sdnets x = {(a, b), (b, a)};\n     \\<not> member DenyAll x\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>a b. sdnets x = {(a, b), (b, a)};\n     \\<not> member DenyAll x\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}", "have * : \"\\<exists>a b. sdnets x = {(a, b), (b, a)} \\<Longrightarrow> \\<not> member DenyAll x \n            \\<Longrightarrow> (first_srcNet x, first_destNet x) \\<in> sdnets x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>a b. sdnets x = {(a, b), (b, a)};\n     \\<not> member DenyAll x\\<rbrakk>\n    \\<Longrightarrow> (first_srcNet x, first_destNet x) \\<in> sdnets x", "by (erule first_isIn)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>a b. sdnets x = {(a, b), (b, a)};\n   \\<not> member DenyAll x\\<rbrakk>\n  \\<Longrightarrow> (first_srcNet x, first_destNet x) \\<in> sdnets x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>a b. sdnets x = {(a, b), (b, a)};\n     \\<not> member DenyAll x\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}", "show     \"\\<exists>a b. sdnets x = {(a, b), (b, a)} \\<Longrightarrow> \\<not> member DenyAll x \\<Longrightarrow>\n               sdnets x = {(first_srcNet x, first_destNet x),  (first_destNet x, first_srcNet x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>a b. sdnets x = {(a, b), (b, a)};\n     \\<not> member DenyAll x\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}", "using *"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>a b. sdnets x = {(a, b), (b, a)};\n   \\<not> member DenyAll x\\<rbrakk>\n  \\<Longrightarrow> (first_srcNet x, first_destNet x) \\<in> sdnets x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>a b. sdnets x = {(a, b), (b, a)};\n     \\<not> member DenyAll x\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>a b. sdnets x = {(a, b), (b, a)};\n   \\<not> member DenyAll x\\<rbrakk>\n  \\<Longrightarrow> sdnets x =\n                    {(first_srcNet x, first_destNet x),\n                     (first_destNet x, first_srcNet x)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alternativelistconc1[rule_format]: \n  \"a \\<in> set (net_list_aux [x]) \\<longrightarrow>  a \\<in> set (net_list_aux [x,y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (net_list_aux [x]) \\<longrightarrow>\n    a \\<in> set (net_list_aux [x, y])", "by (induct x,simp_all)"], ["", "lemma alternativelistconc2[rule_format]: \n  \"a \\<in> set (net_list_aux [x]) \\<longrightarrow> a \\<in> set (net_list_aux [y,x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (net_list_aux [x]) \\<longrightarrow>\n    a \\<in> set (net_list_aux [y, x])", "by (induct y, simp_all)"], ["", "lemma noDA[rule_format]:\n  \"noDenyAll xs \\<longrightarrow> s \\<in> set xs \\<longrightarrow> \\<not> member DenyAll s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll xs \\<longrightarrow>\n    s \\<in> set xs \\<longrightarrow> \\<not> member DenyAll s", "by (induct xs, simp_all)"], ["", "lemma isInAlternativeList:\n  \"(aa \\<in> set (net_list_aux [a]) \\<or> aa \\<in> set (net_list_aux p)) \\<Longrightarrow> aa \\<in> set (net_list_aux (a # p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aa \\<in> set (net_list_aux [a]) \\<or>\n    aa \\<in> set (net_list_aux p) \\<Longrightarrow>\n    aa \\<in> set (net_list_aux (a # p))", "by (case_tac a,simp_all)"], ["", "lemma netlistaux: \n  \"x \\<in> set (net_list_aux (a # p))\\<Longrightarrow>  x \\<in> set (net_list_aux ([a])) \\<or> x \\<in> set (net_list_aux (p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (net_list_aux (a # p)) \\<Longrightarrow>\n    x \\<in> set (net_list_aux [a]) \\<or> x \\<in> set (net_list_aux p)", "apply (case_tac \" x \\<in> set (net_list_aux [a])\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set (net_list_aux (a # p));\n     x \\<notin> set (net_list_aux [a])\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (net_list_aux p)", "apply (case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma firstInNet[rule_format]: \n  \"\\<not> member DenyAll a \\<longrightarrow>  first_destNet a \\<in> set (net_list_aux (a # p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> member DenyAll a \\<longrightarrow>\n    first_destNet a \\<in> set (net_list_aux (a # p))", "apply (rule Combinators.induct, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n                first_destNet x1 \\<in> set (net_list_aux (x1 # p));\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        first_destNet x2 \\<in> set (net_list_aux (x2 # p))\\<rbrakk>\n       \\<Longrightarrow> \\<not> member DenyAll x1 \\<and>\n                         \\<not> member DenyAll x2 \\<longrightarrow>\n                         first_destNet x1\n                         \\<in> set (net_list_aux [x1]) \\<or>\n                         first_destNet x1\n                         \\<in> set (net_list_aux [x2]) \\<or>\n                         first_destNet x1 \\<in> set (net_list_aux p)", "apply (metis netlistaux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma firstInNeta[rule_format]: \n  \"\\<not> member DenyAll a \\<longrightarrow>  first_srcNet a \\<in> set (net_list_aux (a # p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> member DenyAll a \\<longrightarrow>\n    first_srcNet a \\<in> set (net_list_aux (a # p))", "apply (rule Combinators.induct, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n                first_srcNet x1 \\<in> set (net_list_aux (x1 # p));\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        first_srcNet x2 \\<in> set (net_list_aux (x2 # p))\\<rbrakk>\n       \\<Longrightarrow> \\<not> member DenyAll x1 \\<and>\n                         \\<not> member DenyAll x2 \\<longrightarrow>\n                         first_srcNet x1 \\<in> set (net_list_aux [x1]) \\<or>\n                         first_srcNet x1 \\<in> set (net_list_aux [x2]) \\<or>\n                         first_srcNet x1 \\<in> set (net_list_aux p)", "apply (metis netlistaux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma disjComm: \"disjSD_2 a b \\<Longrightarrow> disjSD_2 b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjSD_2 a b \\<Longrightarrow> disjSD_2 b a", "apply (simp add: disjSD_2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>aa ba c d.\n       (aa, ba) \\<in> sdnets a \\<and>\n       (c, d) \\<in> sdnets b \\<longrightarrow>\n       twoNetsDistinct aa ba c d \\<and>\n       twoNetsDistinct aa ba d c \\<Longrightarrow>\n    \\<forall>aa ba c d.\n       (aa, ba) \\<in> sdnets b \\<and>\n       (c, d) \\<in> sdnets a \\<longrightarrow>\n       twoNetsDistinct aa ba c d \\<and> twoNetsDistinct aa ba d c", "apply (intro allI  impI  conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba c d.\n       \\<lbrakk>\\<forall>aa ba c d.\n                   (aa, ba) \\<in> sdnets a \\<and>\n                   (c, d) \\<in> sdnets b \\<longrightarrow>\n                   twoNetsDistinct aa ba c d \\<and>\n                   twoNetsDistinct aa ba d c;\n        (aa, ba) \\<in> sdnets b \\<and> (c, d) \\<in> sdnets a\\<rbrakk>\n       \\<Longrightarrow> twoNetsDistinct aa ba c d\n 2. \\<And>aa ba c d.\n       \\<lbrakk>\\<forall>aa ba c d.\n                   (aa, ba) \\<in> sdnets a \\<and>\n                   (c, d) \\<in> sdnets b \\<longrightarrow>\n                   twoNetsDistinct aa ba c d \\<and>\n                   twoNetsDistinct aa ba d c;\n        (aa, ba) \\<in> sdnets b \\<and> (c, d) \\<in> sdnets a\\<rbrakk>\n       \\<Longrightarrow> twoNetsDistinct aa ba d c", "using tNDComm"], ["proof (prove)\nusing this:\n  twoNetsDistinct ?a ?b ?c ?d \\<Longrightarrow> twoNetsDistinct ?c ?d ?a ?b\n\ngoal (2 subgoals):\n 1. \\<And>aa ba c d.\n       \\<lbrakk>\\<forall>aa ba c d.\n                   (aa, ba) \\<in> sdnets a \\<and>\n                   (c, d) \\<in> sdnets b \\<longrightarrow>\n                   twoNetsDistinct aa ba c d \\<and>\n                   twoNetsDistinct aa ba d c;\n        (aa, ba) \\<in> sdnets b \\<and> (c, d) \\<in> sdnets a\\<rbrakk>\n       \\<Longrightarrow> twoNetsDistinct aa ba c d\n 2. \\<And>aa ba c d.\n       \\<lbrakk>\\<forall>aa ba c d.\n                   (aa, ba) \\<in> sdnets a \\<and>\n                   (c, d) \\<in> sdnets b \\<longrightarrow>\n                   twoNetsDistinct aa ba c d \\<and>\n                   twoNetsDistinct aa ba d c;\n        (aa, ba) \\<in> sdnets b \\<and> (c, d) \\<in> sdnets a\\<rbrakk>\n       \\<Longrightarrow> twoNetsDistinct aa ba d c", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba c d.\n       \\<lbrakk>\\<forall>aa ba c d.\n                   (aa, ba) \\<in> sdnets a \\<and>\n                   (c, d) \\<in> sdnets b \\<longrightarrow>\n                   twoNetsDistinct aa ba c d \\<and>\n                   twoNetsDistinct aa ba d c;\n        (aa, ba) \\<in> sdnets b \\<and> (c, d) \\<in> sdnets a\\<rbrakk>\n       \\<Longrightarrow> twoNetsDistinct aa ba d c", "by (meson tNDComm twoNetsDistinct_def)"], ["", "lemma disjSD2aux:\n  \"disjSD_2 a b \\<Longrightarrow> \\<not> member DenyAll a \\<Longrightarrow> \\<not> member DenyAll b \\<Longrightarrow>\n  disjSD_2 (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n            DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a)\n           b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>disjSD_2 a b; \\<not> member DenyAll a;\n     \\<not> member DenyAll b\\<rbrakk>\n    \\<Longrightarrow> disjSD_2\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a)\n                       b", "apply (drule disjComm,rule disjComm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll b;\n     disjSD_2 b a\\<rbrakk>\n    \\<Longrightarrow> disjSD_2 b\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a)", "apply (simp add: disjSD_2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll b;\n     \\<forall>aa ba c d.\n        (aa, ba) \\<in> sdnets b \\<and>\n        (c, d) \\<in> sdnets a \\<longrightarrow>\n        twoNetsDistinct aa ba c d \\<and> twoNetsDistinct aa ba d c\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aa ba c d.\n                         (aa, ba) \\<in> sdnets b \\<and>\n                         (c = first_destNet a \\<and>\n                          d = first_srcNet a \\<or>\n                          c = first_srcNet a \\<and>\n                          d = first_destNet a \\<or>\n                          (c, d) \\<in> sdnets a) \\<longrightarrow>\n                         twoNetsDistinct aa ba c d \\<and>\n                         twoNetsDistinct aa ba d c", "using first_isIn"], ["proof (prove)\nusing this:\n  \\<not> member DenyAll ?x \\<Longrightarrow>\n  (first_srcNet ?x, first_destNet ?x) \\<in> sdnets ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll b;\n     \\<forall>aa ba c d.\n        (aa, ba) \\<in> sdnets b \\<and>\n        (c, d) \\<in> sdnets a \\<longrightarrow>\n        twoNetsDistinct aa ba c d \\<and> twoNetsDistinct aa ba d c\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aa ba c d.\n                         (aa, ba) \\<in> sdnets b \\<and>\n                         (c = first_destNet a \\<and>\n                          d = first_srcNet a \\<or>\n                          c = first_srcNet a \\<and>\n                          d = first_destNet a \\<or>\n                          (c, d) \\<in> sdnets a) \\<longrightarrow>\n                         twoNetsDistinct aa ba c d \\<and>\n                         twoNetsDistinct aa ba d c", "by blast"], ["", "lemma noDA1eq[rule_format]: \"noDenyAll p \\<longrightarrow> noDenyAll1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll p \\<longrightarrow> noDenyAll1 p", "apply (induct p, simp,rename_tac a p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       noDenyAll p \\<longrightarrow> noDenyAll1 p \\<Longrightarrow>\n       noDenyAll (a # p) \\<longrightarrow> noDenyAll1 (a # p)", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll p \\<longrightarrow> noDenyAll1 p \\<Longrightarrow>\n    noDenyAll (a # p) \\<longrightarrow> noDenyAll1 (a # p)", "apply(case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma noDA1C[rule_format]: \"noDenyAll1 (a#p) \\<longrightarrow> noDenyAll1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 (a # p) \\<longrightarrow> noDenyAll1 p", "by (case_tac a, simp_all,rule impI, rule noDA1eq, simp)+"], ["", "lemma disjSD_2IDa: \n  \"disjSD_2 x y \\<Longrightarrow>\n   \\<not> member DenyAll x \\<Longrightarrow>\n   \\<not> member DenyAll y \\<Longrightarrow> \n   a = first_srcNet x \\<Longrightarrow> \n   b = first_destNet x \\<Longrightarrow> \n   disjSD_2 (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a \\<oplus> x) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>disjSD_2 x y; \\<not> member DenyAll x; \\<not> member DenyAll y;\n     a = first_srcNet x; b = first_destNet x\\<rbrakk>\n    \\<Longrightarrow> disjSD_2\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> x)\n                       y", "by(simp add:disjSD2aux)"], ["", "lemma noDAID[rule_format]: \"noDenyAll p \\<longrightarrow> noDenyAll (insertDenies p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll p \\<longrightarrow> noDenyAll (insertDenies p)", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       noDenyAll p \\<longrightarrow>\n       noDenyAll (insertDenies p) \\<Longrightarrow>\n       \\<not> member DenyAll a \\<and> noDenyAll p \\<longrightarrow>\n       noDenyAll\n        (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n         | _ \\<Rightarrow>\n             DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n             DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n             insertDenies p)", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll p \\<longrightarrow>\n    noDenyAll (insertDenies p) \\<Longrightarrow>\n    \\<not> member DenyAll a \\<and> noDenyAll p \\<longrightarrow>\n    noDenyAll\n     (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n      | _ \\<Rightarrow>\n          DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n          DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n          insertDenies p)", "apply(case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma isInIDo[rule_format]:  \n  \"noDenyAll p  \\<longrightarrow> s \\<in> set (insertDenies p) \\<longrightarrow> \n   (\\<exists>! a. s = (DenyAllFromTo (first_srcNet a) (first_destNet a)) \\<oplus>\n   (DenyAllFromTo (first_destNet a) (first_srcNet a)) \\<oplus> a \\<and> a \\<in> set p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll p \\<longrightarrow>\n    s \\<in> set (insertDenies p) \\<longrightarrow>\n    (\\<exists>!a.\n        s =\n        DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a \\<and>\n        a \\<in> set p)", "apply (induct p, simp, rename_tac a p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       noDenyAll p \\<longrightarrow>\n       s \\<in> set (insertDenies p) \\<longrightarrow>\n       (\\<exists>!a.\n           s =\n           DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n           DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n           a \\<and>\n           a \\<in> set p) \\<Longrightarrow>\n       noDenyAll (a # p) \\<longrightarrow>\n       s \\<in> set (insertDenies (a # p)) \\<longrightarrow>\n       (\\<exists>!aa.\n           s =\n           DenyAllFromTo (first_srcNet aa) (first_destNet aa) \\<oplus>\n           DenyAllFromTo (first_destNet aa) (first_srcNet aa) \\<oplus>\n           aa \\<and>\n           aa \\<in> set (a # p))", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll p \\<longrightarrow>\n    s \\<in> set (insertDenies p) \\<longrightarrow>\n    (\\<exists>!a.\n        s =\n        DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a \\<and>\n        a \\<in> set p) \\<Longrightarrow>\n    noDenyAll (a # p) \\<longrightarrow>\n    s \\<in> set (insertDenies (a # p)) \\<longrightarrow>\n    (\\<exists>!aa.\n        s =\n        DenyAllFromTo (first_srcNet aa) (first_destNet aa) \\<oplus>\n        DenyAllFromTo (first_destNet aa) (first_srcNet aa) \\<oplus>\n        aa \\<and>\n        aa \\<in> set (a # p))", "apply (case_tac \"a = DenyAll\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll p \\<longrightarrow>\n             s \\<in> set (insertDenies p) \\<longrightarrow>\n             (\\<exists>!a.\n                 s =\n                 DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n                 DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n                 a \\<and>\n                 a \\<in> set p);\n     a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll (a # p) \\<longrightarrow>\n                      s \\<in> set (insertDenies (a # p)) \\<longrightarrow>\n                      (\\<exists>!aa.\n                          s =\n                          DenyAllFromTo (first_srcNet aa)\n                           (first_destNet aa) \\<oplus>\n                          DenyAllFromTo (first_destNet aa)\n                           (first_srcNet aa) \\<oplus>\n                          aa \\<and>\n                          aa \\<in> set (a # p))", "apply (case_tac a, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma id_aux1[rule_format]: \"DenyAllFromTo (first_srcNet s) (first_destNet s) \\<oplus>\n      DenyAllFromTo (first_destNet s) (first_srcNet s) \\<oplus> s\\<in> set (insertDenies p)\n    \\<longrightarrow> s \\<in> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAllFromTo (first_srcNet s) (first_destNet s) \\<oplus>\n    DenyAllFromTo (first_destNet s) (first_srcNet s) \\<oplus> s\n    \\<in> set (insertDenies p) \\<longrightarrow>\n    s \\<in> set p", "apply (induct p, simp_all, rename_tac a p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       DenyAllFromTo (first_srcNet s) (first_destNet s) \\<oplus>\n       DenyAllFromTo (first_destNet s) (first_srcNet s) \\<oplus> s\n       \\<in> set (insertDenies p) \\<longrightarrow>\n       s \\<in> set p \\<Longrightarrow>\n       DenyAllFromTo (first_srcNet s) (first_destNet s) \\<oplus>\n       DenyAllFromTo (first_destNet s) (first_srcNet s) \\<oplus> s\n       \\<in> set (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                  | _ \\<Rightarrow>\n                      DenyAllFromTo (first_srcNet a)\n                       (first_destNet a) \\<oplus>\n                      DenyAllFromTo (first_destNet a)\n                       (first_srcNet a) \\<oplus>\n                      a #\n                      insertDenies p) \\<longrightarrow>\n       s = a \\<or> s \\<in> set p", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAllFromTo (first_srcNet s) (first_destNet s) \\<oplus>\n    DenyAllFromTo (first_destNet s) (first_srcNet s) \\<oplus> s\n    \\<in> set (insertDenies p) \\<longrightarrow>\n    s \\<in> set p \\<Longrightarrow>\n    DenyAllFromTo (first_srcNet s) (first_destNet s) \\<oplus>\n    DenyAllFromTo (first_destNet s) (first_srcNet s) \\<oplus> s\n    \\<in> set (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n               | _ \\<Rightarrow>\n                   DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n                   DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n                   a #\n                   insertDenies p) \\<longrightarrow>\n    s = a \\<or> s \\<in> set p", "apply(case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma id_aux2:\n  \"noDenyAll p \\<Longrightarrow>\n   \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s \\<Longrightarrow>\n   \\<not> member DenyAll a \\<Longrightarrow>\n   DenyAllFromTo (first_srcNet s) (first_destNet s) \\<oplus> \n   DenyAllFromTo (first_destNet s) (first_srcNet s) \\<oplus> s \\<in> set (insertDenies p) \\<Longrightarrow>\n   disjSD_2 a (DenyAllFromTo (first_srcNet s) (first_destNet s) \\<oplus> \n   DenyAllFromTo (first_destNet s) (first_srcNet s) \\<oplus> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll p;\n     \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s;\n     \\<not> member DenyAll a;\n     DenyAllFromTo (first_srcNet s) (first_destNet s) \\<oplus>\n     DenyAllFromTo (first_destNet s) (first_srcNet s) \\<oplus> s\n     \\<in> set (insertDenies p)\\<rbrakk>\n    \\<Longrightarrow> disjSD_2 a\n                       (DenyAllFromTo (first_srcNet s)\n                         (first_destNet s) \\<oplus>\n                        DenyAllFromTo (first_destNet s)\n                         (first_srcNet s) \\<oplus>\n                        s)", "by (metis disjComm disjSD2aux isInIDo noDA)"], ["", "lemma id_aux4[rule_format]: \n  \"noDenyAll p \\<Longrightarrow> \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s \\<Longrightarrow> \n   s \\<in> set (insertDenies p) \\<Longrightarrow> \\<not> member DenyAll a \\<Longrightarrow> \n   disjSD_2 a s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll p;\n     \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s;\n     s \\<in> set (insertDenies p); \\<not> member DenyAll a\\<rbrakk>\n    \\<Longrightarrow> disjSD_2 a s", "apply (subgoal_tac \"\\<exists>a. s =\n          DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n          DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a \\<and>\n          a \\<in> set p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>noDenyAll p;\n     \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s;\n     s \\<in> set (insertDenies p); \\<not> member DenyAll a;\n     \\<exists>a.\n        s =\n        DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n        DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a \\<and>\n        a \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> disjSD_2 a s\n 2. \\<lbrakk>noDenyAll p;\n     \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s;\n     s \\<in> set (insertDenies p); \\<not> member DenyAll a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a.\n                         s =\n                         DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<and>\n                         a \\<in> set p", "apply (drule_tac Q = \"disjSD_2 a s\" in exE, simp_all, rule id_aux2, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll p;\n     \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s;\n     s \\<in> set (insertDenies p); \\<not> member DenyAll a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a.\n                         s =\n                         DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<and>\n                         a \\<in> set p", "using isInIDo"], ["proof (prove)\nusing this:\n  \\<lbrakk>noDenyAll ?p; ?s \\<in> set (insertDenies ?p)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!a.\n                       ?s =\n                       DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a \\<and>\n                       a \\<in> set ?p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll p;\n     \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s;\n     s \\<in> set (insertDenies p); \\<not> member DenyAll a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a.\n                         s =\n                         DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a \\<and>\n                         a \\<in> set p", "by blast"], ["", "lemma sepNetsID[rule_format]: \n  \"noDenyAll1 p \\<longrightarrow> separated p \\<longrightarrow> separated (insertDenies p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 p \\<longrightarrow>\n    separated p \\<longrightarrow> separated (insertDenies p)", "apply (induct p, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       noDenyAll1 p \\<longrightarrow>\n       separated p \\<longrightarrow>\n       separated (insertDenies p) \\<Longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       separated (a # p) \\<longrightarrow> separated (insertDenies (a # p))", "apply (rename_tac a p, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>noDenyAll1 (a # p);\n        \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s;\n        separated p; \\<not> noDenyAll1 p\\<rbrakk>\n       \\<Longrightarrow> separated\n                          (case a of\n                           DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                           | _ \\<Rightarrow>\n                               DenyAllFromTo (first_srcNet a)\n                                (first_destNet a) \\<oplus>\n                               DenyAllFromTo (first_destNet a)\n                                (first_srcNet a) \\<oplus>\n                               a #\n                               insertDenies p)\n 2. \\<And>a p.\n       \\<lbrakk>noDenyAll1 (a # p);\n        \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s;\n        separated p; separated (insertDenies p)\\<rbrakk>\n       \\<Longrightarrow> separated\n                          (case a of\n                           DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                           | _ \\<Rightarrow>\n                               DenyAllFromTo (first_srcNet a)\n                                (first_destNet a) \\<oplus>\n                               DenyAllFromTo (first_destNet a)\n                                (first_srcNet a) \\<oplus>\n                               a #\n                               insertDenies p)", "using noDA1C"], ["proof (prove)\nusing this:\n  noDenyAll1 (?a # ?p) \\<Longrightarrow> noDenyAll1 ?p\n\ngoal (2 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>noDenyAll1 (a # p);\n        \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s;\n        separated p; \\<not> noDenyAll1 p\\<rbrakk>\n       \\<Longrightarrow> separated\n                          (case a of\n                           DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                           | _ \\<Rightarrow>\n                               DenyAllFromTo (first_srcNet a)\n                                (first_destNet a) \\<oplus>\n                               DenyAllFromTo (first_destNet a)\n                                (first_srcNet a) \\<oplus>\n                               a #\n                               insertDenies p)\n 2. \\<And>a p.\n       \\<lbrakk>noDenyAll1 (a # p);\n        \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s;\n        separated p; separated (insertDenies p)\\<rbrakk>\n       \\<Longrightarrow> separated\n                          (case a of\n                           DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                           | _ \\<Rightarrow>\n                               DenyAllFromTo (first_srcNet a)\n                                (first_destNet a) \\<oplus>\n                               DenyAllFromTo (first_destNet a)\n                                (first_srcNet a) \\<oplus>\n                               a #\n                               insertDenies p)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>noDenyAll1 (a # p);\n        \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s;\n        separated p; separated (insertDenies p)\\<rbrakk>\n       \\<Longrightarrow> separated\n                          (case a of\n                           DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                           | _ \\<Rightarrow>\n                               DenyAllFromTo (first_srcNet a)\n                                (first_destNet a) \\<oplus>\n                               DenyAllFromTo (first_destNet a)\n                                (first_srcNet a) \\<oplus>\n                               a #\n                               insertDenies p)", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll1 (a # p);\n     \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s; separated p;\n     separated (insertDenies p)\\<rbrakk>\n    \\<Longrightarrow> separated\n                       (case a of\n                        DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                        | _ \\<Rightarrow>\n                            DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a #\n                            insertDenies p)", "apply (case_tac \"a = DenyAll\", auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>noDenyAll p;\n        \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 DenyAll s;\n        separated p; separated (insertDenies p); a = DenyAll;\n        s \\<in> set (insertDenies p)\\<rbrakk>\n       \\<Longrightarrow> disjSD_2 DenyAll s\n 2. \\<lbrakk>noDenyAll1 (a # p);\n     \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s; separated p;\n     separated (insertDenies p); a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> separated\n                       (case a of\n                        DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                        | _ \\<Rightarrow>\n                            DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a #\n                            insertDenies p)", "apply (simp add: disjSD_2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll1 (a # p);\n     \\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s; separated p;\n     separated (insertDenies p); a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> separated\n                       (case a of\n                        DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                        | _ \\<Rightarrow>\n                            DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a #\n                            insertDenies p)", "apply (case_tac a,auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22 s.\n       \\<lbrakk>noDenyAll p;\n        \\<forall>s.\n           s \\<in> set p \\<longrightarrow>\n           disjSD_2 (DenyAllFromTo x21 x22) s;\n        separated p; separated (insertDenies p); a = DenyAllFromTo x21 x22;\n        s \\<in> set (insertDenies p)\\<rbrakk>\n       \\<Longrightarrow> disjSD_2\n                          (DenyAllFromTo x21 x22 \\<oplus>\n                           DenyAllFromTo x22 x21 \\<oplus>\n                           DenyAllFromTo x21 x22)\n                          s\n 2. \\<And>x31 x32 x33 s.\n       \\<lbrakk>noDenyAll p;\n        \\<forall>s.\n           s \\<in> set p \\<longrightarrow>\n           disjSD_2 (AllowPortFromTo x31 x32 x33) s;\n        separated p; separated (insertDenies p);\n        a = AllowPortFromTo x31 x32 x33;\n        s \\<in> set (insertDenies p)\\<rbrakk>\n       \\<Longrightarrow> disjSD_2\n                          (DenyAllFromTo x31 x32 \\<oplus>\n                           DenyAllFromTo x32 x31 \\<oplus>\n                           AllowPortFromTo x31 x32 x33)\n                          s\n 3. \\<And>x41 x42 s.\n       \\<lbrakk>\\<forall>s.\n                   s \\<in> set p \\<longrightarrow>\n                   disjSD_2 (x41 \\<oplus> x42) s;\n        separated p; separated (insertDenies p); a = x41 \\<oplus> x42;\n        \\<not> member DenyAll x41; \\<not> member DenyAll x42; noDenyAll p;\n        s \\<in> set (insertDenies p)\\<rbrakk>\n       \\<Longrightarrow> disjSD_2\n                          (DenyAllFromTo (first_srcNet x41)\n                            (first_destNet x41) \\<oplus>\n                           DenyAllFromTo (first_destNet x41)\n                            (first_srcNet x41) \\<oplus>\n                           x41 \\<oplus> x42)\n                          s", "apply (rule disjSD_2IDa, simp_all, rule id_aux4, simp_all, metis noDA noDAID)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aNDDA[rule_format]: \"allNetsDistinct p \\<longrightarrow> allNetsDistinct(DenyAll#p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allNetsDistinct p \\<longrightarrow> allNetsDistinct (DenyAll # p)", "by (case_tac p,auto simp: allNetsDistinct_def)"], ["", "lemma OTNConc[rule_format]: \"OnlyTwoNets (y # z) \\<longrightarrow>  OnlyTwoNets z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OnlyTwoNets (y # z) \\<longrightarrow> OnlyTwoNets z", "by (case_tac y, simp_all)"], ["", "lemma first_bothNetsd: \"\\<not> member DenyAll x \\<Longrightarrow> first_bothNet x = {first_srcNet x, first_destNet x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> member DenyAll x \\<Longrightarrow>\n    first_bothNet x = {first_srcNet x, first_destNet x}", "by (induct x) simp_all"], ["", "lemma bNaux:\n  \"\\<not> member DenyAll x \\<Longrightarrow> \\<not> member DenyAll y \\<Longrightarrow>\n   first_bothNet x = first_bothNet y \\<Longrightarrow>\n   {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll x; \\<not> member DenyAll y;\n     first_bothNet x = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "by (simp add: first_bothNetsd)"], ["", "lemma setPair: \"{a,b} = {a,d} \\<Longrightarrow> b = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a, b} = {a, d} \\<Longrightarrow> b = d", "by (metis setPaireq)"], ["", "lemma setPair1: \"{a,b} = {d,a} \\<Longrightarrow> b = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a, b} = {d, a} \\<Longrightarrow> b = d", "by (metis Un_empty_right Un_insert_right insert_absorb2 setPaireq)"], ["", "lemma setPair4: \"{a,b} = {c,d} \\<Longrightarrow> a \\<noteq> c \\<Longrightarrow> a = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a, b} = {c, d}; a \\<noteq> c\\<rbrakk> \\<Longrightarrow> a = d", "by auto"], ["", "lemma otnaux1: \" {x, y, x, y} = {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y, x, y} = {x, y}", "by auto"], ["", "lemma OTNIDaux4: \"{x,y,x} = {y,x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y, x} = {y, x}", "by auto"], ["", "lemma setPair5: \"{a,b} = {c,d} \\<Longrightarrow> a \\<noteq> c \\<Longrightarrow> a = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a, b} = {c, d}; a \\<noteq> c\\<rbrakk> \\<Longrightarrow> a = d", "by auto"], ["", "lemma otnaux: \"   \n  \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x; \\<not> member DenyAll y; \n   onlyTwoNets y; onlyTwoNets x\\<rbrakk> \\<Longrightarrow> \n   onlyTwoNets (x \\<oplus> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; onlyTwoNets y; onlyTwoNets x\\<rbrakk>\n    \\<Longrightarrow> onlyTwoNets (x \\<oplus> y)", "apply (simp add: onlyTwoNets_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})", "apply (subgoal_tac \"{first_srcNet x, first_destNet x} =\n                     {first_srcNet y, first_destNet y}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} =\n     {first_srcNet y, first_destNet y}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (case_tac \"(\\<exists>a b. sdnets y = {(a, b)})\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<nexists>a b. sdnets y = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (case_tac \"(\\<exists>a b. sdnets x = {(a, b)})\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<nexists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"sdnets x = {(first_srcNet x, first_destNet x)}\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)}; \\<exists>a b. sdnets x = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"sdnets y = {(first_srcNet y, first_destNet y)}\")"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)}; \\<exists>a b. sdnets x = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)}; \\<exists>a b. sdnets x = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)}\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_srcNet y \\<and>\n                      first_destNet x = first_destNet y \\<or>\n                      (\\<exists>a b.\n                          {(first_srcNet y, first_destNet y),\n                           (first_srcNet x, first_destNet x)} =\n                          {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)}; \\<exists>a b. sdnets x = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (case_tac \"first_srcNet x = first_srcNet y\")"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_srcNet y \\<and>\n                      first_destNet x = first_destNet y \\<or>\n                      (\\<exists>a b.\n                          {(first_srcNet y, first_destNet y),\n                           (first_srcNet x, first_destNet x)} =\n                          {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_srcNet y \\<and>\n                      first_destNet x = first_destNet y \\<or>\n                      (\\<exists>a b.\n                          {(first_srcNet y, first_destNet y),\n                           (first_srcNet x, first_destNet x)} =\n                          {(a, b), (b, a)})\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)}; \\<exists>a b. sdnets x = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp_all"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet y, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_destNet y \\<or>\n                      (\\<exists>a b.\n                          {(first_srcNet y, first_destNet y),\n                           (first_srcNet y, first_destNet x)} =\n                          {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_srcNet x, first_destNet x)} =\n                         {(a, b), (b, a)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule disjI1)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet y, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_destNet y\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_srcNet x, first_destNet x)} =\n                         {(a, b), (b, a)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule setPair)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet y, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> {?a8, first_destNet x} = {?a8, first_destNet y}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_srcNet x, first_destNet x)} =\n                         {(a, b), (b, a)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_srcNet x, first_destNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"first_srcNet x = first_destNet y\")"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_srcNet x, first_destNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_destNet y, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_destNet y \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_destNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"first_destNet x = first_srcNet y\")"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_destNet y, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_destNet y \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y;\n     first_destNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_destNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_destNet y, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_destNet y \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_srcNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 8. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_destNet y, first_srcNet y} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_destNet y, first_srcNet y)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_destNet y \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y;\n     first_destNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_destNet y, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_destNet y \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_srcNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 8. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule_tac x =\"first_srcNet y\" in exI, rule_tac x = \"first_destNet y\" in exI,simp)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_destNet y, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_destNet y \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_srcNet y\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule setPair1)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_destNet y, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_destNet y \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> {?a14, first_destNet x} = {first_srcNet y, ?a14}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule setPair4)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, ?b16} = {?c16, first_destNet y}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x \\<noteq> ?c16\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp_all"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (metis first_isIn singletonE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (metis first_isIn singletonE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"sdnets x = {(first_srcNet x, first_destNet x),\n                                    (first_destNet x, first_srcNet x)}\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)};\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"sdnets y = {(first_srcNet y, first_destNet y)}\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)};\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)};\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)}\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_srcNet y \\<and>\n                      first_destNet x = first_destNet y \\<and>\n                      first_destNet x = first_srcNet y \\<and>\n                      first_srcNet x = first_destNet y \\<or>\n                      (\\<exists>a b.\n                          {(first_srcNet y, first_destNet y),\n                           (first_srcNet x, first_destNet x),\n                           (first_destNet x, first_srcNet x)} =\n                          {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)};\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (case_tac \"first_srcNet x = first_srcNet y\")"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_srcNet y \\<and>\n                      first_destNet x = first_destNet y \\<and>\n                      first_destNet x = first_srcNet y \\<and>\n                      first_srcNet x = first_destNet y \\<or>\n                      (\\<exists>a b.\n                          {(first_srcNet y, first_destNet y),\n                           (first_srcNet x, first_destNet x),\n                           (first_destNet x, first_srcNet x)} =\n                          {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_srcNet y \\<and>\n                      first_destNet x = first_destNet y \\<and>\n                      first_destNet x = first_srcNet y \\<and>\n                      first_srcNet x = first_destNet y \\<or>\n                      (\\<exists>a b.\n                          {(first_srcNet y, first_destNet y),\n                           (first_srcNet x, first_destNet x),\n                           (first_destNet x, first_srcNet x)} =\n                          {(a, b), (b, a)})\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)};\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp_all"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet x),\n         (first_destNet x, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet y, first_destNet x), (first_destNet x, first_srcNet y)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_srcNet y, first_destNet x),\n                          (first_destNet x, first_srcNet y)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"first_destNet x = first_destNet y\")"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet x),\n         (first_destNet x, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet y, first_destNet x), (first_destNet x, first_srcNet y)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x = first_srcNet y;\n     first_destNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_srcNet y, first_destNet x),\n                          (first_destNet x, first_srcNet y)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet x),\n         (first_destNet x, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet y, first_destNet x), (first_destNet x, first_srcNet y)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet x),\n         (first_destNet x, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet y, first_destNet x), (first_destNet x, first_srcNet y)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_destNet y\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule setPair)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet x),\n         (first_destNet x, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet y, first_destNet x), (first_destNet x, first_srcNet y)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> {?a31, first_destNet x} = {?a31, first_destNet y}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"first_srcNet x = first_destNet y\")"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_destNet y, first_destNet x),\n         (first_destNet x, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_destNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_destNet y, first_destNet x),\n      (first_destNet x, first_destNet y)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_destNet y \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_destNet x),\n                          (first_destNet x, first_destNet y)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"first_destNet x = first_srcNet y\")"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_destNet y, first_destNet x),\n         (first_destNet x, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_destNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_destNet y, first_destNet x),\n      (first_destNet x, first_destNet y)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_destNet y \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y;\n     first_destNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_destNet x),\n                          (first_destNet x, first_destNet y)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_destNet y, first_destNet x),\n         (first_destNet x, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_destNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_destNet y, first_destNet x),\n      (first_destNet x, first_destNet y)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_destNet y \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_srcNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_destNet y, first_srcNet y),\n         (first_srcNet y, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_srcNet y} = {first_srcNet y, first_destNet y};\n     sdnets x =\n     {(first_destNet y, first_srcNet y), (first_srcNet y, first_destNet y)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_destNet y \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y;\n     first_destNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet y, first_destNet y)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_destNet y, first_destNet x),\n         (first_destNet x, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_destNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_destNet y, first_destNet x),\n      (first_destNet x, first_destNet y)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_destNet y \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_srcNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule_tac x =\"first_srcNet y\" in exI, rule_tac x = \"first_destNet y\" in exI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_destNet y, first_srcNet y),\n         (first_srcNet y, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_srcNet y} = {first_srcNet y, first_destNet y};\n     sdnets x =\n     {(first_destNet y, first_srcNet y), (first_srcNet y, first_destNet y)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_destNet y \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y;\n     first_destNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y),\n                       (first_srcNet y, first_destNet y)} =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_destNet y, first_destNet x),\n         (first_destNet x, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_destNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_destNet y, first_destNet x),\n      (first_destNet x, first_destNet y)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_destNet y \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_srcNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (metis OTNIDaux4 insert_commute )"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_destNet y, first_destNet x),\n         (first_destNet x, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_destNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_destNet y, first_destNet x),\n      (first_destNet x, first_destNet y)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_destNet y \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_srcNet y\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule setPair1)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_destNet y, first_destNet x),\n         (first_destNet x, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_destNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_destNet y, first_destNet x),\n      (first_destNet x, first_destNet y)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_destNet y \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> {?a41, first_destNet x} = {first_srcNet y, ?a41}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule setPair5)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, ?b43} = {?c43, first_destNet y}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x \\<noteq> ?c43\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply assumption"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y = {(first_srcNet y, first_destNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x \\<noteq> first_srcNet y\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y = {(first_srcNet y, first_destNet y)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (metis first_isIn singletonE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule sdnets2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b. sdnets x = {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<exists>a b. sdnets y = {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> \\<not> member DenyAll x\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (case_tac \"(\\<exists>a b. sdnets x = {(a, b)})\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)});\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<nexists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"sdnets x = {(first_srcNet x, first_destNet x)}\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"sdnets y = {(first_srcNet y, first_destNet y),\n                                 (first_destNet y, first_srcNet y)}\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y),\n      (first_destNet y, first_srcNet y)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y),\n      (first_destNet y, first_srcNet y)}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (case_tac \"first_srcNet x = first_srcNet y\")"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x)} =\n                         {(a, b), (b, a)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp_all"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet y, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet y, first_destNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x)} =\n                         {(a, b), (b, a)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"first_destNet x = first_destNet y\")"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet y, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y;\n     first_destNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet y, first_destNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet y, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x)} =\n                         {(a, b), (b, a)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet y, first_destNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y;\n     first_destNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet y, first_destNet y)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet y, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x)} =\n                         {(a, b), (b, a)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule_tac x =\"first_srcNet y\" in exI, rule_tac x = \"first_destNet y\" in exI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet y, first_destNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y;\n     first_destNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y),\n                       (first_srcNet y, first_destNet y)} =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet y, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x)} =\n                         {(a, b), (b, a)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (metis OTNIDaux4 insert_commute )"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet y, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_destNet y\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x)} =\n                         {(a, b), (b, a)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule setPair)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet y, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> {?a64, first_destNet x} = {?a64, first_destNet y}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x)} =\n                         {(a, b), (b, a)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"first_srcNet x = first_destNet y\")"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_destNet y, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_destNet y, first_destNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"first_destNet x = first_srcNet y\")"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_destNet y, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_destNet y;\n     first_destNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_destNet y, first_destNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_destNet y, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_srcNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 7. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_destNet y, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_srcNet y\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule setPair1)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_destNet y, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> {?a68, first_destNet x} = {first_srcNet y, ?a68}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule setPair4)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, ?b70} = {?c70, first_destNet y}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x \\<noteq> ?c70\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply assumption"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x = {(first_srcNet x, first_destNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x \\<noteq> first_srcNet y\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule sdnets2)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b. sdnets y = {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> \\<not> member DenyAll y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     sdnets x = {(first_srcNet x, first_destNet x)}\\<rbrakk>\n    \\<Longrightarrow> \\<not> member DenyAll y\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<exists>a b. sdnets x = {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x = {(first_srcNet x, first_destNet x)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (metis singletonE first_isIn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"sdnets x = {(first_srcNet x, first_destNet x),\n                                 (first_destNet x, first_srcNet x)}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)};\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"sdnets y = {(first_srcNet y, first_destNet y),\n                                (first_destNet y, first_srcNet y)}\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)};\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y),\n      (first_destNet y, first_srcNet y)}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b)}) \\<or>\n                      (\\<exists>a b.\n                          sdnets x \\<union> sdnets y = {(a, b), (b, a)})\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)};\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y),\n      (first_destNet y, first_srcNet y)}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)};\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (case_tac \"first_srcNet x = first_srcNet y\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)};\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp_all"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet x),\n         (first_destNet x, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet y, first_destNet x), (first_destNet x, first_srcNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet y, first_destNet x),\n                          (first_destNet x, first_srcNet y)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"first_destNet x = first_destNet y\")"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet x),\n         (first_destNet x, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet y, first_destNet x), (first_destNet x, first_srcNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y;\n     first_destNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet y, first_destNet x),\n                          (first_destNet x, first_srcNet y)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet x),\n         (first_destNet x, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet y, first_destNet x), (first_destNet x, first_srcNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y;\n     first_destNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet x),\n         (first_destNet x, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet y, first_destNet x), (first_destNet x, first_srcNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule_tac x =\"first_srcNet y\" in exI, rule_tac x = \"first_destNet y\" in exI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y;\n     first_destNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y),\n                       (first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)} =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet x),\n         (first_destNet x, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet y, first_destNet x), (first_destNet x, first_srcNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule otnaux1)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet x),\n         (first_destNet x, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet y, first_destNet x), (first_destNet x, first_srcNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_destNet y\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule setPair)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet x),\n         (first_destNet x, first_srcNet y)} =\n        {(a, b), (b, a)};\n     {first_srcNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet y, first_destNet x), (first_destNet x, first_srcNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> {?a87, first_destNet x} = {?a87, first_destNet y}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"first_srcNet x = first_destNet y\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y;\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet x, first_destNet x),\n                          (first_destNet x, first_srcNet x)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_destNet y, first_destNet x),\n         (first_destNet x, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_destNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_destNet y, first_destNet x),\n      (first_destNet x, first_destNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_destNet y, first_destNet x),\n                          (first_destNet x, first_destNet y)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (subgoal_tac \"first_destNet x = first_srcNet y\")"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_destNet y, first_destNet x),\n         (first_destNet x, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_destNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_destNet y, first_destNet x),\n      (first_destNet x, first_destNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_destNet y;\n     first_destNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_destNet y, first_destNet x),\n                          (first_destNet x, first_destNet y)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_destNet y, first_destNet x),\n         (first_destNet x, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_destNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_destNet y, first_destNet x),\n      (first_destNet x, first_destNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_srcNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_destNet y, first_srcNet y),\n         (first_srcNet y, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_srcNet y} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x =\n     {(first_destNet y, first_srcNet y), (first_srcNet y, first_destNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_destNet y;\n     first_destNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         {(first_srcNet y, first_destNet y),\n                          (first_destNet y, first_srcNet y),\n                          (first_srcNet y, first_destNet y)} =\n                         {(a, b), (b, a)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_destNet y, first_destNet x),\n         (first_destNet x, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_destNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_destNet y, first_destNet x),\n      (first_destNet x, first_destNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_srcNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule_tac x =\"first_srcNet y\" in exI, rule_tac x = \"first_destNet y\" in exI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_destNet y, first_srcNet y),\n         (first_srcNet y, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_srcNet y} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     sdnets x =\n     {(first_destNet y, first_srcNet y), (first_srcNet y, first_destNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_destNet y;\n     first_destNet x = first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y),\n                       (first_srcNet y, first_destNet y)} =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_destNet y, first_destNet x),\n         (first_destNet x, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_destNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_destNet y, first_destNet x),\n      (first_destNet x, first_destNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_srcNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 6. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (metis OTNIDaux4 insert_commute)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_destNet y, first_destNet x),\n         (first_destNet x, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_destNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_destNet y, first_destNet x),\n      (first_destNet x, first_destNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> first_destNet x = first_srcNet y\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule setPair1)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_destNet y, first_destNet x),\n         (first_destNet x, first_destNet y)} =\n        {(a, b), (b, a)};\n     {first_destNet y, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_destNet y \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_destNet y, first_destNet x),\n      (first_destNet x, first_destNet y)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x = first_destNet y\\<rbrakk>\n    \\<Longrightarrow> {?a97, first_destNet x} = {first_srcNet y, ?a97}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x = first_destNet y\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule setPair4)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, ?b99} = {?c99, first_destNet y}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x \\<noteq> ?c99\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 5. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply assumption"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     \\<exists>a b.\n        {(first_srcNet y, first_destNet y),\n         (first_destNet y, first_srcNet y)} =\n        {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     first_srcNet y \\<noteq> first_destNet y;\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x), (first_destNet x, first_srcNet x)};\n     sdnets y =\n     {(first_srcNet y, first_destNet y), (first_destNet y, first_srcNet y)};\n     first_srcNet x \\<noteq> first_srcNet y\\<rbrakk>\n    \\<Longrightarrow> first_srcNet x \\<noteq> first_srcNet y\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 4. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b.\n        {(first_srcNet x, first_destNet x),\n         (first_destNet x, first_srcNet x)} =\n        {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     first_srcNet x \\<noteq> first_destNet x;\n     sdnets x =\n     {(first_srcNet x, first_destNet x),\n      (first_destNet x, first_srcNet x)}\\<rbrakk>\n    \\<Longrightarrow> sdnets y =\n                      {(first_srcNet y, first_destNet y),\n                       (first_destNet y, first_srcNet y)}\n 2. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y; \\<exists>a b. sdnets y = {(a, b), (b, a)};\n     \\<exists>a b. sdnets x = {(a, b), (b, a)};\n     {first_srcNet x, first_destNet x} = {first_srcNet y, first_destNet y};\n     \\<forall>a b. sdnets y \\<noteq> {(a, b)};\n     \\<forall>a b. sdnets x \\<noteq> {(a, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets x =\n                      {(first_srcNet x, first_destNet x),\n                       (first_destNet x, first_srcNet x)}\n 3. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule sdnets2,simp_all)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>first_bothNet x = first_bothNet y; \\<not> member DenyAll x;\n     \\<not> member DenyAll y;\n     (\\<exists>a b. sdnets y = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets y = {(a, b), (b, a)});\n     (\\<exists>a b. sdnets x = {(a, b)}) \\<or>\n     (\\<exists>a b. sdnets x = {(a, b), (b, a)})\\<rbrakk>\n    \\<Longrightarrow> {first_srcNet x, first_destNet x} =\n                      {first_srcNet y, first_destNet y}", "apply (rule bNaux, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OTNSepaux: \n  \"onlyTwoNets (a \\<oplus> y) \\<and> OnlyTwoNets z \\<longrightarrow> OnlyTwoNets (separate (a \\<oplus> y # z)) \\<Longrightarrow>\n    \\<not> member DenyAll a \\<Longrightarrow>  \\<not> member DenyAll y \\<Longrightarrow>\n    noDenyAll z \\<Longrightarrow> onlyTwoNets a \\<Longrightarrow> OnlyTwoNets (y # z) \\<Longrightarrow> first_bothNet a = first_bothNet y \\<Longrightarrow> \n    OnlyTwoNets (separate (a \\<oplus> y # z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets (a \\<oplus> y) \\<and>\n             OnlyTwoNets z \\<longrightarrow>\n             OnlyTwoNets (separate (a \\<oplus> y # z));\n     \\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets (separate (a \\<oplus> y # z))", "apply (drule mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> onlyTwoNets (a \\<oplus> y) \\<and> OnlyTwoNets z\n 2. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z); first_bothNet a = first_bothNet y;\n     OnlyTwoNets (separate (a \\<oplus> y # z))\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets (separate (a \\<oplus> y # z))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> onlyTwoNets (a \\<oplus> y) \\<and> OnlyTwoNets z", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> onlyTwoNets (a \\<oplus> y)\n 2. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets z", "apply (rule otnaux)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> first_bothNet a = first_bothNet y\n 2. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> \\<not> member DenyAll a\n 3. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> \\<not> member DenyAll y\n 4. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> onlyTwoNets y\n 5. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> onlyTwoNets a\n 6. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets z", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> onlyTwoNets y\n 2. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets z", "apply (rule_tac p = \"(y # z)\" in OTNoTN)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets (y # z)\n 2. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> y \\<noteq> DenyAll\n 3. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> y \\<in> set (y # z)\n 4. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets z", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> y \\<noteq> DenyAll\n 2. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets z", "apply (metis member.simps(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     onlyTwoNets a; OnlyTwoNets (y # z);\n     first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets z", "apply (simp add: onlyTwoNets_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll a; \\<not> member DenyAll y; noDenyAll z;\n     (\\<exists>aa b. sdnets a = {(aa, b)}) \\<or>\n     (\\<exists>aa b. sdnets a = {(aa, b), (b, aa)});\n     OnlyTwoNets (y # z); first_bothNet a = first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets z", "apply (rule_tac y = y in OTNConc,simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OTNSEp[rule_format]: \n  \"noDenyAll1 p \\<longrightarrow> OnlyTwoNets p  \\<longrightarrow>  OnlyTwoNets (separate p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 p \\<longrightarrow>\n    OnlyTwoNets p \\<longrightarrow> OnlyTwoNets (separate p)", "apply (induct p rule: separate.induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x.\n       noDenyAll1 x \\<longrightarrow>\n       OnlyTwoNets x \\<longrightarrow>\n       OnlyTwoNets (separate x) \\<Longrightarrow>\n       noDenyAll1 (DenyAll # x) \\<longrightarrow>\n       OnlyTwoNets (DenyAll # x) \\<longrightarrow>\n       OnlyTwoNets (separate (DenyAll # x))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (DenyAllFromTo v va) =\n                first_bothNet y \\<Longrightarrow>\n                noDenyAll1\n                 (DenyAllFromTo v va \\<oplus> y # z) \\<longrightarrow>\n                OnlyTwoNets\n                 (DenyAllFromTo v va \\<oplus> y # z) \\<longrightarrow>\n                OnlyTwoNets (separate (DenyAllFromTo v va \\<oplus> y # z));\n        first_bothNet (DenyAllFromTo v va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        OnlyTwoNets (y # z) \\<longrightarrow>\n        OnlyTwoNets (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1\n                          (DenyAllFromTo v va # y # z) \\<longrightarrow>\n                         OnlyTwoNets\n                          (DenyAllFromTo v va # y # z) \\<longrightarrow>\n                         OnlyTwoNets (separate (DenyAllFromTo v va # y # z))\n 3. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                noDenyAll1\n                 (AllowPortFromTo v va vb \\<oplus> y # z) \\<longrightarrow>\n                OnlyTwoNets\n                 (AllowPortFromTo v va vb \\<oplus> y # z) \\<longrightarrow>\n                OnlyTwoNets\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        OnlyTwoNets (y # z) \\<longrightarrow>\n        OnlyTwoNets (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1\n                          (AllowPortFromTo v va vb #\n                           y # z) \\<longrightarrow>\n                         OnlyTwoNets\n                          (AllowPortFromTo v va vb #\n                           y # z) \\<longrightarrow>\n                         OnlyTwoNets\n                          (separate (AllowPortFromTo v va vb # y # z))\n 4. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                noDenyAll1\n                 ((v \\<oplus> va) \\<oplus> y # z) \\<longrightarrow>\n                OnlyTwoNets\n                 ((v \\<oplus> va) \\<oplus> y # z) \\<longrightarrow>\n                OnlyTwoNets (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        OnlyTwoNets (y # z) \\<longrightarrow>\n        OnlyTwoNets (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1\n                          (v \\<oplus> va # y # z) \\<longrightarrow>\n                         OnlyTwoNets\n                          (v \\<oplus> va # y # z) \\<longrightarrow>\n                         OnlyTwoNets (separate (v \\<oplus> va # y # z))\n 5. noDenyAll1 [] \\<longrightarrow>\n    OnlyTwoNets [] \\<longrightarrow> OnlyTwoNets (separate [])\n 6. \\<And>vb vc.\n       noDenyAll1 [DenyAllFromTo vb vc] \\<longrightarrow>\n       OnlyTwoNets [DenyAllFromTo vb vc] \\<longrightarrow>\n       OnlyTwoNets (separate [DenyAllFromTo vb vc])\n 7. \\<And>vb vc vd.\n       noDenyAll1 [AllowPortFromTo vb vc vd] \\<longrightarrow>\n       OnlyTwoNets [AllowPortFromTo vb vc vd] \\<longrightarrow>\n       OnlyTwoNets (separate [AllowPortFromTo vb vc vd])\n 8. \\<And>vb vc.\n       noDenyAll1 [vb \\<oplus> vc] \\<longrightarrow>\n       OnlyTwoNets [vb \\<oplus> vc] \\<longrightarrow>\n       OnlyTwoNets (separate [vb \\<oplus> vc])", "by (simp_all add: OTNSepaux noDA1eq)"], ["", "lemma nda[rule_format]: \n  \"singleCombinators (a#p) \\<longrightarrow> noDenyAll p \\<longrightarrow> noDenyAll1 (a # p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators (a # p) \\<longrightarrow>\n    noDenyAll p \\<longrightarrow> noDenyAll1 (a # p)", "apply (induct p,simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. singleCombinators [a] \\<longrightarrow> noDenyAll1 [a]\n 2. \\<And>aa p.\n       singleCombinators (a # p) \\<longrightarrow>\n       noDenyAll p \\<longrightarrow> noDenyAll1 (a # p) \\<Longrightarrow>\n       singleCombinators (a # aa # p) \\<longrightarrow>\n       \\<not> member DenyAll aa \\<and> noDenyAll p \\<longrightarrow>\n       noDenyAll1 (a # aa # p)", "apply (case_tac a, simp_all)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nDAcharn[rule_format]: \"noDenyAll p = (\\<forall> r \\<in> set p. \\<not> member DenyAll r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll p = (\\<forall>r\\<in>set p. \\<not> member DenyAll r)", "by (induct p, simp_all)"], ["", "lemma nDAeqSet: \"set p = set s \\<Longrightarrow> noDenyAll p = noDenyAll s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set p = set s \\<Longrightarrow> noDenyAll p = noDenyAll s", "by (simp add: nDAcharn)"], ["", "lemma nDASCaux[rule_format]: \n  \"DenyAll \\<notin> set p \\<longrightarrow> singleCombinators p \\<longrightarrow>  r \\<in> set p \\<longrightarrow>  \\<not> member DenyAll r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<notin> set p \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    r \\<in> set p \\<longrightarrow> \\<not> member DenyAll r", "apply (case_tac r, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       DenyAll \\<notin> set p \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       x41 \\<oplus> x42 \\<in> set p \\<longrightarrow>\n       \\<not> member DenyAll x41 \\<and> \\<not> member DenyAll x42", "using SCnotConc"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<oplus> ?b \\<in> set ?p; singleCombinators ?p\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       DenyAll \\<notin> set p \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       x41 \\<oplus> x42 \\<in> set p \\<longrightarrow>\n       \\<not> member DenyAll x41 \\<and> \\<not> member DenyAll x42", "by blast"], ["", "lemma nDASC[rule_format]: \n  \"wellformed_policy1 p \\<longrightarrow> singleCombinators p \\<longrightarrow>  noDenyAll1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1 p \\<longrightarrow>\n    singleCombinators p \\<longrightarrow> noDenyAll1 p", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       wellformed_policy1 p \\<longrightarrow>\n       singleCombinators p \\<longrightarrow> noDenyAll1 p \\<Longrightarrow>\n       DenyAll \\<notin> set p \\<longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow> noDenyAll1 (a # p)", "using nDASCaux nDAcharn nda singleCombinatorsConc"], ["proof (prove)\nusing this:\n  \\<lbrakk>DenyAll \\<notin> set ?p; singleCombinators ?p;\n   ?r \\<in> set ?p\\<rbrakk>\n  \\<Longrightarrow> \\<not> member DenyAll ?r\n  noDenyAll ?p = (\\<forall>r\\<in>set ?p. \\<not> member DenyAll r)\n  \\<lbrakk>singleCombinators (?a # ?p); noDenyAll ?p\\<rbrakk>\n  \\<Longrightarrow> noDenyAll1 (?a # ?p)\n  singleCombinators (?x # ?xs) \\<Longrightarrow> singleCombinators ?xs\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       wellformed_policy1 p \\<longrightarrow>\n       singleCombinators p \\<longrightarrow> noDenyAll1 p \\<Longrightarrow>\n       DenyAll \\<notin> set p \\<longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow> noDenyAll1 (a # p)", "by blast"], ["", "lemma noDAAll[rule_format]: \"noDenyAll p = (\\<not> memberP DenyAll p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll p = (\\<not> memberP DenyAll p)", "by (induct p) simp_all"], ["", "lemma memberPsep[symmetric]: \"memberP x p = memberP x (separate p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. memberP x p = memberP x (separate p)", "by (induct p rule: separate.induct)  simp_all"], ["", "lemma noDAsep[rule_format]: \"noDenyAll p \\<Longrightarrow> noDenyAll (separate p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll p \\<Longrightarrow> noDenyAll (separate p)", "by (simp add:noDAAll,subst memberPsep, simp)"], ["", "lemma noDA1sep[rule_format]: \"noDenyAll1 p \\<longrightarrow> noDenyAll1 (separate p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 p \\<longrightarrow> noDenyAll1 (separate p)", "by (induct p rule:separate.induct, simp_all add: noDAsep)"], ["", "lemma isInAlternativeLista: \n  \"(aa \\<in> set (net_list_aux [a]))\\<Longrightarrow>  aa \\<in> set (net_list_aux (a # p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aa \\<in> set (net_list_aux [a]) \\<Longrightarrow>\n    aa \\<in> set (net_list_aux (a # p))", "by (case_tac a,auto)"], ["", "lemma isInAlternativeListb: \n  \"(aa \\<in> set (net_list_aux p))\\<Longrightarrow>  aa \\<in> set (net_list_aux (a # p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aa \\<in> set (net_list_aux p) \\<Longrightarrow>\n    aa \\<in> set (net_list_aux (a # p))", "by (case_tac a,simp_all)"], ["", "lemma ANDSepaux: \"allNetsDistinct (x # y # z) \\<Longrightarrow> allNetsDistinct (x \\<oplus> y # z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allNetsDistinct (x # y # z) \\<Longrightarrow>\n    allNetsDistinct (x \\<oplus> y # z)", "apply (simp add: allNetsDistinct_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       a \\<noteq> b \\<and>\n       a \\<in> set (net_list_aux (x # y # z)) \\<and>\n       b \\<in> set (net_list_aux (x # y # z)) \\<longrightarrow>\n       netsDistinct a b \\<Longrightarrow>\n    \\<forall>a b.\n       a \\<noteq> b \\<and>\n       (a \\<in> set (net_list_aux [x]) \\<or>\n        a \\<in> set (net_list_aux [y]) \\<or>\n        a \\<in> set (net_list_aux z)) \\<and>\n       (b \\<in> set (net_list_aux [x]) \\<or>\n        b \\<in> set (net_list_aux [y]) \\<or>\n        b \\<in> set (net_list_aux z)) \\<longrightarrow>\n       netsDistinct a b", "apply (intro allI impI, rename_tac a b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>a b.\n                   a \\<noteq> b \\<and>\n                   a \\<in> set (net_list_aux (x # y # z)) \\<and>\n                   b \\<in> set (net_list_aux (x # y # z)) \\<longrightarrow>\n                   netsDistinct a b;\n        a \\<noteq> b \\<and>\n        (a \\<in> set (net_list_aux [x]) \\<or>\n         a \\<in> set (net_list_aux [y]) \\<or>\n         a \\<in> set (net_list_aux z)) \\<and>\n        (b \\<in> set (net_list_aux [x]) \\<or>\n         b \\<in> set (net_list_aux [y]) \\<or>\n         b \\<in> set (net_list_aux z))\\<rbrakk>\n       \\<Longrightarrow> netsDistinct a b", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b.\n                a \\<noteq> b \\<and>\n                a \\<in> set (net_list_aux (x # y # z)) \\<and>\n                b \\<in> set (net_list_aux (x # y # z)) \\<longrightarrow>\n                netsDistinct a b;\n     a \\<noteq> b \\<and>\n     (a \\<in> set (net_list_aux [x]) \\<or>\n      a \\<in> set (net_list_aux [y]) \\<or>\n      a \\<in> set (net_list_aux z)) \\<and>\n     (b \\<in> set (net_list_aux [x]) \\<or>\n      b \\<in> set (net_list_aux [y]) \\<or>\n      b \\<in> set (net_list_aux z))\\<rbrakk>\n    \\<Longrightarrow> netsDistinct a b", "apply (drule_tac x = a in spec, drule_tac x = b in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> b \\<and>\n             (a \\<in> set (net_list_aux [x]) \\<or>\n              a \\<in> set (net_list_aux [y]) \\<or>\n              a \\<in> set (net_list_aux z)) \\<and>\n             (b \\<in> set (net_list_aux [x]) \\<or>\n              b \\<in> set (net_list_aux [y]) \\<or>\n              b \\<in> set (net_list_aux z));\n     a \\<noteq> b \\<and>\n     a \\<in> set (net_list_aux (x # y # z)) \\<and>\n     b \\<in> set (net_list_aux (x # y # z)) \\<longrightarrow>\n     netsDistinct a b\\<rbrakk>\n    \\<Longrightarrow> netsDistinct a b", "by (meson isInAlternativeList)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma netlistalternativeSeparateaux:\n  \"net_list_aux [y] @ net_list_aux z = net_list_aux (y # z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. net_list_aux [y] @ net_list_aux z = net_list_aux (y # z)", "by (case_tac y, simp_all)"], ["", "lemma netlistalternativeSeparate: \"net_list_aux p = net_list_aux (separate p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. net_list_aux p = net_list_aux (separate p)", "by (induct p rule:separate.induct, simp_all) (simp_all add: netlistalternativeSeparateaux)"], ["", "lemma  ANDSepaux2: \n  \"allNetsDistinct(x#y#z) \\<Longrightarrow> allNetsDistinct(separate(y#z)) \\<Longrightarrow> allNetsDistinct(x#separate(y#z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allNetsDistinct (x # y # z);\n     allNetsDistinct (separate (y # z))\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct (x # separate (y # z))", "apply (simp add: allNetsDistinct_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b.\n                a \\<noteq> b \\<and>\n                a \\<in> set (net_list_aux (x # y # z)) \\<and>\n                b \\<in> set (net_list_aux (x # y # z)) \\<longrightarrow>\n                netsDistinct a b;\n     \\<forall>a b.\n        a \\<noteq> b \\<and>\n        a \\<in> set (net_list_aux (separate (y # z))) \\<and>\n        b \\<in> set (net_list_aux (separate (y # z))) \\<longrightarrow>\n        netsDistinct a b\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b.\n                         a \\<noteq> b \\<and>\n                         a \\<in> set (net_list_aux\n (x # separate (y # z))) \\<and>\n                         b \\<in> set (net_list_aux\n (x # separate (y # z))) \\<longrightarrow>\n                         netsDistinct a b", "by (metis isInAlternativeList netlistalternativeSeparate netlistaux)"], ["", "lemma ANDSep[rule_format]: \"allNetsDistinct p \\<longrightarrow> allNetsDistinct(separate p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allNetsDistinct p \\<longrightarrow> allNetsDistinct (separate p)", "apply (induct p rule: separate.induct, simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       allNetsDistinct x \\<longrightarrow>\n       allNetsDistinct (separate x) \\<Longrightarrow>\n       allNetsDistinct (DenyAll # x) \\<longrightarrow>\n       allNetsDistinct (DenyAll # separate x)\n 2. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                allNetsDistinct\n                 (DenyAllFromTo v va \\<oplus> y # z) \\<longrightarrow>\n                allNetsDistinct\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        allNetsDistinct (y # z) \\<longrightarrow>\n        allNetsDistinct (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (DenyAllFromTo v va # y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (separate\n                             (DenyAllFromTo v va \\<oplus> y # z))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (DenyAllFromTo v va # y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (DenyAllFromTo v va # separate (y # z)))\n 3. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                allNetsDistinct\n                 (AllowPortFromTo v va vb \\<oplus> y # z) \\<longrightarrow>\n                allNetsDistinct\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        allNetsDistinct (y # z) \\<longrightarrow>\n        allNetsDistinct (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (AllowPortFromTo v va vb #\n                            y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (separate\n                             (AllowPortFromTo v va vb \\<oplus> y #\n                              z))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (AllowPortFromTo v va vb #\n                            y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (AllowPortFromTo v va vb # separate (y # z)))\n 4. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                allNetsDistinct\n                 ((v \\<oplus> va) \\<oplus> y # z) \\<longrightarrow>\n                allNetsDistinct (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        allNetsDistinct (y # z) \\<longrightarrow>\n        allNetsDistinct (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (v \\<oplus> va # y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (separate\n                             ((v \\<oplus> va) \\<oplus> y # z))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (v \\<oplus> va # y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (v \\<oplus> va # separate (y # z)))", "apply (metis ANDConc aNDDA)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                allNetsDistinct\n                 (DenyAllFromTo v va \\<oplus> y # z) \\<longrightarrow>\n                allNetsDistinct\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        allNetsDistinct (y # z) \\<longrightarrow>\n        allNetsDistinct (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (DenyAllFromTo v va # y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (separate\n                             (DenyAllFromTo v va \\<oplus> y # z))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (DenyAllFromTo v va # y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (DenyAllFromTo v va # separate (y # z)))\n 2. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                allNetsDistinct\n                 (AllowPortFromTo v va vb \\<oplus> y # z) \\<longrightarrow>\n                allNetsDistinct\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        allNetsDistinct (y # z) \\<longrightarrow>\n        allNetsDistinct (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (AllowPortFromTo v va vb #\n                            y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (separate\n                             (AllowPortFromTo v va vb \\<oplus> y #\n                              z))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (AllowPortFromTo v va vb #\n                            y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (AllowPortFromTo v va vb # separate (y # z)))\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                allNetsDistinct\n                 ((v \\<oplus> va) \\<oplus> y # z) \\<longrightarrow>\n                allNetsDistinct (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        allNetsDistinct (y # z) \\<longrightarrow>\n        allNetsDistinct (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (v \\<oplus> va # y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (separate\n                             ((v \\<oplus> va) \\<oplus> y # z))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (v \\<oplus> va # y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (v \\<oplus> va # separate (y # z)))", "apply (metis ANDConc ANDSepaux ANDSepaux2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                allNetsDistinct\n                 (AllowPortFromTo v va vb \\<oplus> y # z) \\<longrightarrow>\n                allNetsDistinct\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        allNetsDistinct (y # z) \\<longrightarrow>\n        allNetsDistinct (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (AllowPortFromTo v va vb #\n                            y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (separate\n                             (AllowPortFromTo v va vb \\<oplus> y #\n                              z))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (AllowPortFromTo v va vb #\n                            y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (AllowPortFromTo v va vb # separate (y # z)))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                allNetsDistinct\n                 ((v \\<oplus> va) \\<oplus> y # z) \\<longrightarrow>\n                allNetsDistinct (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        allNetsDistinct (y # z) \\<longrightarrow>\n        allNetsDistinct (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (v \\<oplus> va # y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (separate\n                             ((v \\<oplus> va) \\<oplus> y # z))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (v \\<oplus> va # y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (v \\<oplus> va # separate (y # z)))", "apply (metis ANDConc ANDSepaux ANDSepaux2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                allNetsDistinct\n                 ((v \\<oplus> va) \\<oplus> y # z) \\<longrightarrow>\n                allNetsDistinct (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        allNetsDistinct (y # z) \\<longrightarrow>\n        allNetsDistinct (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (v \\<oplus> va # y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (separate\n                             ((v \\<oplus> va) \\<oplus> y # z))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          allNetsDistinct\n                           (v \\<oplus> va # y # z) \\<longrightarrow>\n                          allNetsDistinct\n                           (v \\<oplus> va # separate (y # z)))", "apply (metis ANDConc ANDSepaux ANDSepaux2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wp1_alternativesep[rule_format]: \n  \"wellformed_policy1_strong p \\<longrightarrow> wellformed_policy1_strong (separate p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<longrightarrow>\n    wellformed_policy1_strong (separate p)", "by (metis sepDA separate.simps(1) wellformed_policy1_strong.simps(2) wp1n_tl)"], ["", "lemma noDAsort[rule_format]: \"noDenyAll1 p \\<longrightarrow> noDenyAll1 (sort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 p \\<longrightarrow> noDenyAll1 (FWNormalisationCore.sort p l)", "apply (case_tac \"p\",simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       noDenyAll1 (a # list) \\<longrightarrow>\n       noDenyAll1\n        (FWNormalisationCore.insort a (FWNormalisationCore.sort list l) l)", "subgoal for a as"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = a # as \\<Longrightarrow>\n    noDenyAll1 (a # as) \\<longrightarrow>\n    noDenyAll1\n     (FWNormalisationCore.insort a (FWNormalisationCore.sort as l) l)", "apply (case_tac \"a = DenyAll\", auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = DenyAll # as; a = DenyAll; noDenyAll as\\<rbrakk>\n    \\<Longrightarrow> noDenyAll (FWNormalisationCore.sort as l)\n 2. \\<lbrakk>p = a # as; a \\<noteq> DenyAll; noDenyAll1 (a # as)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1\n                       (FWNormalisationCore.insort a\n                         (FWNormalisationCore.sort as l) l)", "using NormalisationGenericProofs.set_sort nDAeqSet"], ["proof (prove)\nusing this:\n  set (FWNormalisationCore.sort ?xs ?l) = set ?xs\n  set ?p = set ?s \\<Longrightarrow> noDenyAll ?p = noDenyAll ?s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p = DenyAll # as; a = DenyAll; noDenyAll as\\<rbrakk>\n    \\<Longrightarrow> noDenyAll (FWNormalisationCore.sort as l)\n 2. \\<lbrakk>p = a # as; a \\<noteq> DenyAll; noDenyAll1 (a # as)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1\n                       (FWNormalisationCore.insort a\n                         (FWNormalisationCore.sort as l) l)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a # as; a \\<noteq> DenyAll; noDenyAll1 (a # as)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1\n                       (FWNormalisationCore.insort a\n                         (FWNormalisationCore.sort as l) l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a # as; a \\<noteq> DenyAll; noDenyAll1 (a # as)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1\n                       (FWNormalisationCore.insort a\n                         (FWNormalisationCore.sort as l) l)", "fix a::\"('a,'b)Combinators\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a__ # as; a__ \\<noteq> DenyAll;\n     noDenyAll1 (a__ # as)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1\n                       (FWNormalisationCore.insort a__\n                         (FWNormalisationCore.sort as l) l)", "fix list"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a__ # as; a__ \\<noteq> DenyAll;\n     noDenyAll1 (a__ # as)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1\n                       (FWNormalisationCore.insort a__\n                         (FWNormalisationCore.sort as l) l)", "have * : \"a \\<noteq> DenyAll \\<Longrightarrow> noDenyAll1 (a # list) \\<Longrightarrow> noDenyAll (a#list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> DenyAll; noDenyAll1 (a # list)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll (a # list)", "by (case_tac a, simp_all)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> DenyAll; noDenyAll1 (a # list)\\<rbrakk>\n  \\<Longrightarrow> noDenyAll (a # list)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a__ # as; a__ \\<noteq> DenyAll;\n     noDenyAll1 (a__ # as)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1\n                       (FWNormalisationCore.insort a__\n                         (FWNormalisationCore.sort as l) l)", "show \"a \\<noteq> DenyAll \\<Longrightarrow> noDenyAll1 (a # list) \\<Longrightarrow> noDenyAll1 (insort a (sort list l) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> DenyAll; noDenyAll1 (a # list)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1\n                       (FWNormalisationCore.insort a\n                         (FWNormalisationCore.sort list l) l)", "apply(cases \"insort a (sort list l) l\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>a \\<noteq> DenyAll; noDenyAll1 (a # list);\n        FWNormalisationCore.insort a (FWNormalisationCore.sort list l) l =\n        a # lista\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (a # lista)", "by (metis \"*\" NormalisationGenericProofs.set_insort NormalisationGenericProofs.set_sort \n          list.simps(15) nDAeqSet noDA1eq)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> DenyAll; noDenyAll1 (a # list)\\<rbrakk>\n  \\<Longrightarrow> noDenyAll1\n                     (FWNormalisationCore.insort a\n                       (FWNormalisationCore.sort list l) l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OTNSC[rule_format]: \"singleCombinators p \\<longrightarrow> OnlyTwoNets p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<longrightarrow> OnlyTwoNets p", "apply (induct p,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       singleCombinators p \\<longrightarrow> OnlyTwoNets p \\<Longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow> OnlyTwoNets (a # p)", "apply (rename_tac a p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       singleCombinators p \\<longrightarrow> OnlyTwoNets p \\<Longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow> OnlyTwoNets (a # p)", "apply (rule impI,drule mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a p.\n       singleCombinators (a # p) \\<Longrightarrow> singleCombinators p\n 2. \\<And>a p.\n       \\<lbrakk>singleCombinators (a # p); OnlyTwoNets p\\<rbrakk>\n       \\<Longrightarrow> OnlyTwoNets (a # p)", "apply (erule singleCombinatorsConc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>singleCombinators (a # p); OnlyTwoNets p\\<rbrakk>\n       \\<Longrightarrow> OnlyTwoNets (a # p)", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators (a # b); OnlyTwoNets b\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets (a # b)", "apply (case_tac a, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>singleCombinators b; OnlyTwoNets b;\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> onlyTwoNets (DenyAllFromTo x21 x22)\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>singleCombinators b; OnlyTwoNets b;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> onlyTwoNets (AllowPortFromTo x31 x32 x33)", "apply (simp add: onlyTwoNets_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fMTaux: \"\\<not> member DenyAll x \\<Longrightarrow> first_bothNet x \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> member DenyAll x \\<Longrightarrow> first_bothNet x \\<noteq> {}", "by (metis first_bothNetsd insert_commute insert_not_empty)"], ["", "lemma fl2[rule_format]: \"firstList (separate p) = firstList p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. firstList (separate p) = firstList p", "by (rule separate.induct) simp_all"], ["", "lemma fl3[rule_format]: \"NetsCollected p \\<longrightarrow> (first_bothNet x \\<noteq> firstList p \\<longrightarrow>\n          (\\<forall>a\\<in>set p. first_bothNet x \\<noteq> first_bothNet a))\\<longrightarrow> NetsCollected (x#p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NetsCollected p \\<longrightarrow>\n    (first_bothNet x \\<noteq> firstList p \\<longrightarrow>\n     (\\<forall>a\\<in>set p.\n         first_bothNet x \\<noteq> first_bothNet a)) \\<longrightarrow>\n    NetsCollected (x # p)", "by (induct p) simp_all"], ["", "lemma sortedConc[rule_format]: \" sorted (a # p) l \\<longrightarrow>  sorted p l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    FWNormalisationCore.sorted p l", "by (induct p) simp_all"], ["", "lemma smalleraux2: \n  \"{a,b} \\<in> set l \\<Longrightarrow> {c,d} \\<in> set l \\<Longrightarrow> {a,b} \\<noteq> {c,d} \\<Longrightarrow> \n   smaller (DenyAllFromTo a b) (DenyAllFromTo c d) l \\<Longrightarrow> \n  \\<not> smaller (DenyAllFromTo c d) (DenyAllFromTo a b) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a, b} \\<in> set l; {c, d} \\<in> set l; {a, b} \\<noteq> {c, d};\n     smaller (DenyAllFromTo a b) (DenyAllFromTo c d) l\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller (DenyAllFromTo c d) (DenyAllFromTo a b)\n                              l", "by (metis bothNet.simps(2) pos_noteq smaller.simps(5))"], ["", "lemma smalleraux2a: \n  \"{a,b} \\<in> set l \\<Longrightarrow> {c,d} \\<in> set l \\<Longrightarrow> {a,b} \\<noteq> {c,d} \\<Longrightarrow> \n   smaller (DenyAllFromTo a b) (AllowPortFromTo c d p) l \\<Longrightarrow> \n  \\<not> smaller (AllowPortFromTo c d p) (DenyAllFromTo a b) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a, b} \\<in> set l; {c, d} \\<in> set l; {a, b} \\<noteq> {c, d};\n     smaller (DenyAllFromTo a b) (AllowPortFromTo c d p) l\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller (AllowPortFromTo c d p)\n                              (DenyAllFromTo a b) l", "by (simp) (metis eq_imp_le pos_noteq)"], ["", "lemma smalleraux2b: \n  \"{a,b} \\<in> set l \\<Longrightarrow> {c,d} \\<in> set l \\<Longrightarrow> {a,b} \\<noteq> {c,d} \\<Longrightarrow> y = DenyAllFromTo a b \\<Longrightarrow>\n   smaller (AllowPortFromTo  c d p) y l \\<Longrightarrow> \n  \\<not> smaller y (AllowPortFromTo  c d p) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a, b} \\<in> set l; {c, d} \\<in> set l; {a, b} \\<noteq> {c, d};\n     y = DenyAllFromTo a b; smaller (AllowPortFromTo c d p) y l\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller y (AllowPortFromTo c d p) l", "by (simp) (metis eq_imp_le pos_noteq)"], ["", "lemma smalleraux2c: \n  \"{a,b} \\<in> set l\\<Longrightarrow>{c,d}\\<in>set l\\<Longrightarrow>{a,b} \\<noteq> {c,d} \\<Longrightarrow> y = AllowPortFromTo a b q \\<Longrightarrow> \n    smaller (AllowPortFromTo  c d p) y l \\<Longrightarrow> \\<not> smaller y (AllowPortFromTo  c d p) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a, b} \\<in> set l; {c, d} \\<in> set l; {a, b} \\<noteq> {c, d};\n     y = AllowPortFromTo a b q; smaller (AllowPortFromTo c d p) y l\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller y (AllowPortFromTo c d p) l", "by (simp) (metis pos_noteq)"], ["", "lemma smalleraux3: \n  assumes \"x \\<in> set l\" and \" y \\<in> set l\" and \"x \\<noteq> y\" and \"x = bothNet a\" and \"y = bothNet b\"\n    and \"smaller a b l\" and \"singleCombinators [a]\" and \"singleCombinators [b]\"  \n  shows \"\\<not> smaller b a l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "proof (cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. a = DenyAll \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x21 x22.\n       a = DenyAllFromTo x21 x22 \\<Longrightarrow> \\<not> smaller b a l\n 3. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       \\<not> smaller b a l\n 4. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow> \\<not> smaller b a l", "case DenyAll"], ["proof (state)\nthis:\n  a = DenyAll\n\ngoal (4 subgoals):\n 1. a = DenyAll \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x21 x22.\n       a = DenyAllFromTo x21 x22 \\<Longrightarrow> \\<not> smaller b a l\n 3. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       \\<not> smaller b a l\n 4. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow> \\<not> smaller b a l", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = DenyAll\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "using assms"], ["proof (prove)\nusing this:\n  a = DenyAll\n  x \\<in> set l\n  y \\<in> set l\n  x \\<noteq> y\n  x = bothNet a\n  y = bothNet b\n  smaller a b l\n  singleCombinators [a]\n  singleCombinators [b]\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "by (case_tac b,simp_all)"], ["proof (state)\nthis:\n  \\<not> smaller b a l\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       a = DenyAllFromTo x21 x22 \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       \\<not> smaller b a l\n 3. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow> \\<not> smaller b a l", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       a = DenyAllFromTo x21 x22 \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       \\<not> smaller b a l\n 3. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow> \\<not> smaller b a l", "case (DenyAllFromTo c d)"], ["proof (state)\nthis:\n  a = DenyAllFromTo c d\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       a = DenyAllFromTo x21 x22 \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       \\<not> smaller b a l\n 3. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow> \\<not> smaller b a l", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = DenyAllFromTo c d\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "proof (cases b)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>a = DenyAllFromTo c d; b = DenyAll\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x21 x22.\n       \\<lbrakk>a = DenyAllFromTo c d; b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 4. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "case DenyAll"], ["proof (state)\nthis:\n  b = DenyAll\n\ngoal (4 subgoals):\n 1. \\<lbrakk>a = DenyAllFromTo c d; b = DenyAll\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x21 x22.\n       \\<lbrakk>a = DenyAllFromTo c d; b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 4. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = DenyAll\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "using assms DenyAll DenyAllFromTo"], ["proof (prove)\nusing this:\n  b = DenyAll\n  x \\<in> set l\n  y \\<in> set l\n  x \\<noteq> y\n  x = bothNet a\n  y = bothNet b\n  smaller a b l\n  singleCombinators [a]\n  singleCombinators [b]\n  b = DenyAll\n  a = DenyAllFromTo c d\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "by simp"], ["proof (state)\nthis:\n  \\<not> smaller b a l\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>a = DenyAllFromTo c d; b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 3. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>a = DenyAllFromTo c d; b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 3. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "case (DenyAllFromTo e f)"], ["proof (state)\nthis:\n  b = DenyAllFromTo e f\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>a = DenyAllFromTo c d; b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 3. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = DenyAllFromTo e f\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "using assms  DenyAllFromTo"], ["proof (prove)\nusing this:\n  b = DenyAllFromTo e f\n  x \\<in> set l\n  y \\<in> set l\n  x \\<noteq> y\n  x = bothNet a\n  y = bothNet b\n  smaller a b l\n  singleCombinators [a]\n  singleCombinators [b]\n  b = DenyAllFromTo e f\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "by (metis DenyAllFromTo \\<open>a = DenyAllFromTo c d\\<close>  bothNet.simps(2) smalleraux2)"], ["proof (state)\nthis:\n  \\<not> smaller b a l\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "case (AllowPortFromTo e f g)"], ["proof (state)\nthis:\n  b = AllowPortFromTo e f g\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = AllowPortFromTo e f g\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "using assms DenyAllFromTo AllowPortFromTo"], ["proof (prove)\nusing this:\n  b = AllowPortFromTo e f g\n  x \\<in> set l\n  y \\<in> set l\n  x \\<noteq> y\n  x = bothNet a\n  y = bothNet b\n  smaller a b l\n  singleCombinators [a]\n  singleCombinators [b]\n  a = DenyAllFromTo c d\n  b = AllowPortFromTo e f g\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "by simp (metis eq_imp_le pos_noteq)"], ["proof (state)\nthis:\n  \\<not> smaller b a l\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "case (Conc e f)"], ["proof (state)\nthis:\n  b = e \\<oplus> f\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = e \\<oplus> f\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "using assms"], ["proof (prove)\nusing this:\n  b = e \\<oplus> f\n  x \\<in> set l\n  y \\<in> set l\n  x \\<noteq> y\n  x = bothNet a\n  y = bothNet b\n  smaller a b l\n  singleCombinators [a]\n  singleCombinators [b]\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "by simp"], ["proof (state)\nthis:\n  \\<not> smaller b a l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> smaller b a l\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       \\<not> smaller b a l\n 2. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow> \\<not> smaller b a l", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       \\<not> smaller b a l\n 2. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow> \\<not> smaller b a l", "case (AllowPortFromTo c d p)"], ["proof (state)\nthis:\n  a = AllowPortFromTo c d p\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       \\<not> smaller b a l\n 2. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow> \\<not> smaller b a l", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = AllowPortFromTo c d p\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "proof (cases b)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>a = AllowPortFromTo c d p; b = DenyAll\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x21 x22.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 4. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "case DenyAll"], ["proof (state)\nthis:\n  b = DenyAll\n\ngoal (4 subgoals):\n 1. \\<lbrakk>a = AllowPortFromTo c d p; b = DenyAll\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x21 x22.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 4. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = DenyAll\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "using assms AllowPortFromTo DenyAll"], ["proof (prove)\nusing this:\n  b = DenyAll\n  x \\<in> set l\n  y \\<in> set l\n  x \\<noteq> y\n  x = bothNet a\n  y = bothNet b\n  smaller a b l\n  singleCombinators [a]\n  singleCombinators [b]\n  a = AllowPortFromTo c d p\n  b = DenyAll\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "by simp"], ["proof (state)\nthis:\n  \\<not> smaller b a l\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 3. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 3. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "case (DenyAllFromTo e f)"], ["proof (state)\nthis:\n  b = DenyAllFromTo e f\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 3. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = DenyAllFromTo e f\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "using assms"], ["proof (prove)\nusing this:\n  b = DenyAllFromTo e f\n  x \\<in> set l\n  y \\<in> set l\n  x \\<noteq> y\n  x = bothNet a\n  y = bothNet b\n  smaller a b l\n  singleCombinators [a]\n  singleCombinators [b]\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "by simp (metis AllowPortFromTo DenyAllFromTo bothNet.simps(3) smalleraux2a)"], ["proof (state)\nthis:\n  \\<not> smaller b a l\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "case (AllowPortFromTo e f g)"], ["proof (state)\nthis:\n  b = AllowPortFromTo e f g\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l\n 2. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = AllowPortFromTo e f g\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "using assms"], ["proof (prove)\nusing this:\n  b = AllowPortFromTo e f g\n  x \\<in> set l\n  y \\<in> set l\n  x \\<noteq> y\n  x = bothNet a\n  y = bothNet b\n  smaller a b l\n  singleCombinators [a]\n  singleCombinators [b]\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "by(simp)(metis AllowPortFromTo \\<open>a = AllowPortFromTo c d p\\<close> \n          bothNet.simps(3) smalleraux2c)"], ["proof (state)\nthis:\n  \\<not> smaller b a l\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "case (Conc e f)"], ["proof (state)\nthis:\n  b = e \\<oplus> f\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> smaller b a l", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = e \\<oplus> f\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "using assms"], ["proof (prove)\nusing this:\n  b = e \\<oplus> f\n  x \\<in> set l\n  y \\<in> set l\n  x \\<noteq> y\n  x = bothNet a\n  y = bothNet b\n  smaller a b l\n  singleCombinators [a]\n  singleCombinators [b]\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "by simp"], ["proof (state)\nthis:\n  \\<not> smaller b a l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> smaller b a l\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow> \\<not> smaller b a l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow> \\<not> smaller b a l", "case (Conc c d)"], ["proof (state)\nthis:\n  a = c \\<oplus> d\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow> \\<not> smaller b a l", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = c \\<oplus> d\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "using assms"], ["proof (prove)\nusing this:\n  a = c \\<oplus> d\n  x \\<in> set l\n  y \\<in> set l\n  x \\<noteq> y\n  x = bothNet a\n  y = bothNet b\n  smaller a b l\n  singleCombinators [a]\n  singleCombinators [b]\n\ngoal (1 subgoal):\n 1. \\<not> smaller b a l", "by simp"], ["proof (state)\nthis:\n  \\<not> smaller b a l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smalleraux3a: \n  \"a \\<noteq> DenyAll \\<Longrightarrow> b \\<noteq> DenyAll \\<Longrightarrow> in_list b l \\<Longrightarrow> in_list a l \\<Longrightarrow>  \n   bothNet a \\<noteq> bothNet b \\<Longrightarrow> smaller a b l \\<Longrightarrow> singleCombinators [a] \\<Longrightarrow>\n    singleCombinators [b] \\<Longrightarrow> \\<not> smaller b a l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> DenyAll; b \\<noteq> DenyAll; in_list b l;\n     in_list a l; bothNet a \\<noteq> bothNet b; smaller a b l;\n     singleCombinators [a]; singleCombinators [b]\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller b a l", "apply (rule smalleraux3,simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> DenyAll; b \\<noteq> DenyAll; in_list b l;\n     in_list a l; bothNet a \\<noteq> bothNet b; smaller a b l;\n     singleCombinators [a]; singleCombinators [b]\\<rbrakk>\n    \\<Longrightarrow> bothNet a \\<in> set l\n 2. \\<lbrakk>a \\<noteq> DenyAll; b \\<noteq> DenyAll; in_list b l;\n     in_list a l; bothNet a \\<noteq> bothNet b; smaller a b l;\n     singleCombinators [a]; singleCombinators [b]\\<rbrakk>\n    \\<Longrightarrow> bothNet b \\<in> set l", "apply (case_tac a, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> DenyAll; b \\<noteq> DenyAll; in_list b l;\n     in_list a l; bothNet a \\<noteq> bothNet b; smaller a b l;\n     singleCombinators [a]; singleCombinators [b]\\<rbrakk>\n    \\<Longrightarrow> bothNet b \\<in> set l", "apply (case_tac b, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma posaux[rule_format]: \"position a l < position b l \\<longrightarrow> a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. position a l < position b l \\<longrightarrow> a \\<noteq> b", "by (induct l, simp_all)"], ["", "lemma posaux6[rule_format]: \n  \"a \\<in> set l \\<longrightarrow> b \\<in> set l \\<longrightarrow> a \\<noteq> b \\<longrightarrow> position a l \\<noteq>  position b l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set l \\<longrightarrow>\n    b \\<in> set l \\<longrightarrow>\n    a \\<noteq> b \\<longrightarrow> position a l \\<noteq> position b l", "by (induct l) (simp_all add: position_positive)"], ["", "lemma notSmallerTransaux[rule_format]: \n  \"x \\<noteq> DenyAll \\<Longrightarrow> r \\<noteq> DenyAll \\<Longrightarrow>\n  singleCombinators [x] \\<Longrightarrow>  singleCombinators [y] \\<Longrightarrow>  singleCombinators [r] \\<Longrightarrow>\n  \\<not> smaller y x l \\<Longrightarrow> smaller x y l \\<Longrightarrow> smaller x r l \\<Longrightarrow> smaller y r l \\<Longrightarrow> \n   in_list x l \\<Longrightarrow> in_list y l \\<Longrightarrow> in_list r l \\<Longrightarrow> \\<not> smaller r x l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll; singleCombinators [x];\n     singleCombinators [y]; singleCombinators [r]; \\<not> smaller y x l;\n     smaller x y l; smaller x r l; smaller y r l; in_list x l; in_list y l;\n     in_list r l\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller r x l", "by (metis order_trans)"], ["", "lemma notSmallerTrans[rule_format]: \n  \"x \\<noteq> DenyAll \\<longrightarrow> r \\<noteq> DenyAll \\<longrightarrow> singleCombinators (x#y#z) \\<longrightarrow> \n  \\<not> smaller y x l \\<longrightarrow> sorted (x#y#z) l \\<longrightarrow> r \\<in> set z \\<longrightarrow> \n  all_in_list (x#y#z) l \\<longrightarrow> \\<not> smaller r x l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> DenyAll \\<longrightarrow>\n    r \\<noteq> DenyAll \\<longrightarrow>\n    singleCombinators (x # y # z) \\<longrightarrow>\n    \\<not> smaller y x l \\<longrightarrow>\n    FWNormalisationCore.sorted (x # y # z) l \\<longrightarrow>\n    r \\<in> set z \\<longrightarrow>\n    all_in_list (x # y # z) l \\<longrightarrow> \\<not> smaller r x l", "apply (rule impI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     FWNormalisationCore.sorted (x # y # z) l; r \\<in> set z;\n     all_in_list (x # y # z) l\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller r x l", "apply (rule notSmallerTransaux, simp_all)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators [y]\n 2. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators [r]\n 3. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> smaller x y l\n 4. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> smaller x r l\n 5. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> smaller y r l\n 6. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> in_list y l\n 7. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> in_list r l", "apply (metis singleCombinatorsConc singleCombinatorsStart)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators [r]\n 2. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> smaller x y l\n 3. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> smaller x r l\n 4. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> smaller y r l\n 5. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> in_list y l\n 6. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> in_list r l", "apply (metis SCSubset equalityE remdups.simps(2) set_remdups\n                    singleCombinatorsConc singleCombinatorsStart)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> smaller x y l\n 2. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> smaller x r l\n 3. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> smaller y r l\n 4. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> in_list y l\n 5. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> in_list r l", "apply metis"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> smaller x r l\n 2. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> smaller y r l\n 3. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> in_list y l\n 4. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> in_list r l", "apply (metis sorted.simps(3) in_set_in_list singleCombinatorsConc\n                  singleCombinatorsStart sortedConcStart sorted_is_smaller)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> smaller y r l\n 2. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> in_list y l\n 3. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> in_list r l", "apply (metis sorted_Cons all_in_list.simps(2)\n                 singleCombinatorsConc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> in_list y l\n 2. \\<lbrakk>x \\<noteq> DenyAll; r \\<noteq> DenyAll;\n     singleCombinators (x # y # z); \\<not> smaller y x l;\n     smaller x y l \\<and> FWNormalisationCore.sorted (y # z) l;\n     r \\<in> set z;\n     in_list x l \\<and> in_list y l \\<and> all_in_list z l\\<rbrakk>\n    \\<Longrightarrow> in_list r l", "apply (metis,metis in_set_in_list)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  NCSaux1[rule_format]:\n  \"noDenyAll p \\<longrightarrow> {x, y} \\<in> set l \\<longrightarrow>  all_in_list p l\\<longrightarrow> singleCombinators p \\<longrightarrow> \n  sorted (DenyAllFromTo x y # p) l \\<longrightarrow> {x, y} \\<noteq> firstList p \\<longrightarrow>\n  DenyAllFromTo u v \\<in> set p \\<longrightarrow> {x, y} \\<noteq> {u, v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll p \\<longrightarrow>\n    {x, y} \\<in> set l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    FWNormalisationCore.sorted (DenyAllFromTo x y # p) l \\<longrightarrow>\n    {x, y} \\<noteq> firstList p \\<longrightarrow>\n    DenyAllFromTo u v \\<in> set p \\<longrightarrow> {x, y} \\<noteq> {u, v}", "proof (cases p)"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    noDenyAll p \\<longrightarrow>\n    {x, y} \\<in> set l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    FWNormalisationCore.sorted (DenyAllFromTo x y # p) l \\<longrightarrow>\n    {x, y} \\<noteq> firstList p \\<longrightarrow>\n    DenyAllFromTo u v \\<in> set p \\<longrightarrow> {x, y} \\<noteq> {u, v}\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       noDenyAll p \\<longrightarrow>\n       {x, y} \\<in> set l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (DenyAllFromTo x y # p)\n        l \\<longrightarrow>\n       {x, y} \\<noteq> firstList p \\<longrightarrow>\n       DenyAllFromTo u v \\<in> set p \\<longrightarrow>\n       {x, y} \\<noteq> {u, v}", "case Nil"], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    noDenyAll p \\<longrightarrow>\n    {x, y} \\<in> set l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    FWNormalisationCore.sorted (DenyAllFromTo x y # p) l \\<longrightarrow>\n    {x, y} \\<noteq> firstList p \\<longrightarrow>\n    DenyAllFromTo u v \\<in> set p \\<longrightarrow> {x, y} \\<noteq> {u, v}\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       noDenyAll p \\<longrightarrow>\n       {x, y} \\<in> set l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (DenyAllFromTo x y # p)\n        l \\<longrightarrow>\n       {x, y} \\<noteq> firstList p \\<longrightarrow>\n       DenyAllFromTo u v \\<in> set p \\<longrightarrow>\n       {x, y} \\<noteq> {u, v}", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = []\n\ngoal (1 subgoal):\n 1. noDenyAll p \\<longrightarrow>\n    {x, y} \\<in> set l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    FWNormalisationCore.sorted (DenyAllFromTo x y # p) l \\<longrightarrow>\n    {x, y} \\<noteq> firstList p \\<longrightarrow>\n    DenyAllFromTo u v \\<in> set p \\<longrightarrow> {x, y} \\<noteq> {u, v}", "by simp"], ["proof (state)\nthis:\n  noDenyAll p \\<longrightarrow>\n  {x, y} \\<in> set l \\<longrightarrow>\n  all_in_list p l \\<longrightarrow>\n  singleCombinators p \\<longrightarrow>\n  FWNormalisationCore.sorted (DenyAllFromTo x y # p) l \\<longrightarrow>\n  {x, y} \\<noteq> firstList p \\<longrightarrow>\n  DenyAllFromTo u v \\<in> set p \\<longrightarrow> {x, y} \\<noteq> {u, v}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       noDenyAll p \\<longrightarrow>\n       {x, y} \\<in> set l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (DenyAllFromTo x y # p)\n        l \\<longrightarrow>\n       {x, y} \\<noteq> firstList p \\<longrightarrow>\n       DenyAllFromTo u v \\<in> set p \\<longrightarrow>\n       {x, y} \\<noteq> {u, v}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       noDenyAll p \\<longrightarrow>\n       {x, y} \\<in> set l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (DenyAllFromTo x y # p)\n        l \\<longrightarrow>\n       {x, y} \\<noteq> firstList p \\<longrightarrow>\n       DenyAllFromTo u v \\<in> set p \\<longrightarrow>\n       {x, y} \\<noteq> {u, v}", "case (Cons a list)"], ["proof (state)\nthis:\n  p = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       noDenyAll p \\<longrightarrow>\n       {x, y} \\<in> set l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (DenyAllFromTo x y # p)\n        l \\<longrightarrow>\n       {x, y} \\<noteq> firstList p \\<longrightarrow>\n       DenyAllFromTo u v \\<in> set p \\<longrightarrow>\n       {x, y} \\<noteq> {u, v}", "then"], ["proof (chain)\npicking this:\n  p = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  p = a # list\n\ngoal (1 subgoal):\n 1. noDenyAll p \\<longrightarrow>\n    {x, y} \\<in> set l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    FWNormalisationCore.sorted (DenyAllFromTo x y # p) l \\<longrightarrow>\n    {x, y} \\<noteq> firstList p \\<longrightarrow>\n    DenyAllFromTo u v \\<in> set p \\<longrightarrow> {x, y} \\<noteq> {u, v}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = a # list \\<Longrightarrow>\n    \\<not> member DenyAll a \\<and> noDenyAll list \\<longrightarrow>\n    {x, y} \\<in> set l \\<longrightarrow>\n    in_list a l \\<and> all_in_list list l \\<longrightarrow>\n    singleCombinators (a # list) \\<longrightarrow>\n    smaller (DenyAllFromTo x y) a l \\<and>\n    FWNormalisationCore.sorted (a # list) l \\<longrightarrow>\n    {x, y} \\<noteq> first_bothNet a \\<longrightarrow>\n    (DenyAllFromTo u v = a \\<longrightarrow> {x, y} \\<noteq> {u, v}) \\<and>\n    (DenyAllFromTo u v \\<in> set list \\<longrightarrow>\n     {x, y} \\<noteq> {u, v})", "apply (intro impI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = a # list; \\<not> member DenyAll a \\<and> noDenyAll list;\n     {x, y} \\<in> set l; in_list a l \\<and> all_in_list list l;\n     singleCombinators (a # list);\n     smaller (DenyAllFromTo x y) a l \\<and>\n     FWNormalisationCore.sorted (a # list) l;\n     {x, y} \\<noteq> first_bothNet a; DenyAllFromTo u v = a\\<rbrakk>\n    \\<Longrightarrow> {x, y} \\<noteq> {u, v}\n 2. \\<lbrakk>p = a # list; \\<not> member DenyAll a \\<and> noDenyAll list;\n     {x, y} \\<in> set l; in_list a l \\<and> all_in_list list l;\n     singleCombinators (a # list);\n     smaller (DenyAllFromTo x y) a l \\<and>\n     FWNormalisationCore.sorted (a # list) l;\n     {x, y} \\<noteq> first_bothNet a;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {x, y} \\<noteq> {u, v}", "apply (metis bothNet.simps(2) first_bothNet.simps(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a # list; \\<not> member DenyAll a \\<and> noDenyAll list;\n     {x, y} \\<in> set l; in_list a l \\<and> all_in_list list l;\n     singleCombinators (a # list);\n     smaller (DenyAllFromTo x y) a l \\<and>\n     FWNormalisationCore.sorted (a # list) l;\n     {x, y} \\<noteq> first_bothNet a;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {x, y} \\<noteq> {u, v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a # list; \\<not> member DenyAll a \\<and> noDenyAll list;\n     {x, y} \\<in> set l; in_list a l \\<and> all_in_list list l;\n     singleCombinators (a # list);\n     smaller (DenyAllFromTo x y) a l \\<and>\n     FWNormalisationCore.sorted (a # list) l;\n     {x, y} \\<noteq> first_bothNet a;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {x, y} \\<noteq> {u, v}", "assume 1: \"{x, y} \\<in> set l\" and 2: \"in_list a l \\<and> all_in_list list l\"\n      and 3 : \"singleCombinators (a # list)\"\n      and 4 : \"smaller (DenyAllFromTo x y) a l \\<and> sorted (a # list) l\"\n      and 5 : \"DenyAllFromTo u v \\<in> set list\"\n      and 6 : \"\\<not> member DenyAll a \\<and> noDenyAll list\""], ["proof (state)\nthis:\n  {x, y} \\<in> set l\n  in_list a l \\<and> all_in_list list l\n  singleCombinators (a # list)\n  smaller (DenyAllFromTo x y) a l \\<and>\n  FWNormalisationCore.sorted (a # list) l\n  DenyAllFromTo u v \\<in> set list\n  \\<not> member DenyAll a \\<and> noDenyAll list\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a # list; \\<not> member DenyAll a \\<and> noDenyAll list;\n     {x, y} \\<in> set l; in_list a l \\<and> all_in_list list l;\n     singleCombinators (a # list);\n     smaller (DenyAllFromTo x y) a l \\<and>\n     FWNormalisationCore.sorted (a # list) l;\n     {x, y} \\<noteq> first_bothNet a;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {x, y} \\<noteq> {u, v}", "have * : \"smaller ((DenyAllFromTo x y)::(('a,'b)Combinators)) (DenyAllFromTo u v) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smaller (DenyAllFromTo x y) (DenyAllFromTo u v) l", "apply (insert 1 2 3 4 5, rule_tac y = a in order_trans, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{x, y} \\<in> set l; in_list a l \\<and> all_in_list list l;\n     singleCombinators (a # list);\n     smaller (DenyAllFromTo x y) a l \\<and>\n     FWNormalisationCore.sorted (a # list) l;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {u, v} \\<in> set l\n 2. \\<lbrakk>{x, y} \\<in> set l; in_list a l \\<and> all_in_list list l;\n     singleCombinators (a # list);\n     smaller (DenyAllFromTo x y) a l \\<and>\n     FWNormalisationCore.sorted (a # list) l;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> smaller a (DenyAllFromTo u v) l", "using in_set_in_list"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> set ?p; all_in_list ?p ?l\\<rbrakk>\n  \\<Longrightarrow> in_list ?a ?l\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{x, y} \\<in> set l; in_list a l \\<and> all_in_list list l;\n     singleCombinators (a # list);\n     smaller (DenyAllFromTo x y) a l \\<and>\n     FWNormalisationCore.sorted (a # list) l;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {u, v} \\<in> set l\n 2. \\<lbrakk>{x, y} \\<in> set l; in_list a l \\<and> all_in_list list l;\n     singleCombinators (a # list);\n     smaller (DenyAllFromTo x y) a l \\<and>\n     FWNormalisationCore.sorted (a # list) l;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> smaller a (DenyAllFromTo u v) l", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<in> set l; in_list a l \\<and> all_in_list list l;\n     singleCombinators (a # list);\n     smaller (DenyAllFromTo x y) a l \\<and>\n     FWNormalisationCore.sorted (a # list) l;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> smaller a (DenyAllFromTo u v) l", "by (simp add: sorted_ConsA)"], ["proof (state)\nthis:\n  smaller (DenyAllFromTo x y) (DenyAllFromTo u v) l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a # list; \\<not> member DenyAll a \\<and> noDenyAll list;\n     {x, y} \\<in> set l; in_list a l \\<and> all_in_list list l;\n     singleCombinators (a # list);\n     smaller (DenyAllFromTo x y) a l \\<and>\n     FWNormalisationCore.sorted (a # list) l;\n     {x, y} \\<noteq> first_bothNet a;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {x, y} \\<noteq> {u, v}", "have ** :\"{x, y} \\<noteq> first_bothNet a \\<Longrightarrow>  \n                       \\<not> smaller ((DenyAllFromTo u v)::('a, 'b) Combinators) (DenyAllFromTo x y) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} \\<noteq> first_bothNet a \\<Longrightarrow>\n    \\<not> smaller (DenyAllFromTo u v) (DenyAllFromTo x y) l", "apply (insert 1 2 3 4 5 6, \n          rule_tac y = \"a\" and z = \"list\"  in  notSmallerTrans, \n          simp_all del: smaller.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<noteq> first_bothNet a; {x, y} \\<in> set l;\n     in_list a l \\<and> all_in_list list l; singleCombinators (a # list);\n     smaller (DenyAllFromTo x y) a l \\<and>\n     FWNormalisationCore.sorted (a # list) l;\n     DenyAllFromTo u v \\<in> set list;\n     \\<not> member DenyAll a \\<and> noDenyAll list\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller a (DenyAllFromTo x y) l", "apply (rule smalleraux3a,simp_all del: smaller.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{x, y} \\<noteq> first_bothNet a; {x, y} \\<in> set l;\n     in_list a l \\<and> all_in_list list l; singleCombinators (a # list);\n     smaller (DenyAllFromTo x y) a l \\<and>\n     FWNormalisationCore.sorted (a # list) l;\n     DenyAllFromTo u v \\<in> set list;\n     \\<not> member DenyAll a \\<and> noDenyAll list\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> DenyAll\n 2. \\<lbrakk>{x, y} \\<noteq> first_bothNet a; {x, y} \\<in> set l;\n     in_list a l \\<and> all_in_list list l; singleCombinators (a # list);\n     smaller (DenyAllFromTo x y) a l \\<and>\n     FWNormalisationCore.sorted (a # list) l;\n     DenyAllFromTo u v \\<in> set list;\n     \\<not> member DenyAll a \\<and> noDenyAll list\\<rbrakk>\n    \\<Longrightarrow> {x, y} \\<noteq> bothNet a", "apply (case_tac a, simp_all del: smaller.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{x, y} \\<noteq> first_bothNet a; {x, y} \\<in> set l;\n     in_list a l \\<and> all_in_list list l; singleCombinators (a # list);\n     smaller (DenyAllFromTo x y) a l \\<and>\n     FWNormalisationCore.sorted (a # list) l;\n     DenyAllFromTo u v \\<in> set list;\n     \\<not> member DenyAll a \\<and> noDenyAll list\\<rbrakk>\n    \\<Longrightarrow> {x, y} \\<noteq> bothNet a", "by (metis aux0_0 first_bothNet.elims list.set_intros(1))"], ["proof (state)\nthis:\n  {x, y} \\<noteq> first_bothNet a \\<Longrightarrow>\n  \\<not> smaller (DenyAllFromTo u v) (DenyAllFromTo x y) l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a # list; \\<not> member DenyAll a \\<and> noDenyAll list;\n     {x, y} \\<in> set l; in_list a l \\<and> all_in_list list l;\n     singleCombinators (a # list);\n     smaller (DenyAllFromTo x y) a l \\<and>\n     FWNormalisationCore.sorted (a # list) l;\n     {x, y} \\<noteq> first_bothNet a;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {x, y} \\<noteq> {u, v}", "show \" {x, y} \\<noteq> first_bothNet a \\<Longrightarrow>  {x, y} \\<noteq> {u, v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} \\<noteq> first_bothNet a \\<Longrightarrow> {x, y} \\<noteq> {u, v}", "using  3  \"*\" \"**\""], ["proof (prove)\nusing this:\n  singleCombinators (a # list)\n  smaller (DenyAllFromTo x y) (DenyAllFromTo u v) l\n  {x, y} \\<noteq> first_bothNet a \\<Longrightarrow>\n  \\<not> smaller (DenyAllFromTo u v) (DenyAllFromTo x y) l\n\ngoal (1 subgoal):\n 1. {x, y} \\<noteq> first_bothNet a \\<Longrightarrow> {x, y} \\<noteq> {u, v}", "by force"], ["proof (state)\nthis:\n  {x, y} \\<noteq> first_bothNet a \\<Longrightarrow> {x, y} \\<noteq> {u, v}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  noDenyAll p \\<longrightarrow>\n  {x, y} \\<in> set l \\<longrightarrow>\n  all_in_list p l \\<longrightarrow>\n  singleCombinators p \\<longrightarrow>\n  FWNormalisationCore.sorted (DenyAllFromTo x y # p) l \\<longrightarrow>\n  {x, y} \\<noteq> firstList p \\<longrightarrow>\n  DenyAllFromTo u v \\<in> set p \\<longrightarrow> {x, y} \\<noteq> {u, v}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma posaux3[rule_format]:\"a \\<in> set l \\<longrightarrow> b \\<in> set l \\<longrightarrow> a \\<noteq> b \\<longrightarrow> position a l \\<noteq> position b l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set l \\<longrightarrow>\n    b \\<in> set l \\<longrightarrow>\n    a \\<noteq> b \\<longrightarrow> position a l \\<noteq> position b l", "apply (induct l, auto)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>a \\<notin> set l; b \\<noteq> a; b \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> 0 < position b l\n 2. \\<And>l.\n       \\<lbrakk>b \\<notin> set l; a \\<noteq> b; a \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> 0 < position a l\n 3. \\<And>l.\n       \\<lbrakk>position a l \\<noteq> position b l; b \\<noteq> a;\n        b \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> 0 < position b l\n 4. \\<And>l.\n       \\<lbrakk>position a l \\<noteq> position b l; b \\<noteq> a;\n        a \\<in> set l; b \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> 0 < position b l\n 5. \\<And>l.\n       \\<lbrakk>position a l \\<noteq> position b l; a \\<noteq> b;\n        a \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> 0 < position a l\n 6. \\<And>l.\n       \\<lbrakk>position a l \\<noteq> position b l; a \\<noteq> b;\n        a \\<in> set l; b \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> 0 < position a l", "by(metis position_positive)+"], ["", "lemma posaux4[rule_format]: \n  \"singleCombinators [a] \\<longrightarrow> a\\<noteq> DenyAll \\<longrightarrow> b \\<noteq> DenyAll \\<longrightarrow> in_list a l \\<longrightarrow>in_list b l \\<longrightarrow>\n    smaller a b  l\\<longrightarrow> x = (bothNet a) \\<longrightarrow>  y = (bothNet b) \\<longrightarrow> \n    position x l <= position y l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "proof (cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. a = DenyAll \\<Longrightarrow>\n    singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n 2. \\<And>x21 x22.\n       a = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n 3. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n 4. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "case DenyAll"], ["proof (state)\nthis:\n  a = DenyAll\n\ngoal (4 subgoals):\n 1. a = DenyAll \\<Longrightarrow>\n    singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n 2. \\<And>x21 x22.\n       a = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n 3. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n 4. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "then"], ["proof (chain)\npicking this:\n  a = DenyAll", "show ?thesis"], ["proof (prove)\nusing this:\n  a = DenyAll\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "by simp"], ["proof (state)\nthis:\n  singleCombinators [a] \\<longrightarrow>\n  a \\<noteq> DenyAll \\<longrightarrow>\n  b \\<noteq> DenyAll \\<longrightarrow>\n  in_list a l \\<longrightarrow>\n  in_list b l \\<longrightarrow>\n  smaller a b l \\<longrightarrow>\n  x = bothNet a \\<longrightarrow>\n  y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       a = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n 2. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n 3. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       a = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n 2. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n 3. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "case (DenyAllFromTo c d)"], ["proof (state)\nthis:\n  a = DenyAllFromTo c d\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       a = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n 2. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n 3. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = DenyAllFromTo c d\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "proof (cases b)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>a = DenyAllFromTo c d; b = DenyAll\\<rbrakk>\n    \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                      a \\<noteq> DenyAll \\<longrightarrow>\n                      b \\<noteq> DenyAll \\<longrightarrow>\n                      in_list a l \\<longrightarrow>\n                      in_list b l \\<longrightarrow>\n                      smaller a b l \\<longrightarrow>\n                      x = bothNet a \\<longrightarrow>\n                      y = bothNet b \\<longrightarrow>\n                      position x l \\<le> position y l\n 2. \\<And>x21 x22.\n       \\<lbrakk>a = DenyAllFromTo c d; b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 4. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "case DenyAll"], ["proof (state)\nthis:\n  b = DenyAll\n\ngoal (4 subgoals):\n 1. \\<lbrakk>a = DenyAllFromTo c d; b = DenyAll\\<rbrakk>\n    \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                      a \\<noteq> DenyAll \\<longrightarrow>\n                      b \\<noteq> DenyAll \\<longrightarrow>\n                      in_list a l \\<longrightarrow>\n                      in_list b l \\<longrightarrow>\n                      smaller a b l \\<longrightarrow>\n                      x = bothNet a \\<longrightarrow>\n                      y = bothNet b \\<longrightarrow>\n                      position x l \\<le> position y l\n 2. \\<And>x21 x22.\n       \\<lbrakk>a = DenyAllFromTo c d; b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 4. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = DenyAll\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "by simp"], ["proof (state)\nthis:\n  singleCombinators [a] \\<longrightarrow>\n  a \\<noteq> DenyAll \\<longrightarrow>\n  b \\<noteq> DenyAll \\<longrightarrow>\n  in_list a l \\<longrightarrow>\n  in_list b l \\<longrightarrow>\n  smaller a b l \\<longrightarrow>\n  x = bothNet a \\<longrightarrow>\n  y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>a = DenyAllFromTo c d; b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 3. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>a = DenyAllFromTo c d; b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 3. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "case (DenyAllFromTo e f)"], ["proof (state)\nthis:\n  b = DenyAllFromTo e f\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>a = DenyAllFromTo c d; b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 3. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = DenyAllFromTo e f\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "using  DenyAllFromTo"], ["proof (prove)\nusing this:\n  b = DenyAllFromTo e f\n  b = DenyAllFromTo e f\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "by (auto simp: eq_imp_le  \\<open>a = DenyAllFromTo c d\\<close>)"], ["proof (state)\nthis:\n  singleCombinators [a] \\<longrightarrow>\n  a \\<noteq> DenyAll \\<longrightarrow>\n  b \\<noteq> DenyAll \\<longrightarrow>\n  in_list a l \\<longrightarrow>\n  in_list b l \\<longrightarrow>\n  smaller a b l \\<longrightarrow>\n  x = bothNet a \\<longrightarrow>\n  y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 2. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 2. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "case (AllowPortFromTo e f p)"], ["proof (state)\nthis:\n  b = AllowPortFromTo e f p\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 2. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = AllowPortFromTo e f p\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "using \\<open>a = DenyAllFromTo c d\\<close>"], ["proof (prove)\nusing this:\n  b = AllowPortFromTo e f p\n  a = DenyAllFromTo c d\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "by simp"], ["proof (state)\nthis:\n  singleCombinators [a] \\<longrightarrow>\n  a \\<noteq> DenyAll \\<longrightarrow>\n  b \\<noteq> DenyAll \\<longrightarrow>\n  in_list a l \\<longrightarrow>\n  in_list b l \\<longrightarrow>\n  smaller a b l \\<longrightarrow>\n  x = bothNet a \\<longrightarrow>\n  y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "case (Conc e f)"], ["proof (state)\nthis:\n  b = e \\<oplus> f\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>a = DenyAllFromTo c d; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = e \\<oplus> f\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "using Conc \\<open>a = DenyAllFromTo c d\\<close>"], ["proof (prove)\nusing this:\n  b = e \\<oplus> f\n  b = e \\<oplus> f\n  a = DenyAllFromTo c d\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "by simp"], ["proof (state)\nthis:\n  singleCombinators [a] \\<longrightarrow>\n  a \\<noteq> DenyAll \\<longrightarrow>\n  b \\<noteq> DenyAll \\<longrightarrow>\n  in_list a l \\<longrightarrow>\n  in_list b l \\<longrightarrow>\n  smaller a b l \\<longrightarrow>\n  x = bothNet a \\<longrightarrow>\n  y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  singleCombinators [a] \\<longrightarrow>\n  a \\<noteq> DenyAll \\<longrightarrow>\n  b \\<noteq> DenyAll \\<longrightarrow>\n  in_list a l \\<longrightarrow>\n  in_list b l \\<longrightarrow>\n  smaller a b l \\<longrightarrow>\n  x = bothNet a \\<longrightarrow>\n  y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n 2. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n 2. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "case (AllowPortFromTo c d p)"], ["proof (state)\nthis:\n  a = AllowPortFromTo c d p\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       a = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n 2. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = AllowPortFromTo c d p\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "proof (cases b)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>a = AllowPortFromTo c d p; b = DenyAll\\<rbrakk>\n    \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                      a \\<noteq> DenyAll \\<longrightarrow>\n                      b \\<noteq> DenyAll \\<longrightarrow>\n                      in_list a l \\<longrightarrow>\n                      in_list b l \\<longrightarrow>\n                      smaller a b l \\<longrightarrow>\n                      x = bothNet a \\<longrightarrow>\n                      y = bothNet b \\<longrightarrow>\n                      position x l \\<le> position y l\n 2. \\<And>x21 x22.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 4. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "case DenyAll"], ["proof (state)\nthis:\n  b = DenyAll\n\ngoal (4 subgoals):\n 1. \\<lbrakk>a = AllowPortFromTo c d p; b = DenyAll\\<rbrakk>\n    \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                      a \\<noteq> DenyAll \\<longrightarrow>\n                      b \\<noteq> DenyAll \\<longrightarrow>\n                      in_list a l \\<longrightarrow>\n                      in_list b l \\<longrightarrow>\n                      smaller a b l \\<longrightarrow>\n                      x = bothNet a \\<longrightarrow>\n                      y = bothNet b \\<longrightarrow>\n                      position x l \\<le> position y l\n 2. \\<And>x21 x22.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 4. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = DenyAll\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "by simp"], ["proof (state)\nthis:\n  singleCombinators [a] \\<longrightarrow>\n  a \\<noteq> DenyAll \\<longrightarrow>\n  b \\<noteq> DenyAll \\<longrightarrow>\n  in_list a l \\<longrightarrow>\n  in_list b l \\<longrightarrow>\n  smaller a b l \\<longrightarrow>\n  x = bothNet a \\<longrightarrow>\n  y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 3. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 3. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "case (DenyAllFromTo e f)"], ["proof (state)\nthis:\n  b = DenyAllFromTo e f\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 3. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = DenyAllFromTo e f\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "using AllowPortFromTo"], ["proof (prove)\nusing this:\n  b = DenyAllFromTo e f\n  a = AllowPortFromTo c d p\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "by simp"], ["proof (state)\nthis:\n  singleCombinators [a] \\<longrightarrow>\n  a \\<noteq> DenyAll \\<longrightarrow>\n  b \\<noteq> DenyAll \\<longrightarrow>\n  in_list a l \\<longrightarrow>\n  in_list b l \\<longrightarrow>\n  smaller a b l \\<longrightarrow>\n  x = bothNet a \\<longrightarrow>\n  y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 2. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 2. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "case (AllowPortFromTo e f p2)"], ["proof (state)\nthis:\n  b = AllowPortFromTo e f p2\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>a = AllowPortFromTo c d p;\n        b = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l\n 2. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = AllowPortFromTo e f p2\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "using \\<open>a = AllowPortFromTo c d p\\<close>"], ["proof (prove)\nusing this:\n  b = AllowPortFromTo e f p2\n  a = AllowPortFromTo c d p\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "by simp"], ["proof (state)\nthis:\n  singleCombinators [a] \\<longrightarrow>\n  a \\<noteq> DenyAll \\<longrightarrow>\n  b \\<noteq> DenyAll \\<longrightarrow>\n  in_list a l \\<longrightarrow>\n  in_list b l \\<longrightarrow>\n  smaller a b l \\<longrightarrow>\n  x = bothNet a \\<longrightarrow>\n  y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "case (Conc e f)"], ["proof (state)\nthis:\n  b = e \\<oplus> f\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>a = AllowPortFromTo c d p; b = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> singleCombinators [a] \\<longrightarrow>\n                         a \\<noteq> DenyAll \\<longrightarrow>\n                         b \\<noteq> DenyAll \\<longrightarrow>\n                         in_list a l \\<longrightarrow>\n                         in_list b l \\<longrightarrow>\n                         smaller a b l \\<longrightarrow>\n                         x = bothNet a \\<longrightarrow>\n                         y = bothNet b \\<longrightarrow>\n                         position x l \\<le> position y l", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = e \\<oplus> f\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "using AllowPortFromTo"], ["proof (prove)\nusing this:\n  b = e \\<oplus> f\n  a = AllowPortFromTo c d p\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "by simp"], ["proof (state)\nthis:\n  singleCombinators [a] \\<longrightarrow>\n  a \\<noteq> DenyAll \\<longrightarrow>\n  b \\<noteq> DenyAll \\<longrightarrow>\n  in_list a l \\<longrightarrow>\n  in_list b l \\<longrightarrow>\n  smaller a b l \\<longrightarrow>\n  x = bothNet a \\<longrightarrow>\n  y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  singleCombinators [a] \\<longrightarrow>\n  a \\<noteq> DenyAll \\<longrightarrow>\n  b \\<noteq> DenyAll \\<longrightarrow>\n  in_list a l \\<longrightarrow>\n  in_list b l \\<longrightarrow>\n  smaller a b l \\<longrightarrow>\n  x = bothNet a \\<longrightarrow>\n  y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "case (Conc c d)"], ["proof (state)\nthis:\n  a = c \\<oplus> d\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       a = x41 \\<oplus> x42 \\<Longrightarrow>\n       singleCombinators [a] \\<longrightarrow>\n       a \\<noteq> DenyAll \\<longrightarrow>\n       b \\<noteq> DenyAll \\<longrightarrow>\n       in_list a l \\<longrightarrow>\n       in_list b l \\<longrightarrow>\n       smaller a b l \\<longrightarrow>\n       x = bothNet a \\<longrightarrow>\n       y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = c \\<oplus> d\n\ngoal (1 subgoal):\n 1. singleCombinators [a] \\<longrightarrow>\n    a \\<noteq> DenyAll \\<longrightarrow>\n    b \\<noteq> DenyAll \\<longrightarrow>\n    in_list a l \\<longrightarrow>\n    in_list b l \\<longrightarrow>\n    smaller a b l \\<longrightarrow>\n    x = bothNet a \\<longrightarrow>\n    y = bothNet b \\<longrightarrow> position x l \\<le> position y l", "by simp"], ["proof (state)\nthis:\n  singleCombinators [a] \\<longrightarrow>\n  a \\<noteq> DenyAll \\<longrightarrow>\n  b \\<noteq> DenyAll \\<longrightarrow>\n  in_list a l \\<longrightarrow>\n  in_list b l \\<longrightarrow>\n  smaller a b l \\<longrightarrow>\n  x = bothNet a \\<longrightarrow>\n  y = bothNet b \\<longrightarrow> position x l \\<le> position y l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  NCSaux2[rule_format]:\n  \"noDenyAll p \\<longrightarrow> {a, b} \\<in> set l \\<longrightarrow> all_in_list p l \\<longrightarrow>singleCombinators p \\<longrightarrow>\n   sorted (DenyAllFromTo a b # p) l \\<longrightarrow> {a, b} \\<noteq> firstList p \\<longrightarrow>\n   AllowPortFromTo u v w \\<in> set p \\<longrightarrow>  {a, b} \\<noteq> {u, v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll p \\<longrightarrow>\n    {a, b} \\<in> set l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    FWNormalisationCore.sorted (DenyAllFromTo a b # p) l \\<longrightarrow>\n    {a, b} \\<noteq> firstList p \\<longrightarrow>\n    AllowPortFromTo u v w \\<in> set p \\<longrightarrow>\n    {a, b} \\<noteq> {u, v}", "proof (cases p)"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    noDenyAll p \\<longrightarrow>\n    {a, b} \\<in> set l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    FWNormalisationCore.sorted (DenyAllFromTo a b # p) l \\<longrightarrow>\n    {a, b} \\<noteq> firstList p \\<longrightarrow>\n    AllowPortFromTo u v w \\<in> set p \\<longrightarrow>\n    {a, b} \\<noteq> {u, v}\n 2. \\<And>aa list.\n       p = aa # list \\<Longrightarrow>\n       noDenyAll p \\<longrightarrow>\n       {a, b} \\<in> set l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (DenyAllFromTo a b # p)\n        l \\<longrightarrow>\n       {a, b} \\<noteq> firstList p \\<longrightarrow>\n       AllowPortFromTo u v w \\<in> set p \\<longrightarrow>\n       {a, b} \\<noteq> {u, v}", "case Nil"], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    noDenyAll p \\<longrightarrow>\n    {a, b} \\<in> set l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    FWNormalisationCore.sorted (DenyAllFromTo a b # p) l \\<longrightarrow>\n    {a, b} \\<noteq> firstList p \\<longrightarrow>\n    AllowPortFromTo u v w \\<in> set p \\<longrightarrow>\n    {a, b} \\<noteq> {u, v}\n 2. \\<And>aa list.\n       p = aa # list \\<Longrightarrow>\n       noDenyAll p \\<longrightarrow>\n       {a, b} \\<in> set l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (DenyAllFromTo a b # p)\n        l \\<longrightarrow>\n       {a, b} \\<noteq> firstList p \\<longrightarrow>\n       AllowPortFromTo u v w \\<in> set p \\<longrightarrow>\n       {a, b} \\<noteq> {u, v}", "then"], ["proof (chain)\npicking this:\n  p = []", "show ?thesis"], ["proof (prove)\nusing this:\n  p = []\n\ngoal (1 subgoal):\n 1. noDenyAll p \\<longrightarrow>\n    {a, b} \\<in> set l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    FWNormalisationCore.sorted (DenyAllFromTo a b # p) l \\<longrightarrow>\n    {a, b} \\<noteq> firstList p \\<longrightarrow>\n    AllowPortFromTo u v w \\<in> set p \\<longrightarrow>\n    {a, b} \\<noteq> {u, v}", "by simp"], ["proof (state)\nthis:\n  noDenyAll p \\<longrightarrow>\n  {a, b} \\<in> set l \\<longrightarrow>\n  all_in_list p l \\<longrightarrow>\n  singleCombinators p \\<longrightarrow>\n  FWNormalisationCore.sorted (DenyAllFromTo a b # p) l \\<longrightarrow>\n  {a, b} \\<noteq> firstList p \\<longrightarrow>\n  AllowPortFromTo u v w \\<in> set p \\<longrightarrow> {a, b} \\<noteq> {u, v}\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       p = aa # list \\<Longrightarrow>\n       noDenyAll p \\<longrightarrow>\n       {a, b} \\<in> set l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (DenyAllFromTo a b # p)\n        l \\<longrightarrow>\n       {a, b} \\<noteq> firstList p \\<longrightarrow>\n       AllowPortFromTo u v w \\<in> set p \\<longrightarrow>\n       {a, b} \\<noteq> {u, v}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       p = aa # list \\<Longrightarrow>\n       noDenyAll p \\<longrightarrow>\n       {a, b} \\<in> set l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (DenyAllFromTo a b # p)\n        l \\<longrightarrow>\n       {a, b} \\<noteq> firstList p \\<longrightarrow>\n       AllowPortFromTo u v w \\<in> set p \\<longrightarrow>\n       {a, b} \\<noteq> {u, v}", "case (Cons aa list)"], ["proof (state)\nthis:\n  p = aa # list\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       p = aa # list \\<Longrightarrow>\n       noDenyAll p \\<longrightarrow>\n       {a, b} \\<in> set l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (DenyAllFromTo a b # p)\n        l \\<longrightarrow>\n       {a, b} \\<noteq> firstList p \\<longrightarrow>\n       AllowPortFromTo u v w \\<in> set p \\<longrightarrow>\n       {a, b} \\<noteq> {u, v}", "have *  : \"{a, b} \\<in> set l \\<Longrightarrow>  in_list aa l \\<and> all_in_list list l \\<Longrightarrow>\n                   singleCombinators (aa # list) \\<Longrightarrow>  AllowPortFromTo u v w \\<in> set list \\<Longrightarrow> \n                   smaller (DenyAllFromTo a b) aa l \\<and> sorted (aa # list) l \\<Longrightarrow>\n                   smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list); AllowPortFromTo u v w \\<in> set list;\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l", "apply (rule_tac y = aa in order_trans,simp_all del: smaller.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list); AllowPortFromTo u v w \\<in> set list;\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> {u, v} \\<in> set l\n 2. \\<lbrakk>{a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list); AllowPortFromTo u v w \\<in> set list;\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> smaller aa (AllowPortFromTo u v w) l", "using in_set_in_list"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> set ?p; all_in_list ?p ?l\\<rbrakk>\n  \\<Longrightarrow> in_list ?a ?l\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list); AllowPortFromTo u v w \\<in> set list;\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> {u, v} \\<in> set l\n 2. \\<lbrakk>{a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list); AllowPortFromTo u v w \\<in> set list;\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> smaller aa (AllowPortFromTo u v w) l", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list); AllowPortFromTo u v w \\<in> set list;\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> smaller aa (AllowPortFromTo u v w) l", "using NormalisationGenericProofs.sorted_Cons all_in_list.simps(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>all_in_list (?x # ?xs) ?l; singleCombinators (?x # ?xs)\\<rbrakk>\n  \\<Longrightarrow> (FWNormalisationCore.sorted ?xs ?l \\<and>\n                     (\\<forall>y\\<in>set ?xs. smaller ?x y ?l)) =\n                    FWNormalisationCore.sorted (?x # ?xs) ?l\n  all_in_list (?x # ?xs) ?l = (in_list ?x ?l \\<and> all_in_list ?xs ?l)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list); AllowPortFromTo u v w \\<in> set list;\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> smaller aa (AllowPortFromTo u v w) l", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>{a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n   singleCombinators (aa # list); AllowPortFromTo u v w \\<in> set list;\n   smaller (DenyAllFromTo a b) aa l \\<and>\n   FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n  \\<Longrightarrow> smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       p = aa # list \\<Longrightarrow>\n       noDenyAll p \\<longrightarrow>\n       {a, b} \\<in> set l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (DenyAllFromTo a b # p)\n        l \\<longrightarrow>\n       {a, b} \\<noteq> firstList p \\<longrightarrow>\n       AllowPortFromTo u v w \\<in> set p \\<longrightarrow>\n       {a, b} \\<noteq> {u, v}", "have **: \"AllowPortFromTo u v w \\<in> set list \\<Longrightarrow>\n                    in_list aa l \\<Longrightarrow>   all_in_list list l \\<Longrightarrow> \n                    in_list (AllowPortFromTo u v w) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo u v w \\<in> set list; in_list aa l;\n     all_in_list list l\\<rbrakk>\n    \\<Longrightarrow> in_list (AllowPortFromTo u v w) l", "apply (rule_tac p = list in in_set_in_list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>AllowPortFromTo u v w \\<in> set list; in_list aa l;\n     all_in_list list l\\<rbrakk>\n    \\<Longrightarrow> AllowPortFromTo u v w \\<in> set list\n 2. \\<lbrakk>AllowPortFromTo u v w \\<in> set list; in_list aa l;\n     all_in_list list l\\<rbrakk>\n    \\<Longrightarrow> all_in_list list l", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>AllowPortFromTo u v w \\<in> set list; in_list aa l;\n   all_in_list list l\\<rbrakk>\n  \\<Longrightarrow> in_list (AllowPortFromTo u v w) l\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       p = aa # list \\<Longrightarrow>\n       noDenyAll p \\<longrightarrow>\n       {a, b} \\<in> set l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (DenyAllFromTo a b # p)\n        l \\<longrightarrow>\n       {a, b} \\<noteq> firstList p \\<longrightarrow>\n       AllowPortFromTo u v w \\<in> set p \\<longrightarrow>\n       {a, b} \\<noteq> {u, v}", "assume  \"p = aa # list\""], ["proof (state)\nthis:\n  p = aa # list\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       p = aa # list \\<Longrightarrow>\n       noDenyAll p \\<longrightarrow>\n       {a, b} \\<in> set l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted (DenyAllFromTo a b # p)\n        l \\<longrightarrow>\n       {a, b} \\<noteq> firstList p \\<longrightarrow>\n       AllowPortFromTo u v w \\<in> set p \\<longrightarrow>\n       {a, b} \\<noteq> {u, v}", "then"], ["proof (chain)\npicking this:\n  p = aa # list", "show ?thesis"], ["proof (prove)\nusing this:\n  p = aa # list\n\ngoal (1 subgoal):\n 1. noDenyAll p \\<longrightarrow>\n    {a, b} \\<in> set l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    FWNormalisationCore.sorted (DenyAllFromTo a b # p) l \\<longrightarrow>\n    {a, b} \\<noteq> firstList p \\<longrightarrow>\n    AllowPortFromTo u v w \\<in> set p \\<longrightarrow>\n    {a, b} \\<noteq> {u, v}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = aa # list \\<Longrightarrow>\n    \\<not> member DenyAll aa \\<and> noDenyAll list \\<longrightarrow>\n    {a, b} \\<in> set l \\<longrightarrow>\n    in_list aa l \\<and> all_in_list list l \\<longrightarrow>\n    singleCombinators (aa # list) \\<longrightarrow>\n    smaller (DenyAllFromTo a b) aa l \\<and>\n    FWNormalisationCore.sorted (aa # list) l \\<longrightarrow>\n    {a, b} \\<noteq> first_bothNet aa \\<longrightarrow>\n    (AllowPortFromTo u v w = aa \\<longrightarrow>\n     {a, b} \\<noteq> {u, v}) \\<and>\n    (AllowPortFromTo u v w \\<in> set list \\<longrightarrow>\n     {a, b} \\<noteq> {u, v})", "apply (intro impI conjI,hypsubst, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v}", "apply (subgoal_tac \"smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v}\n 2. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l", "apply (subgoal_tac \"\\<not> smaller (AllowPortFromTo u v w) (DenyAllFromTo a b) l\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l;\n     \\<not> smaller (AllowPortFromTo u v w) (DenyAllFromTo a b) l\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v}\n 2. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller (AllowPortFromTo u v w)\n                              (DenyAllFromTo a b) l\n 3. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l", "apply (rule_tac l = l in posaux)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l;\n     \\<not> smaller (AllowPortFromTo u v w) (DenyAllFromTo a b) l\\<rbrakk>\n    \\<Longrightarrow> position {a, b} l < position {u, v} l\n 2. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller (AllowPortFromTo u v w)\n                              (DenyAllFromTo a b) l\n 3. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l", "apply (rule_tac y = \"position (first_bothNet aa) l\" in basic_trans_rules(22))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l;\n     \\<not> smaller (AllowPortFromTo u v w) (DenyAllFromTo a b) l\\<rbrakk>\n    \\<Longrightarrow> position {a, b} l < position (first_bothNet aa) l\n 2. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l;\n     \\<not> smaller (AllowPortFromTo u v w) (DenyAllFromTo a b) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 3. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller (AllowPortFromTo u v w)\n                              (DenyAllFromTo a b) l\n 4. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l", "apply (simp_all split: if_splits)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l < position (first_bothNet aa) l\n 2. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position {a, b} l < position (first_bothNet aa) l\n 3. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 4. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 5. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 6. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (case_tac aa, simp_all)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>p = DenyAllFromTo x21 x22 # list; {u, v} \\<in> set l;\n        singleCombinators list; {u, v} \\<noteq> {x21, x22};\n        AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n        noDenyAll list; {x21, x22} \\<in> set l; all_in_list list l;\n        a = x21 \\<and> b = x22 \\<or>\n        position {u, v} l \\<le> position {x21, x22} l;\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # list) l;\n        aa = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> position {u, v} l < position {x21, x22} l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>p = AllowPortFromTo x31 x32 x33 # list; {u, v} \\<in> set l;\n        singleCombinators list; {u, v} \\<noteq> {x31, x32};\n        AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n        noDenyAll list; {x31, x32} \\<in> set l; all_in_list list l;\n        position {u, v} l \\<le> position {x31, x32} l;\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> position {u, v} l < position {x31, x32} l\n 3. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position {a, b} l < position (first_bothNet aa) l\n 4. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 5. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 6. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 7. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "subgoal for x x'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = DenyAllFromTo x x' # list; {u, v} \\<in> set l;\n     singleCombinators list; {u, v} \\<noteq> {x, x'};\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v}; noDenyAll list;\n     {x, x'} \\<in> set l; all_in_list list l;\n     a = x \\<and> b = x' \\<or> position {u, v} l \\<le> position {x, x'} l;\n     FWNormalisationCore.sorted (DenyAllFromTo x x' # list) l;\n     aa = DenyAllFromTo x x'\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l < position {x, x'} l", "apply (case_tac \"a = x \\<and> b = x'\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = DenyAllFromTo x x' # list; {u, v} \\<in> set l;\n     singleCombinators list; {u, v} \\<noteq> {x, x'};\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v}; noDenyAll list;\n     {x, x'} \\<in> set l; all_in_list list l;\n     position {u, v} l \\<le> position {x, x'} l;\n     FWNormalisationCore.sorted (DenyAllFromTo x x' # list) l;\n     aa = DenyAllFromTo x x'; a = x \\<longrightarrow> b \\<noteq> x'\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l < position {x, x'} l", "apply (case_tac \"a = x\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = DenyAllFromTo x x' # list; {u, v} \\<in> set l;\n     singleCombinators list; {u, v} \\<noteq> {x, x'};\n     AllowPortFromTo u v w \\<in> set list; {x, b} = {u, v}; noDenyAll list;\n     {x, x'} \\<in> set l; all_in_list list l;\n     position {u, v} l \\<le> position {x, x'} l;\n     FWNormalisationCore.sorted (DenyAllFromTo x x' # list) l;\n     aa = DenyAllFromTo x x'; b \\<noteq> x'; a = x\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l < position {x, x'} l\n 2. \\<lbrakk>p = DenyAllFromTo x x' # list; {u, v} \\<in> set l;\n     singleCombinators list; {u, v} \\<noteq> {x, x'};\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v}; noDenyAll list;\n     {x, x'} \\<in> set l; all_in_list list l;\n     position {u, v} l \\<le> position {x, x'} l;\n     FWNormalisationCore.sorted (DenyAllFromTo x x' # list) l;\n     aa = DenyAllFromTo x x'; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l < position {x, x'} l", "apply (simp add: order.not_eq_order_implies_strict posaux6)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = DenyAllFromTo x x' # list; {u, v} \\<in> set l;\n     singleCombinators list; {u, v} \\<noteq> {x, x'};\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v}; noDenyAll list;\n     {x, x'} \\<in> set l; all_in_list list l;\n     position {u, v} l \\<le> position {x, x'} l;\n     FWNormalisationCore.sorted (DenyAllFromTo x x' # list) l;\n     aa = DenyAllFromTo x x'; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l < position {x, x'} l", "apply (simp add: order.not_eq_order_implies_strict posaux6)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>p = AllowPortFromTo x31 x32 x33 # list; {u, v} \\<in> set l;\n        singleCombinators list; {u, v} \\<noteq> {x31, x32};\n        AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n        noDenyAll list; {x31, x32} \\<in> set l; all_in_list list l;\n        position {u, v} l \\<le> position {x31, x32} l;\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> position {u, v} l < position {x31, x32} l\n 2. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position {a, b} l < position (first_bothNet aa) l\n 3. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 4. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 5. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 6. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (simp add: order.not_eq_order_implies_strict posaux6)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position {a, b} l < position (first_bothNet aa) l\n 2. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 3. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 4. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 5. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (rule basic_trans_rules(18))"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position {a, b} l \\<le> position (first_bothNet aa) l\n 2. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position {a, b} l \\<noteq>\n                      position (first_bothNet aa) l\n 3. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 4. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 5. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 6. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (rule_tac a = \"DenyAllFromTo a b\" and b = aa in posaux4, simp_all)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> aa \\<noteq> DenyAll\n 2. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> first_bothNet aa = bothNet aa\n 3. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position {a, b} l \\<noteq>\n                      position (first_bothNet aa) l\n 4. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 5. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 6. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 7. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (case_tac aa,simp_all)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> first_bothNet aa = bothNet aa\n 2. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position {a, b} l \\<noteq>\n                      position (first_bothNet aa) l\n 3. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 4. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 5. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 6. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (case_tac aa, simp_all)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position {a, b} l \\<noteq>\n                      position (first_bothNet aa) l\n 2. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 3. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 4. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 5. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (rule posaux3, simp_all)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> first_bothNet aa \\<in> set l\n 2. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 3. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 4. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 5. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (case_tac aa, simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 2. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 3. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 4. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (rule_tac a = aa and b = \"AllowPortFromTo u v w\" in posaux4, simp_all)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> aa \\<noteq> DenyAll\n 2. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> smaller aa (AllowPortFromTo u v w) l\n 3. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> first_bothNet aa = bothNet aa\n 4. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 5. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 6. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (case_tac aa,simp_all)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> smaller aa (AllowPortFromTo u v w) l\n 2. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> first_bothNet aa = bothNet aa\n 3. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 4. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 5. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (rule_tac p = list in sorted_is_smaller, simp_all)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> singleCombinators list\n 2. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> first_bothNet aa = bothNet aa\n 3. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 4. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 5. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (case_tac aa, simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>p = aa # list; {u, v} \\<in> set l;\n     singleCombinators (aa # list); {u, v} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} = {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> first_bothNet aa = bothNet aa\n 2. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 3. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 4. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (case_tac aa, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> position (first_bothNet aa) l \\<le> position {u, v} l\n 2. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 3. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (rule_tac a = aa and b = \"AllowPortFromTo u v w\" in posaux4, simp_all)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> aa \\<noteq> DenyAll\n 2. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> {u, v} \\<in> set l\n 3. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> smaller aa (AllowPortFromTo u v w) l\n 4. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> first_bothNet aa = bothNet aa\n 5. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 6. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (case_tac aa,simp_all)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> {u, v} \\<in> set l\n 2. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> smaller aa (AllowPortFromTo u v w) l\n 3. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> first_bothNet aa = bothNet aa\n 4. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 5. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "using **"], ["proof (prove)\nusing this:\n  \\<lbrakk>AllowPortFromTo u v w \\<in> set list; in_list aa l;\n   all_in_list list l\\<rbrakk>\n  \\<Longrightarrow> in_list (AllowPortFromTo u v w) l\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> {u, v} \\<in> set l\n 2. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> smaller aa (AllowPortFromTo u v w) l\n 3. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> first_bothNet aa = bothNet aa\n 4. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 5. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply auto[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> smaller aa (AllowPortFromTo u v w) l\n 2. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> first_bothNet aa = bothNet aa\n 3. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 4. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (metis all_in_list.simps(2) sorted_Cons)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> position {u, v} l \\<le> position {a, b} l;\n     p = aa # list; {a, b} \\<in> set l; singleCombinators (aa # list);\n     {a, b} \\<noteq> first_bothNet aa; AllowPortFromTo u v w \\<in> set list;\n     {a, b} \\<noteq> {u, v}; \\<not> member DenyAll aa; noDenyAll list;\n     in_list aa l; all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n    \\<Longrightarrow> first_bothNet aa = bothNet aa\n 2. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 3. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (case_tac aa, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = aa # list; {a, b} \\<in> set l;\n     singleCombinators (aa # list); {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list; {a, b} \\<noteq> {u, v};\n     \\<not> member DenyAll aa; noDenyAll list; in_list aa l;\n     all_in_list list l; smaller (DenyAllFromTo a b) aa l;\n     FWNormalisationCore.sorted (aa # list) l;\n     position {a, b} l \\<le> position {u, v} l\\<rbrakk>\n    \\<Longrightarrow> position {u, v} l \\<noteq> position {a, b} l\n 2. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "apply (metis ** bothNet.simps(3) in_list.simps(3) posaux6)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "using *"], ["proof (prove)\nusing this:\n  \\<lbrakk>{a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n   singleCombinators (aa # list); AllowPortFromTo u v w \\<in> set list;\n   smaller (DenyAllFromTo a b) aa l \\<and>\n   FWNormalisationCore.sorted (aa # list) l\\<rbrakk>\n  \\<Longrightarrow> smaller (DenyAllFromTo a b) (AllowPortFromTo u v w) l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = aa # list; \\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (DenyAllFromTo a b) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> {u, v} \\<longrightarrow>\n                      position {a, b} l \\<le> position {u, v} l", "by force"], ["proof (state)\nthis:\n  noDenyAll p \\<longrightarrow>\n  {a, b} \\<in> set l \\<longrightarrow>\n  all_in_list p l \\<longrightarrow>\n  singleCombinators p \\<longrightarrow>\n  FWNormalisationCore.sorted (DenyAllFromTo a b # p) l \\<longrightarrow>\n  {a, b} \\<noteq> firstList p \\<longrightarrow>\n  AllowPortFromTo u v w \\<in> set p \\<longrightarrow> {a, b} \\<noteq> {u, v}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  NCSaux3[rule_format]:\n  \"noDenyAll p \\<longrightarrow> {a, b} \\<in> set l \\<longrightarrow>  all_in_list p l \\<longrightarrow>singleCombinators p \\<longrightarrow> \n  sorted (AllowPortFromTo a b w # p) l \\<longrightarrow> {a, b} \\<noteq> firstList p \\<longrightarrow>\n  DenyAllFromTo u v \\<in> set p \\<longrightarrow> {a, b} \\<noteq> {u, v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll p \\<longrightarrow>\n    {a, b} \\<in> set l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    FWNormalisationCore.sorted (AllowPortFromTo a b w # p)\n     l \\<longrightarrow>\n    {a, b} \\<noteq> firstList p \\<longrightarrow>\n    DenyAllFromTo u v \\<in> set p \\<longrightarrow> {a, b} \\<noteq> {u, v}", "apply (case_tac p, simp_all,intro impI conjI,hypsubst,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>p = aa # list;\n        \\<not> member DenyAll aa \\<and> noDenyAll list; {a, b} \\<in> set l;\n        in_list aa l \\<and> all_in_list list l;\n        singleCombinators (aa # list);\n        smaller (AllowPortFromTo a b w) aa l \\<and>\n        FWNormalisationCore.sorted (aa # list) l;\n        {a, b} \\<noteq> first_bothNet aa;\n        DenyAllFromTo u v \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> {a, b} \\<noteq> {u, v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>p = aa # list;\n        \\<not> member DenyAll aa \\<and> noDenyAll list; {a, b} \\<in> set l;\n        in_list aa l \\<and> all_in_list list l;\n        singleCombinators (aa # list);\n        smaller (AllowPortFromTo a b w) aa l \\<and>\n        FWNormalisationCore.sorted (aa # list) l;\n        {a, b} \\<noteq> first_bothNet aa;\n        DenyAllFromTo u v \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> {a, b} \\<noteq> {u, v}", "fix aa::\"('a, 'b) Combinators\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>p = aa # list;\n        \\<not> member DenyAll aa \\<and> noDenyAll list; {a, b} \\<in> set l;\n        in_list aa l \\<and> all_in_list list l;\n        singleCombinators (aa # list);\n        smaller (AllowPortFromTo a b w) aa l \\<and>\n        FWNormalisationCore.sorted (aa # list) l;\n        {a, b} \\<noteq> first_bothNet aa;\n        DenyAllFromTo u v \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> {a, b} \\<noteq> {u, v}", "fix list::\"('a, 'b) Combinators list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>p = aa # list;\n        \\<not> member DenyAll aa \\<and> noDenyAll list; {a, b} \\<in> set l;\n        in_list aa l \\<and> all_in_list list l;\n        singleCombinators (aa # list);\n        smaller (AllowPortFromTo a b w) aa l \\<and>\n        FWNormalisationCore.sorted (aa # list) l;\n        {a, b} \\<noteq> first_bothNet aa;\n        DenyAllFromTo u v \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> {a, b} \\<noteq> {u, v}", "assume 1 : \"\\<not> member DenyAll aa \\<and> noDenyAll list\" and 2: \"{a, b} \\<in> set l \"\n    and  3 : \"in_list aa l \\<and> all_in_list list l\" and 4: \"singleCombinators (aa # list)\"\n    and  5 : \"smaller (AllowPortFromTo a b w) aa l \\<and> sorted (aa # list) l\"\n    and  6 : \"{a, b} \\<noteq> first_bothNet aa\" and 7: \"DenyAllFromTo u v \\<in> set list\""], ["proof (state)\nthis:\n  \\<not> member DenyAll aa \\<and> noDenyAll list\n  {a, b} \\<in> set l\n  in_list aa l \\<and> all_in_list list l\n  singleCombinators (aa # list)\n  smaller (AllowPortFromTo a b w) aa l \\<and>\n  FWNormalisationCore.sorted (aa # list) l\n  {a, b} \\<noteq> first_bothNet aa\n  DenyAllFromTo u v \\<in> set list\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>p = aa # list;\n        \\<not> member DenyAll aa \\<and> noDenyAll list; {a, b} \\<in> set l;\n        in_list aa l \\<and> all_in_list list l;\n        singleCombinators (aa # list);\n        smaller (AllowPortFromTo a b w) aa l \\<and>\n        FWNormalisationCore.sorted (aa # list) l;\n        {a, b} \\<noteq> first_bothNet aa;\n        DenyAllFromTo u v \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> {a, b} \\<noteq> {u, v}", "have *: \"\\<not> smaller (DenyAllFromTo u v) (AllowPortFromTo a b w) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> smaller (DenyAllFromTo u v) (AllowPortFromTo a b w) l", "apply (insert 1 2 3 4 5 6 7, rule_tac y = aa and z = list in notSmallerTrans)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> AllowPortFromTo a b w \\<noteq> DenyAll\n 2. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> DenyAllFromTo u v \\<noteq> DenyAll\n 3. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (AllowPortFromTo a b w # aa # list)\n 4. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller aa (AllowPortFromTo a b w) l\n 5. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (AllowPortFromTo a b w # aa # list) l\n 6. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> DenyAllFromTo u v \\<in> set list\n 7. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> all_in_list (AllowPortFromTo a b w # aa # list) l", "apply (simp_all del: smaller.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller aa (AllowPortFromTo a b w) l", "apply (rule smalleraux3a,simp_all del: smaller.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> aa \\<noteq> DenyAll\n 2. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> bothNet aa", "apply (case_tac aa, simp_all del: smaller.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> bothNet aa", "apply (case_tac aa, simp_all del: smaller.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> smaller (DenyAllFromTo u v) (AllowPortFromTo a b w) l\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>p = aa # list;\n        \\<not> member DenyAll aa \\<and> noDenyAll list; {a, b} \\<in> set l;\n        in_list aa l \\<and> all_in_list list l;\n        singleCombinators (aa # list);\n        smaller (AllowPortFromTo a b w) aa l \\<and>\n        FWNormalisationCore.sorted (aa # list) l;\n        {a, b} \\<noteq> first_bothNet aa;\n        DenyAllFromTo u v \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> {a, b} \\<noteq> {u, v}", "have **: \"smaller (AllowPortFromTo a b w) (DenyAllFromTo u v) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smaller (AllowPortFromTo a b w) (DenyAllFromTo u v) l", "apply (insert 1 2 3 4 5 6 7,rule_tac y = aa in order_trans,simp_all del: smaller.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {u, v} \\<in> set l\n 2. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> smaller aa (DenyAllFromTo u v) l", "apply (subgoal_tac \"in_list (DenyAllFromTo u v) l\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> in_list (DenyAllFromTo u v) l\n 2. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> smaller aa (DenyAllFromTo u v) l", "apply (rule_tac p = list in in_set_in_list, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> smaller aa (DenyAllFromTo u v) l", "apply (rule_tac p = list in sorted_is_smaller,simp_all del: smaller.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {u, v} \\<in> set l\n 2. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> singleCombinators list", "apply (subgoal_tac \"in_list (DenyAllFromTo u v) l\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> in_list (DenyAllFromTo u v) l\n 2. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> singleCombinators list", "apply (rule_tac p = list in in_set_in_list, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b w) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     DenyAllFromTo u v \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> singleCombinators list", "apply (erule singleCombinatorsConc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  smaller (AllowPortFromTo a b w) (DenyAllFromTo u v) l\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>p = aa # list;\n        \\<not> member DenyAll aa \\<and> noDenyAll list; {a, b} \\<in> set l;\n        in_list aa l \\<and> all_in_list list l;\n        singleCombinators (aa # list);\n        smaller (AllowPortFromTo a b w) aa l \\<and>\n        FWNormalisationCore.sorted (aa # list) l;\n        {a, b} \\<noteq> first_bothNet aa;\n        DenyAllFromTo u v \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> {a, b} \\<noteq> {u, v}", "show       \"{a, b} \\<noteq> {u, v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a, b} \\<noteq> {u, v}", "by (insert * **, simp split: if_splits)"], ["proof (state)\nthis:\n  {a, b} \\<noteq> {u, v}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  NCSaux4[rule_format]:\n  \"noDenyAll p \\<longrightarrow> {a, b} \\<in> set l \\<longrightarrow>  all_in_list p l \\<longrightarrow> singleCombinators p \\<longrightarrow> \n sorted (AllowPortFromTo a b c # p) l \\<longrightarrow> {a, b} \\<noteq> firstList p \\<longrightarrow>\n AllowPortFromTo u v w \\<in> set p \\<longrightarrow> {a, b} \\<noteq> {u, v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll p \\<longrightarrow>\n    {a, b} \\<in> set l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    FWNormalisationCore.sorted (AllowPortFromTo a b c # p)\n     l \\<longrightarrow>\n    {a, b} \\<noteq> firstList p \\<longrightarrow>\n    AllowPortFromTo u v w \\<in> set p \\<longrightarrow>\n    {a, b} \\<noteq> {u, v}", "apply (cases p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       p = aa # list \\<Longrightarrow>\n       \\<not> member DenyAll aa \\<and> noDenyAll list \\<longrightarrow>\n       {a, b} \\<in> set l \\<longrightarrow>\n       in_list aa l \\<and> all_in_list list l \\<longrightarrow>\n       singleCombinators (aa # list) \\<longrightarrow>\n       smaller (AllowPortFromTo a b c) aa l \\<and>\n       FWNormalisationCore.sorted (aa # list) l \\<longrightarrow>\n       {a, b} \\<noteq> first_bothNet aa \\<longrightarrow>\n       (AllowPortFromTo u v w = aa \\<longrightarrow>\n        {a, b} \\<noteq> {u, v}) \\<and>\n       (AllowPortFromTo u v w \\<in> set list \\<longrightarrow>\n        {a, b} \\<noteq> {u, v})", "apply (intro impI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>p = aa # list;\n        \\<not> member DenyAll aa \\<and> noDenyAll list; {a, b} \\<in> set l;\n        in_list aa l \\<and> all_in_list list l;\n        singleCombinators (aa # list);\n        smaller (AllowPortFromTo a b c) aa l \\<and>\n        FWNormalisationCore.sorted (aa # list) l;\n        {a, b} \\<noteq> first_bothNet aa;\n        AllowPortFromTo u v w = aa\\<rbrakk>\n       \\<Longrightarrow> {a, b} \\<noteq> {u, v}\n 2. \\<And>aa list.\n       \\<lbrakk>p = aa # list;\n        \\<not> member DenyAll aa \\<and> noDenyAll list; {a, b} \\<in> set l;\n        in_list aa l \\<and> all_in_list list l;\n        singleCombinators (aa # list);\n        smaller (AllowPortFromTo a b c) aa l \\<and>\n        FWNormalisationCore.sorted (aa # list) l;\n        {a, b} \\<noteq> first_bothNet aa;\n        AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> {a, b} \\<noteq> {u, v}", "apply (hypsubst,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>p = aa # list;\n        \\<not> member DenyAll aa \\<and> noDenyAll list; {a, b} \\<in> set l;\n        in_list aa l \\<and> all_in_list list l;\n        singleCombinators (aa # list);\n        smaller (AllowPortFromTo a b c) aa l \\<and>\n        FWNormalisationCore.sorted (aa # list) l;\n        {a, b} \\<noteq> first_bothNet aa;\n        AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> {a, b} \\<noteq> {u, v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>p = aa # list;\n        \\<not> member DenyAll aa \\<and> noDenyAll list; {a, b} \\<in> set l;\n        in_list aa l \\<and> all_in_list list l;\n        singleCombinators (aa # list);\n        smaller (AllowPortFromTo a b c) aa l \\<and>\n        FWNormalisationCore.sorted (aa # list) l;\n        {a, b} \\<noteq> first_bothNet aa;\n        AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> {a, b} \\<noteq> {u, v}", "fix aa::\"('a, 'b) Combinators\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>p = aa # list;\n        \\<not> member DenyAll aa \\<and> noDenyAll list; {a, b} \\<in> set l;\n        in_list aa l \\<and> all_in_list list l;\n        singleCombinators (aa # list);\n        smaller (AllowPortFromTo a b c) aa l \\<and>\n        FWNormalisationCore.sorted (aa # list) l;\n        {a, b} \\<noteq> first_bothNet aa;\n        AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> {a, b} \\<noteq> {u, v}", "fix list::\"('a, 'b) Combinators list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>p = aa # list;\n        \\<not> member DenyAll aa \\<and> noDenyAll list; {a, b} \\<in> set l;\n        in_list aa l \\<and> all_in_list list l;\n        singleCombinators (aa # list);\n        smaller (AllowPortFromTo a b c) aa l \\<and>\n        FWNormalisationCore.sorted (aa # list) l;\n        {a, b} \\<noteq> first_bothNet aa;\n        AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> {a, b} \\<noteq> {u, v}", "assume 1 : \"\\<not> member DenyAll aa \\<and> noDenyAll list\" and 2: \"{a, b} \\<in> set l \"\n    and  3 : \"in_list aa l \\<and> all_in_list list l\" and 4: \"singleCombinators (aa # list)\"\n    and  5 : \"smaller (AllowPortFromTo a b c) aa l \\<and> sorted (aa # list) l\"\n    and  6 : \"{a, b} \\<noteq> first_bothNet aa\" and 7: \"AllowPortFromTo u v w \\<in> set list\""], ["proof (state)\nthis:\n  \\<not> member DenyAll aa \\<and> noDenyAll list\n  {a, b} \\<in> set l\n  in_list aa l \\<and> all_in_list list l\n  singleCombinators (aa # list)\n  smaller (AllowPortFromTo a b c) aa l \\<and>\n  FWNormalisationCore.sorted (aa # list) l\n  {a, b} \\<noteq> first_bothNet aa\n  AllowPortFromTo u v w \\<in> set list\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>p = aa # list;\n        \\<not> member DenyAll aa \\<and> noDenyAll list; {a, b} \\<in> set l;\n        in_list aa l \\<and> all_in_list list l;\n        singleCombinators (aa # list);\n        smaller (AllowPortFromTo a b c) aa l \\<and>\n        FWNormalisationCore.sorted (aa # list) l;\n        {a, b} \\<noteq> first_bothNet aa;\n        AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> {a, b} \\<noteq> {u, v}", "have *: \"\\<not> smaller (AllowPortFromTo u v w) (AllowPortFromTo a b c) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> smaller (AllowPortFromTo u v w) (AllowPortFromTo a b c) l", "apply (insert 1 2 3 4 5 6 7, rule_tac y = aa and z = list in notSmallerTrans)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b c) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> AllowPortFromTo a b c \\<noteq> DenyAll\n 2. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b c) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> AllowPortFromTo u v w \\<noteq> DenyAll\n 3. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b c) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (AllowPortFromTo a b c # aa # list)\n 4. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b c) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller aa (AllowPortFromTo a b c) l\n 5. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b c) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (AllowPortFromTo a b c # aa # list) l\n 6. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b c) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> AllowPortFromTo u v w \\<in> set list\n 7. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b c) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> all_in_list (AllowPortFromTo a b c # aa # list) l", "apply (simp_all del: smaller.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b c) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> \\<not> smaller aa (AllowPortFromTo a b c) l", "apply (rule smalleraux3a,simp_all del: smaller.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b c) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> aa \\<noteq> DenyAll\n 2. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b c) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> bothNet aa", "apply (case_tac aa, simp_all del: smaller.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b c) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> {a, b} \\<noteq> bothNet aa", "apply (case_tac aa, simp_all del: smaller.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> smaller (AllowPortFromTo u v w) (AllowPortFromTo a b c) l\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>p = aa # list;\n        \\<not> member DenyAll aa \\<and> noDenyAll list; {a, b} \\<in> set l;\n        in_list aa l \\<and> all_in_list list l;\n        singleCombinators (aa # list);\n        smaller (AllowPortFromTo a b c) aa l \\<and>\n        FWNormalisationCore.sorted (aa # list) l;\n        {a, b} \\<noteq> first_bothNet aa;\n        AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> {a, b} \\<noteq> {u, v}", "have **: \"smaller (AllowPortFromTo a b c) (AllowPortFromTo u v w) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smaller (AllowPortFromTo a b c) (AllowPortFromTo u v w) l", "apply(insert 1 2 3 4 5 6 7)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll aa \\<and> noDenyAll list;\n     {a, b} \\<in> set l; in_list aa l \\<and> all_in_list list l;\n     singleCombinators (aa # list);\n     smaller (AllowPortFromTo a b c) aa l \\<and>\n     FWNormalisationCore.sorted (aa # list) l;\n     {a, b} \\<noteq> first_bothNet aa;\n     AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n    \\<Longrightarrow> smaller (AllowPortFromTo a b c)\n                       (AllowPortFromTo u v w) l", "apply (case_tac aa, simp_all del: smaller.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x21, x22} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (DenyAllFromTo x21 x22) l \\<and>\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # list) l;\n        {a, b} \\<noteq> {x21, x22}; AllowPortFromTo u v w \\<in> set list;\n        aa = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo a b c)\n                          (AllowPortFromTo u v w) l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x31, x32} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (AllowPortFromTo x31 x32 x33)\n         l \\<and>\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        {a, b} \\<noteq> {x31, x32}; AllowPortFromTo u v w \\<in> set list;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo a b c)\n                          (AllowPortFromTo u v w) l", "apply (rule_tac y = aa in order_trans,simp_all del: smaller.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x21, x22} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (DenyAllFromTo x21 x22) l \\<and>\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # list) l;\n        {a, b} \\<noteq> {x21, x22}; AllowPortFromTo u v w \\<in> set list;\n        aa = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> {u, v} \\<in> set l\n 2. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x21, x22} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (DenyAllFromTo x21 x22) l \\<and>\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # list) l;\n        {a, b} \\<noteq> {x21, x22}; AllowPortFromTo u v w \\<in> set list;\n        aa = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> smaller (DenyAllFromTo x21 x22)\n                          (AllowPortFromTo u v w) l\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x31, x32} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (AllowPortFromTo x31 x32 x33)\n         l \\<and>\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        {a, b} \\<noteq> {x31, x32}; AllowPortFromTo u v w \\<in> set list;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo a b c)\n                          (AllowPortFromTo u v w) l", "apply (subgoal_tac \"in_list (AllowPortFromTo u v w) l\", simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x21, x22} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (DenyAllFromTo x21 x22) l \\<and>\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # list) l;\n        {a, b} \\<noteq> {x21, x22}; AllowPortFromTo u v w \\<in> set list;\n        aa = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> in_list (AllowPortFromTo u v w) l\n 2. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x21, x22} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (DenyAllFromTo x21 x22) l \\<and>\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # list) l;\n        {a, b} \\<noteq> {x21, x22}; AllowPortFromTo u v w \\<in> set list;\n        aa = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> smaller (DenyAllFromTo x21 x22)\n                          (AllowPortFromTo u v w) l\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x31, x32} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (AllowPortFromTo x31 x32 x33)\n         l \\<and>\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        {a, b} \\<noteq> {x31, x32}; AllowPortFromTo u v w \\<in> set list;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo a b c)\n                          (AllowPortFromTo u v w) l", "apply (rule_tac p = list in in_set_in_list, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x21, x22} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (DenyAllFromTo x21 x22) l \\<and>\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # list) l;\n        {a, b} \\<noteq> {x21, x22}; AllowPortFromTo u v w \\<in> set list;\n        aa = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> all_in_list list l\n 2. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x21, x22} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (DenyAllFromTo x21 x22) l \\<and>\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # list) l;\n        {a, b} \\<noteq> {x21, x22}; AllowPortFromTo u v w \\<in> set list;\n        aa = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> smaller (DenyAllFromTo x21 x22)\n                          (AllowPortFromTo u v w) l\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x31, x32} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (AllowPortFromTo x31 x32 x33)\n         l \\<and>\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        {a, b} \\<noteq> {x31, x32}; AllowPortFromTo u v w \\<in> set list;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo a b c)\n                          (AllowPortFromTo u v w) l", "apply (case_tac aa, simp_all del: smaller.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x21, x22} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (DenyAllFromTo x21 x22) l \\<and>\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # list) l;\n        {a, b} \\<noteq> {x21, x22}; AllowPortFromTo u v w \\<in> set list;\n        aa = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> smaller (DenyAllFromTo x21 x22)\n                          (AllowPortFromTo u v w) l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x31, x32} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (AllowPortFromTo x31 x32 x33)\n         l \\<and>\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        {a, b} \\<noteq> {x31, x32}; AllowPortFromTo u v w \\<in> set list;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo a b c)\n                          (AllowPortFromTo u v w) l", "apply (rule_tac p = list in sorted_is_smaller,simp_all del: smaller.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x21, x22} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (DenyAllFromTo x21 x22) l \\<and>\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # list) l;\n        {a, b} \\<noteq> {x21, x22}; AllowPortFromTo u v w \\<in> set list;\n        aa = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> {u, v} \\<in> set l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x31, x32} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (AllowPortFromTo x31 x32 x33)\n         l \\<and>\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        {a, b} \\<noteq> {x31, x32}; AllowPortFromTo u v w \\<in> set list;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo a b c)\n                          (AllowPortFromTo u v w) l", "apply (subgoal_tac \"in_list (AllowPortFromTo u v w) l\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x21, x22} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (DenyAllFromTo x21 x22) l \\<and>\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # list) l;\n        {a, b} \\<noteq> {x21, x22}; AllowPortFromTo u v w \\<in> set list;\n        aa = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> in_list (AllowPortFromTo u v w) l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x31, x32} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (AllowPortFromTo x31 x32 x33)\n         l \\<and>\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        {a, b} \\<noteq> {x31, x32}; AllowPortFromTo u v w \\<in> set list;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo a b c)\n                          (AllowPortFromTo u v w) l", "apply (rule_tac p = list in in_set_in_list, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x31, x32} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (AllowPortFromTo x31 x32 x33)\n         l \\<and>\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        {a, b} \\<noteq> {x31, x32}; AllowPortFromTo u v w \\<in> set list;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo a b c)\n                          (AllowPortFromTo u v w) l", "apply (rule_tac y = aa in order_trans,simp_all del: smaller.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x31, x32} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (AllowPortFromTo x31 x32 x33)\n         l \\<and>\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        {a, b} \\<noteq> {x31, x32}; AllowPortFromTo u v w \\<in> set list;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> {u, v} \\<in> set l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x31, x32} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (AllowPortFromTo x31 x32 x33)\n         l \\<and>\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        {a, b} \\<noteq> {x31, x32}; AllowPortFromTo u v w \\<in> set list;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33)\n                          (AllowPortFromTo u v w) l", "apply (subgoal_tac \"in_list (AllowPortFromTo u v w) l\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x31, x32} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (AllowPortFromTo x31 x32 x33)\n         l \\<and>\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        {a, b} \\<noteq> {x31, x32}; AllowPortFromTo u v w \\<in> set list;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> in_list (AllowPortFromTo u v w) l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x31, x32} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (AllowPortFromTo x31 x32 x33)\n         l \\<and>\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        {a, b} \\<noteq> {x31, x32}; AllowPortFromTo u v w \\<in> set list;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33)\n                          (AllowPortFromTo u v w) l", "using in_set_in_list"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> set ?p; all_in_list ?p ?l\\<rbrakk>\n  \\<Longrightarrow> in_list ?a ?l\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x31, x32} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (AllowPortFromTo x31 x32 x33)\n         l \\<and>\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        {a, b} \\<noteq> {x31, x32}; AllowPortFromTo u v w \\<in> set list;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> in_list (AllowPortFromTo u v w) l\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x31, x32} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (AllowPortFromTo x31 x32 x33)\n         l \\<and>\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        {a, b} \\<noteq> {x31, x32}; AllowPortFromTo u v w \\<in> set list;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33)\n                          (AllowPortFromTo u v w) l", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll list; {a, b} \\<in> set l;\n        {x31, x32} \\<in> set l \\<and> all_in_list list l;\n        singleCombinators list;\n        smaller (AllowPortFromTo a b c) (AllowPortFromTo x31 x32 x33)\n         l \\<and>\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # list) l;\n        {a, b} \\<noteq> {x31, x32}; AllowPortFromTo u v w \\<in> set list;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> smaller (AllowPortFromTo x31 x32 x33)\n                          (AllowPortFromTo u v w) l", "by (metis all_in_list.simps(2) bothNet.simps(3) in_list.simps(3) \n        singleCombinators.simps(5) sorted_ConsA)"], ["proof (state)\nthis:\n  smaller (AllowPortFromTo a b c) (AllowPortFromTo u v w) l\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>p = aa # list;\n        \\<not> member DenyAll aa \\<and> noDenyAll list; {a, b} \\<in> set l;\n        in_list aa l \\<and> all_in_list list l;\n        singleCombinators (aa # list);\n        smaller (AllowPortFromTo a b c) aa l \\<and>\n        FWNormalisationCore.sorted (aa # list) l;\n        {a, b} \\<noteq> first_bothNet aa;\n        AllowPortFromTo u v w \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> {a, b} \\<noteq> {u, v}", "show       \"{a, b} \\<noteq> {u, v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a, b} \\<noteq> {u, v}", "by (insert * **, simp_all split: if_splits)"], ["proof (state)\nthis:\n  {a, b} \\<noteq> {u, v}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NetsCollectedSorted[rule_format]: \n  \"noDenyAll1 p \\<longrightarrow> all_in_list p l \\<longrightarrow> singleCombinators p \\<longrightarrow> sorted p l \\<longrightarrow>  NetsCollected p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 p \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    singleCombinators p \\<longrightarrow>\n    FWNormalisationCore.sorted p l \\<longrightarrow> NetsCollected p", "apply (induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. noDenyAll1 [] \\<longrightarrow>\n    all_in_list [] l \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow>\n    FWNormalisationCore.sorted [] l \\<longrightarrow> NetsCollected []\n 2. \\<And>a p.\n       noDenyAll1 p \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted p l \\<longrightarrow>\n       NetsCollected p \\<Longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       all_in_list (a # p) l \\<longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n       NetsCollected (a # p)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       noDenyAll1 p \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       FWNormalisationCore.sorted p l \\<longrightarrow>\n       NetsCollected p \\<Longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       all_in_list (a # p) l \\<longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n       NetsCollected (a # p)", "apply (intro impI,drule mp,erule noDA1C,drule mp,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        singleCombinators p \\<longrightarrow>\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        NetsCollected p\\<rbrakk>\n       \\<Longrightarrow> NetsCollected (a # p)", "apply (drule mp,erule singleCombinatorsConc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        NetsCollected p\\<rbrakk>\n       \\<Longrightarrow> NetsCollected (a # p)", "apply (drule mp,erule sortedConc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p\\<rbrakk>\n       \\<Longrightarrow> NetsCollected (a # p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p\\<rbrakk>\n       \\<Longrightarrow> NetsCollected (a # p)", "fix a::\" ('a, 'b) Combinators\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p\\<rbrakk>\n       \\<Longrightarrow> NetsCollected (a # p)", "fix p:: \" ('a, 'b) Combinators list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p\\<rbrakk>\n       \\<Longrightarrow> NetsCollected (a # p)", "assume 1: \"noDenyAll1 (a # p)\"        and 2:\"all_in_list (a # p) l\" \n    and  3: \"singleCombinators (a # p)\" and 4: \"sorted (a # p) l\"  and   5: \"NetsCollected p\""], ["proof (state)\nthis:\n  noDenyAll1 (a # p)\n  all_in_list (a # p) l\n  singleCombinators (a # p)\n  FWNormalisationCore.sorted (a # p) l\n  NetsCollected p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p\\<rbrakk>\n       \\<Longrightarrow> NetsCollected (a # p)", "show \"NetsCollected (a # p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NetsCollected (a # p)", "apply(insert 1 2 3 4 5, rule fl3)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n     singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n     NetsCollected p\\<rbrakk>\n    \\<Longrightarrow> NetsCollected p\n 2. \\<And>aa.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "apply(simp, rename_tac \"aa\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "proof (cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = DenyAll\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 2. \\<And>aa x21 x22.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 3. \\<And>aa x31 x32 x33.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 4. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "case DenyAll"], ["proof (state)\nthis:\n  a = DenyAll\n\ngoal (4 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = DenyAll\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 2. \\<And>aa x21 x22.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 3. \\<And>aa x31 x32 x33.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 4. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "fix aa::\"('a, 'b) Combinators\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = DenyAll\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 2. \\<And>aa x21 x22.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 3. \\<And>aa x31 x32 x33.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 4. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "assume 6: \"aa \\<in> set p\""], ["proof (state)\nthis:\n  aa \\<in> set p\n\ngoal (4 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = DenyAll\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 2. \\<And>aa x21 x22.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 3. \\<And>aa x31 x32 x33.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 4. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "show \"first_bothNet a \\<noteq> first_bothNet aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. first_bothNet a \\<noteq> first_bothNet aa", "apply(insert 1 2 3 4 5 6 \\<open>a = DenyAll\\<close>, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll p; all_in_list p l; singleCombinators p;\n     FWNormalisationCore.sorted (DenyAll # p) l; NetsCollected p;\n     aa \\<in> set p; a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> {} \\<noteq> first_bothNet aa", "using fMTaux noDA"], ["proof (prove)\nusing this:\n  \\<not> member DenyAll ?x \\<Longrightarrow> first_bothNet ?x \\<noteq> {}\n  \\<lbrakk>noDenyAll ?xs; ?s \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> \\<not> member DenyAll ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll p; all_in_list p l; singleCombinators p;\n     FWNormalisationCore.sorted (DenyAll # p) l; NetsCollected p;\n     aa \\<in> set p; a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> {} \\<noteq> first_bothNet aa", "by blast"], ["proof (state)\nthis:\n  first_bothNet a \\<noteq> first_bothNet aa\n\ngoal (3 subgoals):\n 1. \\<And>aa x21 x22.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 2. \\<And>aa x31 x32 x33.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 3. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>aa x21 x22.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 2. \\<And>aa x31 x32 x33.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 3. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "case (DenyAllFromTo x21 x22)"], ["proof (state)\nthis:\n  a = DenyAllFromTo x21 x22\n\ngoal (3 subgoals):\n 1. \\<And>aa x21 x22.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 2. \\<And>aa x31 x32 x33.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 3. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "fix aa::\"('a, 'b) Combinators\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>aa x21 x22.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 2. \\<And>aa x31 x32 x33.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 3. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "assume 6: \"first_bothNet a \\<noteq> firstList p\" and 7 :\"aa \\<in> set p\""], ["proof (state)\nthis:\n  first_bothNet a \\<noteq> firstList p\n  aa \\<in> set p\n\ngoal (3 subgoals):\n 1. \\<And>aa x21 x22.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 2. \\<And>aa x31 x32 x33.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 3. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "show \"first_bothNet a \\<noteq> first_bothNet aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. first_bothNet a \\<noteq> first_bothNet aa", "apply(insert 1 2 3 4 5 6 7 \\<open>a = DenyAllFromTo x21 x22\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n     singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n     NetsCollected p; first_bothNet a \\<noteq> firstList p; aa \\<in> set p;\n     a = DenyAllFromTo x21 x22\\<rbrakk>\n    \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "apply(case_tac aa, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21a x22a.\n       \\<lbrakk>noDenyAll p; {x21, x22} \\<in> set l \\<and> all_in_list p l;\n        singleCombinators p;\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # p) l;\n        NetsCollected p; {x21, x22} \\<noteq> firstList p;\n        DenyAllFromTo x21a x22a \\<in> set p; a = DenyAllFromTo x21 x22;\n        aa = DenyAllFromTo x21a x22a\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> {x21a, x22a}\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll p; {x21, x22} \\<in> set l \\<and> all_in_list p l;\n        singleCombinators p;\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # p) l;\n        NetsCollected p; {x21, x22} \\<noteq> firstList p;\n        AllowPortFromTo x31 x32 x33 \\<in> set p; a = DenyAllFromTo x21 x22;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> {x31, x32}\n 3. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll p; {x21, x22} \\<in> set l \\<and> all_in_list p l;\n        singleCombinators p;\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # p) l;\n        NetsCollected p; {x21, x22} \\<noteq> firstList p;\n        x41 \\<oplus> x42 \\<in> set p; a = DenyAllFromTo x21 x22;\n        aa = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> first_bothNet x41", "apply (meson NCSaux1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll p; {x21, x22} \\<in> set l \\<and> all_in_list p l;\n        singleCombinators p;\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # p) l;\n        NetsCollected p; {x21, x22} \\<noteq> firstList p;\n        AllowPortFromTo x31 x32 x33 \\<in> set p; a = DenyAllFromTo x21 x22;\n        aa = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> {x31, x32}\n 2. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll p; {x21, x22} \\<in> set l \\<and> all_in_list p l;\n        singleCombinators p;\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # p) l;\n        NetsCollected p; {x21, x22} \\<noteq> firstList p;\n        x41 \\<oplus> x42 \\<in> set p; a = DenyAllFromTo x21 x22;\n        aa = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> first_bothNet x41", "apply (meson NCSaux2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll p; {x21, x22} \\<in> set l \\<and> all_in_list p l;\n        singleCombinators p;\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # p) l;\n        NetsCollected p; {x21, x22} \\<noteq> firstList p;\n        x41 \\<oplus> x42 \\<in> set p; a = DenyAllFromTo x21 x22;\n        aa = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> first_bothNet x41", "using SCnotConc"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<oplus> ?b \\<in> set ?p; singleCombinators ?p\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll p; {x21, x22} \\<in> set l \\<and> all_in_list p l;\n        singleCombinators p;\n        FWNormalisationCore.sorted (DenyAllFromTo x21 x22 # p) l;\n        NetsCollected p; {x21, x22} \\<noteq> firstList p;\n        x41 \\<oplus> x42 \\<in> set p; a = DenyAllFromTo x21 x22;\n        aa = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> {x21, x22} \\<noteq> first_bothNet x41", "by auto[1]"], ["proof (state)\nthis:\n  first_bothNet a \\<noteq> first_bothNet aa\n\ngoal (2 subgoals):\n 1. \\<And>aa x31 x32 x33.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 2. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>aa x31 x32 x33.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 2. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "case (AllowPortFromTo x31 x32 x33)"], ["proof (state)\nthis:\n  a = AllowPortFromTo x31 x32 x33\n\ngoal (2 subgoals):\n 1. \\<And>aa x31 x32 x33.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 2. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "fix aa::\"('a, 'b) Combinators\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>aa x31 x32 x33.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 2. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "assume 6: \"first_bothNet a \\<noteq> firstList p\" and 7 :\"aa \\<in> set p\""], ["proof (state)\nthis:\n  first_bothNet a \\<noteq> firstList p\n  aa \\<in> set p\n\ngoal (2 subgoals):\n 1. \\<And>aa x31 x32 x33.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa\n 2. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "show \"first_bothNet a \\<noteq> first_bothNet aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. first_bothNet a \\<noteq> first_bothNet aa", "apply(insert 1 2 3 4 6 7 \\<open>a = AllowPortFromTo x31 x32 x33\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n     singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n     first_bothNet a \\<noteq> firstList p; aa \\<in> set p;\n     a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n    \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "apply(case_tac aa, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll p; {x31, x32} \\<in> set l \\<and> all_in_list p l;\n        singleCombinators p;\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # p) l;\n        {x31, x32} \\<noteq> firstList p; DenyAllFromTo x21 x22 \\<in> set p;\n        a = AllowPortFromTo x31 x32 x33; aa = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x21, x22}\n 2. \\<And>x31a x32a x33a.\n       \\<lbrakk>noDenyAll p; {x31, x32} \\<in> set l \\<and> all_in_list p l;\n        singleCombinators p;\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # p) l;\n        {x31, x32} \\<noteq> firstList p;\n        AllowPortFromTo x31a x32a x33a \\<in> set p;\n        a = AllowPortFromTo x31 x32 x33;\n        aa = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x31a, x32a}\n 3. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll p; {x31, x32} \\<in> set l \\<and> all_in_list p l;\n        singleCombinators p;\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # p) l;\n        {x31, x32} \\<noteq> firstList p; x41 \\<oplus> x42 \\<in> set p;\n        a = AllowPortFromTo x31 x32 x33; aa = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> first_bothNet x41", "apply (meson NCSaux3)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x31a x32a x33a.\n       \\<lbrakk>noDenyAll p; {x31, x32} \\<in> set l \\<and> all_in_list p l;\n        singleCombinators p;\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # p) l;\n        {x31, x32} \\<noteq> firstList p;\n        AllowPortFromTo x31a x32a x33a \\<in> set p;\n        a = AllowPortFromTo x31 x32 x33;\n        aa = AllowPortFromTo x31a x32a x33a\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> {x31a, x32a}\n 2. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll p; {x31, x32} \\<in> set l \\<and> all_in_list p l;\n        singleCombinators p;\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # p) l;\n        {x31, x32} \\<noteq> firstList p; x41 \\<oplus> x42 \\<in> set p;\n        a = AllowPortFromTo x31 x32 x33; aa = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> first_bothNet x41", "apply (meson NCSaux4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll p; {x31, x32} \\<in> set l \\<and> all_in_list p l;\n        singleCombinators p;\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # p) l;\n        {x31, x32} \\<noteq> firstList p; x41 \\<oplus> x42 \\<in> set p;\n        a = AllowPortFromTo x31 x32 x33; aa = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> first_bothNet x41", "using SCnotConc"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<oplus> ?b \\<in> set ?p; singleCombinators ?p\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll p; {x31, x32} \\<in> set l \\<and> all_in_list p l;\n        singleCombinators p;\n        FWNormalisationCore.sorted (AllowPortFromTo x31 x32 x33 # p) l;\n        {x31, x32} \\<noteq> firstList p; x41 \\<oplus> x42 \\<in> set p;\n        a = AllowPortFromTo x31 x32 x33; aa = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> {x31, x32} \\<noteq> first_bothNet x41", "by auto"], ["proof (state)\nthis:\n  first_bothNet a \\<noteq> first_bothNet aa\n\ngoal (1 subgoal):\n 1. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "case (Conc x41 x42)"], ["proof (state)\nthis:\n  a = x41 \\<oplus> x42\n\ngoal (1 subgoal):\n 1. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "fix aa::\"('a, 'b) Combinators\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa x41 x42.\n       \\<lbrakk>noDenyAll1 (a # p); all_in_list (a # p) l;\n        singleCombinators (a # p); FWNormalisationCore.sorted (a # p) l;\n        NetsCollected p; first_bothNet a \\<noteq> firstList p;\n        aa \\<in> set p; a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa", "show \"first_bothNet a \\<noteq> first_bothNet aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. first_bothNet a \\<noteq> first_bothNet aa", "by(insert 3 4   \\<open>a = x41 \\<oplus> x42\\<close>,simp)"], ["proof (state)\nthis:\n  first_bothNet a \\<noteq> first_bothNet aa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  NetsCollected (a # p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NetsCollectedSort: \"distinct p \\<Longrightarrow>noDenyAll1 p \\<Longrightarrow> all_in_list p l \\<Longrightarrow>\n                          singleCombinators p \\<Longrightarrow> NetsCollected (sort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct p; noDenyAll1 p; all_in_list p l;\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> NetsCollected (FWNormalisationCore.sort p l)", "apply (rule_tac l = l in NetsCollectedSorted,rule noDAsort, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct p; noDenyAll1 p; all_in_list p l;\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> all_in_list (FWNormalisationCore.sort p l) l\n 2. \\<lbrakk>distinct p; noDenyAll1 p; all_in_list p l;\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (FWNormalisationCore.sort p l) l", "apply (rule_tac b=p in all_in_listSubset)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>distinct p; noDenyAll1 p; all_in_list p l;\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> all_in_list p l\n 2. \\<lbrakk>distinct p; noDenyAll1 p; all_in_list p l;\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> singleCombinators (FWNormalisationCore.sort p l)\n 3. \\<lbrakk>distinct p; noDenyAll1 p; all_in_list p l;\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> set (FWNormalisationCore.sort p l) \\<subseteq> set p\n 4. \\<lbrakk>distinct p; noDenyAll1 p; all_in_list p l;\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted\n                       (FWNormalisationCore.sort p l) l", "by (auto intro: sort_is_sorted)"], ["", "lemma fBNsep[rule_format]: \"(\\<forall>a\\<in>set z. {b,c} \\<noteq> first_bothNet a) \\<longrightarrow>\n                           (\\<forall>a\\<in>set (separate z). {b,c} \\<noteq> first_bothNet a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set z.\n        {b, c} \\<noteq> first_bothNet a) \\<longrightarrow>\n    (\\<forall>a\\<in>set (separate z). {b, c} \\<noteq> first_bothNet a)", "apply (induct z rule: separate.induct, simp)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (DenyAllFromTo v va) =\n                first_bothNet y \\<Longrightarrow>\n                (\\<forall>a\\<in>set (DenyAllFromTo v va \\<oplus> y # z).\n                    {b, c} \\<noteq> first_bothNet a) \\<longrightarrow>\n                (\\<forall>a\\<in>set (separate\n(DenyAllFromTo v va \\<oplus> y # z)).\n                    {b, c} \\<noteq> first_bothNet a);\n        first_bothNet (DenyAllFromTo v va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        (\\<forall>a\\<in>set (y # z).\n            {b, c} \\<noteq> first_bothNet a) \\<longrightarrow>\n        (\\<forall>a\\<in>set (separate (y # z)).\n            {b, c} \\<noteq> first_bothNet a)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (DenyAllFromTo v va # y # z).\n                             {b, c} \\<noteq>\n                             first_bothNet a) \\<longrightarrow>\n                         (\\<forall>a\\<in>set\n    (separate (DenyAllFromTo v va # y # z)).\n                             {b, c} \\<noteq> first_bothNet a)\n 2. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                (\\<forall>a\\<in>set (AllowPortFromTo v va vb \\<oplus> y #\n                                     z).\n                    {b, c} \\<noteq> first_bothNet a) \\<longrightarrow>\n                (\\<forall>a\\<in>set (separate\n(AllowPortFromTo v va vb \\<oplus> y # z)).\n                    {b, c} \\<noteq> first_bothNet a);\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        (\\<forall>a\\<in>set (y # z).\n            {b, c} \\<noteq> first_bothNet a) \\<longrightarrow>\n        (\\<forall>a\\<in>set (separate (y # z)).\n            {b, c} \\<noteq> first_bothNet a)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set\n    (AllowPortFromTo v va vb # y # z).\n                             {b, c} \\<noteq>\n                             first_bothNet a) \\<longrightarrow>\n                         (\\<forall>a\\<in>set\n    (separate (AllowPortFromTo v va vb # y # z)).\n                             {b, c} \\<noteq> first_bothNet a)\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (\\<forall>a\\<in>set ((v \\<oplus> va) \\<oplus> y # z).\n                    {b, c} \\<noteq> first_bothNet a) \\<longrightarrow>\n                (\\<forall>a\\<in>set (separate\n((v \\<oplus> va) \\<oplus> y # z)).\n                    {b, c} \\<noteq> first_bothNet a);\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        (\\<forall>a\\<in>set (y # z).\n            {b, c} \\<noteq> first_bothNet a) \\<longrightarrow>\n        (\\<forall>a\\<in>set (separate (y # z)).\n            {b, c} \\<noteq> first_bothNet a)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (v \\<oplus> va # y # z).\n                             {b, c} \\<noteq>\n                             first_bothNet a) \\<longrightarrow>\n                         (\\<forall>a\\<in>set\n    (separate (v \\<oplus> va # y # z)).\n                             {b, c} \\<noteq> first_bothNet a)\n 4. (\\<forall>a\\<in>set [].\n        {b, c} \\<noteq> first_bothNet a) \\<longrightarrow>\n    (\\<forall>a\\<in>set (separate []). {b, c} \\<noteq> first_bothNet a)\n 5. \\<And>vb vc.\n       (\\<forall>a\\<in>set [DenyAllFromTo vb vc].\n           {b, c} \\<noteq> first_bothNet a) \\<longrightarrow>\n       (\\<forall>a\\<in>set (separate [DenyAllFromTo vb vc]).\n           {b, c} \\<noteq> first_bothNet a)\n 6. \\<And>vb vc vd.\n       (\\<forall>a\\<in>set [AllowPortFromTo vb vc vd].\n           {b, c} \\<noteq> first_bothNet a) \\<longrightarrow>\n       (\\<forall>a\\<in>set (separate [AllowPortFromTo vb vc vd]).\n           {b, c} \\<noteq> first_bothNet a)\n 7. \\<And>vb vc.\n       (\\<forall>a\\<in>set [vb \\<oplus> vc].\n           {b, c} \\<noteq> first_bothNet a) \\<longrightarrow>\n       (\\<forall>a\\<in>set (separate [vb \\<oplus> vc]).\n           {b, c} \\<noteq> first_bothNet a)", "by (rule impI, simp)+"], ["", "lemma fBNsep1[rule_format]: \" (\\<forall>a\\<in>set z. first_bothNet x \\<noteq> first_bothNet a) \\<longrightarrow>\n                        (\\<forall>a\\<in>set (separate z). first_bothNet x \\<noteq> first_bothNet a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set z.\n        first_bothNet x \\<noteq> first_bothNet a) \\<longrightarrow>\n    (\\<forall>a\\<in>set (separate z).\n        first_bothNet x \\<noteq> first_bothNet a)", "apply (induct z rule: separate.induct, simp)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (DenyAllFromTo v va) =\n                first_bothNet y \\<Longrightarrow>\n                (\\<forall>a\\<in>set (DenyAllFromTo v va \\<oplus> y # z).\n                    first_bothNet x \\<noteq>\n                    first_bothNet a) \\<longrightarrow>\n                (\\<forall>a\\<in>set (separate\n(DenyAllFromTo v va \\<oplus> y # z)).\n                    first_bothNet x \\<noteq> first_bothNet a);\n        first_bothNet (DenyAllFromTo v va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        (\\<forall>a\\<in>set (y # z).\n            first_bothNet x \\<noteq> first_bothNet a) \\<longrightarrow>\n        (\\<forall>a\\<in>set (separate (y # z)).\n            first_bothNet x \\<noteq> first_bothNet a)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (DenyAllFromTo v va # y # z).\n                             first_bothNet x \\<noteq>\n                             first_bothNet a) \\<longrightarrow>\n                         (\\<forall>a\\<in>set\n    (separate (DenyAllFromTo v va # y # z)).\n                             first_bothNet x \\<noteq> first_bothNet a)\n 2. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                (\\<forall>a\\<in>set (AllowPortFromTo v va vb \\<oplus> y #\n                                     z).\n                    first_bothNet x \\<noteq>\n                    first_bothNet a) \\<longrightarrow>\n                (\\<forall>a\\<in>set (separate\n(AllowPortFromTo v va vb \\<oplus> y # z)).\n                    first_bothNet x \\<noteq> first_bothNet a);\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        (\\<forall>a\\<in>set (y # z).\n            first_bothNet x \\<noteq> first_bothNet a) \\<longrightarrow>\n        (\\<forall>a\\<in>set (separate (y # z)).\n            first_bothNet x \\<noteq> first_bothNet a)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set\n    (AllowPortFromTo v va vb # y # z).\n                             first_bothNet x \\<noteq>\n                             first_bothNet a) \\<longrightarrow>\n                         (\\<forall>a\\<in>set\n    (separate (AllowPortFromTo v va vb # y # z)).\n                             first_bothNet x \\<noteq> first_bothNet a)\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (\\<forall>a\\<in>set ((v \\<oplus> va) \\<oplus> y # z).\n                    first_bothNet x \\<noteq>\n                    first_bothNet a) \\<longrightarrow>\n                (\\<forall>a\\<in>set (separate\n((v \\<oplus> va) \\<oplus> y # z)).\n                    first_bothNet x \\<noteq> first_bothNet a);\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        (\\<forall>a\\<in>set (y # z).\n            first_bothNet x \\<noteq> first_bothNet a) \\<longrightarrow>\n        (\\<forall>a\\<in>set (separate (y # z)).\n            first_bothNet x \\<noteq> first_bothNet a)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (v \\<oplus> va # y # z).\n                             first_bothNet x \\<noteq>\n                             first_bothNet a) \\<longrightarrow>\n                         (\\<forall>a\\<in>set\n    (separate (v \\<oplus> va # y # z)).\n                             first_bothNet x \\<noteq> first_bothNet a)\n 4. (\\<forall>a\\<in>set [].\n        first_bothNet x \\<noteq> first_bothNet a) \\<longrightarrow>\n    (\\<forall>a\\<in>set (separate []).\n        first_bothNet x \\<noteq> first_bothNet a)\n 5. \\<And>vb vc.\n       (\\<forall>a\\<in>set [DenyAllFromTo vb vc].\n           first_bothNet x \\<noteq> first_bothNet a) \\<longrightarrow>\n       (\\<forall>a\\<in>set (separate [DenyAllFromTo vb vc]).\n           first_bothNet x \\<noteq> first_bothNet a)\n 6. \\<And>vb vc vd.\n       (\\<forall>a\\<in>set [AllowPortFromTo vb vc vd].\n           first_bothNet x \\<noteq> first_bothNet a) \\<longrightarrow>\n       (\\<forall>a\\<in>set (separate [AllowPortFromTo vb vc vd]).\n           first_bothNet x \\<noteq> first_bothNet a)\n 7. \\<And>vb vc.\n       (\\<forall>a\\<in>set [vb \\<oplus> vc].\n           first_bothNet x \\<noteq> first_bothNet a) \\<longrightarrow>\n       (\\<forall>a\\<in>set (separate [vb \\<oplus> vc]).\n           first_bothNet x \\<noteq> first_bothNet a)", "by (rule impI, simp)+"], ["", "lemma NetsCollectedSepauxa:\n  \"{b,c}\\<noteq>firstList z \\<Longrightarrow>  noDenyAll1 z \\<Longrightarrow> \\<forall>a\\<in>set z. {b,c}\\<noteq>first_bothNet a \\<Longrightarrow> NetsCollected z \\<Longrightarrow>  \n   NetsCollected (separate z) \\<Longrightarrow> {b, c} \\<noteq> firstList (separate z) \\<Longrightarrow>   a \\<in> set (separate z) \\<Longrightarrow> \n   {b, c} \\<noteq> first_bothNet a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{b, c} \\<noteq> firstList z; noDenyAll1 z;\n     \\<forall>a\\<in>set z. {b, c} \\<noteq> first_bothNet a; NetsCollected z;\n     NetsCollected (separate z); {b, c} \\<noteq> firstList (separate z);\n     a \\<in> set (separate z)\\<rbrakk>\n    \\<Longrightarrow> {b, c} \\<noteq> first_bothNet a", "by (rule fBNsep) simp_all"], ["", "lemma NetsCollectedSepaux:\n  \"first_bothNet (x::('a,'b)Combinators) \\<noteq> first_bothNet y \\<Longrightarrow> \\<not> member DenyAll y \\<and> noDenyAll z \\<Longrightarrow>  \n   (\\<forall>a\\<in>set z. first_bothNet x \\<noteq> first_bothNet a) \\<and> NetsCollected (y # z) \\<Longrightarrow>\n   NetsCollected (separate (y # z)) \\<Longrightarrow> first_bothNet x \\<noteq> firstList (separate (y # z)) \\<Longrightarrow>\n   a \\<in> set (separate (y # z)) \\<Longrightarrow>\n   first_bothNet (x::('a,'b)Combinators) \\<noteq> first_bothNet (a::('a,'b)Combinators)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>first_bothNet x \\<noteq> first_bothNet y;\n     \\<not> member DenyAll y \\<and> noDenyAll z;\n     (\\<forall>a\\<in>set z. first_bothNet x \\<noteq> first_bothNet a) \\<and>\n     NetsCollected (y # z);\n     NetsCollected (separate (y # z));\n     first_bothNet x \\<noteq> firstList (separate (y # z));\n     a \\<in> set (separate (y # z))\\<rbrakk>\n    \\<Longrightarrow> first_bothNet x \\<noteq> first_bothNet a", "by (rule fBNsep1) auto"], ["", "lemma NetsCollectedSep[rule_format]: \n  \"noDenyAll1 p \\<longrightarrow> NetsCollected p \\<longrightarrow>  NetsCollected (separate p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 p \\<longrightarrow>\n    NetsCollected p \\<longrightarrow> NetsCollected (separate p)", "proof (induct p rule: separate.induct, simp_all, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       noDenyAll1 x \\<longrightarrow>\n       NetsCollected x \\<longrightarrow>\n       NetsCollected (separate x) \\<Longrightarrow>\n       noDenyAll x \\<longrightarrow>\n       ({} \\<noteq> firstList x \\<longrightarrow>\n        (\\<forall>a\\<in>set x. {} \\<noteq> first_bothNet a)) \\<and>\n       NetsCollected x \\<longrightarrow>\n       ({} \\<noteq> firstList (separate x) \\<longrightarrow>\n        (\\<forall>a\\<in>set (separate x).\n            {} \\<noteq> first_bothNet a)) \\<and>\n       NetsCollected (separate x)\n 2. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 3. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 4. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "fix x::\"('a, 'b) Combinators list\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       noDenyAll1 x \\<longrightarrow>\n       NetsCollected x \\<longrightarrow>\n       NetsCollected (separate x) \\<Longrightarrow>\n       noDenyAll x \\<longrightarrow>\n       ({} \\<noteq> firstList x \\<longrightarrow>\n        (\\<forall>a\\<in>set x. {} \\<noteq> first_bothNet a)) \\<and>\n       NetsCollected x \\<longrightarrow>\n       ({} \\<noteq> firstList (separate x) \\<longrightarrow>\n        (\\<forall>a\\<in>set (separate x).\n            {} \\<noteq> first_bothNet a)) \\<and>\n       NetsCollected (separate x)\n 2. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 3. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 4. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "case 1"], ["proof (state)\nthis:\n  noDenyAll1 x_ \\<longrightarrow>\n  NetsCollected x_ \\<longrightarrow> NetsCollected (separate x_)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       noDenyAll1 x \\<longrightarrow>\n       NetsCollected x \\<longrightarrow>\n       NetsCollected (separate x) \\<Longrightarrow>\n       noDenyAll x \\<longrightarrow>\n       ({} \\<noteq> firstList x \\<longrightarrow>\n        (\\<forall>a\\<in>set x. {} \\<noteq> first_bothNet a)) \\<and>\n       NetsCollected x \\<longrightarrow>\n       ({} \\<noteq> firstList (separate x) \\<longrightarrow>\n        (\\<forall>a\\<in>set (separate x).\n            {} \\<noteq> first_bothNet a)) \\<and>\n       NetsCollected (separate x)\n 2. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 3. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 4. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "then"], ["proof (chain)\npicking this:\n  noDenyAll1 x_ \\<longrightarrow>\n  NetsCollected x_ \\<longrightarrow> NetsCollected (separate x_)", "show ?case"], ["proof (prove)\nusing this:\n  noDenyAll1 x_ \\<longrightarrow>\n  NetsCollected x_ \\<longrightarrow> NetsCollected (separate x_)\n\ngoal (1 subgoal):\n 1. noDenyAll x_ \\<longrightarrow>\n    ({} \\<noteq> firstList x_ \\<longrightarrow>\n     (\\<forall>a\\<in>set x_. {} \\<noteq> first_bothNet a)) \\<and>\n    NetsCollected x_ \\<longrightarrow>\n    ({} \\<noteq> firstList (separate x_) \\<longrightarrow>\n     (\\<forall>a\\<in>set (separate x_). {} \\<noteq> first_bothNet a)) \\<and>\n    NetsCollected (separate x_)", "by (metis fMTaux noDA noDA1eq noDAsep)"], ["proof (state)\nthis:\n  noDenyAll x_ \\<longrightarrow>\n  ({} \\<noteq> firstList x_ \\<longrightarrow>\n   (\\<forall>a\\<in>set x_. {} \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected x_ \\<longrightarrow>\n  ({} \\<noteq> firstList (separate x_) \\<longrightarrow>\n   (\\<forall>a\\<in>set (separate x_). {} \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected (separate x_)\n\ngoal (3 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 2. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 2. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "fix v va y"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 2. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "fix z::\"('a, 'b) Combinators list\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 2. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "case 2"], ["proof (state)\nthis:\n  {v_, va_} = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate (DenyAllFromTo v_ va_ \\<oplus> y_ # z_))\n  {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate (y_ # z_))\n\ngoal (3 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 2. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "then"], ["proof (chain)\npicking this:\n  {v_, va_} = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate (DenyAllFromTo v_ va_ \\<oplus> y_ # z_))\n  {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate (y_ # z_))", "show ?case"], ["proof (prove)\nusing this:\n  {v_, va_} = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate (DenyAllFromTo v_ va_ \\<oplus> y_ # z_))\n  {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate (y_ # z_))\n\ngoal (1 subgoal):\n 1. {v_, va_} \\<noteq> first_bothNet y_ \\<longrightarrow>\n    \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n    (\\<forall>a\\<in>set z_. {v_, va_} \\<noteq> first_bothNet a) \\<and>\n    (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n     (\\<forall>a\\<in>set z_.\n         first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n    NetsCollected z_ \\<longrightarrow>\n    ({v_, va_} \\<noteq> firstList (separate (y_ # z_)) \\<longrightarrow>\n     (\\<forall>a\\<in>set (separate (y_ # z_)).\n         {v_, va_} \\<noteq> first_bothNet a)) \\<and>\n    NetsCollected (separate (y_ # z_))", "apply (intro conjI impI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{v_, va_} \\<noteq> first_bothNet y_;\n     \\<not> member DenyAll y_ \\<and> noDenyAll z_;\n     (\\<forall>a\\<in>set z_. {v_, va_} \\<noteq> first_bothNet a) \\<and>\n     (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n      (\\<forall>a\\<in>set z_.\n          first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n     NetsCollected z_;\n     {v_, va_} \\<noteq> firstList (separate (y_ # z_));\n     noDenyAll1 (y_ # z_) \\<longrightarrow>\n     NetsCollected (separate (y_ # z_))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set (separate (y_ # z_)).\n                         {v_, va_} \\<noteq> first_bothNet a\n 2. \\<lbrakk>{v_, va_} = first_bothNet y_ \\<Longrightarrow>\n             \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n             (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n              (\\<forall>a\\<in>set z_.\n                  first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n             NetsCollected z_ \\<longrightarrow>\n             NetsCollected\n              (separate (DenyAllFromTo v_ va_ \\<oplus> y_ # z_));\n     {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n     noDenyAll1 (y_ # z_) \\<longrightarrow>\n     (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n      (\\<forall>a\\<in>set z_.\n          first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n     NetsCollected z_ \\<longrightarrow>\n     NetsCollected (separate (y_ # z_));\n     {v_, va_} \\<noteq> first_bothNet y_;\n     \\<not> member DenyAll y_ \\<and> noDenyAll z_;\n     (\\<forall>a\\<in>set z_. {v_, va_} \\<noteq> first_bothNet a) \\<and>\n     (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n      (\\<forall>a\\<in>set z_.\n          first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n     NetsCollected z_\\<rbrakk>\n    \\<Longrightarrow> NetsCollected (separate (y_ # z_))", "apply (metis NetsCollectedSepaux fl3 noDA1eq noDenyAll.simps(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{v_, va_} = first_bothNet y_ \\<Longrightarrow>\n             \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n             (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n              (\\<forall>a\\<in>set z_.\n                  first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n             NetsCollected z_ \\<longrightarrow>\n             NetsCollected\n              (separate (DenyAllFromTo v_ va_ \\<oplus> y_ # z_));\n     {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n     noDenyAll1 (y_ # z_) \\<longrightarrow>\n     (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n      (\\<forall>a\\<in>set z_.\n          first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n     NetsCollected z_ \\<longrightarrow>\n     NetsCollected (separate (y_ # z_));\n     {v_, va_} \\<noteq> first_bothNet y_;\n     \\<not> member DenyAll y_ \\<and> noDenyAll z_;\n     (\\<forall>a\\<in>set z_. {v_, va_} \\<noteq> first_bothNet a) \\<and>\n     (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n      (\\<forall>a\\<in>set z_.\n          first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n     NetsCollected z_\\<rbrakk>\n    \\<Longrightarrow> NetsCollected (separate (y_ # z_))", "by (metis noDA1eq noDenyAll.simps(1))"], ["proof (state)\nthis:\n  {v_, va_} \\<noteq> first_bothNet y_ \\<longrightarrow>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  (\\<forall>a\\<in>set z_. {v_, va_} \\<noteq> first_bothNet a) \\<and>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  ({v_, va_} \\<noteq> firstList (separate (y_ # z_)) \\<longrightarrow>\n   (\\<forall>a\\<in>set (separate (y_ # z_)).\n       {v_, va_} \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected (separate (y_ # z_))\n\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "fix v va vb y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "fix z::\"('a, 'b) Combinators list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "case 3"], ["proof (state)\nthis:\n  {v_, va_} = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate (AllowPortFromTo v_ va_ vb_ \\<oplus> y_ # z_))\n  {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate (y_ # z_))\n\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             {v, va} \\<noteq> first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         ({v, va} \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              {v, va} \\<noteq> first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "then"], ["proof (chain)\npicking this:\n  {v_, va_} = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate (AllowPortFromTo v_ va_ vb_ \\<oplus> y_ # z_))\n  {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate (y_ # z_))", "show ?case"], ["proof (prove)\nusing this:\n  {v_, va_} = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate (AllowPortFromTo v_ va_ vb_ \\<oplus> y_ # z_))\n  {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate (y_ # z_))\n\ngoal (1 subgoal):\n 1. {v_, va_} \\<noteq> first_bothNet y_ \\<longrightarrow>\n    \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n    (\\<forall>a\\<in>set z_. {v_, va_} \\<noteq> first_bothNet a) \\<and>\n    (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n     (\\<forall>a\\<in>set z_.\n         first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n    NetsCollected z_ \\<longrightarrow>\n    ({v_, va_} \\<noteq> firstList (separate (y_ # z_)) \\<longrightarrow>\n     (\\<forall>a\\<in>set (separate (y_ # z_)).\n         {v_, va_} \\<noteq> first_bothNet a)) \\<and>\n    NetsCollected (separate (y_ # z_))", "apply (intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{v_, va_} = first_bothNet y_ \\<Longrightarrow>\n             \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n             (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n              (\\<forall>a\\<in>set z_.\n                  first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n             NetsCollected z_ \\<longrightarrow>\n             NetsCollected\n              (separate (AllowPortFromTo v_ va_ vb_ \\<oplus> y_ # z_));\n     {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n     noDenyAll1 (y_ # z_) \\<longrightarrow>\n     (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n      (\\<forall>a\\<in>set z_.\n          first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n     NetsCollected z_ \\<longrightarrow>\n     NetsCollected (separate (y_ # z_));\n     {v_, va_} \\<noteq> first_bothNet y_;\n     \\<not> member DenyAll y_ \\<and> noDenyAll z_;\n     (\\<forall>a\\<in>set z_. {v_, va_} \\<noteq> first_bothNet a) \\<and>\n     (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n      (\\<forall>a\\<in>set z_.\n          first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n     NetsCollected z_;\n     {v_, va_} \\<noteq> firstList (separate (y_ # z_))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set (separate (y_ # z_)).\n                         {v_, va_} \\<noteq> first_bothNet a\n 2. \\<lbrakk>{v_, va_} = first_bothNet y_ \\<Longrightarrow>\n             \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n             (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n              (\\<forall>a\\<in>set z_.\n                  first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n             NetsCollected z_ \\<longrightarrow>\n             NetsCollected\n              (separate (AllowPortFromTo v_ va_ vb_ \\<oplus> y_ # z_));\n     {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n     noDenyAll1 (y_ # z_) \\<longrightarrow>\n     (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n      (\\<forall>a\\<in>set z_.\n          first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n     NetsCollected z_ \\<longrightarrow>\n     NetsCollected (separate (y_ # z_));\n     {v_, va_} \\<noteq> first_bothNet y_;\n     \\<not> member DenyAll y_ \\<and> noDenyAll z_;\n     (\\<forall>a\\<in>set z_. {v_, va_} \\<noteq> first_bothNet a) \\<and>\n     (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n      (\\<forall>a\\<in>set z_.\n          first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n     NetsCollected z_\\<rbrakk>\n    \\<Longrightarrow> NetsCollected (separate (y_ # z_))", "apply (metis NetsCollectedSepaux fl3 noDA1eq noDenyAll.simps(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{v_, va_} = first_bothNet y_ \\<Longrightarrow>\n             \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n             (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n              (\\<forall>a\\<in>set z_.\n                  first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n             NetsCollected z_ \\<longrightarrow>\n             NetsCollected\n              (separate (AllowPortFromTo v_ va_ vb_ \\<oplus> y_ # z_));\n     {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n     noDenyAll1 (y_ # z_) \\<longrightarrow>\n     (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n      (\\<forall>a\\<in>set z_.\n          first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n     NetsCollected z_ \\<longrightarrow>\n     NetsCollected (separate (y_ # z_));\n     {v_, va_} \\<noteq> first_bothNet y_;\n     \\<not> member DenyAll y_ \\<and> noDenyAll z_;\n     (\\<forall>a\\<in>set z_. {v_, va_} \\<noteq> first_bothNet a) \\<and>\n     (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n      (\\<forall>a\\<in>set z_.\n          first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n     NetsCollected z_\\<rbrakk>\n    \\<Longrightarrow> NetsCollected (separate (y_ # z_))", "by (metis noDA1eq noDenyAll.simps(1))"], ["proof (state)\nthis:\n  {v_, va_} \\<noteq> first_bothNet y_ \\<longrightarrow>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  (\\<forall>a\\<in>set z_. {v_, va_} \\<noteq> first_bothNet a) \\<and>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  ({v_, va_} \\<noteq> firstList (separate (y_ # z_)) \\<longrightarrow>\n   (\\<forall>a\\<in>set (separate (y_ # z_)).\n       {v_, va_} \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected (separate (y_ # z_))\n\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "fix v va y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "fix z::\"('a, 'b) Combinators list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "case 4"], ["proof (state)\nthis:\n  first_bothNet v_ = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll v_ \\<and>\n  \\<not> member DenyAll va_ \\<and>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate ((v_ \\<oplus> va_) \\<oplus> y_ # z_))\n  first_bothNet v_ \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate (y_ # z_))\n\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n                 (\\<forall>a\\<in>set z.\n                     first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n                NetsCollected z \\<longrightarrow>\n                NetsCollected (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        (first_bothNet y \\<noteq> firstList z \\<longrightarrow>\n         (\\<forall>a\\<in>set z.\n             first_bothNet y \\<noteq> first_bothNet a)) \\<and>\n        NetsCollected z \\<longrightarrow>\n        NetsCollected (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         (\\<forall>a\\<in>set z.\n                             first_bothNet v \\<noteq>\n                             first_bothNet a) \\<and>\n                         (first_bothNet y \\<noteq>\n                          firstList z \\<longrightarrow>\n                          (\\<forall>a\\<in>set z.\n                              first_bothNet y \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected z \\<longrightarrow>\n                         (first_bothNet v \\<noteq>\n                          firstList (separate (y # z)) \\<longrightarrow>\n                          (\\<forall>a\\<in>set (separate (y # z)).\n                              first_bothNet v \\<noteq>\n                              first_bothNet a)) \\<and>\n                         NetsCollected (separate (y # z))", "then"], ["proof (chain)\npicking this:\n  first_bothNet v_ = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll v_ \\<and>\n  \\<not> member DenyAll va_ \\<and>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate ((v_ \\<oplus> va_) \\<oplus> y_ # z_))\n  first_bothNet v_ \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate (y_ # z_))", "show ?case"], ["proof (prove)\nusing this:\n  first_bothNet v_ = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll v_ \\<and>\n  \\<not> member DenyAll va_ \\<and>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate ((v_ \\<oplus> va_) \\<oplus> y_ # z_))\n  first_bothNet v_ \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  NetsCollected (separate (y_ # z_))\n\ngoal (1 subgoal):\n 1. first_bothNet v_ \\<noteq> first_bothNet y_ \\<longrightarrow>\n    \\<not> member DenyAll v_ \\<and>\n    \\<not> member DenyAll va_ \\<and>\n    \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n    (\\<forall>a\\<in>set z_.\n        first_bothNet v_ \\<noteq> first_bothNet a) \\<and>\n    (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n     (\\<forall>a\\<in>set z_.\n         first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n    NetsCollected z_ \\<longrightarrow>\n    (first_bothNet v_ \\<noteq>\n     firstList (separate (y_ # z_)) \\<longrightarrow>\n     (\\<forall>a\\<in>set (separate (y_ # z_)).\n         first_bothNet v_ \\<noteq> first_bothNet a)) \\<and>\n    NetsCollected (separate (y_ # z_))", "by (metis NetsCollectedSepaux fl3 noDA1eq noDenyAll.simps(1))"], ["proof (state)\nthis:\n  first_bothNet v_ \\<noteq> first_bothNet y_ \\<longrightarrow>\n  \\<not> member DenyAll v_ \\<and>\n  \\<not> member DenyAll va_ \\<and>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  (\\<forall>a\\<in>set z_. first_bothNet v_ \\<noteq> first_bothNet a) \\<and>\n  (first_bothNet y_ \\<noteq> firstList z_ \\<longrightarrow>\n   (\\<forall>a\\<in>set z_.\n       first_bothNet y_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected z_ \\<longrightarrow>\n  (first_bothNet v_ \\<noteq>\n   firstList (separate (y_ # z_)) \\<longrightarrow>\n   (\\<forall>a\\<in>set (separate (y_ # z_)).\n       first_bothNet v_ \\<noteq> first_bothNet a)) \\<and>\n  NetsCollected (separate (y_ # z_))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OTNaux: \n  \"onlyTwoNets a \\<Longrightarrow> \\<not> member DenyAll a \\<Longrightarrow> (x,y) \\<in> sdnets a \\<Longrightarrow> \n   (x = first_srcNet a \\<and> y = first_destNet a) \\<or>   (x = first_destNet a \\<and> y = first_srcNet a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets a; \\<not> member DenyAll a;\n     (x, y) \\<in> sdnets a\\<rbrakk>\n    \\<Longrightarrow> x = first_srcNet a \\<and> y = first_destNet a \\<or>\n                      x = first_destNet a \\<and> y = first_srcNet a", "apply (case_tac \"(x = first_srcNet a \\<and> y = first_destNet a)\",simp_all add: onlyTwoNets_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>aa b. sdnets a = {(aa, b)}) \\<or>\n             (\\<exists>aa b. sdnets a = {(aa, b), (b, aa)});\n     \\<not> member DenyAll a; (x, y) \\<in> sdnets a;\n     x = first_srcNet a \\<longrightarrow>\n     y \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> x = first_srcNet a \\<and> y = first_destNet a \\<or>\n                      x = first_destNet a \\<and> y = first_srcNet a", "apply (case_tac \"(\\<exists>aa b. sdnets a = {(aa, b)})\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a; (x, y) \\<in> sdnets a;\n     x = first_srcNet a \\<longrightarrow> y \\<noteq> first_destNet a;\n     \\<exists>aa b. sdnets a = {(aa, b)}\\<rbrakk>\n    \\<Longrightarrow> x = first_srcNet a \\<and> y = first_destNet a \\<or>\n                      x = first_destNet a \\<and> y = first_srcNet a\n 2. \\<lbrakk>\\<exists>aa b. sdnets a = {(aa, b), (b, aa)};\n     \\<not> member DenyAll a; (x, y) \\<in> sdnets a;\n     x = first_srcNet a \\<longrightarrow> y \\<noteq> first_destNet a;\n     \\<forall>aa b. sdnets a \\<noteq> {(aa, b)}\\<rbrakk>\n    \\<Longrightarrow> x = first_srcNet a \\<and> y = first_destNet a \\<or>\n                      x = first_destNet a \\<and> y = first_srcNet a", "apply (subgoal_tac \"sdnets a = {(first_srcNet a,first_destNet a)}\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a; (x, y) \\<in> sdnets a;\n     x = first_srcNet a \\<longrightarrow> y \\<noteq> first_destNet a;\n     \\<exists>aa b. sdnets a = {(aa, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets a = {(first_srcNet a, first_destNet a)}\n 2. \\<lbrakk>\\<exists>aa b. sdnets a = {(aa, b), (b, aa)};\n     \\<not> member DenyAll a; (x, y) \\<in> sdnets a;\n     x = first_srcNet a \\<longrightarrow> y \\<noteq> first_destNet a;\n     \\<forall>aa b. sdnets a \\<noteq> {(aa, b)}\\<rbrakk>\n    \\<Longrightarrow> x = first_srcNet a \\<and> y = first_destNet a \\<or>\n                      x = first_destNet a \\<and> y = first_srcNet a", "apply (metis singletonE first_isIn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>aa b. sdnets a = {(aa, b), (b, aa)};\n     \\<not> member DenyAll a; (x, y) \\<in> sdnets a;\n     x = first_srcNet a \\<longrightarrow> y \\<noteq> first_destNet a;\n     \\<forall>aa b. sdnets a \\<noteq> {(aa, b)}\\<rbrakk>\n    \\<Longrightarrow> x = first_srcNet a \\<and> y = first_destNet a \\<or>\n                      x = first_destNet a \\<and> y = first_srcNet a", "apply (subgoal_tac\"sdnets a = {(first_srcNet a,first_destNet a),(first_destNet a, first_srcNet a)}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>aa b. sdnets a = {(aa, b), (b, aa)};\n     \\<not> member DenyAll a; (x, y) \\<in> sdnets a;\n     x = first_srcNet a \\<longrightarrow> y \\<noteq> first_destNet a;\n     \\<forall>aa b. sdnets a \\<noteq> {(aa, b)};\n     sdnets a =\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)}\\<rbrakk>\n    \\<Longrightarrow> x = first_srcNet a \\<and> y = first_destNet a \\<or>\n                      x = first_destNet a \\<and> y = first_srcNet a\n 2. \\<lbrakk>\\<exists>aa b. sdnets a = {(aa, b), (b, aa)};\n     \\<not> member DenyAll a; (x, y) \\<in> sdnets a;\n     x = first_srcNet a \\<longrightarrow> y \\<noteq> first_destNet a;\n     \\<forall>aa b. sdnets a \\<noteq> {(aa, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets a =\n                      {(first_srcNet a, first_destNet a),\n                       (first_destNet a, first_srcNet a)}", "by(auto intro!: sdnets2)"], ["", "lemma sdnets_charn: \"onlyTwoNets a \\<Longrightarrow> \\<not> member DenyAll a \\<Longrightarrow>\nsdnets a = {(first_srcNet a,first_destNet a)} \\<or> \nsdnets a = {(first_srcNet a, first_destNet a),(first_destNet a, first_srcNet a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets a; \\<not> member DenyAll a\\<rbrakk>\n    \\<Longrightarrow> sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n                      sdnets a =\n                      {(first_srcNet a, first_destNet a),\n                       (first_destNet a, first_srcNet a)}", "apply (case_tac \"sdnets a = {(first_srcNet a, first_destNet a)}\", simp_all add: onlyTwoNets_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>aa b. sdnets a = {(aa, b)}) \\<or>\n             (\\<exists>aa b. sdnets a = {(aa, b), (b, aa)});\n     \\<not> member DenyAll a;\n     sdnets a \\<noteq> {(first_srcNet a, first_destNet a)}\\<rbrakk>\n    \\<Longrightarrow> sdnets a =\n                      {(first_srcNet a, first_destNet a),\n                       (first_destNet a, first_srcNet a)}", "apply (case_tac \"(\\<exists>aa b. sdnets a = {(aa, b)})\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a;\n     sdnets a \\<noteq> {(first_srcNet a, first_destNet a)};\n     \\<exists>aa b. sdnets a = {(aa, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets a =\n                      {(first_srcNet a, first_destNet a),\n                       (first_destNet a, first_srcNet a)}\n 2. \\<lbrakk>\\<exists>aa b. sdnets a = {(aa, b), (b, aa)};\n     \\<not> member DenyAll a;\n     \\<forall>aa b. sdnets a \\<noteq> {(aa, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets a =\n                      {(first_srcNet a, first_destNet a),\n                       (first_destNet a, first_srcNet a)}", "apply (metis singletonE first_isIn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>aa b. sdnets a = {(aa, b), (b, aa)};\n     \\<not> member DenyAll a;\n     \\<forall>aa b. sdnets a \\<noteq> {(aa, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets a =\n                      {(first_srcNet a, first_destNet a),\n                       (first_destNet a, first_srcNet a)}", "apply (subgoal_tac \"sdnets a = {(first_srcNet a,first_destNet a),(first_destNet a,first_srcNet a)}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>aa b. sdnets a = {(aa, b), (b, aa)};\n     \\<not> member DenyAll a; \\<forall>aa b. sdnets a \\<noteq> {(aa, b)};\n     sdnets a =\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)}\\<rbrakk>\n    \\<Longrightarrow> sdnets a =\n                      {(first_srcNet a, first_destNet a),\n                       (first_destNet a, first_srcNet a)}\n 2. \\<lbrakk>\\<exists>aa b. sdnets a = {(aa, b), (b, aa)};\n     \\<not> member DenyAll a;\n     \\<forall>aa b. sdnets a \\<noteq> {(aa, b)}\\<rbrakk>\n    \\<Longrightarrow> sdnets a =\n                      {(first_srcNet a, first_destNet a),\n                       (first_destNet a, first_srcNet a)}", "by( auto intro!: sdnets2)"], ["", "lemma first_bothNet_charn[rule_format]: \n  \"\\<not> member DenyAll a \\<longrightarrow> first_bothNet a = {first_srcNet a, first_destNet a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> member DenyAll a \\<longrightarrow>\n    first_bothNet a = {first_srcNet a, first_destNet a}", "by (induct a) simp_all"], ["", "lemma sdnets_noteq:\n  \"onlyTwoNets a \\<Longrightarrow> onlyTwoNets aa \\<Longrightarrow> first_bothNet a \\<noteq> first_bothNet aa \\<Longrightarrow> \n   \\<not> member DenyAll a \\<Longrightarrow> \\<not> member DenyAll aa \\<Longrightarrow> sdnets a \\<noteq> sdnets aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa\\<rbrakk>\n    \\<Longrightarrow> sdnets a \\<noteq> sdnets aa", "apply (insert sdnets_charn [of a])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa;\n     \\<lbrakk>onlyTwoNets a; \\<not> member DenyAll a\\<rbrakk>\n     \\<Longrightarrow> sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n                       sdnets a =\n                       {(first_srcNet a, first_destNet a),\n                        (first_destNet a, first_srcNet a)}\\<rbrakk>\n    \\<Longrightarrow> sdnets a \\<noteq> sdnets aa", "apply (insert sdnets_charn [of aa])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa;\n     \\<lbrakk>onlyTwoNets a; \\<not> member DenyAll a\\<rbrakk>\n     \\<Longrightarrow> sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n                       sdnets a =\n                       {(first_srcNet a, first_destNet a),\n                        (first_destNet a, first_srcNet a)};\n     \\<lbrakk>onlyTwoNets aa; \\<not> member DenyAll aa\\<rbrakk>\n     \\<Longrightarrow> sdnets aa =\n                       {(first_srcNet aa, first_destNet aa)} \\<or>\n                       sdnets aa =\n                       {(first_srcNet aa, first_destNet aa),\n                        (first_destNet aa, first_srcNet aa)}\\<rbrakk>\n    \\<Longrightarrow> sdnets a \\<noteq> sdnets aa", "apply (insert first_bothNet_charn [of a])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa;\n     \\<lbrakk>onlyTwoNets a; \\<not> member DenyAll a\\<rbrakk>\n     \\<Longrightarrow> sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n                       sdnets a =\n                       {(first_srcNet a, first_destNet a),\n                        (first_destNet a, first_srcNet a)};\n     \\<lbrakk>onlyTwoNets aa; \\<not> member DenyAll aa\\<rbrakk>\n     \\<Longrightarrow> sdnets aa =\n                       {(first_srcNet aa, first_destNet aa)} \\<or>\n                       sdnets aa =\n                       {(first_srcNet aa, first_destNet aa),\n                        (first_destNet aa, first_srcNet aa)};\n     \\<not> member DenyAll a \\<Longrightarrow>\n     first_bothNet a = {first_srcNet a, first_destNet a}\\<rbrakk>\n    \\<Longrightarrow> sdnets a \\<noteq> sdnets aa", "apply (insert first_bothNet_charn [of aa])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa;\n     \\<lbrakk>onlyTwoNets a; \\<not> member DenyAll a\\<rbrakk>\n     \\<Longrightarrow> sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n                       sdnets a =\n                       {(first_srcNet a, first_destNet a),\n                        (first_destNet a, first_srcNet a)};\n     \\<lbrakk>onlyTwoNets aa; \\<not> member DenyAll aa\\<rbrakk>\n     \\<Longrightarrow> sdnets aa =\n                       {(first_srcNet aa, first_destNet aa)} \\<or>\n                       sdnets aa =\n                       {(first_srcNet aa, first_destNet aa),\n                        (first_destNet aa, first_srcNet aa)};\n     \\<not> member DenyAll a \\<Longrightarrow>\n     first_bothNet a = {first_srcNet a, first_destNet a};\n     \\<not> member DenyAll aa \\<Longrightarrow>\n     first_bothNet aa = {first_srcNet aa, first_destNet aa}\\<rbrakk>\n    \\<Longrightarrow> sdnets a \\<noteq> sdnets aa", "by(metis OTNaux first_isIn insert_absorb2 insert_commute)"], ["", "lemma fbn_noteq: \n  \"onlyTwoNets a \\<Longrightarrow>  onlyTwoNets aa \\<Longrightarrow>  first_bothNet a \\<noteq> first_bothNet aa \\<Longrightarrow>\n    \\<not> member DenyAll a \\<Longrightarrow>  \\<not> member DenyAll aa \\<Longrightarrow>  allNetsDistinct [a, aa] \\<Longrightarrow>\n    first_srcNet a \\<noteq> first_srcNet aa \\<or> first_srcNet a \\<noteq> first_destNet aa \\<or> \n    first_destNet a \\<noteq> first_srcNet aa \\<or> first_destNet a \\<noteq> first_destNet aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa]\\<rbrakk>\n    \\<Longrightarrow> first_srcNet a \\<noteq> first_srcNet aa \\<or>\n                      first_srcNet a \\<noteq> first_destNet aa \\<or>\n                      first_destNet a \\<noteq> first_srcNet aa \\<or>\n                      first_destNet a \\<noteq> first_destNet aa", "apply (insert sdnets_charn [of a])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<lbrakk>onlyTwoNets a; \\<not> member DenyAll a\\<rbrakk>\n     \\<Longrightarrow> sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n                       sdnets a =\n                       {(first_srcNet a, first_destNet a),\n                        (first_destNet a, first_srcNet a)}\\<rbrakk>\n    \\<Longrightarrow> first_srcNet a \\<noteq> first_srcNet aa \\<or>\n                      first_srcNet a \\<noteq> first_destNet aa \\<or>\n                      first_destNet a \\<noteq> first_srcNet aa \\<or>\n                      first_destNet a \\<noteq> first_destNet aa", "apply (insert sdnets_charn [of aa])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<lbrakk>onlyTwoNets a; \\<not> member DenyAll a\\<rbrakk>\n     \\<Longrightarrow> sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n                       sdnets a =\n                       {(first_srcNet a, first_destNet a),\n                        (first_destNet a, first_srcNet a)};\n     \\<lbrakk>onlyTwoNets aa; \\<not> member DenyAll aa\\<rbrakk>\n     \\<Longrightarrow> sdnets aa =\n                       {(first_srcNet aa, first_destNet aa)} \\<or>\n                       sdnets aa =\n                       {(first_srcNet aa, first_destNet aa),\n                        (first_destNet aa, first_srcNet aa)}\\<rbrakk>\n    \\<Longrightarrow> first_srcNet a \\<noteq> first_srcNet aa \\<or>\n                      first_srcNet a \\<noteq> first_destNet aa \\<or>\n                      first_destNet a \\<noteq> first_srcNet aa \\<or>\n                      first_destNet a \\<noteq> first_destNet aa", "by (metis first_bothNet_charn)"], ["", "lemma NCisSD2aux: \n  assumes 1: \"onlyTwoNets a\" and 2 : \"onlyTwoNets aa\" and 3 : \"first_bothNet a \\<noteq> first_bothNet aa\"\n    and   4: \"\\<not> member DenyAll a\" and 5: \"\\<not> member DenyAll aa\" and 6:\" allNetsDistinct [a, aa]\"\n  shows   \"disjSD_2 a aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjSD_2 a aa", "apply (insert 1 2 3 4 5 6)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa]\\<rbrakk>\n    \\<Longrightarrow> disjSD_2 a aa", "apply (simp add: disjSD_2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa]\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ab b c d.\n                         (ab, b) \\<in> sdnets a \\<and>\n                         (c, d) \\<in> sdnets aa \\<longrightarrow>\n                         twoNetsDistinct ab b c d \\<and>\n                         twoNetsDistinct ab b d c", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab b c d.\n       \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n        first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n        \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n        (ab, b) \\<in> sdnets a \\<and> (c, d) \\<in> sdnets aa\\<rbrakk>\n       \\<Longrightarrow> twoNetsDistinct ab b c d \\<and>\n                         twoNetsDistinct ab b d c", "apply (insert sdnets_charn [of a]  sdnets_charn [of aa], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab b c d.\n       \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n        first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n        \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n        (ab, b) \\<in> sdnets a \\<and> (c, d) \\<in> sdnets aa;\n        sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n        sdnets a =\n        {(first_srcNet a, first_destNet a),\n         (first_destNet a, first_srcNet a)};\n        sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n        sdnets aa =\n        {(first_srcNet aa, first_destNet aa),\n         (first_destNet aa, first_srcNet aa)}\\<rbrakk>\n       \\<Longrightarrow> twoNetsDistinct ab b c d \\<and>\n                         twoNetsDistinct ab b d c", "apply (insert sdnets_noteq [of a aa]  fbn_noteq [of a aa], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab b c d.\n       \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n        first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n        \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n        (ab, b) \\<in> sdnets a \\<and> (c, d) \\<in> sdnets aa;\n        sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n        sdnets a =\n        {(first_srcNet a, first_destNet a),\n         (first_destNet a, first_srcNet a)};\n        sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n        sdnets aa =\n        {(first_srcNet aa, first_destNet aa),\n         (first_destNet aa, first_srcNet aa)};\n        sdnets a \\<noteq> sdnets aa;\n        first_destNet a = first_srcNet aa \\<longrightarrow>\n        first_srcNet a = first_destNet aa \\<longrightarrow>\n        first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n       \\<Longrightarrow> twoNetsDistinct ab b c d \\<and>\n                         twoNetsDistinct ab b d c", "apply (simp add: allNetsDistinct_def twoNetsDistinct_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab b c d.\n       \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n        first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n        \\<not> member DenyAll aa;\n        \\<forall>ab b.\n           ab \\<noteq> b \\<and>\n           ab \\<in> set (net_list_aux [a, aa]) \\<and>\n           b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n           netsDistinct ab b;\n        (ab, b) \\<in> sdnets a \\<and> (c, d) \\<in> sdnets aa;\n        sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n        sdnets a =\n        {(first_srcNet a, first_destNet a),\n         (first_destNet a, first_srcNet a)};\n        sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n        sdnets aa =\n        {(first_srcNet aa, first_destNet aa),\n         (first_destNet aa, first_srcNet aa)};\n        sdnets a \\<noteq> sdnets aa;\n        first_destNet a = first_srcNet aa \\<longrightarrow>\n        first_srcNet a = first_destNet aa \\<longrightarrow>\n        first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n       \\<Longrightarrow> (netsDistinct ab c \\<or> netsDistinct b d) \\<and>\n                         (netsDistinct ab d \\<or> netsDistinct b c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ab b c d.\n       \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n        first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n        \\<not> member DenyAll aa;\n        \\<forall>ab b.\n           ab \\<noteq> b \\<and>\n           ab \\<in> set (net_list_aux [a, aa]) \\<and>\n           b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n           netsDistinct ab b;\n        (ab, b) \\<in> sdnets a \\<and> (c, d) \\<in> sdnets aa;\n        sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n        sdnets a =\n        {(first_srcNet a, first_destNet a),\n         (first_destNet a, first_srcNet a)};\n        sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n        sdnets aa =\n        {(first_srcNet aa, first_destNet aa),\n         (first_destNet aa, first_srcNet aa)};\n        sdnets a \\<noteq> sdnets aa;\n        first_destNet a = first_srcNet aa \\<longrightarrow>\n        first_srcNet a = first_destNet aa \\<longrightarrow>\n        first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n       \\<Longrightarrow> (netsDistinct ab c \\<or> netsDistinct b d) \\<and>\n                         (netsDistinct ab d \\<or> netsDistinct b c)", "fix ab b c d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ab b c d.\n       \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n        first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n        \\<not> member DenyAll aa;\n        \\<forall>ab b.\n           ab \\<noteq> b \\<and>\n           ab \\<in> set (net_list_aux [a, aa]) \\<and>\n           b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n           netsDistinct ab b;\n        (ab, b) \\<in> sdnets a \\<and> (c, d) \\<in> sdnets aa;\n        sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n        sdnets a =\n        {(first_srcNet a, first_destNet a),\n         (first_destNet a, first_srcNet a)};\n        sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n        sdnets aa =\n        {(first_srcNet aa, first_destNet aa),\n         (first_destNet aa, first_srcNet aa)};\n        sdnets a \\<noteq> sdnets aa;\n        first_destNet a = first_srcNet aa \\<longrightarrow>\n        first_srcNet a = first_destNet aa \\<longrightarrow>\n        first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n       \\<Longrightarrow> (netsDistinct ab c \\<or> netsDistinct b d) \\<and>\n                         (netsDistinct ab d \\<or> netsDistinct b c)", "assume 7: \"\\<forall>ab b. ab\\<noteq>b \\<and> ab\\<in>set(net_list_aux[a,aa]) \\<and> b\\<in>set(net_list_aux [a,aa]) \\<longrightarrow> netsDistinct ab b\"\n    and    8: \"(ab, b) \\<in> sdnets a \\<and> (c, d) \\<in> sdnets aa \"\n    and    9: \"sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n              sdnets a = {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)} \"\n    and   10: \"sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n              sdnets aa = {(first_srcNet aa, first_destNet aa), (first_destNet aa, first_srcNet aa)}\"\n    and   11: \"sdnets a \\<noteq> sdnets aa \"\n    and   12: \"first_destNet a = first_srcNet aa \\<longrightarrow> first_srcNet a = first_destNet aa \\<longrightarrow> \n              first_destNet aa \\<noteq> first_srcNet aa\""], ["proof (state)\nthis:\n  \\<forall>ab b.\n     ab \\<noteq> b \\<and>\n     ab \\<in> set (net_list_aux [a, aa]) \\<and>\n     b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n     netsDistinct ab b\n  (ab, b) \\<in> sdnets a \\<and> (c, d) \\<in> sdnets aa\n  sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n  sdnets a =\n  {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)}\n  sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n  sdnets aa =\n  {(first_srcNet aa, first_destNet aa), (first_destNet aa, first_srcNet aa)}\n  sdnets a \\<noteq> sdnets aa\n  first_destNet a = first_srcNet aa \\<longrightarrow>\n  first_srcNet a = first_destNet aa \\<longrightarrow>\n  first_destNet aa \\<noteq> first_srcNet aa\n\ngoal (1 subgoal):\n 1. \\<And>ab b c d.\n       \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n        first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n        \\<not> member DenyAll aa;\n        \\<forall>ab b.\n           ab \\<noteq> b \\<and>\n           ab \\<in> set (net_list_aux [a, aa]) \\<and>\n           b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n           netsDistinct ab b;\n        (ab, b) \\<in> sdnets a \\<and> (c, d) \\<in> sdnets aa;\n        sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n        sdnets a =\n        {(first_srcNet a, first_destNet a),\n         (first_destNet a, first_srcNet a)};\n        sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n        sdnets aa =\n        {(first_srcNet aa, first_destNet aa),\n         (first_destNet aa, first_srcNet aa)};\n        sdnets a \\<noteq> sdnets aa;\n        first_destNet a = first_srcNet aa \\<longrightarrow>\n        first_srcNet a = first_destNet aa \\<longrightarrow>\n        first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n       \\<Longrightarrow> (netsDistinct ab c \\<or> netsDistinct b d) \\<and>\n                         (netsDistinct ab d \\<or> netsDistinct b c)", "show      \"(netsDistinct ab c \\<or> netsDistinct b d) \\<and> (netsDistinct ab d \\<or> netsDistinct b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (netsDistinct ab c \\<or> netsDistinct b d) \\<and>\n    (netsDistinct ab d \\<or> netsDistinct b c)", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. netsDistinct ab c \\<or> netsDistinct b d\n 2. netsDistinct ab d \\<or> netsDistinct b c", "show \"netsDistinct ab c \\<or> netsDistinct b d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. netsDistinct ab c \\<or> netsDistinct b d", "apply(insert       7 8 9 10 11 12)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab, b) \\<in> sdnets a \\<and> (c, d) \\<in> sdnets aa;\n     sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     sdnets a \\<noteq> sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (cases \"sdnets a = {(first_srcNet a, first_destNet a)}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab, b) \\<in> sdnets a \\<and> (c, d) \\<in> sdnets aa;\n     sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     sdnets a \\<noteq> sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     sdnets a = {(first_srcNet a, first_destNet a)}\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab, b) \\<in> sdnets a \\<and> (c, d) \\<in> sdnets aa;\n     sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     sdnets a \\<noteq> sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     sdnets a \\<noteq> {(first_srcNet a, first_destNet a)}\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (cases \"sdnets aa = {(first_srcNet aa, first_destNet aa)}\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     first_srcNet a = first_srcNet aa \\<longrightarrow>\n     first_destNet a \\<noteq> first_destNet aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)}\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) c \\<or>\n                      netsDistinct (first_destNet a) d\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 4 5 firstInNeta firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) c \\<or>\n                      netsDistinct (first_destNet a) d\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (case_tac \"(c = first_srcNet aa \\<and> d = first_destNet aa)\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and> b = first_destNet a;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (case_tac \"(first_srcNet a) \\<noteq> (first_srcNet aa)\",simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and> b = first_destNet a;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     first_srcNet a \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet aa \\<and> b = first_destNet a;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     sdnets a = {(first_srcNet aa, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     first_srcNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet aa) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 4. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 4 5 firstInNeta alternativelistconc2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet aa \\<and> b = first_destNet a;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     sdnets a = {(first_srcNet aa, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     first_srcNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet aa) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (subgoal_tac \"first_destNet a \\<noteq> first_destNet aa\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet aa \\<and> b = first_destNet a;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     sdnets a = {(first_srcNet aa, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     first_srcNet a = first_srcNet aa;\n     first_destNet a \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet aa) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet aa \\<and> b = first_destNet a;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     sdnets a = {(first_srcNet aa, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     first_srcNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> first_destNet a \\<noteq> first_destNet aa\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 4. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 4 5 firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet aa \\<and> b = first_destNet a;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     sdnets a = {(first_srcNet aa, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     first_srcNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> first_destNet a \\<noteq> first_destNet aa\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 3 4 5 first_bothNetsd)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (case_tac \"(first_destNet aa) \\<noteq> (first_srcNet a)\",simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet aa \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_srcNet a \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_srcNet a), (first_srcNet a, first_srcNet aa)};\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_srcNet a \\<noteq> first_srcNet aa;\n     first_destNet aa = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet a) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 4 5 firstInNeta firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_srcNet a \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_srcNet a), (first_srcNet a, first_srcNet aa)};\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_srcNet a \\<noteq> first_srcNet aa;\n     first_destNet aa = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet a) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (case_tac \"first_destNet aa \\<noteq> first_destNet a\",simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_srcNet a \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_srcNet a), (first_srcNet a, first_srcNet aa)};\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_srcNet a \\<noteq> first_srcNet aa;\n     first_destNet aa = first_srcNet a;\n     first_srcNet a \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet a) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet a \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet a),\n      (first_destNet a, first_srcNet aa)};\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_destNet a, first_destNet a)};\n     first_destNet aa = first_destNet a;\n     first_srcNet a = first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_destNet a) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (subgoal_tac \"first_srcNet aa \\<noteq> first_destNet a\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_srcNet a \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_srcNet a), (first_srcNet a, first_srcNet aa)};\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_srcNet a \\<noteq> first_srcNet aa;\n     first_destNet aa = first_srcNet a;\n     first_srcNet a \\<noteq> first_destNet a;\n     first_srcNet aa \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet a) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_srcNet a \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_srcNet a), (first_srcNet a, first_srcNet aa)};\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_srcNet a \\<noteq> first_srcNet aa;\n     first_destNet aa = first_srcNet a;\n     first_srcNet a \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> first_srcNet aa \\<noteq> first_destNet a\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet a \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet a),\n      (first_destNet a, first_srcNet aa)};\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_destNet a, first_destNet a)};\n     first_destNet aa = first_destNet a;\n     first_srcNet a = first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_destNet a) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 4. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 4 5 firstInNeta firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_srcNet a \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_srcNet a), (first_srcNet a, first_srcNet aa)};\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_srcNet a \\<noteq> first_srcNet aa;\n     first_destNet aa = first_srcNet a;\n     first_srcNet a \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> first_srcNet aa \\<noteq> first_destNet a\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet a \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet a),\n      (first_destNet a, first_srcNet aa)};\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_destNet a, first_destNet a)};\n     first_destNet aa = first_destNet a;\n     first_srcNet a = first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_destNet a) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 3 4 5 first_bothNetsd insert_commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet a \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet a),\n      (first_destNet a, first_srcNet aa)};\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_destNet a, first_destNet a)};\n     first_destNet aa = first_destNet a;\n     first_srcNet a = first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_destNet a) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 5 firstInNeta firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (case_tac \"(c = first_srcNet aa \\<and> d = first_destNet aa)\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (first_srcNet aa, first_destNet aa) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_srcNet aa) \\<or>\n                      netsDistinct b (first_destNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<longrightarrow>\n     d \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (case_tac \"(ab = first_srcNet a \\<and> b = first_destNet a)\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (first_srcNet aa, first_destNet aa) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_destNet aa) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_destNet aa)\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<longrightarrow>\n     d \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (case_tac \"(first_srcNet a) \\<noteq> (first_srcNet aa)\",simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (first_srcNet aa, first_destNet aa) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_destNet a;\n     first_srcNet a \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (first_srcNet aa, first_destNet aa) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet aa, first_destNet a),\n      (first_destNet a, first_srcNet aa)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet aa, first_destNet a),\n      (first_destNet a, first_srcNet aa)} \\<noteq>\n     sdnets aa;\n     first_destNet a \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet aa \\<and> b = first_destNet a;\n     first_srcNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet aa) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_destNet aa) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_destNet aa)\n 4. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<longrightarrow>\n     d \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 4 5 firstInNeta alternativelistconc2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (first_srcNet aa, first_destNet aa) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet aa, first_destNet a),\n      (first_destNet a, first_srcNet aa)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet aa, first_destNet a),\n      (first_destNet a, first_srcNet aa)} \\<noteq>\n     sdnets aa;\n     first_destNet a \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet aa \\<and> b = first_destNet a;\n     first_srcNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet aa) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_destNet aa) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_destNet aa)\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<longrightarrow>\n     d \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (subgoal_tac \"first_destNet a \\<noteq> first_destNet aa\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (first_srcNet aa, first_destNet aa) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet aa, first_destNet a),\n      (first_destNet a, first_srcNet aa)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet aa, first_destNet a),\n      (first_destNet a, first_srcNet aa)} \\<noteq>\n     sdnets aa;\n     first_destNet a \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet aa \\<and> b = first_destNet a;\n     first_srcNet a = first_srcNet aa;\n     first_destNet a \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet aa) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (first_srcNet aa, first_destNet aa) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet aa, first_destNet a),\n      (first_destNet a, first_srcNet aa)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet aa, first_destNet a),\n      (first_destNet a, first_srcNet aa)} \\<noteq>\n     sdnets aa;\n     first_destNet a \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet aa \\<and> b = first_destNet a;\n     first_srcNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> first_destNet a \\<noteq> first_destNet aa\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_destNet aa) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_destNet aa)\n 4. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<longrightarrow>\n     d \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (metis  4 5 firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (first_srcNet aa, first_destNet aa) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet aa, first_destNet a),\n      (first_destNet a, first_srcNet aa)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet aa, first_destNet a),\n      (first_destNet a, first_srcNet aa)} \\<noteq>\n     sdnets aa;\n     first_destNet a \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet aa \\<and> b = first_destNet a;\n     first_srcNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> first_destNet a \\<noteq> first_destNet aa\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_destNet aa) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_destNet aa)\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<longrightarrow>\n     d \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 3 4 5 first_bothNetsd )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_destNet aa) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_destNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<longrightarrow>\n     d \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (case_tac \"(first_destNet aa) \\<noteq> (first_srcNet a)\",simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_destNet aa) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     first_destNet aa \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_destNet aa)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_srcNet a) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_srcNet a)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_srcNet a), (first_srcNet a, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_srcNet a;\n     first_destNet aa = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet a)\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<longrightarrow>\n     d \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 4 5 firstInNeta firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_srcNet a) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_srcNet a)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_srcNet a), (first_srcNet a, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_srcNet a;\n     first_destNet aa = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet a)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<longrightarrow>\n     d \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (case_tac \"first_destNet aa \\<noteq> first_destNet a\", simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_srcNet a) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_srcNet a)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_srcNet a), (first_srcNet a, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_srcNet a;\n     first_destNet aa = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet a)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_srcNet a) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_srcNet a)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_srcNet a), (first_srcNet a, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_srcNet a;\n     first_destNet aa = first_srcNet a;\n     \\<not> first_destNet aa \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet a)\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<longrightarrow>\n     d \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (subgoal_tac \"first_srcNet aa \\<noteq> first_destNet a\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_srcNet a) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_srcNet a)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_srcNet a), (first_srcNet a, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_srcNet a;\n     first_destNet aa = first_srcNet a;\n     first_srcNet aa \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet a)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_srcNet a) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_srcNet a)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_srcNet a), (first_srcNet a, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_srcNet a;\n     first_destNet aa = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> first_srcNet aa \\<noteq> first_destNet a\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_srcNet a) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_srcNet a)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_srcNet a), (first_srcNet a, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_srcNet a;\n     first_destNet aa = first_srcNet a;\n     \\<not> first_destNet aa \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet a)\n 4. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<longrightarrow>\n     d \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 4 5 firstInNeta firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_srcNet a) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_srcNet a)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_srcNet a), (first_srcNet a, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_srcNet a;\n     first_destNet aa = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> first_srcNet aa \\<noteq> first_destNet a\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_srcNet a) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_srcNet a)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_srcNet a), (first_srcNet a, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_srcNet a;\n     first_destNet aa = first_srcNet a;\n     \\<not> first_destNet aa \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet a)\n 3. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<longrightarrow>\n     d \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 3 4 5 first_bothNetsd insert_commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     ab = first_destNet a \\<and>\n     b = first_srcNet a \\<and>\n     (first_srcNet aa, first_srcNet a) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_srcNet a)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_srcNet a), (first_srcNet a, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<and> d = first_srcNet a;\n     first_destNet aa = first_srcNet a;\n     \\<not> first_destNet aa \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet a)\n 2. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<longrightarrow>\n     d \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (metis)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<longrightarrow>\n     d \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<longrightarrow>\n     d \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "assume  14 : \"(ab = first_srcNet a \\<and> b = first_destNet a \\<or> ab = first_destNet a \\<and> b = first_srcNet a) \\<and> (c, d) \\<in> sdnets aa \"\n        and     15 : \"sdnets a = {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)} \"\n        and     16 : \"sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or> sdnets aa = {(first_srcNet aa, first_destNet aa), (first_destNet aa, first_srcNet aa)} \"\n        and     17 : \"{(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)} \\<noteq> sdnets aa \"\n        and     18 : \"first_destNet a = first_srcNet aa \\<longrightarrow> first_srcNet a = first_destNet aa \\<longrightarrow> first_destNet aa \\<noteq> first_srcNet aa \"\n        and     19 : \"first_destNet a \\<noteq> first_srcNet a\"\n        and     20 : \"c = first_srcNet aa \\<longrightarrow> d \\<noteq> first_destNet aa\""], ["proof (state)\nthis:\n  (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n   ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n  (c, d) \\<in> sdnets aa\n  sdnets a =\n  {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)}\n  sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n  sdnets aa =\n  {(first_srcNet aa, first_destNet aa), (first_destNet aa, first_srcNet aa)}\n  {(first_srcNet a, first_destNet a),\n   (first_destNet a, first_srcNet a)} \\<noteq>\n  sdnets aa\n  first_destNet a = first_srcNet aa \\<longrightarrow>\n  first_srcNet a = first_destNet aa \\<longrightarrow>\n  first_destNet aa \\<noteq> first_srcNet aa\n  first_destNet a \\<noteq> first_srcNet a\n  c = first_srcNet aa \\<longrightarrow> d \\<noteq> first_destNet aa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ab b.\n                ab \\<noteq> b \\<and>\n                ab \\<in> set (net_list_aux [a, aa]) \\<and>\n                b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n                netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a;\n     c = first_srcNet aa \\<longrightarrow>\n     d \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "show \" netsDistinct ab c \\<or> netsDistinct b d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. netsDistinct ab c \\<or> netsDistinct b d", "apply (case_tac \"(ab = first_srcNet a \\<and> b = first_destNet a)\",simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ab = first_srcNet a \\<and> b = first_destNet a \\<Longrightarrow>\n    netsDistinct (first_srcNet a) c \\<or> netsDistinct (first_destNet a) d\n 2. ab = first_srcNet a \\<longrightarrow>\n    b \\<noteq> first_destNet a \\<Longrightarrow>\n    netsDistinct ab c \\<or> netsDistinct b d", "apply (case_tac \"c = first_srcNet aa\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     c = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) d\n 2. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) c \\<or>\n                      netsDistinct (first_destNet a) d\n 3. ab = first_srcNet a \\<longrightarrow>\n    b \\<noteq> first_destNet a \\<Longrightarrow>\n    netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 2 5 14 20 OTNaux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) c \\<or>\n                      netsDistinct (first_destNet a) d\n 2. ab = first_srcNet a \\<longrightarrow>\n    b \\<noteq> first_destNet a \\<Longrightarrow>\n    netsDistinct ab c \\<or> netsDistinct b d", "apply (subgoal_tac \"c = first_destNet aa\", simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) d\n 2. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> c = first_destNet aa\n 3. ab = first_srcNet a \\<longrightarrow>\n    b \\<noteq> first_destNet a \\<Longrightarrow>\n    netsDistinct ab c \\<or> netsDistinct b d", "apply (subgoal_tac \"d = first_srcNet aa\", simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa; c = first_destNet aa;\n     d = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> d = first_srcNet aa\n 3. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> c = first_destNet aa\n 4. ab = first_srcNet a \\<longrightarrow>\n    b \\<noteq> first_destNet a \\<Longrightarrow>\n    netsDistinct ab c \\<or> netsDistinct b d", "apply (case_tac \"(first_srcNet a) \\<noteq> (first_destNet aa)\",simp_all)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa; c = first_destNet aa;\n     d = first_srcNet aa; first_srcNet a \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>ab = first_destNet aa \\<and> b = first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa; c = first_destNet aa;\n     d = first_srcNet aa; first_srcNet a = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet aa)\n                       (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 3. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> d = first_srcNet aa\n 4. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> c = first_destNet aa\n 5. ab = first_srcNet a \\<longrightarrow>\n    b \\<noteq> first_destNet a \\<Longrightarrow>\n    netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 4 5 7 firstInNeta firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>ab = first_destNet aa \\<and> b = first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa; c = first_destNet aa;\n     d = first_srcNet aa; first_srcNet a = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet aa)\n                       (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> d = first_srcNet aa\n 3. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> c = first_destNet aa\n 4. ab = first_srcNet a \\<longrightarrow>\n    b \\<noteq> first_destNet a \\<Longrightarrow>\n    netsDistinct ab c \\<or> netsDistinct b d", "apply (subgoal_tac \"first_destNet a \\<noteq> first_srcNet aa\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>ab = first_destNet aa \\<and> b = first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa; c = first_destNet aa;\n     d = first_srcNet aa; first_srcNet a = first_destNet aa;\n     first_destNet a \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet aa)\n                       (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>ab = first_destNet aa \\<and> b = first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa; c = first_destNet aa;\n     d = first_srcNet aa; first_srcNet a = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> first_destNet a \\<noteq> first_srcNet aa\n 3. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> d = first_srcNet aa\n 4. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> c = first_destNet aa\n 5. ab = first_srcNet a \\<longrightarrow>\n    b \\<noteq> first_destNet a \\<Longrightarrow>\n    netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 4 5 7 firstInNeta firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>ab = first_destNet aa \\<and> b = first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa; c = first_destNet aa;\n     d = first_srcNet aa; first_srcNet a = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> first_destNet a \\<noteq> first_srcNet aa\n 2. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> d = first_srcNet aa\n 3. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> c = first_destNet aa\n 4. ab = first_srcNet a \\<longrightarrow>\n    b \\<noteq> first_destNet a \\<Longrightarrow>\n    netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 3 4 5 first_bothNetsd insert_commute)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> d = first_srcNet aa\n 2. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> c = first_destNet aa\n 3. ab = first_srcNet a \\<longrightarrow>\n    b \\<noteq> first_destNet a \\<Longrightarrow>\n    netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 2 5 14 OTNaux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ab = first_srcNet a \\<and> b = first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> c = first_destNet aa\n 2. ab = first_srcNet a \\<longrightarrow>\n    b \\<noteq> first_destNet a \\<Longrightarrow>\n    netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 2 5 14 OTNaux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ab = first_srcNet a \\<longrightarrow>\n    b \\<noteq> first_destNet a \\<Longrightarrow>\n    netsDistinct ab c \\<or> netsDistinct b d", "apply (case_tac \"c = first_srcNet aa\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     c = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_srcNet aa) \\<or>\n                      netsDistinct b d\n 2. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (metis 2 5 14 20 OTNaux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab c \\<or> netsDistinct b d", "apply (subgoal_tac \"c = first_destNet aa\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b d\n 2. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> c = first_destNet aa", "apply (subgoal_tac \"d = first_srcNet aa\", simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa; c = first_destNet aa;\n     d = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet aa)\n 2. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> d = first_srcNet aa\n 3. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> c = first_destNet aa", "apply (case_tac \"(first_destNet a) \\<noteq> (first_destNet aa)\",simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa; c = first_destNet aa;\n     d = first_srcNet aa; first_destNet a \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet aa)\n 2. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet aa;\n     first_destNet aa \\<noteq> first_srcNet aa; c = first_destNet aa;\n     d = first_srcNet aa; first_destNet a = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet aa)\n 3. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> d = first_srcNet aa\n 4. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> c = first_destNet aa", "apply (metis 4 5 7 14 firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet aa;\n     first_destNet aa \\<noteq> first_srcNet aa; c = first_destNet aa;\n     d = first_srcNet aa; first_destNet a = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet aa)\n 2. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> d = first_srcNet aa\n 3. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> c = first_destNet aa", "apply (subgoal_tac \"first_srcNet a \\<noteq> first_srcNet aa\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet aa;\n     first_destNet aa \\<noteq> first_srcNet aa; c = first_destNet aa;\n     d = first_srcNet aa; first_destNet a = first_destNet aa;\n     first_srcNet a \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet aa)\n 2. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet aa;\n     first_destNet aa \\<noteq> first_srcNet aa; c = first_destNet aa;\n     d = first_srcNet aa; first_destNet a = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> first_srcNet a \\<noteq> first_srcNet aa\n 3. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> d = first_srcNet aa\n 4. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> c = first_destNet aa", "apply (metis 4 5 7 14 firstInNeta alternativelistconc2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet aa;\n     first_destNet aa \\<noteq> first_srcNet aa; c = first_destNet aa;\n     d = first_srcNet aa; first_destNet a = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> first_srcNet a \\<noteq> first_srcNet aa\n 2. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> d = first_srcNet aa\n 3. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> c = first_destNet aa", "apply (metis 3 4 5 first_bothNetsd  insert_commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> d = first_srcNet aa\n 2. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> c = first_destNet aa", "apply (metis 2 5 14 OTNaux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ab = first_srcNet a \\<longrightarrow>\n             b \\<noteq> first_destNet a;\n     c \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> c = first_destNet aa", "apply (metis 2 5 14 OTNaux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  netsDistinct ab c \\<or> netsDistinct b d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  netsDistinct ab c \\<or> netsDistinct b d\n\ngoal (1 subgoal):\n 1. netsDistinct ab d \\<or> netsDistinct b c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. netsDistinct ab d \\<or> netsDistinct b c", "show \"netsDistinct ab d \\<or> netsDistinct b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. netsDistinct ab d \\<or> netsDistinct b c", "apply (insert 1 2 3 4 5 6 7 8 9 10 11 12)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab, b) \\<in> sdnets a \\<and> (c, d) \\<in> sdnets aa;\n     sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     sdnets a \\<noteq> sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (cases \"sdnets a = {(first_srcNet a, first_destNet a)}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab, b) \\<in> sdnets a \\<and> (c, d) \\<in> sdnets aa;\n     sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     sdnets a \\<noteq> sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     sdnets a = {(first_srcNet a, first_destNet a)}\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab, b) \\<in> sdnets a \\<and> (c, d) \\<in> sdnets aa;\n     sdnets a = {(first_srcNet a, first_destNet a)} \\<or>\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     sdnets a \\<noteq> sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     sdnets a \\<noteq> {(first_srcNet a, first_destNet a)}\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (cases \"sdnets aa = {(first_srcNet aa, first_destNet aa)}\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     first_srcNet a = first_srcNet aa \\<longrightarrow>\n     first_destNet a \\<noteq> first_destNet aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)}\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) d \\<or>\n                      netsDistinct (first_destNet a) c\n 3. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(c = first_srcNet aa \\<and> d = first_destNet aa)\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and> b = first_destNet a;\n     first_srcNet a = first_srcNet aa \\<longrightarrow>\n     first_destNet a \\<noteq> first_destNet aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) d \\<or>\n                      netsDistinct (first_destNet a) c\n 3. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(first_srcNet a) \\<noteq> (first_destNet aa)\", simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and> b = first_destNet a;\n     first_srcNet a = first_srcNet aa \\<longrightarrow>\n     first_destNet a \\<noteq> first_destNet aa;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     first_srcNet a \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet aa \\<and> b = first_destNet a;\n     first_destNet aa = first_srcNet aa \\<longrightarrow>\n     first_destNet a \\<noteq> first_srcNet aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     sdnets a = {(first_destNet aa, first_destNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     first_srcNet a = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet aa)\n                       (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 3. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) d \\<or>\n                      netsDistinct (first_destNet a) c\n 4. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (metis firstInNeta firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet aa \\<and> b = first_destNet a;\n     first_destNet aa = first_srcNet aa \\<longrightarrow>\n     first_destNet a \\<noteq> first_srcNet aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     sdnets a = {(first_destNet aa, first_destNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     first_srcNet a = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet aa)\n                       (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) d \\<or>\n                      netsDistinct (first_destNet a) c\n 3. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (subgoal_tac \"first_destNet a \\<noteq> first_srcNet aa\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet aa \\<and> b = first_destNet a;\n     first_destNet aa = first_srcNet aa \\<longrightarrow>\n     first_destNet a \\<noteq> first_srcNet aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     sdnets a = {(first_destNet aa, first_destNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     first_srcNet a = first_destNet aa;\n     first_destNet a \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet aa)\n                       (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet aa \\<and> b = first_destNet a;\n     first_destNet aa = first_srcNet aa \\<longrightarrow>\n     first_destNet a \\<noteq> first_srcNet aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     sdnets a = {(first_destNet aa, first_destNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     first_srcNet a = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> first_destNet a \\<noteq> first_srcNet aa\n 3. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) d \\<or>\n                      netsDistinct (first_destNet a) c\n 4. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (metis firstInNeta firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet aa \\<and> b = first_destNet a;\n     first_destNet aa = first_srcNet aa \\<longrightarrow>\n     first_destNet a \\<noteq> first_srcNet aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     sdnets a = {(first_destNet aa, first_destNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     first_srcNet a = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> first_destNet a \\<noteq> first_srcNet aa\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) d \\<or>\n                      netsDistinct (first_destNet a) c\n 3. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (metis first_bothNetsd insert_commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) d \\<or>\n                      netsDistinct (first_destNet a) c\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(c = first_srcNet aa \\<and> d = first_destNet aa)\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and> b = first_destNet a;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 3. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(ab = first_srcNet a \\<and> b = first_destNet a)\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 3. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(first_destNet a) \\<noteq> (first_srcNet aa)\",simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_destNet a;\n     first_destNet a \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a \\<noteq> first_srcNet aa;\n     sdnets a = {(first_srcNet a, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_srcNet aa;\n     first_destNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet aa) (first_srcNet aa)\n 3. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 4. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (metis firstInNeta firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a \\<noteq> first_srcNet aa;\n     sdnets a = {(first_srcNet a, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_srcNet aa;\n     first_destNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet aa) (first_srcNet aa)\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 3. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (subgoal_tac \"first_srcNet a \\<noteq> first_destNet aa\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a \\<noteq> first_srcNet aa;\n     sdnets a = {(first_srcNet a, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_srcNet aa;\n     first_destNet a = first_srcNet aa;\n     first_srcNet a \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet aa) (first_srcNet aa)\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a \\<noteq> first_srcNet aa;\n     sdnets a = {(first_srcNet a, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_srcNet aa;\n     first_destNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> first_srcNet a \\<noteq> first_destNet aa\n 3. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 4. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (metis firstInNeta firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a \\<noteq> first_srcNet aa;\n     sdnets a = {(first_srcNet a, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_srcNet aa;\n     first_destNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> first_srcNet a \\<noteq> first_destNet aa\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 3. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (metis first_bothNetsd insert_commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(first_srcNet aa) \\<noteq> (first_srcNet a)\",simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet aa;\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa = first_srcNet a \\<longrightarrow>\n     first_srcNet a = first_destNet a \\<longrightarrow>\n     first_srcNet aa \\<noteq> first_destNet a;\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_srcNet aa \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet a;\n     sdnets aa =\n     {(first_srcNet a, first_destNet aa),\n      (first_destNet aa, first_srcNet a)};\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet a;\n     first_srcNet aa = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet a) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 3. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (metis firstInNeta alternativelistconc2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet a;\n     sdnets aa =\n     {(first_srcNet a, first_destNet aa),\n      (first_destNet aa, first_srcNet a)};\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet a;\n     first_srcNet aa = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet a) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"first_destNet aa \\<noteq> first_destNet a\",simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet aa \\<and> d = first_srcNet a;\n     sdnets aa =\n     {(first_srcNet a, first_destNet aa),\n      (first_destNet aa, first_srcNet a)};\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet aa \\<noteq> first_srcNet a;\n     first_srcNet aa = first_srcNet a;\n     first_destNet aa \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet a) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet aa)\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet a \\<and> d = first_srcNet a;\n     sdnets aa =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet a \\<noteq> first_srcNet a;\n     first_srcNet aa = first_srcNet a;\n     first_destNet aa = first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet a) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet a)\n 3. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (metis firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and>\n     b = first_destNet a \\<and>\n     c = first_destNet a \\<and> d = first_srcNet a;\n     sdnets aa =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets a = {(first_srcNet a, first_destNet a)};\n     first_destNet a \\<noteq> first_srcNet a;\n     first_srcNet aa = first_srcNet a;\n     first_destNet aa = first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_srcNet a) \\<or>\n                      netsDistinct (first_destNet a) (first_destNet a)\n 2. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (metis first_bothNetsd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "assume 13:\" \\<forall>ab b. ab \\<noteq> b \\<and> ab\\<in>set(net_list_aux[a,aa]) \\<and> b \\<in> set(net_list_aux[a,aa])\n                             \\<longrightarrow> netsDistinct ab b \"\n        and    14 : \"(ab = first_srcNet a \\<and> b = first_destNet a \\<or> \n                        ab = first_destNet a \\<and> b = first_srcNet a) \\<and> (c, d) \\<in> sdnets aa \"\n        and    15 : \" sdnets a = {(first_srcNet a, first_destNet a), \n                                    (first_destNet a, first_srcNet a)} \"\n        and    16 : \" sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or> \n                        sdnets aa = {(first_srcNet aa, first_destNet aa), \n                                     (first_destNet aa, first_srcNet aa)} \"\n        and    17 : \" {(first_srcNet a, first_destNet a), \n                         (first_destNet a, first_srcNet a)} \\<noteq> sdnets aa \""], ["proof (state)\nthis:\n  \\<forall>ab b.\n     ab \\<noteq> b \\<and>\n     ab \\<in> set (net_list_aux [a, aa]) \\<and>\n     b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n     netsDistinct ab b\n  (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n   ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n  (c, d) \\<in> sdnets aa\n  sdnets a =\n  {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)}\n  sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n  sdnets aa =\n  {(first_srcNet aa, first_destNet aa), (first_destNet aa, first_srcNet aa)}\n  {(first_srcNet a, first_destNet a),\n   (first_destNet a, first_srcNet a)} \\<noteq>\n  sdnets aa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>onlyTwoNets a; onlyTwoNets aa;\n     first_bothNet a \\<noteq> first_bothNet aa; \\<not> member DenyAll a;\n     \\<not> member DenyAll aa; allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa;\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet a = first_destNet aa \\<longrightarrow>\n     first_destNet aa \\<noteq> first_srcNet aa;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "show   \"first_destNet a \\<noteq> first_srcNet a \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. first_destNet a \\<noteq> first_srcNet a \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (insert 1 2 3 4 5 6   13 14 15 16 17)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c, d) \\<in> sdnets aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)} \\<or>\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     sdnets aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (cases \"sdnets aa = {(first_srcNet aa, first_destNet aa)}\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet aa = first_destNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_destNet aa;\n     sdnets aa = {(first_srcNet aa, first_destNet aa)}\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet aa)\n 2. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(c = first_srcNet aa \\<and> d = first_destNet aa)\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n     ab = first_destNet a \\<and> b = first_srcNet a;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet aa = first_destNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_destNet aa;\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet aa)\n 2. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(ab = first_srcNet a \\<and> b = first_destNet a)\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet aa = first_destNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_destNet aa;\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet a \\<and> b = first_srcNet a;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet aa = first_destNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_destNet aa;\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a)\n                       (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet aa)\n 3. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(first_destNet a) \\<noteq> (first_srcNet aa)\",simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_destNet a;\n     first_destNet a \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>first_srcNet aa \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     sdnets a =\n     {(first_srcNet a, first_srcNet aa), (first_srcNet aa, first_srcNet a)};\n     first_srcNet aa = first_destNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_destNet aa;\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_srcNet aa;\n     first_destNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet aa) (first_srcNet aa)\n 3. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet a \\<and> b = first_srcNet a;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet aa = first_destNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_destNet aa;\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a)\n                       (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet aa)\n 4. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (metis firstInNeta firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_srcNet aa \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     sdnets a =\n     {(first_srcNet a, first_srcNet aa), (first_srcNet aa, first_srcNet a)};\n     first_srcNet aa = first_destNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_destNet aa;\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_srcNet aa;\n     first_destNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet aa) (first_srcNet aa)\n 2. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet a \\<and> b = first_srcNet a;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet aa = first_destNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_destNet aa;\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a)\n                       (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet aa)\n 3. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (subgoal_tac \"first_srcNet a \\<noteq> first_destNet aa\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_srcNet aa \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     sdnets a =\n     {(first_srcNet a, first_srcNet aa), (first_srcNet aa, first_srcNet a)};\n     first_srcNet aa = first_destNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_destNet aa;\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_srcNet aa;\n     first_destNet a = first_srcNet aa;\n     first_srcNet a \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet aa) (first_srcNet aa)\n 2. \\<lbrakk>first_srcNet aa \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     sdnets a =\n     {(first_srcNet a, first_srcNet aa), (first_srcNet aa, first_srcNet a)};\n     first_srcNet aa = first_destNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_destNet aa;\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_srcNet aa;\n     first_destNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> first_srcNet a \\<noteq> first_destNet aa\n 3. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet a \\<and> b = first_srcNet a;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet aa = first_destNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_destNet aa;\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a)\n                       (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet aa)\n 4. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (metis firstInNeta firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_srcNet aa \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     sdnets a =\n     {(first_srcNet a, first_srcNet aa), (first_srcNet aa, first_srcNet a)};\n     first_srcNet aa = first_destNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_destNet aa;\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_srcNet aa;\n     first_destNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> first_srcNet a \\<noteq> first_destNet aa\n 2. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet a \\<and> b = first_srcNet a;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet aa = first_destNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_destNet aa;\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a)\n                       (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet aa)\n 3. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (metis first_bothNetsd insert_commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet a \\<and> b = first_srcNet a;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet aa = first_destNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_destNet aa;\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a)\n                       (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet aa)\n 2. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(first_srcNet aa) \\<noteq> (first_srcNet a)\",simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet a \\<and> b = first_srcNet a;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     first_destNet a = first_srcNet aa \\<longrightarrow>\n     first_srcNet aa = first_destNet aa \\<longrightarrow>\n     first_srcNet a \\<noteq> first_destNet aa;\n     sdnets aa = {(first_srcNet aa, first_destNet aa)};\n     c = first_srcNet aa \\<and> d = first_destNet aa;\n     first_srcNet aa \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a)\n                       (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet aa)\n 2. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet a \\<and> b = first_srcNet a;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet a, first_destNet aa)};\n     c = first_srcNet a \\<and> d = first_destNet aa;\n     first_srcNet aa = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a)\n                       (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet a)\n 3. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (metis firstInNeta alternativelistconc2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet a \\<and> b = first_srcNet a;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet a, first_destNet aa)};\n     c = first_srcNet a \\<and> d = first_destNet aa;\n     first_srcNet aa = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a)\n                       (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet a)\n 2. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"first_destNet aa \\<noteq> first_destNet a\",simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet a \\<and> b = first_srcNet a;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet a, first_destNet aa)};\n     c = first_srcNet a \\<and> d = first_destNet aa;\n     first_srcNet aa = first_srcNet a;\n     first_destNet aa \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a)\n                       (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet a)\n 2. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet a \\<and> b = first_srcNet a;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet a, first_destNet a)};\n     c = first_srcNet a \\<and> d = first_destNet a;\n     first_srcNet aa = first_srcNet a;\n     first_destNet aa = first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_destNet a) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet a)\n 3. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (metis firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     ab = first_destNet a \\<and> b = first_srcNet a;\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa = {(first_srcNet a, first_destNet a)};\n     c = first_srcNet a \\<and> d = first_destNet a;\n     first_srcNet aa = first_srcNet a;\n     first_destNet aa = first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_destNet a) (first_destNet a) \\<or>\n                      netsDistinct (first_srcNet a) (first_srcNet a)\n 2. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (metis first_bothNetsd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "assume 20: \"{(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)} \\<noteq>\n                        {(first_srcNet aa, first_destNet aa), (first_destNet aa, first_srcNet aa)}\"\n          and    21: \"first_destNet a \\<noteq> first_srcNet a\""], ["proof (state)\nthis:\n  {(first_srcNet a, first_destNet a),\n   (first_destNet a, first_srcNet a)} \\<noteq>\n  {(first_srcNet aa, first_destNet aa), (first_destNet aa, first_srcNet aa)}\n  first_destNet a \\<noteq> first_srcNet a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>first_destNet a \\<noteq> first_srcNet a; onlyTwoNets a;\n     onlyTwoNets aa; first_bothNet a \\<noteq> first_bothNet aa;\n     \\<not> member DenyAll a; \\<not> member DenyAll aa;\n     allNetsDistinct [a, aa];\n     \\<forall>ab b.\n        ab \\<noteq> b \\<and>\n        ab \\<in> set (net_list_aux [a, aa]) \\<and>\n        b \\<in> set (net_list_aux [a, aa]) \\<longrightarrow>\n        netsDistinct ab b;\n     (ab = first_srcNet a \\<and> b = first_destNet a \\<or>\n      ab = first_destNet a \\<and> b = first_srcNet a) \\<and>\n     (c = first_srcNet aa \\<and> d = first_destNet aa \\<or>\n      c = first_destNet aa \\<and> d = first_srcNet aa);\n     sdnets a =\n     {(first_srcNet a, first_destNet a), (first_destNet a, first_srcNet a)};\n     sdnets aa =\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     {(first_srcNet a, first_destNet a),\n      (first_destNet a, first_srcNet a)} \\<noteq>\n     {(first_srcNet aa, first_destNet aa),\n      (first_destNet aa, first_srcNet aa)};\n     first_destNet aa \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "show       \"netsDistinct ab d \\<or> netsDistinct b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(c = first_srcNet aa \\<and> d = first_destNet aa)\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. c = first_srcNet aa \\<and> d = first_destNet aa \\<Longrightarrow>\n    netsDistinct ab (first_destNet aa) \\<or>\n    netsDistinct b (first_srcNet aa)\n 2. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(ab = first_srcNet a \\<and> b = first_destNet a)\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<longrightarrow>\n     b \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet aa)\n 3. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(first_destNet a) \\<noteq> (first_srcNet aa)\", simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_destNet a;\n     first_destNet a \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_destNet a) (first_srcNet aa)\n 2. \\<lbrakk>c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_srcNet aa;\n     first_destNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet aa) (first_srcNet aa)\n 3. \\<lbrakk>c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<longrightarrow>\n     b \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet aa)\n 4. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (metis 4 5 7 firstInNeta firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_srcNet aa;\n     first_destNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet aa) (first_srcNet aa)\n 2. \\<lbrakk>c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<longrightarrow>\n     b \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet aa)\n 3. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (subgoal_tac \"first_srcNet a \\<noteq> first_destNet aa\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_srcNet aa;\n     first_destNet a = first_srcNet aa;\n     first_srcNet a \\<noteq> first_destNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct (first_srcNet a) (first_destNet aa) \\<or>\n                      netsDistinct (first_srcNet aa) (first_srcNet aa)\n 2. \\<lbrakk>c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_srcNet aa;\n     first_destNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> first_srcNet a \\<noteq> first_destNet aa\n 3. \\<lbrakk>c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<longrightarrow>\n     b \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet aa)\n 4. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (metis 4 5 7 firstInNeta firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<and> b = first_srcNet aa;\n     first_destNet a = first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> first_srcNet a \\<noteq> first_destNet aa\n 2. \\<lbrakk>c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<longrightarrow>\n     b \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet aa)\n 3. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (metis 20 insert_commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<longrightarrow>\n     b \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet aa)\n 2. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(first_srcNet aa) \\<noteq> (first_srcNet a)\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>c = first_srcNet aa \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<longrightarrow> b \\<noteq> first_destNet a;\n     first_srcNet aa \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet aa)\n 2. \\<lbrakk>c = first_srcNet a \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<longrightarrow> b \\<noteq> first_destNet a;\n     first_srcNet aa = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet a)\n 3. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (metis 4 5 13 14  firstInNeta alternativelistconc2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c = first_srcNet a \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<longrightarrow> b \\<noteq> first_destNet a;\n     first_srcNet aa = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet a)\n 2. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"first_destNet aa \\<noteq> first_destNet a\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>c = first_srcNet a \\<and> d = first_destNet aa;\n     ab = first_srcNet a \\<longrightarrow> b \\<noteq> first_destNet a;\n     first_srcNet aa = first_srcNet a;\n     first_destNet aa \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet aa) \\<or>\n                      netsDistinct b (first_srcNet a)\n 2. \\<lbrakk>c = first_srcNet a \\<and> d = first_destNet a;\n     ab = first_srcNet a \\<longrightarrow> b \\<noteq> first_destNet a;\n     first_srcNet aa = first_srcNet a;\n     first_destNet aa = first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet a) \\<or>\n                      netsDistinct b (first_srcNet a)\n 3. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (metis 4 5 13 14  firstInNet alternativelistconc2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c = first_srcNet a \\<and> d = first_destNet a;\n     ab = first_srcNet a \\<longrightarrow> b \\<noteq> first_destNet a;\n     first_srcNet aa = first_srcNet a;\n     first_destNet aa = first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet a) \\<or>\n                      netsDistinct b (first_srcNet a)\n 2. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(ab = first_srcNet a \\<and> b = first_destNet a)\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c = first_srcNet a \\<and> d = first_destNet a;\n     ab = first_srcNet a \\<longrightarrow> b \\<noteq> first_destNet a;\n     first_srcNet aa = first_srcNet a;\n     first_destNet aa = first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet a) \\<or>\n                      netsDistinct b (first_srcNet a)\n 2. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(first_destNet a) \\<noteq> (first_srcNet aa)\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>c = first_srcNet a \\<and> d = first_destNet a;\n     ab = first_srcNet a \\<longrightarrow> b \\<noteq> first_destNet a;\n     first_srcNet aa = first_srcNet a; first_destNet aa = first_destNet a;\n     first_destNet a \\<noteq> first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_destNet a) \\<or>\n                      netsDistinct b (first_srcNet a)\n 2. \\<lbrakk>c = first_srcNet a \\<and> d = first_srcNet a;\n     ab = first_srcNet a \\<longrightarrow> b \\<noteq> first_srcNet a;\n     first_srcNet aa = first_srcNet a; first_destNet aa = first_srcNet a;\n     first_destNet a = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_srcNet a) \\<or>\n                      netsDistinct b (first_srcNet a)\n 3. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (metis  20)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c = first_srcNet a \\<and> d = first_srcNet a;\n     ab = first_srcNet a \\<longrightarrow> b \\<noteq> first_srcNet a;\n     first_srcNet aa = first_srcNet a; first_destNet aa = first_srcNet a;\n     first_destNet a = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_srcNet a) \\<or>\n                      netsDistinct b (first_srcNet a)\n 2. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (subgoal_tac \"first_srcNet a \\<noteq> first_srcNet aa\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>c = first_srcNet a \\<and> d = first_srcNet a;\n     ab = first_srcNet a \\<longrightarrow> b \\<noteq> first_srcNet a;\n     first_srcNet aa = first_srcNet a; first_destNet aa = first_srcNet a;\n     first_destNet a = first_srcNet a;\n     first_srcNet a \\<noteq> first_srcNet aa\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab (first_srcNet a) \\<or>\n                      netsDistinct b (first_srcNet a)\n 2. \\<lbrakk>c = first_srcNet a \\<and> d = first_srcNet a;\n     ab = first_srcNet a \\<longrightarrow> b \\<noteq> first_srcNet a;\n     first_srcNet aa = first_srcNet a; first_destNet aa = first_srcNet a;\n     first_destNet a = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> first_srcNet a \\<noteq> first_srcNet aa\n 3. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (metis  20)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c = first_srcNet a \\<and> d = first_srcNet a;\n     ab = first_srcNet a \\<longrightarrow> b \\<noteq> first_srcNet a;\n     first_srcNet aa = first_srcNet a; first_destNet aa = first_srcNet a;\n     first_destNet a = first_srcNet a\\<rbrakk>\n    \\<Longrightarrow> first_srcNet a \\<noteq> first_srcNet aa\n 2. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (metis 21)"], ["proof (prove)\ngoal (1 subgoal):\n 1. c = first_srcNet aa \\<longrightarrow>\n    d \\<noteq> first_destNet aa \\<Longrightarrow>\n    netsDistinct ab d \\<or> netsDistinct b c", "apply (case_tac \"(first_srcNet aa) \\<noteq> (first_destNet a)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c = first_srcNet aa \\<longrightarrow>\n             d \\<noteq> first_destNet aa;\n     first_srcNet aa \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c\n 2. \\<lbrakk>c = first_srcNet aa \\<longrightarrow>\n             d \\<noteq> first_destNet aa;\n     \\<not> first_srcNet aa \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "apply (metis (no_types, lifting)  2 3 4 5 7 14 OTNaux \n              firstInNet firstInNeta first_bothNetsd isInAlternativeList)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c = first_srcNet aa \\<longrightarrow>\n             d \\<noteq> first_destNet aa;\n     \\<not> first_srcNet aa \\<noteq> first_destNet a\\<rbrakk>\n    \\<Longrightarrow> netsDistinct ab d \\<or> netsDistinct b c", "by (metis 2 4 5 7 20 14 OTNaux doubleton_eq_iff firstInNet \n              firstInNeta isInAlternativeList)"], ["proof (state)\nthis:\n  netsDistinct ab d \\<or> netsDistinct b c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  first_destNet a \\<noteq> first_srcNet a \\<Longrightarrow>\n  netsDistinct ab d \\<or> netsDistinct b c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  netsDistinct ab d \\<or> netsDistinct b c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (netsDistinct ab c \\<or> netsDistinct b d) \\<and>\n  (netsDistinct ab d \\<or> netsDistinct b c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ANDaux3[rule_format]: \n  \"y \\<in> set xs \\<longrightarrow> a \\<in> set (net_list_aux [y]) \\<longrightarrow>  a \\<in> set (net_list_aux xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set xs \\<longrightarrow>\n    a \\<in> set (net_list_aux [y]) \\<longrightarrow>\n    a \\<in> set (net_list_aux xs)", "by (induct xs) (simp_all add: isInAlternativeList)"], ["", "lemma ANDaux2: \n  \"allNetsDistinct (x # xs) \\<Longrightarrow> y \\<in> set xs \\<Longrightarrow> allNetsDistinct [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allNetsDistinct (x # xs); y \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct [x, y]", "apply (simp add: allNetsDistinct_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b.\n                a \\<noteq> b \\<and>\n                a \\<in> set (net_list_aux (x # xs)) \\<and>\n                b \\<in> set (net_list_aux (x # xs)) \\<longrightarrow>\n                netsDistinct a b;\n     y \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b.\n                         a \\<noteq> b \\<and>\n                         a \\<in> set (net_list_aux [x, y]) \\<and>\n                         b \\<in> set (net_list_aux [x, y]) \\<longrightarrow>\n                         netsDistinct a b", "by (meson ANDaux3 isInAlternativeList netlistaux)"], ["", "lemma NCisSD2[rule_format]: \n  \"\\<not> member DenyAll a     \\<Longrightarrow>  OnlyTwoNets (a#p) \\<Longrightarrow> \n  NetsCollected2 (a # p) \\<Longrightarrow> NetsCollected (a#p) \\<Longrightarrow>\n  noDenyAll ( p) \\<Longrightarrow> allNetsDistinct (a # p) \\<Longrightarrow> s \\<in> set p \\<Longrightarrow>\n  disjSD_2 a s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll a; OnlyTwoNets (a # p);\n     NetsCollected2 (a # p); NetsCollected (a # p); noDenyAll p;\n     allNetsDistinct (a # p); s \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> disjSD_2 a s", "by (metis ANDaux2 FWNormalisationCore.member.simps(2) NCisSD2aux NetsCollected.simps(1) \n      NetsCollected2.simps(1) OTNConc OTNoTN empty_iff empty_set list.set_intros(1) noDA)"], ["", "lemma separatedNC[rule_format]: \n  \"OnlyTwoNets p \\<longrightarrow> NetsCollected2 p \\<longrightarrow> NetsCollected p \\<longrightarrow> noDenyAll1 p \\<longrightarrow>  \n   allNetsDistinct p  \\<longrightarrow> separated p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OnlyTwoNets p \\<longrightarrow>\n    NetsCollected2 p \\<longrightarrow>\n    NetsCollected p \\<longrightarrow>\n    noDenyAll1 p \\<longrightarrow>\n    allNetsDistinct p \\<longrightarrow> separated p", "proof (induct p, simp_all, rename_tac a b, case_tac \"a = DenyAll\", simp_all, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>OnlyTwoNets b \\<longrightarrow>\n                NetsCollected2 b \\<longrightarrow>\n                NetsCollected b \\<longrightarrow>\n                noDenyAll1 b \\<longrightarrow>\n                allNetsDistinct b \\<longrightarrow> separated b;\n        a = DenyAll\\<rbrakk>\n       \\<Longrightarrow> OnlyTwoNets b \\<longrightarrow>\n                         {} \\<noteq> firstList b \\<and>\n                         NetsCollected2 b \\<longrightarrow>\n                         (\\<forall>a\\<in>set b.\n                             {} \\<noteq> first_bothNet a) \\<and>\n                         NetsCollected b \\<longrightarrow>\n                         noDenyAll b \\<longrightarrow>\n                         allNetsDistinct (DenyAll # b) \\<longrightarrow>\n                         (\\<forall>s.\n                             s \\<in> set b \\<longrightarrow>\n                             disjSD_2 DenyAll s) \\<and>\n                         separated b\n 2. \\<And>a b.\n       \\<lbrakk>OnlyTwoNets b \\<longrightarrow>\n                NetsCollected2 b \\<longrightarrow>\n                NetsCollected b \\<longrightarrow>\n                noDenyAll1 b \\<longrightarrow>\n                allNetsDistinct b \\<longrightarrow> separated b;\n        a \\<noteq> DenyAll\\<rbrakk>\n       \\<Longrightarrow> OnlyTwoNets (a # b) \\<longrightarrow>\n                         first_bothNet a \\<noteq> firstList b \\<and>\n                         NetsCollected2 b \\<longrightarrow>\n                         (\\<forall>aa\\<in>set b.\n                             first_bothNet a \\<noteq>\n                             first_bothNet aa) \\<and>\n                         NetsCollected b \\<longrightarrow>\n                         noDenyAll1 (a # b) \\<longrightarrow>\n                         allNetsDistinct (a # b) \\<longrightarrow>\n                         (\\<forall>s.\n                             s \\<in> set b \\<longrightarrow>\n                             disjSD_2 a s) \\<and>\n                         separated b", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>OnlyTwoNets b \\<longrightarrow>\n                NetsCollected2 b \\<longrightarrow>\n                NetsCollected b \\<longrightarrow>\n                noDenyAll1 b \\<longrightarrow>\n                allNetsDistinct b \\<longrightarrow> separated b;\n        a = DenyAll\\<rbrakk>\n       \\<Longrightarrow> OnlyTwoNets b \\<longrightarrow>\n                         {} \\<noteq> firstList b \\<and>\n                         NetsCollected2 b \\<longrightarrow>\n                         (\\<forall>a\\<in>set b.\n                             {} \\<noteq> first_bothNet a) \\<and>\n                         NetsCollected b \\<longrightarrow>\n                         noDenyAll b \\<longrightarrow>\n                         allNetsDistinct (DenyAll # b) \\<longrightarrow>\n                         (\\<forall>s.\n                             s \\<in> set b \\<longrightarrow>\n                             disjSD_2 DenyAll s) \\<and>\n                         separated b\n 2. \\<And>a b.\n       \\<lbrakk>OnlyTwoNets b \\<longrightarrow>\n                NetsCollected2 b \\<longrightarrow>\n                NetsCollected b \\<longrightarrow>\n                noDenyAll1 b \\<longrightarrow>\n                allNetsDistinct b \\<longrightarrow> separated b;\n        a \\<noteq> DenyAll\\<rbrakk>\n       \\<Longrightarrow> OnlyTwoNets (a # b) \\<longrightarrow>\n                         first_bothNet a \\<noteq> firstList b \\<and>\n                         NetsCollected2 b \\<longrightarrow>\n                         (\\<forall>aa\\<in>set b.\n                             first_bothNet a \\<noteq>\n                             first_bothNet aa) \\<and>\n                         NetsCollected b \\<longrightarrow>\n                         noDenyAll1 (a # b) \\<longrightarrow>\n                         allNetsDistinct (a # b) \\<longrightarrow>\n                         (\\<forall>s.\n                             s \\<in> set b \\<longrightarrow>\n                             disjSD_2 a s) \\<and>\n                         separated b", "fix p::\"('a set set, 'b) Combinators list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>OnlyTwoNets b \\<longrightarrow>\n                NetsCollected2 b \\<longrightarrow>\n                NetsCollected b \\<longrightarrow>\n                noDenyAll1 b \\<longrightarrow>\n                allNetsDistinct b \\<longrightarrow> separated b;\n        a = DenyAll\\<rbrakk>\n       \\<Longrightarrow> OnlyTwoNets b \\<longrightarrow>\n                         {} \\<noteq> firstList b \\<and>\n                         NetsCollected2 b \\<longrightarrow>\n                         (\\<forall>a\\<in>set b.\n                             {} \\<noteq> first_bothNet a) \\<and>\n                         NetsCollected b \\<longrightarrow>\n                         noDenyAll b \\<longrightarrow>\n                         allNetsDistinct (DenyAll # b) \\<longrightarrow>\n                         (\\<forall>s.\n                             s \\<in> set b \\<longrightarrow>\n                             disjSD_2 DenyAll s) \\<and>\n                         separated b\n 2. \\<And>a b.\n       \\<lbrakk>OnlyTwoNets b \\<longrightarrow>\n                NetsCollected2 b \\<longrightarrow>\n                NetsCollected b \\<longrightarrow>\n                noDenyAll1 b \\<longrightarrow>\n                allNetsDistinct b \\<longrightarrow> separated b;\n        a \\<noteq> DenyAll\\<rbrakk>\n       \\<Longrightarrow> OnlyTwoNets (a # b) \\<longrightarrow>\n                         first_bothNet a \\<noteq> firstList b \\<and>\n                         NetsCollected2 b \\<longrightarrow>\n                         (\\<forall>aa\\<in>set b.\n                             first_bothNet a \\<noteq>\n                             first_bothNet aa) \\<and>\n                         NetsCollected b \\<longrightarrow>\n                         noDenyAll1 (a # b) \\<longrightarrow>\n                         allNetsDistinct (a # b) \\<longrightarrow>\n                         (\\<forall>s.\n                             s \\<in> set b \\<longrightarrow>\n                             disjSD_2 a s) \\<and>\n                         separated b", "show  \"OnlyTwoNets p \\<longrightarrow> NetsCollected2 p \\<longrightarrow> NetsCollected p \\<longrightarrow> noDenyAll1 p \\<longrightarrow> \n          allNetsDistinct p \\<longrightarrow> separated p \\<Longrightarrow> a \\<noteq> DenyAll \\<Longrightarrow>  OnlyTwoNets (a # p) \\<longrightarrow>\n          first_bothNet a \\<noteq> firstList p \\<and> NetsCollected2 p \\<longrightarrow>\n          (\\<forall>aa\\<in>set p. first_bothNet a \\<noteq> first_bothNet aa) \\<and> NetsCollected p \\<longrightarrow>\n          noDenyAll1 (a # p) \\<longrightarrow> allNetsDistinct (a # p) \\<longrightarrow> (\\<forall>s. s \\<in> set p \\<longrightarrow> \n          disjSD_2 a s) \\<and> separated p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n             NetsCollected2 p \\<longrightarrow>\n             NetsCollected p \\<longrightarrow>\n             noDenyAll1 p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow> separated p;\n     a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets (a # p) \\<longrightarrow>\n                      first_bothNet a \\<noteq> firstList p \\<and>\n                      NetsCollected2 p \\<longrightarrow>\n                      (\\<forall>aa\\<in>set p.\n                          first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n                      NetsCollected p \\<longrightarrow>\n                      noDenyAll1 (a # p) \\<longrightarrow>\n                      allNetsDistinct (a # p) \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated p", "apply (intro impI,drule mp, erule OTNConc,drule mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> DenyAll; OnlyTwoNets (a # p);\n     first_bothNet a \\<noteq> firstList p \\<and> NetsCollected2 p;\n     (\\<forall>aa\\<in>set p.\n         first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n     NetsCollected p;\n     noDenyAll1 (a # p); allNetsDistinct (a # p)\\<rbrakk>\n    \\<Longrightarrow> NetsCollected2 p\n 2. \\<lbrakk>a \\<noteq> DenyAll; OnlyTwoNets (a # p);\n     first_bothNet a \\<noteq> firstList p \\<and> NetsCollected2 p;\n     (\\<forall>aa\\<in>set p.\n         first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n     NetsCollected p;\n     noDenyAll1 (a # p); allNetsDistinct (a # p);\n     NetsCollected p \\<longrightarrow>\n     noDenyAll1 p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> separated p\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated p", "apply (case_tac p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> DenyAll; OnlyTwoNets (a # p);\n     first_bothNet a \\<noteq> firstList p \\<and> NetsCollected2 p;\n     (\\<forall>aa\\<in>set p.\n         first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n     NetsCollected p;\n     noDenyAll1 (a # p); allNetsDistinct (a # p);\n     noDenyAll1 p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> separated p\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated p", "apply (drule mp,erule noDA1C, intro conjI  allI impI  NCisSD2, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>a \\<noteq> DenyAll; OnlyTwoNets (a # p);\n        first_bothNet a \\<noteq> firstList p \\<and> NetsCollected2 p;\n        (\\<forall>aa\\<in>set p.\n            first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n        NetsCollected p;\n        noDenyAll1 (a # p); allNetsDistinct (a # p);\n        allNetsDistinct p \\<longrightarrow> separated p;\n        s \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> \\<not> member DenyAll a\n 2. \\<And>s.\n       \\<lbrakk>a \\<noteq> DenyAll; OnlyTwoNets (a # p);\n        first_bothNet a \\<noteq> firstList p \\<and> NetsCollected2 p;\n        (\\<forall>aa\\<in>set p.\n            first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n        NetsCollected p;\n        noDenyAll1 (a # p); allNetsDistinct (a # p);\n        allNetsDistinct p \\<longrightarrow> separated p;\n        s \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> noDenyAll p\n 3. \\<lbrakk>a \\<noteq> DenyAll; OnlyTwoNets (a # p);\n     first_bothNet a \\<noteq> firstList p \\<and> NetsCollected2 p;\n     (\\<forall>aa\\<in>set p.\n         first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n     NetsCollected p;\n     noDenyAll1 (a # p); allNetsDistinct (a # p);\n     allNetsDistinct p \\<longrightarrow> separated p\\<rbrakk>\n    \\<Longrightarrow> separated p", "apply (case_tac a, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>a \\<noteq> DenyAll; OnlyTwoNets (a # p);\n        first_bothNet a \\<noteq> firstList p \\<and> NetsCollected2 p;\n        (\\<forall>aa\\<in>set p.\n            first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n        NetsCollected p;\n        noDenyAll1 (a # p); allNetsDistinct (a # p);\n        allNetsDistinct p \\<longrightarrow> separated p;\n        s \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> noDenyAll p\n 2. \\<lbrakk>a \\<noteq> DenyAll; OnlyTwoNets (a # p);\n     first_bothNet a \\<noteq> firstList p \\<and> NetsCollected2 p;\n     (\\<forall>aa\\<in>set p.\n         first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n     NetsCollected p;\n     noDenyAll1 (a # p); allNetsDistinct (a # p);\n     allNetsDistinct p \\<longrightarrow> separated p\\<rbrakk>\n    \\<Longrightarrow> separated p", "apply (case_tac a, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> DenyAll; OnlyTwoNets (a # p);\n     first_bothNet a \\<noteq> firstList p \\<and> NetsCollected2 p;\n     (\\<forall>aa\\<in>set p.\n         first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n     NetsCollected p;\n     noDenyAll1 (a # p); allNetsDistinct (a # p);\n     allNetsDistinct p \\<longrightarrow> separated p\\<rbrakk>\n    \\<Longrightarrow> separated p", "using ANDConc"], ["proof (prove)\nusing this:\n  allNetsDistinct (?a # ?p) \\<Longrightarrow> allNetsDistinct ?p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> DenyAll; OnlyTwoNets (a # p);\n     first_bothNet a \\<noteq> firstList p \\<and> NetsCollected2 p;\n     (\\<forall>aa\\<in>set p.\n         first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n     NetsCollected p;\n     noDenyAll1 (a # p); allNetsDistinct (a # p);\n     allNetsDistinct p \\<longrightarrow> separated p\\<rbrakk>\n    \\<Longrightarrow> separated p", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n           NetsCollected2 p \\<longrightarrow>\n           NetsCollected p \\<longrightarrow>\n           noDenyAll1 p \\<longrightarrow>\n           allNetsDistinct p \\<longrightarrow> separated p;\n   a \\<noteq> DenyAll\\<rbrakk>\n  \\<Longrightarrow> OnlyTwoNets (a # p) \\<longrightarrow>\n                    first_bothNet a \\<noteq> firstList p \\<and>\n                    NetsCollected2 p \\<longrightarrow>\n                    (\\<forall>aa\\<in>set p.\n                        first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n                    NetsCollected p \\<longrightarrow>\n                    noDenyAll1 (a # p) \\<longrightarrow>\n                    allNetsDistinct (a # p) \\<longrightarrow>\n                    (\\<forall>s.\n                        s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n                    separated p\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>OnlyTwoNets b \\<longrightarrow>\n                NetsCollected2 b \\<longrightarrow>\n                NetsCollected b \\<longrightarrow>\n                noDenyAll1 b \\<longrightarrow>\n                allNetsDistinct b \\<longrightarrow> separated b;\n        a = DenyAll\\<rbrakk>\n       \\<Longrightarrow> OnlyTwoNets b \\<longrightarrow>\n                         {} \\<noteq> firstList b \\<and>\n                         NetsCollected2 b \\<longrightarrow>\n                         (\\<forall>a\\<in>set b.\n                             {} \\<noteq> first_bothNet a) \\<and>\n                         NetsCollected b \\<longrightarrow>\n                         noDenyAll b \\<longrightarrow>\n                         allNetsDistinct (DenyAll # b) \\<longrightarrow>\n                         (\\<forall>s.\n                             s \\<in> set b \\<longrightarrow>\n                             disjSD_2 DenyAll s) \\<and>\n                         separated b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>OnlyTwoNets b \\<longrightarrow>\n                NetsCollected2 b \\<longrightarrow>\n                NetsCollected b \\<longrightarrow>\n                noDenyAll1 b \\<longrightarrow>\n                allNetsDistinct b \\<longrightarrow> separated b;\n        a = DenyAll\\<rbrakk>\n       \\<Longrightarrow> OnlyTwoNets b \\<longrightarrow>\n                         {} \\<noteq> firstList b \\<and>\n                         NetsCollected2 b \\<longrightarrow>\n                         (\\<forall>a\\<in>set b.\n                             {} \\<noteq> first_bothNet a) \\<and>\n                         NetsCollected b \\<longrightarrow>\n                         noDenyAll b \\<longrightarrow>\n                         allNetsDistinct (DenyAll # b) \\<longrightarrow>\n                         (\\<forall>s.\n                             s \\<in> set b \\<longrightarrow>\n                             disjSD_2 DenyAll s) \\<and>\n                         separated b", "fix a::\"('a set set,'b) Combinators \""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>OnlyTwoNets b \\<longrightarrow>\n                NetsCollected2 b \\<longrightarrow>\n                NetsCollected b \\<longrightarrow>\n                noDenyAll1 b \\<longrightarrow>\n                allNetsDistinct b \\<longrightarrow> separated b;\n        a = DenyAll\\<rbrakk>\n       \\<Longrightarrow> OnlyTwoNets b \\<longrightarrow>\n                         {} \\<noteq> firstList b \\<and>\n                         NetsCollected2 b \\<longrightarrow>\n                         (\\<forall>a\\<in>set b.\n                             {} \\<noteq> first_bothNet a) \\<and>\n                         NetsCollected b \\<longrightarrow>\n                         noDenyAll b \\<longrightarrow>\n                         allNetsDistinct (DenyAll # b) \\<longrightarrow>\n                         (\\<forall>s.\n                             s \\<in> set b \\<longrightarrow>\n                             disjSD_2 DenyAll s) \\<and>\n                         separated b", "fix p ::\"('a set set,'b) Combinators list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>OnlyTwoNets b \\<longrightarrow>\n                NetsCollected2 b \\<longrightarrow>\n                NetsCollected b \\<longrightarrow>\n                noDenyAll1 b \\<longrightarrow>\n                allNetsDistinct b \\<longrightarrow> separated b;\n        a = DenyAll\\<rbrakk>\n       \\<Longrightarrow> OnlyTwoNets b \\<longrightarrow>\n                         {} \\<noteq> firstList b \\<and>\n                         NetsCollected2 b \\<longrightarrow>\n                         (\\<forall>a\\<in>set b.\n                             {} \\<noteq> first_bothNet a) \\<and>\n                         NetsCollected b \\<longrightarrow>\n                         noDenyAll b \\<longrightarrow>\n                         allNetsDistinct (DenyAll # b) \\<longrightarrow>\n                         (\\<forall>s.\n                             s \\<in> set b \\<longrightarrow>\n                             disjSD_2 DenyAll s) \\<and>\n                         separated b", "show  \"OnlyTwoNets p \\<longrightarrow> NetsCollected2 p \\<longrightarrow> NetsCollected p \\<longrightarrow> noDenyAll1 p \\<longrightarrow> \n          allNetsDistinct p \\<longrightarrow> separated p \\<Longrightarrow>  a = DenyAll \\<Longrightarrow>  OnlyTwoNets p \\<longrightarrow>\n          {}\\<noteq>firstList p \\<and> NetsCollected2 p \\<longrightarrow> (\\<forall>a\\<in>set p. {}\\<noteq>first_bothNet a)\\<and>NetsCollected p \\<longrightarrow>\n          noDenyAll p \\<longrightarrow> allNetsDistinct (DenyAll # p) \\<longrightarrow> \n          (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 DenyAll s) \\<and> separated p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n             NetsCollected2 p \\<longrightarrow>\n             NetsCollected p \\<longrightarrow>\n             noDenyAll1 p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow> separated p;\n     a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets p \\<longrightarrow>\n                      {} \\<noteq> firstList p \\<and>\n                      NetsCollected2 p \\<longrightarrow>\n                      (\\<forall>a\\<in>set p.\n                          {} \\<noteq> first_bothNet a) \\<and>\n                      NetsCollected p \\<longrightarrow>\n                      noDenyAll p \\<longrightarrow>\n                      allNetsDistinct (DenyAll # p) \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 DenyAll s) \\<and>\n                      separated p", "by (simp add: ANDConc disjSD_2_def noDA1eq)"], ["proof (state)\nthis:\n  \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n           NetsCollected2 p \\<longrightarrow>\n           NetsCollected p \\<longrightarrow>\n           noDenyAll1 p \\<longrightarrow>\n           allNetsDistinct p \\<longrightarrow> separated p;\n   a = DenyAll\\<rbrakk>\n  \\<Longrightarrow> OnlyTwoNets p \\<longrightarrow>\n                    {} \\<noteq> firstList p \\<and>\n                    NetsCollected2 p \\<longrightarrow>\n                    (\\<forall>a\\<in>set p.\n                        {} \\<noteq> first_bothNet a) \\<and>\n                    NetsCollected p \\<longrightarrow>\n                    noDenyAll p \\<longrightarrow>\n                    allNetsDistinct (DenyAll # p) \\<longrightarrow>\n                    (\\<forall>s.\n                        s \\<in> set p \\<longrightarrow>\n                        disjSD_2 DenyAll s) \\<and>\n                    separated p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma separatedNC'[rule_format]: \n  \"OnlyTwoNets p \\<longrightarrow> NetsCollected2 p \\<longrightarrow> NetsCollected p \\<longrightarrow> noDenyAll1 p \\<longrightarrow>  \n   allNetsDistinct p  \\<longrightarrow> separated p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OnlyTwoNets p \\<longrightarrow>\n    NetsCollected2 p \\<longrightarrow>\n    NetsCollected p \\<longrightarrow>\n    noDenyAll1 p \\<longrightarrow>\n    allNetsDistinct p \\<longrightarrow> separated p", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. OnlyTwoNets [] \\<longrightarrow>\n    NetsCollected2 [] \\<longrightarrow>\n    NetsCollected [] \\<longrightarrow>\n    noDenyAll1 [] \\<longrightarrow>\n    allNetsDistinct [] \\<longrightarrow> separated []\n 2. \\<And>a p.\n       OnlyTwoNets p \\<longrightarrow>\n       NetsCollected2 p \\<longrightarrow>\n       NetsCollected p \\<longrightarrow>\n       noDenyAll1 p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow> separated p \\<Longrightarrow>\n       OnlyTwoNets (a # p) \\<longrightarrow>\n       NetsCollected2 (a # p) \\<longrightarrow>\n       NetsCollected (a # p) \\<longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow> separated (a # p)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. OnlyTwoNets [] \\<longrightarrow>\n    NetsCollected2 [] \\<longrightarrow>\n    NetsCollected [] \\<longrightarrow>\n    noDenyAll1 [] \\<longrightarrow>\n    allNetsDistinct [] \\<longrightarrow> separated []\n 2. \\<And>a p.\n       OnlyTwoNets p \\<longrightarrow>\n       NetsCollected2 p \\<longrightarrow>\n       NetsCollected p \\<longrightarrow>\n       noDenyAll1 p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow> separated p \\<Longrightarrow>\n       OnlyTwoNets (a # p) \\<longrightarrow>\n       NetsCollected2 (a # p) \\<longrightarrow>\n       NetsCollected (a # p) \\<longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow> separated (a # p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. OnlyTwoNets [] \\<longrightarrow>\n    NetsCollected2 [] \\<longrightarrow>\n    NetsCollected [] \\<longrightarrow>\n    noDenyAll1 [] \\<longrightarrow>\n    allNetsDistinct [] \\<longrightarrow> separated []", "by simp"], ["proof (state)\nthis:\n  OnlyTwoNets [] \\<longrightarrow>\n  NetsCollected2 [] \\<longrightarrow>\n  NetsCollected [] \\<longrightarrow>\n  noDenyAll1 [] \\<longrightarrow>\n  allNetsDistinct [] \\<longrightarrow> separated []\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       OnlyTwoNets p \\<longrightarrow>\n       NetsCollected2 p \\<longrightarrow>\n       NetsCollected p \\<longrightarrow>\n       noDenyAll1 p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow> separated p \\<Longrightarrow>\n       OnlyTwoNets (a # p) \\<longrightarrow>\n       NetsCollected2 (a # p) \\<longrightarrow>\n       NetsCollected (a # p) \\<longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow> separated (a # p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       OnlyTwoNets p \\<longrightarrow>\n       NetsCollected2 p \\<longrightarrow>\n       NetsCollected p \\<longrightarrow>\n       noDenyAll1 p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow> separated p \\<Longrightarrow>\n       OnlyTwoNets (a # p) \\<longrightarrow>\n       NetsCollected2 (a # p) \\<longrightarrow>\n       NetsCollected (a # p) \\<longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow> separated (a # p)", "case (Cons a p)"], ["proof (state)\nthis:\n  OnlyTwoNets p \\<longrightarrow>\n  NetsCollected2 p \\<longrightarrow>\n  NetsCollected p \\<longrightarrow>\n  noDenyAll1 p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow> separated p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       OnlyTwoNets p \\<longrightarrow>\n       NetsCollected2 p \\<longrightarrow>\n       NetsCollected p \\<longrightarrow>\n       noDenyAll1 p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow> separated p \\<Longrightarrow>\n       OnlyTwoNets (a # p) \\<longrightarrow>\n       NetsCollected2 (a # p) \\<longrightarrow>\n       NetsCollected (a # p) \\<longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow> separated (a # p)", "then"], ["proof (chain)\npicking this:\n  OnlyTwoNets p \\<longrightarrow>\n  NetsCollected2 p \\<longrightarrow>\n  NetsCollected p \\<longrightarrow>\n  noDenyAll1 p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow> separated p", "show ?case"], ["proof (prove)\nusing this:\n  OnlyTwoNets p \\<longrightarrow>\n  NetsCollected2 p \\<longrightarrow>\n  NetsCollected p \\<longrightarrow>\n  noDenyAll1 p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow> separated p\n\ngoal (1 subgoal):\n 1. OnlyTwoNets (a # p) \\<longrightarrow>\n    NetsCollected2 (a # p) \\<longrightarrow>\n    NetsCollected (a # p) \\<longrightarrow>\n    noDenyAll1 (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow> separated (a # p)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. OnlyTwoNets p \\<longrightarrow>\n    NetsCollected2 p \\<longrightarrow>\n    NetsCollected p \\<longrightarrow>\n    noDenyAll1 p \\<longrightarrow>\n    allNetsDistinct p \\<longrightarrow> separated p \\<Longrightarrow>\n    OnlyTwoNets (a # p) \\<longrightarrow>\n    first_bothNet a \\<noteq> firstList p \\<and>\n    NetsCollected2 p \\<longrightarrow>\n    (\\<forall>aa\\<in>set p.\n        first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n    NetsCollected p \\<longrightarrow>\n    noDenyAll1 (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n    separated p", "proof (cases \"a = DenyAll\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n             NetsCollected2 p \\<longrightarrow>\n             NetsCollected p \\<longrightarrow>\n             noDenyAll1 p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow> separated p;\n     a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets (a # p) \\<longrightarrow>\n                      first_bothNet a \\<noteq> firstList p \\<and>\n                      NetsCollected2 p \\<longrightarrow>\n                      (\\<forall>aa\\<in>set p.\n                          first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n                      NetsCollected p \\<longrightarrow>\n                      noDenyAll1 (a # p) \\<longrightarrow>\n                      allNetsDistinct (a # p) \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated p\n 2. \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n             NetsCollected2 p \\<longrightarrow>\n             NetsCollected p \\<longrightarrow>\n             noDenyAll1 p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow> separated p;\n     a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets (a # p) \\<longrightarrow>\n                      first_bothNet a \\<noteq> firstList p \\<and>\n                      NetsCollected2 p \\<longrightarrow>\n                      (\\<forall>aa\\<in>set p.\n                          first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n                      NetsCollected p \\<longrightarrow>\n                      noDenyAll1 (a # p) \\<longrightarrow>\n                      allNetsDistinct (a # p) \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated p", "print_cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n             NetsCollected2 p \\<longrightarrow>\n             NetsCollected p \\<longrightarrow>\n             noDenyAll1 p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow> separated p;\n     a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets (a # p) \\<longrightarrow>\n                      first_bothNet a \\<noteq> firstList p \\<and>\n                      NetsCollected2 p \\<longrightarrow>\n                      (\\<forall>aa\\<in>set p.\n                          first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n                      NetsCollected p \\<longrightarrow>\n                      noDenyAll1 (a # p) \\<longrightarrow>\n                      allNetsDistinct (a # p) \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated p\n 2. \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n             NetsCollected2 p \\<longrightarrow>\n             NetsCollected p \\<longrightarrow>\n             noDenyAll1 p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow> separated p;\n     a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets (a # p) \\<longrightarrow>\n                      first_bothNet a \\<noteq> firstList p \\<and>\n                      NetsCollected2 p \\<longrightarrow>\n                      (\\<forall>aa\\<in>set p.\n                          first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n                      NetsCollected p \\<longrightarrow>\n                      noDenyAll1 (a # p) \\<longrightarrow>\n                      allNetsDistinct (a # p) \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated p", "case True"], ["proof (state)\nthis:\n  a = DenyAll\n\ngoal (2 subgoals):\n 1. \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n             NetsCollected2 p \\<longrightarrow>\n             NetsCollected p \\<longrightarrow>\n             noDenyAll1 p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow> separated p;\n     a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets (a # p) \\<longrightarrow>\n                      first_bothNet a \\<noteq> firstList p \\<and>\n                      NetsCollected2 p \\<longrightarrow>\n                      (\\<forall>aa\\<in>set p.\n                          first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n                      NetsCollected p \\<longrightarrow>\n                      noDenyAll1 (a # p) \\<longrightarrow>\n                      allNetsDistinct (a # p) \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated p\n 2. \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n             NetsCollected2 p \\<longrightarrow>\n             NetsCollected p \\<longrightarrow>\n             noDenyAll1 p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow> separated p;\n     a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets (a # p) \\<longrightarrow>\n                      first_bothNet a \\<noteq> firstList p \\<and>\n                      NetsCollected2 p \\<longrightarrow>\n                      (\\<forall>aa\\<in>set p.\n                          first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n                      NetsCollected p \\<longrightarrow>\n                      noDenyAll1 (a # p) \\<longrightarrow>\n                      allNetsDistinct (a # p) \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated p", "then"], ["proof (chain)\npicking this:\n  a = DenyAll", "show \"OnlyTwoNets (a # p) \\<longrightarrow>  first_bothNet a \\<noteq> firstList p \\<and> NetsCollected2 p \\<longrightarrow>\n                      (\\<forall>aa\\<in>set p. first_bothNet a \\<noteq> first_bothNet aa) \\<and> NetsCollected p \\<longrightarrow>\n                      noDenyAll1 (a # p) \\<longrightarrow> allNetsDistinct (a # p) \\<longrightarrow> \n                      (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and> separated p\""], ["proof (prove)\nusing this:\n  a = DenyAll\n\ngoal (1 subgoal):\n 1. OnlyTwoNets (a # p) \\<longrightarrow>\n    first_bothNet a \\<noteq> firstList p \\<and>\n    NetsCollected2 p \\<longrightarrow>\n    (\\<forall>aa\\<in>set p.\n        first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n    NetsCollected p \\<longrightarrow>\n    noDenyAll1 (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n    separated p", "apply(insert Cons.hyps \\<open>a = DenyAll\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n             NetsCollected2 p \\<longrightarrow>\n             NetsCollected p \\<longrightarrow>\n             noDenyAll1 p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow> separated p;\n     a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets (a # p) \\<longrightarrow>\n                      first_bothNet a \\<noteq> firstList p \\<and>\n                      NetsCollected2 p \\<longrightarrow>\n                      (\\<forall>aa\\<in>set p.\n                          first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n                      NetsCollected p \\<longrightarrow>\n                      noDenyAll1 (a # p) \\<longrightarrow>\n                      allNetsDistinct (a # p) \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated p", "apply (intro impI,drule mp, erule OTNConc,drule mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = DenyAll; OnlyTwoNets (a # p);\n     first_bothNet a \\<noteq> firstList p \\<and> NetsCollected2 p;\n     (\\<forall>aa\\<in>set p.\n         first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n     NetsCollected p;\n     noDenyAll1 (a # p); allNetsDistinct (a # p)\\<rbrakk>\n    \\<Longrightarrow> NetsCollected2 p\n 2. \\<lbrakk>a = DenyAll; OnlyTwoNets (a # p);\n     first_bothNet a \\<noteq> firstList p \\<and> NetsCollected2 p;\n     (\\<forall>aa\\<in>set p.\n         first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n     NetsCollected p;\n     noDenyAll1 (a # p); allNetsDistinct (a # p);\n     NetsCollected p \\<longrightarrow>\n     noDenyAll1 p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> separated p\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated p", "apply (case_tac p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = DenyAll; OnlyTwoNets p;\n     {} \\<noteq> firstList p \\<and> NetsCollected2 p;\n     (\\<forall>aa\\<in>set p. {} \\<noteq> first_bothNet aa) \\<and>\n     NetsCollected p;\n     noDenyAll p; allNetsDistinct (DenyAll # p);\n     noDenyAll1 p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> separated p\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 DenyAll s) \\<and>\n                      separated p", "apply (case_tac a, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OnlyTwoNets p; {} \\<noteq> firstList p \\<and> NetsCollected2 p;\n     (\\<forall>aa\\<in>set p. {} \\<noteq> first_bothNet aa) \\<and>\n     NetsCollected p;\n     noDenyAll p; allNetsDistinct (DenyAll # p);\n     noDenyAll1 p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> separated p;\n     a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 DenyAll s) \\<and>\n                      separated p", "apply (case_tac a, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OnlyTwoNets p; {} \\<noteq> firstList p \\<and> NetsCollected2 p;\n     (\\<forall>aa\\<in>set p. {} \\<noteq> first_bothNet aa) \\<and>\n     NetsCollected p;\n     noDenyAll p; allNetsDistinct (DenyAll # p);\n     noDenyAll1 p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> separated p;\n     a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 DenyAll s) \\<and>\n                      separated p", "by (simp add: ANDConc disjSD_2_def noDA1eq)"], ["proof (state)\nthis:\n  OnlyTwoNets (a # p) \\<longrightarrow>\n  first_bothNet a \\<noteq> firstList p \\<and>\n  NetsCollected2 p \\<longrightarrow>\n  (\\<forall>aa\\<in>set p. first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n  NetsCollected p \\<longrightarrow>\n  noDenyAll1 (a # p) \\<longrightarrow>\n  allNetsDistinct (a # p) \\<longrightarrow>\n  (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n  separated p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n             NetsCollected2 p \\<longrightarrow>\n             NetsCollected p \\<longrightarrow>\n             noDenyAll1 p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow> separated p;\n     a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets (a # p) \\<longrightarrow>\n                      first_bothNet a \\<noteq> firstList p \\<and>\n                      NetsCollected2 p \\<longrightarrow>\n                      (\\<forall>aa\\<in>set p.\n                          first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n                      NetsCollected p \\<longrightarrow>\n                      noDenyAll1 (a # p) \\<longrightarrow>\n                      allNetsDistinct (a # p) \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n             NetsCollected2 p \\<longrightarrow>\n             NetsCollected p \\<longrightarrow>\n             noDenyAll1 p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow> separated p;\n     a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets (a # p) \\<longrightarrow>\n                      first_bothNet a \\<noteq> firstList p \\<and>\n                      NetsCollected2 p \\<longrightarrow>\n                      (\\<forall>aa\\<in>set p.\n                          first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n                      NetsCollected p \\<longrightarrow>\n                      noDenyAll1 (a # p) \\<longrightarrow>\n                      allNetsDistinct (a # p) \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated p", "case False"], ["proof (state)\nthis:\n  a \\<noteq> DenyAll\n\ngoal (1 subgoal):\n 1. \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n             NetsCollected2 p \\<longrightarrow>\n             NetsCollected p \\<longrightarrow>\n             noDenyAll1 p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow> separated p;\n     a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets (a # p) \\<longrightarrow>\n                      first_bothNet a \\<noteq> firstList p \\<and>\n                      NetsCollected2 p \\<longrightarrow>\n                      (\\<forall>aa\\<in>set p.\n                          first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n                      NetsCollected p \\<longrightarrow>\n                      noDenyAll1 (a # p) \\<longrightarrow>\n                      allNetsDistinct (a # p) \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated p", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> DenyAll", "show \"OnlyTwoNets (a # p) \\<longrightarrow>  first_bothNet a \\<noteq> firstList p \\<and> NetsCollected2 p \\<longrightarrow>\n                      (\\<forall>aa\\<in>set p. first_bothNet a \\<noteq> first_bothNet aa) \\<and> NetsCollected p \\<longrightarrow>\n                      noDenyAll1 (a # p) \\<longrightarrow> allNetsDistinct (a # p) \\<longrightarrow> (\\<forall>s. s \\<in> set p \\<longrightarrow> \n                      disjSD_2 a s) \\<and> separated p\""], ["proof (prove)\nusing this:\n  a \\<noteq> DenyAll\n\ngoal (1 subgoal):\n 1. OnlyTwoNets (a # p) \\<longrightarrow>\n    first_bothNet a \\<noteq> firstList p \\<and>\n    NetsCollected2 p \\<longrightarrow>\n    (\\<forall>aa\\<in>set p.\n        first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n    NetsCollected p \\<longrightarrow>\n    noDenyAll1 (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n    separated p", "apply(insert Cons.hyps \\<open>a \\<noteq> DenyAll\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OnlyTwoNets p \\<longrightarrow>\n             NetsCollected2 p \\<longrightarrow>\n             NetsCollected p \\<longrightarrow>\n             noDenyAll1 p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow> separated p;\n     a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> OnlyTwoNets (a # p) \\<longrightarrow>\n                      first_bothNet a \\<noteq> firstList p \\<and>\n                      NetsCollected2 p \\<longrightarrow>\n                      (\\<forall>aa\\<in>set p.\n                          first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n                      NetsCollected p \\<longrightarrow>\n                      noDenyAll1 (a # p) \\<longrightarrow>\n                      allNetsDistinct (a # p) \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set p \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated p", "by (metis NetsCollected.simps(1) NetsCollected2.simps(1) separated.simps(1) separatedNC)"], ["proof (state)\nthis:\n  OnlyTwoNets (a # p) \\<longrightarrow>\n  first_bothNet a \\<noteq> firstList p \\<and>\n  NetsCollected2 p \\<longrightarrow>\n  (\\<forall>aa\\<in>set p. first_bothNet a \\<noteq> first_bothNet aa) \\<and>\n  NetsCollected p \\<longrightarrow>\n  noDenyAll1 (a # p) \\<longrightarrow>\n  allNetsDistinct (a # p) \\<longrightarrow>\n  (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n  separated p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  OnlyTwoNets (a # p) \\<longrightarrow>\n  NetsCollected2 (a # p) \\<longrightarrow>\n  NetsCollected (a # p) \\<longrightarrow>\n  noDenyAll1 (a # p) \\<longrightarrow>\n  allNetsDistinct (a # p) \\<longrightarrow> separated (a # p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NC2Sep[rule_format]: \"noDenyAll1 p \\<longrightarrow> NetsCollected2 (separate p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 p \\<longrightarrow> NetsCollected2 (separate p)", "proof (induct p rule: separate.induct, simp_all, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       noDenyAll1 x \\<longrightarrow>\n       NetsCollected2 (separate x) \\<Longrightarrow>\n       noDenyAll x \\<longrightarrow>\n       separate x = [] \\<or>\n       {} \\<noteq> firstList (separate x) \\<and> NetsCollected2 (separate x)\n 2. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 3. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 4. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "fix x :: \"('a, 'b) Combinators list\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       noDenyAll1 x \\<longrightarrow>\n       NetsCollected2 (separate x) \\<Longrightarrow>\n       noDenyAll x \\<longrightarrow>\n       separate x = [] \\<or>\n       {} \\<noteq> firstList (separate x) \\<and> NetsCollected2 (separate x)\n 2. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 3. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 4. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "case 1"], ["proof (state)\nthis:\n  noDenyAll1 x_ \\<longrightarrow> NetsCollected2 (separate x_)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       noDenyAll1 x \\<longrightarrow>\n       NetsCollected2 (separate x) \\<Longrightarrow>\n       noDenyAll x \\<longrightarrow>\n       separate x = [] \\<or>\n       {} \\<noteq> firstList (separate x) \\<and> NetsCollected2 (separate x)\n 2. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 3. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 4. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "then"], ["proof (chain)\npicking this:\n  noDenyAll1 x_ \\<longrightarrow> NetsCollected2 (separate x_)", "show ?case"], ["proof (prove)\nusing this:\n  noDenyAll1 x_ \\<longrightarrow> NetsCollected2 (separate x_)\n\ngoal (1 subgoal):\n 1. noDenyAll x_ \\<longrightarrow>\n    separate x_ = [] \\<or>\n    {} \\<noteq> firstList (separate x_) \\<and> NetsCollected2 (separate x_)", "by (metis fMTaux firstList.simps(1) fl2 noDA1eq noDenyAll.elims(2) separate.simps(5))"], ["proof (state)\nthis:\n  noDenyAll x_ \\<longrightarrow>\n  separate x_ = [] \\<or>\n  {} \\<noteq> firstList (separate x_) \\<and> NetsCollected2 (separate x_)\n\ngoal (3 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 2. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 2. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "fix v va"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 2. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "fix y::\" ('a, 'b) Combinators\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 2. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "fix z"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 2. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "case 2"], ["proof (state)\nthis:\n  {v_, va_} = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  NetsCollected2 (separate (DenyAllFromTo v_ va_ \\<oplus> y_ # z_))\n  {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow> NetsCollected2 (separate (y_ # z_))\n\ngoal (3 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (DenyAllFromTo v va \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 2. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "then"], ["proof (chain)\npicking this:\n  {v_, va_} = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  NetsCollected2 (separate (DenyAllFromTo v_ va_ \\<oplus> y_ # z_))\n  {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow> NetsCollected2 (separate (y_ # z_))", "show ?case"], ["proof (prove)\nusing this:\n  {v_, va_} = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  NetsCollected2 (separate (DenyAllFromTo v_ va_ \\<oplus> y_ # z_))\n  {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow> NetsCollected2 (separate (y_ # z_))\n\ngoal (1 subgoal):\n 1. {v_, va_} \\<noteq> first_bothNet y_ \\<longrightarrow>\n    \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n    separate (y_ # z_) = [] \\<or>\n    {v_, va_} \\<noteq> firstList (separate (y_ # z_)) \\<and>\n    NetsCollected2 (separate (y_ # z_))", "by (simp add: fl2 noDA1eq)"], ["proof (state)\nthis:\n  {v_, va_} \\<noteq> first_bothNet y_ \\<longrightarrow>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  separate (y_ # z_) = [] \\<or>\n  {v_, va_} \\<noteq> firstList (separate (y_ # z_)) \\<and>\n  NetsCollected2 (separate (y_ # z_))\n\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "fix v va vb"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "fix y::\" ('a, 'b) Combinators\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "fix z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "case 3"], ["proof (state)\nthis:\n  {v_, va_} = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  NetsCollected2 (separate (AllowPortFromTo v_ va_ vb_ \\<oplus> y_ # z_))\n  {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow> NetsCollected2 (separate (y_ # z_))\n\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2\n                 (separate (AllowPortFromTo v va vb \\<oplus> y # z));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         {v, va} \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "then"], ["proof (chain)\npicking this:\n  {v_, va_} = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  NetsCollected2 (separate (AllowPortFromTo v_ va_ vb_ \\<oplus> y_ # z_))\n  {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow> NetsCollected2 (separate (y_ # z_))", "show ?case"], ["proof (prove)\nusing this:\n  {v_, va_} = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  NetsCollected2 (separate (AllowPortFromTo v_ va_ vb_ \\<oplus> y_ # z_))\n  {v_, va_} \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow> NetsCollected2 (separate (y_ # z_))\n\ngoal (1 subgoal):\n 1. {v_, va_} \\<noteq> first_bothNet y_ \\<longrightarrow>\n    \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n    separate (y_ # z_) = [] \\<or>\n    {v_, va_} \\<noteq> firstList (separate (y_ # z_)) \\<and>\n    NetsCollected2 (separate (y_ # z_))", "by (simp add: fl2 noDA1eq)"], ["proof (state)\nthis:\n  {v_, va_} \\<noteq> first_bothNet y_ \\<longrightarrow>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  separate (y_ # z_) = [] \\<or>\n  {v_, va_} \\<noteq> firstList (separate (y_ # z_)) \\<and>\n  NetsCollected2 (separate (y_ # z_))\n\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "fix v va"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "fix y::\" ('a, 'b) Combinators\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "case 4"], ["proof (state)\nthis:\n  first_bothNet v_ = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll v_ \\<and>\n  \\<not> member DenyAll va_ \\<and>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  NetsCollected2 (separate ((v_ \\<oplus> va_) \\<oplus> y_ # z_))\n  first_bothNet v_ \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow> NetsCollected2 (separate (y_ # z_))\n\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                \\<not> member DenyAll v \\<and>\n                \\<not> member DenyAll va \\<and>\n                \\<not> member DenyAll y \\<and> noDenyAll z \\<longrightarrow>\n                NetsCollected2 (separate ((v \\<oplus> va) \\<oplus> y # z));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        noDenyAll1 (y # z) \\<longrightarrow>\n        NetsCollected2 (separate (y # z))\\<rbrakk>\n       \\<Longrightarrow> first_bothNet v \\<noteq>\n                         first_bothNet y \\<longrightarrow>\n                         \\<not> member DenyAll v \\<and>\n                         \\<not> member DenyAll va \\<and>\n                         \\<not> member DenyAll y \\<and>\n                         noDenyAll z \\<longrightarrow>\n                         separate (y # z) = [] \\<or>\n                         first_bothNet v \\<noteq>\n                         firstList (separate (y # z)) \\<and>\n                         NetsCollected2 (separate (y # z))", "then"], ["proof (chain)\npicking this:\n  first_bothNet v_ = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll v_ \\<and>\n  \\<not> member DenyAll va_ \\<and>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  NetsCollected2 (separate ((v_ \\<oplus> va_) \\<oplus> y_ # z_))\n  first_bothNet v_ \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow> NetsCollected2 (separate (y_ # z_))", "show ?case"], ["proof (prove)\nusing this:\n  first_bothNet v_ = first_bothNet y_ \\<Longrightarrow>\n  \\<not> member DenyAll v_ \\<and>\n  \\<not> member DenyAll va_ \\<and>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  NetsCollected2 (separate ((v_ \\<oplus> va_) \\<oplus> y_ # z_))\n  first_bothNet v_ \\<noteq> first_bothNet y_ \\<Longrightarrow>\n  noDenyAll1 (y_ # z_) \\<longrightarrow> NetsCollected2 (separate (y_ # z_))\n\ngoal (1 subgoal):\n 1. first_bothNet v_ \\<noteq> first_bothNet y_ \\<longrightarrow>\n    \\<not> member DenyAll v_ \\<and>\n    \\<not> member DenyAll va_ \\<and>\n    \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n    separate (y_ # z_) = [] \\<or>\n    first_bothNet v_ \\<noteq> firstList (separate (y_ # z_)) \\<and>\n    NetsCollected2 (separate (y_ # z_))", "by (simp add: fl2 noDA1eq)"], ["proof (state)\nthis:\n  first_bothNet v_ \\<noteq> first_bothNet y_ \\<longrightarrow>\n  \\<not> member DenyAll v_ \\<and>\n  \\<not> member DenyAll va_ \\<and>\n  \\<not> member DenyAll y_ \\<and> noDenyAll z_ \\<longrightarrow>\n  separate (y_ # z_) = [] \\<or>\n  first_bothNet v_ \\<noteq> firstList (separate (y_ # z_)) \\<and>\n  NetsCollected2 (separate (y_ # z_))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma separatedSep[rule_format]: \n  \"OnlyTwoNets p \\<longrightarrow> NetsCollected2 p   \\<longrightarrow> NetsCollected p \\<longrightarrow> \n   noDenyAll1 p  \\<longrightarrow> allNetsDistinct p  \\<longrightarrow> separated (separate p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OnlyTwoNets p \\<longrightarrow>\n    NetsCollected2 p \\<longrightarrow>\n    NetsCollected p \\<longrightarrow>\n    noDenyAll1 p \\<longrightarrow>\n    allNetsDistinct p \\<longrightarrow> separated (separate p)", "by (simp add: ANDSep NC2Sep NetsCollectedSep OTNSEp noDA1sep separatedNC)"], ["", "lemma rADnMT[rule_format]: \"p \\<noteq> []  \\<longrightarrow> removeAllDuplicates p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow> removeAllDuplicates p \\<noteq> []", "by (induct p) simp_all"], ["", "lemma remDupsNMT[rule_format]: \"p \\<noteq> [] \\<longrightarrow> remdups p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow> remdups p \\<noteq> []", "by (metis remdups_eq_nil_iff)"], ["", "lemma sets_distinct1: \"(n::int) \\<noteq> m \\<Longrightarrow> {(a,b). a = n} \\<noteq> {(a,b). a = m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> m \\<Longrightarrow> {(a, b). a = n} \\<noteq> {(a, b). a = m}", "by auto"], ["", "lemma sets_distinct2: \"(m::int) \\<noteq> n \\<Longrightarrow> {(a,b). a = n} \\<noteq> {(a,b). a = m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> n \\<Longrightarrow> {(a, b). a = n} \\<noteq> {(a, b). a = m}", "by auto"], ["", "lemma sets_distinct5: \"(n::int) < m \\<Longrightarrow> {(a,b). a = n} \\<noteq> {(a,b). a = m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < m \\<Longrightarrow> {(a, b). a = n} \\<noteq> {(a, b). a = m}", "by auto"], ["", "lemma sets_distinct6: \"(m::int) < n \\<Longrightarrow> {(a,b). a = n} \\<noteq> {(a,b). a = m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> {(a, b). a = n} \\<noteq> {(a, b). a = m}", "by auto"], ["", "end"]]}