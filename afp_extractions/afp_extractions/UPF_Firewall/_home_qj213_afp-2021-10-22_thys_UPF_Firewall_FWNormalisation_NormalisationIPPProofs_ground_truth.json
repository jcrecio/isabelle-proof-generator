{"file_name": "/home/qj213/afp-2021-10-22/thys/UPF_Firewall/FWNormalisation/NormalisationIPPProofs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UPF_Firewall", "problem_names": ["lemma ConcAssoc: \"Cp((A \\<oplus> B) \\<oplus> D) = Cp(A \\<oplus> (B \\<oplus> D))\"", "lemma aux26[simp]: \n  \"twoNetsDistinct a b c d \\<Longrightarrow> dom (Cp (AllowPortFromTo a b p)) \\<inter> dom (Cp (DenyAllFromTo c d)) = {}\"", "lemma wp2_aux[rule_format]: \n  \"wellformed_policy2Pr (xs @ [x]) \\<longrightarrow> wellformed_policy2Pr xs\"", "lemma Cdom2: \"x \\<in> dom(Cp b) \\<Longrightarrow> Cp (a \\<oplus> b) x = (Cp b) x\"", "lemma wp2Conc[rule_format]: \"wellformed_policy2Pr (x#xs) \\<Longrightarrow> wellformed_policy2Pr xs\"", "lemma DAimpliesMR_E[rule_format]: \"DenyAll \\<in> set p \\<longrightarrow>\n                                   (\\<exists> r. applied_rule_rev Cp x p = Some r)\"", "lemma DAimplieMR[rule_format]: \"DenyAll \\<in> set p \\<Longrightarrow> applied_rule_rev Cp x p \\<noteq> None\"", "lemma MRList1[rule_format]: \"x \\<in> dom (Cp a) \\<Longrightarrow> applied_rule_rev Cp x (b@[a]) = Some a\"", "lemma MRList2: \"x \\<in> dom (Cp a) \\<Longrightarrow> applied_rule_rev Cp x (c@b@[a]) = Some a\"", "lemma MRList3: \n  \"x \\<notin> dom(Cp xa) \\<Longrightarrow> applied_rule_rev Cp x (a@b#xs@[xa]) = applied_rule_rev Cp x (a @ b # xs)\"", "lemma CConcEnd[rule_format]: \n  \"Cp a x = Some y \\<longrightarrow> Cp (list2FWpolicy (xs @ [a])) x = Some y\" (is \"?P xs\")", "lemma CConcStartaux: \"Cp a x = None \\<Longrightarrow> (Cp aa ++ Cp a) x = Cp aa x\"", "lemma CConcStart[rule_format]: \n  \"xs \\<noteq> [] \\<longrightarrow> Cp a x = None \\<longrightarrow> Cp (list2FWpolicy (xs @ [a])) x = Cp (list2FWpolicy xs) x\"", "lemma mrNnt[simp]: \"applied_rule_rev Cp x p = Some a \\<Longrightarrow> p \\<noteq> []\"", "lemma mr_is_C[rule_format]: \n  \"applied_rule_rev Cp x p = Some a \\<longrightarrow> Cp (list2FWpolicy (p)) x = Cp a x\"", "lemma CConcStart2: \n  \"p \\<noteq> [] \\<Longrightarrow> x \\<notin> dom (Cp a) \\<Longrightarrow> Cp(list2FWpolicy (p@[a])) x = Cp (list2FWpolicy p)x\"", "lemma CConcEnd1: \n  \"q@p \\<noteq> [] \\<Longrightarrow> x \\<notin> dom (Cp a) \\<Longrightarrow> Cp(list2FWpolicy(q@p@[a])) x = Cp (list2FWpolicy (q@p))x\"", "lemma CConcEnd2[rule_format]: \n  \"x \\<in> dom (Cp a) \\<longrightarrow> Cp (list2FWpolicy (xs @ [a])) x = Cp a x\"  (is \"?P xs\")", "lemma bar3: \n  \"x \\<in> dom (Cp (list2FWpolicy (xs @ [xa]))) \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy xs)) \\<or> x \\<in> dom (Cp xa)\"", "lemma CeqEnd[rule_format,simp]: \n  \"a \\<noteq> [] \\<longrightarrow> x \\<in> dom (Cp(list2FWpolicy a)) \\<longrightarrow> Cp(list2FWpolicy(b@a)) x = (Cp(list2FWpolicy a)) x\"", "lemma CConcStartA[rule_format,simp]: \n  \"x \\<in> dom (Cp a) \\<longrightarrow> x \\<in> dom (Cp (list2FWpolicy (a # b)))\" (is \"?P b\")", "lemma domConc: \n  \"x \\<in> dom (Cp (list2FWpolicy b)) \\<Longrightarrow> b \\<noteq> []  \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (a@b)))\"", "lemma CeqStart[rule_format,simp]:\n  \"x \\<notin> dom (Cp (list2FWpolicy a)) \\<longrightarrow> a \\<noteq> [] \\<longrightarrow> b \\<noteq> [] \\<longrightarrow>\n   Cp (list2FWpolicy (b@a)) x = (Cp (list2FWpolicy b)) x\"", "lemma C_eq_if_mr_eq2: \n  \"applied_rule_rev Cp x a = Some r \\<Longrightarrow> applied_rule_rev Cp x b = Some r \\<Longrightarrow> a\\<noteq>[] \\<Longrightarrow> b\\<noteq>[] \\<Longrightarrow>\n   (Cp (list2FWpolicy a)) x = (Cp (list2FWpolicy b)) x\"", "lemma nMRtoNone[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> applied_rule_rev Cp x p = None \\<longrightarrow> Cp (list2FWpolicy p) x = None\"", "lemma C_eq_if_mr_eq: \n  \"applied_rule_rev Cp x b = applied_rule_rev Cp x a \\<Longrightarrow> a \\<noteq> [] \\<Longrightarrow> b \\<noteq> [] \\<Longrightarrow>  \n  (Cp (list2FWpolicy a)) x = (Cp (list2FWpolicy b)) x\"", "lemma notmatching_notdom: \n  \"applied_rule_rev Cp x (p@[a]) \\<noteq> Some a \\<Longrightarrow> x \\<notin> dom (Cp a)\"", "lemma foo3a[rule_format]: \n  \"applied_rule_rev Cp x (a@[b]@c) = Some b \\<longrightarrow>  r \\<in> set c \\<longrightarrow> b \\<notin> set c \\<longrightarrow> x \\<notin> dom (Cp r)\"", "lemma foo3D: \n  \"wellformed_policy1 p \\<Longrightarrow> p=DenyAll#ps \\<Longrightarrow> applied_rule_rev Cp x p = Some DenyAll \\<Longrightarrow> r\\<in>set ps \\<Longrightarrow> \n   x \\<notin> dom (Cp r)\"", "lemma foo4[rule_format]: \n  \"set p = set s \\<and> (\\<forall> r. r \\<in> set p \\<longrightarrow> x \\<notin> dom (Cp r)) \\<longrightarrow> (\\<forall> r .r \\<in> set s \\<longrightarrow> x \\<notin> dom (Cp r))\"", "lemma foo5b[rule_format]: \n  \"x \\<in> dom (Cp b) \\<longrightarrow> (\\<forall> r. r \\<in> set c \\<longrightarrow> x \\<notin> dom (Cp r))\\<longrightarrow> applied_rule_rev Cp x (b#c) = Some b\"", "lemma mr_first: \n  \"x \\<in> dom (Cp b) \\<Longrightarrow> (\\<forall> r. r \\<in> set c \\<longrightarrow> x \\<notin> dom (Cp r)) \\<Longrightarrow> s = b#c \\<Longrightarrow> \n   applied_rule_rev Cp x s = Some b\"", "lemma mr_charn[rule_format]: \n  \"a \\<in> set p \\<longrightarrow> (x \\<in> dom (Cp a)) \\<longrightarrow>(\\<forall> r. r \\<in> set p \\<and> x \\<in> dom (Cp r) \\<longrightarrow> r = a) \\<longrightarrow>  \n   applied_rule_rev Cp x p = Some a\"", "lemma foo8: \n  \"\\<forall> r. r \\<in> set p \\<and> x \\<in> dom (Cp r) \\<longrightarrow> r = a \\<Longrightarrow> set p = set s \\<Longrightarrow> \n   \\<forall> r. r \\<in> set s \\<and> x \\<in> dom (Cp r) \\<longrightarrow> r = a\"", "lemma mrConcEnd[rule_format]: \n  \"applied_rule_rev Cp x (b # p) = Some a \\<longrightarrow> a \\<noteq> b \\<longrightarrow> applied_rule_rev Cp x p = Some a\"", "lemma wp3tl[rule_format]: \"wellformed_policy3Pr p \\<longrightarrow> wellformed_policy3Pr (tl p)\"", "lemma wp3Conc[rule_format]: \"wellformed_policy3Pr (a#p) \\<longrightarrow> wellformed_policy3Pr p\"", "lemma foo98[rule_format]:\n  \"applied_rule_rev Cp x (aa # p) = Some a \\<longrightarrow> x \\<in> dom (Cp r) \\<longrightarrow> r \\<in> set p \\<longrightarrow> a \\<in> set p\"", "lemma mrMTNone[simp]: \"applied_rule_rev Cp x [] = None\"", "lemma DAAux[simp]: \"x \\<in> dom (Cp DenyAll)\"", "lemma mrSet[rule_format]: \"applied_rule_rev Cp x p = Some r \\<longrightarrow> r \\<in> set p\"", "lemma mr_not_Conc: \"singleCombinators p \\<Longrightarrow> applied_rule_rev Cp x p \\<noteq> Some (a\\<oplus>b)\"", "lemma foo25[rule_format]: \"wellformed_policy3Pr (p@[x]) \\<longrightarrow> wellformed_policy3Pr p\"", "lemma mr_in_dom[rule_format]: \"applied_rule_rev Cp x p = Some a \\<longrightarrow> x \\<in> dom (Cp a)\"", "lemma wp3EndMT[rule_format]: \n  \"wellformed_policy3Pr (p@[xs]) \\<longrightarrow>  AllowPortFromTo a b po \\<in> set p \\<longrightarrow>\n   dom (Cp (AllowPortFromTo a b po)) \\<inter> dom (Cp xs) = {}\"", "lemma foo29: \"dom (Cp a) \\<noteq> {} \\<Longrightarrow> dom (Cp a) \\<inter> dom (Cp b) = {} \\<Longrightarrow> a \\<noteq> b\"", "lemma foo28:  \n  \"AllowPortFromTo a b po\\<in>set p \\<Longrightarrow> dom(Cp(AllowPortFromTo a b po))\\<noteq>{} \\<Longrightarrow> \n   (wellformed_policy3Pr(p@[x])) \\<Longrightarrow> \n   x \\<noteq> AllowPortFromTo a b po\"", "lemma foo28a[rule_format]: \"x \\<in> dom (Cp a) \\<Longrightarrow> dom (Cp a) \\<noteq> {}\"", "lemma allow_deny_dom[simp]: \n  \"dom (Cp (AllowPortFromTo a b po)) \\<subseteq> dom (Cp (DenyAllFromTo a b))\"", "lemma DenyAllowDisj: \n  \"dom (Cp (AllowPortFromTo a b p)) \\<noteq> {} \\<Longrightarrow> \n   dom (Cp (DenyAllFromTo a b)) \\<inter> dom (Cp (AllowPortFromTo a b p))  \\<noteq> {}\"", "lemma foo31: \n  \"\\<forall> r. r \\<in> set p \\<and> x \\<in> dom (Cp r) \\<longrightarrow> \n         (r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll) \\<Longrightarrow> \n   set p = set s \\<Longrightarrow> \n   (\\<forall>r. r\\<in>set s \\<and> x\\<in>dom(Cp r) \\<longrightarrow> r=AllowPortFromTo a b po \\<or> r=DenyAllFromTo a b \\<or> r = DenyAll)\"", "lemma wp1_auxa: \"wellformed_policy1_strong p\\<Longrightarrow>(\\<exists> r. applied_rule_rev Cp x p = Some r)\"", "lemma deny_dom[simp]:  \n  \"twoNetsDistinct a b c d \\<Longrightarrow> dom (Cp (DenyAllFromTo a b)) \\<inter> dom (Cp (DenyAllFromTo c d)) = {}\"", "lemma domTrans: \"\\<lbrakk>dom a \\<subseteq> dom b; dom(b) \\<inter> dom (c) = {}\\<rbrakk> \\<Longrightarrow> dom(a) \\<inter> dom(c) = {}\"", "lemma DomInterAllowsMT: \n  \" twoNetsDistinct a b c d \\<Longrightarrow> dom (Cp(AllowPortFromTo a b p)) \\<inter> dom(Cp(AllowPortFromTo c d po))={}\"", "lemma DomInterAllowsMT_Ports: \n  \"p \\<noteq> po \\<Longrightarrow> dom (Cp (AllowPortFromTo a b p)) \\<inter> dom (Cp (AllowPortFromTo c d po)) = {}\"", "lemma wellformed_policy3_charn[rule_format]: \n  \"singleCombinators p \\<longrightarrow> distinct p \\<longrightarrow> allNetsDistinct p \\<longrightarrow> \n   wellformed_policy1 p \\<longrightarrow> wellformed_policy2Pr p  \\<longrightarrow> wellformed_policy3Pr p\"", "lemma DistinctNetsDenyAllow: \n  \"DenyAllFromTo b c \\<in> set p \\<Longrightarrow> AllowPortFromTo a d po \\<in> set p\\<Longrightarrow> allNetsDistinct p \\<Longrightarrow>\n  dom (Cp (DenyAllFromTo b c)) \\<inter> dom (Cp (AllowPortFromTo a d po)) \\<noteq> {}\\<Longrightarrow>\n  b = a \\<and> c = d\"", "lemma DistinctNetsAllowAllow: \n  \"AllowPortFromTo b c poo \\<in> set p \\<Longrightarrow> AllowPortFromTo a d po \\<in> set p \\<Longrightarrow> \n  allNetsDistinct p \\<Longrightarrow> dom(Cp(AllowPortFromTo b c poo)) \\<inter> dom(Cp(AllowPortFromTo a d po)) \\<noteq> {} \\<Longrightarrow> \n  b = a \\<and> c = d \\<and> poo = po\"", "lemma WP2RS2[simp]: \n  \"singleCombinators p \\<Longrightarrow> distinct p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> \n   wellformed_policy2Pr (removeShadowRules2 p)\"", "lemma AD_aux: \n  \"AllowPortFromTo a b po \\<in> set p \\<Longrightarrow> DenyAllFromTo c d \\<in> set p \\<Longrightarrow> \n   allNetsDistinct  p \\<Longrightarrow> singleCombinators p \\<Longrightarrow> a \\<noteq> c \\<or> b \\<noteq> d \\<Longrightarrow>\n   dom (Cp (AllowPortFromTo a b po)) \\<inter> dom (Cp (DenyAllFromTo c d)) = {}\"", "lemma sorted_WP2[rule_format]: \n  \"sorted p l \\<longrightarrow> all_in_list p l \\<longrightarrow> distinct p \\<longrightarrow> allNetsDistinct p \\<longrightarrow> singleCombinators p \\<longrightarrow> \n   wellformed_policy2Pr p\"", "lemma wellformed2_sorted[simp]: \n  \"all_in_list p l \\<Longrightarrow> distinct p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> singleCombinators p \\<Longrightarrow> \n   wellformed_policy2Pr (sort p l)\"", "lemma wellformed2_sortedQ[simp]: \n  \"all_in_list p l \\<Longrightarrow> distinct p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> singleCombinators p \\<Longrightarrow> \n   wellformed_policy2Pr (qsort p l)\"", "lemma C_DenyAll[simp]: \"Cp (list2FWpolicy (xs @ [DenyAll])) x = Some (deny ())\"", "lemma C_eq_RS1n:\n  \"Cp(list2FWpolicy (removeShadowRules1_alternative p)) = Cp(list2FWpolicy p)\"", "lemma C_eq_RS1[simp]: \n  \"p \\<noteq> [] \\<Longrightarrow> Cp(list2FWpolicy (removeShadowRules1 p)) = Cp(list2FWpolicy p)\"", "lemma EX_MR_aux[rule_format]: \n  \"applied_rule_rev Cp x (DenyAll # p) \\<noteq> Some DenyAll \\<longrightarrow> (\\<exists>y. applied_rule_rev Cp x p = Some y)\"", "lemma EX_MR : \n  \"applied_rule_rev Cp x p \\<noteq> (Some DenyAll) \\<Longrightarrow> p = DenyAll#ps \\<Longrightarrow> \n   (applied_rule_rev Cp x p = applied_rule_rev Cp x ps)\"", "lemma mr_not_DA:\n  \"wellformed_policy1_strong s \\<Longrightarrow> applied_rule_rev Cp x p = Some (DenyAllFromTo a ab) \\<Longrightarrow>\n    set p = set s \\<Longrightarrow> applied_rule_rev Cp x s \\<noteq> Some DenyAll\"", "lemma domsMT_notND_DD: \n  \"dom (Cp (DenyAllFromTo a b)) \\<inter> dom (Cp (DenyAllFromTo c d)) \\<noteq> {} \\<Longrightarrow> \\<not> netsDistinct a c\"", "lemma domsMT_notND_DD2: \n  \"dom (Cp (DenyAllFromTo a b)) \\<inter> dom (Cp (DenyAllFromTo c d)) \\<noteq> {} \\<Longrightarrow> \\<not> netsDistinct b d\"", "lemma domsMT_notND_DD3: \n  \"x \\<in> dom (Cp (DenyAllFromTo a b)) \\<Longrightarrow> x \\<in> dom (Cp (DenyAllFromTo c d)) \\<Longrightarrow> \\<not> netsDistinct a c\"", "lemma domsMT_notND_DD4: \n  \"x \\<in> dom (Cp (DenyAllFromTo a b)) \\<Longrightarrow> x \\<in> dom (Cp (DenyAllFromTo c d)) \\<Longrightarrow> \\<not> netsDistinct b d\"", "lemma NetsEq_if_sameP_DD: \n  \"allNetsDistinct p \\<Longrightarrow> u\\<in> set p \\<Longrightarrow> v\\<in> set p \\<Longrightarrow> u = (DenyAllFromTo a b) \\<Longrightarrow> \n   v = (DenyAllFromTo c d) \\<Longrightarrow> x \\<in> dom (Cp (u)) \\<Longrightarrow> x \\<in> dom (Cp (v)) \\<Longrightarrow> \n    a = c \\<and> b = d\"", "lemma rule_charn1: \n  assumes aND         : \"allNetsDistinct p\"\n    and     mr_is_allow : \"applied_rule_rev Cp x p = Some (AllowPortFromTo a b po)\"\n    and     SC          : \"singleCombinators p\"\n    and     inp         : \"r \\<in> set p\" \n    and     inDom       : \"x \\<in> dom (Cp r)\"\n  shows   \"(r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll)\"", "lemma none_MT_rulessubset[rule_format]: \n  \"none_MT_rules Cp a \\<longrightarrow> set b \\<subseteq> set a \\<longrightarrow> none_MT_rules Cp b\"", "lemma nMTSort: \"none_MT_rules Cp p \\<Longrightarrow> none_MT_rules Cp (sort p l)\"", "lemma nMTSortQ: \"none_MT_rules Cp p \\<Longrightarrow> none_MT_rules Cp (qsort p l)\"", "lemma wp3char[rule_format]: \"none_MT_rules Cp xs \\<and>  Cp (AllowPortFromTo a b po) = Map.empty \\<and> \n                            wellformed_policy3Pr (xs @ [DenyAllFromTo a b]) \\<longrightarrow> \n                             AllowPortFromTo a b po \\<notin> set xs\"", "lemma wp3charn[rule_format]: \n  assumes domAllow:     \"dom (Cp (AllowPortFromTo a b po)) \\<noteq> {}\" \n    and     wp3:          \"wellformed_policy3Pr (xs @ [DenyAllFromTo a b])\"\n  shows allowNotInList: \"AllowPortFromTo a b po \\<notin> set xs\"", "lemma rule_charn2: \n  assumes aND:        \"allNetsDistinct p\"\n    and wp1:            \"wellformed_policy1 p\"\n    and SC:             \"singleCombinators p\"\n    and wp3:            \"wellformed_policy3Pr p\"\n    and allow_in_list:  \"AllowPortFromTo c d po \\<in> set p\"\n    and x_in_dom_allow: \"x \\<in> dom (Cp (AllowPortFromTo c d po))\"\n  shows               \"applied_rule_rev Cp x p = Some (AllowPortFromTo c d po)\"", "lemma rule_charn3: \n \"wellformed_policy1 p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> singleCombinators p \\<Longrightarrow> \n  wellformed_policy3Pr p \\<Longrightarrow> applied_rule_rev Cp x p = Some (DenyAllFromTo c d) \\<Longrightarrow> \n  AllowPortFromTo a b po \\<in> set p \\<Longrightarrow> x \\<notin> dom (Cp (AllowPortFromTo a b po))\"", "lemma rule_charn4: \n  assumes wp1:    \"wellformed_policy1 p\" \n    and     aND:    \"allNetsDistinct p\" \n    and     SC:     \"singleCombinators p\"\n    and     wp3:    \"wellformed_policy3Pr p\"  \n    and     DA:     \"DenyAll \\<notin> set p\" \n    and     mr:     \"applied_rule_rev Cp x p = Some (DenyAllFromTo a b)\"\n    and     rinp:   \"r \\<in> set p\"\n    and     xindom: \"x \\<in> dom (Cp r)\"\n  shows  \"r = DenyAllFromTo a b\"", "lemma foo31a: \n   \"(\\<forall> r. r \\<in> set p \\<and> x \\<in> dom (Cp r) \\<longrightarrow>\n           (r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll)) \\<Longrightarrow>\n    set p = set s \\<Longrightarrow>  r \\<in> set s  \\<Longrightarrow> x \\<in> dom (Cp r) \\<Longrightarrow>\n           (r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll)\"", "lemma aux4[rule_format]: \n  \"applied_rule_rev Cp x (a#p) = Some a \\<longrightarrow> a \\<notin> set (p) \\<longrightarrow> applied_rule_rev Cp x p = None\"", "lemma mrDA_tl: \n  assumes mr_DA: \"applied_rule_rev Cp x p = Some DenyAll\"\n    and     wp1n:  \"wellformed_policy1_strong p\"\n  shows          \"applied_rule_rev Cp x (tl p) = None\"", "lemma rule_charnDAFT: \n  \"wellformed_policy1_strong p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> singleCombinators p \\<Longrightarrow> \n   wellformed_policy3Pr p \\<Longrightarrow> applied_rule_rev Cp x p = Some (DenyAllFromTo a b) \\<Longrightarrow>\n   r \\<in> set (tl p) \\<Longrightarrow> x \\<in> dom (Cp r) \\<Longrightarrow> \n   r = DenyAllFromTo a b\"", "lemma mrDenyAll_is_unique: \n  \"wellformed_policy1_strong p \\<Longrightarrow> applied_rule_rev Cp x p = Some DenyAll \\<Longrightarrow> r \\<in> set (tl p) \\<Longrightarrow> \n  x \\<notin> dom (Cp r)\"", "theorem  C_eq_Sets_mr: \n  assumes sets_eq: \"set p = set s\"\n    and     SC:      \"singleCombinators p\"\n    and     wp1_p:   \"wellformed_policy1_strong p\"\n    and     wp1_s:   \"wellformed_policy1_strong s\"\n    and     wp3_p:   \"wellformed_policy3Pr p\"       \n    and     wp3_s:   \"wellformed_policy3Pr s\"  \n    and     aND:     \"allNetsDistinct p\"          \n  shows            \"applied_rule_rev Cp x p = applied_rule_rev Cp x s\"", "lemma C_eq_Sets: \n\"singleCombinators p \\<Longrightarrow> wellformed_policy1_strong p \\<Longrightarrow> wellformed_policy1_strong s \\<Longrightarrow>\n wellformed_policy3Pr p \\<Longrightarrow> wellformed_policy3Pr s \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> set p = set s \\<Longrightarrow>\n Cp (list2FWpolicy p) x  = Cp (list2FWpolicy s) x\"", "lemma C_eq_sorted: \n  \"distinct p \\<Longrightarrow> all_in_list p l \\<Longrightarrow> singleCombinators p \\<Longrightarrow>\n   wellformed_policy1_strong p\\<Longrightarrow> wellformed_policy3Pr p\\<Longrightarrow> allNetsDistinct p \\<Longrightarrow>\n   Cp (list2FWpolicy (sort p l))= Cp (list2FWpolicy p)\"", "lemma C_eq_sortedQ: \n  \"distinct p \\<Longrightarrow> all_in_list p l \\<Longrightarrow> singleCombinators p \\<Longrightarrow> \n   wellformed_policy1_strong p \\<Longrightarrow>  wellformed_policy3Pr p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow>\n   Cp (list2FWpolicy (qsort p l))= Cp (list2FWpolicy p)\"", "lemma C_eq_RS2_mr: \"applied_rule_rev Cp x (removeShadowRules2 p)= applied_rule_rev Cp x p\"", "lemma C_eq_None[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> applied_rule_rev Cp x p = None \\<longrightarrow>  Cp (list2FWpolicy p) x = None\"", "lemma C_eq_None2:\n  \"a \\<noteq> []  \\<Longrightarrow> b \\<noteq> [] \\<Longrightarrow>  applied_rule_rev Cp x a = None  \\<Longrightarrow>  applied_rule_rev Cp x b = None \\<Longrightarrow>\n  (Cp (list2FWpolicy a)) x = (Cp (list2FWpolicy b)) x\"", "lemma C_eq_RS2: \n  \"wellformed_policy1_strong p \\<Longrightarrow> \n  Cp (list2FWpolicy (removeShadowRules2 p))= Cp (list2FWpolicy p)\"", "lemma none_MT_rulesRS2: \"none_MT_rules Cp p \\<Longrightarrow> none_MT_rules Cp (removeShadowRules2 p)\"", "lemma CconcNone: \n  \"dom (Cp a) = {} \\<Longrightarrow> p \\<noteq> [] \\<Longrightarrow> Cp (list2FWpolicy (a # p)) x = Cp (list2FWpolicy p) x\"", "lemma none_MT_rulesrd[rule_format]: \"none_MT_rules Cp p \\<longrightarrow> none_MT_rules Cp (remdups p)\"", "lemma DARS3[rule_format]:\"DenyAll \\<notin> set p\\<longrightarrow>DenyAll \\<notin> set (rm_MT_rules Cp p)\"", "lemma DAnMT: \"dom (Cp DenyAll) \\<noteq> {}\"", "lemma DAnMT2: \"Cp DenyAll \\<noteq> Map.empty\"", "lemma wp1n_RS3[rule_format,simp]: \n  \"wellformed_policy1_strong p \\<longrightarrow>  wellformed_policy1_strong (rm_MT_rules Cp p)\"", "lemma AILRS3[rule_format,simp]: \n  \"all_in_list p l \\<longrightarrow> all_in_list (rm_MT_rules Cp p) l\"", "lemma SCRS3[rule_format,simp]: \n  \"singleCombinators p \\<longrightarrow> singleCombinators(rm_MT_rules Cp p)\"", "lemma RS3subset: \"set (rm_MT_rules Cp p)  \\<subseteq> set p \"", "lemma ANDRS3[simp]: \n  \"singleCombinators p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> allNetsDistinct (rm_MT_rules Cp p)\"", "lemma nlpaux: \"x \\<notin> dom (Cp b) \\<Longrightarrow> Cp (a \\<oplus> b) x = Cp a x\"", "lemma notindom[rule_format]: \n  \"a \\<in> set p \\<longrightarrow>  x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow> x \\<notin> dom (Cp a)\"", "lemma C_eq_rd[rule_format]: \n  \"p \\<noteq> [] \\<Longrightarrow> Cp (list2FWpolicy (remdups p)) = Cp (list2FWpolicy p)\"", "lemma nMT_domMT: \n  \"\\<not> not_MT Cp  p \\<Longrightarrow> p \\<noteq> [] \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy p))\"", "lemma C_eq_RS3_aux[rule_format]: \n  \"not_MT Cp  p \\<Longrightarrow>  Cp (list2FWpolicy p) x = Cp (list2FWpolicy (rm_MT_rules Cp p)) x\"", "lemma C_eq_id: \n  \"wellformed_policy1_strong p \\<Longrightarrow> Cp(list2FWpolicy (insertDeny p)) = Cp (list2FWpolicy p)\"", "lemma C_eq_RS3: \n  \"not_MT Cp  p \\<Longrightarrow>  Cp(list2FWpolicy (rm_MT_rules Cp p)) = Cp (list2FWpolicy p)\"", "lemma NMPrd[rule_format]: \"not_MT Cp  p \\<longrightarrow> not_MT Cp  (remdups p)\"", "lemma NMPDA[rule_format]: \"DenyAll \\<in> set p \\<longrightarrow> not_MT Cp  p\"", "lemma NMPiD[rule_format]: \"not_MT Cp  (insertDeny p)\"", "lemma list2FWpolicy2list[rule_format]: \n  \"Cp (list2FWpolicy(policy2list p)) = (Cp p)\"", "lemmas C_eq_Lemmas = none_MT_rulesRS2 none_MT_rulesrd  SCp2l wp1n_RS2  wp1ID NMPiD waux2\n                     wp1alternative_RS1 p2lNmt list2FWpolicy2list wellformed_policy3_charn  wp1_eq", "lemmas C_eq_subst_Lemmas = C_eq_sorted C_eq_sortedQ C_eq_RS2 C_eq_rd C_eq_RS3 C_eq_id", "lemma C_eq_All_untilSorted: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n    Cp(list2FWpolicy (sort (removeShadowRules2 (remdups (rm_MT_rules Cp (insertDeny \n                           (removeShadowRules1 (policy2list p)))))) l)) = \n    Cp p\"", "lemma C_eq_All_untilSortedQ: \n  \"DenyAll\\<in> set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n    Cp(list2FWpolicy (qsort (removeShadowRules2 (remdups (rm_MT_rules Cp (insertDeny \n                            (removeShadowRules1 (policy2list p)))))) l)) = \n    Cp p\"", "lemma C_eq_All_untilSorted_withSimps: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow>  all_in_list (policy2list p) l \\<Longrightarrow>\n allNetsDistinct (policy2list p) \\<Longrightarrow>\n Cp(list2FWpolicy(sort(removeShadowRules2(remdups(rm_MT_rules Cp (insertDeny\n                      (removeShadowRules1(policy2list p)))))) l)) = \n Cp p\"", "lemma C_eq_All_untilSorted_withSimpsQ: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow>  all_in_list (policy2list p) l \\<Longrightarrow>\n allNetsDistinct (policy2list p) \\<Longrightarrow>\n Cp(list2FWpolicy(qsort(removeShadowRules2(remdups(rm_MT_rules Cp (insertDeny\n                       (removeShadowRules1  (policy2list p)))))) l)) = \n Cp p\"", "lemma InDomConc[rule_format]: \"p \\<noteq> [] \\<longrightarrow> x \\<in> dom (Cp (list2FWpolicy (p))) \\<longrightarrow>\n                               x \\<in>  dom (Cp (list2FWpolicy (a#p)))\"", "lemma not_in_member[rule_format]: \"member a b \\<longrightarrow> x \\<notin> dom (Cp b) \\<longrightarrow> x \\<notin> dom (Cp a)\"", "lemma src_in_sdnets[rule_format]: \n  \"\\<not> member DenyAll x \\<longrightarrow> p \\<in> dom (Cp x) \\<longrightarrow> subnetsOfAdr (src p) \\<inter> (fst_set (sdnets x)) \\<noteq> {}\"", "lemma dest_in_sdnets[rule_format]: \n  \"\\<not> member DenyAll x \\<longrightarrow> p \\<in> dom (Cp x) \\<longrightarrow> subnetsOfAdr (dest p) \\<inter> (snd_set (sdnets x)) \\<noteq> {}\"", "lemma sdnets_in_subnets[rule_format]: \n  \"p\\<in> dom (Cp x) \\<longrightarrow> \\<not> member DenyAll x \\<longrightarrow>\n   (\\<exists> (a,b)\\<in>sdnets x. a \\<in> subnetsOfAdr (src p) \\<and> b \\<in> subnetsOfAdr (dest p))\"", "lemma disjSD_no_p_in_both[rule_format]:   \n  \"\\<lbrakk>disjSD_2 x y; \\<not> member DenyAll x; \\<not> member DenyAll y;  \n   p \\<in> dom (Cp x); p \\<in> dom (Cp y)\\<rbrakk> \\<Longrightarrow> False\"", "lemma list2FWpolicy_eq: \n  \"zs \\<noteq> [] \\<Longrightarrow> Cp (list2FWpolicy (x \\<oplus> y # z)) p = Cp (x \\<oplus> list2FWpolicy (y # z)) p\"", "lemma dom_sep[rule_format]: \n  \"x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow> x \\<in> dom (Cp (list2FWpolicy(separate p)))\"", "lemma domdConcStart[rule_format]: \n  \"x \\<in> dom (Cp (list2FWpolicy (a#b))) \\<longrightarrow> x \\<notin> dom (Cp (list2FWpolicy b)) \\<longrightarrow> x \\<in> dom (Cp (a))\"", "lemma sep_dom2_aux: \n  \"x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> y # z))) \\<Longrightarrow> x \\<in> dom (Cp (a \\<oplus> list2FWpolicy (y # z)))\"", "lemma sep_dom2_aux2: \n  \"(x \\<in> dom (Cp (list2FWpolicy (separate (y # z)))) \\<longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))) \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (a # separate (y # z)))) \\<Longrightarrow> \n  x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> y # z)))\"", "lemma sep_dom2[rule_format]: \n  \"x \\<in> dom (Cp (list2FWpolicy (separate p))) \\<longrightarrow> x \\<in> dom (Cp (list2FWpolicy( p)))\"", "lemma sepDom: \"dom (Cp (list2FWpolicy p)) = dom (Cp (list2FWpolicy (separate p)))\"", "lemma C_eq_s_ext[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> Cp (list2FWpolicy (separate p)) a  = Cp (list2FWpolicy p) a \"", "lemma C_eq_s: \"p \\<noteq> [] \\<Longrightarrow> Cp (list2FWpolicy (separate p)) = Cp (list2FWpolicy p)\"", "lemmas sortnMTQ = NormalisationIntegerPortProof.C_eq_Lemmas_sep(14)", "lemmas C_eq_Lemmas_sep = C_eq_Lemmas sortnMT sortnMTQ RS2_NMT NMPrd not_MTimpnotMT", "lemma C_eq_until_separated:\n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n Cp (list2FWpolicy (separate (sort (removeShadowRules2 (remdups (rm_MT_rules Cp\n            (insertDeny (removeShadowRules1 (policy2list p)))))) l))) = \n Cp p\"", "lemma C_eq_until_separatedQ:\n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> all_in_list (policy2list p) l \\<Longrightarrow>\n   allNetsDistinct (policy2list p) \\<Longrightarrow>\n     Cp(list2FWpolicy(separate(qsort(\n           removeShadowRules2(remdups (rm_MT_rules Cp\n                 (insertDeny (removeShadowRules1 (policy2list p)))))) l))) = \n     Cp p\"", "lemma domID[rule_format]: \n  \"p \\<noteq> [] \\<and> x \\<in> dom(Cp(list2FWpolicy p)) \\<longrightarrow> x \\<in> dom (Cp(list2FWpolicy(insertDenies p)))\"", "lemma DA_is_deny: \n  \"x \\<in> dom (Cp (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)) \\<Longrightarrow>\nCp (DenyAllFromTo a b\\<oplus>DenyAllFromTo b a \\<oplus> DenyAllFromTo a b) x = Some (deny ())\"", "lemma iDdomAux[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow> \n   x \\<in> dom (Cp (list2FWpolicy (insertDenies p))) \\<longrightarrow>\n   Cp (list2FWpolicy (insertDenies p)) x = Some (deny ())\"", "lemma iD_isD[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow> \n   Cp (DenyAll \\<oplus> list2FWpolicy (insertDenies p)) x = Cp DenyAll x\"", "lemma inDomConc:\n  \"x\\<notin>dom (Cp a) \\<Longrightarrow> x\\<notin>dom (Cp (list2FWpolicy p)) \\<Longrightarrow> x \\<notin> dom (Cp (list2FWpolicy(a#p)))\"", "lemma domsdisj[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> (\\<forall> x s. s \\<in> set p \\<and> x \\<in> dom (Cp A) \\<longrightarrow>  x \\<notin> dom (Cp s)) \\<longrightarrow> y \\<in> dom (Cp A) \\<longrightarrow>\n   y \\<notin> dom (Cp (list2FWpolicy p))\"", "lemma isSepaux:\n  \"p \\<noteq> [] \\<Longrightarrow> noDenyAll (a#p) \\<Longrightarrow> separated (a # p) \\<Longrightarrow>\n   x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)  (first_destNet a) \\<oplus>\n                DenyAllFromTo (first_destNet a) (first_srcNet a)  \\<oplus> a)) \\<Longrightarrow>\n   x \\<notin> dom (Cp (list2FWpolicy p))\"", "lemma none_MT_rulessep[rule_format]: \"none_MT_rules Cp p \\<longrightarrow> none_MT_rules Cp (separate p)\"", "lemma dom_id: \n  \"noDenyAll (a#p) \\<Longrightarrow> separated (a#p) \\<Longrightarrow> p \\<noteq> [] \\<Longrightarrow>\n   x \\<notin> dom (Cp (list2FWpolicy p)) \\<Longrightarrow> x \\<in> dom (Cp (a)) \\<Longrightarrow> \n   x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\"", "lemma C_eq_iD_aux2[rule_format]: \n  \"noDenyAll1 p \\<longrightarrow> separated p\\<longrightarrow> p \\<noteq> []\\<longrightarrow> x \\<in> dom (Cp (list2FWpolicy p))\\<longrightarrow>\n  Cp(list2FWpolicy (insertDenies p)) x = Cp(list2FWpolicy p) x\"", "lemma C_eq_iD: \n  \"separated p \\<Longrightarrow> noDenyAll1 p \\<Longrightarrow> wellformed_policy1_strong p  \\<Longrightarrow> \n   Cp(list2FWpolicy (insertDenies p)) = Cp (list2FWpolicy p)\"", "lemma noDAsortQ[rule_format]: \"noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)\"", "lemma NetsCollectedSortQ: \n  \"distinct p \\<Longrightarrow>noDenyAll1 p \\<Longrightarrow> all_in_list p l \\<Longrightarrow> singleCombinators p \\<Longrightarrow> \n   NetsCollected (qsort p l)\"", "lemmas CLemmas =  nMTSort nMTSortQ none_MT_rulesRS2 none_MT_rulesrd\n                  noDAsort noDAsortQ nDASC wp1_eq  wp1ID    SCp2l ANDSep   wp1n_RS2 \n                  OTNSEp OTNSC noDA1sep wp1_alternativesep wellformed_eq \n                  wellformed1_alternative_sorted", "lemmas C_eqLemmas_id = CLemmas  NC2Sep NetsCollectedSep \n                       NetsCollectedSort NetsCollectedSortQ separatedNC", "lemma C_eq_Until_InsertDenies: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow> allNetsDistinct (policy2list p)\\<Longrightarrow> \n    Cp (list2FWpolicy((insertDenies(separate(sort(removeShadowRules2 \n            (remdups(rm_MT_rules Cp (insertDeny (removeShadowRules1 (policy2list p)))))) l))))) =\n    Cp p\"", "lemma C_eq_Until_InsertDeniesQ: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> all_in_list  (policy2list p) l \\<Longrightarrow> \n   allNetsDistinct (policy2list p) \\<Longrightarrow> \n     Cp (list2FWpolicy ((insertDenies (separate (qsort  (removeShadowRules2 \n          (remdups (rm_MT_rules Cp (insertDeny (removeShadowRules1 (policy2list p)))))) l))))) = \n     Cp p\"", "lemma C_eq_RD_aux[rule_format]: \"Cp (p) x = Cp (removeDuplicates p) x\"", "lemma C_eq_RAD_aux[rule_format]: \n  \"p \\<noteq> []  \\<longrightarrow> Cp (list2FWpolicy p) x = Cp (list2FWpolicy (removeAllDuplicates p)) x\"", "lemma C_eq_RAD: \n  \"p \\<noteq> []  \\<Longrightarrow> Cp (list2FWpolicy p) = Cp (list2FWpolicy (removeAllDuplicates p)) \"", "lemma C_eq_compile: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> all_in_list (policy2list p) l \\<Longrightarrow> \n allNetsDistinct (policy2list p) \\<Longrightarrow> \n   Cp (list2FWpolicy (removeAllDuplicates (insertDenies (separate \n          (sort (removeShadowRules2 (remdups (rm_MT_rules Cp (insertDeny \n                   (removeShadowRules1 (policy2list p)))))) l))))) = Cp p\"", "lemma C_eq_compileQ: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow>  allNetsDistinct(policy2list p) \\<Longrightarrow> \n  Cp (list2FWpolicy (removeAllDuplicates (insertDenies (separate (qsort \n                         (removeShadowRules2 (remdups (rm_MT_rules Cp (insertDeny \n                               (removeShadowRules1 (policy2list p)))))) l))))) = Cp p\"", "lemma C_eq_normalizePr: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> allNetsDistinct (policy2list p) \\<Longrightarrow> \n all_in_list (policy2list p) (Nets_List p) \\<Longrightarrow> \n Cp (list2FWpolicy (normalizePr p)) = Cp p\"", "lemma C_eq_normalizePrQ: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> allNetsDistinct (policy2list p) \\<Longrightarrow>\n all_in_list (policy2list p) (Nets_List p) \\<Longrightarrow> \n Cp (list2FWpolicy (normalizePrQ p)) = Cp p\"", "lemma domSubset3: \"dom (Cp (DenyAll \\<oplus> x)) = dom (Cp (DenyAll))\"", "lemma domSubset4: \n  \"dom (Cp (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x \\<oplus> AllowPortFromTo x y dn)) = \n   dom (Cp (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x))\"", "lemma domSubset5: \n  \"dom (Cp (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x \\<oplus> AllowPortFromTo y x dn)) = \n  dom (Cp (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x))\"", "lemma domSubset1: \n  \"dom (Cp (DenyAllFromTo one two \\<oplus> DenyAllFromTo two one \\<oplus> AllowPortFromTo one two dn \\<oplus> x)) = \n   dom (Cp (DenyAllFromTo one two \\<oplus> DenyAllFromTo two one \\<oplus> x))\"", "lemma domSubset2: \n  \"dom (Cp (DenyAllFromTo one two \\<oplus> DenyAllFromTo two one \\<oplus> AllowPortFromTo two one dn \\<oplus> x)) = \n  dom (Cp (DenyAllFromTo one two \\<oplus> DenyAllFromTo two one \\<oplus> x))\"", "lemma ConcAssoc2: \"Cp (X \\<oplus> Y \\<oplus> ((A \\<oplus> B) \\<oplus> D)) = Cp (X \\<oplus> Y \\<oplus> A \\<oplus> B \\<oplus> D)\"", "lemma ConcAssoc3: \"Cp (X \\<oplus> ((Y \\<oplus> A) \\<oplus> D)) = Cp (X \\<oplus> Y \\<oplus> A \\<oplus> D)\"", "lemma RS3_NMT[rule_format]: \"DenyAll \\<in> set p \\<longrightarrow>\n    rm_MT_rules Cp p \\<noteq> []\"", "lemma norm_notMT: \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> normalizePr p \\<noteq> []\"", "lemma norm_notMTQ: \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> normalizePrQ p \\<noteq> []\"", "lemma domDA: \"dom (Cp (DenyAll \\<oplus> A)) = dom (Cp (DenyAll))\"", "lemmas domain_reasoningPr = domDA ConcAssoc2 domSubset1 domSubset2 \n  domSubset3 domSubset4  domSubset5 domSubsetDistr1\n  domSubsetDistr2 domSubsetDistrA domSubsetDistrD coerc_assoc ConcAssoc \n  ConcAssoc3", "lemma list2policyR_Start[rule_format]: \"p \\<in> dom (Cp a) \\<longrightarrow>\n                 Cp (list2policyR (a # list)) p = Cp a p\"", "lemma list2policyR_End: \"p \\<notin> dom (Cp a) \\<Longrightarrow>\n        Cp (list2policyR (a # list)) p = (Cp a \\<Oplus> list2policy (map Cp list)) p\"", "lemma l2polR_eq_el[rule_format]: \"N \\<noteq> [] \\<longrightarrow>\n Cp( list2policyR N) p =  (list2policy (map Cp N)) p\"", "lemma l2polR_eq: \n  \"N \\<noteq> [] \\<Longrightarrow> Cp( list2policyR N) =  (list2policy (map Cp N))\"", "lemma list2FWpolicys_eq_el[rule_format]: \n  \"Filter \\<noteq> []  \\<longrightarrow>  Cp (list2policyR Filter) p =  Cp (list2FWpolicy (rev Filter)) p\"", "lemma list2FWpolicys_eq: \n  \"Filter \\<noteq> []  \\<Longrightarrow>\n  Cp (list2policyR Filter) =  Cp (list2FWpolicy (rev Filter))\"", "lemma list2FWpolicys_eq_sym: \n  \"Filter \\<noteq> []  \\<Longrightarrow>\n  Cp (list2policyR (rev Filter)) =  Cp (list2FWpolicy Filter)\"", "lemma p_eq[rule_format]: \"p \\<noteq> [] \\<longrightarrow> \n list2policy (map Cp (rev p)) = Cp (list2FWpolicy p)\"", "lemma p_eq2[rule_format]: \"normalizePr x \\<noteq> [] \\<longrightarrow> \n  Cp (list2FWpolicy (normalizePr x)) = Cp x \\<longrightarrow>\n list2policy (map Cp (rev (normalizePr x))) = Cp x\"", "lemma p_eq2Q[rule_format]: \"normalizePrQ x \\<noteq> [] \\<longrightarrow> \n  Cp (list2FWpolicy (normalizePrQ x)) = Cp x \\<longrightarrow>\n list2policy (map Cp (rev (normalizePrQ x))) = Cp x\"", "lemma list2listNMT[rule_format]: \"x \\<noteq> [] \\<longrightarrow>map sem x \\<noteq> []\"", "lemma Norm_Distr2: \n  \"r o_f ((P \\<Otimes>\\<^sub>2 (list2policy Q)) o d) = \n  (list2policy ((P \\<Otimes>\\<^sub>L Q) (\\<Otimes>\\<^sub>2) r d))\"", "lemma NATDistr: \n  \"N \\<noteq> [] \\<Longrightarrow> F = Cp (list2policyR N) \\<Longrightarrow> \n  ((\\<lambda> (x,y). x) o_f ((NAT \\<Otimes>\\<^sub>2 F) o (\\<lambda> x. (x,x)))  = \n   (list2policy (  ((NAT \\<Otimes>\\<^sub>L (map Cp N)) (\\<Otimes>\\<^sub>2) \n    (\\<lambda> (x,y). x) (\\<lambda> x. (x,x))))))\"", "lemma C_eq_normalize_manual: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> allNetsDistinct (policy2list p) \\<Longrightarrow>\n   all_in_list (policy2list p) l \\<Longrightarrow> \n   Cp (list2FWpolicy (normalize_manual_orderPr p l)) = Cp p\"", "lemma p_eq2_manualQ[rule_format]: \n  \"normalize_manual_orderPrQ x l \\<noteq> [] \\<longrightarrow> \n   Cp (list2FWpolicy (normalize_manual_orderPrQ x l)) = Cp x \\<longrightarrow>\n   list2policy (map Cp (rev (normalize_manual_orderPrQ x l))) = Cp x\"", "lemma norm_notMT_manualQ: \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> normalize_manual_orderPrQ p l \\<noteq> []\"", "lemma C_eq_normalizePr_manualQ: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow>\n   allNetsDistinct (policy2list p) \\<Longrightarrow>\n   all_in_list (policy2list p) l \\<Longrightarrow> \n   Cp (list2FWpolicy (normalize_manual_orderPrQ p l)) = Cp p\"", "lemma p_eq2_manual[rule_format]: \"normalize_manual_orderPr x l \\<noteq> [] \\<longrightarrow> \n  Cp (list2FWpolicy (normalize_manual_orderPr x l)) = Cp x \\<longrightarrow>\n list2policy (map Cp (rev (normalize_manual_orderPr x l))) = Cp x\"", "lemma norm_notMT_manual: \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> normalize_manual_orderPr p l \\<noteq> []\"", "lemma normalizePrNAT: \n  \"DenyAll \\<in> set (policy2list Filter) \\<Longrightarrow> \n   allNetsDistinct (policy2list Filter) \\<Longrightarrow>  \n   all_in_list (policy2list Filter) (Nets_List Filter) \\<Longrightarrow> \n   ((\\<lambda> (x,y). x) o_f (((NAT \\<Otimes>\\<^sub>2 Cp Filter) o (\\<lambda>x. (x,x)))))  = \n   list2policy ((NAT \\<Otimes>\\<^sub>L (map Cp (rev (normalizePr Filter)))) (\\<Otimes>\\<^sub>2) (\\<lambda> (x,y). x) (\\<lambda> x. (x,x)))\"", "lemma domSimpl[simp]: \"dom (Cp (A \\<oplus> DenyAll)) = dom (Cp (DenyAll))\""], "translations": [["", "lemma ConcAssoc: \"Cp((A \\<oplus> B) \\<oplus> D) = Cp(A \\<oplus> (B \\<oplus> D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp ((A \\<oplus> B) \\<oplus> D) = Cp (A \\<oplus> B \\<oplus> D)", "by (simp add: Cp.simps)"], ["", "lemma aux26[simp]: \n  \"twoNetsDistinct a b c d \\<Longrightarrow> dom (Cp (AllowPortFromTo a b p)) \\<inter> dom (Cp (DenyAllFromTo c d)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. twoNetsDistinct a b c d \\<Longrightarrow>\n    dom (Cp (AllowPortFromTo a b p)) \\<inter> dom (Cp (DenyAllFromTo c d)) =\n    {}", "by(auto simp:twoNetsDistinct_def netsDistinct_def PLemmas, auto)"], ["", "lemma wp2_aux[rule_format]: \n  \"wellformed_policy2Pr (xs @ [x]) \\<longrightarrow> wellformed_policy2Pr xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy2Pr (xs @ [x]) \\<longrightarrow>\n    wellformed_policy2Pr xs", "apply(induct xs, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       wellformed_policy2Pr (xs @ [x]) \\<longrightarrow>\n       wellformed_policy2Pr xs \\<Longrightarrow>\n       wellformed_policy2Pr (a # xs @ [x]) \\<longrightarrow>\n       wellformed_policy2Pr (a # xs)", "subgoal for a as"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy2Pr (as @ [x]) \\<longrightarrow>\n    wellformed_policy2Pr as \\<Longrightarrow>\n    wellformed_policy2Pr (a # as @ [x]) \\<longrightarrow>\n    wellformed_policy2Pr (a # as)", "apply(case_tac \"a\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Cdom2: \"x \\<in> dom(Cp b) \\<Longrightarrow> Cp (a \\<oplus> b) x = (Cp b) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp b) \\<Longrightarrow> Cp (a \\<oplus> b) x = Cp b x", "by (auto simp: Cp.simps)"], ["", "lemma wp2Conc[rule_format]: \"wellformed_policy2Pr (x#xs) \\<Longrightarrow> wellformed_policy2Pr xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy2Pr (x # xs) \\<Longrightarrow> wellformed_policy2Pr xs", "by (case_tac \"x\",simp_all)"], ["", "lemma DAimpliesMR_E[rule_format]: \"DenyAll \\<in> set p \\<longrightarrow>\n                                   (\\<exists> r. applied_rule_rev Cp x p = Some r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set p \\<longrightarrow>\n    (\\<exists>r. applied_rule_rev Cp x p = \\<lfloor>r\\<rfloor>)", "apply (simp add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set p \\<longrightarrow>\n    (\\<exists>r. applied_rule Cp x (rev p) = \\<lfloor>r\\<rfloor>)", "apply (rule_tac xs = p in rev_induct, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       DenyAll \\<in> set xs \\<longrightarrow>\n       (\\<exists>r.\n           applied_rule Cp x (rev xs) =\n           \\<lfloor>r\\<rfloor>) \\<Longrightarrow>\n       x \\<notin> dom (Cp DenyAll) \\<longrightarrow>\n       DenyAll = xa \\<longrightarrow>\n       (\\<exists>r. applied_rule Cp x (rev xs) = \\<lfloor>r\\<rfloor>)", "by (metis Cp.simps(1) denyAllDom)"], ["", "lemma DAimplieMR[rule_format]: \"DenyAll \\<in> set p \\<Longrightarrow> applied_rule_rev Cp x p \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set p \\<Longrightarrow>\n    applied_rule_rev Cp x p \\<noteq> \\<bottom>", "by (auto intro: DAimpliesMR_E)"], ["", "lemma MRList1[rule_format]: \"x \\<in> dom (Cp a) \\<Longrightarrow> applied_rule_rev Cp x (b@[a]) = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp a) \\<Longrightarrow>\n    applied_rule_rev Cp x (b @ [a]) = \\<lfloor>a\\<rfloor>", "by (simp add: applied_rule_rev_def)"], ["", "lemma MRList2: \"x \\<in> dom (Cp a) \\<Longrightarrow> applied_rule_rev Cp x (c@b@[a]) = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp a) \\<Longrightarrow>\n    applied_rule_rev Cp x (c @ b @ [a]) = \\<lfloor>a\\<rfloor>", "by (simp add: applied_rule_rev_def)"], ["", "lemma MRList3: \n  \"x \\<notin> dom(Cp xa) \\<Longrightarrow> applied_rule_rev Cp x (a@b#xs@[xa]) = applied_rule_rev Cp x (a @ b # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom (Cp xa) \\<Longrightarrow>\n    applied_rule_rev Cp x (a @ b # xs @ [xa]) =\n    applied_rule_rev Cp x (a @ b # xs)", "by (simp add: applied_rule_rev_def)"], ["", "lemma CConcEnd[rule_format]: \n  \"Cp a x = Some y \\<longrightarrow> Cp (list2FWpolicy (xs @ [a])) x = Some y\" (is \"?P xs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp a x = \\<lfloor>y\\<rfloor> \\<longrightarrow>\n    Cp (list2FWpolicy (xs @ [a])) x = \\<lfloor>y\\<rfloor>", "apply (rule_tac P = ?P in list2FWpolicy.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Cp a x = \\<lfloor>y\\<rfloor> \\<longrightarrow>\n    Cp (list2FWpolicy ([] @ [a])) x = \\<lfloor>y\\<rfloor>\n 2. \\<And>xa.\n       Cp a x = \\<lfloor>y\\<rfloor> \\<longrightarrow>\n       Cp (list2FWpolicy ([xa] @ [a])) x = \\<lfloor>y\\<rfloor>\n 3. \\<And>xa v va.\n       Cp a x = \\<lfloor>y\\<rfloor> \\<longrightarrow>\n       Cp (list2FWpolicy ((v # va) @ [a])) x =\n       \\<lfloor>y\\<rfloor> \\<Longrightarrow>\n       Cp a x = \\<lfloor>y\\<rfloor> \\<longrightarrow>\n       Cp (list2FWpolicy ((xa # v # va) @ [a])) x = \\<lfloor>y\\<rfloor>", "by (simp_all add:Cp.simps)"], ["", "lemma CConcStartaux: \"Cp a x = None \\<Longrightarrow> (Cp aa ++ Cp a) x = Cp aa x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp a x = \\<bottom> \\<Longrightarrow> (Cp a \\<Oplus> Cp aa) x = Cp aa x", "by (simp add: PLemmas)"], ["", "lemma CConcStart[rule_format]: \n  \"xs \\<noteq> [] \\<longrightarrow> Cp a x = None \\<longrightarrow> Cp (list2FWpolicy (xs @ [a])) x = Cp (list2FWpolicy xs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<longrightarrow>\n    Cp a x = \\<bottom> \\<longrightarrow>\n    Cp (list2FWpolicy (xs @ [a])) x = Cp (list2FWpolicy xs) x", "by (rule list2FWpolicy.induct) (simp_all add: PLemmas)"], ["", "lemma mrNnt[simp]: \"applied_rule_rev Cp x p = Some a \\<Longrightarrow> p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n    p \\<noteq> []", "by (simp add: applied_rule_rev_def)(auto)"], ["", "lemma mr_is_C[rule_format]: \n  \"applied_rule_rev Cp x p = Some a \\<longrightarrow> Cp (list2FWpolicy (p)) x = Cp a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    Cp (list2FWpolicy p) x = Cp a x", "apply (simp add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule Cp x (rev p) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    Cp (list2FWpolicy p) x = Cp a x", "apply (rule rev_induct, simp_all, safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa xs y.\n       \\<lbrakk>applied_rule Cp x (rev xs) \\<noteq> \\<lfloor>a\\<rfloor>;\n        Cp a x = \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy (xs @ [a])) x = Cp a x\n 2. \\<And>xa xs y.\n       \\<lbrakk>Cp (list2FWpolicy xs) x = Cp a x;\n        Cp a x = \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy (xs @ [a])) x = Cp a x\n 3. \\<And>xa xs.\n       \\<lbrakk>Cp (list2FWpolicy xs) x = Cp a x;\n        \\<nexists>y. Cp xa x = \\<lfloor>y\\<rfloor>;\n        applied_rule Cp x (rev xs) = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy (xs @ [xa])) x = Cp a x", "apply (metis CConcEnd )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xs y.\n       \\<lbrakk>Cp (list2FWpolicy xs) x = Cp a x;\n        Cp a x = \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy (xs @ [a])) x = Cp a x\n 2. \\<And>xa xs.\n       \\<lbrakk>Cp (list2FWpolicy xs) x = Cp a x;\n        \\<nexists>y. Cp xa x = \\<lfloor>y\\<rfloor>;\n        applied_rule Cp x (rev xs) = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy (xs @ [xa])) x = Cp a x", "apply (metis CConcEnd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>Cp (list2FWpolicy xs) x = Cp a x;\n        \\<nexists>y. Cp xa x = \\<lfloor>y\\<rfloor>;\n        applied_rule Cp x (rev xs) = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy (xs @ [xa])) x = Cp a x", "by (metis CConcStart applied_rule_rev_def mrNnt option.exhaust)"], ["", "lemma CConcStart2: \n  \"p \\<noteq> [] \\<Longrightarrow> x \\<notin> dom (Cp a) \\<Longrightarrow> Cp(list2FWpolicy (p@[a])) x = Cp (list2FWpolicy p)x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (p @ [a])) x =\n                      Cp (list2FWpolicy p) x", "by (erule CConcStart,simp add: PLemmas)"], ["", "lemma CConcEnd1: \n  \"q@p \\<noteq> [] \\<Longrightarrow> x \\<notin> dom (Cp a) \\<Longrightarrow> Cp(list2FWpolicy(q@p@[a])) x = Cp (list2FWpolicy (q@p))x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q @ p \\<noteq> []; x \\<notin> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (q @ p @ [a])) x =\n                      Cp (list2FWpolicy (q @ p)) x", "by (subst lCdom2) (rule CConcStart2, simp_all)"], ["", "lemma CConcEnd2[rule_format]: \n  \"x \\<in> dom (Cp a) \\<longrightarrow> Cp (list2FWpolicy (xs @ [a])) x = Cp a x\"  (is \"?P xs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp a) \\<longrightarrow>\n    Cp (list2FWpolicy (xs @ [a])) x = Cp a x", "by (rule_tac P = ?P in list2FWpolicy.induct) (auto simp:Cp.simps)"], ["", "lemma bar3: \n  \"x \\<in> dom (Cp (list2FWpolicy (xs @ [xa]))) \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy xs)) \\<or> x \\<in> dom (Cp xa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (list2FWpolicy (xs @ [xa]))) \\<Longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy xs)) \\<or> x \\<in> dom (Cp xa)", "by auto (metis CConcStart eq_Nil_appendI l2p_aux2 option.simps(3))"], ["", "lemma CeqEnd[rule_format,simp]: \n  \"a \\<noteq> [] \\<longrightarrow> x \\<in> dom (Cp(list2FWpolicy a)) \\<longrightarrow> Cp(list2FWpolicy(b@a)) x = (Cp(list2FWpolicy a)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy a)) \\<longrightarrow>\n    Cp (list2FWpolicy (b @ a)) x = Cp (list2FWpolicy a) x", "proof (induct rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n    Cp (list2FWpolicy (b @ [])) x = Cp (list2FWpolicy []) x\n 2. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy xs)) \\<longrightarrow>\n       Cp (list2FWpolicy (b @ xs)) x =\n       Cp (list2FWpolicy xs) x \\<Longrightarrow>\n       xs @ [xa] \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (xs @ [xa]))) \\<longrightarrow>\n       Cp (list2FWpolicy (b @ xs @ [xa])) x =\n       Cp (list2FWpolicy (xs @ [xa])) x", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n    Cp (list2FWpolicy (b @ [])) x = Cp (list2FWpolicy []) x\n 2. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy xs)) \\<longrightarrow>\n       Cp (list2FWpolicy (b @ xs)) x =\n       Cp (list2FWpolicy xs) x \\<Longrightarrow>\n       xs @ [xa] \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (xs @ [xa]))) \\<longrightarrow>\n       Cp (list2FWpolicy (b @ xs @ [xa])) x =\n       Cp (list2FWpolicy (xs @ [xa])) x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n    Cp (list2FWpolicy (b @ [])) x = Cp (list2FWpolicy []) x", "by simp"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n  Cp (list2FWpolicy (b @ [])) x = Cp (list2FWpolicy []) x\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy xs)) \\<longrightarrow>\n       Cp (list2FWpolicy (b @ xs)) x =\n       Cp (list2FWpolicy xs) x \\<Longrightarrow>\n       xs @ [xa] \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (xs @ [xa]))) \\<longrightarrow>\n       Cp (list2FWpolicy (b @ xs @ [xa])) x =\n       Cp (list2FWpolicy (xs @ [xa])) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy xs)) \\<longrightarrow>\n       Cp (list2FWpolicy (b @ xs)) x =\n       Cp (list2FWpolicy xs) x \\<Longrightarrow>\n       xs @ [xa] \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (xs @ [xa]))) \\<longrightarrow>\n       Cp (list2FWpolicy (b @ xs @ [xa])) x =\n       Cp (list2FWpolicy (xs @ [xa])) x", "case (snoc xa xs)"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy xs)) \\<longrightarrow>\n  Cp (list2FWpolicy (b @ xs)) x = Cp (list2FWpolicy xs) x\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy xs)) \\<longrightarrow>\n       Cp (list2FWpolicy (b @ xs)) x =\n       Cp (list2FWpolicy xs) x \\<Longrightarrow>\n       xs @ [xa] \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (xs @ [xa]))) \\<longrightarrow>\n       Cp (list2FWpolicy (b @ xs @ [xa])) x =\n       Cp (list2FWpolicy (xs @ [xa])) x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ [xa] \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (xs @ [xa]))) \\<longrightarrow>\n    Cp (list2FWpolicy (b @ xs @ [xa])) x = Cp (list2FWpolicy (xs @ [xa])) x", "apply (case_tac \"xs \\<noteq> []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (xs @ [xa]))) \\<longrightarrow>\n    Cp (list2FWpolicy (b @ xs @ [xa])) x = Cp (list2FWpolicy (xs @ [xa])) x\n 2. xs = [] \\<Longrightarrow>\n    x \\<in> dom (Cp xa) \\<longrightarrow>\n    Cp (list2FWpolicy (b @ [xa])) x = Cp xa x", "apply (case_tac \"x \\<in> dom (Cp xa)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; x \\<in> dom (Cp xa)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (xs @ [xa]))) \\<longrightarrow>\n                      Cp (list2FWpolicy (b @ xs @ [xa])) x =\n                      Cp (list2FWpolicy (xs @ [xa])) x\n 2. \\<lbrakk>xs \\<noteq> []; x \\<notin> dom (Cp xa)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (xs @ [xa]))) \\<longrightarrow>\n                      Cp (list2FWpolicy (b @ xs @ [xa])) x =\n                      Cp (list2FWpolicy (xs @ [xa])) x\n 3. xs = [] \\<Longrightarrow>\n    x \\<in> dom (Cp xa) \\<longrightarrow>\n    Cp (list2FWpolicy (b @ [xa])) x = Cp xa x", "apply (metis CConcEnd2 MRList2 mr_is_C )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; x \\<notin> dom (Cp xa)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (xs @ [xa]))) \\<longrightarrow>\n                      Cp (list2FWpolicy (b @ xs @ [xa])) x =\n                      Cp (list2FWpolicy (xs @ [xa])) x\n 2. xs = [] \\<Longrightarrow>\n    x \\<in> dom (Cp xa) \\<longrightarrow>\n    Cp (list2FWpolicy (b @ [xa])) x = Cp xa x", "apply (metis snoc.hyps CConcEnd1 CConcStart2 Nil_is_append_conv bar3 )"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow>\n    x \\<in> dom (Cp xa) \\<longrightarrow>\n    Cp (list2FWpolicy (b @ [xa])) x = Cp xa x", "by (metis MRList2 eq_Nil_appendI mr_is_C )"], ["proof (state)\nthis:\n  xs @ [xa] \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (xs @ [xa]))) \\<longrightarrow>\n  Cp (list2FWpolicy (b @ xs @ [xa])) x = Cp (list2FWpolicy (xs @ [xa])) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma CConcStartA[rule_format,simp]: \n  \"x \\<in> dom (Cp a) \\<longrightarrow> x \\<in> dom (Cp (list2FWpolicy (a # b)))\" (is \"?P b\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp a) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (a # b)))", "by (rule_tac P = ?P in list2FWpolicy.induct)   (simp_all add: Cp.simps)"], ["", "lemma domConc: \n  \"x \\<in> dom (Cp (list2FWpolicy b)) \\<Longrightarrow> b \\<noteq> []  \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (a@b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy b)); b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (a @ b)))", "by (auto simp: PLemmas)"], ["", "lemma CeqStart[rule_format,simp]:\n  \"x \\<notin> dom (Cp (list2FWpolicy a)) \\<longrightarrow> a \\<noteq> [] \\<longrightarrow> b \\<noteq> [] \\<longrightarrow>\n   Cp (list2FWpolicy (b@a)) x = (Cp (list2FWpolicy b)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom (Cp (list2FWpolicy a)) \\<longrightarrow>\n    a \\<noteq> [] \\<longrightarrow>\n    b \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (b @ a)) x = Cp (list2FWpolicy b) x", "by (rule list2FWpolicy.induct,simp_all) (auto simp: list2FWpolicyconc PLemmas)"], ["", "lemma C_eq_if_mr_eq2: \n  \"applied_rule_rev Cp x a = Some r \\<Longrightarrow> applied_rule_rev Cp x b = Some r \\<Longrightarrow> a\\<noteq>[] \\<Longrightarrow> b\\<noteq>[] \\<Longrightarrow>\n   (Cp (list2FWpolicy a)) x = (Cp (list2FWpolicy b)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev Cp x a = \\<lfloor>r\\<rfloor>;\n     applied_rule_rev Cp x b = \\<lfloor>r\\<rfloor>; a \\<noteq> [];\n     b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy a) x = Cp (list2FWpolicy b) x", "by (metis mr_is_C)"], ["", "lemma nMRtoNone[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> applied_rule_rev Cp x p = None \\<longrightarrow> Cp (list2FWpolicy p) x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    applied_rule_rev Cp x p = \\<bottom> \\<longrightarrow>\n    Cp (list2FWpolicy p) x = \\<bottom>", "proof (induct rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    applied_rule_rev Cp x [] = \\<bottom> \\<longrightarrow>\n    Cp (list2FWpolicy []) x = \\<bottom>\n 2. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       applied_rule_rev Cp x xs = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy xs) x = \\<bottom> \\<Longrightarrow>\n       xs @ [xa] \\<noteq> [] \\<longrightarrow>\n       applied_rule_rev Cp x (xs @ [xa]) = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    applied_rule_rev Cp x [] = \\<bottom> \\<longrightarrow>\n    Cp (list2FWpolicy []) x = \\<bottom>\n 2. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       applied_rule_rev Cp x xs = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy xs) x = \\<bottom> \\<Longrightarrow>\n       xs @ [xa] \\<noteq> [] \\<longrightarrow>\n       applied_rule_rev Cp x (xs @ [xa]) = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    applied_rule_rev Cp x [] = \\<bottom> \\<longrightarrow>\n    Cp (list2FWpolicy []) x = \\<bottom>", "by simp"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  applied_rule_rev Cp x [] = \\<bottom> \\<longrightarrow>\n  Cp (list2FWpolicy []) x = \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       applied_rule_rev Cp x xs = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy xs) x = \\<bottom> \\<Longrightarrow>\n       xs @ [xa] \\<noteq> [] \\<longrightarrow>\n       applied_rule_rev Cp x (xs @ [xa]) = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       applied_rule_rev Cp x xs = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy xs) x = \\<bottom> \\<Longrightarrow>\n       xs @ [xa] \\<noteq> [] \\<longrightarrow>\n       applied_rule_rev Cp x (xs @ [xa]) = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "case (snoc xa xs)"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<longrightarrow>\n  applied_rule_rev Cp x xs = \\<bottom> \\<longrightarrow>\n  Cp (list2FWpolicy xs) x = \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       applied_rule_rev Cp x xs = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy xs) x = \\<bottom> \\<Longrightarrow>\n       xs @ [xa] \\<noteq> [] \\<longrightarrow>\n       applied_rule_rev Cp x (xs @ [xa]) = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ [xa] \\<noteq> [] \\<longrightarrow>\n    applied_rule_rev Cp x (xs @ [xa]) = \\<bottom> \\<longrightarrow>\n    Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "apply (case_tac \"xs = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    applied_rule_rev Cp x [xa] = \\<bottom> \\<longrightarrow>\n    Cp xa x = \\<bottom>\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    applied_rule_rev Cp x (xs @ [xa]) = \\<bottom> \\<longrightarrow>\n    Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "by (simp_all add: snoc.hyps applied_rule_rev_def dom_def)"], ["proof (state)\nthis:\n  xs @ [xa] \\<noteq> [] \\<longrightarrow>\n  applied_rule_rev Cp x (xs @ [xa]) = \\<bottom> \\<longrightarrow>\n  Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_if_mr_eq: \n  \"applied_rule_rev Cp x b = applied_rule_rev Cp x a \\<Longrightarrow> a \\<noteq> [] \\<Longrightarrow> b \\<noteq> [] \\<Longrightarrow>  \n  (Cp (list2FWpolicy a)) x = (Cp (list2FWpolicy b)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev Cp x b = applied_rule_rev Cp x a;\n     a \\<noteq> []; b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy a) x = Cp (list2FWpolicy b) x", "apply (cases \"applied_rule_rev Cp x a = None\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x b = \\<bottom>; a \\<noteq> [];\n     b \\<noteq> []; applied_rule_rev Cp x a = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy a) x = Cp (list2FWpolicy b) x\n 2. \\<lbrakk>applied_rule_rev Cp x b = applied_rule_rev Cp x a;\n     a \\<noteq> []; b \\<noteq> [];\n     \\<exists>y. applied_rule_rev Cp x a = \\<lfloor>y\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy a) x = Cp (list2FWpolicy b) x", "apply (subst nMRtoNone,simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x b = \\<bottom>; a \\<noteq> [];\n     b \\<noteq> []; applied_rule_rev Cp x a = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> \\<bottom> = Cp (list2FWpolicy b) x\n 2. \\<lbrakk>applied_rule_rev Cp x b = applied_rule_rev Cp x a;\n     a \\<noteq> []; b \\<noteq> [];\n     \\<exists>y. applied_rule_rev Cp x a = \\<lfloor>y\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy a) x = Cp (list2FWpolicy b) x", "apply (subst nMRtoNone,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev Cp x b = applied_rule_rev Cp x a;\n     a \\<noteq> []; b \\<noteq> [];\n     \\<exists>y. applied_rule_rev Cp x a = \\<lfloor>y\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy a) x = Cp (list2FWpolicy b) x", "by (auto intro: C_eq_if_mr_eq2)"], ["", "lemma notmatching_notdom: \n  \"applied_rule_rev Cp x (p@[a]) \\<noteq> Some a \\<Longrightarrow> x \\<notin> dom (Cp a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (p @ [a]) \\<noteq>\n    \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n    x \\<notin> dom (Cp a)", "by (simp add: applied_rule_rev_def split: if_splits)"], ["", "lemma foo3a[rule_format]: \n  \"applied_rule_rev Cp x (a@[b]@c) = Some b \\<longrightarrow>  r \\<in> set c \\<longrightarrow> b \\<notin> set c \\<longrightarrow> x \\<notin> dom (Cp r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (a @ [b] @ c) =\n    \\<lfloor>b\\<rfloor> \\<longrightarrow>\n    r \\<in> set c \\<longrightarrow>\n    b \\<notin> set c \\<longrightarrow> x \\<notin> dom (Cp r)", "proof (induct rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. applied_rule_rev Cp x (a @ [b] @ []) =\n    \\<lfloor>b\\<rfloor> \\<longrightarrow>\n    r \\<in> set [] \\<longrightarrow>\n    b \\<notin> set [] \\<longrightarrow> x \\<notin> dom (Cp r)\n 2. \\<And>xa xs.\n       applied_rule_rev Cp x (a @ [b] @ xs) =\n       \\<lfloor>b\\<rfloor> \\<longrightarrow>\n       r \\<in> set xs \\<longrightarrow>\n       b \\<notin> set xs \\<longrightarrow>\n       x \\<notin> dom (Cp r) \\<Longrightarrow>\n       applied_rule_rev Cp x (a @ [b] @ xs @ [xa]) =\n       \\<lfloor>b\\<rfloor> \\<longrightarrow>\n       r \\<in> set (xs @ [xa]) \\<longrightarrow>\n       b \\<notin> set (xs @ [xa]) \\<longrightarrow> x \\<notin> dom (Cp r)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. applied_rule_rev Cp x (a @ [b] @ []) =\n    \\<lfloor>b\\<rfloor> \\<longrightarrow>\n    r \\<in> set [] \\<longrightarrow>\n    b \\<notin> set [] \\<longrightarrow> x \\<notin> dom (Cp r)\n 2. \\<And>xa xs.\n       applied_rule_rev Cp x (a @ [b] @ xs) =\n       \\<lfloor>b\\<rfloor> \\<longrightarrow>\n       r \\<in> set xs \\<longrightarrow>\n       b \\<notin> set xs \\<longrightarrow>\n       x \\<notin> dom (Cp r) \\<Longrightarrow>\n       applied_rule_rev Cp x (a @ [b] @ xs @ [xa]) =\n       \\<lfloor>b\\<rfloor> \\<longrightarrow>\n       r \\<in> set (xs @ [xa]) \\<longrightarrow>\n       b \\<notin> set (xs @ [xa]) \\<longrightarrow> x \\<notin> dom (Cp r)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (a @ [b] @ []) =\n    \\<lfloor>b\\<rfloor> \\<longrightarrow>\n    r \\<in> set [] \\<longrightarrow>\n    b \\<notin> set [] \\<longrightarrow> x \\<notin> dom (Cp r)", "by simp"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (a @ [b] @ []) =\n  \\<lfloor>b\\<rfloor> \\<longrightarrow>\n  r \\<in> set [] \\<longrightarrow>\n  b \\<notin> set [] \\<longrightarrow> x \\<notin> dom (Cp r)\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       applied_rule_rev Cp x (a @ [b] @ xs) =\n       \\<lfloor>b\\<rfloor> \\<longrightarrow>\n       r \\<in> set xs \\<longrightarrow>\n       b \\<notin> set xs \\<longrightarrow>\n       x \\<notin> dom (Cp r) \\<Longrightarrow>\n       applied_rule_rev Cp x (a @ [b] @ xs @ [xa]) =\n       \\<lfloor>b\\<rfloor> \\<longrightarrow>\n       r \\<in> set (xs @ [xa]) \\<longrightarrow>\n       b \\<notin> set (xs @ [xa]) \\<longrightarrow> x \\<notin> dom (Cp r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       applied_rule_rev Cp x (a @ [b] @ xs) =\n       \\<lfloor>b\\<rfloor> \\<longrightarrow>\n       r \\<in> set xs \\<longrightarrow>\n       b \\<notin> set xs \\<longrightarrow>\n       x \\<notin> dom (Cp r) \\<Longrightarrow>\n       applied_rule_rev Cp x (a @ [b] @ xs @ [xa]) =\n       \\<lfloor>b\\<rfloor> \\<longrightarrow>\n       r \\<in> set (xs @ [xa]) \\<longrightarrow>\n       b \\<notin> set (xs @ [xa]) \\<longrightarrow> x \\<notin> dom (Cp r)", "case (snoc xa xs)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (a @ [b] @ xs) =\n  \\<lfloor>b\\<rfloor> \\<longrightarrow>\n  r \\<in> set xs \\<longrightarrow>\n  b \\<notin> set xs \\<longrightarrow> x \\<notin> dom (Cp r)\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       applied_rule_rev Cp x (a @ [b] @ xs) =\n       \\<lfloor>b\\<rfloor> \\<longrightarrow>\n       r \\<in> set xs \\<longrightarrow>\n       b \\<notin> set xs \\<longrightarrow>\n       x \\<notin> dom (Cp r) \\<Longrightarrow>\n       applied_rule_rev Cp x (a @ [b] @ xs @ [xa]) =\n       \\<lfloor>b\\<rfloor> \\<longrightarrow>\n       r \\<in> set (xs @ [xa]) \\<longrightarrow>\n       b \\<notin> set (xs @ [xa]) \\<longrightarrow> x \\<notin> dom (Cp r)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (a @ [b] @ xs @ [xa]) =\n    \\<lfloor>b\\<rfloor> \\<longrightarrow>\n    r \\<in> set (xs @ [xa]) \\<longrightarrow>\n    b \\<notin> set (xs @ [xa]) \\<longrightarrow> x \\<notin> dom (Cp r)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (a @ b # xs @ [xa]) =\n    \\<lfloor>b\\<rfloor> \\<longrightarrow>\n    (r = xa \\<longrightarrow>\n     b \\<noteq> xa \\<and> b \\<notin> set xs \\<longrightarrow>\n     x \\<notin> dom (Cp xa)) \\<and>\n    (r \\<in> set xs \\<longrightarrow>\n     b \\<noteq> xa \\<and> b \\<notin> set xs \\<longrightarrow>\n     x \\<notin> dom (Cp r))", "apply (rule impI|rule conjI|simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x (a @ b # xs @ [xa]) =\n             \\<lfloor>b\\<rfloor>;\n     r = xa; b \\<noteq> xa \\<and> b \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp xa)\n 2. applied_rule_rev Cp x (a @ b # xs @ [xa]) =\n    \\<lfloor>b\\<rfloor> \\<Longrightarrow>\n    r \\<in> set xs \\<longrightarrow>\n    b \\<noteq> xa \\<and> b \\<notin> set xs \\<longrightarrow>\n    x \\<notin> dom (Cp r)", "apply (rule_tac p = \"a @ b # xs\" in notmatching_notdom,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (a @ b # xs @ [xa]) =\n    \\<lfloor>b\\<rfloor> \\<Longrightarrow>\n    r \\<in> set xs \\<longrightarrow>\n    b \\<noteq> xa \\<and> b \\<notin> set xs \\<longrightarrow>\n    x \\<notin> dom (Cp r)", "by (metis Cons_eq_appendI NormalisationIPPProofs.MRList2 NormalisationIPPProofs.MRList3 \n        append_Nil option.inject snoc.hyps)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (a @ [b] @ xs @ [xa]) =\n  \\<lfloor>b\\<rfloor> \\<longrightarrow>\n  r \\<in> set (xs @ [xa]) \\<longrightarrow>\n  b \\<notin> set (xs @ [xa]) \\<longrightarrow> x \\<notin> dom (Cp r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foo3D: \n  \"wellformed_policy1 p \\<Longrightarrow> p=DenyAll#ps \\<Longrightarrow> applied_rule_rev Cp x p = Some DenyAll \\<Longrightarrow> r\\<in>set ps \\<Longrightarrow> \n   x \\<notin> dom (Cp r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1 p; p = DenyAll # ps;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAll\\<rfloor>;\n     r \\<in> set ps\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp r)", "by (rule_tac a = \"[]\" and b = \"DenyAll\" and c = \"ps\"  in foo3a, simp_all)"], ["", "lemma foo4[rule_format]: \n  \"set p = set s \\<and> (\\<forall> r. r \\<in> set p \\<longrightarrow> x \\<notin> dom (Cp r)) \\<longrightarrow> (\\<forall> r .r \\<in> set s \\<longrightarrow> x \\<notin> dom (Cp r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set p = set s \\<and>\n    (\\<forall>r.\n        r \\<in> set p \\<longrightarrow>\n        x \\<notin> dom (Cp r)) \\<longrightarrow>\n    (\\<forall>r. r \\<in> set s \\<longrightarrow> x \\<notin> dom (Cp r))", "by simp"], ["", "lemma foo5b[rule_format]: \n  \"x \\<in> dom (Cp b) \\<longrightarrow> (\\<forall> r. r \\<in> set c \\<longrightarrow> x \\<notin> dom (Cp r))\\<longrightarrow> applied_rule_rev Cp x (b#c) = Some b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp b) \\<longrightarrow>\n    (\\<forall>r.\n        r \\<in> set c \\<longrightarrow>\n        x \\<notin> dom (Cp r)) \\<longrightarrow>\n    applied_rule_rev Cp x (b # c) = \\<lfloor>b\\<rfloor>", "apply (simp add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp b) \\<longrightarrow>\n    (\\<forall>r.\n        r \\<in> set c \\<longrightarrow>\n        x \\<notin> dom (Cp r)) \\<longrightarrow>\n    applied_rule Cp x (rev c @ [b]) = \\<lfloor>b\\<rfloor>", "apply (rule_tac xs = c in rev_induct, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mr_first: \n  \"x \\<in> dom (Cp b) \\<Longrightarrow> (\\<forall> r. r \\<in> set c \\<longrightarrow> x \\<notin> dom (Cp r)) \\<Longrightarrow> s = b#c \\<Longrightarrow> \n   applied_rule_rev Cp x s = Some b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (Cp b);\n     \\<forall>r. r \\<in> set c \\<longrightarrow> x \\<notin> dom (Cp r);\n     s = b # c\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x s = \\<lfloor>b\\<rfloor>", "by (simp add: foo5b)"], ["", "lemma mr_charn[rule_format]: \n  \"a \\<in> set p \\<longrightarrow> (x \\<in> dom (Cp a)) \\<longrightarrow>(\\<forall> r. r \\<in> set p \\<and> x \\<in> dom (Cp r) \\<longrightarrow> r = a) \\<longrightarrow>  \n   applied_rule_rev Cp x p = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set p \\<longrightarrow>\n    x \\<in> dom (Cp a) \\<longrightarrow>\n    (\\<forall>r.\n        r \\<in> set p \\<and> x \\<in> dom (Cp r) \\<longrightarrow>\n        r = a) \\<longrightarrow>\n    applied_rule_rev Cp x p = \\<lfloor>a\\<rfloor>", "apply(rule_tac xs = p in rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<in> set [] \\<longrightarrow>\n    x \\<in> dom (Cp a) \\<longrightarrow>\n    (\\<forall>r.\n        r \\<in> set [] \\<and> x \\<in> dom (Cp r) \\<longrightarrow>\n        r = a) \\<longrightarrow>\n    applied_rule_rev Cp x [] = \\<lfloor>a\\<rfloor>\n 2. \\<And>xa xs.\n       a \\<in> set xs \\<longrightarrow>\n       x \\<in> dom (Cp a) \\<longrightarrow>\n       (\\<forall>r.\n           r \\<in> set xs \\<and> x \\<in> dom (Cp r) \\<longrightarrow>\n           r = a) \\<longrightarrow>\n       applied_rule_rev Cp x xs = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       a \\<in> set (xs @ [xa]) \\<longrightarrow>\n       x \\<in> dom (Cp a) \\<longrightarrow>\n       (\\<forall>r.\n           r \\<in> set (xs @ [xa]) \\<and>\n           x \\<in> dom (Cp r) \\<longrightarrow>\n           r = a) \\<longrightarrow>\n       applied_rule_rev Cp x (xs @ [xa]) = \\<lfloor>a\\<rfloor>", "apply(simp_all only:applied_rule_rev_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<in> set [] \\<longrightarrow>\n    x \\<in> dom (Cp a) \\<longrightarrow>\n    (\\<forall>r.\n        r \\<in> set [] \\<and> x \\<in> dom (Cp r) \\<longrightarrow>\n        r = a) \\<longrightarrow>\n    applied_rule Cp x (rev []) = \\<lfloor>a\\<rfloor>\n 2. \\<And>xa xs.\n       a \\<in> set xs \\<longrightarrow>\n       x \\<in> dom (Cp a) \\<longrightarrow>\n       (\\<forall>r.\n           r \\<in> set xs \\<and> x \\<in> dom (Cp r) \\<longrightarrow>\n           r = a) \\<longrightarrow>\n       applied_rule Cp x (rev xs) = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       a \\<in> set (xs @ [xa]) \\<longrightarrow>\n       x \\<in> dom (Cp a) \\<longrightarrow>\n       (\\<forall>r.\n           r \\<in> set (xs @ [xa]) \\<and>\n           x \\<in> dom (Cp r) \\<longrightarrow>\n           r = a) \\<longrightarrow>\n       applied_rule Cp x (rev (xs @ [xa])) = \\<lfloor>a\\<rfloor>", "apply(simp,safe,simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xs y.\n       \\<lbrakk>a = xa; Cp xa x = \\<lfloor>y\\<rfloor>;\n        \\<forall>r.\n           (r = xa \\<or> r \\<in> set xs) \\<and>\n           x \\<in> dom (Cp r) \\<longrightarrow>\n           r = xa;\n        xa \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> dom (Cp xa) \\<longrightarrow>\n                         applied_rule Cp x (rev xs) = \\<lfloor>xa\\<rfloor>\n 2. \\<And>xa xs y r ya.\n       \\<lbrakk>a = xa \\<or> a \\<in> set xs; Cp a x = \\<lfloor>y\\<rfloor>;\n        \\<forall>r.\n           (r = xa \\<or> r \\<in> set xs) \\<and>\n           x \\<in> dom (Cp r) \\<longrightarrow>\n           r = a;\n        (if x \\<in> dom (Cp xa) then \\<lfloor>xa\\<rfloor>\n         else applied_rule Cp x (rev xs)) \\<noteq>\n        \\<lfloor>a\\<rfloor>;\n        r \\<in> set xs; Cp r x = \\<lfloor>ya\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> r = a", "by(auto)"], ["", "lemma foo8: \n  \"\\<forall> r. r \\<in> set p \\<and> x \\<in> dom (Cp r) \\<longrightarrow> r = a \\<Longrightarrow> set p = set s \\<Longrightarrow> \n   \\<forall> r. r \\<in> set s \\<and> x \\<in> dom (Cp r) \\<longrightarrow> r = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>r.\n                r \\<in> set p \\<and> x \\<in> dom (Cp r) \\<longrightarrow>\n                r = a;\n     set p = set s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>r.\n                         r \\<in> set s \\<and>\n                         x \\<in> dom (Cp r) \\<longrightarrow>\n                         r = a", "by auto"], ["", "lemma mrConcEnd[rule_format]: \n  \"applied_rule_rev Cp x (b # p) = Some a \\<longrightarrow> a \\<noteq> b \\<longrightarrow> applied_rule_rev Cp x p = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (b # p) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    a \\<noteq> b \\<longrightarrow>\n    applied_rule_rev Cp x p = \\<lfloor>a\\<rfloor>", "apply (simp add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule Cp x (rev p @ [b]) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    a \\<noteq> b \\<longrightarrow>\n    applied_rule Cp x (rev p) = \\<lfloor>a\\<rfloor>", "apply (rule_tac xs = p in rev_induct,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       applied_rule Cp x (rev xs @ [b]) =\n       \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       a \\<noteq> b \\<longrightarrow>\n       applied_rule Cp x (rev xs) = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       x \\<notin> dom (Cp a) \\<longrightarrow>\n       x \\<in> dom (Cp xa) \\<longrightarrow>\n       xa = a \\<longrightarrow>\n       a \\<noteq> b \\<longrightarrow>\n       applied_rule Cp x (rev xs) = \\<lfloor>a\\<rfloor>", "by auto"], ["", "lemma wp3tl[rule_format]: \"wellformed_policy3Pr p \\<longrightarrow> wellformed_policy3Pr (tl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy3Pr p \\<longrightarrow> wellformed_policy3Pr (tl p)", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       wellformed_policy3Pr p \\<longrightarrow>\n       wellformed_policy3Pr (tl p) \\<Longrightarrow>\n       wellformed_policy3Pr (a # p) \\<longrightarrow> wellformed_policy3Pr p", "subgoal for a as"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy3Pr as \\<longrightarrow>\n    wellformed_policy3Pr (tl as) \\<Longrightarrow>\n    wellformed_policy3Pr (a # as) \\<longrightarrow> wellformed_policy3Pr as", "apply(case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wp3Conc[rule_format]: \"wellformed_policy3Pr (a#p) \\<longrightarrow> wellformed_policy3Pr p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy3Pr (a # p) \\<longrightarrow> wellformed_policy3Pr p", "by (induct p, simp_all, case_tac a, simp_all)"], ["", "lemma foo98[rule_format]:\n  \"applied_rule_rev Cp x (aa # p) = Some a \\<longrightarrow> x \\<in> dom (Cp r) \\<longrightarrow> r \\<in> set p \\<longrightarrow> a \\<in> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (aa # p) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    x \\<in> dom (Cp r) \\<longrightarrow>\n    r \\<in> set p \\<longrightarrow> a \\<in> set p", "unfolding applied_rule_rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule Cp x (rev (aa # p)) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    x \\<in> dom (Cp r) \\<longrightarrow>\n    r \\<in> set p \\<longrightarrow> a \\<in> set p", "proof (induct rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. applied_rule Cp x (rev [aa]) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    x \\<in> dom (Cp r) \\<longrightarrow>\n    r \\<in> set [] \\<longrightarrow> a \\<in> set []\n 2. \\<And>xa xs.\n       applied_rule Cp x (rev (aa # xs)) =\n       \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       x \\<in> dom (Cp r) \\<longrightarrow>\n       r \\<in> set xs \\<longrightarrow> a \\<in> set xs \\<Longrightarrow>\n       applied_rule Cp x (rev (aa # xs @ [xa])) =\n       \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       x \\<in> dom (Cp r) \\<longrightarrow>\n       r \\<in> set (xs @ [xa]) \\<longrightarrow> a \\<in> set (xs @ [xa])", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. applied_rule Cp x (rev [aa]) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    x \\<in> dom (Cp r) \\<longrightarrow>\n    r \\<in> set [] \\<longrightarrow> a \\<in> set []\n 2. \\<And>xa xs.\n       applied_rule Cp x (rev (aa # xs)) =\n       \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       x \\<in> dom (Cp r) \\<longrightarrow>\n       r \\<in> set xs \\<longrightarrow> a \\<in> set xs \\<Longrightarrow>\n       applied_rule Cp x (rev (aa # xs @ [xa])) =\n       \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       x \\<in> dom (Cp r) \\<longrightarrow>\n       r \\<in> set (xs @ [xa]) \\<longrightarrow> a \\<in> set (xs @ [xa])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule Cp x (rev [aa]) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    x \\<in> dom (Cp r) \\<longrightarrow>\n    r \\<in> set [] \\<longrightarrow> a \\<in> set []", "by simp"], ["proof (state)\nthis:\n  applied_rule Cp x (rev [aa]) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n  x \\<in> dom (Cp r) \\<longrightarrow>\n  r \\<in> set [] \\<longrightarrow> a \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       applied_rule Cp x (rev (aa # xs)) =\n       \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       x \\<in> dom (Cp r) \\<longrightarrow>\n       r \\<in> set xs \\<longrightarrow> a \\<in> set xs \\<Longrightarrow>\n       applied_rule Cp x (rev (aa # xs @ [xa])) =\n       \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       x \\<in> dom (Cp r) \\<longrightarrow>\n       r \\<in> set (xs @ [xa]) \\<longrightarrow> a \\<in> set (xs @ [xa])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       applied_rule Cp x (rev (aa # xs)) =\n       \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       x \\<in> dom (Cp r) \\<longrightarrow>\n       r \\<in> set xs \\<longrightarrow> a \\<in> set xs \\<Longrightarrow>\n       applied_rule Cp x (rev (aa # xs @ [xa])) =\n       \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       x \\<in> dom (Cp r) \\<longrightarrow>\n       r \\<in> set (xs @ [xa]) \\<longrightarrow> a \\<in> set (xs @ [xa])", "case (snoc xa xs)"], ["proof (state)\nthis:\n  applied_rule Cp x (rev (aa # xs)) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n  x \\<in> dom (Cp r) \\<longrightarrow>\n  r \\<in> set xs \\<longrightarrow> a \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       applied_rule Cp x (rev (aa # xs)) =\n       \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       x \\<in> dom (Cp r) \\<longrightarrow>\n       r \\<in> set xs \\<longrightarrow> a \\<in> set xs \\<Longrightarrow>\n       applied_rule Cp x (rev (aa # xs @ [xa])) =\n       \\<lfloor>a\\<rfloor> \\<longrightarrow>\n       x \\<in> dom (Cp r) \\<longrightarrow>\n       r \\<in> set (xs @ [xa]) \\<longrightarrow> a \\<in> set (xs @ [xa])", "then"], ["proof (chain)\npicking this:\n  applied_rule Cp x (rev (aa # xs)) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n  x \\<in> dom (Cp r) \\<longrightarrow>\n  r \\<in> set xs \\<longrightarrow> a \\<in> set xs", "show ?case"], ["proof (prove)\nusing this:\n  applied_rule Cp x (rev (aa # xs)) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n  x \\<in> dom (Cp r) \\<longrightarrow>\n  r \\<in> set xs \\<longrightarrow> a \\<in> set xs\n\ngoal (1 subgoal):\n 1. applied_rule Cp x (rev (aa # xs @ [xa])) =\n    \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    x \\<in> dom (Cp r) \\<longrightarrow>\n    r \\<in> set (xs @ [xa]) \\<longrightarrow> a \\<in> set (xs @ [xa])", "by simp_all (case_tac \"r = xa\", simp_all)"], ["proof (state)\nthis:\n  applied_rule Cp x (rev (aa # xs @ [xa])) =\n  \\<lfloor>a\\<rfloor> \\<longrightarrow>\n  x \\<in> dom (Cp r) \\<longrightarrow>\n  r \\<in> set (xs @ [xa]) \\<longrightarrow> a \\<in> set (xs @ [xa])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mrMTNone[simp]: \"applied_rule_rev Cp x [] = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x [] = \\<bottom>", "by (simp add: applied_rule_rev_def)"], ["", "lemma DAAux[simp]: \"x \\<in> dom (Cp DenyAll)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp DenyAll)", "by (simp add: dom_def PolicyCombinators.PolicyCombinators Cp.simps)"], ["", "lemma mrSet[rule_format]: \"applied_rule_rev Cp x p = Some r \\<longrightarrow> r \\<in> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = \\<lfloor>r\\<rfloor> \\<longrightarrow>\n    r \\<in> set p", "unfolding  applied_rule_rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule Cp x (rev p) = \\<lfloor>r\\<rfloor> \\<longrightarrow>\n    r \\<in> set p", "by (rule_tac xs=p in rev_induct) simp_all"], ["", "lemma mr_not_Conc: \"singleCombinators p \\<Longrightarrow> applied_rule_rev Cp x p \\<noteq> Some (a\\<oplus>b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<Longrightarrow>\n    applied_rule_rev Cp x p \\<noteq> \\<lfloor>a \\<oplus> b\\<rfloor>", "by (auto simp:  mrSet dest: mrSet elim: SCnotConc)"], ["", "lemma foo25[rule_format]: \"wellformed_policy3Pr (p@[x]) \\<longrightarrow> wellformed_policy3Pr p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy3Pr (p @ [x]) \\<longrightarrow> wellformed_policy3Pr p", "apply(induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       wellformed_policy3Pr (p @ [x]) \\<longrightarrow>\n       wellformed_policy3Pr p \\<Longrightarrow>\n       wellformed_policy3Pr (a # p @ [x]) \\<longrightarrow>\n       wellformed_policy3Pr (a # p)", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy3Pr (p @ [x]) \\<longrightarrow>\n    wellformed_policy3Pr p \\<Longrightarrow>\n    wellformed_policy3Pr (a # p @ [x]) \\<longrightarrow>\n    wellformed_policy3Pr (a # p)", "apply(case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mr_in_dom[rule_format]: \"applied_rule_rev Cp x p = Some a \\<longrightarrow> x \\<in> dom (Cp a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    x \\<in> dom (Cp a)", "by (rule_tac xs = p in rev_induct) (auto simp: applied_rule_rev_def)"], ["", "lemma wp3EndMT[rule_format]: \n  \"wellformed_policy3Pr (p@[xs]) \\<longrightarrow>  AllowPortFromTo a b po \\<in> set p \\<longrightarrow>\n   dom (Cp (AllowPortFromTo a b po)) \\<inter> dom (Cp xs) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy3Pr (p @ [xs]) \\<longrightarrow>\n    AllowPortFromTo a b po \\<in> set p \\<longrightarrow>\n    dom (Cp (AllowPortFromTo a b po)) \\<inter> dom (Cp xs) = {}", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       wellformed_policy3Pr (p @ [xs]) \\<longrightarrow>\n       AllowPortFromTo a b po \\<in> set p \\<longrightarrow>\n       dom (Cp (AllowPortFromTo a b po)) \\<inter> dom (Cp xs) =\n       {} \\<Longrightarrow>\n       wellformed_policy3Pr (aa # p @ [xs]) \\<longrightarrow>\n       (AllowPortFromTo a b po = aa \\<longrightarrow>\n        dom (Cp aa) \\<inter> dom (Cp xs) = {}) \\<and>\n       (AllowPortFromTo a b po \\<in> set p \\<longrightarrow>\n        dom (Cp (AllowPortFromTo a b po)) \\<inter> dom (Cp xs) = {})", "by (metis NormalisationIPPProofs.wp3Conc aux0_4 inf_commute list.set_intros(1) \n      wellformed_policy3Pr.simps(2))"], ["", "lemma foo29: \"dom (Cp a) \\<noteq> {} \\<Longrightarrow> dom (Cp a) \\<inter> dom (Cp b) = {} \\<Longrightarrow> a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom (Cp a) \\<noteq> {};\n     dom (Cp a) \\<inter> dom (Cp b) = {}\\<rbrakk>\n    \\<Longrightarrow> a \\<noteq> b", "by auto"], ["", "lemma foo28:  \n  \"AllowPortFromTo a b po\\<in>set p \\<Longrightarrow> dom(Cp(AllowPortFromTo a b po))\\<noteq>{} \\<Longrightarrow> \n   (wellformed_policy3Pr(p@[x])) \\<Longrightarrow> \n   x \\<noteq> AllowPortFromTo a b po\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo a b po \\<in> set p;\n     dom (Cp (AllowPortFromTo a b po)) \\<noteq> {};\n     wellformed_policy3Pr (p @ [x])\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> AllowPortFromTo a b po", "by (metis foo29 Cp.simps(3) wp3EndMT)"], ["", "lemma foo28a[rule_format]: \"x \\<in> dom (Cp a) \\<Longrightarrow> dom (Cp a) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp a) \\<Longrightarrow> dom (Cp a) \\<noteq> {}", "by auto"], ["", "lemma allow_deny_dom[simp]: \n  \"dom (Cp (AllowPortFromTo a b po)) \\<subseteq> dom (Cp (DenyAllFromTo a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (Cp (AllowPortFromTo a b po))\n    \\<subseteq> dom (Cp (DenyAllFromTo a b))", "by (simp_all add: twoNetsDistinct_def netsDistinct_def PLemmas) auto"], ["", "lemma DenyAllowDisj: \n  \"dom (Cp (AllowPortFromTo a b p)) \\<noteq> {} \\<Longrightarrow> \n   dom (Cp (DenyAllFromTo a b)) \\<inter> dom (Cp (AllowPortFromTo a b p))  \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (Cp (AllowPortFromTo a b p)) \\<noteq> {} \\<Longrightarrow>\n    dom (Cp (DenyAllFromTo a b)) \\<inter>\n    dom (Cp (AllowPortFromTo a b p)) \\<noteq>\n    {}", "by (metis Int_absorb1 allow_deny_dom)"], ["", "lemma foo31: \n  \"\\<forall> r. r \\<in> set p \\<and> x \\<in> dom (Cp r) \\<longrightarrow> \n         (r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll) \\<Longrightarrow> \n   set p = set s \\<Longrightarrow> \n   (\\<forall>r. r\\<in>set s \\<and> x\\<in>dom(Cp r) \\<longrightarrow> r=AllowPortFromTo a b po \\<or> r=DenyAllFromTo a b \\<or> r = DenyAll)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>r.\n                r \\<in> set p \\<and> x \\<in> dom (Cp r) \\<longrightarrow>\n                r = AllowPortFromTo a b po \\<or>\n                r = DenyAllFromTo a b \\<or> r = DenyAll;\n     set p = set s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>r.\n                         r \\<in> set s \\<and>\n                         x \\<in> dom (Cp r) \\<longrightarrow>\n                         r = AllowPortFromTo a b po \\<or>\n                         r = DenyAllFromTo a b \\<or> r = DenyAll", "by auto"], ["", "lemma wp1_auxa: \"wellformed_policy1_strong p\\<Longrightarrow>(\\<exists> r. applied_rule_rev Cp x p = Some r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<Longrightarrow>\n    \\<exists>r. applied_rule_rev Cp x p = \\<lfloor>r\\<rfloor>", "apply (rule DAimpliesMR_E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<Longrightarrow> DenyAll \\<in> set p", "by (erule wp1_aux1aa)"], ["", "lemma deny_dom[simp]:  \n  \"twoNetsDistinct a b c d \\<Longrightarrow> dom (Cp (DenyAllFromTo a b)) \\<inter> dom (Cp (DenyAllFromTo c d)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. twoNetsDistinct a b c d \\<Longrightarrow>\n    dom (Cp (DenyAllFromTo a b)) \\<inter> dom (Cp (DenyAllFromTo c d)) = {}", "by (simp add: Cp.simps) (erule aux6)"], ["", "lemma domTrans: \"\\<lbrakk>dom a \\<subseteq> dom b; dom(b) \\<inter> dom (c) = {}\\<rbrakk> \\<Longrightarrow> dom(a) \\<inter> dom(c) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom a \\<subseteq> dom b; dom b \\<inter> dom c = {}\\<rbrakk>\n    \\<Longrightarrow> dom a \\<inter> dom c = {}", "by auto"], ["", "lemma DomInterAllowsMT: \n  \" twoNetsDistinct a b c d \\<Longrightarrow> dom (Cp(AllowPortFromTo a b p)) \\<inter> dom(Cp(AllowPortFromTo c d po))={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. twoNetsDistinct a b c d \\<Longrightarrow>\n    dom (Cp (AllowPortFromTo a b p)) \\<inter>\n    dom (Cp (AllowPortFromTo c d po)) =\n    {}", "apply (case_tac \"p = po\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>twoNetsDistinct a b c d; p = po\\<rbrakk>\n    \\<Longrightarrow> dom (Cp (AllowPortFromTo a b po)) \\<inter>\n                      dom (Cp (AllowPortFromTo c d po)) =\n                      {}\n 2. \\<lbrakk>twoNetsDistinct a b c d; p \\<noteq> po\\<rbrakk>\n    \\<Longrightarrow> dom (Cp (AllowPortFromTo a b p)) \\<inter>\n                      dom (Cp (AllowPortFromTo c d po)) =\n                      {}", "apply (rule_tac b = \"Cp (DenyAllFromTo a b)\" in domTrans, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>twoNetsDistinct a b c d; p = po\\<rbrakk>\n    \\<Longrightarrow> dom (Cp (DenyAllFromTo a b)) \\<inter>\n                      dom (Cp (AllowPortFromTo c d po)) =\n                      {}\n 2. \\<lbrakk>twoNetsDistinct a b c d; p \\<noteq> po\\<rbrakk>\n    \\<Longrightarrow> dom (Cp (AllowPortFromTo a b p)) \\<inter>\n                      dom (Cp (AllowPortFromTo c d po)) =\n                      {}", "apply (metis domComm aux26 tNDComm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>twoNetsDistinct a b c d; p \\<noteq> po\\<rbrakk>\n    \\<Longrightarrow> dom (Cp (AllowPortFromTo a b p)) \\<inter>\n                      dom (Cp (AllowPortFromTo c d po)) =\n                      {}", "apply (simp add: twoNetsDistinct_def netsDistinct_def PLemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>aa ab b.\n                 (\\<forall>x\\<in>a. (aa, ab, b) \\<notin> x) \\<or>\n                 (\\<forall>x\\<in>c. (aa, ab, b) \\<notin> x)) \\<or>\n             (\\<forall>a aa ba.\n                 (\\<forall>x\\<in>b. (a, aa, ba) \\<notin> x) \\<or>\n                 (\\<forall>x\\<in>d. (a, aa, ba) \\<notin> x));\n     p \\<noteq> po\\<rbrakk>\n    \\<Longrightarrow> {aa.\n                       ((\\<exists>x\\<in>a. fst (snd aa) \\<in> x) \\<and>\n                        (\\<exists>x\\<in>b.\n                            fst (snd (snd aa)) \\<in> x) \\<longrightarrow>\n                        (fst (snd (fst (snd (snd aa)))) =\n                         snd p \\<longrightarrow>\n                         snd (snd (fst (snd (snd aa)))) = fst p) \\<and>\n                        fst (snd (fst (snd (snd aa)))) = snd p) \\<and>\n                       (\\<exists>x\\<in>a. fst (snd aa) \\<in> x) \\<and>\n                       (\\<exists>x\\<in>b.\n                           fst (snd (snd aa)) \\<in> x)} \\<inter>\n                      {a. ((\\<exists>x\\<in>c. fst (snd a) \\<in> x) \\<and>\n                           (\\<exists>x\\<in>d.\n                               fst (snd (snd a)) \\<in> x) \\<longrightarrow>\n                           (fst (snd (fst (snd (snd a)))) =\n                            snd po \\<longrightarrow>\n                            snd (snd (fst (snd (snd a)))) = fst po) \\<and>\n                           fst (snd (fst (snd (snd a)))) = snd po) \\<and>\n                          (\\<exists>x\\<in>c. fst (snd a) \\<in> x) \\<and>\n                          (\\<exists>x\\<in>d. fst (snd (snd a)) \\<in> x)} =\n                      {}", "by (auto simp: prod_eqI)"], ["", "lemma DomInterAllowsMT_Ports: \n  \"p \\<noteq> po \\<Longrightarrow> dom (Cp (AllowPortFromTo a b p)) \\<inter> dom (Cp (AllowPortFromTo c d po)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> po \\<Longrightarrow>\n    dom (Cp (AllowPortFromTo a b p)) \\<inter>\n    dom (Cp (AllowPortFromTo c d po)) =\n    {}", "apply (simp add: twoNetsDistinct_def netsDistinct_def PLemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> po \\<Longrightarrow>\n    {aa.\n     ((\\<exists>x\\<in>a. fst (snd aa) \\<in> x) \\<and>\n      (\\<exists>x\\<in>b. fst (snd (snd aa)) \\<in> x) \\<longrightarrow>\n      (fst (snd (fst (snd (snd aa)))) = snd p \\<longrightarrow>\n       snd (snd (fst (snd (snd aa)))) = fst p) \\<and>\n      fst (snd (fst (snd (snd aa)))) = snd p) \\<and>\n     (\\<exists>x\\<in>a. fst (snd aa) \\<in> x) \\<and>\n     (\\<exists>x\\<in>b. fst (snd (snd aa)) \\<in> x)} \\<inter>\n    {a. ((\\<exists>x\\<in>c. fst (snd a) \\<in> x) \\<and>\n         (\\<exists>x\\<in>d. fst (snd (snd a)) \\<in> x) \\<longrightarrow>\n         (fst (snd (fst (snd (snd a)))) = snd po \\<longrightarrow>\n          snd (snd (fst (snd (snd a)))) = fst po) \\<and>\n         fst (snd (fst (snd (snd a)))) = snd po) \\<and>\n        (\\<exists>x\\<in>c. fst (snd a) \\<in> x) \\<and>\n        (\\<exists>x\\<in>d. fst (snd (snd a)) \\<in> x)} =\n    {}", "by (auto simp: prod_eqI)"], ["", "lemma wellformed_policy3_charn[rule_format]: \n  \"singleCombinators p \\<longrightarrow> distinct p \\<longrightarrow> allNetsDistinct p \\<longrightarrow> \n   wellformed_policy1 p \\<longrightarrow> wellformed_policy2Pr p  \\<longrightarrow> wellformed_policy3Pr p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<longrightarrow>\n    distinct p \\<longrightarrow>\n    allNetsDistinct p \\<longrightarrow>\n    wellformed_policy1 p \\<longrightarrow>\n    wellformed_policy2Pr p \\<longrightarrow> wellformed_policy3Pr p", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. singleCombinators [] \\<longrightarrow>\n    distinct [] \\<longrightarrow>\n    allNetsDistinct [] \\<longrightarrow>\n    wellformed_policy1 [] \\<longrightarrow>\n    wellformed_policy2Pr [] \\<longrightarrow> wellformed_policy3Pr []\n 2. \\<And>a p.\n       singleCombinators p \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow>\n       wellformed_policy1 p \\<longrightarrow>\n       wellformed_policy2Pr p \\<longrightarrow>\n       wellformed_policy3Pr p \\<Longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       wellformed_policy1 (a # p) \\<longrightarrow>\n       wellformed_policy2Pr (a # p) \\<longrightarrow>\n       wellformed_policy3Pr (a # p)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. singleCombinators [] \\<longrightarrow>\n    distinct [] \\<longrightarrow>\n    allNetsDistinct [] \\<longrightarrow>\n    wellformed_policy1 [] \\<longrightarrow>\n    wellformed_policy2Pr [] \\<longrightarrow> wellformed_policy3Pr []\n 2. \\<And>a p.\n       singleCombinators p \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow>\n       wellformed_policy1 p \\<longrightarrow>\n       wellformed_policy2Pr p \\<longrightarrow>\n       wellformed_policy3Pr p \\<Longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       wellformed_policy1 (a # p) \\<longrightarrow>\n       wellformed_policy2Pr (a # p) \\<longrightarrow>\n       wellformed_policy3Pr (a # p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators [] \\<longrightarrow>\n    distinct [] \\<longrightarrow>\n    allNetsDistinct [] \\<longrightarrow>\n    wellformed_policy1 [] \\<longrightarrow>\n    wellformed_policy2Pr [] \\<longrightarrow> wellformed_policy3Pr []", "by simp"], ["proof (state)\nthis:\n  singleCombinators [] \\<longrightarrow>\n  distinct [] \\<longrightarrow>\n  allNetsDistinct [] \\<longrightarrow>\n  wellformed_policy1 [] \\<longrightarrow>\n  wellformed_policy2Pr [] \\<longrightarrow> wellformed_policy3Pr []\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       singleCombinators p \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow>\n       wellformed_policy1 p \\<longrightarrow>\n       wellformed_policy2Pr p \\<longrightarrow>\n       wellformed_policy3Pr p \\<Longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       wellformed_policy1 (a # p) \\<longrightarrow>\n       wellformed_policy2Pr (a # p) \\<longrightarrow>\n       wellformed_policy3Pr (a # p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       singleCombinators p \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow>\n       wellformed_policy1 p \\<longrightarrow>\n       wellformed_policy2Pr p \\<longrightarrow>\n       wellformed_policy3Pr p \\<Longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       wellformed_policy1 (a # p) \\<longrightarrow>\n       wellformed_policy2Pr (a # p) \\<longrightarrow>\n       wellformed_policy3Pr (a # p)", "case (Cons a p)"], ["proof (state)\nthis:\n  singleCombinators p \\<longrightarrow>\n  distinct p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow>\n  wellformed_policy1 p \\<longrightarrow>\n  wellformed_policy2Pr p \\<longrightarrow> wellformed_policy3Pr p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       singleCombinators p \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow>\n       wellformed_policy1 p \\<longrightarrow>\n       wellformed_policy2Pr p \\<longrightarrow>\n       wellformed_policy3Pr p \\<Longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       wellformed_policy1 (a # p) \\<longrightarrow>\n       wellformed_policy2Pr (a # p) \\<longrightarrow>\n       wellformed_policy3Pr (a # p)", "then"], ["proof (chain)\npicking this:\n  singleCombinators p \\<longrightarrow>\n  distinct p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow>\n  wellformed_policy1 p \\<longrightarrow>\n  wellformed_policy2Pr p \\<longrightarrow> wellformed_policy3Pr p", "show ?case"], ["proof (prove)\nusing this:\n  singleCombinators p \\<longrightarrow>\n  distinct p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow>\n  wellformed_policy1 p \\<longrightarrow>\n  wellformed_policy2Pr p \\<longrightarrow> wellformed_policy3Pr p\n\ngoal (1 subgoal):\n 1. singleCombinators (a # p) \\<longrightarrow>\n    distinct (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    wellformed_policy1 (a # p) \\<longrightarrow>\n    wellformed_policy2Pr (a # p) \\<longrightarrow>\n    wellformed_policy3Pr (a # p)", "apply (auto intro: singleCombinatorsConc ANDConc waux2 wp2Conc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators (a # p); a \\<notin> set p; distinct p;\n     allNetsDistinct (a # p); DenyAll \\<notin> set p;\n     wellformed_policy2Pr (a # p); wellformed_policy3Pr p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy3Pr (a # p)", "apply (case_tac a,simp_all, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 aa b r.\n       \\<lbrakk>singleCombinators p;\n        AllowPortFromTo x31 x32 (aa, b) \\<notin> set p; distinct p;\n        allNetsDistinct (AllowPortFromTo x31 x32 (aa, b) # p);\n        DenyAll \\<notin> set p; wellformed_policy3Pr p;\n        a = AllowPortFromTo x31 x32 (aa, b);\n        \\<forall>a ba.\n           DenyAllFromTo a ba \\<in> set p \\<longrightarrow>\n           dom (Cp (AllowPortFromTo x31 x32 (aa, b))) \\<inter>\n           dom (Cp (DenyAllFromTo a ba)) =\n           {};\n        wellformed_policy2Pr p; r \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> dom (Cp r) \\<inter>\n                         dom (Cp (AllowPortFromTo x31 x32 (aa, b))) =\n                         {}", "subgoal for a b c d r"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; AllowPortFromTo a b (c, d) \\<notin> set p;\n     distinct p; allNetsDistinct (AllowPortFromTo a b (c, d) # p);\n     DenyAll \\<notin> set p; wellformed_policy3Pr p;\n     a__ = AllowPortFromTo a b (c, d);\n     \\<forall>a ba.\n        DenyAllFromTo a ba \\<in> set p \\<longrightarrow>\n        dom (Cp (AllowPortFromTo a b (c, d))) \\<inter>\n        dom (Cp (DenyAllFromTo a ba)) =\n        {};\n     wellformed_policy2Pr p; r \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> dom (Cp r) \\<inter>\n                      dom (Cp (AllowPortFromTo a b (c, d))) =\n                      {}", "apply (case_tac r,simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>singleCombinators p;\n        AllowPortFromTo a b (c, d) \\<notin> set p; distinct p;\n        allNetsDistinct (AllowPortFromTo a b (c, d) # p);\n        DenyAll \\<notin> set p; wellformed_policy3Pr p;\n        a__ = AllowPortFromTo a b (c, d);\n        \\<forall>a ba.\n           DenyAllFromTo a ba \\<in> set p \\<longrightarrow>\n           dom (Cp (AllowPortFromTo a b (c, d))) \\<inter>\n           dom (Cp (DenyAllFromTo a ba)) =\n           {};\n        wellformed_policy2Pr p; DenyAllFromTo x21 x22 \\<in> set p;\n        r = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> dom (Cp (DenyAllFromTo x21 x22)) \\<inter>\n                         dom (Cp (AllowPortFromTo a b (c, d))) =\n                         {}\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>singleCombinators p;\n        AllowPortFromTo a b (c, d) \\<notin> set p; distinct p;\n        allNetsDistinct (AllowPortFromTo a b (c, d) # p);\n        DenyAll \\<notin> set p; wellformed_policy3Pr p;\n        a__ = AllowPortFromTo a b (c, d);\n        \\<forall>a ba.\n           DenyAllFromTo a ba \\<in> set p \\<longrightarrow>\n           dom (Cp (AllowPortFromTo a b (c, d))) \\<inter>\n           dom (Cp (DenyAllFromTo a ba)) =\n           {};\n        wellformed_policy2Pr p; AllowPortFromTo x31 x32 x33 \\<in> set p;\n        r = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> dom (Cp (AllowPortFromTo x31 x32 x33)) \\<inter>\n                         dom (Cp (AllowPortFromTo a b (c, d))) =\n                         {}\n 3. \\<And>x41 x42.\n       \\<lbrakk>singleCombinators p;\n        AllowPortFromTo a b (c, d) \\<notin> set p; distinct p;\n        allNetsDistinct (AllowPortFromTo a b (c, d) # p);\n        DenyAll \\<notin> set p; wellformed_policy3Pr p;\n        a__ = AllowPortFromTo a b (c, d);\n        \\<forall>a ba.\n           DenyAllFromTo a ba \\<in> set p \\<longrightarrow>\n           dom (Cp (AllowPortFromTo a b (c, d))) \\<inter>\n           dom (Cp (DenyAllFromTo a ba)) =\n           {};\n        wellformed_policy2Pr p; x41 \\<oplus> x42 \\<in> set p;\n        r = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> dom (Cp (x41 \\<oplus> x42)) \\<inter>\n                         dom (Cp (AllowPortFromTo a b (c, d))) =\n                         {}", "apply (metis Int_commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>singleCombinators p;\n        AllowPortFromTo a b (c, d) \\<notin> set p; distinct p;\n        allNetsDistinct (AllowPortFromTo a b (c, d) # p);\n        DenyAll \\<notin> set p; wellformed_policy3Pr p;\n        a__ = AllowPortFromTo a b (c, d);\n        \\<forall>a ba.\n           DenyAllFromTo a ba \\<in> set p \\<longrightarrow>\n           dom (Cp (AllowPortFromTo a b (c, d))) \\<inter>\n           dom (Cp (DenyAllFromTo a ba)) =\n           {};\n        wellformed_policy2Pr p; AllowPortFromTo x31 x32 x33 \\<in> set p;\n        r = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> dom (Cp (AllowPortFromTo x31 x32 x33)) \\<inter>\n                         dom (Cp (AllowPortFromTo a b (c, d))) =\n                         {}\n 2. \\<And>x41 x42.\n       \\<lbrakk>singleCombinators p;\n        AllowPortFromTo a b (c, d) \\<notin> set p; distinct p;\n        allNetsDistinct (AllowPortFromTo a b (c, d) # p);\n        DenyAll \\<notin> set p; wellformed_policy3Pr p;\n        a__ = AllowPortFromTo a b (c, d);\n        \\<forall>a ba.\n           DenyAllFromTo a ba \\<in> set p \\<longrightarrow>\n           dom (Cp (AllowPortFromTo a b (c, d))) \\<inter>\n           dom (Cp (DenyAllFromTo a ba)) =\n           {};\n        wellformed_policy2Pr p; x41 \\<oplus> x42 \\<in> set p;\n        r = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> dom (Cp (x41 \\<oplus> x42)) \\<inter>\n                         dom (Cp (AllowPortFromTo a b (c, d))) =\n                         {}", "apply (metis DomInterAllowsMT aux7aa DomInterAllowsMT_Ports)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>singleCombinators p;\n        AllowPortFromTo a b (c, d) \\<notin> set p; distinct p;\n        allNetsDistinct (AllowPortFromTo a b (c, d) # p);\n        DenyAll \\<notin> set p; wellformed_policy3Pr p;\n        a__ = AllowPortFromTo a b (c, d);\n        \\<forall>a ba.\n           DenyAllFromTo a ba \\<in> set p \\<longrightarrow>\n           dom (Cp (AllowPortFromTo a b (c, d))) \\<inter>\n           dom (Cp (DenyAllFromTo a ba)) =\n           {};\n        wellformed_policy2Pr p; x41 \\<oplus> x42 \\<in> set p;\n        r = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> dom (Cp (x41 \\<oplus> x42)) \\<inter>\n                         dom (Cp (AllowPortFromTo a b (c, d))) =\n                         {}", "apply (metis aux0_0 )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  singleCombinators (a # p) \\<longrightarrow>\n  distinct (a # p) \\<longrightarrow>\n  allNetsDistinct (a # p) \\<longrightarrow>\n  wellformed_policy1 (a # p) \\<longrightarrow>\n  wellformed_policy2Pr (a # p) \\<longrightarrow>\n  wellformed_policy3Pr (a # p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma DistinctNetsDenyAllow: \n  \"DenyAllFromTo b c \\<in> set p \\<Longrightarrow> AllowPortFromTo a d po \\<in> set p\\<Longrightarrow> allNetsDistinct p \\<Longrightarrow>\n  dom (Cp (DenyAllFromTo b c)) \\<inter> dom (Cp (AllowPortFromTo a d po)) \\<noteq> {}\\<Longrightarrow>\n  b = a \\<and> c = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAllFromTo b c \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p; allNetsDistinct p;\n     dom (Cp (DenyAllFromTo b c)) \\<inter>\n     dom (Cp (AllowPortFromTo a d po)) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d", "apply (simp add: allNetsDistinct_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAllFromTo b c \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     \\<forall>a b.\n        a \\<noteq> b \\<and>\n        a \\<in> set (net_list_aux p) \\<and>\n        b \\<in> set (net_list_aux p) \\<longrightarrow>\n        netsDistinct a b;\n     dom (Cp (DenyAllFromTo b c)) \\<inter>\n     dom (Cp (AllowPortFromTo a d po)) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d", "apply (frule_tac x = \"b\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAllFromTo b c \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     \\<forall>a b.\n        a \\<noteq> b \\<and>\n        a \\<in> set (net_list_aux p) \\<and>\n        b \\<in> set (net_list_aux p) \\<longrightarrow>\n        netsDistinct a b;\n     dom (Cp (DenyAllFromTo b c)) \\<inter>\n     dom (Cp (AllowPortFromTo a d po)) \\<noteq>\n     {};\n     \\<forall>ba.\n        b \\<noteq> ba \\<and>\n        b \\<in> set (net_list_aux p) \\<and>\n        ba \\<in> set (net_list_aux p) \\<longrightarrow>\n        netsDistinct b ba\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d", "apply (drule_tac x = \"d\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAllFromTo b c \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     dom (Cp (DenyAllFromTo b c)) \\<inter>\n     dom (Cp (AllowPortFromTo a d po)) \\<noteq>\n     {};\n     \\<forall>ba.\n        b \\<noteq> ba \\<and>\n        b \\<in> set (net_list_aux p) \\<and>\n        ba \\<in> set (net_list_aux p) \\<longrightarrow>\n        netsDistinct b ba;\n     \\<forall>b.\n        d \\<noteq> b \\<and>\n        d \\<in> set (net_list_aux p) \\<and>\n        b \\<in> set (net_list_aux p) \\<longrightarrow>\n        netsDistinct d b\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d", "apply (drule_tac x = \"a\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAllFromTo b c \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     dom (Cp (DenyAllFromTo b c)) \\<inter>\n     dom (Cp (AllowPortFromTo a d po)) \\<noteq>\n     {};\n     \\<forall>b.\n        d \\<noteq> b \\<and>\n        d \\<in> set (net_list_aux p) \\<and>\n        b \\<in> set (net_list_aux p) \\<longrightarrow>\n        netsDistinct d b;\n     b \\<noteq> a \\<and>\n     b \\<in> set (net_list_aux p) \\<and>\n     a \\<in> set (net_list_aux p) \\<longrightarrow>\n     netsDistinct b a\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d", "apply (drule_tac x = \"c\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAllFromTo b c \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     dom (Cp (DenyAllFromTo b c)) \\<inter>\n     dom (Cp (AllowPortFromTo a d po)) \\<noteq>\n     {};\n     b \\<noteq> a \\<and>\n     b \\<in> set (net_list_aux p) \\<and>\n     a \\<in> set (net_list_aux p) \\<longrightarrow>\n     netsDistinct b a;\n     d \\<noteq> c \\<and>\n     d \\<in> set (net_list_aux p) \\<and>\n     c \\<in> set (net_list_aux p) \\<longrightarrow>\n     netsDistinct d c\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d", "apply (metis Int_commute ND0aux1 ND0aux3 NDComm aux26 twoNetsDistinct_def ND0aux2 ND0aux4)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma DistinctNetsAllowAllow: \n  \"AllowPortFromTo b c poo \\<in> set p \\<Longrightarrow> AllowPortFromTo a d po \\<in> set p \\<Longrightarrow> \n  allNetsDistinct p \\<Longrightarrow> dom(Cp(AllowPortFromTo b c poo)) \\<inter> dom(Cp(AllowPortFromTo a d po)) \\<noteq> {} \\<Longrightarrow> \n  b = a \\<and> c = d \\<and> poo = po\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo b c poo \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p; allNetsDistinct p;\n     dom (Cp (AllowPortFromTo b c poo)) \\<inter>\n     dom (Cp (AllowPortFromTo a d po)) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d \\<and> poo = po", "apply (simp add: allNetsDistinct_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo b c poo \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     \\<forall>a b.\n        a \\<noteq> b \\<and>\n        a \\<in> set (net_list_aux p) \\<and>\n        b \\<in> set (net_list_aux p) \\<longrightarrow>\n        netsDistinct a b;\n     dom (Cp (AllowPortFromTo b c poo)) \\<inter>\n     dom (Cp (AllowPortFromTo a d po)) \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d \\<and> poo = po", "apply (frule_tac x = \"b\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo b c poo \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     \\<forall>a b.\n        a \\<noteq> b \\<and>\n        a \\<in> set (net_list_aux p) \\<and>\n        b \\<in> set (net_list_aux p) \\<longrightarrow>\n        netsDistinct a b;\n     dom (Cp (AllowPortFromTo b c poo)) \\<inter>\n     dom (Cp (AllowPortFromTo a d po)) \\<noteq>\n     {};\n     \\<forall>ba.\n        b \\<noteq> ba \\<and>\n        b \\<in> set (net_list_aux p) \\<and>\n        ba \\<in> set (net_list_aux p) \\<longrightarrow>\n        netsDistinct b ba\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d \\<and> poo = po", "apply (drule_tac x = \"d\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo b c poo \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     dom (Cp (AllowPortFromTo b c poo)) \\<inter>\n     dom (Cp (AllowPortFromTo a d po)) \\<noteq>\n     {};\n     \\<forall>ba.\n        b \\<noteq> ba \\<and>\n        b \\<in> set (net_list_aux p) \\<and>\n        ba \\<in> set (net_list_aux p) \\<longrightarrow>\n        netsDistinct b ba;\n     \\<forall>b.\n        d \\<noteq> b \\<and>\n        d \\<in> set (net_list_aux p) \\<and>\n        b \\<in> set (net_list_aux p) \\<longrightarrow>\n        netsDistinct d b\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d \\<and> poo = po", "apply (drule_tac x = \"a\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo b c poo \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     dom (Cp (AllowPortFromTo b c poo)) \\<inter>\n     dom (Cp (AllowPortFromTo a d po)) \\<noteq>\n     {};\n     \\<forall>b.\n        d \\<noteq> b \\<and>\n        d \\<in> set (net_list_aux p) \\<and>\n        b \\<in> set (net_list_aux p) \\<longrightarrow>\n        netsDistinct d b;\n     b \\<noteq> a \\<and>\n     b \\<in> set (net_list_aux p) \\<and>\n     a \\<in> set (net_list_aux p) \\<longrightarrow>\n     netsDistinct b a\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d \\<and> poo = po", "apply (drule_tac x = \"c\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo b c poo \\<in> set p;\n     AllowPortFromTo a d po \\<in> set p;\n     dom (Cp (AllowPortFromTo b c poo)) \\<inter>\n     dom (Cp (AllowPortFromTo a d po)) \\<noteq>\n     {};\n     b \\<noteq> a \\<and>\n     b \\<in> set (net_list_aux p) \\<and>\n     a \\<in> set (net_list_aux p) \\<longrightarrow>\n     netsDistinct b a;\n     d \\<noteq> c \\<and>\n     d \\<in> set (net_list_aux p) \\<and>\n     c \\<in> set (net_list_aux p) \\<longrightarrow>\n     netsDistinct d c\\<rbrakk>\n    \\<Longrightarrow> b = a \\<and> c = d \\<and> poo = po", "apply (metis DomInterAllowsMT DomInterAllowsMT_Ports ND0aux3 ND0aux4 NDComm  twoNetsDistinct_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WP2RS2[simp]: \n  \"singleCombinators p \\<Longrightarrow> distinct p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> \n   wellformed_policy2Pr (removeShadowRules2 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; distinct p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2Pr (removeShadowRules2 p)", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>singleCombinators []; distinct []; allNetsDistinct []\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2Pr (removeShadowRules2 [])\n 2. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>singleCombinators p; distinct p;\n                 allNetsDistinct p\\<rbrakk>\n                \\<Longrightarrow> wellformed_policy2Pr\n                                   (removeShadowRules2 p);\n        singleCombinators (a # p); distinct (a # p);\n        allNetsDistinct (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy2Pr (removeShadowRules2 (a # p))", "case Nil"], ["proof (state)\nthis:\n  singleCombinators []\n  distinct []\n  allNetsDistinct []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>singleCombinators []; distinct []; allNetsDistinct []\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2Pr (removeShadowRules2 [])\n 2. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>singleCombinators p; distinct p;\n                 allNetsDistinct p\\<rbrakk>\n                \\<Longrightarrow> wellformed_policy2Pr\n                                   (removeShadowRules2 p);\n        singleCombinators (a # p); distinct (a # p);\n        allNetsDistinct (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy2Pr (removeShadowRules2 (a # p))", "then"], ["proof (chain)\npicking this:\n  singleCombinators []\n  distinct []\n  allNetsDistinct []", "show ?case"], ["proof (prove)\nusing this:\n  singleCombinators []\n  distinct []\n  allNetsDistinct []\n\ngoal (1 subgoal):\n 1. wellformed_policy2Pr (removeShadowRules2 [])", "by simp"], ["proof (state)\nthis:\n  wellformed_policy2Pr (removeShadowRules2 [])\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>singleCombinators p; distinct p;\n                 allNetsDistinct p\\<rbrakk>\n                \\<Longrightarrow> wellformed_policy2Pr\n                                   (removeShadowRules2 p);\n        singleCombinators (a # p); distinct (a # p);\n        allNetsDistinct (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy2Pr (removeShadowRules2 (a # p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>singleCombinators p; distinct p;\n                 allNetsDistinct p\\<rbrakk>\n                \\<Longrightarrow> wellformed_policy2Pr\n                                   (removeShadowRules2 p);\n        singleCombinators (a # p); distinct (a # p);\n        allNetsDistinct (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy2Pr (removeShadowRules2 (a # p))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>singleCombinators xs; distinct xs; allNetsDistinct xs\\<rbrakk>\n  \\<Longrightarrow> wellformed_policy2Pr (removeShadowRules2 xs)\n  singleCombinators (x # xs)\n  distinct (x # xs)\n  allNetsDistinct (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>singleCombinators p; distinct p;\n                 allNetsDistinct p\\<rbrakk>\n                \\<Longrightarrow> wellformed_policy2Pr\n                                   (removeShadowRules2 p);\n        singleCombinators (a # p); distinct (a # p);\n        allNetsDistinct (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy2Pr (removeShadowRules2 (a # p))", "have wp_xs: \"wellformed_policy2Pr (removeShadowRules2 xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy2Pr (removeShadowRules2 xs)", "by (metis Cons ANDConc distinct.simps(2) singleCombinatorsConc)"], ["proof (state)\nthis:\n  wellformed_policy2Pr (removeShadowRules2 xs)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>singleCombinators p; distinct p;\n                 allNetsDistinct p\\<rbrakk>\n                \\<Longrightarrow> wellformed_policy2Pr\n                                   (removeShadowRules2 p);\n        singleCombinators (a # p); distinct (a # p);\n        allNetsDistinct (a # p)\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy2Pr (removeShadowRules2 (a # p))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy2Pr (removeShadowRules2 (x # xs))", "proof (cases x)"], ["proof (state)\ngoal (4 subgoals):\n 1. x = DenyAll \\<Longrightarrow>\n    wellformed_policy2Pr (removeShadowRules2 (x # xs))\n 2. \\<And>x21 x22.\n       x = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))\n 3. \\<And>x31 x32 x33.\n       x = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))\n 4. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))", "case DenyAll"], ["proof (state)\nthis:\n  x = DenyAll\n\ngoal (4 subgoals):\n 1. x = DenyAll \\<Longrightarrow>\n    wellformed_policy2Pr (removeShadowRules2 (x # xs))\n 2. \\<And>x21 x22.\n       x = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))\n 3. \\<And>x31 x32 x33.\n       x = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))\n 4. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = DenyAll\n\ngoal (1 subgoal):\n 1. wellformed_policy2Pr (removeShadowRules2 (x # xs))", "using wp_xs"], ["proof (prove)\nusing this:\n  x = DenyAll\n  wellformed_policy2Pr (removeShadowRules2 xs)\n\ngoal (1 subgoal):\n 1. wellformed_policy2Pr (removeShadowRules2 (x # xs))", "by simp"], ["proof (state)\nthis:\n  wellformed_policy2Pr (removeShadowRules2 (x # xs))\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       x = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))\n 2. \\<And>x31 x32 x33.\n       x = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))\n 3. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       x = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))\n 2. \\<And>x31 x32 x33.\n       x = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))\n 3. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))", "case (DenyAllFromTo a b)"], ["proof (state)\nthis:\n  x = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       x = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))\n 2. \\<And>x31 x32 x33.\n       x = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))\n 3. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = DenyAllFromTo a b\n\ngoal (1 subgoal):\n 1. wellformed_policy2Pr (removeShadowRules2 (x # xs))", "using wp_xs Cons"], ["proof (prove)\nusing this:\n  x = DenyAllFromTo a b\n  wellformed_policy2Pr (removeShadowRules2 xs)\n  \\<lbrakk>singleCombinators xs; distinct xs; allNetsDistinct xs\\<rbrakk>\n  \\<Longrightarrow> wellformed_policy2Pr (removeShadowRules2 xs)\n  singleCombinators (x # xs)\n  distinct (x # xs)\n  allNetsDistinct (x # xs)\n\ngoal (1 subgoal):\n 1. wellformed_policy2Pr (removeShadowRules2 (x # xs))", "by (simp,metis DenyAllFromTo aux aux7 tNDComm deny_dom)"], ["proof (state)\nthis:\n  wellformed_policy2Pr (removeShadowRules2 (x # xs))\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       x = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))\n 2. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       x = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))\n 2. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))", "case (AllowPortFromTo a b p)"], ["proof (state)\nthis:\n  x = AllowPortFromTo a b p\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       x = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))\n 2. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = AllowPortFromTo a b p\n\ngoal (1 subgoal):\n 1. wellformed_policy2Pr (removeShadowRules2 (x # xs))", "using  wp_xs"], ["proof (prove)\nusing this:\n  x = AllowPortFromTo a b p\n  wellformed_policy2Pr (removeShadowRules2 xs)\n\ngoal (1 subgoal):\n 1. wellformed_policy2Pr (removeShadowRules2 (x # xs))", "by (simp, metis aux26 AllowPortFromTo Cons(4) aux aux7a tNDComm)"], ["proof (state)\nthis:\n  wellformed_policy2Pr (removeShadowRules2 (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))", "case (Conc a b)"], ["proof (state)\nthis:\n  x = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       x = x41 \\<oplus> x42 \\<Longrightarrow>\n       wellformed_policy2Pr (removeShadowRules2 (x # xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. wellformed_policy2Pr (removeShadowRules2 (x # xs))", "by (metis Conc Cons(2) singleCombinators.simps(2))"], ["proof (state)\nthis:\n  wellformed_policy2Pr (removeShadowRules2 (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wellformed_policy2Pr (removeShadowRules2 (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AD_aux: \n  \"AllowPortFromTo a b po \\<in> set p \\<Longrightarrow> DenyAllFromTo c d \\<in> set p \\<Longrightarrow> \n   allNetsDistinct  p \\<Longrightarrow> singleCombinators p \\<Longrightarrow> a \\<noteq> c \\<or> b \\<noteq> d \\<Longrightarrow>\n   dom (Cp (AllowPortFromTo a b po)) \\<inter> dom (Cp (DenyAllFromTo c d)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>AllowPortFromTo a b po \\<in> set p;\n     DenyAllFromTo c d \\<in> set p; allNetsDistinct p; singleCombinators p;\n     a \\<noteq> c \\<or> b \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> dom (Cp (AllowPortFromTo a b po)) \\<inter>\n                      dom (Cp (DenyAllFromTo c d)) =\n                      {}", "by (rule aux26,rule_tac x =\"AllowPortFromTo a b po\" and y = \"DenyAllFromTo c d\" in tND) auto"], ["", "lemma sorted_WP2[rule_format]: \n  \"sorted p l \\<longrightarrow> all_in_list p l \\<longrightarrow> distinct p \\<longrightarrow> allNetsDistinct p \\<longrightarrow> singleCombinators p \\<longrightarrow> \n   wellformed_policy2Pr p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted p l \\<longrightarrow>\n    all_in_list p l \\<longrightarrow>\n    distinct p \\<longrightarrow>\n    allNetsDistinct p \\<longrightarrow>\n    singleCombinators p \\<longrightarrow> wellformed_policy2Pr p", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. FWNormalisationCore.sorted [] l \\<longrightarrow>\n    all_in_list [] l \\<longrightarrow>\n    distinct [] \\<longrightarrow>\n    allNetsDistinct [] \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow> wellformed_policy2Pr []\n 2. \\<And>a p.\n       FWNormalisationCore.sorted p l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       wellformed_policy2Pr p \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n       all_in_list (a # p) l \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       wellformed_policy2Pr (a # p)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. FWNormalisationCore.sorted [] l \\<longrightarrow>\n    all_in_list [] l \\<longrightarrow>\n    distinct [] \\<longrightarrow>\n    allNetsDistinct [] \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow> wellformed_policy2Pr []\n 2. \\<And>a p.\n       FWNormalisationCore.sorted p l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       wellformed_policy2Pr p \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n       all_in_list (a # p) l \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       wellformed_policy2Pr (a # p)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted [] l \\<longrightarrow>\n    all_in_list [] l \\<longrightarrow>\n    distinct [] \\<longrightarrow>\n    allNetsDistinct [] \\<longrightarrow>\n    singleCombinators [] \\<longrightarrow> wellformed_policy2Pr []", "by simp"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted [] l \\<longrightarrow>\n  all_in_list [] l \\<longrightarrow>\n  distinct [] \\<longrightarrow>\n  allNetsDistinct [] \\<longrightarrow>\n  singleCombinators [] \\<longrightarrow> wellformed_policy2Pr []\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       FWNormalisationCore.sorted p l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       wellformed_policy2Pr p \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n       all_in_list (a # p) l \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       wellformed_policy2Pr (a # p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       FWNormalisationCore.sorted p l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       wellformed_policy2Pr p \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n       all_in_list (a # p) l \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       wellformed_policy2Pr (a # p)", "case (Cons a p)"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted p l \\<longrightarrow>\n  all_in_list p l \\<longrightarrow>\n  distinct p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow>\n  singleCombinators p \\<longrightarrow> wellformed_policy2Pr p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       FWNormalisationCore.sorted p l \\<longrightarrow>\n       all_in_list p l \\<longrightarrow>\n       distinct p \\<longrightarrow>\n       allNetsDistinct p \\<longrightarrow>\n       singleCombinators p \\<longrightarrow>\n       wellformed_policy2Pr p \\<Longrightarrow>\n       FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n       all_in_list (a # p) l \\<longrightarrow>\n       distinct (a # p) \\<longrightarrow>\n       allNetsDistinct (a # p) \\<longrightarrow>\n       singleCombinators (a # p) \\<longrightarrow>\n       wellformed_policy2Pr (a # p)", "thus ?case"], ["proof (prove)\nusing this:\n  FWNormalisationCore.sorted p l \\<longrightarrow>\n  all_in_list p l \\<longrightarrow>\n  distinct p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow>\n  singleCombinators p \\<longrightarrow> wellformed_policy2Pr p\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    all_in_list (a # p) l \\<longrightarrow>\n    distinct (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    singleCombinators (a # p) \\<longrightarrow> wellformed_policy2Pr (a # p)", "proof (cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n             all_in_list p l \\<longrightarrow>\n             distinct p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow>\n             singleCombinators p \\<longrightarrow> wellformed_policy2Pr p;\n     a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n                      all_in_list (a # p) l \\<longrightarrow>\n                      distinct (a # p) \\<longrightarrow>\n                      allNetsDistinct (a # p) \\<longrightarrow>\n                      singleCombinators (a # p) \\<longrightarrow>\n                      wellformed_policy2Pr (a # p)\n 2. \\<And>x21 x22.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)\n 4. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)", "case DenyAll"], ["proof (state)\nthis:\n  a = DenyAll\n\ngoal (4 subgoals):\n 1. \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n             all_in_list p l \\<longrightarrow>\n             distinct p \\<longrightarrow>\n             allNetsDistinct p \\<longrightarrow>\n             singleCombinators p \\<longrightarrow> wellformed_policy2Pr p;\n     a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n                      all_in_list (a # p) l \\<longrightarrow>\n                      distinct (a # p) \\<longrightarrow>\n                      allNetsDistinct (a # p) \\<longrightarrow>\n                      singleCombinators (a # p) \\<longrightarrow>\n                      wellformed_policy2Pr (a # p)\n 2. \\<And>x21 x22.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)\n 4. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = DenyAll\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    all_in_list (a # p) l \\<longrightarrow>\n    distinct (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    singleCombinators (a # p) \\<longrightarrow> wellformed_policy2Pr (a # p)", "using  Cons"], ["proof (prove)\nusing this:\n  a = DenyAll\n  FWNormalisationCore.sorted p l \\<longrightarrow>\n  all_in_list p l \\<longrightarrow>\n  distinct p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow>\n  singleCombinators p \\<longrightarrow> wellformed_policy2Pr p\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    all_in_list (a # p) l \\<longrightarrow>\n    distinct (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    singleCombinators (a # p) \\<longrightarrow> wellformed_policy2Pr (a # p)", "by (auto intro: ANDConc singleCombinatorsConc sortedConcEnd)"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n  all_in_list (a # p) l \\<longrightarrow>\n  distinct (a # p) \\<longrightarrow>\n  allNetsDistinct (a # p) \\<longrightarrow>\n  singleCombinators (a # p) \\<longrightarrow> wellformed_policy2Pr (a # p)\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)\n 3. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)\n 3. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)", "case (DenyAllFromTo c d)"], ["proof (state)\nthis:\n  a = DenyAllFromTo c d\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)\n 3. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = DenyAllFromTo c d\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    all_in_list (a # p) l \\<longrightarrow>\n    distinct (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    singleCombinators (a # p) \\<longrightarrow> wellformed_policy2Pr (a # p)", "using  Cons"], ["proof (prove)\nusing this:\n  a = DenyAllFromTo c d\n  FWNormalisationCore.sorted p l \\<longrightarrow>\n  all_in_list p l \\<longrightarrow>\n  distinct p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow>\n  singleCombinators p \\<longrightarrow> wellformed_policy2Pr p\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    all_in_list (a # p) l \\<longrightarrow>\n    distinct (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    singleCombinators (a # p) \\<longrightarrow> wellformed_policy2Pr (a # p)", "apply (simp, intro impI conjI allI impI deny_dom)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = DenyAllFromTo c d;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        all_in_list p l \\<longrightarrow>\n        distinct p \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow>\n        singleCombinators p \\<longrightarrow> wellformed_policy2Pr p;\n        a = DenyAllFromTo c d;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        all_in_list p l \\<longrightarrow>\n        distinct p \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow>\n        singleCombinators p \\<longrightarrow> wellformed_policy2Pr p;\n        FWNormalisationCore.sorted (DenyAllFromTo c d # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        DenyAllFromTo c d \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (DenyAllFromTo c d # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> twoNetsDistinct c d aa b\n 2. \\<lbrakk>a = DenyAllFromTo c d;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     all_in_list p l \\<longrightarrow>\n     distinct p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow>\n     singleCombinators p \\<longrightarrow> wellformed_policy2Pr p;\n     a = DenyAllFromTo c d;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     all_in_list p l \\<longrightarrow>\n     distinct p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow>\n     singleCombinators p \\<longrightarrow> wellformed_policy2Pr p;\n     FWNormalisationCore.sorted (DenyAllFromTo c d # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     DenyAllFromTo c d \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (DenyAllFromTo c d # p); singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2Pr p", "by (auto intro: aux7 tNDComm ANDConc singleCombinatorsConc sortedConcEnd)"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n  all_in_list (a # p) l \\<longrightarrow>\n  distinct (a # p) \\<longrightarrow>\n  allNetsDistinct (a # p) \\<longrightarrow>\n  singleCombinators (a # p) \\<longrightarrow> wellformed_policy2Pr (a # p)\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)\n 2. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)\n 2. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)", "case (AllowPortFromTo c d e)"], ["proof (state)\nthis:\n  a = AllowPortFromTo c d e\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)\n 2. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = AllowPortFromTo c d e\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    all_in_list (a # p) l \\<longrightarrow>\n    distinct (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    singleCombinators (a # p) \\<longrightarrow> wellformed_policy2Pr (a # p)", "using Cons"], ["proof (prove)\nusing this:\n  a = AllowPortFromTo c d e\n  FWNormalisationCore.sorted p l \\<longrightarrow>\n  all_in_list p l \\<longrightarrow>\n  distinct p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow>\n  singleCombinators p \\<longrightarrow> wellformed_policy2Pr p\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n    all_in_list (a # p) l \\<longrightarrow>\n    distinct (a # p) \\<longrightarrow>\n    allNetsDistinct (a # p) \\<longrightarrow>\n    singleCombinators (a # p) \\<longrightarrow> wellformed_policy2Pr (a # p)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     all_in_list p l \\<longrightarrow>\n     distinct p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow>\n     singleCombinators p \\<longrightarrow> wellformed_policy2Pr p\\<rbrakk>\n    \\<Longrightarrow> FWNormalisationCore.sorted (AllowPortFromTo c d e # p)\n                       l \\<longrightarrow>\n                      {c, d} \\<in> set l \\<and>\n                      all_in_list p l \\<longrightarrow>\n                      AllowPortFromTo c d e \\<notin> set p \\<and>\n                      distinct p \\<longrightarrow>\n                      allNetsDistinct\n                       (AllowPortFromTo c d e # p) \\<longrightarrow>\n                      singleCombinators p \\<longrightarrow>\n                      (\\<forall>a b.\n                          DenyAllFromTo a b \\<in> set p \\<longrightarrow>\n                          dom (Cp (AllowPortFromTo c d e)) \\<inter>\n                          dom (Cp (DenyAllFromTo a b)) =\n                          {}) \\<and>\n                      wellformed_policy2Pr p", "apply (intro impI conjI allI, rename_tac \"aa\" \"b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        all_in_list p l \\<longrightarrow>\n        distinct p \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow>\n        singleCombinators p \\<longrightarrow> wellformed_policy2Pr p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> dom (Cp (AllowPortFromTo c d e)) \\<inter>\n                         dom (Cp (DenyAllFromTo aa b)) =\n                         {}\n 2. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     all_in_list p l \\<longrightarrow>\n     distinct p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow>\n     singleCombinators p \\<longrightarrow> wellformed_policy2Pr p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p);\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2Pr p", "apply (rule aux26)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>a = AllowPortFromTo c d e;\n        FWNormalisationCore.sorted p l \\<longrightarrow>\n        all_in_list p l \\<longrightarrow>\n        distinct p \\<longrightarrow>\n        allNetsDistinct p \\<longrightarrow>\n        singleCombinators p \\<longrightarrow> wellformed_policy2Pr p;\n        FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n        {c, d} \\<in> set l \\<and> all_in_list p l;\n        AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n        allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n        DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n       \\<Longrightarrow> twoNetsDistinct c d aa b\n 2. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     all_in_list p l \\<longrightarrow>\n     distinct p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow>\n     singleCombinators p \\<longrightarrow> wellformed_policy2Pr p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p);\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2Pr p", "subgoal for aa b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     all_in_list p l \\<longrightarrow>\n     distinct p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow>\n     singleCombinators p \\<longrightarrow> wellformed_policy2Pr p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n     DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> twoNetsDistinct c d aa b", "apply (rule_tac x = \"AllowPortFromTo c d e\" and y = \"DenyAllFromTo aa b\" in tND, \n            assumption,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> wellformed_policy2Pr p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n     DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> c = aa \\<longrightarrow> d \\<noteq> b", "apply (subgoal_tac \"smaller (AllowPortFromTo c d e) (DenyAllFromTo aa b) l\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> wellformed_policy2Pr p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n     DenyAllFromTo aa b \\<in> set p;\n     smaller (AllowPortFromTo c d e) (DenyAllFromTo aa b) l\\<rbrakk>\n    \\<Longrightarrow> c = aa \\<longrightarrow> d \\<noteq> b\n 2. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> wellformed_policy2Pr p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n     DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> smaller (AllowPortFromTo c d e) (DenyAllFromTo aa b) l", "apply (simp split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> wellformed_policy2Pr p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n     DenyAllFromTo aa b \\<in> set p; {c, d} \\<noteq> {aa, b};\n     {c, d} \\<in> set l; all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p; distinct p;\n     position {c, d} l \\<le> position {aa, b} l\\<rbrakk>\n    \\<Longrightarrow> c = aa \\<longrightarrow> d \\<noteq> b\n 2. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> wellformed_policy2Pr p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n     DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> smaller (AllowPortFromTo c d e) (DenyAllFromTo aa b) l", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> wellformed_policy2Pr p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n     DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> smaller (AllowPortFromTo c d e) (DenyAllFromTo aa b) l", "apply (erule sorted_is_smaller, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow> wellformed_policy2Pr p;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p); singleCombinators p;\n     DenyAllFromTo aa b \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> {aa, b} \\<in> set l", "apply (metis bothNet.simps(2) in_list.simps(2) in_set_in_list)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = AllowPortFromTo c d e;\n     FWNormalisationCore.sorted p l \\<longrightarrow>\n     all_in_list p l \\<longrightarrow>\n     distinct p \\<longrightarrow>\n     allNetsDistinct p \\<longrightarrow>\n     singleCombinators p \\<longrightarrow> wellformed_policy2Pr p;\n     FWNormalisationCore.sorted (AllowPortFromTo c d e # p) l;\n     {c, d} \\<in> set l \\<and> all_in_list p l;\n     AllowPortFromTo c d e \\<notin> set p \\<and> distinct p;\n     allNetsDistinct (AllowPortFromTo c d e # p);\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2Pr p", "by (auto intro: aux7 tNDComm ANDConc singleCombinatorsConc sortedConcEnd)"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n  all_in_list (a # p) l \\<longrightarrow>\n  distinct (a # p) \\<longrightarrow>\n  allNetsDistinct (a # p) \\<longrightarrow>\n  singleCombinators (a # p) \\<longrightarrow> wellformed_policy2Pr (a # p)\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a # p)\n                          l \\<longrightarrow>\n                         all_in_list (a # p) l \\<longrightarrow>\n                         distinct (a # p) \\<longrightarrow>\n                         allNetsDistinct (a # p) \\<longrightarrow>\n                         singleCombinators (a # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a # p)", "case (Conc a b)"], ["proof (state)\nthis:\n  a__ = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>FWNormalisationCore.sorted p l \\<longrightarrow>\n                all_in_list p l \\<longrightarrow>\n                distinct p \\<longrightarrow>\n                allNetsDistinct p \\<longrightarrow>\n                singleCombinators p \\<longrightarrow>\n                wellformed_policy2Pr p;\n        a__ = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> FWNormalisationCore.sorted (a__ # p)\n                          l \\<longrightarrow>\n                         all_in_list (a__ # p) l \\<longrightarrow>\n                         distinct (a__ # p) \\<longrightarrow>\n                         allNetsDistinct (a__ # p) \\<longrightarrow>\n                         singleCombinators (a__ # p) \\<longrightarrow>\n                         wellformed_policy2Pr (a__ # p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a__ = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a__ # p) l \\<longrightarrow>\n    all_in_list (a__ # p) l \\<longrightarrow>\n    distinct (a__ # p) \\<longrightarrow>\n    allNetsDistinct (a__ # p) \\<longrightarrow>\n    singleCombinators (a__ # p) \\<longrightarrow>\n    wellformed_policy2Pr (a__ # p)", "using Cons"], ["proof (prove)\nusing this:\n  a__ = a \\<oplus> b\n  FWNormalisationCore.sorted p l \\<longrightarrow>\n  all_in_list p l \\<longrightarrow>\n  distinct p \\<longrightarrow>\n  allNetsDistinct p \\<longrightarrow>\n  singleCombinators p \\<longrightarrow> wellformed_policy2Pr p\n\ngoal (1 subgoal):\n 1. FWNormalisationCore.sorted (a__ # p) l \\<longrightarrow>\n    all_in_list (a__ # p) l \\<longrightarrow>\n    distinct (a__ # p) \\<longrightarrow>\n    allNetsDistinct (a__ # p) \\<longrightarrow>\n    singleCombinators (a__ # p) \\<longrightarrow>\n    wellformed_policy2Pr (a__ # p)", "by simp"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted (a__ # p) l \\<longrightarrow>\n  all_in_list (a__ # p) l \\<longrightarrow>\n  distinct (a__ # p) \\<longrightarrow>\n  allNetsDistinct (a__ # p) \\<longrightarrow>\n  singleCombinators (a__ # p) \\<longrightarrow>\n  wellformed_policy2Pr (a__ # p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  FWNormalisationCore.sorted (a # p) l \\<longrightarrow>\n  all_in_list (a # p) l \\<longrightarrow>\n  distinct (a # p) \\<longrightarrow>\n  allNetsDistinct (a # p) \\<longrightarrow>\n  singleCombinators (a # p) \\<longrightarrow> wellformed_policy2Pr (a # p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wellformed2_sorted[simp]: \n  \"all_in_list p l \\<Longrightarrow> distinct p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> singleCombinators p \\<Longrightarrow> \n   wellformed_policy2Pr (sort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_in_list p l; distinct p; allNetsDistinct p;\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2Pr (FWNormalisationCore.sort p l)", "by (metis distinct_sort set_sort sorted_WP2 SC3 aND_sort all_in_listSubset order_refl sort_is_sorted)"], ["", "lemma wellformed2_sortedQ[simp]: \n  \"all_in_list p l \\<Longrightarrow> distinct p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> singleCombinators p \\<Longrightarrow> \n   wellformed_policy2Pr (qsort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_in_list p l; distinct p; allNetsDistinct p;\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy2Pr (qsort p l)", "by (metis sorted_WP2 SC3Q aND_sortQ all_in_listSubset distinct_sortQ set_sortQ sort_is_sortedQ subsetI)"], ["", "lemma C_DenyAll[simp]: \"Cp (list2FWpolicy (xs @ [DenyAll])) x = Some (deny ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (xs @ [DenyAll])) x = \\<lfloor>deny ()\\<rfloor>", "by (auto simp: PLemmas)"], ["", "lemma C_eq_RS1n:\n  \"Cp(list2FWpolicy (removeShadowRules1_alternative p)) = Cp(list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (removeShadowRules1_alternative p)) =\n    Cp (list2FWpolicy p)", "proof (cases \"p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    Cp (list2FWpolicy (removeShadowRules1_alternative p)) =\n    Cp (list2FWpolicy p)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       Cp (list2FWpolicy (removeShadowRules1_alternative p)) =\n       Cp (list2FWpolicy p)", "case Nil"], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    Cp (list2FWpolicy (removeShadowRules1_alternative p)) =\n    Cp (list2FWpolicy p)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       Cp (list2FWpolicy (removeShadowRules1_alternative p)) =\n       Cp (list2FWpolicy p)", "then"], ["proof (chain)\npicking this:\n  p = []", "show ?thesis"], ["proof (prove)\nusing this:\n  p = []\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (removeShadowRules1_alternative p)) =\n    Cp (list2FWpolicy p)", "by (simp, metis list2FWpolicy.simps(1) rSR1_eq removeShadowRules1.simps(2))"], ["proof (state)\nthis:\n  Cp (list2FWpolicy (removeShadowRules1_alternative p)) =\n  Cp (list2FWpolicy p)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       Cp (list2FWpolicy (removeShadowRules1_alternative p)) =\n       Cp (list2FWpolicy p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       Cp (list2FWpolicy (removeShadowRules1_alternative p)) =\n       Cp (list2FWpolicy p)", "case (Cons a list)"], ["proof (state)\nthis:\n  p = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       Cp (list2FWpolicy (removeShadowRules1_alternative p)) =\n       Cp (list2FWpolicy p)", "then"], ["proof (chain)\npicking this:\n  p = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  p = a # list\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (removeShadowRules1_alternative p)) =\n    Cp (list2FWpolicy p)", "apply (hypsubst, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = a # list \\<Longrightarrow>\n    Cp (list2FWpolicy (removeShadowRules1_alternative (a # list))) =\n    Cp (list2FWpolicy (a # list))", "apply (thin_tac \"p = a # list\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (removeShadowRules1_alternative (a # list))) =\n    Cp (list2FWpolicy (a # list))", "proof (induct rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. Cp (list2FWpolicy (removeShadowRules1_alternative [])) =\n    Cp (list2FWpolicy [])\n 2. \\<And>x xs.\n       Cp (list2FWpolicy (removeShadowRules1_alternative xs)) =\n       Cp (list2FWpolicy xs) \\<Longrightarrow>\n       Cp (list2FWpolicy (removeShadowRules1_alternative (xs @ [x]))) =\n       Cp (list2FWpolicy (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Cp (list2FWpolicy (removeShadowRules1_alternative [])) =\n    Cp (list2FWpolicy [])\n 2. \\<And>x xs.\n       Cp (list2FWpolicy (removeShadowRules1_alternative xs)) =\n       Cp (list2FWpolicy xs) \\<Longrightarrow>\n       Cp (list2FWpolicy (removeShadowRules1_alternative (xs @ [x]))) =\n       Cp (list2FWpolicy (xs @ [x]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (removeShadowRules1_alternative [])) =\n    Cp (list2FWpolicy [])", "by (metis rSR1_eq removeShadowRules1.simps(2))"], ["proof (state)\nthis:\n  Cp (list2FWpolicy (removeShadowRules1_alternative [])) =\n  Cp (list2FWpolicy [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       Cp (list2FWpolicy (removeShadowRules1_alternative xs)) =\n       Cp (list2FWpolicy xs) \\<Longrightarrow>\n       Cp (list2FWpolicy (removeShadowRules1_alternative (xs @ [x]))) =\n       Cp (list2FWpolicy (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       Cp (list2FWpolicy (removeShadowRules1_alternative xs)) =\n       Cp (list2FWpolicy xs) \\<Longrightarrow>\n       Cp (list2FWpolicy (removeShadowRules1_alternative (xs @ [x]))) =\n       Cp (list2FWpolicy (xs @ [x]))", "case (snoc x xs)"], ["proof (state)\nthis:\n  Cp (list2FWpolicy (removeShadowRules1_alternative xs)) =\n  Cp (list2FWpolicy xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       Cp (list2FWpolicy (removeShadowRules1_alternative xs)) =\n       Cp (list2FWpolicy xs) \\<Longrightarrow>\n       Cp (list2FWpolicy (removeShadowRules1_alternative (xs @ [x]))) =\n       Cp (list2FWpolicy (xs @ [x]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (removeShadowRules1_alternative (xs @ [x]))) =\n    Cp (list2FWpolicy (xs @ [x]))", "apply (case_tac \"xs = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Cp (list2FWpolicy (removeShadowRules1_alternative [x])) = Cp x\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Cp (list2FWpolicy (removeShadowRules1_alternative (xs @ [x]))) =\n    Cp (list2FWpolicy (xs @ [x]))", "apply (simp add: removeShadowRules1_alternative_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Cp (list2FWpolicy (rev (removeShadowRules1_alternative_rev [x]))) = Cp x\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Cp (list2FWpolicy (removeShadowRules1_alternative (xs @ [x]))) =\n    Cp (list2FWpolicy (xs @ [x]))", "apply (insert snoc.hyps, case_tac x, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> [];\n     Cp (list2FWpolicy (removeShadowRules1_alternative xs)) =\n     Cp (list2FWpolicy xs)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (removeShadowRules1_alternative (xs @ [x]))) =\n                      Cp (list2FWpolicy (xs @ [x]))", "apply (rule ext, rename_tac xa)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xs \\<noteq> [];\n        Cp (list2FWpolicy (removeShadowRules1_alternative xs)) =\n        Cp (list2FWpolicy xs)\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy\n                              (removeShadowRules1_alternative (xs @ [x])))\n                          xa =\n                         Cp (list2FWpolicy (xs @ [x])) xa", "apply (case_tac \"x = DenyAll\",simp_all add: PLemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xs \\<noteq> [];\n        Cp (list2FWpolicy (removeShadowRules1_alternative xs)) =\n        Cp (list2FWpolicy xs);\n        x \\<noteq> DenyAll\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy\n                              (removeShadowRules1_alternative (xs @ [x])))\n                          xa =\n                         Cp (list2FWpolicy (xs @ [x])) xa", "apply (rule_tac t = \"removeShadowRules1_alternative (xs @ [x])\" and\n          s = \"(removeShadowRules1_alternative xs)@[x]\" in subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xs \\<noteq> [];\n        Cp (list2FWpolicy (removeShadowRules1_alternative xs)) =\n        Cp (list2FWpolicy xs);\n        x \\<noteq> DenyAll\\<rbrakk>\n       \\<Longrightarrow> removeShadowRules1_alternative xs @ [x] =\n                         removeShadowRules1_alternative (xs @ [x])\n 2. \\<And>xa.\n       \\<lbrakk>xs \\<noteq> [];\n        Cp (list2FWpolicy (removeShadowRules1_alternative xs)) =\n        Cp (list2FWpolicy xs);\n        x \\<noteq> DenyAll\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy\n                              (removeShadowRules1_alternative xs @ [x]))\n                          xa =\n                         Cp (list2FWpolicy (xs @ [x])) xa", "apply (erule RS1n_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xs \\<noteq> [];\n        Cp (list2FWpolicy (removeShadowRules1_alternative xs)) =\n        Cp (list2FWpolicy xs);\n        x \\<noteq> DenyAll\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy\n                              (removeShadowRules1_alternative xs @ [x]))\n                          xa =\n                         Cp (list2FWpolicy (xs @ [x])) xa", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> [];\n     Cp (list2FWpolicy (removeShadowRules1_alternative xs)) =\n     Cp (list2FWpolicy xs);\n     x \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (removeShadowRules1_alternative xs @ [x]))\n                       a =\n                      Cp (list2FWpolicy (xs @ [x])) a", "apply (case_tac \"a \\<in> dom (Cp x)\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Cp (list2FWpolicy (removeShadowRules1_alternative (xs @ [x]))) =\n  Cp (list2FWpolicy (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Cp (list2FWpolicy (removeShadowRules1_alternative p)) =\n  Cp (list2FWpolicy p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_RS1[simp]: \n  \"p \\<noteq> [] \\<Longrightarrow> Cp(list2FWpolicy (removeShadowRules1 p)) = Cp(list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    Cp (list2FWpolicy (removeShadowRules1 p)) = Cp (list2FWpolicy p)", "by (metis rSR1_eq C_eq_RS1n)"], ["", "lemma EX_MR_aux[rule_format]: \n  \"applied_rule_rev Cp x (DenyAll # p) \\<noteq> Some DenyAll \\<longrightarrow> (\\<exists>y. applied_rule_rev Cp x p = Some y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (DenyAll # p) \\<noteq>\n    \\<lfloor>DenyAll\\<rfloor> \\<longrightarrow>\n    (\\<exists>y. applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>)", "by (simp add: applied_rule_rev_def) (rule_tac xs = p in rev_induct, simp_all)"], ["", "lemma EX_MR : \n  \"applied_rule_rev Cp x p \\<noteq> (Some DenyAll) \\<Longrightarrow> p = DenyAll#ps \\<Longrightarrow> \n   (applied_rule_rev Cp x p = applied_rule_rev Cp x ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev Cp x p \\<noteq> \\<lfloor>DenyAll\\<rfloor>;\n     p = DenyAll # ps\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x ps", "apply (auto,subgoal_tac \"applied_rule_rev Cp x (DenyAll#ps) \\<noteq> None\", auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>y \\<noteq> DenyAll; p = DenyAll # ps;\n        applied_rule_rev Cp x (DenyAll # ps) = \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>y\\<rfloor> = applied_rule_rev Cp x ps\n 2. \\<lbrakk>applied_rule_rev Cp x (DenyAll # ps) \\<noteq>\n             \\<lfloor>DenyAll\\<rfloor>;\n     p = DenyAll # ps\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         applied_rule_rev Cp x (DenyAll # ps) =\n                         \\<lfloor>y\\<rfloor>", "apply (metis mrConcEnd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev Cp x (DenyAll # ps) \\<noteq>\n             \\<lfloor>DenyAll\\<rfloor>;\n     p = DenyAll # ps\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         applied_rule_rev Cp x (DenyAll # ps) =\n                         \\<lfloor>y\\<rfloor>", "by (metis DAimpliesMR_E list.sel(1) hd_in_set list.simps(3) not_Some_eq)"], ["", "lemma mr_not_DA:\n  \"wellformed_policy1_strong s \\<Longrightarrow> applied_rule_rev Cp x p = Some (DenyAllFromTo a ab) \\<Longrightarrow>\n    set p = set s \\<Longrightarrow> applied_rule_rev Cp x s \\<noteq> Some DenyAll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1_strong s;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a ab\\<rfloor>;\n     set p = set s\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x s \\<noteq>\n                      \\<lfloor>DenyAll\\<rfloor>", "apply (subst wp1n_tl, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1_strong s;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a ab\\<rfloor>;\n     set p = set s\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (DenyAll # tl s) \\<noteq>\n                      \\<lfloor>DenyAll\\<rfloor>", "by (metis (mono_tags, lifting) Combinators.distinct(1) foo98          \n      mrSet mr_in_dom WP1n_DA_notinSet set_ConsD wp1n_tl)"], ["", "lemma domsMT_notND_DD: \n  \"dom (Cp (DenyAllFromTo a b)) \\<inter> dom (Cp (DenyAllFromTo c d)) \\<noteq> {} \\<Longrightarrow> \\<not> netsDistinct a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (Cp (DenyAllFromTo a b)) \\<inter>\n    dom (Cp (DenyAllFromTo c d)) \\<noteq>\n    {} \\<Longrightarrow>\n    \\<not> netsDistinct a c", "by (erule contrapos_nn) (simp add: Cp.simps aux6 twoNetsDistinct_def)"], ["", "lemma domsMT_notND_DD2: \n  \"dom (Cp (DenyAllFromTo a b)) \\<inter> dom (Cp (DenyAllFromTo c d)) \\<noteq> {} \\<Longrightarrow> \\<not> netsDistinct b d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (Cp (DenyAllFromTo a b)) \\<inter>\n    dom (Cp (DenyAllFromTo c d)) \\<noteq>\n    {} \\<Longrightarrow>\n    \\<not> netsDistinct b d", "by (erule contrapos_nn) (simp add: Cp.simps aux6 twoNetsDistinct_def)"], ["", "lemma domsMT_notND_DD3: \n  \"x \\<in> dom (Cp (DenyAllFromTo a b)) \\<Longrightarrow> x \\<in> dom (Cp (DenyAllFromTo c d)) \\<Longrightarrow> \\<not> netsDistinct a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (Cp (DenyAllFromTo a b));\n     x \\<in> dom (Cp (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> \\<not> netsDistinct a c", "by (auto intro!: domsMT_notND_DD)"], ["", "lemma domsMT_notND_DD4: \n  \"x \\<in> dom (Cp (DenyAllFromTo a b)) \\<Longrightarrow> x \\<in> dom (Cp (DenyAllFromTo c d)) \\<Longrightarrow> \\<not> netsDistinct b d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (Cp (DenyAllFromTo a b));\n     x \\<in> dom (Cp (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> \\<not> netsDistinct b d", "by (auto intro!: domsMT_notND_DD2)"], ["", "lemma NetsEq_if_sameP_DD: \n  \"allNetsDistinct p \\<Longrightarrow> u\\<in> set p \\<Longrightarrow> v\\<in> set p \\<Longrightarrow> u = (DenyAllFromTo a b) \\<Longrightarrow> \n   v = (DenyAllFromTo c d) \\<Longrightarrow> x \\<in> dom (Cp (u)) \\<Longrightarrow> x \\<in> dom (Cp (v)) \\<Longrightarrow> \n    a = c \\<and> b = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allNetsDistinct p; u \\<in> set p; v \\<in> set p;\n     u = DenyAllFromTo a b; v = DenyAllFromTo c d; x \\<in> dom (Cp u);\n     x \\<in> dom (Cp v)\\<rbrakk>\n    \\<Longrightarrow> a = c \\<and> b = d", "unfolding allNetsDistinct_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b.\n                a \\<noteq> b \\<and>\n                a \\<in> set (net_list p) \\<and>\n                b \\<in> set (net_list p) \\<longrightarrow>\n                netsDistinct a b;\n     u \\<in> set p; v \\<in> set p; u = DenyAllFromTo a b;\n     v = DenyAllFromTo c d; x \\<in> dom (Cp u); x \\<in> dom (Cp v)\\<rbrakk>\n    \\<Longrightarrow> a = c \\<and> b = d", "by (simp)(metis allNetsDistinct_def ND0aux1 ND0aux2 domsMT_notND_DD3 domsMT_notND_DD4 )"], ["", "lemma rule_charn1: \n  assumes aND         : \"allNetsDistinct p\"\n    and     mr_is_allow : \"applied_rule_rev Cp x p = Some (AllowPortFromTo a b po)\"\n    and     SC          : \"singleCombinators p\"\n    and     inp         : \"r \\<in> set p\" \n    and     inDom       : \"x \\<in> dom (Cp r)\"\n  shows   \"(r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll", "proof (cases r)"], ["proof (state)\ngoal (4 subgoals):\n 1. r = DenyAll \\<Longrightarrow>\n    r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll\n 2. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 3. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 4. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "case DenyAll"], ["proof (state)\nthis:\n  r = DenyAll\n\ngoal (4 subgoals):\n 1. r = DenyAll \\<Longrightarrow>\n    r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll\n 2. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 3. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 4. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll", "by (metis DenyAll)"], ["proof (state)\nthis:\n  r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 2. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 3. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 2. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 3. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "case (DenyAllFromTo x y)"], ["proof (state)\nthis:\n  r = DenyAllFromTo x y\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 2. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 3. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll", "by (metis DenyAllFromTo NormalisationIPPProofs.AD_aux NormalisationIPPProofs.mrSet \n        NormalisationIPPProofs.mr_in_dom SC aND domInterMT inDom inp mr_is_allow)"], ["proof (state)\nthis:\n  r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 2. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 2. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "case (AllowPortFromTo x y b)"], ["proof (state)\nthis:\n  r = AllowPortFromTo x y b\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll\n 2. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll", "by (metis (mono_tags, lifting) AllowPortFromTo NormalisationIPPProofs.DistinctNetsAllowAllow \n        NormalisationIPPProofs.mrSet NormalisationIPPProofs.mr_in_dom aND domInterMT inDom \n        inp mr_is_allow)"], ["proof (state)\nthis:\n  r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "case (Conc x y)"], ["proof (state)\nthis:\n  r = x \\<oplus> y\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow>\n       r = AllowPortFromTo a b po \\<or>\n       r = DenyAllFromTo a b \\<or> r = DenyAll", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = x \\<oplus> y\n\ngoal (1 subgoal):\n 1. r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll", "using assms"], ["proof (prove)\nusing this:\n  r = x \\<oplus> y\n  allNetsDistinct p\n  applied_rule_rev Cp x p = \\<lfloor>AllowPortFromTo a b po\\<rfloor>\n  singleCombinators p\n  r \\<in> set p\n  x \\<in> dom (Cp r)\n\ngoal (1 subgoal):\n 1. r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll", "by (metis aux0_0)"], ["proof (state)\nthis:\n  r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma none_MT_rulessubset[rule_format]: \n  \"none_MT_rules Cp a \\<longrightarrow> set b \\<subseteq> set a \\<longrightarrow> none_MT_rules Cp b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. none_MT_rules Cp a \\<longrightarrow>\n    set b \\<subseteq> set a \\<longrightarrow> none_MT_rules Cp b", "by (induct b,simp_all) (metis notMTnMT)"], ["", "lemma nMTSort: \"none_MT_rules Cp p \\<Longrightarrow> none_MT_rules Cp (sort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. none_MT_rules Cp p \\<Longrightarrow>\n    none_MT_rules Cp (FWNormalisationCore.sort p l)", "by (metis set_sort nMTeqSet)"], ["", "lemma nMTSortQ: \"none_MT_rules Cp p \\<Longrightarrow> none_MT_rules Cp (qsort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. none_MT_rules Cp p \\<Longrightarrow> none_MT_rules Cp (qsort p l)", "by (metis set_sortQ nMTeqSet)"], ["", "lemma wp3char[rule_format]: \"none_MT_rules Cp xs \\<and>  Cp (AllowPortFromTo a b po) = Map.empty \\<and> \n                            wellformed_policy3Pr (xs @ [DenyAllFromTo a b]) \\<longrightarrow> \n                             AllowPortFromTo a b po \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. none_MT_rules Cp xs \\<and>\n    Cp (AllowPortFromTo a b po) = \\<emptyset> \\<and>\n    wellformed_policy3Pr (xs @ [DenyAllFromTo a b]) \\<longrightarrow>\n    AllowPortFromTo a b po \\<notin> set xs", "by (induct xs, simp_all) (metis domNMT wp3Conc)"], ["", "lemma wp3charn[rule_format]: \n  assumes domAllow:     \"dom (Cp (AllowPortFromTo a b po)) \\<noteq> {}\" \n    and     wp3:          \"wellformed_policy3Pr (xs @ [DenyAllFromTo a b])\"\n  shows allowNotInList: \"AllowPortFromTo a b po \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AllowPortFromTo a b po \\<notin> set xs", "apply (insert assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom (Cp (AllowPortFromTo a b po)) \\<noteq> {};\n     wellformed_policy3Pr (xs @ [DenyAllFromTo a b])\\<rbrakk>\n    \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>dom (Cp (AllowPortFromTo a b po)) \\<noteq> {};\n     wellformed_policy3Pr ([] @ [DenyAllFromTo a b])\\<rbrakk>\n    \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set []\n 2. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>dom (Cp (AllowPortFromTo a b po)) \\<noteq> {};\n                 wellformed_policy3Pr (xs @ [DenyAllFromTo a b])\\<rbrakk>\n                \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set xs;\n        dom (Cp (AllowPortFromTo a b po)) \\<noteq> {};\n        wellformed_policy3Pr ((aa # xs) @ [DenyAllFromTo a b])\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set (aa # xs)", "case Nil"], ["proof (state)\nthis:\n  dom (Cp (AllowPortFromTo a b po)) \\<noteq> {}\n  wellformed_policy3Pr ([] @ [DenyAllFromTo a b])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>dom (Cp (AllowPortFromTo a b po)) \\<noteq> {};\n     wellformed_policy3Pr ([] @ [DenyAllFromTo a b])\\<rbrakk>\n    \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set []\n 2. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>dom (Cp (AllowPortFromTo a b po)) \\<noteq> {};\n                 wellformed_policy3Pr (xs @ [DenyAllFromTo a b])\\<rbrakk>\n                \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set xs;\n        dom (Cp (AllowPortFromTo a b po)) \\<noteq> {};\n        wellformed_policy3Pr ((aa # xs) @ [DenyAllFromTo a b])\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set (aa # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. AllowPortFromTo a b po \\<notin> set []", "by simp"], ["proof (state)\nthis:\n  AllowPortFromTo a b po \\<notin> set []\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>dom (Cp (AllowPortFromTo a b po)) \\<noteq> {};\n                 wellformed_policy3Pr (xs @ [DenyAllFromTo a b])\\<rbrakk>\n                \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set xs;\n        dom (Cp (AllowPortFromTo a b po)) \\<noteq> {};\n        wellformed_policy3Pr ((aa # xs) @ [DenyAllFromTo a b])\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set (aa # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>dom (Cp (AllowPortFromTo a b po)) \\<noteq> {};\n                 wellformed_policy3Pr (xs @ [DenyAllFromTo a b])\\<rbrakk>\n                \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set xs;\n        dom (Cp (AllowPortFromTo a b po)) \\<noteq> {};\n        wellformed_policy3Pr ((aa # xs) @ [DenyAllFromTo a b])\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set (aa # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>dom (Cp (AllowPortFromTo a b po)) \\<noteq> {};\n   wellformed_policy3Pr (xs @ [DenyAllFromTo a b])\\<rbrakk>\n  \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set xs\n  dom (Cp (AllowPortFromTo a b po)) \\<noteq> {}\n  wellformed_policy3Pr ((x # xs) @ [DenyAllFromTo a b])\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>dom (Cp (AllowPortFromTo a b po)) \\<noteq> {};\n                 wellformed_policy3Pr (xs @ [DenyAllFromTo a b])\\<rbrakk>\n                \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set xs;\n        dom (Cp (AllowPortFromTo a b po)) \\<noteq> {};\n        wellformed_policy3Pr ((aa # xs) @ [DenyAllFromTo a b])\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set (aa # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. AllowPortFromTo a b po \\<notin> set (x # xs)", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>dom (Cp (AllowPortFromTo a b po)) \\<noteq> {};\n   wellformed_policy3Pr (xs @ [DenyAllFromTo a b])\\<rbrakk>\n  \\<Longrightarrow> AllowPortFromTo a b po \\<notin> set xs\n  dom (Cp (AllowPortFromTo a b po)) \\<noteq> {}\n  wellformed_policy3Pr ((x # xs) @ [DenyAllFromTo a b])\n\ngoal (1 subgoal):\n 1. AllowPortFromTo a b po \\<notin> set (x # xs)", "by (simp,auto intro: wp3Conc) (auto simp: DenyAllowDisj domAllow)"], ["proof (state)\nthis:\n  AllowPortFromTo a b po \\<notin> set (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rule_charn2: \n  assumes aND:        \"allNetsDistinct p\"\n    and wp1:            \"wellformed_policy1 p\"\n    and SC:             \"singleCombinators p\"\n    and wp3:            \"wellformed_policy3Pr p\"\n    and allow_in_list:  \"AllowPortFromTo c d po \\<in> set p\"\n    and x_in_dom_allow: \"x \\<in> dom (Cp (AllowPortFromTo c d po))\"\n  shows               \"applied_rule_rev Cp x p = Some (AllowPortFromTo c d po)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "proof  (insert assms, induct p rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>allNetsDistinct []; wellformed_policy1 [];\n     singleCombinators []; wellformed_policy3Pr [];\n     AllowPortFromTo c d po \\<in> set [];\n     x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x [] =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct xs; wellformed_policy1 xs;\n                 singleCombinators xs; wellformed_policy3Pr xs;\n                 AllowPortFromTo c d po \\<in> set xs;\n                 x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x xs =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (xs @ [xa]); wellformed_policy1 (xs @ [xa]);\n        singleCombinators (xs @ [xa]); wellformed_policy3Pr (xs @ [xa]);\n        AllowPortFromTo c d po \\<in> set (xs @ [xa]);\n        x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (xs @ [xa]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "case Nil"], ["proof (state)\nthis:\n  allNetsDistinct []\n  wellformed_policy1 []\n  singleCombinators []\n  wellformed_policy3Pr []\n  AllowPortFromTo c d po \\<in> set []\n  x \\<in> dom (Cp (AllowPortFromTo c d po))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>allNetsDistinct []; wellformed_policy1 [];\n     singleCombinators []; wellformed_policy3Pr [];\n     AllowPortFromTo c d po \\<in> set [];\n     x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x [] =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct xs; wellformed_policy1 xs;\n                 singleCombinators xs; wellformed_policy3Pr xs;\n                 AllowPortFromTo c d po \\<in> set xs;\n                 x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x xs =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (xs @ [xa]); wellformed_policy1 (xs @ [xa]);\n        singleCombinators (xs @ [xa]); wellformed_policy3Pr (xs @ [xa]);\n        AllowPortFromTo c d po \\<in> set (xs @ [xa]);\n        x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (xs @ [xa]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x [] = \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "using Nil"], ["proof (prove)\nusing this:\n  allNetsDistinct []\n  wellformed_policy1 []\n  singleCombinators []\n  wellformed_policy3Pr []\n  AllowPortFromTo c d po \\<in> set []\n  x \\<in> dom (Cp (AllowPortFromTo c d po))\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x [] = \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  applied_rule_rev Cp x [] = \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct xs; wellformed_policy1 xs;\n                 singleCombinators xs; wellformed_policy3Pr xs;\n                 AllowPortFromTo c d po \\<in> set xs;\n                 x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x xs =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (xs @ [xa]); wellformed_policy1 (xs @ [xa]);\n        singleCombinators (xs @ [xa]); wellformed_policy3Pr (xs @ [xa]);\n        AllowPortFromTo c d po \\<in> set (xs @ [xa]);\n        x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (xs @ [xa]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct xs; wellformed_policy1 xs;\n                 singleCombinators xs; wellformed_policy3Pr xs;\n                 AllowPortFromTo c d po \\<in> set xs;\n                 x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x xs =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (xs @ [xa]); wellformed_policy1 (xs @ [xa]);\n        singleCombinators (xs @ [xa]); wellformed_policy3Pr (xs @ [xa]);\n        AllowPortFromTo c d po \\<in> set (xs @ [xa]);\n        x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (xs @ [xa]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "case (snoc y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys; singleCombinators ys;\n   wellformed_policy3Pr ys; AllowPortFromTo c d po \\<in> set ys;\n   x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n  \\<Longrightarrow> applied_rule_rev Cp x ys =\n                    \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n  allNetsDistinct (ys @ [y])\n  wellformed_policy1 (ys @ [y])\n  singleCombinators (ys @ [y])\n  wellformed_policy3Pr (ys @ [y])\n  AllowPortFromTo c d po \\<in> set (ys @ [y])\n  x \\<in> dom (Cp (AllowPortFromTo c d po))\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct xs; wellformed_policy1 xs;\n                 singleCombinators xs; wellformed_policy3Pr xs;\n                 AllowPortFromTo c d po \\<in> set xs;\n                 x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x xs =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (xs @ [xa]); wellformed_policy1 (xs @ [xa]);\n        singleCombinators (xs @ [xa]); wellformed_policy3Pr (xs @ [xa]);\n        AllowPortFromTo c d po \\<in> set (xs @ [xa]);\n        x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (xs @ [xa]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "using snoc"], ["proof (prove)\nusing this:\n  \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys; singleCombinators ys;\n   wellformed_policy3Pr ys; AllowPortFromTo c d po \\<in> set ys;\n   x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n  \\<Longrightarrow> applied_rule_rev Cp x ys =\n                    \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n  allNetsDistinct (ys @ [y])\n  wellformed_policy1 (ys @ [y])\n  singleCombinators (ys @ [y])\n  wellformed_policy3Pr (ys @ [y])\n  AllowPortFromTo c d po \\<in> set (ys @ [y])\n  x \\<in> dom (Cp (AllowPortFromTo c d po))\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys;\n              AllowPortFromTo c d po \\<in> set ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po = y \\<or> AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (case_tac \"y = (AllowPortFromTo c d po)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys;\n              AllowPortFromTo c d po \\<in> set ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po = y \\<or> AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y = AllowPortFromTo c d po\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys;\n              AllowPortFromTo c d po \\<in> set ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po = y \\<or> AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y \\<noteq> AllowPortFromTo c d po\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (simp add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys;\n              AllowPortFromTo c d po \\<in> set ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po = y \\<or> AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y \\<noteq> AllowPortFromTo c d po\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y \\<noteq> AllowPortFromTo c d po\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (subgoal_tac \"ys \\<noteq> []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y \\<noteq> AllowPortFromTo c d po\\<rbrakk>\n    \\<Longrightarrow> ys \\<noteq> []", "apply (subgoal_tac \"applied_rule_rev Cp x ys = Some (AllowPortFromTo c d po)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n     applied_rule_rev Cp x ys =\n     \\<lfloor>AllowPortFromTo c d po\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x ys =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 3. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y \\<noteq> AllowPortFromTo c d po\\<rbrakk>\n    \\<Longrightarrow> ys \\<noteq> []", "defer 1"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x ys =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y \\<noteq> AllowPortFromTo c d po\\<rbrakk>\n    \\<Longrightarrow> ys \\<noteq> []\n 3. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n     applied_rule_rev Cp x ys =\n     \\<lfloor>AllowPortFromTo c d po\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (metis ANDConcEnd SCConcEnd WP1ConcEnd foo25)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y \\<noteq> AllowPortFromTo c d po\\<rbrakk>\n    \\<Longrightarrow> ys \\<noteq> []\n 2. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n     applied_rule_rev Cp x ys =\n     \\<lfloor>AllowPortFromTo c d po\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (metis inSet_not_MT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n     applied_rule_rev Cp x ys =\n     \\<lfloor>AllowPortFromTo c d po\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "proof (cases y)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n     applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 4. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "case DenyAll"], ["proof (state)\nthis:\n  y = DenyAll\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n              singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n             \\<Longrightarrow> applied_rule_rev Cp x ys =\n                               \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n     singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n     applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 4. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = DenyAll\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "using DenyAll snoc"], ["proof (prove)\nusing this:\n  y = DenyAll\n  y = DenyAll\n  \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys; singleCombinators ys;\n   wellformed_policy3Pr ys; AllowPortFromTo c d po \\<in> set ys;\n   x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n  \\<Longrightarrow> applied_rule_rev Cp x ys =\n                    \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n  allNetsDistinct (ys @ [y])\n  wellformed_policy1 (ys @ [y])\n  singleCombinators (ys @ [y])\n  wellformed_policy3Pr (ys @ [y])\n  AllowPortFromTo c d po \\<in> set (ys @ [y])\n  x \\<in> dom (Cp (AllowPortFromTo c d po))\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAll;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev Cp x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [DenyAll]); wellformed_policy1 (ys @ [DenyAll]);\n     singleCombinators (ys @ [DenyAll]);\n     wellformed_policy3Pr (ys @ [DenyAll]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (ys @ [DenyAll]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "by (metis DAnotTL DenyAll inSet_not_MT policy2list.simps(2))"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (ys @ [y]) =\n  \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 3. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 3. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "case (DenyAllFromTo a b)"], ["proof (state)\nthis:\n  y = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 3. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "using snoc"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n  \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys; singleCombinators ys;\n   wellformed_policy3Pr ys; AllowPortFromTo c d po \\<in> set ys;\n   x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n  \\<Longrightarrow> applied_rule_rev Cp x ys =\n                    \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n  allNetsDistinct (ys @ [y])\n  wellformed_policy1 (ys @ [y])\n  singleCombinators (ys @ [y])\n  wellformed_policy3Pr (ys @ [y])\n  AllowPortFromTo c d po \\<in> set (ys @ [y])\n  x \\<in> dom (Cp (AllowPortFromTo c d po))\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev Cp x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [DenyAllFromTo a b]);\n     wellformed_policy1 (ys @ [DenyAllFromTo a b]);\n     singleCombinators (ys @ [DenyAllFromTo a b]);\n     wellformed_policy3Pr (ys @ [DenyAllFromTo a b]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (ys @ [DenyAllFromTo a b]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (simp_all add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule Cp x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [DenyAllFromTo a b]);\n     wellformed_policy1 (ys @ [DenyAllFromTo a b]);\n     singleCombinators (ys @ [DenyAllFromTo a b]);\n     wellformed_policy3Pr (ys @ [DenyAllFromTo a b]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp (DenyAllFromTo a b)) \\<and>\n                      (x \\<notin> dom (Cp\n  (DenyAllFromTo a b)) \\<longrightarrow>\n                       applied_rule Cp x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule Cp x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [DenyAllFromTo a b]);\n     wellformed_policy1 (ys @ [DenyAllFromTo a b]);\n     singleCombinators (ys @ [DenyAllFromTo a b]);\n     wellformed_policy3Pr (ys @ [DenyAllFromTo a b]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp (DenyAllFromTo a b))\n 2. \\<lbrakk>y = DenyAllFromTo a b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule Cp x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [DenyAllFromTo a b]);\n     wellformed_policy1 (ys @ [DenyAllFromTo a b]);\n     singleCombinators (ys @ [DenyAllFromTo a b]);\n     wellformed_policy3Pr (ys @ [DenyAllFromTo a b]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp\n (DenyAllFromTo a b)) \\<longrightarrow>\n                      applied_rule Cp x (rev ys) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (metis domInterMT  wp3EndMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule Cp x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [DenyAllFromTo a b]);\n     wellformed_policy1 (ys @ [DenyAllFromTo a b]);\n     singleCombinators (ys @ [DenyAllFromTo a b]);\n     wellformed_policy3Pr (ys @ [DenyAllFromTo a b]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp\n (DenyAllFromTo a b)) \\<longrightarrow>\n                      applied_rule Cp x (rev ys) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule Cp x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [DenyAllFromTo a b]);\n     wellformed_policy1 (ys @ [DenyAllFromTo a b]);\n     singleCombinators (ys @ [DenyAllFromTo a b]);\n     wellformed_policy3Pr (ys @ [DenyAllFromTo a b]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po));\n     x \\<notin> dom (Cp (DenyAllFromTo a b))\\<rbrakk>\n    \\<Longrightarrow> applied_rule Cp x (rev ys) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "by (metis ANDConcEnd DenyAllFromTo SCConcEnd WP1ConcEnd foo25)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (ys @ [y]) =\n  \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "case (AllowPortFromTo a1 a2 b)"], ["proof (state)\nthis:\n  y = AllowPortFromTo a1 a2 b\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n 2. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a1 a2 b\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "using AllowPortFromTo snoc"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a1 a2 b\n  y = AllowPortFromTo a1 a2 b\n  \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys; singleCombinators ys;\n   wellformed_policy3Pr ys; AllowPortFromTo c d po \\<in> set ys;\n   x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n  \\<Longrightarrow> applied_rule_rev Cp x ys =\n                    \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n  allNetsDistinct (ys @ [y])\n  wellformed_policy1 (ys @ [y])\n  singleCombinators (ys @ [y])\n  wellformed_policy3Pr (ys @ [y])\n  AllowPortFromTo c d po \\<in> set (ys @ [y])\n  x \\<in> dom (Cp (AllowPortFromTo c d po))\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a1 a2 b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3Pr ys;\n      AllowPortFromTo c d po \\<in> set ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev Cp x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy1 (ys @ [AllowPortFromTo a1 a2 b]);\n     singleCombinators (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy3Pr (ys @ [AllowPortFromTo a1 a2 b]);\n     c = a1 \\<and> d = a2 \\<and> po = b \\<or>\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x\n                       (ys @ [AllowPortFromTo a1 a2 b]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (simp_all add: applied_rule_rev_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a1 a2 b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3Pr ys;\n      AllowPortFromTo c d po \\<in> set ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule Cp x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy1 (ys @ [AllowPortFromTo a1 a2 b]);\n     singleCombinators (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy3Pr (ys @ [AllowPortFromTo a1 a2 b]);\n     c = a1 \\<and> d = a2 \\<and> po = b \\<or>\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> dom (Cp (AllowPortFromTo a1 a2\n   b)) \\<longrightarrow>\n                       a1 = c \\<and> a2 = d \\<and> b = po) \\<and>\n                      (x \\<notin> dom (Cp\n  (AllowPortFromTo a1 a2 b)) \\<longrightarrow>\n                       applied_rule Cp x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a1 a2 b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3Pr ys;\n      AllowPortFromTo c d po \\<in> set ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule Cp x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy1 (ys @ [AllowPortFromTo a1 a2 b]);\n     singleCombinators (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy3Pr (ys @ [AllowPortFromTo a1 a2 b]);\n     c = a1 \\<and> d = a2 \\<and> po = b \\<or>\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (AllowPortFromTo a1 a2\n  b)) \\<longrightarrow>\n                      a1 = c \\<and> a2 = d \\<and> b = po\n 2. \\<lbrakk>y = AllowPortFromTo a1 a2 b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3Pr ys;\n      AllowPortFromTo c d po \\<in> set ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule Cp x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy1 (ys @ [AllowPortFromTo a1 a2 b]);\n     singleCombinators (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy3Pr (ys @ [AllowPortFromTo a1 a2 b]);\n     c = a1 \\<and> d = a2 \\<and> po = b \\<or>\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp\n (AllowPortFromTo a1 a2 b)) \\<longrightarrow>\n                      applied_rule Cp x (rev ys) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply (metis domInterMT  wp3EndMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a1 a2 b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3Pr ys;\n      AllowPortFromTo c d po \\<in> set ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule Cp x (rev ys) =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy1 (ys @ [AllowPortFromTo a1 a2 b]);\n     singleCombinators (ys @ [AllowPortFromTo a1 a2 b]);\n     wellformed_policy3Pr (ys @ [AllowPortFromTo a1 a2 b]);\n     c = a1 \\<and> d = a2 \\<and> po = b \\<or>\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp\n (AllowPortFromTo a1 a2 b)) \\<longrightarrow>\n                      applied_rule Cp x (rev ys) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "by (metis ANDConcEnd AllowPortFromTo SCConcEnd WP1ConcEnd foo25 x_in_dom_allow)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (ys @ [y]) =\n  \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "case (Conc a b)"], ["proof (state)\nthis:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n                 singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n                \\<Longrightarrow> applied_rule_rev Cp x ys =\n                                  \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        allNetsDistinct (ys @ [y]); wellformed_policy1 (ys @ [y]);\n        singleCombinators (ys @ [y]); wellformed_policy3Pr (ys @ [y]);\n        AllowPortFromTo c d po \\<in> set ys;\n        x \\<in> dom (Cp (AllowPortFromTo c d po));\n        y \\<noteq> AllowPortFromTo c d po; ys \\<noteq> [];\n        applied_rule_rev Cp x ys = \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x (ys @ [y]) =\n                         \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "using Conc snoc"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n  y = a \\<oplus> b\n  \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys; singleCombinators ys;\n   wellformed_policy3Pr ys; AllowPortFromTo c d po \\<in> set ys;\n   x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n  \\<Longrightarrow> applied_rule_rev Cp x ys =\n                    \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n  allNetsDistinct (ys @ [y])\n  wellformed_policy1 (ys @ [y])\n  singleCombinators (ys @ [y])\n  wellformed_policy3Pr (ys @ [y])\n  AllowPortFromTo c d po \\<in> set (ys @ [y])\n  x \\<in> dom (Cp (AllowPortFromTo c d po))\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (ys @ [y]) =\n    \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<lbrakk>allNetsDistinct ys; wellformed_policy1 ys;\n      singleCombinators ys; wellformed_policy3Pr ys\\<rbrakk>\n     \\<Longrightarrow> applied_rule_rev Cp x ys =\n                       \\<lfloor>AllowPortFromTo c d po\\<rfloor>;\n     allNetsDistinct (ys @ [a \\<oplus> b]);\n     wellformed_policy1 (ys @ [a \\<oplus> b]);\n     singleCombinators (ys @ [a \\<oplus> b]);\n     wellformed_policy3Pr (ys @ [a \\<oplus> b]);\n     AllowPortFromTo c d po \\<in> set ys;\n     x \\<in> dom (Cp (AllowPortFromTo c d po))\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (ys @ [a \\<oplus> b]) =\n                      \\<lfloor>AllowPortFromTo c d po\\<rfloor>", "by (metis Conc aux0_0 in_set_conv_decomp)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (ys @ [y]) =\n  \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (ys @ [y]) =\n  \\<lfloor>AllowPortFromTo c d po\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rule_charn3: \n \"wellformed_policy1 p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> singleCombinators p \\<Longrightarrow> \n  wellformed_policy3Pr p \\<Longrightarrow> applied_rule_rev Cp x p = Some (DenyAllFromTo c d) \\<Longrightarrow> \n  AllowPortFromTo a b po \\<in> set p \\<Longrightarrow> x \\<notin> dom (Cp (AllowPortFromTo a b po))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1 p; allNetsDistinct p; singleCombinators p;\n     wellformed_policy3Pr p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo c d\\<rfloor>;\n     AllowPortFromTo a b po \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp (AllowPortFromTo a b po))", "by (clarify) (simp add: NormalisationIPPProofs.rule_charn2 domI)"], ["", "lemma rule_charn4: \n  assumes wp1:    \"wellformed_policy1 p\" \n    and     aND:    \"allNetsDistinct p\" \n    and     SC:     \"singleCombinators p\"\n    and     wp3:    \"wellformed_policy3Pr p\"  \n    and     DA:     \"DenyAll \\<notin> set p\" \n    and     mr:     \"applied_rule_rev Cp x p = Some (DenyAllFromTo a b)\"\n    and     rinp:   \"r \\<in> set p\"\n    and     xindom: \"x \\<in> dom (Cp r)\"\n  shows  \"r = DenyAllFromTo a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "proof (cases r)"], ["proof (state)\ngoal (4 subgoals):\n 1. r = DenyAll \\<Longrightarrow> r = DenyAllFromTo a b\n 2. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow> r = DenyAllFromTo a b\n 3. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = DenyAllFromTo a b\n 4. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "case DenyAll"], ["proof (state)\nthis:\n  r = DenyAll\n\ngoal (4 subgoals):\n 1. r = DenyAll \\<Longrightarrow> r = DenyAllFromTo a b\n 2. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow> r = DenyAllFromTo a b\n 3. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = DenyAllFromTo a b\n 4. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = DenyAll\n\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "using DenyAll assms"], ["proof (prove)\nusing this:\n  r = DenyAll\n  r = DenyAll\n  wellformed_policy1 p\n  allNetsDistinct p\n  singleCombinators p\n  wellformed_policy3Pr p\n  DenyAll \\<notin> set p\n  applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n  r \\<in> set p\n  x \\<in> dom (Cp r)\n\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "by simp"], ["proof (state)\nthis:\n  r = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow> r = DenyAllFromTo a b\n 2. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = DenyAllFromTo a b\n 3. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow> r = DenyAllFromTo a b\n 2. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = DenyAllFromTo a b\n 3. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "case (DenyAllFromTo c d)"], ["proof (state)\nthis:\n  r = DenyAllFromTo c d\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       r = DenyAllFromTo x21 x22 \\<Longrightarrow> r = DenyAllFromTo a b\n 2. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = DenyAllFromTo a b\n 3. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = DenyAllFromTo c d\n\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "using assms"], ["proof (prove)\nusing this:\n  r = DenyAllFromTo c d\n  wellformed_policy1 p\n  allNetsDistinct p\n  singleCombinators p\n  wellformed_policy3Pr p\n  DenyAll \\<notin> set p\n  applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n  r \\<in> set p\n  x \\<in> dom (Cp r)\n\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = DenyAllFromTo c d; wellformed_policy1 p; allNetsDistinct p;\n     singleCombinators p; wellformed_policy3Pr p; DenyAll \\<notin> set p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     DenyAllFromTo c d \\<in> set p;\n     x \\<in> dom (Cp (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> c = a \\<and> d = b", "apply (erule_tac x = x and p = p and v = \"(DenyAllFromTo a b)\" and\n        u = \"(DenyAllFromTo c d)\"  in NetsEq_if_sameP_DD, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = DenyAllFromTo c d; wellformed_policy1 p;\n     singleCombinators p; wellformed_policy3Pr p; DenyAll \\<notin> set p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     DenyAllFromTo c d \\<in> set p;\n     x \\<in> dom (Cp (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> DenyAllFromTo a b \\<in> set p\n 2. \\<lbrakk>r = DenyAllFromTo c d; wellformed_policy1 p;\n     singleCombinators p; wellformed_policy3Pr p; DenyAll \\<notin> set p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     DenyAllFromTo c d \\<in> set p;\n     x \\<in> dom (Cp (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (DenyAllFromTo a b))", "apply (erule mrSet)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = DenyAllFromTo c d; wellformed_policy1 p;\n     singleCombinators p; wellformed_policy3Pr p; DenyAll \\<notin> set p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     DenyAllFromTo c d \\<in> set p;\n     x \\<in> dom (Cp (DenyAllFromTo c d))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (DenyAllFromTo a b))", "by (erule mr_in_dom)"], ["proof (state)\nthis:\n  r = DenyAllFromTo a b\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = DenyAllFromTo a b\n 2. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = DenyAllFromTo a b\n 2. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "case (AllowPortFromTo c d e)"], ["proof (state)\nthis:\n  r = AllowPortFromTo c d e\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       r = AllowPortFromTo x31 x32 x33 \\<Longrightarrow>\n       r = DenyAllFromTo a b\n 2. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = AllowPortFromTo c d e\n\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "using assms"], ["proof (prove)\nusing this:\n  r = AllowPortFromTo c d e\n  wellformed_policy1 p\n  allNetsDistinct p\n  singleCombinators p\n  wellformed_policy3Pr p\n  DenyAll \\<notin> set p\n  applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n  r \\<in> set p\n  x \\<in> dom (Cp r)\n\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = AllowPortFromTo c d e; wellformed_policy1 p;\n     allNetsDistinct p; singleCombinators p; wellformed_policy3Pr p;\n     DenyAll \\<notin> set p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     AllowPortFromTo c d e \\<in> set p;\n     x \\<in> dom (Cp (AllowPortFromTo c d e))\\<rbrakk>\n    \\<Longrightarrow> False", "apply (subgoal_tac \"x \\<notin> dom (Cp  (AllowPortFromTo c d e))\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = AllowPortFromTo c d e; wellformed_policy1 p;\n     allNetsDistinct p; singleCombinators p; wellformed_policy3Pr p;\n     DenyAll \\<notin> set p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     AllowPortFromTo c d e \\<in> set p;\n     x \\<in> dom (Cp (AllowPortFromTo c d e))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp (AllowPortFromTo c d e))", "by (rule_tac p = p in rule_charn3, auto intro: SCnotConc)"], ["proof (state)\nthis:\n  r = DenyAllFromTo a b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "case (Conc a b)"], ["proof (state)\nthis:\n  r = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       r = x41 \\<oplus> x42 \\<Longrightarrow> r = DenyAllFromTo a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "using assms"], ["proof (prove)\nusing this:\n  r = a \\<oplus> b\n  wellformed_policy1 p\n  allNetsDistinct p\n  singleCombinators p\n  wellformed_policy3Pr p\n  DenyAll \\<notin> set p\n  applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n  r \\<in> set p\n  x \\<in> dom (Cp r)\n\ngoal (1 subgoal):\n 1. r = DenyAllFromTo a b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = a \\<oplus> b; wellformed_policy1 p; allNetsDistinct p;\n     singleCombinators p; wellformed_policy3Pr p; DenyAll \\<notin> set p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     a \\<oplus> b \\<in> set p; x \\<in> dom (Cp (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis Conc aux0_0)"], ["proof (state)\nthis:\n  r = DenyAllFromTo a b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foo31a: \n   \"(\\<forall> r. r \\<in> set p \\<and> x \\<in> dom (Cp r) \\<longrightarrow>\n           (r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll)) \\<Longrightarrow>\n    set p = set s \\<Longrightarrow>  r \\<in> set s  \\<Longrightarrow> x \\<in> dom (Cp r) \\<Longrightarrow>\n           (r = AllowPortFromTo a b po \\<or> r = DenyAllFromTo a b \\<or> r = DenyAll)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>r.\n                r \\<in> set p \\<and> x \\<in> dom (Cp r) \\<longrightarrow>\n                r = AllowPortFromTo a b po \\<or>\n                r = DenyAllFromTo a b \\<or> r = DenyAll;\n     set p = set s; r \\<in> set s; x \\<in> dom (Cp r)\\<rbrakk>\n    \\<Longrightarrow> r = AllowPortFromTo a b po \\<or>\n                      r = DenyAllFromTo a b \\<or> r = DenyAll", "by auto"], ["", "lemma aux4[rule_format]: \n  \"applied_rule_rev Cp x (a#p) = Some a \\<longrightarrow> a \\<notin> set (p) \\<longrightarrow> applied_rule_rev Cp x p = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (a # p) = \\<lfloor>a\\<rfloor> \\<longrightarrow>\n    a \\<notin> set p \\<longrightarrow> applied_rule_rev Cp x p = \\<bottom>", "by (rule rev_induct, simp_all) (intro impI,simp add: applied_rule_rev_def split: if_splits)"], ["", "lemma mrDA_tl: \n  assumes mr_DA: \"applied_rule_rev Cp x p = Some DenyAll\"\n    and     wp1n:  \"wellformed_policy1_strong p\"\n  shows          \"applied_rule_rev Cp x (tl p) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (tl p) = \\<bottom>", "apply (rule aux4 [where a = DenyAll])"], ["proof (prove)\ngoal (2 subgoals):\n 1. applied_rule_rev Cp x (DenyAll # tl p) = \\<lfloor>DenyAll\\<rfloor>\n 2. DenyAll \\<notin> set (tl p)", "apply (metis wp1n_tl mr_DA wp1n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<notin> set (tl p)", "by (metis WP1n_DA_notinSet wp1n)"], ["", "lemma rule_charnDAFT: \n  \"wellformed_policy1_strong p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> singleCombinators p \\<Longrightarrow> \n   wellformed_policy3Pr p \\<Longrightarrow> applied_rule_rev Cp x p = Some (DenyAllFromTo a b) \\<Longrightarrow>\n   r \\<in> set (tl p) \\<Longrightarrow> x \\<in> dom (Cp r) \\<Longrightarrow> \n   r = DenyAllFromTo a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1_strong p; allNetsDistinct p;\n     singleCombinators p; wellformed_policy3Pr p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     r \\<in> set (tl p); x \\<in> dom (Cp r)\\<rbrakk>\n    \\<Longrightarrow> r = DenyAllFromTo a b", "apply (subgoal_tac \"p = DenyAll#(tl p)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wellformed_policy1_strong p; allNetsDistinct p;\n     singleCombinators p; wellformed_policy3Pr p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     r \\<in> set (tl p); x \\<in> dom (Cp r); p = DenyAll # tl p\\<rbrakk>\n    \\<Longrightarrow> r = DenyAllFromTo a b\n 2. \\<lbrakk>wellformed_policy1_strong p; allNetsDistinct p;\n     singleCombinators p; wellformed_policy3Pr p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     r \\<in> set (tl p); x \\<in> dom (Cp r)\\<rbrakk>\n    \\<Longrightarrow> p = DenyAll # tl p", "apply (metis (no_types, lifting) ANDConc Combinators.distinct(1) NormalisationIPPProofs.mrConcEnd \n      NormalisationIPPProofs.rule_charn4 NormalisationIPPProofs.wp3Conc WP1n_DA_notinSet \n      singleCombinatorsConc waux2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1_strong p; allNetsDistinct p;\n     singleCombinators p; wellformed_policy3Pr p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     r \\<in> set (tl p); x \\<in> dom (Cp r)\\<rbrakk>\n    \\<Longrightarrow> p = DenyAll # tl p", "using wp1n_tl"], ["proof (prove)\nusing this:\n  wellformed_policy1_strong ?p \\<Longrightarrow> ?p = DenyAll # tl ?p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1_strong p; allNetsDistinct p;\n     singleCombinators p; wellformed_policy3Pr p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>;\n     r \\<in> set (tl p); x \\<in> dom (Cp r)\\<rbrakk>\n    \\<Longrightarrow> p = DenyAll # tl p", "by auto"], ["", "lemma mrDenyAll_is_unique: \n  \"wellformed_policy1_strong p \\<Longrightarrow> applied_rule_rev Cp x p = Some DenyAll \\<Longrightarrow> r \\<in> set (tl p) \\<Longrightarrow> \n  x \\<notin> dom (Cp r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1_strong p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAll\\<rfloor>;\n     r \\<in> set (tl p)\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp r)", "apply (rule_tac a = \"[]\" and b = \"DenyAll\" and c = \"tl p\"  in foo3a, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wellformed_policy1_strong p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAll\\<rfloor>;\n     r \\<in> set (tl p)\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (DenyAll # tl p) =\n                      \\<lfloor>DenyAll\\<rfloor>\n 2. \\<lbrakk>wellformed_policy1_strong p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAll\\<rfloor>;\n     r \\<in> set (tl p)\\<rbrakk>\n    \\<Longrightarrow> DenyAll \\<notin> set (tl p)", "apply (metis wp1n_tl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed_policy1_strong p;\n     applied_rule_rev Cp x p = \\<lfloor>DenyAll\\<rfloor>;\n     r \\<in> set (tl p)\\<rbrakk>\n    \\<Longrightarrow> DenyAll \\<notin> set (tl p)", "by (metis WP1n_DA_notinSet)"], ["", "theorem  C_eq_Sets_mr: \n  assumes sets_eq: \"set p = set s\"\n    and     SC:      \"singleCombinators p\"\n    and     wp1_p:   \"wellformed_policy1_strong p\"\n    and     wp1_s:   \"wellformed_policy1_strong s\"\n    and     wp3_p:   \"wellformed_policy3Pr p\"       \n    and     wp3_s:   \"wellformed_policy3Pr s\"  \n    and     aND:     \"allNetsDistinct p\"          \n  shows            \"applied_rule_rev Cp x p = applied_rule_rev Cp x s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = applied_rule_rev Cp x s", "proof (cases \"applied_rule_rev Cp x p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. applied_rule_rev Cp x p = \\<bottom> \\<Longrightarrow>\n    applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>a.\n       applied_rule_rev Cp x p = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       applied_rule_rev Cp x p = applied_rule_rev Cp x s", "case None"], ["proof (state)\nthis:\n  applied_rule_rev Cp x p = \\<bottom>\n\ngoal (2 subgoals):\n 1. applied_rule_rev Cp x p = \\<bottom> \\<Longrightarrow>\n    applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>a.\n       applied_rule_rev Cp x p = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       applied_rule_rev Cp x p = applied_rule_rev Cp x s", "have DA: \"DenyAll \\<in> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set p", "using wp1_p"], ["proof (prove)\nusing this:\n  wellformed_policy1_strong p\n\ngoal (1 subgoal):\n 1. DenyAll \\<in> set p", "by (auto simp: wp1_aux1aa)"], ["proof (state)\nthis:\n  DenyAll \\<in> set p\n\ngoal (2 subgoals):\n 1. applied_rule_rev Cp x p = \\<bottom> \\<Longrightarrow>\n    applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>a.\n       applied_rule_rev Cp x p = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       applied_rule_rev Cp x p = applied_rule_rev Cp x s", "have notDA: \"DenyAll \\<notin> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<notin> set p", "using None"], ["proof (prove)\nusing this:\n  applied_rule_rev Cp x p = \\<bottom>\n\ngoal (1 subgoal):\n 1. DenyAll \\<notin> set p", "by (auto simp: DAimplieMR)"], ["proof (state)\nthis:\n  DenyAll \\<notin> set p\n\ngoal (2 subgoals):\n 1. applied_rule_rev Cp x p = \\<bottom> \\<Longrightarrow>\n    applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>a.\n       applied_rule_rev Cp x p = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       applied_rule_rev Cp x p = applied_rule_rev Cp x s", "thus ?thesis"], ["proof (prove)\nusing this:\n  DenyAll \\<notin> set p\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = applied_rule_rev Cp x s", "using DA"], ["proof (prove)\nusing this:\n  DenyAll \\<notin> set p\n  DenyAll \\<in> set p\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = applied_rule_rev Cp x s", "by (contradiction)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x p = applied_rule_rev Cp x s\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       applied_rule_rev Cp x p = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       applied_rule_rev Cp x p = applied_rule_rev Cp x s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       applied_rule_rev Cp x p = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       applied_rule_rev Cp x p = applied_rule_rev Cp x s", "case (Some y)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       applied_rule_rev Cp x p = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       applied_rule_rev Cp x p = applied_rule_rev Cp x s", "thus ?thesis"], ["proof (prove)\nusing this:\n  applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = applied_rule_rev Cp x s", "proof (cases y)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "have tl_p: \"p = DenyAll#(tl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = DenyAll # tl p", "by (metis wp1_p wp1n_tl)"], ["proof (state)\nthis:\n  p = DenyAll # tl p\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "have tl_s: \"s = DenyAll#(tl s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = DenyAll # tl s", "by (metis wp1_s wp1n_tl)"], ["proof (state)\nthis:\n  s = DenyAll # tl s\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "have tl_eq: \"set (tl p) = set (tl s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (tl p) = set (tl s)", "by (metis list.sel(3) WP1n_DA_notinSet sets_eq foo2\n          wellformed_policy1_charn wp1_aux1aa wp1_eq wp1_p wp1_s)"], ["proof (state)\nthis:\n  set (tl p) = set (tl s)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "{"], ["proof (state)\nthis:\n  set (tl p) = set (tl s)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "case DenyAll"], ["proof (state)\nthis:\n  y = DenyAll\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "have mr_p_is_DenyAll: \"applied_rule_rev Cp x p = Some DenyAll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = \\<lfloor>DenyAll\\<rfloor>", "by (simp add: DenyAll Some)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x p = \\<lfloor>DenyAll\\<rfloor>\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "hence x_notin_tl_p: \"\\<forall> r. r \\<in> set (tl p) \\<longrightarrow>  x \\<notin> dom (Cp r)\""], ["proof (prove)\nusing this:\n  applied_rule_rev Cp x p = \\<lfloor>DenyAll\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>r. r \\<in> set (tl p) \\<longrightarrow> x \\<notin> dom (Cp r)", "using wp1_p"], ["proof (prove)\nusing this:\n  applied_rule_rev Cp x p = \\<lfloor>DenyAll\\<rfloor>\n  wellformed_policy1_strong p\n\ngoal (1 subgoal):\n 1. \\<forall>r. r \\<in> set (tl p) \\<longrightarrow> x \\<notin> dom (Cp r)", "by (auto simp: mrDenyAll_is_unique)"], ["proof (state)\nthis:\n  \\<forall>r. r \\<in> set (tl p) \\<longrightarrow> x \\<notin> dom (Cp r)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "hence x_notin_tl_s: \"\\<forall> r. r \\<in> set (tl s) \\<longrightarrow>  x \\<notin> dom (Cp r)\""], ["proof (prove)\nusing this:\n  \\<forall>r. r \\<in> set (tl p) \\<longrightarrow> x \\<notin> dom (Cp r)\n\ngoal (1 subgoal):\n 1. \\<forall>r. r \\<in> set (tl s) \\<longrightarrow> x \\<notin> dom (Cp r)", "using tl_eq"], ["proof (prove)\nusing this:\n  \\<forall>r. r \\<in> set (tl p) \\<longrightarrow> x \\<notin> dom (Cp r)\n  set (tl p) = set (tl s)\n\ngoal (1 subgoal):\n 1. \\<forall>r. r \\<in> set (tl s) \\<longrightarrow> x \\<notin> dom (Cp r)", "by auto"], ["proof (state)\nthis:\n  \\<forall>r. r \\<in> set (tl s) \\<longrightarrow> x \\<notin> dom (Cp r)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "hence mr_s_is_DenyAll: \"applied_rule_rev Cp x s = Some DenyAll\""], ["proof (prove)\nusing this:\n  \\<forall>r. r \\<in> set (tl s) \\<longrightarrow> x \\<notin> dom (Cp r)\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x s = \\<lfloor>DenyAll\\<rfloor>", "using tl_s"], ["proof (prove)\nusing this:\n  \\<forall>r. r \\<in> set (tl s) \\<longrightarrow> x \\<notin> dom (Cp r)\n  s = DenyAll # tl s\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x s = \\<lfloor>DenyAll\\<rfloor>", "by (auto simp: mr_first)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x s = \\<lfloor>DenyAll\\<rfloor>\n\ngoal (4 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 4. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "thus ?thesis"], ["proof (prove)\nusing this:\n  applied_rule_rev Cp x s = \\<lfloor>DenyAll\\<rfloor>\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = applied_rule_rev Cp x s", "using mr_p_is_DenyAll"], ["proof (prove)\nusing this:\n  applied_rule_rev Cp x s = \\<lfloor>DenyAll\\<rfloor>\n  applied_rule_rev Cp x p = \\<lfloor>DenyAll\\<rfloor>\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = applied_rule_rev Cp x s", "by simp"], ["proof (state)\nthis:\n  applied_rule_rev Cp x p = applied_rule_rev Cp x s\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "case (DenyAllFromTo a b)"], ["proof (state)\nthis:\n  y = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "have mr_p_is_DAFT: \"applied_rule_rev Cp x p = Some (DenyAllFromTo a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>", "by (simp add: DenyAllFromTo Some)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "have DA_notin_tl: \"DenyAll \\<notin> set (tl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<notin> set (tl p)", "by (metis WP1n_DA_notinSet wp1_p)"], ["proof (state)\nthis:\n  DenyAll \\<notin> set (tl p)\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "have mr_tl_p: \"applied_rule_rev Cp x p = applied_rule_rev Cp x (tl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = applied_rule_rev Cp x (tl p)", "by (metis Combinators.simps(4) DenyAllFromTo Some mrConcEnd tl_p)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x p = applied_rule_rev Cp x (tl p)\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "have dom_tl_p: \"\\<And> r. r \\<in> set (tl p) \\<and> x \\<in> dom (Cp r) \\<Longrightarrow> \n                        r = (DenyAllFromTo a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> set (tl p) \\<and> x \\<in> dom (Cp r) \\<Longrightarrow>\n       r = DenyAllFromTo a b", "using wp1_p aND SC wp3_p mr_p_is_DAFT"], ["proof (prove)\nusing this:\n  wellformed_policy1_strong p\n  allNetsDistinct p\n  singleCombinators p\n  wellformed_policy3Pr p\n  applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> set (tl p) \\<and> x \\<in> dom (Cp r) \\<Longrightarrow>\n       r = DenyAllFromTo a b", "by (auto simp: rule_charnDAFT)"], ["proof (state)\nthis:\n  ?r \\<in> set (tl p) \\<and> x \\<in> dom (Cp ?r) \\<Longrightarrow>\n  ?r = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "hence dom_tl_s: \"\\<And> r. r \\<in> set (tl s) \\<and> x \\<in> dom (Cp r) \\<Longrightarrow> \n                         r = (DenyAllFromTo a b)\""], ["proof (prove)\nusing this:\n  ?r \\<in> set (tl p) \\<and> x \\<in> dom (Cp ?r) \\<Longrightarrow>\n  ?r = DenyAllFromTo a b\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> set (tl s) \\<and> x \\<in> dom (Cp r) \\<Longrightarrow>\n       r = DenyAllFromTo a b", "using tl_eq"], ["proof (prove)\nusing this:\n  ?r \\<in> set (tl p) \\<and> x \\<in> dom (Cp ?r) \\<Longrightarrow>\n  ?r = DenyAllFromTo a b\n  set (tl p) = set (tl s)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> set (tl s) \\<and> x \\<in> dom (Cp r) \\<Longrightarrow>\n       r = DenyAllFromTo a b", "by auto"], ["proof (state)\nthis:\n  ?r \\<in> set (tl s) \\<and> x \\<in> dom (Cp ?r) \\<Longrightarrow>\n  ?r = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "have DAFT_in_tl_s: \"DenyAllFromTo a b \\<in> set (tl s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAllFromTo a b \\<in> set (tl s)", "using mr_tl_p"], ["proof (prove)\nusing this:\n  applied_rule_rev Cp x p = applied_rule_rev Cp x (tl p)\n\ngoal (1 subgoal):\n 1. DenyAllFromTo a b \\<in> set (tl s)", "by (metis DenyAllFromTo mrSet mr_p_is_DAFT tl_eq)"], ["proof (state)\nthis:\n  DenyAllFromTo a b \\<in> set (tl s)\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "have x_in_dom_DAFT: \"x \\<in> dom (Cp (DenyAllFromTo a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (DenyAllFromTo a b))", "by (metis mr_p_is_DAFT DenyAllFromTo mr_in_dom)"], ["proof (state)\nthis:\n  x \\<in> dom (Cp (DenyAllFromTo a b))\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "hence mr_tl_s_is_DAFT: \"applied_rule_rev Cp x (tl s) = Some (DenyAllFromTo a b)\""], ["proof (prove)\nusing this:\n  x \\<in> dom (Cp (DenyAllFromTo a b))\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (tl s) = \\<lfloor>DenyAllFromTo a b\\<rfloor>", "using DAFT_in_tl_s dom_tl_s"], ["proof (prove)\nusing this:\n  x \\<in> dom (Cp (DenyAllFromTo a b))\n  DenyAllFromTo a b \\<in> set (tl s)\n  ?r \\<in> set (tl s) \\<and> x \\<in> dom (Cp ?r) \\<Longrightarrow>\n  ?r = DenyAllFromTo a b\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (tl s) = \\<lfloor>DenyAllFromTo a b\\<rfloor>", "by (metis mr_charn)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (tl s) = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "hence mr_s_is_DAFT: \"applied_rule_rev Cp x s = Some (DenyAllFromTo a b)\""], ["proof (prove)\nusing this:\n  applied_rule_rev Cp x (tl s) = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x s = \\<lfloor>DenyAllFromTo a b\\<rfloor>", "using tl_s"], ["proof (prove)\nusing this:\n  applied_rule_rev Cp x (tl s) = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n  s = DenyAll # tl s\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x s = \\<lfloor>DenyAllFromTo a b\\<rfloor>", "by (metis  DA_notin_tl DenyAllFromTo EX_MR mrDA_tl \n            not_Some_eq tl_eq wellformed_policy1_strong.simps(2))"], ["proof (state)\nthis:\n  applied_rule_rev Cp x s = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 3. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "thus ?thesis"], ["proof (prove)\nusing this:\n  applied_rule_rev Cp x s = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = applied_rule_rev Cp x s", "using mr_p_is_DAFT"], ["proof (prove)\nusing this:\n  applied_rule_rev Cp x s = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n  applied_rule_rev Cp x p = \\<lfloor>DenyAllFromTo a b\\<rfloor>\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = applied_rule_rev Cp x s", "by simp"], ["proof (state)\nthis:\n  applied_rule_rev Cp x p = applied_rule_rev Cp x s\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "case (AllowPortFromTo a b c)"], ["proof (state)\nthis:\n  y = AllowPortFromTo a b c\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "have wp1s: \"wellformed_policy1 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1 s", "by (metis wp1_eq wp1_s)"], ["proof (state)\nthis:\n  wellformed_policy1 s\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "have mr_p_is_A: \"applied_rule_rev Cp x p = Some (AllowPortFromTo a b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = \\<lfloor>AllowPortFromTo a b c\\<rfloor>", "by (simp add: AllowPortFromTo Some)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x p = \\<lfloor>AllowPortFromTo a b c\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "hence A_in_s: \"AllowPortFromTo a b c \\<in> set s\""], ["proof (prove)\nusing this:\n  applied_rule_rev Cp x p = \\<lfloor>AllowPortFromTo a b c\\<rfloor>\n\ngoal (1 subgoal):\n 1. AllowPortFromTo a b c \\<in> set s", "using sets_eq"], ["proof (prove)\nusing this:\n  applied_rule_rev Cp x p = \\<lfloor>AllowPortFromTo a b c\\<rfloor>\n  set p = set s\n\ngoal (1 subgoal):\n 1. AllowPortFromTo a b c \\<in> set s", "by (auto intro: mrSet)"], ["proof (state)\nthis:\n  AllowPortFromTo a b c \\<in> set s\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "have x_in_dom_A: \"x \\<in> dom (Cp (AllowPortFromTo a b c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (AllowPortFromTo a b c))", "by (metis mr_p_is_A AllowPortFromTo mr_in_dom)"], ["proof (state)\nthis:\n  x \\<in> dom (Cp (AllowPortFromTo a b c))\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "have SCs: \"singleCombinators s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators s", "using SC sets_eq"], ["proof (prove)\nusing this:\n  singleCombinators p\n  set p = set s\n\ngoal (1 subgoal):\n 1. singleCombinators s", "by (auto intro: SCSubset)"], ["proof (state)\nthis:\n  singleCombinators s\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "hence ANDs: \"allNetsDistinct s\""], ["proof (prove)\nusing this:\n  singleCombinators s\n\ngoal (1 subgoal):\n 1. allNetsDistinct s", "using aND sets_eq SC"], ["proof (prove)\nusing this:\n  singleCombinators s\n  allNetsDistinct p\n  set p = set s\n  singleCombinators p\n\ngoal (1 subgoal):\n 1. allNetsDistinct s", "by (auto intro: aNDSetsEq)"], ["proof (state)\nthis:\n  allNetsDistinct s\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "hence mr_s_is_A: \"applied_rule_rev Cp x s = Some (AllowPortFromTo a b c)\""], ["proof (prove)\nusing this:\n  allNetsDistinct s\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x s = \\<lfloor>AllowPortFromTo a b c\\<rfloor>", "using A_in_s wp1s mr_p_is_A aND SCs wp3_s x_in_dom_A"], ["proof (prove)\nusing this:\n  allNetsDistinct s\n  AllowPortFromTo a b c \\<in> set s\n  wellformed_policy1 s\n  applied_rule_rev Cp x p = \\<lfloor>AllowPortFromTo a b c\\<rfloor>\n  allNetsDistinct p\n  singleCombinators s\n  wellformed_policy3Pr s\n  x \\<in> dom (Cp (AllowPortFromTo a b c))\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x s = \\<lfloor>AllowPortFromTo a b c\\<rfloor>", "by (simp add: rule_charn2)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x s = \\<lfloor>AllowPortFromTo a b c\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s\n 2. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "thus ?thesis"], ["proof (prove)\nusing this:\n  applied_rule_rev Cp x s = \\<lfloor>AllowPortFromTo a b c\\<rfloor>\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = applied_rule_rev Cp x s", "using mr_p_is_A"], ["proof (prove)\nusing this:\n  applied_rule_rev Cp x s = \\<lfloor>AllowPortFromTo a b c\\<rfloor>\n  applied_rule_rev Cp x p = \\<lfloor>AllowPortFromTo a b c\\<rfloor>\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = applied_rule_rev Cp x s", "by simp"], ["proof (state)\nthis:\n  applied_rule_rev Cp x p = applied_rule_rev Cp x s\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "}"], ["proof (state)\nthis:\n  y = AllowPortFromTo ?a2 ?b2 ?c2 \\<Longrightarrow>\n  applied_rule_rev Cp x p = applied_rule_rev Cp x s\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "case (Conc a b)"], ["proof (state)\nthis:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>applied_rule_rev Cp x p = \\<lfloor>y\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x p = applied_rule_rev Cp x s", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x p = applied_rule_rev Cp x s", "by (metis Some mr_not_Conc SC)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x p = applied_rule_rev Cp x s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  applied_rule_rev Cp x p = applied_rule_rev Cp x s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_Sets: \n\"singleCombinators p \\<Longrightarrow> wellformed_policy1_strong p \\<Longrightarrow> wellformed_policy1_strong s \\<Longrightarrow>\n wellformed_policy3Pr p \\<Longrightarrow> wellformed_policy3Pr s \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> set p = set s \\<Longrightarrow>\n Cp (list2FWpolicy p) x  = Cp (list2FWpolicy s) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; wellformed_policy1_strong p;\n     wellformed_policy1_strong s; wellformed_policy3Pr p;\n     wellformed_policy3Pr s; allNetsDistinct p; set p = set s\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy p) x = Cp (list2FWpolicy s) x", "by (metis C_eq_Sets_mr C_eq_if_mr_eq  wellformed_policy1_strong.simps(1))"], ["", "lemma C_eq_sorted: \n  \"distinct p \\<Longrightarrow> all_in_list p l \\<Longrightarrow> singleCombinators p \\<Longrightarrow>\n   wellformed_policy1_strong p\\<Longrightarrow> wellformed_policy3Pr p\\<Longrightarrow> allNetsDistinct p \\<Longrightarrow>\n   Cp (list2FWpolicy (sort p l))= Cp (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct p; all_in_list p l; singleCombinators p;\n     wellformed_policy1_strong p; wellformed_policy3Pr p;\n     allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (FWNormalisationCore.sort p l)) =\n                      Cp (list2FWpolicy p)", "by (rule ext)\n    (meson distinct_sort set_sort C_eq_Sets wellformed2_sorted wellformed_policy3_charn SC3 aND_sort \n      wellformed1_alternative_sorted wp1_eq)"], ["", "lemma C_eq_sortedQ: \n  \"distinct p \\<Longrightarrow> all_in_list p l \\<Longrightarrow> singleCombinators p \\<Longrightarrow> \n   wellformed_policy1_strong p \\<Longrightarrow>  wellformed_policy3Pr p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow>\n   Cp (list2FWpolicy (qsort p l))= Cp (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct p; all_in_list p l; singleCombinators p;\n     wellformed_policy1_strong p; wellformed_policy3Pr p;\n     allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (qsort p l)) = Cp (list2FWpolicy p)", "by (rule ext)\n    (metis C_eq_Sets wellformed2_sortedQ wellformed_policy3_charn SC3Q aND_sortQ distinct_sortQ \n      set_sortQ wellformed1_sorted_auxQ wellformed_eq wp1_aux1aa)"], ["", "lemma C_eq_RS2_mr: \"applied_rule_rev Cp x (removeShadowRules2 p)= applied_rule_rev Cp x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (removeShadowRules2 p) = applied_rule_rev Cp x p", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. applied_rule_rev Cp x (removeShadowRules2 []) = applied_rule_rev Cp x []\n 2. \\<And>a p.\n       applied_rule_rev Cp x (removeShadowRules2 p) =\n       applied_rule_rev Cp x p \\<Longrightarrow>\n       applied_rule_rev Cp x (removeShadowRules2 (a # p)) =\n       applied_rule_rev Cp x (a # p)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. applied_rule_rev Cp x (removeShadowRules2 []) = applied_rule_rev Cp x []\n 2. \\<And>a p.\n       applied_rule_rev Cp x (removeShadowRules2 p) =\n       applied_rule_rev Cp x p \\<Longrightarrow>\n       applied_rule_rev Cp x (removeShadowRules2 (a # p)) =\n       applied_rule_rev Cp x (a # p)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (removeShadowRules2 []) = applied_rule_rev Cp x []", "by simp"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (removeShadowRules2 []) = applied_rule_rev Cp x []\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       applied_rule_rev Cp x (removeShadowRules2 p) =\n       applied_rule_rev Cp x p \\<Longrightarrow>\n       applied_rule_rev Cp x (removeShadowRules2 (a # p)) =\n       applied_rule_rev Cp x (a # p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       applied_rule_rev Cp x (removeShadowRules2 p) =\n       applied_rule_rev Cp x p \\<Longrightarrow>\n       applied_rule_rev Cp x (removeShadowRules2 (a # p)) =\n       applied_rule_rev Cp x (a # p)", "case (Cons y ys)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (removeShadowRules2 ys) = applied_rule_rev Cp x ys\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       applied_rule_rev Cp x (removeShadowRules2 p) =\n       applied_rule_rev Cp x p \\<Longrightarrow>\n       applied_rule_rev Cp x (removeShadowRules2 (a # p)) =\n       applied_rule_rev Cp x (a # p)", "thus ?case"], ["proof (prove)\nusing this:\n  applied_rule_rev Cp x (removeShadowRules2 ys) = applied_rule_rev Cp x ys\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev Cp x (y # ys)", "proof (cases \"ys = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x (removeShadowRules2 ys) =\n             applied_rule_rev Cp x ys;\n     ys = []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev Cp x (y # ys)\n 2. \\<lbrakk>applied_rule_rev Cp x (removeShadowRules2 ys) =\n             applied_rule_rev Cp x ys;\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev Cp x (y # ys)", "case True"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x (removeShadowRules2 ys) =\n             applied_rule_rev Cp x ys;\n     ys = []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev Cp x (y # ys)\n 2. \\<lbrakk>applied_rule_rev Cp x (removeShadowRules2 ys) =\n             applied_rule_rev Cp x ys;\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev Cp x (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys = []\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev Cp x (y # ys)", "by (cases y, simp_all)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev Cp x (y # ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev Cp x (removeShadowRules2 ys) =\n             applied_rule_rev Cp x ys;\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev Cp x (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev Cp x (removeShadowRules2 ys) =\n             applied_rule_rev Cp x ys;\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev Cp x (y # ys)", "case False"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>applied_rule_rev Cp x (removeShadowRules2 ys) =\n             applied_rule_rev Cp x ys;\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev Cp x (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev Cp x (y # ys)", "proof (cases y)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>ys \\<noteq> []; y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev Cp x (y # ys)\n 2. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> []; y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> []; y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)\n 4. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)", "case DenyAll"], ["proof (state)\nthis:\n  y = DenyAll\n\ngoal (4 subgoals):\n 1. \\<lbrakk>ys \\<noteq> []; y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev Cp x (y # ys)\n 2. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> []; y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> []; y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)\n 4. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = DenyAll\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev Cp x (y # ys)", "by (simp, metis Cons DenyAll mreq_end2)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev Cp x (y # ys)\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> []; y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> []; y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)\n 3. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> []; y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> []; y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)\n 3. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)", "case (DenyAllFromTo a b)"], ["proof (state)\nthis:\n  y = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> []; y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> []; y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)\n 3. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev Cp x (y # ys)", "by (simp, metis Cons DenyAllFromTo mreq_end2)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev Cp x (y # ys)\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> []; y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)\n 2. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> []; y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)\n 2. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)", "case (AllowPortFromTo a b p)"], ["proof (state)\nthis:\n  y = AllowPortFromTo a b p\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> []; y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)\n 2. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a b p\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev Cp x (y # ys)", "proof (cases \"DenyAllFromTo a b \\<in> set ys\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b p;\n     DenyAllFromTo a b \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev Cp x (y # ys)\n 2. \\<lbrakk>y = AllowPortFromTo a b p;\n     DenyAllFromTo a b \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev Cp x (y # ys)", "case True"], ["proof (state)\nthis:\n  DenyAllFromTo a b \\<in> set ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b p;\n     DenyAllFromTo a b \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev Cp x (y # ys)\n 2. \\<lbrakk>y = AllowPortFromTo a b p;\n     DenyAllFromTo a b \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev Cp x (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  DenyAllFromTo a b \\<in> set ys\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev Cp x (y # ys)", "using AllowPortFromTo Cons"], ["proof (prove)\nusing this:\n  DenyAllFromTo a b \\<in> set ys\n  y = AllowPortFromTo a b p\n  applied_rule_rev Cp x (removeShadowRules2 ys) = applied_rule_rev Cp x ys\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev Cp x (y # ys)", "apply (cases \"applied_rule_rev Cp x ys = None\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x ys = \\<bottom>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev Cp x (removeShadowRules2 ys) = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> \\<bottom> =\n                      applied_rule_rev Cp x (AllowPortFromTo a b p # ys)\n 2. \\<lbrakk>\\<exists>y. applied_rule_rev Cp x ys = \\<lfloor>y\\<rfloor>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev Cp x (removeShadowRules2 ys) =\n     applied_rule_rev Cp x ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x ys =\n                      applied_rule_rev Cp x (AllowPortFromTo a b p # ys)", "apply (subgoal_tac \"x \\<notin> dom (Cp (AllowPortFromTo a b p))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x ys = \\<bottom>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev Cp x (removeShadowRules2 ys) = \\<bottom>;\n     x \\<notin> dom (Cp (AllowPortFromTo a b p))\\<rbrakk>\n    \\<Longrightarrow> \\<bottom> =\n                      applied_rule_rev Cp x (AllowPortFromTo a b p # ys)\n 2. \\<lbrakk>applied_rule_rev Cp x ys = \\<bottom>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev Cp x (removeShadowRules2 ys) = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp (AllowPortFromTo a b p))\n 3. \\<lbrakk>\\<exists>y. applied_rule_rev Cp x ys = \\<lfloor>y\\<rfloor>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev Cp x (removeShadowRules2 ys) =\n     applied_rule_rev Cp x ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x ys =\n                      applied_rule_rev Cp x (AllowPortFromTo a b p # ys)", "apply (subst mrconcNone, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x ys = \\<bottom>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev Cp x (removeShadowRules2 ys) = \\<bottom>;\n     x \\<notin> dom (Cp (AllowPortFromTo a b p))\\<rbrakk>\n    \\<Longrightarrow> \\<bottom> =\n                      applied_rule_rev Cp x [AllowPortFromTo a b p]\n 2. \\<lbrakk>applied_rule_rev Cp x ys = \\<bottom>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev Cp x (removeShadowRules2 ys) = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp (AllowPortFromTo a b p))\n 3. \\<lbrakk>\\<exists>y. applied_rule_rev Cp x ys = \\<lfloor>y\\<rfloor>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev Cp x (removeShadowRules2 ys) =\n     applied_rule_rev Cp x ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x ys =\n                      applied_rule_rev Cp x (AllowPortFromTo a b p # ys)", "apply (simp add: applied_rule_rev_def )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x ys = \\<bottom>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev Cp x (removeShadowRules2 ys) = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp (AllowPortFromTo a b p))\n 2. \\<lbrakk>\\<exists>y. applied_rule_rev Cp x ys = \\<lfloor>y\\<rfloor>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev Cp x (removeShadowRules2 ys) =\n     applied_rule_rev Cp x ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x ys =\n                      applied_rule_rev Cp x (AllowPortFromTo a b p # ys)", "apply (rule contra_subsetD [OF allow_deny_dom])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>applied_rule_rev Cp x ys = \\<bottom>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev Cp x (removeShadowRules2 ys) = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp (DenyAllFromTo a b))\n 2. \\<lbrakk>\\<exists>y. applied_rule_rev Cp x ys = \\<lfloor>y\\<rfloor>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev Cp x (removeShadowRules2 ys) =\n     applied_rule_rev Cp x ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x ys =\n                      applied_rule_rev Cp x (AllowPortFromTo a b p # ys)", "apply (erule mrNoneMT,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>y. applied_rule_rev Cp x ys = \\<lfloor>y\\<rfloor>;\n     DenyAllFromTo a b \\<in> set ys; y = AllowPortFromTo a b p;\n     applied_rule_rev Cp x (removeShadowRules2 ys) =\n     applied_rule_rev Cp x ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x ys =\n                      applied_rule_rev Cp x (AllowPortFromTo a b p # ys)", "apply (metis AllowPortFromTo mrconc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev Cp x (y # ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b p;\n     DenyAllFromTo a b \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev Cp x (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b p;\n     DenyAllFromTo a b \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev Cp x (y # ys)", "case False"], ["proof (state)\nthis:\n  DenyAllFromTo a b \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b p;\n     DenyAllFromTo a b \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n                      applied_rule_rev Cp x (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  DenyAllFromTo a b \\<notin> set ys\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev Cp x (y # ys)", "using False Cons AllowPortFromTo"], ["proof (prove)\nusing this:\n  DenyAllFromTo a b \\<notin> set ys\n  DenyAllFromTo a b \\<notin> set ys\n  applied_rule_rev Cp x (removeShadowRules2 ys) = applied_rule_rev Cp x ys\n  y = AllowPortFromTo a b p\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev Cp x (y # ys)", "by (simp, metis AllowPortFromTo Cons mreq_end2)"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev Cp x (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev Cp x (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)", "case (Conc a b)"], ["proof (state)\nthis:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> []; y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> applied_rule_rev Cp x\n                          (removeShadowRules2 (y # ys)) =\n                         applied_rule_rev Cp x (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n    applied_rule_rev Cp x (y # ys)", "by (metis Cons mreq_end2 removeShadowRules2.simps(4))"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev Cp x (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev Cp x (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  applied_rule_rev Cp x (removeShadowRules2 (y # ys)) =\n  applied_rule_rev Cp x (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_None[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> applied_rule_rev Cp x p = None \\<longrightarrow>  Cp (list2FWpolicy p) x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    applied_rule_rev Cp x p = \\<bottom> \\<longrightarrow>\n    Cp (list2FWpolicy p) x = \\<bottom>", "unfolding applied_rule_rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    applied_rule Cp x (rev p) = \\<bottom> \\<longrightarrow>\n    Cp (list2FWpolicy p) x = \\<bottom>", "proof(induct rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    applied_rule Cp x (rev []) = \\<bottom> \\<longrightarrow>\n    Cp (list2FWpolicy []) x = \\<bottom>\n 2. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       applied_rule Cp x (rev xs) = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy xs) x = \\<bottom> \\<Longrightarrow>\n       xs @ [xa] \\<noteq> [] \\<longrightarrow>\n       applied_rule Cp x (rev (xs @ [xa])) = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    applied_rule Cp x (rev []) = \\<bottom> \\<longrightarrow>\n    Cp (list2FWpolicy []) x = \\<bottom>\n 2. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       applied_rule Cp x (rev xs) = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy xs) x = \\<bottom> \\<Longrightarrow>\n       xs @ [xa] \\<noteq> [] \\<longrightarrow>\n       applied_rule Cp x (rev (xs @ [xa])) = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    applied_rule Cp x (rev []) = \\<bottom> \\<longrightarrow>\n    Cp (list2FWpolicy []) x = \\<bottom>", "by simp"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  applied_rule Cp x (rev []) = \\<bottom> \\<longrightarrow>\n  Cp (list2FWpolicy []) x = \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       applied_rule Cp x (rev xs) = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy xs) x = \\<bottom> \\<Longrightarrow>\n       xs @ [xa] \\<noteq> [] \\<longrightarrow>\n       applied_rule Cp x (rev (xs @ [xa])) = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       applied_rule Cp x (rev xs) = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy xs) x = \\<bottom> \\<Longrightarrow>\n       xs @ [xa] \\<noteq> [] \\<longrightarrow>\n       applied_rule Cp x (rev (xs @ [xa])) = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "case (snoc xa xs)"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<longrightarrow>\n  applied_rule Cp x (rev xs) = \\<bottom> \\<longrightarrow>\n  Cp (list2FWpolicy xs) x = \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       xs \\<noteq> [] \\<longrightarrow>\n       applied_rule Cp x (rev xs) = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy xs) x = \\<bottom> \\<Longrightarrow>\n       xs @ [xa] \\<noteq> [] \\<longrightarrow>\n       applied_rule Cp x (rev (xs @ [xa])) = \\<bottom> \\<longrightarrow>\n       Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ [xa] \\<noteq> [] \\<longrightarrow>\n    applied_rule Cp x (rev (xs @ [xa])) = \\<bottom> \\<longrightarrow>\n    Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "apply (insert snoc.hyps, intro impI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> [] \\<longrightarrow>\n             applied_rule Cp x (rev xs) = \\<bottom> \\<longrightarrow>\n             Cp (list2FWpolicy xs) x = \\<bottom>;\n     (if x \\<in> dom (Cp xa) then \\<lfloor>xa\\<rfloor>\n      else applied_rule Cp x (rev xs)) =\n     \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "apply (case_tac \"xs \\<noteq> []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> [] \\<longrightarrow>\n             applied_rule Cp x (rev xs) = \\<bottom> \\<longrightarrow>\n             Cp (list2FWpolicy xs) x = \\<bottom>;\n     (if x \\<in> dom (Cp xa) then \\<lfloor>xa\\<rfloor>\n      else applied_rule Cp x (rev xs)) =\n     \\<bottom>;\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>\n 2. \\<lbrakk>xs \\<noteq> [] \\<longrightarrow>\n             applied_rule Cp x (rev xs) = \\<bottom> \\<longrightarrow>\n             Cp (list2FWpolicy xs) x = \\<bottom>;\n     (if x \\<in> dom (Cp xa) then \\<lfloor>xa\\<rfloor>\n      else applied_rule Cp x (rev xs)) =\n     \\<bottom>;\n     \\<not> xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "apply (metis CConcStart2 option.simps(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> [] \\<longrightarrow>\n             applied_rule Cp x (rev xs) = \\<bottom> \\<longrightarrow>\n             Cp (list2FWpolicy xs) x = \\<bottom>;\n     (if x \\<in> dom (Cp xa) then \\<lfloor>xa\\<rfloor>\n      else applied_rule Cp x (rev xs)) =\n     \\<bottom>;\n     \\<not> xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>", "by (metis append_Nil domIff l2p_aux2 option.distinct(1))"], ["proof (state)\nthis:\n  xs @ [xa] \\<noteq> [] \\<longrightarrow>\n  applied_rule Cp x (rev (xs @ [xa])) = \\<bottom> \\<longrightarrow>\n  Cp (list2FWpolicy (xs @ [xa])) x = \\<bottom>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_None2:\n  \"a \\<noteq> []  \\<Longrightarrow> b \\<noteq> [] \\<Longrightarrow>  applied_rule_rev Cp x a = None  \\<Longrightarrow>  applied_rule_rev Cp x b = None \\<Longrightarrow>\n  (Cp (list2FWpolicy a)) x = (Cp (list2FWpolicy b)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> []; b \\<noteq> [];\n     applied_rule_rev Cp x a = \\<bottom>;\n     applied_rule_rev Cp x b = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy a) x = Cp (list2FWpolicy b) x", "by (auto simp: C_eq_None)"], ["", "lemma C_eq_RS2: \n  \"wellformed_policy1_strong p \\<Longrightarrow> \n  Cp (list2FWpolicy (removeShadowRules2 p))= Cp (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<Longrightarrow>\n    Cp (list2FWpolicy (removeShadowRules2 p)) = Cp (list2FWpolicy p)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       wellformed_policy1_strong p \\<Longrightarrow>\n       Cp (list2FWpolicy (removeShadowRules2 p)) x = Cp (list2FWpolicy p) x", "by (metis C_eq_RS2_mr C_eq_if_mr_eq RS2_NMT wp1_alternative_not_mt)"], ["", "lemma none_MT_rulesRS2: \"none_MT_rules Cp p \\<Longrightarrow> none_MT_rules Cp (removeShadowRules2 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. none_MT_rules Cp p \\<Longrightarrow>\n    none_MT_rules Cp (removeShadowRules2 p)", "by (auto simp: RS2Set none_MT_rulessubset)"], ["", "lemma CconcNone: \n  \"dom (Cp a) = {} \\<Longrightarrow> p \\<noteq> [] \\<Longrightarrow> Cp (list2FWpolicy (a # p)) x = Cp (list2FWpolicy p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom (Cp a) = {}; p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (a # p)) x = Cp (list2FWpolicy p) x", "apply (case_tac \"p = []\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom (Cp a) = {}; p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (a # p)) x = Cp (list2FWpolicy p) x", "apply (case_tac \"x\\<in> dom (Cp (list2FWpolicy(p)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>dom (Cp a) = {}; p \\<noteq> [];\n     x \\<in> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (a # p)) x = Cp (list2FWpolicy p) x\n 2. \\<lbrakk>dom (Cp a) = {}; p \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (a # p)) x = Cp (list2FWpolicy p) x", "apply (metis Cdom2 list2FWpolicyconc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom (Cp a) = {}; p \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (a # p)) x = Cp (list2FWpolicy p) x", "apply (metis Cp.simps(4) map_add_dom_app_simps(2) inSet_not_MT list2FWpolicyconc set_empty2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma none_MT_rulesrd[rule_format]: \"none_MT_rules Cp p \\<longrightarrow> none_MT_rules Cp (remdups p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. none_MT_rules Cp p \\<longrightarrow> none_MT_rules Cp (remdups p)", "by (induct p, simp_all)"], ["", "lemma DARS3[rule_format]:\"DenyAll \\<notin> set p\\<longrightarrow>DenyAll \\<notin> set (rm_MT_rules Cp p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<notin> set p \\<longrightarrow>\n    DenyAll \\<notin> set (rm_MT_rules Cp p)", "by (induct p, simp_all)"], ["", "lemma DAnMT: \"dom (Cp DenyAll) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (Cp DenyAll) \\<noteq> {}", "by (simp add: dom_def Cp.simps PolicyCombinators.PolicyCombinators)"], ["", "lemma DAnMT2: \"Cp DenyAll \\<noteq> Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp DenyAll \\<noteq> \\<emptyset>", "by (metis DAAux dom_eq_empty_conv empty_iff)"], ["", "lemma wp1n_RS3[rule_format,simp]: \n  \"wellformed_policy1_strong p \\<longrightarrow>  wellformed_policy1_strong (rm_MT_rules Cp p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<longrightarrow>\n    wellformed_policy1_strong (rm_MT_rules Cp p)", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       wellformed_policy1_strong p \\<longrightarrow>\n       wellformed_policy1_strong (rm_MT_rules Cp p) \\<Longrightarrow>\n       (dom (Cp DenyAll) = {} \\<longrightarrow>\n        a = DenyAll \\<and> DenyAll \\<notin> set p \\<longrightarrow>\n        wellformed_policy1_strong (rm_MT_rules Cp p)) \\<and>\n       (dom (Cp DenyAll) \\<noteq> {} \\<longrightarrow>\n        a = DenyAll \\<and> DenyAll \\<notin> set p \\<longrightarrow>\n        DenyAll \\<notin> set (rm_MT_rules Cp p))", "apply (rule conjI| rule impI|simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>wellformed_policy1_strong p \\<longrightarrow>\n                wellformed_policy1_strong (rm_MT_rules Cp p);\n        dom (Cp DenyAll) = {}; DenyAll \\<notin> set p\\<rbrakk>\n       \\<Longrightarrow> wellformed_policy1_strong (rm_MT_rules Cp p)\n 2. \\<And>a p.\n       wellformed_policy1_strong p \\<longrightarrow>\n       wellformed_policy1_strong (rm_MT_rules Cp p) \\<Longrightarrow>\n       dom (Cp DenyAll) \\<noteq> {} \\<longrightarrow>\n       a = DenyAll \\<and> DenyAll \\<notin> set p \\<longrightarrow>\n       DenyAll \\<notin> set (rm_MT_rules Cp p)", "apply (metis DAnMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       wellformed_policy1_strong p \\<longrightarrow>\n       wellformed_policy1_strong (rm_MT_rules Cp p) \\<Longrightarrow>\n       dom (Cp DenyAll) \\<noteq> {} \\<longrightarrow>\n       a = DenyAll \\<and> DenyAll \\<notin> set p \\<longrightarrow>\n       DenyAll \\<notin> set (rm_MT_rules Cp p)", "apply (metis DARS3)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma AILRS3[rule_format,simp]: \n  \"all_in_list p l \\<longrightarrow> all_in_list (rm_MT_rules Cp p) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_in_list p l \\<longrightarrow> all_in_list (rm_MT_rules Cp p) l", "by (induct p, simp_all)"], ["", "lemma SCRS3[rule_format,simp]: \n  \"singleCombinators p \\<longrightarrow> singleCombinators(rm_MT_rules Cp p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<longrightarrow>\n    singleCombinators (rm_MT_rules Cp p)", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       singleCombinators p \\<longrightarrow>\n       singleCombinators (rm_MT_rules Cp p) \\<Longrightarrow>\n       (dom (Cp a) = {} \\<longrightarrow>\n        singleCombinators (a # p) \\<longrightarrow>\n        singleCombinators (rm_MT_rules Cp p)) \\<and>\n       (dom (Cp a) \\<noteq> {} \\<longrightarrow>\n        singleCombinators (a # p) \\<longrightarrow>\n        singleCombinators (a # rm_MT_rules Cp p))", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. singleCombinators p \\<longrightarrow>\n    singleCombinators (rm_MT_rules Cp p) \\<Longrightarrow>\n    (dom (Cp a) = {} \\<longrightarrow>\n     singleCombinators (a # p) \\<longrightarrow>\n     singleCombinators (rm_MT_rules Cp p)) \\<and>\n    (dom (Cp a) \\<noteq> {} \\<longrightarrow>\n     singleCombinators (a # p) \\<longrightarrow>\n     singleCombinators (a # rm_MT_rules Cp p))", "apply(case_tac \"a\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma RS3subset: \"set (rm_MT_rules Cp p)  \\<subseteq> set p \""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rm_MT_rules Cp p) \\<subseteq> set p", "by (induct p, auto)"], ["", "lemma ANDRS3[simp]: \n  \"singleCombinators p \\<Longrightarrow> allNetsDistinct p \\<Longrightarrow> allNetsDistinct (rm_MT_rules Cp p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>singleCombinators p; allNetsDistinct p\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct (rm_MT_rules Cp p)", "by (rule_tac b = p in aNDSubset, simp_all add:RS3subset)"], ["", "lemma nlpaux: \"x \\<notin> dom (Cp b) \\<Longrightarrow> Cp (a \\<oplus> b) x = Cp a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom (Cp b) \\<Longrightarrow> Cp (a \\<oplus> b) x = Cp a x", "by (metis Cp.simps(4) map_add_dom_app_simps(3))"], ["", "lemma notindom[rule_format]: \n  \"a \\<in> set p \\<longrightarrow>  x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow> x \\<notin> dom (Cp a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set p \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n    x \\<notin> dom (Cp a)", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> set [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n    x \\<notin> dom (Cp a)\n 2. \\<And>aa p.\n       a \\<in> set p \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       x \\<notin> dom (Cp a) \\<Longrightarrow>\n       a \\<in> set (aa # p) \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy (aa # p))) \\<longrightarrow>\n       x \\<notin> dom (Cp a)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. a \\<in> set [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n    x \\<notin> dom (Cp a)\n 2. \\<And>aa p.\n       a \\<in> set p \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       x \\<notin> dom (Cp a) \\<Longrightarrow>\n       a \\<in> set (aa # p) \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy (aa # p))) \\<longrightarrow>\n       x \\<notin> dom (Cp a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n    x \\<notin> dom (Cp a)", "by simp"], ["proof (state)\nthis:\n  a \\<in> set [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n  x \\<notin> dom (Cp a)\n\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       a \\<in> set p \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       x \\<notin> dom (Cp a) \\<Longrightarrow>\n       a \\<in> set (aa # p) \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy (aa # p))) \\<longrightarrow>\n       x \\<notin> dom (Cp a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       a \\<in> set p \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       x \\<notin> dom (Cp a) \\<Longrightarrow>\n       a \\<in> set (aa # p) \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy (aa # p))) \\<longrightarrow>\n       x \\<notin> dom (Cp a)", "case (Cons a p)"], ["proof (state)\nthis:\n  a \\<in> set p \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<notin> dom (Cp a)\n\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       a \\<in> set p \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       x \\<notin> dom (Cp a) \\<Longrightarrow>\n       a \\<in> set (aa # p) \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy (aa # p))) \\<longrightarrow>\n       x \\<notin> dom (Cp a)", "then"], ["proof (chain)\npicking this:\n  a \\<in> set p \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<notin> dom (Cp a)", "show ?case"], ["proof (prove)\nusing this:\n  a \\<in> set p \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<notin> dom (Cp a)\n\ngoal (1 subgoal):\n 1. a \\<in> set (a # p) \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n    x \\<notin> dom (Cp a)", "apply (simp_all,intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> set p \\<longrightarrow>\n             x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<notin> dom (Cp a);\n     a \\<in> set p \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n     x \\<notin> dom (Cp a);\n     a = a; x \\<notin> dom (Cp (list2FWpolicy (a # p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp a)\n 2. \\<lbrakk>a \\<in> set p \\<longrightarrow>\n             x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<notin> dom (Cp a);\n     a \\<in> set p \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n     x \\<notin> dom (Cp a);\n     a \\<in> set p; x \\<notin> dom (Cp (list2FWpolicy (a # p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp a)", "apply (metis CConcStartA)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> set p \\<longrightarrow>\n             x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<notin> dom (Cp a);\n     a \\<in> set p \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n     x \\<notin> dom (Cp a);\n     a \\<in> set p; x \\<notin> dom (Cp (list2FWpolicy (a # p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<notin> dom (Cp a);\n     a \\<in> set p; x \\<notin> dom (Cp (list2FWpolicy (a # p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp a)", "apply (metis Cdom2 List.set_simps(2) domIff insert_absorb list.simps(2) list2FWpolicyconc set_empty)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a \\<in> set (a # p) \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n  x \\<notin> dom (Cp a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_rd[rule_format]: \n  \"p \\<noteq> [] \\<Longrightarrow> Cp (list2FWpolicy (remdups p)) = Cp (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    Cp (list2FWpolicy (remdups p)) = Cp (list2FWpolicy p)", "proof (rule ext, induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       [] \\<noteq> [] \\<Longrightarrow>\n       Cp (list2FWpolicy (remdups [])) x = Cp (list2FWpolicy []) x\n 2. \\<And>a p x.\n       \\<lbrakk>\\<And>x.\n                   p \\<noteq> [] \\<Longrightarrow>\n                   Cp (list2FWpolicy (remdups p)) x =\n                   Cp (list2FWpolicy p) x;\n        a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy (remdups (a # p))) x =\n                         Cp (list2FWpolicy (a # p)) x", "case Nil"], ["proof (state)\nthis:\n  [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       [] \\<noteq> [] \\<Longrightarrow>\n       Cp (list2FWpolicy (remdups [])) x = Cp (list2FWpolicy []) x\n 2. \\<And>a p x.\n       \\<lbrakk>\\<And>x.\n                   p \\<noteq> [] \\<Longrightarrow>\n                   Cp (list2FWpolicy (remdups p)) x =\n                   Cp (list2FWpolicy p) x;\n        a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy (remdups (a # p))) x =\n                         Cp (list2FWpolicy (a # p)) x", "thus ?case"], ["proof (prove)\nusing this:\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (remdups [])) x = Cp (list2FWpolicy []) x", "by simp"], ["proof (state)\nthis:\n  Cp (list2FWpolicy (remdups [])) x = Cp (list2FWpolicy []) x\n\ngoal (1 subgoal):\n 1. \\<And>a p x.\n       \\<lbrakk>\\<And>x.\n                   p \\<noteq> [] \\<Longrightarrow>\n                   Cp (list2FWpolicy (remdups p)) x =\n                   Cp (list2FWpolicy p) x;\n        a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy (remdups (a # p))) x =\n                         Cp (list2FWpolicy (a # p)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p x.\n       \\<lbrakk>\\<And>x.\n                   p \\<noteq> [] \\<Longrightarrow>\n                   Cp (list2FWpolicy (remdups p)) x =\n                   Cp (list2FWpolicy p) x;\n        a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy (remdups (a # p))) x =\n                         Cp (list2FWpolicy (a # p)) x", "case (Cons y ys)"], ["proof (state)\nthis:\n  ys \\<noteq> [] \\<Longrightarrow>\n  Cp (list2FWpolicy (remdups ys)) ?x = Cp (list2FWpolicy ys) ?x\n  y # ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a p x.\n       \\<lbrakk>\\<And>x.\n                   p \\<noteq> [] \\<Longrightarrow>\n                   Cp (list2FWpolicy (remdups p)) x =\n                   Cp (list2FWpolicy p) x;\n        a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy (remdups (a # p))) x =\n                         Cp (list2FWpolicy (a # p)) x", "thus ?case"], ["proof (prove)\nusing this:\n  ys \\<noteq> [] \\<Longrightarrow>\n  Cp (list2FWpolicy (remdups ys)) ?x = Cp (list2FWpolicy ys) ?x\n  y # ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (remdups (y # ys))) x = Cp (list2FWpolicy (y # ys)) x", "proof (cases \"ys = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                ys \\<noteq> [] \\<Longrightarrow>\n                Cp (list2FWpolicy (remdups ys)) x = Cp (list2FWpolicy ys) x;\n     y # ys \\<noteq> []; ys = []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (remdups (y # ys))) x =\n                      Cp (list2FWpolicy (y # ys)) x\n 2. \\<lbrakk>\\<And>x.\n                ys \\<noteq> [] \\<Longrightarrow>\n                Cp (list2FWpolicy (remdups ys)) x = Cp (list2FWpolicy ys) x;\n     y # ys \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (remdups (y # ys))) x =\n                      Cp (list2FWpolicy (y # ys)) x", "case True"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                ys \\<noteq> [] \\<Longrightarrow>\n                Cp (list2FWpolicy (remdups ys)) x = Cp (list2FWpolicy ys) x;\n     y # ys \\<noteq> []; ys = []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (remdups (y # ys))) x =\n                      Cp (list2FWpolicy (y # ys)) x\n 2. \\<lbrakk>\\<And>x.\n                ys \\<noteq> [] \\<Longrightarrow>\n                Cp (list2FWpolicy (remdups ys)) x = Cp (list2FWpolicy ys) x;\n     y # ys \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (remdups (y # ys))) x =\n                      Cp (list2FWpolicy (y # ys)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys = []\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (remdups (y # ys))) x = Cp (list2FWpolicy (y # ys)) x", "by simp"], ["proof (state)\nthis:\n  Cp (list2FWpolicy (remdups (y # ys))) x = Cp (list2FWpolicy (y # ys)) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                ys \\<noteq> [] \\<Longrightarrow>\n                Cp (list2FWpolicy (remdups ys)) x = Cp (list2FWpolicy ys) x;\n     y # ys \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (remdups (y # ys))) x =\n                      Cp (list2FWpolicy (y # ys)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                ys \\<noteq> [] \\<Longrightarrow>\n                Cp (list2FWpolicy (remdups ys)) x = Cp (list2FWpolicy ys) x;\n     y # ys \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (remdups (y # ys))) x =\n                      Cp (list2FWpolicy (y # ys)) x", "case False"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                ys \\<noteq> [] \\<Longrightarrow>\n                Cp (list2FWpolicy (remdups ys)) x = Cp (list2FWpolicy ys) x;\n     y # ys \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (remdups (y # ys))) x =\n                      Cp (list2FWpolicy (y # ys)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (remdups (y # ys))) x = Cp (list2FWpolicy (y # ys)) x", "using Cons"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  ys \\<noteq> [] \\<Longrightarrow>\n  Cp (list2FWpolicy (remdups ys)) ?x = Cp (list2FWpolicy ys) ?x\n  y # ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (remdups (y # ys))) x = Cp (list2FWpolicy (y # ys)) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x.\n        Cp (list2FWpolicy (remdups ys)) x = Cp (list2FWpolicy ys) x\\<rbrakk>\n    \\<Longrightarrow> (y \\<in> set ys \\<longrightarrow>\n                       Cp (list2FWpolicy ys) x =\n                       Cp (list2FWpolicy (y # ys)) x) \\<and>\n                      (y \\<notin> set ys \\<longrightarrow>\n                       Cp (list2FWpolicy (y # remdups ys)) x =\n                       Cp (list2FWpolicy (y # ys)) x)", "apply (intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. Cp (list2FWpolicy (remdups ys)) x = Cp (list2FWpolicy ys) x;\n     y \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy ys) x =\n                      Cp (list2FWpolicy (y # ys)) x\n 2. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. Cp (list2FWpolicy (remdups ys)) x = Cp (list2FWpolicy ys) x;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # remdups ys)) x =\n                      Cp (list2FWpolicy (y # ys)) x", "apply (metis Cdom2 nlpaux notindom domIff l2p_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys \\<noteq> [];\n     \\<And>x. Cp (list2FWpolicy (remdups ys)) x = Cp (list2FWpolicy ys) x;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # remdups ys)) x =\n                      Cp (list2FWpolicy (y # ys)) x", "by (metis (no_types, lifting) Cdom2 nlpaux domIff l2p_aux remDupsNMT)"], ["proof (state)\nthis:\n  Cp (list2FWpolicy (remdups (y # ys))) x = Cp (list2FWpolicy (y # ys)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Cp (list2FWpolicy (remdups (y # ys))) x = Cp (list2FWpolicy (y # ys)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nMT_domMT: \n  \"\\<not> not_MT Cp  p \\<Longrightarrow> p \\<noteq> [] \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> not_MT Cp p; p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy p))", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> not_MT Cp []; [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy []))\n 2. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>\\<not> not_MT Cp p; p \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy p));\n        \\<not> not_MT Cp (a # p); a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy (a # p)))", "case Nil"], ["proof (state)\nthis:\n  \\<not> not_MT Cp []\n  [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> not_MT Cp []; [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy []))\n 2. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>\\<not> not_MT Cp p; p \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy p));\n        \\<not> not_MT Cp (a # p); a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy (a # p)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> not_MT Cp []\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. r \\<notin> dom (Cp (list2FWpolicy []))", "by simp"], ["proof (state)\nthis:\n  r \\<notin> dom (Cp (list2FWpolicy []))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>\\<not> not_MT Cp p; p \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy p));\n        \\<not> not_MT Cp (a # p); a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy (a # p)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>\\<not> not_MT Cp p; p \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy p));\n        \\<not> not_MT Cp (a # p); a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy (a # p)))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> not_MT Cp xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy xs))\n  \\<not> not_MT Cp (x # xs)\n  x # xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>\\<not> not_MT Cp p; p \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy p));\n        \\<not> not_MT Cp (a # p); a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy (a # p)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> not_MT Cp xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy xs))\n  \\<not> not_MT Cp (x # xs)\n  x # xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. r \\<notin> dom (Cp (list2FWpolicy (x # xs)))", "apply (simp split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n             r \\<notin> dom (Cp (list2FWpolicy xs));\n     dom (Cp x) = {}; \\<not> not_MT Cp xs\\<rbrakk>\n    \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy (x # xs)))", "apply (cases \"xs = []\",simp_all )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<notin> dom (Cp (list2FWpolicy xs)); dom (Cp x) = {};\n     \\<not> not_MT Cp xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> r \\<notin> dom (Cp (list2FWpolicy (x # xs)))", "by (metis CconcNone domIff)"], ["proof (state)\nthis:\n  r \\<notin> dom (Cp (list2FWpolicy (x # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_RS3_aux[rule_format]: \n  \"not_MT Cp  p \\<Longrightarrow>  Cp (list2FWpolicy p) x = Cp (list2FWpolicy (rm_MT_rules Cp p)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_MT Cp p \\<Longrightarrow>\n    Cp (list2FWpolicy p) x = Cp (list2FWpolicy (rm_MT_rules Cp p)) x", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. not_MT Cp [] \\<Longrightarrow>\n    Cp (list2FWpolicy []) x = Cp (list2FWpolicy (rm_MT_rules Cp [])) x\n 2. \\<And>a p.\n       \\<lbrakk>not_MT Cp p \\<Longrightarrow>\n                Cp (list2FWpolicy p) x =\n                Cp (list2FWpolicy (rm_MT_rules Cp p)) x;\n        not_MT Cp (a # p)\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy (a # p)) x =\n                         Cp (list2FWpolicy (rm_MT_rules Cp (a # p))) x", "case Nil"], ["proof (state)\nthis:\n  not_MT Cp []\n\ngoal (2 subgoals):\n 1. not_MT Cp [] \\<Longrightarrow>\n    Cp (list2FWpolicy []) x = Cp (list2FWpolicy (rm_MT_rules Cp [])) x\n 2. \\<And>a p.\n       \\<lbrakk>not_MT Cp p \\<Longrightarrow>\n                Cp (list2FWpolicy p) x =\n                Cp (list2FWpolicy (rm_MT_rules Cp p)) x;\n        not_MT Cp (a # p)\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy (a # p)) x =\n                         Cp (list2FWpolicy (rm_MT_rules Cp (a # p))) x", "thus ?case"], ["proof (prove)\nusing this:\n  not_MT Cp []\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy []) x = Cp (list2FWpolicy (rm_MT_rules Cp [])) x", "by simp"], ["proof (state)\nthis:\n  Cp (list2FWpolicy []) x = Cp (list2FWpolicy (rm_MT_rules Cp [])) x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>not_MT Cp p \\<Longrightarrow>\n                Cp (list2FWpolicy p) x =\n                Cp (list2FWpolicy (rm_MT_rules Cp p)) x;\n        not_MT Cp (a # p)\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy (a # p)) x =\n                         Cp (list2FWpolicy (rm_MT_rules Cp (a # p))) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>not_MT Cp p \\<Longrightarrow>\n                Cp (list2FWpolicy p) x =\n                Cp (list2FWpolicy (rm_MT_rules Cp p)) x;\n        not_MT Cp (a # p)\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy (a # p)) x =\n                         Cp (list2FWpolicy (rm_MT_rules Cp (a # p))) x", "case (Cons y ys)"], ["proof (state)\nthis:\n  not_MT Cp ys \\<Longrightarrow>\n  Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x\n  not_MT Cp (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>not_MT Cp p \\<Longrightarrow>\n                Cp (list2FWpolicy p) x =\n                Cp (list2FWpolicy (rm_MT_rules Cp p)) x;\n        not_MT Cp (a # p)\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy (a # p)) x =\n                         Cp (list2FWpolicy (rm_MT_rules Cp (a # p))) x", "thus ?case"], ["proof (prove)\nusing this:\n  not_MT Cp ys \\<Longrightarrow>\n  Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x\n  not_MT Cp (y # ys)\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (y # ys)) x =\n    Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "proof (cases \"not_MT Cp  ys\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>not_MT Cp ys \\<Longrightarrow>\n             Cp (list2FWpolicy ys) x =\n             Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     not_MT Cp (y # ys); not_MT Cp ys\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x\n 2. \\<lbrakk>not_MT Cp ys \\<Longrightarrow>\n             Cp (list2FWpolicy ys) x =\n             Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     not_MT Cp (y # ys); \\<not> not_MT Cp ys\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "case True"], ["proof (state)\nthis:\n  not_MT Cp ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>not_MT Cp ys \\<Longrightarrow>\n             Cp (list2FWpolicy ys) x =\n             Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     not_MT Cp (y # ys); not_MT Cp ys\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x\n 2. \\<lbrakk>not_MT Cp ys \\<Longrightarrow>\n             Cp (list2FWpolicy ys) x =\n             Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     not_MT Cp (y # ys); \\<not> not_MT Cp ys\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  not_MT Cp ys\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (y # ys)) x =\n    Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "using Cons"], ["proof (prove)\nusing this:\n  not_MT Cp ys\n  not_MT Cp ys \\<Longrightarrow>\n  Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x\n  not_MT Cp (y # ys)\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (y # ys)) x =\n    Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>not_MT Cp ys;\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     if dom (Cp y) = {} then not_MT Cp ys else True\\<rbrakk>\n    \\<Longrightarrow> (dom (Cp y) = {} \\<longrightarrow>\n                       Cp (list2FWpolicy (y # ys)) x =\n                       Cp (list2FWpolicy (rm_MT_rules Cp ys)) x) \\<and>\n                      (dom (Cp y) \\<noteq> {} \\<longrightarrow>\n                       Cp (list2FWpolicy (y # ys)) x =\n                       Cp (list2FWpolicy (y # rm_MT_rules Cp ys)) x)", "apply (intro conjI impI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Cp (list2FWpolicy ys) x =\n             Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     not_MT Cp ys; dom (Cp y) = {}\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (rm_MT_rules Cp ys)) x\n 2. \\<lbrakk>not_MT Cp ys;\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     if dom (Cp y) = {} then not_MT Cp ys else True;\n     dom (Cp y) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (y # rm_MT_rules Cp ys)) x", "apply (metis CconcNone True not_MTimpnotMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>not_MT Cp ys;\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     if dom (Cp y) = {} then not_MT Cp ys else True;\n     dom (Cp y) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (y # rm_MT_rules Cp ys)) x", "apply (cases \"x \\<in> dom (Cp (list2FWpolicy ys))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>not_MT Cp ys;\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     if dom (Cp y) = {} then not_MT Cp ys else True; dom (Cp y) \\<noteq> {};\n     x \\<in> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (y # rm_MT_rules Cp ys)) x\n 2. \\<lbrakk>not_MT Cp ys;\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     if dom (Cp y) = {} then not_MT Cp ys else True; dom (Cp y) \\<noteq> {};\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (y # rm_MT_rules Cp ys)) x", "apply (subgoal_tac \"x \\<in> dom (Cp (list2FWpolicy (rm_MT_rules Cp ys)))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>not_MT Cp ys;\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     if dom (Cp y) = {} then not_MT Cp ys else True; dom (Cp y) \\<noteq> {};\n     x \\<in> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (list2FWpolicy (rm_MT_rules Cp ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (y # rm_MT_rules Cp ys)) x\n 2. \\<lbrakk>not_MT Cp ys;\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     if dom (Cp y) = {} then not_MT Cp ys else True; dom (Cp y) \\<noteq> {};\n     x \\<in> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (rm_MT_rules Cp ys)))\n 3. \\<lbrakk>not_MT Cp ys;\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     if dom (Cp y) = {} then not_MT Cp ys else True; dom (Cp y) \\<noteq> {};\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (y # rm_MT_rules Cp ys)) x", "apply (metis (mono_tags) Cons_eq_appendI NMPrm CeqEnd append_Nil not_MTimpnotMT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>not_MT Cp ys;\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     if dom (Cp y) = {} then not_MT Cp ys else True; dom (Cp y) \\<noteq> {};\n     x \\<in> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (rm_MT_rules Cp ys)))\n 2. \\<lbrakk>not_MT Cp ys;\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     if dom (Cp y) = {} then not_MT Cp ys else True; dom (Cp y) \\<noteq> {};\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (y # rm_MT_rules Cp ys)) x", "apply (simp add: domIff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>not_MT Cp ys;\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     if dom (Cp y) = {} then not_MT Cp ys else True; dom (Cp y) \\<noteq> {};\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (y # rm_MT_rules Cp ys)) x", "apply (subgoal_tac \"x \\<notin>  dom (Cp (list2FWpolicy (rm_MT_rules Cp ys)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>not_MT Cp ys;\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     if dom (Cp y) = {} then not_MT Cp ys else True; dom (Cp y) \\<noteq> {};\n     x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<notin> dom (Cp (list2FWpolicy (rm_MT_rules Cp ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (y # rm_MT_rules Cp ys)) x\n 2. \\<lbrakk>not_MT Cp ys;\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     if dom (Cp y) = {} then not_MT Cp ys else True; dom (Cp y) \\<noteq> {};\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp\n (list2FWpolicy (rm_MT_rules Cp ys)))", "apply (metis l2p_aux l2p_aux2 nlpaux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>not_MT Cp ys;\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     if dom (Cp y) = {} then not_MT Cp ys else True; dom (Cp y) \\<noteq> {};\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp\n (list2FWpolicy (rm_MT_rules Cp ys)))", "by (metis domIff)"], ["proof (state)\nthis:\n  Cp (list2FWpolicy (y # ys)) x =\n  Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>not_MT Cp ys \\<Longrightarrow>\n             Cp (list2FWpolicy ys) x =\n             Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     not_MT Cp (y # ys); \\<not> not_MT Cp ys\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>not_MT Cp ys \\<Longrightarrow>\n             Cp (list2FWpolicy ys) x =\n             Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     not_MT Cp (y # ys); \\<not> not_MT Cp ys\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "case False"], ["proof (state)\nthis:\n  \\<not> not_MT Cp ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>not_MT Cp ys \\<Longrightarrow>\n             Cp (list2FWpolicy ys) x =\n             Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     not_MT Cp (y # ys); \\<not> not_MT Cp ys\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> not_MT Cp ys\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (y # ys)) x =\n    Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "using Cons False"], ["proof (prove)\nusing this:\n  \\<not> not_MT Cp ys\n  not_MT Cp ys \\<Longrightarrow>\n  Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x\n  not_MT Cp (y # ys)\n  \\<not> not_MT Cp ys\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (y # ys)) x =\n    Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "proof (cases \"ys = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> not_MT Cp ys;\n     not_MT Cp ys \\<Longrightarrow>\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     not_MT Cp (y # ys); \\<not> not_MT Cp ys; ys = []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x\n 2. \\<lbrakk>\\<not> not_MT Cp ys;\n     not_MT Cp ys \\<Longrightarrow>\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     not_MT Cp (y # ys); \\<not> not_MT Cp ys; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "case True"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> not_MT Cp ys;\n     not_MT Cp ys \\<Longrightarrow>\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     not_MT Cp (y # ys); \\<not> not_MT Cp ys; ys = []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x\n 2. \\<lbrakk>\\<not> not_MT Cp ys;\n     not_MT Cp ys \\<Longrightarrow>\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     not_MT Cp (y # ys); \\<not> not_MT Cp ys; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys = []\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (y # ys)) x =\n    Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "using Cons"], ["proof (prove)\nusing this:\n  ys = []\n  not_MT Cp ys \\<Longrightarrow>\n  Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x\n  not_MT Cp (y # ys)\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (y # ys)) x =\n    Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "by (simp) (rule impI, simp)"], ["proof (state)\nthis:\n  Cp (list2FWpolicy (y # ys)) x =\n  Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> not_MT Cp ys;\n     not_MT Cp ys \\<Longrightarrow>\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     not_MT Cp (y # ys); \\<not> not_MT Cp ys; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> not_MT Cp ys;\n     not_MT Cp ys \\<Longrightarrow>\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     not_MT Cp (y # ys); \\<not> not_MT Cp ys; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "case False"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> not_MT Cp ys;\n     not_MT Cp ys \\<Longrightarrow>\n     Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x;\n     not_MT Cp (y # ys); \\<not> not_MT Cp ys; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (y # ys)) x =\n    Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "using Cons False \\<open>\\<not> not_MT Cp ys\\<close>"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  not_MT Cp ys \\<Longrightarrow>\n  Cp (list2FWpolicy ys) x = Cp (list2FWpolicy (rm_MT_rules Cp ys)) x\n  not_MT Cp (y # ys)\n  ys \\<noteq> []\n  \\<not> not_MT Cp ys\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (y # ys)) x =\n    Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if dom (Cp y) = {} then not_MT Cp ys else True; ys \\<noteq> [];\n     \\<not> not_MT Cp ys\\<rbrakk>\n    \\<Longrightarrow> (dom (Cp y) = {} \\<longrightarrow>\n                       Cp (list2FWpolicy (y # ys)) x =\n                       Cp (list2FWpolicy (rm_MT_rules Cp ys)) x) \\<and>\n                      (dom (Cp y) \\<noteq> {} \\<longrightarrow>\n                       Cp (list2FWpolicy (y # ys)) x =\n                       Cp (list2FWpolicy (y # rm_MT_rules Cp ys)) x)", "apply (intro conjI impI| simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys \\<noteq> []; \\<not> not_MT Cp ys;\n     dom (Cp y) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (y # rm_MT_rules Cp ys)) x", "apply (subgoal_tac \"rm_MT_rules Cp ys = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ys \\<noteq> []; \\<not> not_MT Cp ys; dom (Cp y) \\<noteq> {};\n     rm_MT_rules Cp ys = []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (y # rm_MT_rules Cp ys)) x\n 2. \\<lbrakk>ys \\<noteq> []; \\<not> not_MT Cp ys;\n     dom (Cp y) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> rm_MT_rules Cp ys = []", "apply (subgoal_tac \"x \\<notin> dom (Cp (list2FWpolicy ys))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ys \\<noteq> []; \\<not> not_MT Cp ys; dom (Cp y) \\<noteq> {};\n     rm_MT_rules Cp ys = []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x =\n                      Cp (list2FWpolicy (y # rm_MT_rules Cp ys)) x\n 2. \\<lbrakk>ys \\<noteq> []; \\<not> not_MT Cp ys; dom (Cp y) \\<noteq> {};\n     rm_MT_rules Cp ys = []\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp (list2FWpolicy ys))\n 3. \\<lbrakk>ys \\<noteq> []; \\<not> not_MT Cp ys;\n     dom (Cp y) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> rm_MT_rules Cp ys = []", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ys \\<noteq> []; \\<not> not_MT Cp ys; dom (Cp y) \\<noteq> {};\n     rm_MT_rules Cp ys = []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (y # ys)) x = Cp y x\n 2. \\<lbrakk>ys \\<noteq> []; \\<not> not_MT Cp ys; dom (Cp y) \\<noteq> {};\n     rm_MT_rules Cp ys = []\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp (list2FWpolicy ys))\n 3. \\<lbrakk>ys \\<noteq> []; \\<not> not_MT Cp ys;\n     dom (Cp y) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> rm_MT_rules Cp ys = []", "apply (metis l2p_aux nlpaux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ys \\<noteq> []; \\<not> not_MT Cp ys; dom (Cp y) \\<noteq> {};\n     rm_MT_rules Cp ys = []\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp (list2FWpolicy ys))\n 2. \\<lbrakk>ys \\<noteq> []; \\<not> not_MT Cp ys;\n     dom (Cp y) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> rm_MT_rules Cp ys = []", "apply (erule nMT_domMT, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys \\<noteq> []; \\<not> not_MT Cp ys;\n     dom (Cp y) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> rm_MT_rules Cp ys = []", "by (metis SR3nMT)"], ["proof (state)\nthis:\n  Cp (list2FWpolicy (y # ys)) x =\n  Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Cp (list2FWpolicy (y # ys)) x =\n  Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Cp (list2FWpolicy (y # ys)) x =\n  Cp (list2FWpolicy (rm_MT_rules Cp (y # ys))) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_id: \n  \"wellformed_policy1_strong p \\<Longrightarrow> Cp(list2FWpolicy (insertDeny p)) = Cp (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_policy1_strong p \\<Longrightarrow>\n    Cp (list2FWpolicy (insertDeny p)) = Cp (list2FWpolicy p)", "by (rule ext) (metis insertDeny.simps(1) wp1n_tl)"], ["", "lemma C_eq_RS3: \n  \"not_MT Cp  p \\<Longrightarrow>  Cp(list2FWpolicy (rm_MT_rules Cp p)) = Cp (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_MT Cp p \\<Longrightarrow>\n    Cp (list2FWpolicy (rm_MT_rules Cp p)) = Cp (list2FWpolicy p)", "by (rule ext) (erule C_eq_RS3_aux[symmetric])"], ["", "lemma NMPrd[rule_format]: \"not_MT Cp  p \\<longrightarrow> not_MT Cp  (remdups p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_MT Cp p \\<longrightarrow> not_MT Cp (remdups p)", "by (induct p, simp_all) (auto simp: NMPcharn)"], ["", "lemma NMPDA[rule_format]: \"DenyAll \\<in> set p \\<longrightarrow> not_MT Cp  p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set p \\<longrightarrow> not_MT Cp p", "by (induct p, simp_all add: DAnMT)"], ["", "lemma NMPiD[rule_format]: \"not_MT Cp  (insertDeny p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_MT Cp (insertDeny p)", "by (insert DAiniD [of p]) (erule NMPDA)"], ["", "lemma list2FWpolicy2list[rule_format]: \n  \"Cp (list2FWpolicy(policy2list p)) = (Cp p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy (policy2list p)) = Cp p", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. Cp (list2FWpolicy (policy2list p)) x = Cp p x", "apply (induct_tac p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>Cp (list2FWpolicy (policy2list x1)) x = Cp x1 x;\n        Cp (list2FWpolicy (policy2list x2)) x = Cp x2 x\\<rbrakk>\n       \\<Longrightarrow> Cp (list2FWpolicy\n                              (policy2list x1 @ policy2list x2))\n                          x =\n                         Cp (x1 \\<oplus> x2) x", "subgoal for x x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Cp (list2FWpolicy (policy2list x1)) x = Cp x1 x;\n     Cp (list2FWpolicy (policy2list x2)) x = Cp x2 x\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (policy2list x1 @ policy2list x2))\n                       x =\n                      Cp (x1 \\<oplus> x2) x", "apply (case_tac \"x \\<in> dom (Cp (x2))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Cp (list2FWpolicy (policy2list x1)) x = Cp x1 x;\n     Cp (list2FWpolicy (policy2list x2)) x = Cp x2 x;\n     x \\<in> dom (Cp x2)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (policy2list x1 @ policy2list x2))\n                       x =\n                      Cp (x1 \\<oplus> x2) x\n 2. \\<lbrakk>Cp (list2FWpolicy (policy2list x1)) x = Cp x1 x;\n     Cp (list2FWpolicy (policy2list x2)) x = Cp x2 x;\n     x \\<notin> dom (Cp x2)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (policy2list x1 @ policy2list x2))\n                       x =\n                      Cp (x1 \\<oplus> x2) x", "apply (metis Cdom2 CeqEnd domIff p2lNmt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Cp (list2FWpolicy (policy2list x1)) x = Cp x1 x;\n     Cp (list2FWpolicy (policy2list x2)) x = Cp x2 x;\n     x \\<notin> dom (Cp x2)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (policy2list x1 @ policy2list x2))\n                       x =\n                      Cp (x1 \\<oplus> x2) x", "apply (metis CeqStart domIff p2lNmt nlpaux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas C_eq_Lemmas = none_MT_rulesRS2 none_MT_rulesrd  SCp2l wp1n_RS2  wp1ID NMPiD waux2\n                     wp1alternative_RS1 p2lNmt list2FWpolicy2list wellformed_policy3_charn  wp1_eq"], ["", "lemmas C_eq_subst_Lemmas = C_eq_sorted C_eq_sortedQ C_eq_RS2 C_eq_rd C_eq_RS3 C_eq_id"], ["", "lemma C_eq_All_untilSorted: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n    Cp(list2FWpolicy (sort (removeShadowRules2 (remdups (rm_MT_rules Cp (insertDeny \n                           (removeShadowRules1 (policy2list p)))))) l)) = \n    Cp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (FWNormalisationCore.sort\n                             (removeShadowRules2\n                               (remdups\n                                 (rm_MT_rules Cp\n                                   (insertDeny\n                                     (removeShadowRules1\n (policy2list p))))))\n                             l)) =\n                      Cp p", "apply (subst C_eq_sorted,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (removeShadowRules2\n                             (remdups\n                               (rm_MT_rules Cp\n                                 (insertDeny\n                                   (removeShadowRules1\n                                     (policy2list p))))))) =\n                      Cp p", "apply (subst C_eq_RS2,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (remdups\n                             (rm_MT_rules Cp\n                               (insertDeny\n                                 (removeShadowRules1 (policy2list p)))))) =\n                      Cp p", "apply (subst C_eq_rd,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (rm_MT_rules Cp\n                             (insertDeny\n                               (removeShadowRules1 (policy2list p))))) =\n                      Cp p", "apply (subst C_eq_RS3,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (insertDeny\n                             (removeShadowRules1 (policy2list p)))) =\n                      Cp p", "apply (subst C_eq_id,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_eq_All_untilSortedQ: \n  \"DenyAll\\<in> set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n    Cp(list2FWpolicy (qsort (removeShadowRules2 (remdups (rm_MT_rules Cp (insertDeny \n                            (removeShadowRules1 (policy2list p)))))) l)) = \n    Cp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (qsort\n                             (removeShadowRules2\n                               (remdups\n                                 (rm_MT_rules Cp\n                                   (insertDeny\n                                     (removeShadowRules1\n (policy2list p))))))\n                             l)) =\n                      Cp p", "apply (subst C_eq_sortedQ,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (removeShadowRules2\n                             (remdups\n                               (rm_MT_rules Cp\n                                 (insertDeny\n                                   (removeShadowRules1\n                                     (policy2list p))))))) =\n                      Cp p", "apply (subst C_eq_RS2,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (remdups\n                             (rm_MT_rules Cp\n                               (insertDeny\n                                 (removeShadowRules1 (policy2list p)))))) =\n                      Cp p", "apply (subst C_eq_rd,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (rm_MT_rules Cp\n                             (insertDeny\n                               (removeShadowRules1 (policy2list p))))) =\n                      Cp p", "apply (subst C_eq_RS3,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (insertDeny\n                             (removeShadowRules1 (policy2list p)))) =\n                      Cp p", "apply (subst C_eq_id,simp_all add: C_eq_Lemmas)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_eq_All_untilSorted_withSimps: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow>  all_in_list (policy2list p) l \\<Longrightarrow>\n allNetsDistinct (policy2list p) \\<Longrightarrow>\n Cp(list2FWpolicy(sort(removeShadowRules2(remdups(rm_MT_rules Cp (insertDeny\n                      (removeShadowRules1(policy2list p)))))) l)) = \n Cp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (FWNormalisationCore.sort\n                             (removeShadowRules2\n                               (remdups\n                                 (rm_MT_rules Cp\n                                   (insertDeny\n                                     (removeShadowRules1\n (policy2list p))))))\n                             l)) =\n                      Cp p", "by (simp_all add: C_eq_Lemmas C_eq_subst_Lemmas)"], ["", "lemma C_eq_All_untilSorted_withSimpsQ: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow>  all_in_list (policy2list p) l \\<Longrightarrow>\n allNetsDistinct (policy2list p) \\<Longrightarrow>\n Cp(list2FWpolicy(qsort(removeShadowRules2(remdups(rm_MT_rules Cp (insertDeny\n                       (removeShadowRules1  (policy2list p)))))) l)) = \n Cp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (qsort\n                             (removeShadowRules2\n                               (remdups\n                                 (rm_MT_rules Cp\n                                   (insertDeny\n                                     (removeShadowRules1\n (policy2list p))))))\n                             l)) =\n                      Cp p", "by (simp_all add: C_eq_Lemmas C_eq_subst_Lemmas)"], ["", "lemma InDomConc[rule_format]: \"p \\<noteq> [] \\<longrightarrow> x \\<in> dom (Cp (list2FWpolicy (p))) \\<longrightarrow>\n                               x \\<in>  dom (Cp (list2FWpolicy (a#p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (a # p)))", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<Longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (aa # p))) \\<longrightarrow>\n       x \\<in> dom (Cp (a \\<oplus> list2FWpolicy (aa # p)))", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<Longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n    x \\<in> dom (Cp (a \\<oplus> list2FWpolicy (a # p)))", "apply(case_tac \"p = []\",simp_all add: dom_def Cp.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_in_member[rule_format]: \"member a b \\<longrightarrow> x \\<notin> dom (Cp b) \\<longrightarrow> x \\<notin> dom (Cp a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member a b \\<longrightarrow>\n    x \\<notin> dom (Cp b) \\<longrightarrow> x \\<notin> dom (Cp a)", "by (induct b)(simp_all add: dom_def Cp.simps)"], ["", "lemma src_in_sdnets[rule_format]: \n  \"\\<not> member DenyAll x \\<longrightarrow> p \\<in> dom (Cp x) \\<longrightarrow> subnetsOfAdr (src p) \\<inter> (fst_set (sdnets x)) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> member DenyAll x \\<longrightarrow>\n    p \\<in> dom (Cp x) \\<longrightarrow>\n    subnetsOfAdr (src p) \\<inter> fst_set (sdnets x) \\<noteq> {}", "apply (induct rule: Combinators.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<not> member DenyAll DenyAll \\<longrightarrow>\n    p \\<in> dom (Cp DenyAll) \\<longrightarrow>\n    subnetsOfAdr (src p) \\<inter> fst_set (sdnets DenyAll) \\<noteq> {}\n 2. \\<And>x1 x2.\n       \\<not> member DenyAll (DenyAllFromTo x1 x2) \\<longrightarrow>\n       p \\<in> dom (Cp (DenyAllFromTo x1 x2)) \\<longrightarrow>\n       subnetsOfAdr (src p) \\<inter>\n       fst_set (sdnets (DenyAllFromTo x1 x2)) \\<noteq>\n       {}\n 3. \\<And>x1 x2 x3.\n       \\<not> member DenyAll (AllowPortFromTo x1 x2 x3) \\<longrightarrow>\n       p \\<in> dom (Cp (AllowPortFromTo x1 x2 x3)) \\<longrightarrow>\n       subnetsOfAdr (src p) \\<inter>\n       fst_set (sdnets (AllowPortFromTo x1 x2 x3)) \\<noteq>\n       {}\n 4. \\<And>x1 x2.\n       \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n                p \\<in> dom (Cp x1) \\<longrightarrow>\n                subnetsOfAdr (src p) \\<inter> fst_set (sdnets x1) \\<noteq>\n                {};\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        p \\<in> dom (Cp x2) \\<longrightarrow>\n        subnetsOfAdr (src p) \\<inter> fst_set (sdnets x2) \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> member DenyAll\n                                 (x1 \\<oplus> x2) \\<longrightarrow>\n                         p \\<in> dom (Cp (x1 \\<oplus> x2)) \\<longrightarrow>\n                         subnetsOfAdr (src p) \\<inter>\n                         fst_set (sdnets (x1 \\<oplus> x2)) \\<noteq>\n                         {}", "apply (simp_all add: fst_set_def subnetsOfAdr_def PLemmas, rename_tac x1 x2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n                (\\<exists>y.\n                    Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n                {};\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n        {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n        {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> member DenyAll x1 \\<and>\n                         \\<not> member DenyAll x2 \\<longrightarrow>\n                         (\\<exists>y.\n                             (case Cp x2 p of\n                              \\<bottom> \\<Rightarrow> Cp x1 p\n                              | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                                  \\<lfloor>x\\<rfloor>) =\n                             \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                         {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                         {a. \\<exists>b.\n                                (a, b) \\<in> sdnets x1 \\<or>\n                                (a, b) \\<in> sdnets x2} \\<noteq>\n                         {}", "apply (intro impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n                (\\<exists>y.\n                    Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n                {};\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n        {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n        {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n        {};\n        \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n        \\<exists>y.\n           (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n            | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n           \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                         {a. \\<exists>b.\n                                (a, b) \\<in> sdnets x1 \\<or>\n                                (a, b) \\<in> sdnets x2} \\<noteq>\n                         {}", "apply (simp add: fst_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(\\<exists>y.\n                    Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                {x. \\<exists>x\\<in>x. fst (snd p) \\<in> x} \\<inter>\n                {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n                {};\n        (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n        {x. \\<exists>x\\<in>x. fst (snd p) \\<in> x} \\<inter>\n        {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n        {};\n        \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n        \\<exists>y.\n           (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n            | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n           \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                         {a. \\<exists>b.\n                                (a, b) \\<in> sdnets x1 \\<or>\n                                (a, b) \\<in> sdnets x2} \\<noteq>\n                         {}", "subgoal for x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>y. Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd p) \\<in> x} \\<inter>\n             {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd p) \\<in> x} \\<inter>\n     {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                      {a. \\<exists>b.\n                             (a, b) \\<in> sdnets x1 \\<or>\n                             (a, b) \\<in> sdnets x2} \\<noteq>\n                      {}", "apply (case_tac \"p \\<in> dom (Cp x2)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<exists>y. Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd p) \\<in> x} \\<inter>\n             {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd p) \\<in> x} \\<inter>\n     {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<in> dom (Cp x2)\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                      {a. \\<exists>b.\n                             (a, b) \\<in> sdnets x1 \\<or>\n                             (a, b) \\<in> sdnets x2} \\<noteq>\n                      {}\n 2. \\<lbrakk>(\\<exists>y. Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd p) \\<in> x} \\<inter>\n             {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd p) \\<in> x} \\<inter>\n     {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<notin> dom (Cp x2)\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                      {a. \\<exists>b.\n                             (a, b) \\<in> sdnets x1 \\<or>\n                             (a, b) \\<in> sdnets x2} \\<noteq>\n                      {}", "apply (rule subnetAux)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(\\<exists>y. Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd p) \\<in> x} \\<inter>\n             {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd p) \\<in> x} \\<inter>\n     {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<in> dom (Cp x2)\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                      ?A1 \\<noteq>\n                      {}\n 2. \\<lbrakk>(\\<exists>y. Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd p) \\<in> x} \\<inter>\n             {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd p) \\<in> x} \\<inter>\n     {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<in> dom (Cp x2)\\<rbrakk>\n    \\<Longrightarrow> ?A1\n                      \\<subseteq> {a. \\<exists>b.\n   (a, b) \\<in> sdnets x1 \\<or> (a, b) \\<in> sdnets x2}\n 3. \\<lbrakk>(\\<exists>y. Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd p) \\<in> x} \\<inter>\n             {a. \\<exists>b. (a, b) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd p) \\<in> x} \\<inter>\n     {a. \\<exists>b. (a, b) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<notin> dom (Cp x2)\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x. fst (snd p) \\<in> s} \\<inter>\n                      {a. \\<exists>b.\n                             (a, b) \\<in> sdnets x1 \\<or>\n                             (a, b) \\<in> sdnets x2} \\<noteq>\n                      {}", "apply (auto simp: PLemmas)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dest_in_sdnets[rule_format]: \n  \"\\<not> member DenyAll x \\<longrightarrow> p \\<in> dom (Cp x) \\<longrightarrow> subnetsOfAdr (dest p) \\<inter> (snd_set (sdnets x)) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> member DenyAll x \\<longrightarrow>\n    p \\<in> dom (Cp x) \\<longrightarrow>\n    subnetsOfAdr (dest p) \\<inter> snd_set (sdnets x) \\<noteq> {}", "apply (induct rule: Combinators.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<not> member DenyAll DenyAll \\<longrightarrow>\n    p \\<in> dom (Cp DenyAll) \\<longrightarrow>\n    subnetsOfAdr (dest p) \\<inter> snd_set (sdnets DenyAll) \\<noteq> {}\n 2. \\<And>x1 x2.\n       \\<not> member DenyAll (DenyAllFromTo x1 x2) \\<longrightarrow>\n       p \\<in> dom (Cp (DenyAllFromTo x1 x2)) \\<longrightarrow>\n       subnetsOfAdr (dest p) \\<inter>\n       snd_set (sdnets (DenyAllFromTo x1 x2)) \\<noteq>\n       {}\n 3. \\<And>x1 x2 x3.\n       \\<not> member DenyAll (AllowPortFromTo x1 x2 x3) \\<longrightarrow>\n       p \\<in> dom (Cp (AllowPortFromTo x1 x2 x3)) \\<longrightarrow>\n       subnetsOfAdr (dest p) \\<inter>\n       snd_set (sdnets (AllowPortFromTo x1 x2 x3)) \\<noteq>\n       {}\n 4. \\<And>x1 x2.\n       \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n                p \\<in> dom (Cp x1) \\<longrightarrow>\n                subnetsOfAdr (dest p) \\<inter> snd_set (sdnets x1) \\<noteq>\n                {};\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        p \\<in> dom (Cp x2) \\<longrightarrow>\n        subnetsOfAdr (dest p) \\<inter> snd_set (sdnets x2) \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> member DenyAll\n                                 (x1 \\<oplus> x2) \\<longrightarrow>\n                         p \\<in> dom (Cp (x1 \\<oplus> x2)) \\<longrightarrow>\n                         subnetsOfAdr (dest p) \\<inter>\n                         snd_set (sdnets (x1 \\<oplus> x2)) \\<noteq>\n                         {}", "apply (simp_all add: snd_set_def subnetsOfAdr_def PLemmas, rename_tac x1 x2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<not> member DenyAll x1 \\<longrightarrow>\n                (\\<exists>y.\n                    Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                {x. \\<exists>s\\<in>x. fst (snd (snd p)) \\<in> s} \\<inter>\n                {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n                {};\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n        {x. \\<exists>s\\<in>x. fst (snd (snd p)) \\<in> s} \\<inter>\n        {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> member DenyAll x1 \\<and>\n                         \\<not> member DenyAll x2 \\<longrightarrow>\n                         (\\<exists>y.\n                             (case Cp x2 p of\n                              \\<bottom> \\<Rightarrow> Cp x1 p\n                              | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                                  \\<lfloor>x\\<rfloor>) =\n                             \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                         {x. \\<exists>s\\<in>x.\n                                fst (snd (snd p)) \\<in> s} \\<inter>\n                         {a. \\<exists>b.\n                                (b, a) \\<in> sdnets x1 \\<or>\n                                (b, a) \\<in> sdnets x2} \\<noteq>\n                         {}", "apply (intro impI,simp add: snd_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(\\<exists>y.\n                    Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n                {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n                {};\n        (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n        {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n        {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n        {};\n        \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n        \\<exists>y.\n           (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n            | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n           \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> {x. \\<exists>s\\<in>x.\n                                fst (snd (snd p)) \\<in> s} \\<inter>\n                         {a. \\<exists>b.\n                                (b, a) \\<in> sdnets x1 \\<or>\n                                (b, a) \\<in> sdnets x2} \\<noteq>\n                         {}", "subgoal for x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>y. Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n             {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n     {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x.\n                             fst (snd (snd p)) \\<in> s} \\<inter>\n                      {a. \\<exists>b.\n                             (b, a) \\<in> sdnets x1 \\<or>\n                             (b, a) \\<in> sdnets x2} \\<noteq>\n                      {}", "apply (case_tac \"p \\<in> dom (Cp x2)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<exists>y. Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n             {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n     {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<in> dom (Cp x2)\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x.\n                             fst (snd (snd p)) \\<in> s} \\<inter>\n                      {a. \\<exists>b.\n                             (b, a) \\<in> sdnets x1 \\<or>\n                             (b, a) \\<in> sdnets x2} \\<noteq>\n                      {}\n 2. \\<lbrakk>(\\<exists>y. Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n             {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n     {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<notin> dom (Cp x2)\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x.\n                             fst (snd (snd p)) \\<in> s} \\<inter>\n                      {a. \\<exists>b.\n                             (b, a) \\<in> sdnets x1 \\<or>\n                             (b, a) \\<in> sdnets x2} \\<noteq>\n                      {}", "apply (rule subnetAux)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(\\<exists>y. Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n             {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n     {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<in> dom (Cp x2)\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x.\n                             fst (snd (snd p)) \\<in> s} \\<inter>\n                      ?A1 \\<noteq>\n                      {}\n 2. \\<lbrakk>(\\<exists>y. Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n             {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n     {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<in> dom (Cp x2)\\<rbrakk>\n    \\<Longrightarrow> ?A1\n                      \\<subseteq> {a. \\<exists>b.\n   (b, a) \\<in> sdnets x1 \\<or> (b, a) \\<in> sdnets x2}\n 3. \\<lbrakk>(\\<exists>y. Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n             {a. \\<exists>b. (b, a) \\<in> sdnets x1} \\<noteq>\n             {};\n     (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     {x. \\<exists>x\\<in>x. fst (snd (snd p)) \\<in> x} \\<inter>\n     {a. \\<exists>b. (b, a) \\<in> sdnets x2} \\<noteq>\n     {};\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     \\<exists>y.\n        (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     p \\<notin> dom (Cp x2)\\<rbrakk>\n    \\<Longrightarrow> {x. \\<exists>s\\<in>x.\n                             fst (snd (snd p)) \\<in> s} \\<inter>\n                      {a. \\<exists>b.\n                             (b, a) \\<in> sdnets x1 \\<or>\n                             (b, a) \\<in> sdnets x2} \\<noteq>\n                      {}", "apply (auto simp: PLemmas)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sdnets_in_subnets[rule_format]: \n  \"p\\<in> dom (Cp x) \\<longrightarrow> \\<not> member DenyAll x \\<longrightarrow>\n   (\\<exists> (a,b)\\<in>sdnets x. a \\<in> subnetsOfAdr (src p) \\<and> b \\<in> subnetsOfAdr (dest p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> dom (Cp x) \\<longrightarrow>\n    \\<not> member DenyAll x \\<longrightarrow>\n    (\\<exists>(a, b)\\<in>sdnets x.\n        a \\<in> subnetsOfAdr (src p) \\<and> b \\<in> subnetsOfAdr (dest p))", "apply (rule Combinators.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. p \\<in> dom (Cp DenyAll) \\<longrightarrow>\n    \\<not> member DenyAll DenyAll \\<longrightarrow>\n    (\\<exists>a\\<in>sdnets DenyAll.\n        case a of\n        (a, b) \\<Rightarrow>\n          a \\<in> subnetsOfAdr (src p) \\<and> b \\<in> subnetsOfAdr (dest p))\n 2. \\<And>x1 x2.\n       p \\<in> dom (Cp (DenyAllFromTo x1 x2)) \\<longrightarrow>\n       \\<not> member DenyAll (DenyAllFromTo x1 x2) \\<longrightarrow>\n       (\\<exists>a\\<in>sdnets (DenyAllFromTo x1 x2).\n           case a of\n           (a, b) \\<Rightarrow>\n             a \\<in> subnetsOfAdr (src p) \\<and>\n             b \\<in> subnetsOfAdr (dest p))\n 3. \\<And>x1 x2 x3.\n       p \\<in> dom (Cp (AllowPortFromTo x1 x2 x3)) \\<longrightarrow>\n       \\<not> member DenyAll (AllowPortFromTo x1 x2 x3) \\<longrightarrow>\n       (\\<exists>a\\<in>sdnets (AllowPortFromTo x1 x2 x3).\n           case a of\n           (a, b) \\<Rightarrow>\n             a \\<in> subnetsOfAdr (src p) \\<and>\n             b \\<in> subnetsOfAdr (dest p))\n 4. \\<And>x1 x2.\n       \\<lbrakk>p \\<in> dom (Cp x1) \\<longrightarrow>\n                \\<not> member DenyAll x1 \\<longrightarrow>\n                (\\<exists>a\\<in>sdnets x1.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      a \\<in> subnetsOfAdr (src p) \\<and>\n                      b \\<in> subnetsOfAdr (dest p));\n        p \\<in> dom (Cp x2) \\<longrightarrow>\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        (\\<exists>a\\<in>sdnets x2.\n            case a of\n            (a, b) \\<Rightarrow>\n              a \\<in> subnetsOfAdr (src p) \\<and>\n              b \\<in> subnetsOfAdr (dest p))\\<rbrakk>\n       \\<Longrightarrow> p \\<in> dom (Cp (x1 \\<oplus> x2)) \\<longrightarrow>\n                         \\<not> member DenyAll\n                                 (x1 \\<oplus> x2) \\<longrightarrow>\n                         (\\<exists>a\\<in>sdnets (x1 \\<oplus> x2).\n                             case a of\n                             (a, b) \\<Rightarrow>\n                               a \\<in> subnetsOfAdr (src p) \\<and>\n                               b \\<in> subnetsOfAdr (dest p))", "apply (simp_all add: PLemmas subnetsOfAdr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(\\<exists>y.\n                    Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                \\<not> member DenyAll x1 \\<longrightarrow>\n                (\\<exists>x\\<in>sdnets x1.\n                    case x of\n                    (a, b) \\<Rightarrow>\n                      (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                      (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n        (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n        \\<not> member DenyAll x2 \\<longrightarrow>\n        (\\<exists>x\\<in>sdnets x2.\n            case x of\n            (a, b) \\<Rightarrow>\n              (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n              (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y.\n                             (case Cp x2 p of\n                              \\<bottom> \\<Rightarrow> Cp x1 p\n                              | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                                  \\<lfloor>x\\<rfloor>) =\n                             \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                         \\<not> member DenyAll x1 \\<and>\n                         \\<not> member DenyAll x2 \\<longrightarrow>\n                         (\\<exists>x\\<in>sdnets x1 \\<union> sdnets x2.\n                             case x of\n                             (a, b) \\<Rightarrow>\n                               (\\<exists>x\\<in>a.\n                                   fst (snd p) \\<in> x) \\<and>\n                               (\\<exists>x\\<in>b.\n                                   fst (snd (snd p)) \\<in> x))", "apply (intro impI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(\\<exists>y.\n                    Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                (\\<exists>x\\<in>sdnets x1.\n                    case x of\n                    (a, b) \\<Rightarrow>\n                      (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                      (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n        (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n        (\\<exists>x\\<in>sdnets x2.\n            case x of\n            (a, b) \\<Rightarrow>\n              (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n              (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n        \\<exists>y.\n           (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n            | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n           \\<lfloor>y\\<rfloor>;\n        \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>sdnets x1 \\<union> sdnets x2.\n                            case x of\n                            (a, b) \\<Rightarrow>\n                              (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                              (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x)", "subgoal for x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>y. Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             (\\<exists>x\\<in>sdnets x1.\n                 case x of\n                 (a, b) \\<Rightarrow>\n                   (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                   (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n     (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     (\\<exists>x\\<in>sdnets x2.\n         case x of\n         (a, b) \\<Rightarrow>\n           (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n           (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n     \\<exists>y.\n        (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>sdnets x1 \\<union> sdnets x2.\n                         case x of\n                         (a, b) \\<Rightarrow>\n                           (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                           (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x)", "apply (case_tac \"p \\<in> dom (Cp (x2))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<exists>y. Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             (\\<exists>x\\<in>sdnets x1.\n                 case x of\n                 (a, b) \\<Rightarrow>\n                   (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                   (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n     (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     (\\<exists>x\\<in>sdnets x2.\n         case x of\n         (a, b) \\<Rightarrow>\n           (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n           (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n     \\<exists>y.\n        (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     p \\<in> dom (Cp x2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>sdnets x1 \\<union> sdnets x2.\n                         case x of\n                         (a, b) \\<Rightarrow>\n                           (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                           (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x)\n 2. \\<lbrakk>(\\<exists>y. Cp x1 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n             (\\<exists>x\\<in>sdnets x1.\n                 case x of\n                 (a, b) \\<Rightarrow>\n                   (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                   (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n     (\\<exists>y. Cp x2 p = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n     (\\<exists>x\\<in>sdnets x2.\n         case x of\n         (a, b) \\<Rightarrow>\n           (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n           (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x));\n     \\<exists>y.\n        (case Cp x2 p of \\<bottom> \\<Rightarrow> Cp x1 p\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow> \\<lfloor>x\\<rfloor>) =\n        \\<lfloor>y\\<rfloor>;\n     \\<not> member DenyAll x1 \\<and> \\<not> member DenyAll x2;\n     p \\<notin> dom (Cp x2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>sdnets x1 \\<union> sdnets x2.\n                         case x of\n                         (a, b) \\<Rightarrow>\n                           (\\<exists>x\\<in>a. fst (snd p) \\<in> x) \\<and>\n                           (\\<exists>x\\<in>b. fst (snd (snd p)) \\<in> x)", "apply (auto simp: PLemmas subnetsOfAdr_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma disjSD_no_p_in_both[rule_format]:   \n  \"\\<lbrakk>disjSD_2 x y; \\<not> member DenyAll x; \\<not> member DenyAll y;  \n   p \\<in> dom (Cp x); p \\<in> dom (Cp y)\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>disjSD_2 x y; \\<not> member DenyAll x; \\<not> member DenyAll y;\n     p \\<in> dom (Cp x); p \\<in> dom (Cp y)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule_tac A = \"sdnets x\" and B = \"sdnets y\" and D = \"src p\" and F = \"dest p\" in tndFalse)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>disjSD_2 x y; \\<not> member DenyAll x; \\<not> member DenyAll y;\n     p \\<in> dom (Cp x); p \\<in> dom (Cp y)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b c d.\n                         (a, b) \\<in> sdnets x \\<and>\n                         (c, d) \\<in> sdnets y \\<longrightarrow>\n                         twoNetsDistinct a b c d\n 2. \\<lbrakk>disjSD_2 x y; \\<not> member DenyAll x; \\<not> member DenyAll y;\n     p \\<in> dom (Cp x); p \\<in> dom (Cp y)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(a, b)\\<in>sdnets x.\n                         a \\<in> subnetsOfAdr (src p) \\<and>\n                         b \\<in> subnetsOfAdr (dest p)\n 3. \\<lbrakk>disjSD_2 x y; \\<not> member DenyAll x; \\<not> member DenyAll y;\n     p \\<in> dom (Cp x); p \\<in> dom (Cp y)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(a, b)\\<in>sdnets y.\n                         a \\<in> subnetsOfAdr (src p) \\<and>\n                         b \\<in> subnetsOfAdr (dest p)", "by (auto simp: dest_in_sdnets src_in_sdnets sdnets_in_subnets disjSD_2_def)"], ["", "lemma list2FWpolicy_eq: \n  \"zs \\<noteq> [] \\<Longrightarrow> Cp (list2FWpolicy (x \\<oplus> y # z)) p = Cp (x \\<oplus> list2FWpolicy (y # z)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zs \\<noteq> [] \\<Longrightarrow>\n    Cp (list2FWpolicy (x \\<oplus> y # z)) p =\n    Cp (x \\<oplus> list2FWpolicy (y # z)) p", "by (metis ConcAssoc l2p_aux list2FWpolicy.simps(2))"], ["", "lemma dom_sep[rule_format]: \n  \"x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow> x \\<in> dom (Cp (list2FWpolicy(separate p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (separate p)))", "proof (induct p rule: separate.induct,simp_all, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (DenyAllFromTo v va \\<oplus> y #\n                                   z))) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (separate\n                                    (DenyAllFromTo v va \\<oplus> y # z))));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (DenyAllFromTo v va # separate (y # z)))))\n 2. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (AllowPortFromTo v va vb \\<oplus> y #\n                                   z))) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (separate\n                                    (AllowPortFromTo v va vb \\<oplus> y #\n                                     z))));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy\n    (separate (AllowPortFromTo v va vb \\<oplus> y # z))))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (AllowPortFromTo v va vb # separate (y # z)))))\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  ((v \\<oplus> va) \\<oplus> y #\n                                   z))) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (separate\n                                    ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "case (1 v va y z)"], ["proof (state)\nthis:\n  {v, va} = first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    (DenyAllFromTo v va \\<oplus> y # z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    (separate (DenyAllFromTo v va \\<oplus> y # z))))\n  {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\n\ngoal (3 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (DenyAllFromTo v va \\<oplus> y #\n                                   z))) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (separate\n                                    (DenyAllFromTo v va \\<oplus> y # z))));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (DenyAllFromTo v va # separate (y # z)))))\n 2. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (AllowPortFromTo v va vb \\<oplus> y #\n                                   z))) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (separate\n                                    (AllowPortFromTo v va vb \\<oplus> y #\n                                     z))));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy\n    (separate (AllowPortFromTo v va vb \\<oplus> y # z))))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (AllowPortFromTo v va vb # separate (y # z)))))\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  ((v \\<oplus> va) \\<oplus> y #\n                                   z))) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (separate\n                                    ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "then"], ["proof (chain)\npicking this:\n  {v, va} = first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    (DenyAllFromTo v va \\<oplus> y # z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    (separate (DenyAllFromTo v va \\<oplus> y # z))))\n  {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))", "show ?case"], ["proof (prove)\nusing this:\n  {v, va} = first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    (DenyAllFromTo v va \\<oplus> y # z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    (separate (DenyAllFromTo v va \\<oplus> y # z))))\n  {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\n\ngoal (1 subgoal):\n 1. ({v, va} = first_bothNet y \\<longrightarrow>\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus>\n                      list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         (DenyAllFromTo v va \\<oplus> y # z))))) \\<and>\n    ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus>\n                      list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo v va # separate (y # z)))))", "apply (intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (DenyAllFromTo v va \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 (DenyAllFromTo v va \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} = first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate (DenyAllFromTo v va \\<oplus> y # z))))\n 2. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (DenyAllFromTo v va \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 (DenyAllFromTo v va \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va # separate (y # z))))", "apply (simp,drule mp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va \\<oplus> y # z)))\n 2. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         (DenyAllFromTo v va \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate (DenyAllFromTo v va \\<oplus> y # z))))\n 3. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (DenyAllFromTo v va \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 (DenyAllFromTo v va \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va # separate (y # z))))", "apply (case_tac \"x \\<in> dom (Cp (DenyAllFromTo v va))\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (DenyAllFromTo v va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va \\<oplus> y # z)))\n 2. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (DenyAllFromTo v va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va \\<oplus> y # z)))\n 3. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         (DenyAllFromTo v va \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate (DenyAllFromTo v va \\<oplus> y # z))))\n 4. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (DenyAllFromTo v va \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 (DenyAllFromTo v va \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va # separate (y # z))))", "apply (metis CConcStartA domIff l2p_aux2 list2FWpolicyconc not_Cons_self )"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (DenyAllFromTo v va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va \\<oplus> y # z)))\n 2. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         (DenyAllFromTo v va \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate (DenyAllFromTo v va \\<oplus> y # z))))\n 3. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (DenyAllFromTo v va \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 (DenyAllFromTo v va \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va # separate (y # z))))", "apply (subgoal_tac \"x \\<in> dom (Cp (list2FWpolicy (y #z)))\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (DenyAllFromTo v va));\n     x \\<in> dom (Cp (list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va \\<oplus> y # z)))\n 2. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (DenyAllFromTo v va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))\n 3. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         (DenyAllFromTo v va \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate (DenyAllFromTo v va \\<oplus> y # z))))\n 4. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (DenyAllFromTo v va \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 (DenyAllFromTo v va \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va # separate (y # z))))", "apply (metis CConcStartA Cdom2 domIff l2p_aux2 list2FWpolicyconc nlpaux)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (DenyAllFromTo v va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))\n 2. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         (DenyAllFromTo v va \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate (DenyAllFromTo v va \\<oplus> y # z))))\n 3. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (DenyAllFromTo v va \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 (DenyAllFromTo v va \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va # separate (y # z))))", "apply (subgoal_tac \"x \\<in> dom (Cp (list2FWpolicy ((DenyAllFromTo v va)#y#z)))\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (DenyAllFromTo v va));\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo v va # y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))\n 2. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (DenyAllFromTo v va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va # y # z)))\n 3. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         (DenyAllFromTo v va \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate (DenyAllFromTo v va \\<oplus> y # z))))\n 4. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (DenyAllFromTo v va \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 (DenyAllFromTo v va \\<oplus> y # z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va # separate (y # z))))", "apply (simp add: dom_def Cp.simps,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va # separate (y # z))))", "apply (case_tac \"x \\<in> dom (Cp (DenyAllFromTo v va))\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (DenyAllFromTo v va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va # separate (y # z))))", "apply (subgoal_tac \"x \\<in> dom (Cp (list2FWpolicy (y #z)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (DenyAllFromTo v va));\n     x \\<in> dom (Cp (list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va # separate (y # z))))\n 2. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (DenyAllFromTo v va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))", "apply (metis InDomConc sepnMT list.simps(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (DenyAllFromTo v va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))", "apply (subgoal_tac \"x \\<in> dom (Cp (list2FWpolicy ((DenyAllFromTo v va)#y#z)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (DenyAllFromTo v va));\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo v va # y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))\n 2. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (DenyAllFromTo v va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo v va # y # z)))", "by (simp_all add: dom_def Cp.simps)"], ["proof (state)\nthis:\n  ({v, va} = first_bothNet y \\<longrightarrow>\n   x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus>\n                    list2FWpolicy (y # z))) \\<longrightarrow>\n   x \\<in> dom (Cp (list2FWpolicy\n                     (separate\n                       (DenyAllFromTo v va \\<oplus> y # z))))) \\<and>\n  ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n   x \\<in> dom (Cp (DenyAllFromTo v va \\<oplus>\n                    list2FWpolicy (y # z))) \\<longrightarrow>\n   x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo v va # separate (y # z)))))\n\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (AllowPortFromTo v va vb \\<oplus> y #\n                                   z))) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (separate\n                                    (AllowPortFromTo v va vb \\<oplus> y #\n                                     z))));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy\n    (separate (AllowPortFromTo v va vb \\<oplus> y # z))))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (AllowPortFromTo v va vb # separate (y # z)))))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  ((v \\<oplus> va) \\<oplus> y #\n                                   z))) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (separate\n                                    ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (AllowPortFromTo v va vb \\<oplus> y #\n                                   z))) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (separate\n                                    (AllowPortFromTo v va vb \\<oplus> y #\n                                     z))));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy\n    (separate (AllowPortFromTo v va vb \\<oplus> y # z))))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (AllowPortFromTo v va vb # separate (y # z)))))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  ((v \\<oplus> va) \\<oplus> y #\n                                   z))) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (separate\n                                    ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "case (2 v va vb y z)"], ["proof (state)\nthis:\n  {v, va} = first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    (AllowPortFromTo v va vb \\<oplus> y #\n                     z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    (separate (AllowPortFromTo v va vb \\<oplus> y # z))))\n  {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\n\ngoal (2 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (AllowPortFromTo v va vb \\<oplus> y #\n                                   z))) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (separate\n                                    (AllowPortFromTo v va vb \\<oplus> y #\n                                     z))));\n        {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy\n    (separate (AllowPortFromTo v va vb \\<oplus> y # z))))) \\<and>\n                         ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (AllowPortFromTo v va vb \\<oplus>\n   list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (AllowPortFromTo v va vb # separate (y # z)))))\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  ((v \\<oplus> va) \\<oplus> y #\n                                   z))) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (separate\n                                    ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "then"], ["proof (chain)\npicking this:\n  {v, va} = first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    (AllowPortFromTo v va vb \\<oplus> y #\n                     z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    (separate (AllowPortFromTo v va vb \\<oplus> y # z))))\n  {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))", "show ?case"], ["proof (prove)\nusing this:\n  {v, va} = first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    (AllowPortFromTo v va vb \\<oplus> y #\n                     z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    (separate (AllowPortFromTo v va vb \\<oplus> y # z))))\n  {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\n\ngoal (1 subgoal):\n 1. ({v, va} = first_bothNet y \\<longrightarrow>\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         (AllowPortFromTo v va vb \\<oplus> y # z))))) \\<and>\n    ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy\n                       (AllowPortFromTo v va vb # separate (y # z)))))", "apply (intro impI conjI,simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (AllowPortFromTo v va vb \\<oplus> y #\n                        z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         (AllowPortFromTo v va vb \\<oplus> y #\n                          z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate (AllowPortFromTo v va vb \\<oplus> y # z))))\n 2. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (AllowPortFromTo v va vb \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 (AllowPortFromTo v va vb \\<oplus> y #\n                                  z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (AllowPortFromTo v va vb # separate (y # z))))", "apply (case_tac \"x \\<in> dom (Cp (AllowPortFromTo v va vb))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (AllowPortFromTo v va vb \\<oplus> y #\n                        z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         (AllowPortFromTo v va vb \\<oplus> y # z))));\n     x \\<in> dom (Cp (AllowPortFromTo v va vb))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate (AllowPortFromTo v va vb \\<oplus> y # z))))\n 2. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (AllowPortFromTo v va vb \\<oplus> y #\n                        z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         (AllowPortFromTo v va vb \\<oplus> y # z))));\n     x \\<notin> dom (Cp (AllowPortFromTo v va vb))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate (AllowPortFromTo v va vb \\<oplus> y # z))))\n 3. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (AllowPortFromTo v va vb \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 (AllowPortFromTo v va vb \\<oplus> y #\n                                  z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (AllowPortFromTo v va vb # separate (y # z))))", "apply (metis CConcStartA domIff  l2p_aux2 list2FWpolicyconc not_Cons_self )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (AllowPortFromTo v va vb \\<oplus> y #\n                        z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         (AllowPortFromTo v va vb \\<oplus> y # z))));\n     x \\<notin> dom (Cp (AllowPortFromTo v va vb))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate (AllowPortFromTo v va vb \\<oplus> y # z))))\n 2. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (AllowPortFromTo v va vb \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 (AllowPortFromTo v va vb \\<oplus> y #\n                                  z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (AllowPortFromTo v va vb # separate (y # z))))", "apply (subgoal_tac \"x \\<in> dom (Cp (list2FWpolicy (y #z)))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (AllowPortFromTo v va vb \\<oplus> y #\n                        z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         (AllowPortFromTo v va vb \\<oplus> y # z))));\n     x \\<notin> dom (Cp (AllowPortFromTo v va vb));\n     x \\<in> dom (Cp (list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate (AllowPortFromTo v va vb \\<oplus> y # z))))\n 2. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (AllowPortFromTo v va vb \\<oplus> y #\n                        z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         (AllowPortFromTo v va vb \\<oplus> y # z))));\n     x \\<notin> dom (Cp (AllowPortFromTo v va vb))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))\n 3. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (AllowPortFromTo v va vb \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 (AllowPortFromTo v va vb \\<oplus> y #\n                                  z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (AllowPortFromTo v va vb # separate (y # z))))", "apply (metis CConcStartA Cdom2 InDomConc domIff l2p_aux2 list2FWpolicyconc nlpaux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{v, va} = first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (AllowPortFromTo v va vb \\<oplus> y #\n                        z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         (AllowPortFromTo v va vb \\<oplus> y # z))));\n     x \\<notin> dom (Cp (AllowPortFromTo v va vb))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))\n 2. \\<lbrakk>{v, va} = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (AllowPortFromTo v va vb \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 (AllowPortFromTo v va vb \\<oplus> y #\n                                  z))));\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (AllowPortFromTo v va vb # separate (y # z))))", "apply (simp add: dom_def Cp.simps, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (AllowPortFromTo v va vb # separate (y # z))))", "apply (case_tac \"x \\<in> dom (Cp (AllowPortFromTo v va vb))\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (AllowPortFromTo v va vb))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (AllowPortFromTo v va vb # separate (y # z))))", "apply (subgoal_tac \"x \\<in> dom (Cp (list2FWpolicy (y #z)))\",simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (AllowPortFromTo v va vb));\n     x \\<in> dom (Cp (list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (AllowPortFromTo v va vb # separate (y # z))))\n 2. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (AllowPortFromTo v va vb))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))", "apply (metis Conc_not_MT InDomConc sepnMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     {v, va} \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                      list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (AllowPortFromTo v va vb))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))", "apply (metis domIff nlpaux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ({v, va} = first_bothNet y \\<longrightarrow>\n   x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                    list2FWpolicy (y # z))) \\<longrightarrow>\n   x \\<in> dom (Cp (list2FWpolicy\n                     (separate\n                       (AllowPortFromTo v va vb \\<oplus> y # z))))) \\<and>\n  ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n   x \\<in> dom (Cp (AllowPortFromTo v va vb \\<oplus>\n                    list2FWpolicy (y # z))) \\<longrightarrow>\n   x \\<in> dom (Cp (list2FWpolicy\n                     (AllowPortFromTo v va vb # separate (y # z)))))\n\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  ((v \\<oplus> va) \\<oplus> y #\n                                   z))) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (separate\n                                    ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  ((v \\<oplus> va) \\<oplus> y #\n                                   z))) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (separate\n                                    ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "case (3 v va y z)"], ["proof (state)\nthis:\n  first_bothNet v = first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    ((v \\<oplus> va) \\<oplus> y # z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    (separate ((v \\<oplus> va) \\<oplus> y # z))))\n  first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\n\ngoal (1 subgoal):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  ((v \\<oplus> va) \\<oplus> y #\n                                   z))) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (separate\n                                    ((v \\<oplus> va) \\<oplus> y # z))));\n        first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n       \\<Longrightarrow> (first_bothNet v =\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n                         (first_bothNet v \\<noteq>\n                          first_bothNet y \\<longrightarrow>\n                          x \\<in> dom (Cp\n  ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))) \\<longrightarrow>\n                          x \\<in> dom (Cp\n  (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "then"], ["proof (chain)\npicking this:\n  first_bothNet v = first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    ((v \\<oplus> va) \\<oplus> y # z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    (separate ((v \\<oplus> va) \\<oplus> y # z))))\n  first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))", "show ?case"], ["proof (prove)\nusing this:\n  first_bothNet v = first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    ((v \\<oplus> va) \\<oplus> y # z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy\n                    (separate ((v \\<oplus> va) \\<oplus> y # z))))\n  first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\n\ngoal (1 subgoal):\n 1. (first_bothNet v = first_bothNet y \\<longrightarrow>\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus>\n                      list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n    (first_bothNet v \\<noteq> first_bothNet y \\<longrightarrow>\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus>\n                      list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (v \\<oplus> va # separate (y # z)))))", "apply (intro conjI impI,simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       ((v \\<oplus> va) \\<oplus> y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         ((v \\<oplus> va) \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate ((v \\<oplus> va) \\<oplus> y # z))))\n 2. \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               ((v \\<oplus> va) \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 ((v \\<oplus> va) \\<oplus> y # z))));\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     first_bothNet v \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (v \\<oplus> va # separate (y # z))))", "apply (drule mp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  ((v \\<oplus> va) \\<oplus> y # z)))\n 2. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         ((v \\<oplus> va) \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate ((v \\<oplus> va) \\<oplus> y # z))))\n 3. \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               ((v \\<oplus> va) \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 ((v \\<oplus> va) \\<oplus> y # z))));\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     first_bothNet v \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (v \\<oplus> va # separate (y # z))))", "apply (case_tac \"x \\<in> dom (Cp ((v \\<oplus> va)))\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  ((v \\<oplus> va) \\<oplus> y # z)))\n 2. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  ((v \\<oplus> va) \\<oplus> y # z)))\n 3. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         ((v \\<oplus> va) \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate ((v \\<oplus> va) \\<oplus> y # z))))\n 4. \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               ((v \\<oplus> va) \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 ((v \\<oplus> va) \\<oplus> y # z))));\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     first_bothNet v \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (v \\<oplus> va # separate (y # z))))", "apply (metis Cp.simps(4) CConcStartA ConcAssoc domIff list2FWpolicy2list list2FWpolicyconc p2lNmt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  ((v \\<oplus> va) \\<oplus> y # z)))\n 2. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         ((v \\<oplus> va) \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate ((v \\<oplus> va) \\<oplus> y # z))))\n 3. \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               ((v \\<oplus> va) \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 ((v \\<oplus> va) \\<oplus> y # z))));\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     first_bothNet v \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (v \\<oplus> va # separate (y # z))))", "defer 1"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (separate\n                         ((v \\<oplus> va) \\<oplus> y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (separate ((v \\<oplus> va) \\<oplus> y # z))))\n 2. \\<lbrakk>first_bothNet v = first_bothNet y \\<Longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               ((v \\<oplus> va) \\<oplus> y #\n                                z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (separate\n                                 ((v \\<oplus> va) \\<oplus> y # z))));\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     first_bothNet v \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (v \\<oplus> va # separate (y # z))))\n 3. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  ((v \\<oplus> va) \\<oplus> y # z)))", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     first_bothNet v \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus>\n                      list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (v \\<oplus> va # separate (y # z))))\n 2. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  ((v \\<oplus> va) \\<oplus> y # z)))", "apply (case_tac \"x \\<in> dom (Cp ((v \\<oplus> va)))\",simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (y # z))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (separate (y # z))));\n     first_bothNet v \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (v \\<oplus> va # separate (y # z))))\n 2. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  ((v \\<oplus> va) \\<oplus> y # z)))", "apply (drule mp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_bothNet v \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))\n 2. \\<lbrakk>first_bothNet v \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va));\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (v \\<oplus> va # separate (y # z))))\n 3. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  ((v \\<oplus> va) \\<oplus> y # z)))", "apply (simp add: Cp.simps dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>first_bothNet v \\<noteq> first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va));\n     x \\<in> dom (Cp (list2FWpolicy (separate (y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (v \\<oplus> va # separate (y # z))))\n 2. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  ((v \\<oplus> va) \\<oplus> y # z)))", "apply (metis InDomConc list.simps(2)sepnMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  ((v \\<oplus> va) \\<oplus> y # z)))", "apply (subgoal_tac \"x \\<in> dom (Cp (list2FWpolicy (y#z)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va));\n     x \\<in> dom (Cp (list2FWpolicy (y # z)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  ((v \\<oplus> va) \\<oplus> y # z)))\n 2. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))", "apply (case_tac \"x \\<in> dom (Cp y)\",simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va)); x \\<in> dom (Cp y)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  ((v \\<oplus> va) \\<oplus> y # z)))\n 2. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va));\n     x \\<in> dom (Cp (list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp y)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  ((v \\<oplus> va) \\<oplus> y # z)))\n 3. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))", "apply (metis CConcStartA Cdom2 ConcAssoc domIff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va));\n     x \\<in> dom (Cp (list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp y)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  ((v \\<oplus> va) \\<oplus> y # z)))\n 2. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))", "apply (metis InDomConc domIff l2p_aux2 list2FWpolicyconc nlpaux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))", "apply (case_tac \"x \\<in> dom (Cp y)\",simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>first_bothNet v = first_bothNet y;\n     x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z)));\n     x \\<notin> dom (Cp (v \\<oplus> va)); x \\<notin> dom (Cp y)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))", "by (metis domIff nlpaux)"], ["proof (state)\nthis:\n  (first_bothNet v = first_bothNet y \\<longrightarrow>\n   x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus>\n                    list2FWpolicy (y # z))) \\<longrightarrow>\n   x \\<in> dom (Cp (list2FWpolicy\n                     (separate ((v \\<oplus> va) \\<oplus> y # z))))) \\<and>\n  (first_bothNet v \\<noteq> first_bothNet y \\<longrightarrow>\n   x \\<in> dom (Cp ((v \\<oplus> va) \\<oplus>\n                    list2FWpolicy (y # z))) \\<longrightarrow>\n   x \\<in> dom (Cp (list2FWpolicy (v \\<oplus> va # separate (y # z)))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma domdConcStart[rule_format]: \n  \"x \\<in> dom (Cp (list2FWpolicy (a#b))) \\<longrightarrow> x \\<notin> dom (Cp (list2FWpolicy b)) \\<longrightarrow> x \\<in> dom (Cp (a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (list2FWpolicy (a # b))) \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy b)) \\<longrightarrow>\n    x \\<in> dom (Cp a)", "by (induct b, simp_all) (auto simp: PLemmas)"], ["", "lemma sep_dom2_aux: \n  \"x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> y # z))) \\<Longrightarrow> x \\<in> dom (Cp (a \\<oplus> list2FWpolicy (y # z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> y # z))) \\<Longrightarrow>\n    x \\<in> dom (Cp (a \\<oplus> list2FWpolicy (y # z)))", "by auto (metis list2FWpolicy_eq p2lNmt)"], ["", "lemma sep_dom2_aux2: \n  \"(x \\<in> dom (Cp (list2FWpolicy (separate (y # z)))) \\<longrightarrow> x \\<in> dom (Cp (list2FWpolicy (y # z)))) \\<Longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (a # separate (y # z)))) \\<Longrightarrow> \n  x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> y # z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy\n                               (separate (y # z)))) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (y # z)));\n     x \\<in> dom (Cp (list2FWpolicy (a # separate (y # z))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> y # z)))", "by (metis CConcStartA InDomConc domdConcStart list.simps(2) list2FWpolicy.simps(2) list2FWpolicyconc)"], ["", "lemma sep_dom2[rule_format]: \n  \"x \\<in> dom (Cp (list2FWpolicy (separate p))) \\<longrightarrow> x \\<in> dom (Cp (list2FWpolicy( p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (list2FWpolicy (separate p))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy p))", "by (rule separate.induct) (simp_all add: sep_dom2_aux sep_dom2_aux2)"], ["", "lemma sepDom: \"dom (Cp (list2FWpolicy p)) = dom (Cp (list2FWpolicy (separate p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (Cp (list2FWpolicy p)) = dom (Cp (list2FWpolicy (separate p)))", "by (rule equalityI) (rule subsetI, (erule dom_sep|erule sep_dom2))+"], ["", "lemma C_eq_s_ext[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> Cp (list2FWpolicy (separate p)) a  = Cp (list2FWpolicy p) a \""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate p)) a = Cp (list2FWpolicy p) a", "proof (induct rule: separate.induct, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x.\n       x \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate x)) a =\n       Cp (list2FWpolicy x) a \\<Longrightarrow>\n       DenyAll # x \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate (DenyAll # x))) a =\n       Cp (list2FWpolicy (DenyAll # x)) a\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (DenyAllFromTo v va) =\n                first_bothNet y \\<Longrightarrow>\n                DenyAllFromTo v va \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate (DenyAllFromTo v va \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n        first_bothNet (DenyAllFromTo v va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> DenyAllFromTo v va # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (DenyAllFromTo v va # y # z)))\n                          a =\n                         Cp (list2FWpolicy (DenyAllFromTo v va # y # z)) a\n 3. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                AllowPortFromTo v va vb \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))\n                 a;\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo v va vb # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (AllowPortFromTo v va vb # y # z)))\n                          a =\n                         Cp (list2FWpolicy\n                              (AllowPortFromTo v va vb # y # z))\n                          a\n 4. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (v \\<oplus> va # y # z)))\n                          a =\n                         Cp (list2FWpolicy (v \\<oplus> va # y # z)) a\n 5. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [])) a = Cp (list2FWpolicy []) a\n 6. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 7. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 8. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "case (1 x)"], ["proof (state)\nthis:\n  x \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate x)) a = Cp (list2FWpolicy x) a\n\ngoal (8 subgoals):\n 1. \\<And>x.\n       x \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate x)) a =\n       Cp (list2FWpolicy x) a \\<Longrightarrow>\n       DenyAll # x \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate (DenyAll # x))) a =\n       Cp (list2FWpolicy (DenyAll # x)) a\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (DenyAllFromTo v va) =\n                first_bothNet y \\<Longrightarrow>\n                DenyAllFromTo v va \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate (DenyAllFromTo v va \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n        first_bothNet (DenyAllFromTo v va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> DenyAllFromTo v va # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (DenyAllFromTo v va # y # z)))\n                          a =\n                         Cp (list2FWpolicy (DenyAllFromTo v va # y # z)) a\n 3. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                AllowPortFromTo v va vb \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))\n                 a;\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo v va vb # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (AllowPortFromTo v va vb # y # z)))\n                          a =\n                         Cp (list2FWpolicy\n                              (AllowPortFromTo v va vb # y # z))\n                          a\n 4. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (v \\<oplus> va # y # z)))\n                          a =\n                         Cp (list2FWpolicy (v \\<oplus> va # y # z)) a\n 5. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [])) a = Cp (list2FWpolicy []) a\n 6. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 7. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 8. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate x)) a = Cp (list2FWpolicy x) a\n\ngoal (1 subgoal):\n 1. DenyAll # x \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate (DenyAll # x))) a =\n    Cp (list2FWpolicy (DenyAll # x)) a", "apply (cases \"x = []\",simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> [];\n     Cp (list2FWpolicy (separate x)) a = Cp (list2FWpolicy x) a\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (DenyAll # separate x)) a =\n                      Cp (list2FWpolicy (DenyAll # x)) a", "apply (cases \"a \\<in> dom (Cp (list2FWpolicy x))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> [];\n     Cp (list2FWpolicy (separate x)) a = Cp (list2FWpolicy x) a;\n     a \\<in> dom (Cp (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (DenyAll # separate x)) a =\n                      Cp (list2FWpolicy (DenyAll # x)) a\n 2. \\<lbrakk>x \\<noteq> [];\n     Cp (list2FWpolicy (separate x)) a = Cp (list2FWpolicy x) a;\n     a \\<notin> dom (Cp (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (DenyAll # separate x)) a =\n                      Cp (list2FWpolicy (DenyAll # x)) a", "apply (subgoal_tac \"a \\<in> dom (Cp (list2FWpolicy (separate x)))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<noteq> [];\n     Cp (list2FWpolicy (separate x)) a = Cp (list2FWpolicy x) a;\n     a \\<in> dom (Cp (list2FWpolicy x));\n     a \\<in> dom (Cp (list2FWpolicy (separate x)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (DenyAll # separate x)) a =\n                      Cp (list2FWpolicy (DenyAll # x)) a\n 2. \\<lbrakk>x \\<noteq> [];\n     Cp (list2FWpolicy (separate x)) a = Cp (list2FWpolicy x) a;\n     a \\<in> dom (Cp (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> a \\<in> dom (Cp (list2FWpolicy (separate x)))\n 3. \\<lbrakk>x \\<noteq> [];\n     Cp (list2FWpolicy (separate x)) a = Cp (list2FWpolicy x) a;\n     a \\<notin> dom (Cp (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (DenyAll # separate x)) a =\n                      Cp (list2FWpolicy (DenyAll # x)) a", "apply (metis Cdom2 list2FWpolicyconc sepDom sepnMT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> [];\n     Cp (list2FWpolicy (separate x)) a = Cp (list2FWpolicy x) a;\n     a \\<in> dom (Cp (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> a \\<in> dom (Cp (list2FWpolicy (separate x)))\n 2. \\<lbrakk>x \\<noteq> [];\n     Cp (list2FWpolicy (separate x)) a = Cp (list2FWpolicy x) a;\n     a \\<notin> dom (Cp (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (DenyAll # separate x)) a =\n                      Cp (list2FWpolicy (DenyAll # x)) a", "apply (metis sepDom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> [];\n     Cp (list2FWpolicy (separate x)) a = Cp (list2FWpolicy x) a;\n     a \\<notin> dom (Cp (list2FWpolicy x))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (DenyAll # separate x)) a =\n                      Cp (list2FWpolicy (DenyAll # x)) a", "by (metis nlpaux sepDom list2FWpolicyconc sepnMT)"], ["proof (state)\nthis:\n  DenyAll # x \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate (DenyAll # x))) a =\n  Cp (list2FWpolicy (DenyAll # x)) a\n\ngoal (7 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (DenyAllFromTo v va) =\n                first_bothNet y \\<Longrightarrow>\n                DenyAllFromTo v va \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate (DenyAllFromTo v va \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n        first_bothNet (DenyAllFromTo v va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> DenyAllFromTo v va # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (DenyAllFromTo v va # y # z)))\n                          a =\n                         Cp (list2FWpolicy (DenyAllFromTo v va # y # z)) a\n 2. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                AllowPortFromTo v va vb \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))\n                 a;\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo v va vb # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (AllowPortFromTo v va vb # y # z)))\n                          a =\n                         Cp (list2FWpolicy\n                              (AllowPortFromTo v va vb # y # z))\n                          a\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (v \\<oplus> va # y # z)))\n                          a =\n                         Cp (list2FWpolicy (v \\<oplus> va # y # z)) a\n 4. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [])) a = Cp (list2FWpolicy []) a\n 5. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 6. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 7. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (DenyAllFromTo v va) =\n                first_bothNet y \\<Longrightarrow>\n                DenyAllFromTo v va \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate (DenyAllFromTo v va \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n        first_bothNet (DenyAllFromTo v va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> DenyAllFromTo v va # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (DenyAllFromTo v va # y # z)))\n                          a =\n                         Cp (list2FWpolicy (DenyAllFromTo v va # y # z)) a\n 2. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                AllowPortFromTo v va vb \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))\n                 a;\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo v va vb # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (AllowPortFromTo v va vb # y # z)))\n                          a =\n                         Cp (list2FWpolicy\n                              (AllowPortFromTo v va vb # y # z))\n                          a\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (v \\<oplus> va # y # z)))\n                          a =\n                         Cp (list2FWpolicy (v \\<oplus> va # y # z)) a\n 4. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [])) a = Cp (list2FWpolicy []) a\n 5. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 6. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 7. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "case (2 v va y z)"], ["proof (state)\nthis:\n  first_bothNet (DenyAllFromTo v va) = first_bothNet y \\<Longrightarrow>\n  DenyAllFromTo v va \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))) a =\n  Cp (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a\n  first_bothNet (DenyAllFromTo v va) \\<noteq>\n  first_bothNet y \\<Longrightarrow>\n  y # z \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate (y # z))) a = Cp (list2FWpolicy (y # z)) a\n\ngoal (7 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (DenyAllFromTo v va) =\n                first_bothNet y \\<Longrightarrow>\n                DenyAllFromTo v va \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate (DenyAllFromTo v va \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n        first_bothNet (DenyAllFromTo v va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> DenyAllFromTo v va # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (DenyAllFromTo v va # y # z)))\n                          a =\n                         Cp (list2FWpolicy (DenyAllFromTo v va # y # z)) a\n 2. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                AllowPortFromTo v va vb \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))\n                 a;\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo v va vb # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (AllowPortFromTo v va vb # y # z)))\n                          a =\n                         Cp (list2FWpolicy\n                              (AllowPortFromTo v va vb # y # z))\n                          a\n 3. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (v \\<oplus> va # y # z)))\n                          a =\n                         Cp (list2FWpolicy (v \\<oplus> va # y # z)) a\n 4. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [])) a = Cp (list2FWpolicy []) a\n 5. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 6. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 7. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "thus ?case"], ["proof (prove)\nusing this:\n  first_bothNet (DenyAllFromTo v va) = first_bothNet y \\<Longrightarrow>\n  DenyAllFromTo v va \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))) a =\n  Cp (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a\n  first_bothNet (DenyAllFromTo v va) \\<noteq>\n  first_bothNet y \\<Longrightarrow>\n  y # z \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate (y # z))) a = Cp (list2FWpolicy (y # z)) a\n\ngoal (1 subgoal):\n 1. DenyAllFromTo v va # y # z \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate (DenyAllFromTo v va # y # z))) a =\n    Cp (list2FWpolicy (DenyAllFromTo v va # y # z)) a", "apply (cases \"z = []\",simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n             Cp (list2FWpolicy (separate [y])) a = Cp y a;\n     z = []\\<rbrakk>\n    \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                      Cp (list2FWpolicy (DenyAllFromTo v va # separate [y]))\n                       a =\n                      Cp (DenyAllFromTo v va \\<oplus> y) a\n 2. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     Cp (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))) a =\n     Cp (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     Cp (list2FWpolicy (separate (y # z))) a =\n     Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                       Cp (list2FWpolicy\n                            (DenyAllFromTo v va \\<oplus> y # z))\n                        a =\n                       Cp (DenyAllFromTo v va \\<oplus>\n                           list2FWpolicy (y # z))\n                        a) \\<and>\n                      ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                       Cp (list2FWpolicy\n                            (DenyAllFromTo v va # separate (y # z)))\n                        a =\n                       Cp (DenyAllFromTo v va \\<oplus>\n                           list2FWpolicy (y # z))\n                        a)", "apply (intro conjI impI|simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Cp (list2FWpolicy (separate [y])) a = Cp y a; z = [];\n     {v, va} \\<noteq> first_bothNet y\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (DenyAllFromTo v va # separate [y]))\n                       a =\n                      Cp (DenyAllFromTo v va \\<oplus> y) a\n 2. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     Cp (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))) a =\n     Cp (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     Cp (list2FWpolicy (separate (y # z))) a =\n     Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                       Cp (list2FWpolicy\n                            (DenyAllFromTo v va \\<oplus> y # z))\n                        a =\n                       Cp (DenyAllFromTo v va \\<oplus>\n                           list2FWpolicy (y # z))\n                        a) \\<and>\n                      ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                       Cp (list2FWpolicy\n                            (DenyAllFromTo v va # separate (y # z)))\n                        a =\n                       Cp (DenyAllFromTo v va \\<oplus>\n                           list2FWpolicy (y # z))\n                        a)", "apply (simp add: PLemmas(8) UPFDefs(8) list2FWpolicyconc sepnMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     Cp (list2FWpolicy (separate (DenyAllFromTo v va \\<oplus> y # z))) a =\n     Cp (list2FWpolicy (DenyAllFromTo v va \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     Cp (list2FWpolicy (separate (y # z))) a =\n     Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                       Cp (list2FWpolicy\n                            (DenyAllFromTo v va \\<oplus> y # z))\n                        a =\n                       Cp (DenyAllFromTo v va \\<oplus>\n                           list2FWpolicy (y # z))\n                        a) \\<and>\n                      ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                       Cp (list2FWpolicy\n                            (DenyAllFromTo v va # separate (y # z)))\n                        a =\n                       Cp (DenyAllFromTo v va \\<oplus>\n                           list2FWpolicy (y # z))\n                        a)", "by (metis (mono_tags, lifting) Conc_not_MT Cdom2 list2FWpolicy_eq nlpaux sepDom l2p_aux sepnMT)"], ["proof (state)\nthis:\n  DenyAllFromTo v va # y # z \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate (DenyAllFromTo v va # y # z))) a =\n  Cp (list2FWpolicy (DenyAllFromTo v va # y # z)) a\n\ngoal (6 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                AllowPortFromTo v va vb \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))\n                 a;\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo v va vb # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (AllowPortFromTo v va vb # y # z)))\n                          a =\n                         Cp (list2FWpolicy\n                              (AllowPortFromTo v va vb # y # z))\n                          a\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (v \\<oplus> va # y # z)))\n                          a =\n                         Cp (list2FWpolicy (v \\<oplus> va # y # z)) a\n 3. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [])) a = Cp (list2FWpolicy []) a\n 4. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 5. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 6. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                AllowPortFromTo v va vb \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))\n                 a;\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo v va vb # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (AllowPortFromTo v va vb # y # z)))\n                          a =\n                         Cp (list2FWpolicy\n                              (AllowPortFromTo v va vb # y # z))\n                          a\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (v \\<oplus> va # y # z)))\n                          a =\n                         Cp (list2FWpolicy (v \\<oplus> va # y # z)) a\n 3. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [])) a = Cp (list2FWpolicy []) a\n 4. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 5. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 6. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "case (3 v va vb y z)"], ["proof (state)\nthis:\n  first_bothNet (AllowPortFromTo v va vb) =\n  first_bothNet y \\<Longrightarrow>\n  AllowPortFromTo v va vb \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate (AllowPortFromTo v va vb \\<oplus> y # z))) a =\n  Cp (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z)) a\n  first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n  first_bothNet y \\<Longrightarrow>\n  y # z \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate (y # z))) a = Cp (list2FWpolicy (y # z)) a\n\ngoal (6 subgoals):\n 1. \\<And>v va vb y z.\n       \\<lbrakk>first_bothNet (AllowPortFromTo v va vb) =\n                first_bothNet y \\<Longrightarrow>\n                AllowPortFromTo v va vb \\<oplus> y # z \\<noteq>\n                [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z))\n                 a;\n        first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> AllowPortFromTo v va vb # y # z \\<noteq>\n                         [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (AllowPortFromTo v va vb # y # z)))\n                          a =\n                         Cp (list2FWpolicy\n                              (AllowPortFromTo v va vb # y # z))\n                          a\n 2. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (v \\<oplus> va # y # z)))\n                          a =\n                         Cp (list2FWpolicy (v \\<oplus> va # y # z)) a\n 3. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [])) a = Cp (list2FWpolicy []) a\n 4. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 5. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 6. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "thus ?case"], ["proof (prove)\nusing this:\n  first_bothNet (AllowPortFromTo v va vb) =\n  first_bothNet y \\<Longrightarrow>\n  AllowPortFromTo v va vb \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate (AllowPortFromTo v va vb \\<oplus> y # z))) a =\n  Cp (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z)) a\n  first_bothNet (AllowPortFromTo v va vb) \\<noteq>\n  first_bothNet y \\<Longrightarrow>\n  y # z \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate (y # z))) a = Cp (list2FWpolicy (y # z)) a\n\ngoal (1 subgoal):\n 1. AllowPortFromTo v va vb # y # z \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate (AllowPortFromTo v va vb # y # z))) a =\n    Cp (list2FWpolicy (AllowPortFromTo v va vb # y # z)) a", "apply (cases \"z = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n             Cp (list2FWpolicy (separate [y])) a = Cp y a;\n     z = []\\<rbrakk>\n    \\<Longrightarrow> {v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                      Cp (list2FWpolicy\n                           (AllowPortFromTo v va vb # separate [y]))\n                       a =\n                      Cp (AllowPortFromTo v va vb \\<oplus> y) a\n 2. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     Cp (list2FWpolicy (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n      a =\n     Cp (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     Cp (list2FWpolicy (separate (y # z))) a =\n     Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                       Cp (list2FWpolicy\n                            (AllowPortFromTo v va vb \\<oplus> y # z))\n                        a =\n                       Cp (AllowPortFromTo v va vb \\<oplus>\n                           list2FWpolicy (y # z))\n                        a) \\<and>\n                      ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                       Cp (list2FWpolicy\n                            (AllowPortFromTo v va vb # separate (y # z)))\n                        a =\n                       Cp (AllowPortFromTo v va vb \\<oplus>\n                           list2FWpolicy (y # z))\n                        a)", "apply (simp add: PLemmas(8) UPFDefs(8) list2FWpolicyconc sepnMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<noteq> [];\n     {v, va} = first_bothNet y \\<Longrightarrow>\n     Cp (list2FWpolicy (separate (AllowPortFromTo v va vb \\<oplus> y # z)))\n      a =\n     Cp (list2FWpolicy (AllowPortFromTo v va vb \\<oplus> y # z)) a;\n     {v, va} \\<noteq> first_bothNet y \\<Longrightarrow>\n     Cp (list2FWpolicy (separate (y # z))) a =\n     Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> ({v, va} = first_bothNet y \\<longrightarrow>\n                       Cp (list2FWpolicy\n                            (AllowPortFromTo v va vb \\<oplus> y # z))\n                        a =\n                       Cp (AllowPortFromTo v va vb \\<oplus>\n                           list2FWpolicy (y # z))\n                        a) \\<and>\n                      ({v, va} \\<noteq> first_bothNet y \\<longrightarrow>\n                       Cp (list2FWpolicy\n                            (AllowPortFromTo v va vb # separate (y # z)))\n                        a =\n                       Cp (AllowPortFromTo v va vb \\<oplus>\n                           list2FWpolicy (y # z))\n                        a)", "by (metis (no_types, hide_lams) Conc_not_MT Cdom2  nlpaux domIff l2p_aux sepnMT)"], ["proof (state)\nthis:\n  AllowPortFromTo v va vb # y # z \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate (AllowPortFromTo v va vb # y # z))) a =\n  Cp (list2FWpolicy (AllowPortFromTo v va vb # y # z)) a\n\ngoal (5 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (v \\<oplus> va # y # z)))\n                          a =\n                         Cp (list2FWpolicy (v \\<oplus> va # y # z)) a\n 2. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [])) a = Cp (list2FWpolicy []) a\n 3. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 4. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 5. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (v \\<oplus> va # y # z)))\n                          a =\n                         Cp (list2FWpolicy (v \\<oplus> va # y # z)) a\n 2. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [])) a = Cp (list2FWpolicy []) a\n 3. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 4. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 5. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "case (4 v va y z)"], ["proof (state)\nthis:\n  first_bothNet (v \\<oplus> va) = first_bothNet y \\<Longrightarrow>\n  (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))) a =\n  Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a\n  first_bothNet (v \\<oplus> va) \\<noteq> first_bothNet y \\<Longrightarrow>\n  y # z \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate (y # z))) a = Cp (list2FWpolicy (y # z)) a\n\ngoal (5 subgoals):\n 1. \\<And>v va y z.\n       \\<lbrakk>first_bothNet (v \\<oplus> va) =\n                first_bothNet y \\<Longrightarrow>\n                (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n                Cp (list2FWpolicy\n                     (separate ((v \\<oplus> va) \\<oplus> y # z)))\n                 a =\n                Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n        first_bothNet (v \\<oplus> va) \\<noteq>\n        first_bothNet y \\<Longrightarrow>\n        y # z \\<noteq> [] \\<longrightarrow>\n        Cp (list2FWpolicy (separate (y # z))) a =\n        Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n       \\<Longrightarrow> v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n                         Cp (list2FWpolicy\n                              (separate (v \\<oplus> va # y # z)))\n                          a =\n                         Cp (list2FWpolicy (v \\<oplus> va # y # z)) a\n 2. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [])) a = Cp (list2FWpolicy []) a\n 3. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 4. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 5. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "thus ?case"], ["proof (prove)\nusing this:\n  first_bothNet (v \\<oplus> va) = first_bothNet y \\<Longrightarrow>\n  (v \\<oplus> va) \\<oplus> y # z \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))) a =\n  Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a\n  first_bothNet (v \\<oplus> va) \\<noteq> first_bothNet y \\<Longrightarrow>\n  y # z \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate (y # z))) a = Cp (list2FWpolicy (y # z)) a\n\ngoal (1 subgoal):\n 1. v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate (v \\<oplus> va # y # z))) a =\n    Cp (list2FWpolicy (v \\<oplus> va # y # z)) a", "apply (cases \"z = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n             Cp (list2FWpolicy (separate [y])) a = Cp y a;\n     z = []\\<rbrakk>\n    \\<Longrightarrow> first_bothNet v \\<noteq>\n                      first_bothNet y \\<longrightarrow>\n                      Cp (list2FWpolicy (v \\<oplus> va # separate [y])) a =\n                      Cp ((v \\<oplus> va) \\<oplus> y) a\n 2. \\<lbrakk>z \\<noteq> [];\n     first_bothNet v = first_bothNet y \\<Longrightarrow>\n     Cp (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))) a =\n     Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     Cp (list2FWpolicy (separate (y # z))) a =\n     Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> (first_bothNet v = first_bothNet y \\<longrightarrow>\n                       Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z))\n                        a =\n                       Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))\n                        a) \\<and>\n                      (first_bothNet v \\<noteq>\n                       first_bothNet y \\<longrightarrow>\n                       Cp (list2FWpolicy (v \\<oplus> va # separate (y # z)))\n                        a =\n                       Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))\n                        a)", "apply (simp add: PLemmas(8) UPFDefs(8) l2p_aux sepnMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<noteq> [];\n     first_bothNet v = first_bothNet y \\<Longrightarrow>\n     Cp (list2FWpolicy (separate ((v \\<oplus> va) \\<oplus> y # z))) a =\n     Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z)) a;\n     first_bothNet v \\<noteq> first_bothNet y \\<Longrightarrow>\n     Cp (list2FWpolicy (separate (y # z))) a =\n     Cp (list2FWpolicy (y # z)) a\\<rbrakk>\n    \\<Longrightarrow> (first_bothNet v = first_bothNet y \\<longrightarrow>\n                       Cp (list2FWpolicy ((v \\<oplus> va) \\<oplus> y # z))\n                        a =\n                       Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))\n                        a) \\<and>\n                      (first_bothNet v \\<noteq>\n                       first_bothNet y \\<longrightarrow>\n                       Cp (list2FWpolicy (v \\<oplus> va # separate (y # z)))\n                        a =\n                       Cp ((v \\<oplus> va) \\<oplus> list2FWpolicy (y # z))\n                        a)", "by (metis (no_types, lifting) ConcAssoc PLemmas(8) UPFDefs(8) list.distinct(1) \n        list2FWpolicyconc sepnMT)"], ["proof (state)\nthis:\n  v \\<oplus> va # y # z \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate (v \\<oplus> va # y # z))) a =\n  Cp (list2FWpolicy (v \\<oplus> va # y # z)) a\n\ngoal (4 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [])) a = Cp (list2FWpolicy []) a\n 2. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 3. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 4. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [])) a = Cp (list2FWpolicy []) a\n 2. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 3. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 4. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "case 5"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [])) a = Cp (list2FWpolicy []) a\n 2. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 3. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 4. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [])) a = Cp (list2FWpolicy []) a", "by simp"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate [])) a = Cp (list2FWpolicy []) a\n\ngoal (3 subgoals):\n 1. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 2. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 3. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 2. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 3. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "case 6"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>vb vc.\n       [DenyAllFromTo vb vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [DenyAllFromTo vb vc])) a =\n       Cp (list2FWpolicy [DenyAllFromTo vb vc]) a\n 2. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 3. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [DenyAllFromTo vb_ vc_] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [DenyAllFromTo vb_ vc_])) a =\n    Cp (list2FWpolicy [DenyAllFromTo vb_ vc_]) a", "by simp"], ["proof (state)\nthis:\n  [DenyAllFromTo vb_ vc_] \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate [DenyAllFromTo vb_ vc_])) a =\n  Cp (list2FWpolicy [DenyAllFromTo vb_ vc_]) a\n\ngoal (2 subgoals):\n 1. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 2. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 2. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "case 7"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>vb vc vd.\n       [AllowPortFromTo vb vc vd] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [AllowPortFromTo vb vc vd])) a =\n       Cp (list2FWpolicy [AllowPortFromTo vb vc vd]) a\n 2. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [AllowPortFromTo vb_ vc_ vd_] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [AllowPortFromTo vb_ vc_ vd_])) a =\n    Cp (list2FWpolicy [AllowPortFromTo vb_ vc_ vd_]) a", "by simp"], ["proof (state)\nthis:\n  [AllowPortFromTo vb_ vc_ vd_] \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate [AllowPortFromTo vb_ vc_ vd_])) a =\n  Cp (list2FWpolicy [AllowPortFromTo vb_ vc_ vd_]) a\n\ngoal (1 subgoal):\n 1. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "case 8"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>vb vc.\n       [vb \\<oplus> vc] \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (separate [vb \\<oplus> vc])) a =\n       Cp (list2FWpolicy [vb \\<oplus> vc]) a", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [vb_ \\<oplus> vc_] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (separate [vb_ \\<oplus> vc_])) a =\n    Cp (list2FWpolicy [vb_ \\<oplus> vc_]) a", "by simp"], ["proof (state)\nthis:\n  [vb_ \\<oplus> vc_] \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (separate [vb_ \\<oplus> vc_])) a =\n  Cp (list2FWpolicy [vb_ \\<oplus> vc_]) a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_s: \"p \\<noteq> [] \\<Longrightarrow> Cp (list2FWpolicy (separate p)) = Cp (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    Cp (list2FWpolicy (separate p)) = Cp (list2FWpolicy p)", "by (rule ext) (simp add: C_eq_s_ext)"], ["", "lemmas sortnMTQ = NormalisationIntegerPortProof.C_eq_Lemmas_sep(14)"], ["", "lemmas C_eq_Lemmas_sep = C_eq_Lemmas sortnMT sortnMTQ RS2_NMT NMPrd not_MTimpnotMT"], ["", "lemma C_eq_until_separated:\n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow> allNetsDistinct(policy2list p) \\<Longrightarrow>\n Cp (list2FWpolicy (separate (sort (removeShadowRules2 (remdups (rm_MT_rules Cp\n            (insertDeny (removeShadowRules1 (policy2list p)))))) l))) = \n Cp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (separate\n                             (FWNormalisationCore.sort\n                               (removeShadowRules2\n                                 (remdups\n                                   (rm_MT_rules Cp\n                                     (insertDeny\n (removeShadowRules1 (policy2list p))))))\n                               l))) =\n                      Cp p", "by (simp add: C_eq_All_untilSorted_withSimps C_eq_s wellformed1_alternative_sorted wp1ID wp1n_RS2)"], ["", "lemma C_eq_until_separatedQ:\n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> all_in_list (policy2list p) l \\<Longrightarrow>\n   allNetsDistinct (policy2list p) \\<Longrightarrow>\n     Cp(list2FWpolicy(separate(qsort(\n           removeShadowRules2(remdups (rm_MT_rules Cp\n                 (insertDeny (removeShadowRules1 (policy2list p)))))) l))) = \n     Cp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (separate\n                             (qsort\n                               (removeShadowRules2\n                                 (remdups\n                                   (rm_MT_rules Cp\n                                     (insertDeny\n (removeShadowRules1 (policy2list p))))))\n                               l))) =\n                      Cp p", "by (simp add: C_eq_All_untilSorted_withSimpsQ C_eq_s setnMT wp1ID wp1n_RS2)"], ["", "lemma domID[rule_format]: \n  \"p \\<noteq> [] \\<and> x \\<in> dom(Cp(list2FWpolicy p)) \\<longrightarrow> x \\<in> dom (Cp(list2FWpolicy(insertDenies p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<and>\n    x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))", "proof(induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<and>\n    x \\<in> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (insertDenies [])))\n 2. \\<And>a p.\n       p \\<noteq> [] \\<and>\n       x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<and>\n       x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (insertDenies (a # p))))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<and>\n    x \\<in> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (insertDenies [])))\n 2. \\<And>a p.\n       p \\<noteq> [] \\<and>\n       x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<and>\n       x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (insertDenies (a # p))))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<and>\n    x \\<in> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (insertDenies [])))", "by simp"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<and>\n  x \\<in> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies [])))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<and>\n       x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<and>\n       x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (insertDenies (a # p))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<and>\n       x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<and>\n       x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (insertDenies (a # p))))", "case (Cons a p)"], ["proof (state)\nthis:\n  p \\<noteq> [] \\<and> x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<and>\n       x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<and>\n       x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (insertDenies (a # p))))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> [] \\<and> x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<and> x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. a # p \\<noteq> [] \\<and>\n    x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (insertDenies (a # p))))", "proof(cases \"p=[]\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n     p = []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (a # p))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (a # p))))\n 2. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (a # p))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (a # p))))", "case 1"], ["proof (state)\nthis:\n  p \\<noteq> [] \\<and> x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n  p = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n     p = []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (a # p))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (a # p))))\n 2. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (a # p))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (a # p))))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> [] \\<and> x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n  p = []", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<and> x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n  p = []\n\ngoal (1 subgoal):\n 1. a # p \\<noteq> [] \\<and>\n    x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (insertDenies (a # p))))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = [] \\<Longrightarrow>\n    x \\<in> dom (Cp a) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy\n                      (case a of\n                       DenyAll \\<Rightarrow> DenyAll # insertDenies []\n                       | _ \\<Rightarrow>\n                           DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a #\n                           insertDenies [])))", "apply(rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = []; x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies []\n   | _ \\<Rightarrow>\n       DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n       DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n       insertDenies [])))", "apply (cases a, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>p = []; x \\<in> dom (Cp (DenyAllFromTo x21 x22));\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (DenyAllFromTo x21 x22 \\<oplus>\n  DenyAllFromTo x22 x21 \\<oplus> DenyAllFromTo x21 x22))\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>p = []; x \\<in> dom (Cp (AllowPortFromTo x31 x32 x33));\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (DenyAllFromTo x31 x32 \\<oplus>\n  DenyAllFromTo x32 x31 \\<oplus> AllowPortFromTo x31 x32 x33))\n 3. \\<And>x41 x42.\n       \\<lbrakk>p = []; x \\<in> dom (Cp (x41 \\<oplus> x42));\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (DenyAllFromTo (first_srcNet x41) (first_destNet x41) \\<oplus>\n  DenyAllFromTo (first_destNet x41) (first_srcNet x41) \\<oplus>\n  x41 \\<oplus> x42))", "apply (simp_all add: Cp.simps dom_def)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>p = [];\n        (\\<exists>y. Cp x42 x = \\<lfloor>y\\<rfloor>) \\<or>\n        (\\<exists>y. Cp x41 x = \\<lfloor>y\\<rfloor>);\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y. Cp x42 x = \\<lfloor>y\\<rfloor>) \\<or>\n                         (\\<exists>y. Cp x41 x = \\<lfloor>y\\<rfloor>) \\<or>\n                         (\\<exists>y.\n                             deny_all_from_to (first_destNet x41)\n                              (first_srcNet x41) x =\n                             \\<lfloor>y\\<rfloor>) \\<or>\n                         (\\<exists>y.\n                             deny_all_from_to (first_srcNet x41)\n                              (first_destNet x41) x =\n                             \\<lfloor>y\\<rfloor>)", "by auto"], ["proof (state)\nthis:\n  a # p \\<noteq> [] \\<and>\n  x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies (a # p))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (a # p))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (a # p))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (a # p))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (a # p))))", "case 2"], ["proof (state)\nthis:\n  p \\<noteq> [] \\<and> x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (a # p))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (a # p))))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> [] \\<and> x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<and> x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. a # p \\<noteq> [] \\<and>\n    x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (insertDenies (a # p))))", "proof(cases \"x \\<in> dom(Cp(list2FWpolicy p))\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (a # p))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (a # p))))\n 2. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (a # p))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (a # p))))", "case 1"], ["proof (state)\nthis:\n  p \\<noteq> [] \\<and> x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []\n  x \\<in> dom (Cp (list2FWpolicy p))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (a # p))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (a # p))))\n 2. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (a # p))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (a # p))))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> [] \\<and> x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []\n  x \\<in> dom (Cp (list2FWpolicy p))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<and> x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []\n  x \\<in> dom (Cp (list2FWpolicy p))\n\ngoal (1 subgoal):\n 1. a # p \\<noteq> [] \\<and>\n    x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (insertDenies (a # p))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (a # p))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n   | _ \\<Rightarrow>\n       DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n       DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n       insertDenies p)))", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp (list2FWpolicy (a # p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n   | _ \\<Rightarrow>\n       DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n       DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n       insertDenies p)))", "apply (cases a, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n        p \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo x21 x22 # p)));\n        a = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (DenyAllFromTo x21 x22 \\<oplus>\n    DenyAllFromTo x22 x21 \\<oplus> DenyAllFromTo x21 x22 #\n    insertDenies p)))\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n        p \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x31 x32 x33 # p)));\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (DenyAllFromTo x31 x32 \\<oplus>\n    DenyAllFromTo x32 x31 \\<oplus> AllowPortFromTo x31 x32 x33 #\n    insertDenies p)))\n 3. \\<And>x41 x42.\n       \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n        p \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (x41 \\<oplus> x42 # p)));\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (DenyAllFromTo (first_srcNet x41) (first_destNet x41) \\<oplus>\n    DenyAllFromTo (first_destNet x41) (first_srcNet x41) \\<oplus>\n    x41 \\<oplus> x42 #\n    insertDenies p)))", "apply (metis InDomConc idNMT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n        p \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x31 x32 x33 # p)));\n        a = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (DenyAllFromTo x31 x32 \\<oplus>\n    DenyAllFromTo x32 x31 \\<oplus> AllowPortFromTo x31 x32 x33 #\n    insertDenies p)))\n 2. \\<And>x41 x42.\n       \\<lbrakk>x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n        p \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (x41 \\<oplus> x42 # p)));\n        a = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (DenyAllFromTo (first_srcNet x41) (first_destNet x41) \\<oplus>\n    DenyAllFromTo (first_destNet x41) (first_srcNet x41) \\<oplus>\n    x41 \\<oplus> x42 #\n    insertDenies p)))", "apply (rule InDomConc, simp_all add: idNMT)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a # p \\<noteq> [] \\<and>\n  x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies (a # p))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (a # p))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (a # p))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (a # p))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (a # p))))", "case 2"], ["proof (state)\nthis:\n  p \\<noteq> [] \\<and> x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> [] \\<and>\n             x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy (insertDenies p)));\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> a # p \\<noteq> [] \\<and>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (a # p))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (a # p))))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> [] \\<and> x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<and> x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n\ngoal (1 subgoal):\n 1. a # p \\<noteq> [] \\<and>\n    x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (insertDenies (a # p))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (a # p))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n   | _ \\<Rightarrow>\n       DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n       DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n       insertDenies p)))", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp (list2FWpolicy (a # p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n   | _ \\<Rightarrow>\n       DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n       DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n       insertDenies p)))", "proof(cases \"x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp (list2FWpolicy (a # p)));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n   | _ \\<Rightarrow>\n       DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n       DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n       insertDenies p)))\n 2. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp (list2FWpolicy (a # p)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n   | _ \\<Rightarrow>\n       DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n       DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n       insertDenies p)))", "case 1"], ["proof (state)\nthis:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (a # p)))\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp (list2FWpolicy (a # p)));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n   | _ \\<Rightarrow>\n       DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n       DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n       insertDenies p)))\n 2. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp (list2FWpolicy (a # p)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n   | _ \\<Rightarrow>\n       DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n       DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n       insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (a # p)))\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (a # p)))\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (list2FWpolicy\n                      (case a of\n                       DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                       | _ \\<Rightarrow>\n                           DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a #\n                           insertDenies p)))", "proof(induct a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp (list2FWpolicy (DenyAll # p)));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (case DenyAll of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n   | _ \\<Rightarrow>\n       DenyAllFromTo (first_srcNet DenyAll) (first_destNet DenyAll) \\<oplus>\n       DenyAllFromTo (first_destNet DenyAll) (first_srcNet DenyAll) \\<oplus>\n       DenyAll #\n       insertDenies p)))\n 2. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 3. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "case DenyAll"], ["proof (state)\nthis:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (DenyAll # p)))\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp (list2FWpolicy (DenyAll # p)));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (case DenyAll of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n   | _ \\<Rightarrow>\n       DenyAllFromTo (first_srcNet DenyAll) (first_destNet DenyAll) \\<oplus>\n       DenyAllFromTo (first_destNet DenyAll) (first_srcNet DenyAll) \\<oplus>\n       DenyAll #\n       insertDenies p)))\n 2. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 3. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (DenyAll # p)))\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (DenyAll # p)))\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (list2FWpolicy\n                      (case DenyAll of\n                       DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                       | _ \\<Rightarrow>\n                           DenyAllFromTo (first_srcNet DenyAll)\n                            (first_destNet DenyAll) \\<oplus>\n                           DenyAllFromTo (first_destNet DenyAll)\n                            (first_srcNet DenyAll) \\<oplus>\n                           DenyAll #\n                           insertDenies p)))", "by simp"], ["proof (state)\nthis:\n  x \\<in> dom (Cp (list2FWpolicy\n                    (case DenyAll of\n                     DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                     | _ \\<Rightarrow>\n                         DenyAllFromTo (first_srcNet DenyAll)\n                          (first_destNet DenyAll) \\<oplus>\n                         DenyAllFromTo (first_destNet DenyAll)\n                          (first_srcNet DenyAll) \\<oplus>\n                         DenyAll #\n                         insertDenies p)))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "case (DenyAllFromTo src dest)"], ["proof (state)\nthis:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo src dest # p)))\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo src dest # p)))\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo src dest # p)))\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (list2FWpolicy\n                      (case DenyAllFromTo src dest of\n                       DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                       | _ \\<Rightarrow>\n                           DenyAllFromTo\n                            (first_srcNet (DenyAllFromTo src dest))\n                            (first_destNet\n                              (DenyAllFromTo src dest)) \\<oplus>\n                           DenyAllFromTo\n                            (first_destNet (DenyAllFromTo src dest))\n                            (first_srcNet (DenyAllFromTo src dest)) \\<oplus>\n                           DenyAllFromTo src dest #\n                           insertDenies p)))", "by simp (rule InDomConc, simp add: idNMT)"], ["proof (state)\nthis:\n  x \\<in> dom (Cp (list2FWpolicy\n                    (case DenyAllFromTo src dest of\n                     DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                     | _ \\<Rightarrow>\n                         DenyAllFromTo\n                          (first_srcNet (DenyAllFromTo src dest))\n                          (first_destNet (DenyAllFromTo src dest)) \\<oplus>\n                         DenyAllFromTo\n                          (first_destNet (DenyAllFromTo src dest))\n                          (first_srcNet (DenyAllFromTo src dest)) \\<oplus>\n                         DenyAllFromTo src dest #\n                         insertDenies p)))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "case (AllowPortFromTo src dest port)"], ["proof (state)\nthis:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo src dest port # p)))\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo src dest port # p)))\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo src dest port # p)))\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (list2FWpolicy\n                      (case AllowPortFromTo src dest port of\n                       DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                       | _ \\<Rightarrow>\n                           DenyAllFromTo\n                            (first_srcNet (AllowPortFromTo src dest port))\n                            (first_destNet\n                              (AllowPortFromTo src dest port)) \\<oplus>\n                           DenyAllFromTo\n                            (first_destNet (AllowPortFromTo src dest port))\n                            (first_srcNet\n                              (AllowPortFromTo src dest port)) \\<oplus>\n                           AllowPortFromTo src dest port #\n                           insertDenies p)))", "by simp (rule InDomConc, simp  add: idNMT)"], ["proof (state)\nthis:\n  x \\<in> dom (Cp (list2FWpolicy\n                    (case AllowPortFromTo src dest port of\n                     DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                     | _ \\<Rightarrow>\n                         DenyAllFromTo\n                          (first_srcNet (AllowPortFromTo src dest port))\n                          (first_destNet\n                            (AllowPortFromTo src dest port)) \\<oplus>\n                         DenyAllFromTo\n                          (first_destNet (AllowPortFromTo src dest port))\n                          (first_srcNet\n                            (AllowPortFromTo src dest port)) \\<oplus>\n                         AllowPortFromTo src dest port #\n                         insertDenies p)))\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "case (Conc _ _)"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n   x \\<in> dom (Cp (list2FWpolicy (a1_ # p)));\n   x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n(case a1_ of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n | _ \\<Rightarrow>\n     DenyAllFromTo (first_srcNet a1_) (first_destNet a1_) \\<oplus>\n     DenyAllFromTo (first_destNet a1_) (first_srcNet a1_) \\<oplus> a1_ #\n     insertDenies p)))\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n   x \\<in> dom (Cp (list2FWpolicy (a2_ # p)));\n   x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n(case a2_ of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n | _ \\<Rightarrow>\n     DenyAllFromTo (first_srcNet a2_) (first_destNet a2_) \\<oplus>\n     DenyAllFromTo (first_destNet a2_) (first_srcNet a2_) \\<oplus> a2_ #\n     insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (a1_ \\<oplus> a2_ # p)))\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n   x \\<in> dom (Cp (list2FWpolicy (a1_ # p)));\n   x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n(case a1_ of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n | _ \\<Rightarrow>\n     DenyAllFromTo (first_srcNet a1_) (first_destNet a1_) \\<oplus>\n     DenyAllFromTo (first_destNet a1_) (first_srcNet a1_) \\<oplus> a1_ #\n     insertDenies p)))\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n   x \\<in> dom (Cp (list2FWpolicy (a2_ # p)));\n   x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n(case a2_ of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n | _ \\<Rightarrow>\n     DenyAllFromTo (first_srcNet a2_) (first_destNet a2_) \\<oplus>\n     DenyAllFromTo (first_destNet a2_) (first_srcNet a2_) \\<oplus> a2_ #\n     insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (a1_ \\<oplus> a2_ # p)))\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n   x \\<in> dom (Cp (list2FWpolicy (a1_ # p)));\n   x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n(case a1_ of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n | _ \\<Rightarrow>\n     DenyAllFromTo (first_srcNet a1_) (first_destNet a1_) \\<oplus>\n     DenyAllFromTo (first_destNet a1_) (first_srcNet a1_) \\<oplus> a1_ #\n     insertDenies p)))\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n   x \\<in> dom (Cp (list2FWpolicy (a2_ # p)));\n   x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n(case a2_ of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n | _ \\<Rightarrow>\n     DenyAllFromTo (first_srcNet a2_) (first_destNet a2_) \\<oplus>\n     DenyAllFromTo (first_destNet a2_) (first_srcNet a2_) \\<oplus> a2_ #\n     insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (a1_ \\<oplus> a2_ # p)))\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (list2FWpolicy\n                      (case a1_ \\<oplus> a2_ of\n                       DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                       | _ \\<Rightarrow>\n                           DenyAllFromTo (first_srcNet (a1_ \\<oplus> a2_))\n                            (first_destNet (a1_ \\<oplus> a2_)) \\<oplus>\n                           DenyAllFromTo (first_destNet (a1_ \\<oplus> a2_))\n                            (first_srcNet (a1_ \\<oplus> a2_)) \\<oplus>\n                           a1_ \\<oplus> a2_ #\n                           insertDenies p)))", "by simp(rule InDomConc, simp add: idNMT)"], ["proof (state)\nthis:\n  x \\<in> dom (Cp (list2FWpolicy\n                    (case a1_ \\<oplus> a2_ of\n                     DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                     | _ \\<Rightarrow>\n                         DenyAllFromTo (first_srcNet (a1_ \\<oplus> a2_))\n                          (first_destNet (a1_ \\<oplus> a2_)) \\<oplus>\n                         DenyAllFromTo (first_destNet (a1_ \\<oplus> a2_))\n                          (first_srcNet (a1_ \\<oplus> a2_)) \\<oplus>\n                         a1_ \\<oplus> a2_ #\n                         insertDenies p)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> dom (Cp (list2FWpolicy\n                    (case a of\n                     DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                     | _ \\<Rightarrow>\n                         DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a #\n                         insertDenies p)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp (list2FWpolicy (a # p)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n   | _ \\<Rightarrow>\n       DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n       DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n       insertDenies p)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp (list2FWpolicy (a # p)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n   | _ \\<Rightarrow>\n       DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n       DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n       insertDenies p)))", "case 2"], ["proof (state)\nthis:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (a # p)))\n  x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp (list2FWpolicy (a # p)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (case a of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n   | _ \\<Rightarrow>\n       DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n       DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a #\n       insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (a # p)))\n  x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (a # p)))\n  x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (list2FWpolicy\n                      (case a of\n                       DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                       | _ \\<Rightarrow>\n                           DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a #\n                           insertDenies p)))", "proof (induct a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp (list2FWpolicy (DenyAll # p)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (case DenyAll of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n   | _ \\<Rightarrow>\n       DenyAllFromTo (first_srcNet DenyAll) (first_destNet DenyAll) \\<oplus>\n       DenyAllFromTo (first_destNet DenyAll) (first_srcNet DenyAll) \\<oplus>\n       DenyAll #\n       insertDenies p)))\n 2. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 3. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (Cp (list2FWpolicy\n(insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "case DenyAll"], ["proof (state)\nthis:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (DenyAll # p)))\n  x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp (list2FWpolicy (DenyAll # p)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n  (case DenyAll of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n   | _ \\<Rightarrow>\n       DenyAllFromTo (first_srcNet DenyAll) (first_destNet DenyAll) \\<oplus>\n       DenyAllFromTo (first_destNet DenyAll) (first_srcNet DenyAll) \\<oplus>\n       DenyAll #\n       insertDenies p)))\n 2. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 3. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (Cp (list2FWpolicy\n(insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (DenyAll # p)))\n  x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (DenyAll # p)))\n  x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (list2FWpolicy\n                      (case DenyAll of\n                       DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                       | _ \\<Rightarrow>\n                           DenyAllFromTo (first_srcNet DenyAll)\n                            (first_destNet DenyAll) \\<oplus>\n                           DenyAllFromTo (first_destNet DenyAll)\n                            (first_srcNet DenyAll) \\<oplus>\n                           DenyAll #\n                           insertDenies p)))", "by simp"], ["proof (state)\nthis:\n  x \\<in> dom (Cp (list2FWpolicy\n                    (case DenyAll of\n                     DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                     | _ \\<Rightarrow>\n                         DenyAllFromTo (first_srcNet DenyAll)\n                          (first_destNet DenyAll) \\<oplus>\n                         DenyAllFromTo (first_destNet DenyAll)\n                          (first_srcNet DenyAll) \\<oplus>\n                         DenyAll #\n                         insertDenies p)))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (Cp (list2FWpolicy\n(insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (Cp (list2FWpolicy\n(insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "case (DenyAllFromTo src dest)"], ["proof (state)\nthis:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo src dest # p)))\n  x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo x1 x2 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case DenyAllFromTo x1 x2 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (DenyAllFromTo x1 x2))\n         (first_destNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo (first_destNet (DenyAllFromTo x1 x2))\n         (first_srcNet (DenyAllFromTo x1 x2)) \\<oplus>\n        DenyAllFromTo x1 x2 #\n        insertDenies p)))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (Cp (list2FWpolicy\n(insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo src dest # p)))\n  x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo src dest # p)))\n  x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (list2FWpolicy\n                      (case DenyAllFromTo src dest of\n                       DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                       | _ \\<Rightarrow>\n                           DenyAllFromTo\n                            (first_srcNet (DenyAllFromTo src dest))\n                            (first_destNet\n                              (DenyAllFromTo src dest)) \\<oplus>\n                           DenyAllFromTo\n                            (first_destNet (DenyAllFromTo src dest))\n                            (first_srcNet (DenyAllFromTo src dest)) \\<oplus>\n                           DenyAllFromTo src dest #\n                           insertDenies p)))", "by(simp,metis domIff CConcStartA list2FWpolicyconc nlpaux Cdom2)"], ["proof (state)\nthis:\n  x \\<in> dom (Cp (list2FWpolicy\n                    (case DenyAllFromTo src dest of\n                     DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                     | _ \\<Rightarrow>\n                         DenyAllFromTo\n                          (first_srcNet (DenyAllFromTo src dest))\n                          (first_destNet (DenyAllFromTo src dest)) \\<oplus>\n                         DenyAllFromTo\n                          (first_destNet (DenyAllFromTo src dest))\n                          (first_srcNet (DenyAllFromTo src dest)) \\<oplus>\n                         DenyAllFromTo src dest #\n                         insertDenies p)))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (Cp (list2FWpolicy\n(insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (Cp (list2FWpolicy\n(insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "case (AllowPortFromTo src dest port)"], ["proof (state)\nthis:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo src dest port # p)))\n  x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo x1 x2 x3 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case AllowPortFromTo x1 x2 x3 of\n    DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (AllowPortFromTo x1 x2 x3))\n         (first_destNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        DenyAllFromTo (first_destNet (AllowPortFromTo x1 x2 x3))\n         (first_srcNet (AllowPortFromTo x1 x2 x3)) \\<oplus>\n        AllowPortFromTo x1 x2 x3 #\n        insertDenies p)))\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (Cp (list2FWpolicy\n(insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo src dest port # p)))\n  x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo src dest port # p)))\n  x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (list2FWpolicy\n                      (case AllowPortFromTo src dest port of\n                       DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                       | _ \\<Rightarrow>\n                           DenyAllFromTo\n                            (first_srcNet (AllowPortFromTo src dest port))\n                            (first_destNet\n                              (AllowPortFromTo src dest port)) \\<oplus>\n                           DenyAllFromTo\n                            (first_destNet (AllowPortFromTo src dest port))\n                            (first_srcNet\n                              (AllowPortFromTo src dest port)) \\<oplus>\n                           AllowPortFromTo src dest port #\n                           insertDenies p)))", "by(simp,metis domIff CConcStartA list2FWpolicyconc nlpaux Cdom2)"], ["proof (state)\nthis:\n  x \\<in> dom (Cp (list2FWpolicy\n                    (case AllowPortFromTo src dest port of\n                     DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                     | _ \\<Rightarrow>\n                         DenyAllFromTo\n                          (first_srcNet (AllowPortFromTo src dest port))\n                          (first_destNet\n                            (AllowPortFromTo src dest port)) \\<oplus>\n                         DenyAllFromTo\n                          (first_destNet (AllowPortFromTo src dest port))\n                          (first_srcNet\n                            (AllowPortFromTo src dest port)) \\<oplus>\n                         AllowPortFromTo src dest port #\n                         insertDenies p)))\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (Cp (list2FWpolicy\n(insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (Cp (list2FWpolicy\n(insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "case (Conc _ _)"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n   x \\<in> dom (Cp (list2FWpolicy (a1_ # p)));\n   x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n(case a1_ of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n | _ \\<Rightarrow>\n     DenyAllFromTo (first_srcNet a1_) (first_destNet a1_) \\<oplus>\n     DenyAllFromTo (first_destNet a1_) (first_srcNet a1_) \\<oplus> a1_ #\n     insertDenies p)))\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n   x \\<in> dom (Cp (list2FWpolicy (a2_ # p)));\n   x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n(case a2_ of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n | _ \\<Rightarrow>\n     DenyAllFromTo (first_srcNet a2_) (first_destNet a2_) \\<oplus>\n     DenyAllFromTo (first_destNet a2_) (first_srcNet a2_) \\<oplus> a2_ #\n     insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (a1_ \\<oplus> a2_ # p)))\n  x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> [];\n                 x \\<notin> dom (Cp (list2FWpolicy p));\n                 x \\<in> dom (Cp (list2FWpolicy (a1 # p)));\n                 x \\<notin> dom (Cp (list2FWpolicy\n(insertDenies p)))\\<rbrakk>\n                \\<Longrightarrow> x \\<in> dom\n     (Cp (list2FWpolicy\n           (case a1 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n            | _ \\<Rightarrow>\n                DenyAllFromTo (first_srcNet a1) (first_destNet a1) \\<oplus>\n                DenyAllFromTo (first_destNet a1) (first_srcNet a1) \\<oplus>\n                a1 #\n                insertDenies p)));\n        \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n         x \\<in> dom (Cp (list2FWpolicy (a2 # p)));\n         x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n        \\<Longrightarrow> x \\<in> dom (Cp\n  (list2FWpolicy\n    (case a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n     | _ \\<Rightarrow>\n         DenyAllFromTo (first_srcNet a2) (first_destNet a2) \\<oplus>\n         DenyAllFromTo (first_destNet a2) (first_srcNet a2) \\<oplus> a2 #\n         insertDenies p)));\n        p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n        x \\<in> dom (Cp (list2FWpolicy (a1 \\<oplus> a2 # p)));\n        x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom (Cp\n (list2FWpolicy\n   (case a1 \\<oplus> a2 of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n    | _ \\<Rightarrow>\n        DenyAllFromTo (first_srcNet (a1 \\<oplus> a2))\n         (first_destNet (a1 \\<oplus> a2)) \\<oplus>\n        DenyAllFromTo (first_destNet (a1 \\<oplus> a2))\n         (first_srcNet (a1 \\<oplus> a2)) \\<oplus>\n        a1 \\<oplus> a2 #\n        insertDenies p)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n   x \\<in> dom (Cp (list2FWpolicy (a1_ # p)));\n   x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n(case a1_ of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n | _ \\<Rightarrow>\n     DenyAllFromTo (first_srcNet a1_) (first_destNet a1_) \\<oplus>\n     DenyAllFromTo (first_destNet a1_) (first_srcNet a1_) \\<oplus> a1_ #\n     insertDenies p)))\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n   x \\<in> dom (Cp (list2FWpolicy (a2_ # p)));\n   x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n(case a2_ of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n | _ \\<Rightarrow>\n     DenyAllFromTo (first_srcNet a2_) (first_destNet a2_) \\<oplus>\n     DenyAllFromTo (first_destNet a2_) (first_srcNet a2_) \\<oplus> a2_ #\n     insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (a1_ \\<oplus> a2_ # p)))\n  x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n   x \\<in> dom (Cp (list2FWpolicy (a1_ # p)));\n   x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n(case a1_ of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n | _ \\<Rightarrow>\n     DenyAllFromTo (first_srcNet a1_) (first_destNet a1_) \\<oplus>\n     DenyAllFromTo (first_destNet a1_) (first_srcNet a1_) \\<oplus> a1_ #\n     insertDenies p)))\n  \\<lbrakk>p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n   x \\<in> dom (Cp (list2FWpolicy (a2_ # p)));\n   x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> dom (Cp (list2FWpolicy\n(case a2_ of DenyAll \\<Rightarrow> DenyAll # insertDenies p\n | _ \\<Rightarrow>\n     DenyAllFromTo (first_srcNet a2_) (first_destNet a2_) \\<oplus>\n     DenyAllFromTo (first_destNet a2_) (first_srcNet a2_) \\<oplus> a2_ #\n     insertDenies p)))\n  p \\<noteq> []\n  x \\<notin> dom (Cp (list2FWpolicy p))\n  x \\<in> dom (Cp (list2FWpolicy (a1_ \\<oplus> a2_ # p)))\n  x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (list2FWpolicy\n                      (case a1_ \\<oplus> a2_ of\n                       DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                       | _ \\<Rightarrow>\n                           DenyAllFromTo (first_srcNet (a1_ \\<oplus> a2_))\n                            (first_destNet (a1_ \\<oplus> a2_)) \\<oplus>\n                           DenyAllFromTo (first_destNet (a1_ \\<oplus> a2_))\n                            (first_srcNet (a1_ \\<oplus> a2_)) \\<oplus>\n                           a1_ \\<oplus> a2_ #\n                           insertDenies p)))", "by simp (metis CConcStartA Cdom2 Conc(5) ConcAssoc domIff domdConcStart)"], ["proof (state)\nthis:\n  x \\<in> dom (Cp (list2FWpolicy\n                    (case a1_ \\<oplus> a2_ of\n                     DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                     | _ \\<Rightarrow>\n                         DenyAllFromTo (first_srcNet (a1_ \\<oplus> a2_))\n                          (first_destNet (a1_ \\<oplus> a2_)) \\<oplus>\n                         DenyAllFromTo (first_destNet (a1_ \\<oplus> a2_))\n                          (first_srcNet (a1_ \\<oplus> a2_)) \\<oplus>\n                         a1_ \\<oplus> a2_ #\n                         insertDenies p)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> dom (Cp (list2FWpolicy\n                    (case a of\n                     DenyAll \\<Rightarrow> DenyAll # insertDenies p\n                     | _ \\<Rightarrow>\n                         DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a #\n                         insertDenies p)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a # p \\<noteq> [] \\<and>\n  x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies (a # p))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a # p \\<noteq> [] \\<and>\n  x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies (a # p))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a # p \\<noteq> [] \\<and>\n  x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies (a # p))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma DA_is_deny: \n  \"x \\<in> dom (Cp (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)) \\<Longrightarrow>\nCp (DenyAllFromTo a b\\<oplus>DenyAllFromTo b a \\<oplus> DenyAllFromTo a b) x = Some (deny ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (Cp (DenyAllFromTo a b \\<oplus>\n                     DenyAllFromTo b a \\<oplus>\n                     DenyAllFromTo a b)) \\<Longrightarrow>\n    Cp (DenyAllFromTo a b \\<oplus>\n        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n     x =\n    \\<lfloor>deny ()\\<rfloor>", "by (case_tac \"x \\<in> dom (Cp (DenyAllFromTo a b))\") (simp_all add: PLemmas split: if_splits)"], ["", "lemma iDdomAux[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow> \n   x \\<in> dom (Cp (list2FWpolicy (insertDenies p))) \\<longrightarrow>\n   Cp (list2FWpolicy (insertDenies p)) x = Some (deny ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (insertDenies p))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies p)) x = \\<lfloor>deny ()\\<rfloor>", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (insertDenies []))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies [])) x = \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (insertDenies p))) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies p)) x =\n       \\<lfloor>deny ()\\<rfloor> \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy\n                         (insertDenies (a # p)))) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies (a # p))) x =\n       \\<lfloor>deny ()\\<rfloor>", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (insertDenies []))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies [])) x = \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (insertDenies p))) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies p)) x =\n       \\<lfloor>deny ()\\<rfloor> \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy\n                         (insertDenies (a # p)))) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies (a # p))) x =\n       \\<lfloor>deny ()\\<rfloor>", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (insertDenies []))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies [])) x = \\<lfloor>deny ()\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies []))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies [])) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (insertDenies p))) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies p)) x =\n       \\<lfloor>deny ()\\<rfloor> \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy\n                         (insertDenies (a # p)))) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies (a # p))) x =\n       \\<lfloor>deny ()\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (insertDenies p))) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies p)) x =\n       \\<lfloor>deny ()\\<rfloor> \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy\n                         (insertDenies (a # p)))) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies (a # p))) x =\n       \\<lfloor>deny ()\\<rfloor>", "case (Cons y ys)"], ["proof (state)\nthis:\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (insertDenies p))) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies p)) x =\n       \\<lfloor>deny ()\\<rfloor> \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<notin> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy\n                         (insertDenies (a # p)))) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies (a # p))) x =\n       \\<lfloor>deny ()\\<rfloor>", "thus ?case"], ["proof (prove)\nusing this:\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy\n                      (insertDenies (y # ys)))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "proof (cases y)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n             x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (insertDenies ys))) \\<longrightarrow>\n             Cp (list2FWpolicy (insertDenies ys)) x =\n             \\<lfloor>deny ()\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (y # ys)))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 4. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "case DenyAll"], ["proof (state)\nthis:\n  y = DenyAll\n\ngoal (4 subgoals):\n 1. \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n             x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (insertDenies ys))) \\<longrightarrow>\n             Cp (list2FWpolicy (insertDenies ys)) x =\n             \\<lfloor>deny ()\\<rfloor>;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (y # ys)))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 4. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = DenyAll", "show ?thesis"], ["proof (prove)\nusing this:\n  y = DenyAll\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy\n                      (insertDenies (y # ys)))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 3. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 3. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "case (DenyAllFromTo a b)"], ["proof (state)\nthis:\n  y = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 3. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = DenyAllFromTo a b", "show ?thesis"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy\n                      (insertDenies (y # ys)))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "using DenyAllFromTo Cons"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n  y = DenyAllFromTo a b\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy\n                      (insertDenies (y # ys)))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x =\n     \\<lfloor>deny ()\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp\n (list2FWpolicy (DenyAllFromTo a b # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n   insertDenies ys))) \\<longrightarrow>\n                      Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (rule impI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "proof (cases \"ys = []\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys = []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "case 1"], ["proof (state)\nthis:\n  y = DenyAllFromTo a b\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)))\n  x \\<in> dom (Cp (list2FWpolicy\n                    (DenyAllFromTo a b \\<oplus>\n                     DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                     insertDenies ys)))\n  ys = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys = []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = DenyAllFromTo a b\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)))\n  x \\<in> dom (Cp (list2FWpolicy\n                    (DenyAllFromTo a b \\<oplus>\n                     DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                     insertDenies ys)))\n  ys = []", "show ?case"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)))\n  x \\<in> dom (Cp (list2FWpolicy\n                    (DenyAllFromTo a b \\<oplus>\n                     DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                     insertDenies ys)))\n  ys = []\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy\n         (DenyAllFromTo a b \\<oplus>\n          DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n          insertDenies ys))\n     x =\n    \\<lfloor>deny ()\\<rfloor>", "by (simp add: DA_is_deny)"], ["proof (state)\nthis:\n  Cp (list2FWpolicy\n       (DenyAllFromTo a b \\<oplus>\n        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n        insertDenies ys))\n   x =\n  \\<lfloor>deny ()\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "case 2"], ["proof (state)\nthis:\n  y = DenyAllFromTo a b\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)))\n  x \\<in> dom (Cp (list2FWpolicy\n                    (DenyAllFromTo a b \\<oplus>\n                     DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                     insertDenies ys)))\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = DenyAllFromTo a b\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)))\n  x \\<in> dom (Cp (list2FWpolicy\n                    (DenyAllFromTo a b \\<oplus>\n                     DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                     insertDenies ys)))\n  ys \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)))\n  x \\<in> dom (Cp (list2FWpolicy\n                    (DenyAllFromTo a b \\<oplus>\n                     DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                     insertDenies ys)))\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. Cp (list2FWpolicy\n         (DenyAllFromTo a b \\<oplus>\n          DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n          insertDenies ys))\n     x =\n    \\<lfloor>deny ()\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (drule mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp (list2FWpolicy ys))\n 2. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys \\<noteq> [];\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x =\n     \\<lfloor>deny ()\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (metis DenyAllFromTo InDomConc )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys \\<noteq> [];\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x =\n     \\<lfloor>deny ()\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (cases \"x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\",simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys \\<noteq> [];\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (metis Cdom2 DenyAllFromTo  idNMT list2FWpolicyconc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (subgoal_tac \"Cp (list2FWpolicy (DenyAllFromTo a b \\<oplus>\n                                    DenyAllFromTo b a \\<oplus> DenyAllFromTo a b#insertDenies ys)) x =\n                                Cp ((DenyAllFromTo a b \\<oplus> DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)) x \")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo a b \\<oplus>\n           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n           insertDenies ys))\n      x =\n     Cp (DenyAllFromTo a b \\<oplus>\n         DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n      x\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (DenyAllFromTo a b \\<oplus>\n                          DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n                       x", "apply (metis DA_is_deny DenyAllFromTo domdConcStart)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     x \\<notin> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                        insertDenies ys)));\n     ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (DenyAllFromTo a b \\<oplus>\n                          DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n                       x", "apply (metis DenyAllFromTo l2p_aux2 list2FWpolicyconc nlpaux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Cp (list2FWpolicy\n       (DenyAllFromTo a b \\<oplus>\n        DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n        insertDenies ys))\n   x =\n  \\<lfloor>deny ()\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "case (AllowPortFromTo a b c)"], ["proof (state)\nthis:\n  y = AllowPortFromTo a b c\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>\n 2. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = AllowPortFromTo a b c", "show ?thesis"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a b c\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy\n                      (insertDenies (y # ys)))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "using Cons AllowPortFromTo"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a b c\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  y = AllowPortFromTo a b c\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy\n                      (insertDenies (y # ys)))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "proof (cases \"ys = []\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys = []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (y # ys)))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (y # ys)))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "case 1"], ["proof (state)\nthis:\n  y = AllowPortFromTo a b c\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  y = AllowPortFromTo a b c\n  ys = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys = []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (y # ys)))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (y # ys)))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = AllowPortFromTo a b c\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  y = AllowPortFromTo a b c\n  ys = []", "show ?case"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a b c\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  y = AllowPortFromTo a b c\n  ys = []\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy\n                      (insertDenies (y # ys)))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "apply (simp,intro impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys = []; y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys = [];\n     x \\<notin> dom (Cp (AllowPortFromTo a b c));\n     x \\<in> dom (Cp (DenyAllFromTo a b \\<oplus>\n                      DenyAllFromTo b a \\<oplus>\n                      AllowPortFromTo a b c))\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo a b \\<oplus>\n                          DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (subgoal_tac \"x \\<in> dom (Cp (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys = []; y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys = [];\n     x \\<notin> dom (Cp (AllowPortFromTo a b c));\n     x \\<in> dom (Cp (DenyAllFromTo a b \\<oplus>\n                      DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c));\n     x \\<in> dom (Cp (DenyAllFromTo a b \\<oplus>\n                      DenyAllFromTo b a))\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo a b \\<oplus>\n                          DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = AllowPortFromTo a b c; ys = []; y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys = [];\n     x \\<notin> dom (Cp (AllowPortFromTo a b c));\n     x \\<in> dom (Cp (DenyAllFromTo a b \\<oplus>\n                      DenyAllFromTo b a \\<oplus>\n                      AllowPortFromTo a b c))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (DenyAllFromTo a b \\<oplus>\n DenyAllFromTo b a))", "apply (auto simp: PLemmas split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (y # ys)))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (y # ys)))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "case 2"], ["proof (state)\nthis:\n  y = AllowPortFromTo a b c\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  y = AllowPortFromTo a b c\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (y # ys)))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = AllowPortFromTo a b c\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  y = AllowPortFromTo a b c\n  ys \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a b c\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>\n  y = AllowPortFromTo a b c\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy\n                      (insertDenies (y # ys)))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "apply (simp, intro impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy\n                               (insertDenies ys))) \\<longrightarrow>\n             Cp (list2FWpolicy (insertDenies ys)) x =\n             \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> []; y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                        insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (drule mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                        insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp (list2FWpolicy ys))\n 2. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                        insertDenies ys)));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x =\n     \\<lfloor>deny ()\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (metis AllowPortFromTo InDomConc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     y = AllowPortFromTo a b c;\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                        insertDenies ys)));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys))) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x =\n     \\<lfloor>deny ()\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (cases \"x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\",simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                        insertDenies ys)));\n     Cp (list2FWpolicy (insertDenies ys)) x = \\<lfloor>deny ()\\<rfloor>;\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (metis AllowPortFromTo Cdom2 idNMT list2FWpolicyconc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (subgoal_tac \"Cp (list2FWpolicy (DenyAllFromTo a b \\<oplus>\n                                                    DenyAllFromTo b a \\<oplus> \n                                                    AllowPortFromTo a b c#insertDenies ys)) x =\n                                 Cp ((DenyAllFromTo a b \\<oplus> DenyAllFromTo b a)) x \")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo a b \\<oplus>\n           DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n           insertDenies ys))\n      x =\n     Cp (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a) x\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a) x", "apply (auto simp: PLemmas split: if_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo a b \\<oplus>\n                        DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a) x", "by (metis AllowPortFromTo CConcStartA ConcAssoc idNMT list2FWpolicyconc nlpaux)"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "case (Conc a b)"], ["proof (state)\nthis:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>ys \\<noteq> [] \\<longrightarrow>\n                x \\<notin> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy\n                                  (insertDenies ys))) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                \\<lfloor>deny ()\\<rfloor>;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<notin> dom (Cp\n    (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = a \\<oplus> b", "show ?thesis"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy\n                      (insertDenies (y # ys)))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "proof (cases \"ys = []\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys = []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (y # ys)))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (y # ys)))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "case 1"], ["proof (state)\nthis:\n  y = a \\<oplus> b\n  ys = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys = []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (y # ys)))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (y # ys)))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = a \\<oplus> b\n  ys = []", "show ?case"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n  ys = []\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy\n                      (insertDenies (y # ys)))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "apply(simp,intro impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys = []; y = a \\<oplus> b; ys = [];\n     x \\<notin> dom (Cp (a \\<oplus> b));\n     x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                       (first_destNet a) \\<oplus>\n                      DenyAllFromTo (first_destNet a)\n                       (first_srcNet a) \\<oplus>\n                      a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a \\<oplus> b)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (subgoal_tac \"x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus> \n                                             DenyAllFromTo (first_destNet a) (first_srcNet a)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys = []; y = a \\<oplus> b; ys = [];\n     x \\<notin> dom (Cp (a \\<oplus> b));\n     x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                       (first_destNet a) \\<oplus>\n                      DenyAllFromTo (first_destNet a)\n                       (first_srcNet a) \\<oplus>\n                      a \\<oplus> b));\n     x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                       (first_destNet a) \\<oplus>\n                      DenyAllFromTo (first_destNet a)\n                       (first_srcNet a)))\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a \\<oplus> b)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = a \\<oplus> b; ys = []; y = a \\<oplus> b; ys = [];\n     x \\<notin> dom (Cp (a \\<oplus> b));\n     x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                       (first_destNet a) \\<oplus>\n                      DenyAllFromTo (first_destNet a)\n                       (first_srcNet a) \\<oplus>\n                      a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n  (first_destNet a) \\<oplus>\n DenyAllFromTo (first_destNet a) (first_srcNet a)))", "by (auto simp: PLemmas split: if_splits)"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (y # ys)))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (y # ys)))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "case 2"], ["proof (state)\nthis:\n  y = a \\<oplus> b\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<notin> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (insertDenies (y # ys)))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      \\<lfloor>deny ()\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  y = a \\<oplus> b\n  ys \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy\n                      (insertDenies (y # ys)))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>", "apply(simp,intro impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []; y = a \\<oplus> b;\n     ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply(cases \"x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []; y = a \\<oplus> b;\n     ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []; y = a \\<oplus> b;\n     ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (metis Cdom2 Conc Cons InDomConc idNMT list2FWpolicyconc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []; y = a \\<oplus> b;\n     ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (subgoal_tac \"Cp (list2FWpolicy(DenyAllFromTo (first_srcNet a)(first_destNet a) \\<oplus> \n                                                   DenyAllFromTo (first_destNet a) (first_srcNet a)\\<oplus> \n                                                   a \\<oplus> b#insertDenies ys)) x =\n                                 Cp ((DenyAllFromTo(first_srcNet a)  (first_destNet a) \\<oplus>\n                                      DenyAllFromTo (first_destNet a)(first_srcNet  a) \\<oplus> a \\<oplus> b)) x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []; y = a \\<oplus> b;\n     ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n           DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n           a \\<oplus> b #\n           insertDenies ys))\n      x =\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n         a \\<oplus> b)\n      x\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []; y = a \\<oplus> b;\n     ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a \\<oplus> b)\n                       x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n           DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n           a \\<oplus> b #\n           insertDenies ys))\n      x =\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n         a \\<oplus> b)\n      x\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a \\<oplus> b)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []; y = a \\<oplus> b;\n     ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a \\<oplus> b)\n                       x", "defer 1"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> []; y = a \\<oplus> b;\n     ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a \\<oplus> b)\n                       x\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n           DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n           a \\<oplus> b #\n           insertDenies ys))\n      x =\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n         a \\<oplus> b)\n      x\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a \\<oplus> b)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (metis Conc l2p_aux2 list2FWpolicyconc nlpaux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n           DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n           a \\<oplus> b #\n           insertDenies ys))\n      x =\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n         a \\<oplus> b)\n      x\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a \\<oplus> b)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (subgoal_tac \"Cp((DenyAllFromTo(first_srcNet a)(first_destNet a) \\<oplus> \n                                     DenyAllFromTo (first_destNet a)(first_srcNet a)\\<oplus> a \\<oplus> b)) x = \n                                 Cp((DenyAllFromTo (first_srcNet a)(first_destNet a)\\<oplus> \n                                     DenyAllFromTo (first_destNet a)  (first_srcNet a))) x \")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n           DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n           a \\<oplus> b #\n           insertDenies ys))\n      x =\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n         a \\<oplus> b)\n      x;\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n         a \\<oplus> b)\n      x =\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a))\n      x\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a \\<oplus> b)\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n           DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n           a \\<oplus> b #\n           insertDenies ys))\n      x =\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n         a \\<oplus> b)\n      x\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a \\<oplus> b)\n                       x =\n                      Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a) (first_srcNet a))\n                       x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n           DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n           a \\<oplus> b #\n           insertDenies ys))\n      x =\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a))\n      x;\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n         a \\<oplus> b)\n      x =\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a))\n      x\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a) (first_srcNet a))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n           DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n           a \\<oplus> b #\n           insertDenies ys))\n      x =\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n         a \\<oplus> b)\n      x\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a \\<oplus> b)\n                       x =\n                      Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a) (first_srcNet a))\n                       x", "defer 1"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n           DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n           a \\<oplus> b #\n           insertDenies ys))\n      x =\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n         a \\<oplus> b)\n      x\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a \\<oplus> b)\n                       x =\n                      Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a) (first_srcNet a))\n                       x\n 2. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n           DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n           a \\<oplus> b #\n           insertDenies ys))\n      x =\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a))\n      x;\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n         a \\<oplus> b)\n      x =\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a))\n      x\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a) (first_srcNet a))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "apply (metis CConcStartA Conc ConcAssoc nlpaux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     x \\<in> dom (Cp (list2FWpolicy\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a \\<oplus> b #\n                        insertDenies ys)));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n           DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n           a \\<oplus> b #\n           insertDenies ys))\n      x =\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a))\n      x;\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus>\n         a \\<oplus> b)\n      x =\n     Cp (DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n         DenyAllFromTo (first_destNet a) (first_srcNet a))\n      x\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a) (first_srcNet a))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>", "by (auto simp: PLemmas split: if_splits)"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<notin> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (insertDenies (y # ys)))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies (y # ys))) x = \\<lfloor>deny ()\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iD_isD[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow> \n   Cp (DenyAll \\<oplus> list2FWpolicy (insertDenies p)) x = Cp DenyAll x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n    Cp (DenyAll \\<oplus> list2FWpolicy (insertDenies p)) x = Cp DenyAll x", "apply (case_tac \"x \\<in> dom (Cp (list2FWpolicy (insertDenies p)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> dom (Cp (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n    p \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n    Cp (DenyAll \\<oplus> list2FWpolicy (insertDenies p)) x = Cp DenyAll x\n 2. x \\<notin> dom (Cp (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n    p \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n    Cp (DenyAll \\<oplus> list2FWpolicy (insertDenies p)) x = Cp DenyAll x", "apply (simp add: Cp.simps(1) Cdom2 iDdomAux deny_all_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom (Cp (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n    p \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n    Cp (DenyAll \\<oplus> list2FWpolicy (insertDenies p)) x = Cp DenyAll x", "using NormalisationIPPProofs.nlpaux"], ["proof (prove)\nusing this:\n  ?x \\<notin> dom (Cp ?b) \\<Longrightarrow>\n  Cp (?a \\<oplus> ?b) ?x = Cp ?a ?x\n\ngoal (1 subgoal):\n 1. x \\<notin> dom (Cp (list2FWpolicy (insertDenies p))) \\<Longrightarrow>\n    p \\<noteq> [] \\<longrightarrow>\n    x \\<notin> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n    Cp (DenyAll \\<oplus> list2FWpolicy (insertDenies p)) x = Cp DenyAll x", "by blast"], ["", "lemma inDomConc:\n  \"x\\<notin>dom (Cp a) \\<Longrightarrow> x\\<notin>dom (Cp (list2FWpolicy p)) \\<Longrightarrow> x \\<notin> dom (Cp (list2FWpolicy(a#p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> dom (Cp a);\n     x \\<notin> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp (list2FWpolicy (a # p)))", "by (metis domdConcStart)"], ["", "lemma domsdisj[rule_format]: \n  \"p \\<noteq> [] \\<longrightarrow> (\\<forall> x s. s \\<in> set p \\<and> x \\<in> dom (Cp A) \\<longrightarrow>  x \\<notin> dom (Cp s)) \\<longrightarrow> y \\<in> dom (Cp A) \\<longrightarrow>\n   y \\<notin> dom (Cp (list2FWpolicy p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x s.\n        s \\<in> set p \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n        x \\<notin> dom (Cp s)) \\<longrightarrow>\n    y \\<in> dom (Cp A) \\<longrightarrow>\n    y \\<notin> dom (Cp (list2FWpolicy p))", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x s.\n        s \\<in> set [] \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n        x \\<notin> dom (Cp s)) \\<longrightarrow>\n    y \\<in> dom (Cp A) \\<longrightarrow>\n    y \\<notin> dom (Cp (list2FWpolicy []))\n 2. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set p \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n           x \\<notin> dom (Cp s)) \\<longrightarrow>\n       y \\<in> dom (Cp A) \\<longrightarrow>\n       y \\<notin> dom (Cp (list2FWpolicy p)) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set (a # p) \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n           x \\<notin> dom (Cp s)) \\<longrightarrow>\n       y \\<in> dom (Cp A) \\<longrightarrow>\n       y \\<notin> dom (Cp (list2FWpolicy (a # p)))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x s.\n        s \\<in> set [] \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n        x \\<notin> dom (Cp s)) \\<longrightarrow>\n    y \\<in> dom (Cp A) \\<longrightarrow>\n    y \\<notin> dom (Cp (list2FWpolicy []))\n 2. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set p \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n           x \\<notin> dom (Cp s)) \\<longrightarrow>\n       y \\<in> dom (Cp A) \\<longrightarrow>\n       y \\<notin> dom (Cp (list2FWpolicy p)) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set (a # p) \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n           x \\<notin> dom (Cp s)) \\<longrightarrow>\n       y \\<in> dom (Cp A) \\<longrightarrow>\n       y \\<notin> dom (Cp (list2FWpolicy (a # p)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x s.\n        s \\<in> set [] \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n        x \\<notin> dom (Cp s)) \\<longrightarrow>\n    y \\<in> dom (Cp A) \\<longrightarrow>\n    y \\<notin> dom (Cp (list2FWpolicy []))", "by simp"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  (\\<forall>x s.\n      s \\<in> set [] \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n      x \\<notin> dom (Cp s)) \\<longrightarrow>\n  y \\<in> dom (Cp A) \\<longrightarrow>\n  y \\<notin> dom (Cp (list2FWpolicy []))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set p \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n           x \\<notin> dom (Cp s)) \\<longrightarrow>\n       y \\<in> dom (Cp A) \\<longrightarrow>\n       y \\<notin> dom (Cp (list2FWpolicy p)) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set (a # p) \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n           x \\<notin> dom (Cp s)) \\<longrightarrow>\n       y \\<in> dom (Cp A) \\<longrightarrow>\n       y \\<notin> dom (Cp (list2FWpolicy (a # p)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set p \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n           x \\<notin> dom (Cp s)) \\<longrightarrow>\n       y \\<in> dom (Cp A) \\<longrightarrow>\n       y \\<notin> dom (Cp (list2FWpolicy p)) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set (a # p) \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n           x \\<notin> dom (Cp s)) \\<longrightarrow>\n       y \\<in> dom (Cp A) \\<longrightarrow>\n       y \\<notin> dom (Cp (list2FWpolicy (a # p)))", "case (Cons a p)"], ["proof (state)\nthis:\n  p \\<noteq> [] \\<longrightarrow>\n  (\\<forall>x s.\n      s \\<in> set p \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n      x \\<notin> dom (Cp s)) \\<longrightarrow>\n  y \\<in> dom (Cp A) \\<longrightarrow> y \\<notin> dom (Cp (list2FWpolicy p))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set p \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n           x \\<notin> dom (Cp s)) \\<longrightarrow>\n       y \\<in> dom (Cp A) \\<longrightarrow>\n       y \\<notin> dom (Cp (list2FWpolicy p)) \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x s.\n           s \\<in> set (a # p) \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n           x \\<notin> dom (Cp s)) \\<longrightarrow>\n       y \\<in> dom (Cp A) \\<longrightarrow>\n       y \\<notin> dom (Cp (list2FWpolicy (a # p)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a # p \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x s.\n        s \\<in> set (a # p) \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n        x \\<notin> dom (Cp s)) \\<longrightarrow>\n    y \\<in> dom (Cp A) \\<longrightarrow>\n    y \\<notin> dom (Cp (list2FWpolicy (a # p)))", "apply (case_tac \"p = []\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    (\\<forall>aa ab ac b ad ae ba bb.\n        (aa, (ab, ac, b), (ad, ae, ba), bb)\n        \\<in> dom (Cp A) \\<longrightarrow>\n        (aa, (ab, ac, b), (ad, ae, ba), bb)\n        \\<notin> dom (Cp a)) \\<longrightarrow>\n    y \\<in> dom (Cp A) \\<longrightarrow> y \\<notin> dom (Cp a)\n 2. p \\<noteq> [] \\<Longrightarrow>\n    a # p \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x s.\n        s \\<in> set (a # p) \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n        x \\<notin> dom (Cp s)) \\<longrightarrow>\n    y \\<in> dom (Cp A) \\<longrightarrow>\n    y \\<notin> dom (Cp (list2FWpolicy (a # p)))", "apply (rule_tac x = y in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    \\<forall>x.\n       (\\<forall>aa ab ac b ad ae ba bb.\n           (aa, (ab, ac, b), (ad, ae, ba), bb)\n           \\<in> dom (Cp A) \\<longrightarrow>\n           (aa, (ab, ac, b), (ad, ae, ba), bb)\n           \\<notin> dom (Cp a)) \\<longrightarrow>\n       x \\<in> dom (Cp A) \\<longrightarrow> x \\<notin> dom (Cp a)\n 2. p \\<noteq> [] \\<Longrightarrow>\n    a # p \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x s.\n        s \\<in> set (a # p) \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n        x \\<notin> dom (Cp s)) \\<longrightarrow>\n    y \\<in> dom (Cp A) \\<longrightarrow>\n    y \\<notin> dom (Cp (list2FWpolicy (a # p)))", "apply (simp add: split_tupled_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    a # p \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x s.\n        s \\<in> set (a # p) \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n        x \\<notin> dom (Cp s)) \\<longrightarrow>\n    y \\<in> dom (Cp A) \\<longrightarrow>\n    y \\<notin> dom (Cp (list2FWpolicy (a # p)))", "by (metis Cons.hyps inDomConc list.set_intros(1) list.set_intros(2))"], ["proof (state)\nthis:\n  a # p \\<noteq> [] \\<longrightarrow>\n  (\\<forall>x s.\n      s \\<in> set (a # p) \\<and> x \\<in> dom (Cp A) \\<longrightarrow>\n      x \\<notin> dom (Cp s)) \\<longrightarrow>\n  y \\<in> dom (Cp A) \\<longrightarrow>\n  y \\<notin> dom (Cp (list2FWpolicy (a # p)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isSepaux:\n  \"p \\<noteq> [] \\<Longrightarrow> noDenyAll (a#p) \\<Longrightarrow> separated (a # p) \\<Longrightarrow>\n   x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)  (first_destNet a) \\<oplus>\n                DenyAllFromTo (first_destNet a) (first_srcNet a)  \\<oplus> a)) \\<Longrightarrow>\n   x \\<notin> dom (Cp (list2FWpolicy p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; noDenyAll (a # p); separated (a # p);\n     x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                       (first_destNet a) \\<oplus>\n                      DenyAllFromTo (first_destNet a)\n                       (first_srcNet a) \\<oplus>\n                      a))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp (list2FWpolicy p))", "apply (rule_tac A = \"(DenyAllFromTo (first_srcNet  a) (first_destNet a) \\<oplus>\n                      DenyAllFromTo (first_destNet a) (first_srcNet  a) \\<oplus> a)\" in domsdisj, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa s.\n       \\<lbrakk>p \\<noteq> []; \\<not> member DenyAll a \\<and> noDenyAll p;\n        (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n        separated p;\n        x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a));\n        s \\<in> set p \\<and>\n        xa \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a))\\<rbrakk>\n       \\<Longrightarrow> xa \\<notin> dom (Cp s)", "apply (rule notI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa s.\n       \\<lbrakk>p \\<noteq> []; \\<not> member DenyAll a \\<and> noDenyAll p;\n        (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n        separated p;\n        x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                          (first_destNet a) \\<oplus>\n                         DenyAllFromTo (first_destNet a)\n                          (first_srcNet a) \\<oplus>\n                         a));\n        s \\<in> set p \\<and>\n        xa \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a));\n        xa \\<in> dom (Cp s)\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for xa s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; \\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                       (first_destNet a) \\<oplus>\n                      DenyAllFromTo (first_destNet a)\n                       (first_srcNet a) \\<oplus>\n                      a));\n     s \\<in> set p \\<and>\n     xa \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a));\n     xa \\<in> dom (Cp s)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule_tac p = xa and x =\"(DenyAllFromTo (first_srcNet a) (first_destNet a) \\<oplus>\n                               DenyAllFromTo (first_destNet a) (first_srcNet  a) \\<oplus> a)\" \n        and y = s in disjSD_no_p_in_both, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; \\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                       (first_destNet a) \\<oplus>\n                      DenyAllFromTo (first_destNet a)\n                       (first_srcNet a) \\<oplus>\n                      a));\n     s \\<in> set p \\<and>\n     xa \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a));\n     xa \\<in> dom (Cp s)\\<rbrakk>\n    \\<Longrightarrow> disjSD_2\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a)\n                       s\n 2. \\<lbrakk>p \\<noteq> []; \\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                       (first_destNet a) \\<oplus>\n                      DenyAllFromTo (first_destNet a)\n                       (first_srcNet a) \\<oplus>\n                      a));\n     s \\<in> set p \\<and>\n     xa \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a));\n     xa \\<in> dom (Cp s)\\<rbrakk>\n    \\<Longrightarrow> \\<not> member DenyAll s", "using disjSD2aux noDA"], ["proof (prove)\nusing this:\n  \\<lbrakk>disjSD_2 ?a ?b; \\<not> member DenyAll ?a;\n   \\<not> member DenyAll ?b\\<rbrakk>\n  \\<Longrightarrow> disjSD_2\n                     (DenyAllFromTo (first_srcNet ?a)\n                       (first_destNet ?a) \\<oplus>\n                      DenyAllFromTo (first_destNet ?a)\n                       (first_srcNet ?a) \\<oplus>\n                      ?a)\n                     ?b\n  \\<lbrakk>noDenyAll ?xs; ?s \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> \\<not> member DenyAll ?s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> []; \\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                       (first_destNet a) \\<oplus>\n                      DenyAllFromTo (first_destNet a)\n                       (first_srcNet a) \\<oplus>\n                      a));\n     s \\<in> set p \\<and>\n     xa \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a));\n     xa \\<in> dom (Cp s)\\<rbrakk>\n    \\<Longrightarrow> disjSD_2\n                       (DenyAllFromTo (first_srcNet a)\n                         (first_destNet a) \\<oplus>\n                        DenyAllFromTo (first_destNet a)\n                         (first_srcNet a) \\<oplus>\n                        a)\n                       s\n 2. \\<lbrakk>p \\<noteq> []; \\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                       (first_destNet a) \\<oplus>\n                      DenyAllFromTo (first_destNet a)\n                       (first_srcNet a) \\<oplus>\n                      a));\n     s \\<in> set p \\<and>\n     xa \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a));\n     xa \\<in> dom (Cp s)\\<rbrakk>\n    \\<Longrightarrow> \\<not> member DenyAll s", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; \\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                       (first_destNet a) \\<oplus>\n                      DenyAllFromTo (first_destNet a)\n                       (first_srcNet a) \\<oplus>\n                      a));\n     s \\<in> set p \\<and>\n     xa \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a));\n     xa \\<in> dom (Cp s)\\<rbrakk>\n    \\<Longrightarrow> \\<not> member DenyAll s", "using noDA"], ["proof (prove)\nusing this:\n  \\<lbrakk>noDenyAll ?xs; ?s \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> \\<not> member DenyAll ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; \\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                       (first_destNet a) \\<oplus>\n                      DenyAllFromTo (first_destNet a)\n                       (first_srcNet a) \\<oplus>\n                      a));\n     s \\<in> set p \\<and>\n     xa \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n                        (first_destNet a) \\<oplus>\n                       DenyAllFromTo (first_destNet a)\n                        (first_srcNet a) \\<oplus>\n                       a));\n     xa \\<in> dom (Cp s)\\<rbrakk>\n    \\<Longrightarrow> \\<not> member DenyAll s", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma none_MT_rulessep[rule_format]: \"none_MT_rules Cp p \\<longrightarrow> none_MT_rules Cp (separate p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. none_MT_rules Cp p \\<longrightarrow> none_MT_rules Cp (separate p)", "by (induct p rule: separate.induct) (simp_all add: Cp.simps map_add_le_mapE map_le_antisym)"], ["", "lemma dom_id: \n  \"noDenyAll (a#p) \\<Longrightarrow> separated (a#p) \\<Longrightarrow> p \\<noteq> [] \\<Longrightarrow>\n   x \\<notin> dom (Cp (list2FWpolicy p)) \\<Longrightarrow> x \\<in> dom (Cp (a)) \\<Longrightarrow> \n   x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll (a # p); separated (a # p); p \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy p)); x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (Cp (list2FWpolicy (insertDenies p)))", "apply (rule_tac a = a in isSepaux, simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> insertDenies p \\<noteq> []\n 2. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll (insertDenies p)\n 3. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set (insertDenies p) \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated (insertDenies p)\n 4. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n  (first_destNet a) \\<oplus>\n DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a))", "using idNMT"], ["proof (prove)\nusing this:\n  ?p \\<noteq> [] \\<Longrightarrow> insertDenies ?p \\<noteq> []\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> insertDenies p \\<noteq> []\n 2. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll (insertDenies p)\n 3. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set (insertDenies p) \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated (insertDenies p)\n 4. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n  (first_destNet a) \\<oplus>\n DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a))", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll (insertDenies p)\n 2. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set (insertDenies p) \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated (insertDenies p)\n 3. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n  (first_destNet a) \\<oplus>\n DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a))", "using noDAID"], ["proof (prove)\nusing this:\n  noDenyAll ?p \\<Longrightarrow> noDenyAll (insertDenies ?p)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll (insertDenies p)\n 2. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set (insertDenies p) \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated (insertDenies p)\n 3. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n  (first_destNet a) \\<oplus>\n DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a))", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set (insertDenies p) \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated (insertDenies p)\n 2. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n  (first_destNet a) \\<oplus>\n DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a))", "using id_aux4 noDA1eq sepNetsID"], ["proof (prove)\nusing this:\n  \\<lbrakk>noDenyAll ?p;\n   \\<And>s. s \\<in> set ?p \\<Longrightarrow> disjSD_2 ?a s;\n   ?s \\<in> set (insertDenies ?p); \\<not> member DenyAll ?a\\<rbrakk>\n  \\<Longrightarrow> disjSD_2 ?a ?s\n  noDenyAll ?p \\<Longrightarrow> noDenyAll1 ?p\n  \\<lbrakk>noDenyAll1 ?p; separated ?p\\<rbrakk>\n  \\<Longrightarrow> separated (insertDenies ?p)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s.\n                          s \\<in> set (insertDenies p) \\<longrightarrow>\n                          disjSD_2 a s) \\<and>\n                      separated (insertDenies p)\n 2. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n  (first_destNet a) \\<oplus>\n DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> member DenyAll a \\<and> noDenyAll p;\n     (\\<forall>s. s \\<in> set p \\<longrightarrow> disjSD_2 a s) \\<and>\n     separated p;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p));\n     x \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (DenyAllFromTo (first_srcNet a)\n  (first_destNet a) \\<oplus>\n DenyAllFromTo (first_destNet a) (first_srcNet a) \\<oplus> a))", "by (simp add: NormalisationIPPProofs.Cdom2 domIff)"], ["", "lemma C_eq_iD_aux2[rule_format]: \n  \"noDenyAll1 p \\<longrightarrow> separated p\\<longrightarrow> p \\<noteq> []\\<longrightarrow> x \\<in> dom (Cp (list2FWpolicy p))\\<longrightarrow>\n  Cp(list2FWpolicy (insertDenies p)) x = Cp(list2FWpolicy p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 p \\<longrightarrow>\n    separated p \\<longrightarrow>\n    p \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies p)) x = Cp (list2FWpolicy p) x", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. noDenyAll1 [] \\<longrightarrow>\n    separated [] \\<longrightarrow>\n    [] \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies [])) x = Cp (list2FWpolicy []) x\n 2. \\<And>a p.\n       noDenyAll1 p \\<longrightarrow>\n       separated p \\<longrightarrow>\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies p)) x =\n       Cp (list2FWpolicy p) x \\<Longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       separated (a # p) \\<longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies (a # p))) x =\n       Cp (list2FWpolicy (a # p)) x", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. noDenyAll1 [] \\<longrightarrow>\n    separated [] \\<longrightarrow>\n    [] \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies [])) x = Cp (list2FWpolicy []) x\n 2. \\<And>a p.\n       noDenyAll1 p \\<longrightarrow>\n       separated p \\<longrightarrow>\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies p)) x =\n       Cp (list2FWpolicy p) x \\<Longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       separated (a # p) \\<longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies (a # p))) x =\n       Cp (list2FWpolicy (a # p)) x", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 [] \\<longrightarrow>\n    separated [] \\<longrightarrow>\n    [] \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies [])) x = Cp (list2FWpolicy []) x", "by simp"], ["proof (state)\nthis:\n  noDenyAll1 [] \\<longrightarrow>\n  separated [] \\<longrightarrow>\n  [] \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy [])) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies [])) x = Cp (list2FWpolicy []) x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       noDenyAll1 p \\<longrightarrow>\n       separated p \\<longrightarrow>\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies p)) x =\n       Cp (list2FWpolicy p) x \\<Longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       separated (a # p) \\<longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies (a # p))) x =\n       Cp (list2FWpolicy (a # p)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       noDenyAll1 p \\<longrightarrow>\n       separated p \\<longrightarrow>\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies p)) x =\n       Cp (list2FWpolicy p) x \\<Longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       separated (a # p) \\<longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies (a # p))) x =\n       Cp (list2FWpolicy (a # p)) x", "case (Cons y ys)"], ["proof (state)\nthis:\n  noDenyAll1 ys \\<longrightarrow>\n  separated ys \\<longrightarrow>\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       noDenyAll1 p \\<longrightarrow>\n       separated p \\<longrightarrow>\n       p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy p)) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies p)) x =\n       Cp (list2FWpolicy p) x \\<Longrightarrow>\n       noDenyAll1 (a # p) \\<longrightarrow>\n       separated (a # p) \\<longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       x \\<in> dom (Cp (list2FWpolicy (a # p))) \\<longrightarrow>\n       Cp (list2FWpolicy (insertDenies (a # p))) x =\n       Cp (list2FWpolicy (a # p)) x", "thus ?case"], ["proof (prove)\nusing this:\n  noDenyAll1 ys \\<longrightarrow>\n  separated ys \\<longrightarrow>\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x =\n    Cp (list2FWpolicy (y # ys)) x", "using Cons"], ["proof (prove)\nusing this:\n  noDenyAll1 ys \\<longrightarrow>\n  separated ys \\<longrightarrow>\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x\n  noDenyAll1 ys \\<longrightarrow>\n  separated ys \\<longrightarrow>\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x =\n    Cp (list2FWpolicy (y # ys)) x", "proof (cases y)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             separated ys \\<longrightarrow>\n             ys \\<noteq> [] \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n             Cp (list2FWpolicy (insertDenies ys)) x =\n             Cp (list2FWpolicy ys) x;\n     noDenyAll1 ys \\<longrightarrow>\n     separated ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                      separated (y # ys) \\<longrightarrow>\n                      y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (y # ys))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      Cp (list2FWpolicy (y # ys)) x\n 2. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x\n 4. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x", "case DenyAll"], ["proof (state)\nthis:\n  y = DenyAll\n\ngoal (4 subgoals):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             separated ys \\<longrightarrow>\n             ys \\<noteq> [] \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n             Cp (list2FWpolicy (insertDenies ys)) x =\n             Cp (list2FWpolicy ys) x;\n     noDenyAll1 ys \\<longrightarrow>\n     separated ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                      separated (y # ys) \\<longrightarrow>\n                      y # ys \\<noteq> [] \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (y # ys))) \\<longrightarrow>\n                      Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                      Cp (list2FWpolicy (y # ys)) x\n 2. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x\n 4. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = DenyAll\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x =\n    Cp (list2FWpolicy (y # ys)) x", "using Cons DenyAll"], ["proof (prove)\nusing this:\n  y = DenyAll\n  noDenyAll1 ys \\<longrightarrow>\n  separated ys \\<longrightarrow>\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x\n  y = DenyAll\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x =\n    Cp (list2FWpolicy (y # ys)) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             separated ys \\<longrightarrow>\n             ys \\<noteq> [] \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n             Cp (list2FWpolicy (insertDenies ys)) x =\n             Cp (list2FWpolicy ys) x;\n     y = DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll ys \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set ys \\<longrightarrow>\n                          disjSD_2 DenyAll s) \\<and>\n                      separated ys \\<longrightarrow>\n                      Cp (list2FWpolicy (DenyAll # insertDenies ys)) x =\n                      Cp (list2FWpolicy (DenyAll # ys)) x", "apply (case_tac \"ys = []\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             separated ys \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n             Cp (list2FWpolicy (insertDenies ys)) x =\n             Cp (list2FWpolicy ys) x;\n     y = DenyAll; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> noDenyAll ys \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set ys \\<longrightarrow>\n                          disjSD_2 DenyAll s) \\<and>\n                      separated ys \\<longrightarrow>\n                      Cp (list2FWpolicy (DenyAll # insertDenies ys)) x =\n                      Cp (list2FWpolicy (DenyAll # ys)) x", "apply (case_tac \"x \\<in> dom (Cp (list2FWpolicy ys))\",simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             separated ys \\<longrightarrow>\n             Cp (list2FWpolicy (insertDenies ys)) x =\n             Cp (list2FWpolicy ys) x;\n     y = DenyAll; ys \\<noteq> [];\n     x \\<in> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> noDenyAll ys \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set ys \\<longrightarrow>\n                          disjSD_2 DenyAll s) \\<and>\n                      separated ys \\<longrightarrow>\n                      Cp (list2FWpolicy (DenyAll # insertDenies ys)) x =\n                      Cp (list2FWpolicy (DenyAll # ys)) x\n 2. \\<lbrakk>y = DenyAll; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> noDenyAll ys \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set ys \\<longrightarrow>\n                          disjSD_2 DenyAll s) \\<and>\n                      separated ys \\<longrightarrow>\n                      Cp (list2FWpolicy (DenyAll # insertDenies ys)) x =\n                      Cp (list2FWpolicy (DenyAll # ys)) x", "apply (metis Cdom2 domID idNMT list2FWpolicyconc noDA1eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAll; ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> noDenyAll ys \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set ys \\<longrightarrow>\n                          disjSD_2 DenyAll s) \\<and>\n                      separated ys \\<longrightarrow>\n                      Cp (list2FWpolicy (DenyAll # insertDenies ys)) x =\n                      Cp (list2FWpolicy (DenyAll # ys)) x", "apply (metis DenyAll iD_isD idNMT list2FWpolicyconc nlpaux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  noDenyAll1 (y # ys) \\<longrightarrow>\n  separated (y # ys) \\<longrightarrow>\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies (y # ys))) x =\n  Cp (list2FWpolicy (y # ys)) x\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x\n 3. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x\n 3. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x", "case (DenyAllFromTo a b)"], ["proof (state)\nthis:\n  y = DenyAllFromTo a b\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = DenyAllFromTo x21 x22\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x\n 3. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x =\n    Cp (list2FWpolicy (y # ys)) x", "using Cons"], ["proof (prove)\nusing this:\n  y = DenyAllFromTo a b\n  noDenyAll1 ys \\<longrightarrow>\n  separated ys \\<longrightarrow>\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x =\n    Cp (list2FWpolicy (y # ys)) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     noDenyAll1 ys \\<longrightarrow>\n     separated ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x =\n     Cp (list2FWpolicy ys) x\\<rbrakk>\n    \\<Longrightarrow> noDenyAll ys \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set ys \\<longrightarrow>\n                          disjSD_2 (DenyAllFromTo a b) s) \\<and>\n                      separated ys \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (DenyAllFromTo a b # ys))) \\<longrightarrow>\n                      Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (rule impI|rule allI|rule conjI|simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     noDenyAll1 ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (case_tac \"ys = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b; x \\<in> dom (Cp (DenyAllFromTo a b));\n     ys = []\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo a b \\<oplus>\n                          DenyAllFromTo b a \\<oplus> DenyAllFromTo a b)\n                       x =\n                      Cp (DenyAllFromTo a b) x\n 2. \\<lbrakk>y = DenyAllFromTo a b;\n     noDenyAll1 ys \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (metis Cdom2 ConcAssoc DenyAllFromTo)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     noDenyAll1 ys \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (case_tac \"x \\<in> dom (Cp (list2FWpolicy ys))\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b;\n     noDenyAll1 ys \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x\n 2. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (drule mp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 ys\n 2. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x =\n     Cp (list2FWpolicy ys) x\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x\n 3. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (metis noDA1eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x =\n     Cp (list2FWpolicy ys) x\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x\n 2. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (case_tac \"x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x\n 2. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x\n 3. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (metis Cdom2 DenyAllFromTo idNMT list2FWpolicyconc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x\n 2. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (metis domID)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (case_tac \"x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x\n 2. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (subgoal_tac \"Cp (list2FWpolicy (DenyAllFromTo a b \\<oplus> DenyAllFromTo b a \\<oplus>\n                          DenyAllFromTo a b # insertDenies ys)) x = Some (deny ())\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo a b \\<oplus>\n           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n           insertDenies ys))\n      x =\n     \\<lfloor>deny ()\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x\n 2. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 3. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo a b \\<oplus>\n           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n           insertDenies ys))\n      x =\n     \\<lfloor>deny ()\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<lfloor>deny ()\\<rfloor> =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x\n 2. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 3. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (subgoal_tac \"Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x =\n                           Cp ((DenyAllFromTo a b)) x\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo a b \\<oplus>\n           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n           insertDenies ys))\n      x =\n     \\<lfloor>deny ()\\<rfloor>;\n     Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x =\n     Cp (DenyAllFromTo a b) x\\<rbrakk>\n    \\<Longrightarrow> \\<lfloor>deny ()\\<rfloor> =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x\n 2. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo a b \\<oplus>\n           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n           insertDenies ys))\n      x =\n     \\<lfloor>deny ()\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x =\n                      Cp (DenyAllFromTo a b) x\n 3. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 4. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (simp add: PLemmas, simp split: if_splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)));\n     Cp (list2FWpolicy\n          (DenyAllFromTo a b \\<oplus>\n           DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n           insertDenies ys))\n      x =\n     \\<lfloor>deny ()\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x =\n                      Cp (DenyAllFromTo a b) x\n 2. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 3. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (metis list2FWpolicyconc nlpaux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      \\<lfloor>deny ()\\<rfloor>\n 2. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (metis Cdom2 DenyAllFromTo iD_isD iDdomAux idNMT list2FWpolicyconc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = DenyAllFromTo a b; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (DenyAllFromTo a b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (DenyAllFromTo a b # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus> DenyAllFromTo a b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (DenyAllFromTo a b # ys)) x", "apply (metis Cdom2 DenyAllFromTo domIff idNMT list2FWpolicyconc nlpaux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  noDenyAll1 (y # ys) \\<longrightarrow>\n  separated (y # ys) \\<longrightarrow>\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies (y # ys))) x =\n  Cp (list2FWpolicy (y # ys)) x\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x\n 2. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x\n 2. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x", "case (AllowPortFromTo a b c)"], ["proof (state)\nthis:\n  y = AllowPortFromTo a b c\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = AllowPortFromTo x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x\n 2. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a b c\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x =\n    Cp (list2FWpolicy (y # ys)) x", "using AllowPortFromTo Cons"], ["proof (prove)\nusing this:\n  y = AllowPortFromTo a b c\n  y = AllowPortFromTo a b c\n  noDenyAll1 ys \\<longrightarrow>\n  separated ys \\<longrightarrow>\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x =\n    Cp (list2FWpolicy (y # ys)) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     noDenyAll1 ys \\<longrightarrow>\n     separated ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x =\n     Cp (list2FWpolicy ys) x\\<rbrakk>\n    \\<Longrightarrow> noDenyAll ys \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set ys \\<longrightarrow>\n                          disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n                      separated ys \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (AllowPortFromTo a b c # ys))) \\<longrightarrow>\n                      Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (rule impI|rule allI|rule conjI|simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     noDenyAll1 ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (case_tac \"ys = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     x \\<in> dom (Cp (AllowPortFromTo a b c)); ys = []\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo a b \\<oplus>\n                          DenyAllFromTo b a \\<oplus> AllowPortFromTo a b c)\n                       x =\n                      Cp (AllowPortFromTo a b c) x\n 2. \\<lbrakk>y = AllowPortFromTo a b c;\n     noDenyAll1 ys \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (metis Cdom2 ConcAssoc AllowPortFromTo)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     noDenyAll1 ys \\<longrightarrow>\n     x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (case_tac \"x \\<in> dom (Cp (list2FWpolicy ys))\",simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c;\n     noDenyAll1 ys \\<longrightarrow>\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x\n 2. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (drule mp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 ys\n 2. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x =\n     Cp (list2FWpolicy ys) x\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x\n 3. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (metis noDA1eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x =\n     Cp (list2FWpolicy ys) x\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x\n 2. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (case_tac \"x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x\n 2. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x\n 3. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (metis Cdom2 AllowPortFromTo idNMT list2FWpolicyconc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x\n 2. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (metis domID)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x", "apply (subgoal_tac \"x \\<in> dom (Cp (AllowPortFromTo a b c))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (AllowPortFromTo a b c))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x\n 2. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (AllowPortFromTo a b c))", "apply (case_tac \"x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (AllowPortFromTo a b c));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x\n 2. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (AllowPortFromTo a b c));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x\n 3. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (AllowPortFromTo a b c))", "apply (metis AllowPortFromTo Cdom2 ConcAssoc l2p_aux2 list2FWpolicyconc nlpaux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (AllowPortFromTo a b c));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo a b \\<oplus>\n                            DenyAllFromTo b a \\<oplus>\n                            AllowPortFromTo a b c #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (AllowPortFromTo a b c # ys)) x\n 2. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (AllowPortFromTo a b c))", "apply (meson Combinators.distinct(3) FWNormalisationCore.member.simps(4) NormalisationIPPProofs.dom_id noDenyAll.simps(1) separated.simps(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = AllowPortFromTo a b c; noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow>\n         disjSD_2 (AllowPortFromTo a b c) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (AllowPortFromTo a b c # ys)));\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom (Cp (AllowPortFromTo a b c))", "apply (metis AllowPortFromTo domdConcStart)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  noDenyAll1 (y # ys) \\<longrightarrow>\n  separated (y # ys) \\<longrightarrow>\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies (y # ys))) x =\n  Cp (list2FWpolicy (y # ys)) x\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x", "case (Conc a b)"], ["proof (state)\nthis:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n                separated ys \\<longrightarrow>\n                ys \\<noteq> [] \\<longrightarrow>\n                x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n                Cp (list2FWpolicy (insertDenies ys)) x =\n                Cp (list2FWpolicy ys) x;\n        noDenyAll1 ys \\<longrightarrow>\n        separated ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow>\n        x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n        Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n        y = x41 \\<oplus> x42\\<rbrakk>\n       \\<Longrightarrow> noDenyAll1 (y # ys) \\<longrightarrow>\n                         separated (y # ys) \\<longrightarrow>\n                         y # ys \\<noteq> [] \\<longrightarrow>\n                         x \\<in> dom (Cp\n (list2FWpolicy (y # ys))) \\<longrightarrow>\n                         Cp (list2FWpolicy (insertDenies (y # ys))) x =\n                         Cp (list2FWpolicy (y # ys)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x =\n    Cp (list2FWpolicy (y # ys)) x", "using Cons Conc"], ["proof (prove)\nusing this:\n  y = a \\<oplus> b\n  noDenyAll1 ys \\<longrightarrow>\n  separated ys \\<longrightarrow>\n  ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x\n  y = a \\<oplus> b\n\ngoal (1 subgoal):\n 1. noDenyAll1 (y # ys) \\<longrightarrow>\n    separated (y # ys) \\<longrightarrow>\n    y # ys \\<noteq> [] \\<longrightarrow>\n    x \\<in> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n    Cp (list2FWpolicy (insertDenies (y # ys))) x =\n    Cp (list2FWpolicy (y # ys)) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             separated ys \\<longrightarrow>\n             ys \\<noteq> [] \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n             Cp (list2FWpolicy (insertDenies ys)) x =\n             Cp (list2FWpolicy ys) x;\n     y = a \\<oplus> b\\<rbrakk>\n    \\<Longrightarrow> \\<not> member DenyAll a \\<and>\n                      \\<not> member DenyAll b \\<and>\n                      noDenyAll ys \\<longrightarrow>\n                      (\\<forall>s.\n                          s \\<in> set ys \\<longrightarrow>\n                          disjSD_2 (a \\<oplus> b) s) \\<and>\n                      separated ys \\<longrightarrow>\n                      x \\<in> dom (Cp (list2FWpolicy\n  (a \\<oplus> b # ys))) \\<longrightarrow>\n                      Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (intro impI allI conjI|simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             ys \\<noteq> [] \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n             Cp (list2FWpolicy (insertDenies ys)) x =\n             Cp (list2FWpolicy ys) x;\n     y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (case_tac \"ys = []\",simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and> \\<not> member DenyAll b;\n     x \\<in> dom (Cp (a \\<oplus> b)); ys = []\\<rbrakk>\n    \\<Longrightarrow> Cp (DenyAllFromTo (first_srcNet a)\n                           (first_destNet a) \\<oplus>\n                          DenyAllFromTo (first_destNet a)\n                           (first_srcNet a) \\<oplus>\n                          a \\<oplus> b)\n                       x =\n                      Cp (a \\<oplus> b) x\n 2. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n             Cp (list2FWpolicy (insertDenies ys)) x =\n             Cp (list2FWpolicy ys) x;\n     y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (metis Cdom2 ConcAssoc Conc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             x \\<in> dom (Cp (list2FWpolicy ys)) \\<longrightarrow>\n             Cp (list2FWpolicy (insertDenies ys)) x =\n             Cp (list2FWpolicy ys) x;\n     y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys)));\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (case_tac \"x \\<in> dom (Cp (list2FWpolicy ys))\",simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>noDenyAll1 ys \\<longrightarrow>\n             Cp (list2FWpolicy (insertDenies ys)) x =\n             Cp (list2FWpolicy ys) x;\n     y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<in> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (drule mp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<in> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 ys\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x =\n     Cp (list2FWpolicy ys) x\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 3. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (metis noDA1eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x =\n     Cp (list2FWpolicy ys) x\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (case_tac \"x \\<in> dom (Cp (a \\<oplus> b))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<in> dom (Cp (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<notin> dom (Cp (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 3. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (case_tac \"x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\", simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<in> dom (Cp (a \\<oplus> b));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<in> dom (Cp (a \\<oplus> b));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 3. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<notin> dom (Cp (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 4. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (subst list2FWpolicyconc)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<in> dom (Cp (a \\<oplus> b));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> insertDenies ys \\<noteq> []\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<in> dom (Cp (a \\<oplus> b));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp ((DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b) \\<oplus>\n                          list2FWpolicy (insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 3. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<in> dom (Cp (a \\<oplus> b));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 4. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<notin> dom (Cp (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 5. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (rule idNMT, simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<in> dom (Cp (a \\<oplus> b));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp ((DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b) \\<oplus>\n                          list2FWpolicy (insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<in> dom (Cp (a \\<oplus> b));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 3. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<notin> dom (Cp (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 4. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (metis domID)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<in> dom (Cp (a \\<oplus> b));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<notin> dom (Cp (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 3. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (metis Cdom2 Conc idNMT list2FWpolicyconc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<in> dom (Cp (list2FWpolicy ys));\n     Cp (list2FWpolicy (insertDenies ys)) x = Cp (list2FWpolicy ys) x;\n     x \\<notin> dom (Cp (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (metis Cdom2 Conc domIff idNMT list2FWpolicyconc )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (case_tac \"x \\<in> dom (Cp (a \\<oplus> b))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<notin> dom (Cp (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (case_tac \"x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (a \\<oplus> b));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (a \\<oplus> b));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 3. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<notin> dom (Cp (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (subst list2FWpolicyconc)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (a \\<oplus> b));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> insertDenies ys \\<noteq> []\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (a \\<oplus> b));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp ((DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b) \\<oplus>\n                          list2FWpolicy (insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 3. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (a \\<oplus> b));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 4. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<notin> dom (Cp (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (rule idNMT, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (a \\<oplus> b));\n     x \\<notin> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp ((DenyAllFromTo (first_srcNet a)\n                            (first_destNet a) \\<oplus>\n                           DenyAllFromTo (first_destNet a)\n                            (first_srcNet a) \\<oplus>\n                           a \\<oplus> b) \\<oplus>\n                          list2FWpolicy (insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (a \\<oplus> b));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 3. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<notin> dom (Cp (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (metis Cdom2 Conc ConcAssoc list2FWpolicyconc nlpaux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     ys \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<in> dom (Cp (a \\<oplus> b));\n     x \\<in> dom (Cp (list2FWpolicy (insertDenies ys)))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x\n 2. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<notin> dom (Cp (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (metis (lifting, no_types) FWNormalisationCore.member.simps(1) NormalisationIPPProofs.dom_id noDenyAll.simps(1) separated.simps(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = a \\<oplus> b;\n     \\<not> member DenyAll a \\<and>\n     \\<not> member DenyAll b \\<and> noDenyAll ys;\n     (\\<forall>s.\n         s \\<in> set ys \\<longrightarrow> disjSD_2 (a \\<oplus> b) s) \\<and>\n     separated ys;\n     x \\<in> dom (Cp (list2FWpolicy (a \\<oplus> b # ys))); ys \\<noteq> [];\n     x \\<notin> dom (Cp (list2FWpolicy ys));\n     x \\<notin> dom (Cp (a \\<oplus> b))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (DenyAllFromTo (first_srcNet a)\n                             (first_destNet a) \\<oplus>\n                            DenyAllFromTo (first_destNet a)\n                             (first_srcNet a) \\<oplus>\n                            a \\<oplus> b #\n                            insertDenies ys))\n                       x =\n                      Cp (list2FWpolicy (a \\<oplus> b # ys)) x", "apply (metis Conc domdConcStart)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  noDenyAll1 (y # ys) \\<longrightarrow>\n  separated (y # ys) \\<longrightarrow>\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies (y # ys))) x =\n  Cp (list2FWpolicy (y # ys)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  noDenyAll1 (y # ys) \\<longrightarrow>\n  separated (y # ys) \\<longrightarrow>\n  y # ys \\<noteq> [] \\<longrightarrow>\n  x \\<in> dom (Cp (list2FWpolicy (y # ys))) \\<longrightarrow>\n  Cp (list2FWpolicy (insertDenies (y # ys))) x =\n  Cp (list2FWpolicy (y # ys)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_iD: \n  \"separated p \\<Longrightarrow> noDenyAll1 p \\<Longrightarrow> wellformed_policy1_strong p  \\<Longrightarrow> \n   Cp(list2FWpolicy (insertDenies p)) = Cp (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>separated p; noDenyAll1 p; wellformed_policy1_strong p\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (insertDenies p)) =\n                      Cp (list2FWpolicy p)", "by (rule ext) (metis CConcStartA C_eq_iD_aux2 DAAux wp1_alternative_not_mt wp1n_tl)"], ["", "lemma noDAsortQ[rule_format]: \"noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)", "proof (cases \"p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)", "case Nil"], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)", "then"], ["proof (chain)\npicking this:\n  p = []", "show ?thesis"], ["proof (prove)\nusing this:\n  p = []\n\ngoal (1 subgoal):\n 1. noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)", "by simp"], ["proof (state)\nthis:\n  noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)", "case (Cons a list)"], ["proof (state)\nthis:\n  p = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)", "apply (insert \\<open>p = a # list\\<close>, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = a # list \\<Longrightarrow>\n    noDenyAll1 (a # list) \\<longrightarrow>\n    noDenyAll1\n     (qsort (filter (\\<lambda>y. \\<not> smaller a y l) list) l @\n      a # qsort (filter (\\<lambda>y. smaller a y l) list) l)", "proof (cases \"a = DenyAll\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = a # list; a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (a # list) \\<longrightarrow>\n                      noDenyAll1\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)\n 2. \\<lbrakk>p = a # list; a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (a # list) \\<longrightarrow>\n                      noDenyAll1\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)", "case True"], ["proof (state)\nthis:\n  a = DenyAll\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p = a # list; a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (a # list) \\<longrightarrow>\n                      noDenyAll1\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)\n 2. \\<lbrakk>p = a # list; a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (a # list) \\<longrightarrow>\n                      noDenyAll1\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)", "assume * : \"a = DenyAll\""], ["proof (state)\nthis:\n  a = DenyAll\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p = a # list; a = DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (a # list) \\<longrightarrow>\n                      noDenyAll1\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)\n 2. \\<lbrakk>p = a # list; a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (a # list) \\<longrightarrow>\n                      noDenyAll1\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)", "show \"noDenyAll1(a # list) \\<longrightarrow> \n               noDenyAll1(qsort[y\\<leftarrow>list . \\<not> smaller a y l] l @ a # qsort [y\\<leftarrow>list . smaller a y l] l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 (a # list) \\<longrightarrow>\n    noDenyAll1\n     (qsort (filter (\\<lambda>y. \\<not> smaller a y l) list) l @\n      a # qsort (filter (\\<lambda>y. smaller a y l) list) l)", "using noDAsortQ"], ["proof (prove)\nusing this:\n  noDenyAll1 ?p \\<Longrightarrow> noDenyAll1 (qsort ?p ?l)\n\ngoal (1 subgoal):\n 1. noDenyAll1 (a # list) \\<longrightarrow>\n    noDenyAll1\n     (qsort (filter (\\<lambda>y. \\<not> smaller a y l) list) l @\n      a # qsort (filter (\\<lambda>y. smaller a y l) list) l)", "by fastforce"], ["proof (state)\nthis:\n  noDenyAll1 (a # list) \\<longrightarrow>\n  noDenyAll1\n   (qsort (filter (\\<lambda>y. \\<not> smaller a y l) list) l @\n    a # qsort (filter (\\<lambda>y. smaller a y l) list) l)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a # list; a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (a # list) \\<longrightarrow>\n                      noDenyAll1\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a # list; a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (a # list) \\<longrightarrow>\n                      noDenyAll1\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)", "case False"], ["proof (state)\nthis:\n  a \\<noteq> DenyAll\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a # list; a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (a # list) \\<longrightarrow>\n                      noDenyAll1\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)", "assume * : \"a \\<noteq> DenyAll\""], ["proof (state)\nthis:\n  a \\<noteq> DenyAll\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a # list; a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (a # list) \\<longrightarrow>\n                      noDenyAll1\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)", "have ** : \"noDenyAll1 (a # list) \\<Longrightarrow> noDenyAll (a # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 (a # list) \\<Longrightarrow> noDenyAll (a # list)", "by(case_tac a,simp_all add:*)"], ["proof (state)\nthis:\n  noDenyAll1 (a # list) \\<Longrightarrow> noDenyAll (a # list)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a # list; a \\<noteq> DenyAll\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1 (a # list) \\<longrightarrow>\n                      noDenyAll1\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)", "show \"noDenyAll1(a # list) \\<longrightarrow> \n               noDenyAll1(qsort[y\\<leftarrow>list . \\<not> smaller a y l] l @ a # qsort [y\\<leftarrow>list . smaller a y l] l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noDenyAll1 (a # list) \\<longrightarrow>\n    noDenyAll1\n     (qsort (filter (\\<lambda>y. \\<not> smaller a y l) list) l @\n      a # qsort (filter (\\<lambda>y. smaller a y l) list) l)", "apply (insert *,rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> DenyAll; noDenyAll1 (a # list)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll1\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)", "apply (rule noDA1eq, frule **)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> DenyAll; noDenyAll1 (a # list);\n     noDenyAll (a # list)\\<rbrakk>\n    \\<Longrightarrow> noDenyAll\n                       (qsort\n                         (filter (\\<lambda>y. \\<not> smaller a y l) list)\n                         l @\n                        a #\n                        qsort (filter (\\<lambda>y. smaller a y l) list) l)", "by (metis append_Cons append_Nil nDAeqSet qsort.simps(2) set_sortQ)"], ["proof (state)\nthis:\n  noDenyAll1 (a # list) \\<longrightarrow>\n  noDenyAll1\n   (qsort (filter (\\<lambda>y. \\<not> smaller a y l) list) l @\n    a # qsort (filter (\\<lambda>y. smaller a y l) list) l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  noDenyAll1 p \\<longrightarrow> noDenyAll1 (qsort p l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NetsCollectedSortQ: \n  \"distinct p \\<Longrightarrow>noDenyAll1 p \\<Longrightarrow> all_in_list p l \\<Longrightarrow> singleCombinators p \\<Longrightarrow> \n   NetsCollected (qsort p l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct p; noDenyAll1 p; all_in_list p l;\n     singleCombinators p\\<rbrakk>\n    \\<Longrightarrow> NetsCollected (qsort p l)", "by(metis C_eqLemmas_id(22))"], ["", "lemmas CLemmas =  nMTSort nMTSortQ none_MT_rulesRS2 none_MT_rulesrd\n                  noDAsort noDAsortQ nDASC wp1_eq  wp1ID    SCp2l ANDSep   wp1n_RS2 \n                  OTNSEp OTNSC noDA1sep wp1_alternativesep wellformed_eq \n                  wellformed1_alternative_sorted"], ["", "lemmas C_eqLemmas_id = CLemmas  NC2Sep NetsCollectedSep \n                       NetsCollectedSort NetsCollectedSortQ separatedNC"], ["", "lemma C_eq_Until_InsertDenies: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow> allNetsDistinct (policy2list p)\\<Longrightarrow> \n    Cp (list2FWpolicy((insertDenies(separate(sort(removeShadowRules2 \n            (remdups(rm_MT_rules Cp (insertDeny (removeShadowRules1 (policy2list p)))))) l))))) =\n    Cp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (insertDenies\n                             (separate\n                               (FWNormalisationCore.sort\n                                 (removeShadowRules2\n                                   (remdups\n                                     (rm_MT_rules Cp\n (insertDeny (removeShadowRules1 (policy2list p))))))\n                                 l)))) =\n                      Cp p", "by (subst C_eq_iD,simp_all add: C_eqLemmas_id) (rule C_eq_until_separated, simp_all)"], ["", "lemma C_eq_Until_InsertDeniesQ: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> all_in_list  (policy2list p) l \\<Longrightarrow> \n   allNetsDistinct (policy2list p) \\<Longrightarrow> \n     Cp (list2FWpolicy ((insertDenies (separate (qsort  (removeShadowRules2 \n          (remdups (rm_MT_rules Cp (insertDeny (removeShadowRules1 (policy2list p)))))) l))))) = \n     Cp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (insertDenies\n                             (separate\n                               (qsort\n                                 (removeShadowRules2\n                                   (remdups\n                                     (rm_MT_rules Cp\n (insertDeny (removeShadowRules1 (policy2list p))))))\n                                 l)))) =\n                      Cp p", "apply (subst C_eq_iD, simp_all add: C_eqLemmas_id)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> wellformed_policy1_strong\n                       (separate\n                         (qsort\n                           (removeShadowRules2\n                             (remdups\n                               (rm_MT_rules Cp\n                                 (insertDeny\n                                   (removeShadowRules1 (policy2list p))))))\n                           l))\n 2. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (separate\n                             (qsort\n                               (removeShadowRules2\n                                 (remdups\n                                   (rm_MT_rules Cp\n                                     (insertDeny\n (removeShadowRules1 (policy2list p))))))\n                               l))) =\n                      Cp p", "apply (metis WP1rd set_qsort wellformed1_sortedQ wellformed_eq wp1ID wp1_alternativesep \n      wp1_aux1aa wp1n_RS2 wp1n_RS3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (separate\n                             (qsort\n                               (removeShadowRules2\n                                 (remdups\n                                   (rm_MT_rules Cp\n                                     (insertDeny\n (removeShadowRules1 (policy2list p))))))\n                               l))) =\n                      Cp p", "apply (rule C_eq_until_separatedQ)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> DenyAll \\<in> set (policy2list p)\n 2. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> all_in_list (policy2list p) l\n 3. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> allNetsDistinct (policy2list p)", "by simp_all"], ["", "lemma C_eq_RD_aux[rule_format]: \"Cp (p) x = Cp (removeDuplicates p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp p x = Cp (removeDuplicates p) x", "apply (induct p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>Cp p1 x = Cp (removeDuplicates p1) x;\n        Cp p2 x = Cp (removeDuplicates p2) x\\<rbrakk>\n       \\<Longrightarrow> (member p1 p2 \\<longrightarrow>\n                          Cp (p1 \\<oplus> p2) x =\n                          Cp (removeDuplicates p2) x) \\<and>\n                         (\\<not> member p1 p2 \\<longrightarrow>\n                          Cp (p1 \\<oplus> p2) x =\n                          Cp (p1 \\<oplus> removeDuplicates p2) x)", "apply (intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p1 p2.\n       \\<lbrakk>Cp p1 x = Cp (removeDuplicates p1) x;\n        Cp p2 x = Cp (removeDuplicates p2) x; member p1 p2\\<rbrakk>\n       \\<Longrightarrow> Cp (p1 \\<oplus> p2) x = Cp (removeDuplicates p2) x\n 2. \\<And>p1 p2.\n       \\<lbrakk>Cp p1 x = Cp (removeDuplicates p1) x;\n        Cp p2 x = Cp (removeDuplicates p2) x; \\<not> member p1 p2\\<rbrakk>\n       \\<Longrightarrow> Cp (p1 \\<oplus> p2) x =\n                         Cp (p1 \\<oplus> removeDuplicates p2) x", "by (metis Cdom2 domIff nlpaux not_in_member) (metis Cp.simps(4) CConcStartaux Cdom2 domIff)"], ["", "lemma C_eq_RAD_aux[rule_format]: \n  \"p \\<noteq> []  \\<longrightarrow> Cp (list2FWpolicy p) x = Cp (list2FWpolicy (removeAllDuplicates p)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy p) x = Cp (list2FWpolicy (removeAllDuplicates p)) x", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy []) x = Cp (list2FWpolicy (removeAllDuplicates [])) x\n 2. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy p) x =\n       Cp (list2FWpolicy (removeAllDuplicates p)) x \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (a # p)) x =\n       Cp (list2FWpolicy (removeAllDuplicates (a # p))) x", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy []) x = Cp (list2FWpolicy (removeAllDuplicates [])) x\n 2. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy p) x =\n       Cp (list2FWpolicy (removeAllDuplicates p)) x \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (a # p)) x =\n       Cp (list2FWpolicy (removeAllDuplicates (a # p))) x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy []) x = Cp (list2FWpolicy (removeAllDuplicates [])) x", "by simp"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy []) x = Cp (list2FWpolicy (removeAllDuplicates [])) x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy p) x =\n       Cp (list2FWpolicy (removeAllDuplicates p)) x \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (a # p)) x =\n       Cp (list2FWpolicy (removeAllDuplicates (a # p))) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy p) x =\n       Cp (list2FWpolicy (removeAllDuplicates p)) x \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (a # p)) x =\n       Cp (list2FWpolicy (removeAllDuplicates (a # p))) x", "case (Cons a p)"], ["proof (state)\nthis:\n  p \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy p) x = Cp (list2FWpolicy (removeAllDuplicates p)) x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       p \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy p) x =\n       Cp (list2FWpolicy (removeAllDuplicates p)) x \\<Longrightarrow>\n       a # p \\<noteq> [] \\<longrightarrow>\n       Cp (list2FWpolicy (a # p)) x =\n       Cp (list2FWpolicy (removeAllDuplicates (a # p))) x", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy p) x = Cp (list2FWpolicy (removeAllDuplicates p)) x", "show ?case"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy p) x = Cp (list2FWpolicy (removeAllDuplicates p)) x\n\ngoal (1 subgoal):\n 1. a # p \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (a # p)) x =\n    Cp (list2FWpolicy (removeAllDuplicates (a # p))) x", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy p) x =\n    Cp (list2FWpolicy (removeAllDuplicates p)) x \\<Longrightarrow>\n    Cp (list2FWpolicy (a # p)) x =\n    Cp (list2FWpolicy (removeDuplicates a # removeAllDuplicates p)) x", "apply (case_tac \"p = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> Cp a x = Cp (removeDuplicates a) x\n 2. \\<lbrakk>Cp (list2FWpolicy p) x =\n             Cp (list2FWpolicy (removeAllDuplicates p)) x;\n     p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (a # p)) x =\n                      Cp (list2FWpolicy\n                           (removeDuplicates a # removeAllDuplicates p))\n                       x", "apply (metis C_eq_RD_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Cp (list2FWpolicy p) x =\n             Cp (list2FWpolicy (removeAllDuplicates p)) x;\n     p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (a # p)) x =\n                      Cp (list2FWpolicy\n                           (removeDuplicates a # removeAllDuplicates p))\n                       x", "apply (subst list2FWpolicyconc, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Cp (list2FWpolicy p) x =\n             Cp (list2FWpolicy (removeAllDuplicates p)) x;\n     p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (a \\<oplus> list2FWpolicy p) x =\n                      Cp (list2FWpolicy\n                           (removeDuplicates a # removeAllDuplicates p))\n                       x", "apply (case_tac \"x \\<in> dom (Cp (list2FWpolicy p))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Cp (list2FWpolicy p) x =\n             Cp (list2FWpolicy (removeAllDuplicates p)) x;\n     p \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> Cp (a \\<oplus> list2FWpolicy p) x =\n                      Cp (list2FWpolicy\n                           (removeDuplicates a # removeAllDuplicates p))\n                       x\n 2. \\<lbrakk>Cp (list2FWpolicy p) x =\n             Cp (list2FWpolicy (removeAllDuplicates p)) x;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> Cp (a \\<oplus> list2FWpolicy p) x =\n                      Cp (list2FWpolicy\n                           (removeDuplicates a # removeAllDuplicates p))\n                       x", "apply (subst list2FWpolicyconc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Cp (list2FWpolicy p) x =\n             Cp (list2FWpolicy (removeAllDuplicates p)) x;\n     p \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> removeAllDuplicates p \\<noteq> []\n 2. \\<lbrakk>Cp (list2FWpolicy p) x =\n             Cp (list2FWpolicy (removeAllDuplicates p)) x;\n     p \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> Cp (a \\<oplus> list2FWpolicy p) x =\n                      Cp (removeDuplicates a \\<oplus>\n                          list2FWpolicy (removeAllDuplicates p))\n                       x\n 3. \\<lbrakk>Cp (list2FWpolicy p) x =\n             Cp (list2FWpolicy (removeAllDuplicates p)) x;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> Cp (a \\<oplus> list2FWpolicy p) x =\n                      Cp (list2FWpolicy\n                           (removeDuplicates a # removeAllDuplicates p))\n                       x", "apply (rule rADnMT, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Cp (list2FWpolicy p) x =\n             Cp (list2FWpolicy (removeAllDuplicates p)) x;\n     p \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> Cp (a \\<oplus> list2FWpolicy p) x =\n                      Cp (removeDuplicates a \\<oplus>\n                          list2FWpolicy (removeAllDuplicates p))\n                       x\n 2. \\<lbrakk>Cp (list2FWpolicy p) x =\n             Cp (list2FWpolicy (removeAllDuplicates p)) x;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> Cp (a \\<oplus> list2FWpolicy p) x =\n                      Cp (list2FWpolicy\n                           (removeDuplicates a # removeAllDuplicates p))\n                       x", "apply (subst Cdom2,simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Cp (list2FWpolicy p) x =\n             Cp (list2FWpolicy (removeAllDuplicates p)) x;\n     p \\<noteq> []; x \\<in> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy p) x =\n                      Cp (removeDuplicates a \\<oplus>\n                          list2FWpolicy (removeAllDuplicates p))\n                       x\n 2. \\<lbrakk>Cp (list2FWpolicy p) x =\n             Cp (list2FWpolicy (removeAllDuplicates p)) x;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> Cp (a \\<oplus> list2FWpolicy p) x =\n                      Cp (list2FWpolicy\n                           (removeDuplicates a # removeAllDuplicates p))\n                       x", "apply (simp add: NormalisationIPPProofs.Cdom2 domIff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Cp (list2FWpolicy p) x =\n             Cp (list2FWpolicy (removeAllDuplicates p)) x;\n     p \\<noteq> []; x \\<notin> dom (Cp (list2FWpolicy p))\\<rbrakk>\n    \\<Longrightarrow> Cp (a \\<oplus> list2FWpolicy p) x =\n                      Cp (list2FWpolicy\n                           (removeDuplicates a # removeAllDuplicates p))\n                       x", "by (metis C_eq_RD_aux nlpaux domIff list2FWpolicyconc rADnMT)"], ["proof (state)\nthis:\n  a # p \\<noteq> [] \\<longrightarrow>\n  Cp (list2FWpolicy (a # p)) x =\n  Cp (list2FWpolicy (removeAllDuplicates (a # p))) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_eq_RAD: \n  \"p \\<noteq> []  \\<Longrightarrow> Cp (list2FWpolicy p) = Cp (list2FWpolicy (removeAllDuplicates p)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    Cp (list2FWpolicy p) = Cp (list2FWpolicy (removeAllDuplicates p))", "by (rule ext) (erule C_eq_RAD_aux)"], ["", "lemma C_eq_compile: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> all_in_list (policy2list p) l \\<Longrightarrow> \n allNetsDistinct (policy2list p) \\<Longrightarrow> \n   Cp (list2FWpolicy (removeAllDuplicates (insertDenies (separate \n          (sort (removeShadowRules2 (remdups (rm_MT_rules Cp (insertDeny \n                   (removeShadowRules1 (policy2list p)))))) l))))) = Cp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (removeAllDuplicates\n                             (insertDenies\n                               (separate\n                                 (FWNormalisationCore.sort\n                                   (removeShadowRules2\n                                     (remdups\n (rm_MT_rules Cp (insertDeny (removeShadowRules1 (policy2list p))))))\n                                   l))))) =\n                      Cp p", "by (metis C_eq_RAD C_eq_Until_InsertDenies removeAllDuplicates.simps(2))"], ["", "lemma C_eq_compileQ: \n  \"DenyAll\\<in>set(policy2list p) \\<Longrightarrow> all_in_list(policy2list p) l \\<Longrightarrow>  allNetsDistinct(policy2list p) \\<Longrightarrow> \n  Cp (list2FWpolicy (removeAllDuplicates (insertDenies (separate (qsort \n                         (removeShadowRules2 (remdups (rm_MT_rules Cp (insertDeny \n                               (removeShadowRules1 (policy2list p)))))) l))))) = Cp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (removeAllDuplicates\n                             (insertDenies\n                               (separate\n                                 (qsort\n                                   (removeShadowRules2\n                                     (remdups\n (rm_MT_rules Cp (insertDeny (removeShadowRules1 (policy2list p))))))\n                                   l))))) =\n                      Cp p", "apply (subst C_eq_RAD[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> insertDenies\n                       (separate\n                         (qsort\n                           (removeShadowRules2\n                             (remdups\n                               (rm_MT_rules Cp\n                                 (insertDeny\n                                   (removeShadowRules1 (policy2list p))))))\n                           l)) \\<noteq>\n                      []\n 2. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (insertDenies\n                             (separate\n                               (qsort\n                                 (removeShadowRules2\n                                   (remdups\n                                     (rm_MT_rules Cp\n (insertDeny (removeShadowRules1 (policy2list p))))))\n                                 l)))) =\n                      Cp p", "apply (rule idNMT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> separate\n                       (qsort\n                         (removeShadowRules2\n                           (remdups\n                             (rm_MT_rules Cp\n                               (insertDeny\n                                 (removeShadowRules1 (policy2list p))))))\n                         l) \\<noteq>\n                      []\n 2. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (insertDenies\n                             (separate\n                               (qsort\n                                 (removeShadowRules2\n                                   (remdups\n                                     (rm_MT_rules Cp\n (insertDeny (removeShadowRules1 (policy2list p))))))\n                                 l)))) =\n                      Cp p", "apply (metis WP1rd sepnMT sortnMTQ wellformed_policy1_strong.simps(1) wp1ID wp1n_RS2 wp1n_RS3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     all_in_list (policy2list p) l; allNetsDistinct (policy2list p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (insertDenies\n                             (separate\n                               (qsort\n                                 (removeShadowRules2\n                                   (remdups\n                                     (rm_MT_rules Cp\n (insertDeny (removeShadowRules1 (policy2list p))))))\n                                 l)))) =\n                      Cp p", "apply (rule C_eq_Until_InsertDeniesQ, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_eq_normalizePr: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> allNetsDistinct (policy2list p) \\<Longrightarrow> \n all_in_list (policy2list p) (Nets_List p) \\<Longrightarrow> \n Cp (list2FWpolicy (normalizePr p)) = Cp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     allNetsDistinct (policy2list p);\n     all_in_list (policy2list p) (Nets_List p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (normalizePr p)) = Cp p", "unfolding normalizePrQ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     allNetsDistinct (policy2list p);\n     all_in_list (policy2list p) (Nets_List p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (normalizePr p)) = Cp p", "by (simp add: C_eq_compile normalizePr_def)"], ["", "lemma C_eq_normalizePrQ: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> allNetsDistinct (policy2list p) \\<Longrightarrow>\n all_in_list (policy2list p) (Nets_List p) \\<Longrightarrow> \n Cp (list2FWpolicy (normalizePrQ p)) = Cp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     allNetsDistinct (policy2list p);\n     all_in_list (policy2list p) (Nets_List p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (normalizePrQ p)) = Cp p", "unfolding normalizePrQ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     allNetsDistinct (policy2list p);\n     all_in_list (policy2list p) (Nets_List p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (removeAllDuplicates\n                             (insertDenies\n                               (separate\n                                 (qsort\n                                   (removeShadowRules2\n                                     (remdups\n (rm_MT_rules Cp (insertDeny (removeShadowRules1 (policy2list p))))))\n                                   (Nets_List p)))))) =\n                      Cp p", "using C_eq_compileQ"], ["proof (prove)\nusing this:\n  \\<lbrakk>DenyAll \\<in> set (policy2list ?p);\n   all_in_list (policy2list ?p) ?l;\n   allNetsDistinct (policy2list ?p)\\<rbrakk>\n  \\<Longrightarrow> Cp (list2FWpolicy\n                         (removeAllDuplicates\n                           (insertDenies\n                             (separate\n                               (qsort\n                                 (removeShadowRules2\n                                   (remdups\n                                     (rm_MT_rules Cp\n (insertDeny (removeShadowRules1 (policy2list ?p))))))\n                                 ?l))))) =\n                    Cp ?p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     allNetsDistinct (policy2list p);\n     all_in_list (policy2list p) (Nets_List p)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (removeAllDuplicates\n                             (insertDenies\n                               (separate\n                                 (qsort\n                                   (removeShadowRules2\n                                     (remdups\n (rm_MT_rules Cp (insertDeny (removeShadowRules1 (policy2list p))))))\n                                   (Nets_List p)))))) =\n                      Cp p", "by auto"], ["", "lemma domSubset3: \"dom (Cp (DenyAll \\<oplus> x)) = dom (Cp (DenyAll))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (Cp (DenyAll \\<oplus> x)) = dom (Cp DenyAll)", "by (simp add: PLemmas split_tupled_all split: option.splits)"], ["", "lemma domSubset4: \n  \"dom (Cp (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x \\<oplus> AllowPortFromTo x y dn)) = \n   dom (Cp (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (Cp (DenyAllFromTo x y \\<oplus>\n             DenyAllFromTo y x \\<oplus> AllowPortFromTo x y dn)) =\n    dom (Cp (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x))", "by (simp  add: PLemmas split: option.splits decision.splits) auto"], ["", "lemma domSubset5: \n  \"dom (Cp (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x \\<oplus> AllowPortFromTo y x dn)) = \n  dom (Cp (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (Cp (DenyAllFromTo x y \\<oplus>\n             DenyAllFromTo y x \\<oplus> AllowPortFromTo y x dn)) =\n    dom (Cp (DenyAllFromTo x y \\<oplus> DenyAllFromTo y x))", "by (simp add: PLemmas split: option.splits decision.splits) auto"], ["", "lemma domSubset1: \n  \"dom (Cp (DenyAllFromTo one two \\<oplus> DenyAllFromTo two one \\<oplus> AllowPortFromTo one two dn \\<oplus> x)) = \n   dom (Cp (DenyAllFromTo one two \\<oplus> DenyAllFromTo two one \\<oplus> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (Cp (DenyAllFromTo one two \\<oplus>\n             DenyAllFromTo two one \\<oplus>\n             AllowPortFromTo one two dn \\<oplus> x)) =\n    dom (Cp (DenyAllFromTo one two \\<oplus>\n             DenyAllFromTo two one \\<oplus> x))", "by (simp add: PLemmas allow_all_def deny_all_def split: option.splits decision.splits)  auto"], ["", "lemma domSubset2: \n  \"dom (Cp (DenyAllFromTo one two \\<oplus> DenyAllFromTo two one \\<oplus> AllowPortFromTo two one dn \\<oplus> x)) = \n  dom (Cp (DenyAllFromTo one two \\<oplus> DenyAllFromTo two one \\<oplus> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (Cp (DenyAllFromTo one two \\<oplus>\n             DenyAllFromTo two one \\<oplus>\n             AllowPortFromTo two one dn \\<oplus> x)) =\n    dom (Cp (DenyAllFromTo one two \\<oplus>\n             DenyAllFromTo two one \\<oplus> x))", "by (simp add: PLemmas  allow_all_def deny_all_def split: option.splits decision.splits) auto"], ["", "lemma ConcAssoc2: \"Cp (X \\<oplus> Y \\<oplus> ((A \\<oplus> B) \\<oplus> D)) = Cp (X \\<oplus> Y \\<oplus> A \\<oplus> B \\<oplus> D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp (X \\<oplus> Y \\<oplus> (A \\<oplus> B) \\<oplus> D) =\n    Cp (X \\<oplus> Y \\<oplus> A \\<oplus> B \\<oplus> D)", "by (simp add: Cp.simps)"], ["", "lemma ConcAssoc3: \"Cp (X \\<oplus> ((Y \\<oplus> A) \\<oplus> D)) = Cp (X \\<oplus> Y \\<oplus> A \\<oplus> D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp (X \\<oplus> (Y \\<oplus> A) \\<oplus> D) =\n    Cp (X \\<oplus> Y \\<oplus> A \\<oplus> D)", "by (simp add: Cp.simps)"], ["", "lemma RS3_NMT[rule_format]: \"DenyAll \\<in> set p \\<longrightarrow>\n    rm_MT_rules Cp p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set p \\<longrightarrow> rm_MT_rules Cp p \\<noteq> []", "by (induct_tac p) (simp_all add: PLemmas)"], ["", "lemma norm_notMT: \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> normalizePr p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set (policy2list p) \\<Longrightarrow>\n    normalizePr p \\<noteq> []", "unfolding normalizePrQ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set (policy2list p) \\<Longrightarrow>\n    normalizePr p \\<noteq> []", "by (simp add: DAiniD RS3_NMT RS2_NMT idNMT normalizePr_def rADnMT sepnMT sortnMT)"], ["", "lemma norm_notMTQ: \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> normalizePrQ p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set (policy2list p) \\<Longrightarrow>\n    normalizePrQ p \\<noteq> []", "unfolding normalizePrQ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set (policy2list p) \\<Longrightarrow>\n    removeAllDuplicates\n     (insertDenies\n       (separate\n         (qsort\n           (removeShadowRules2\n             (remdups\n               (rm_MT_rules Cp\n                 (insertDeny (removeShadowRules1 (policy2list p))))))\n           (Nets_List p)))) \\<noteq>\n    []", "by (simp add: DAiniD RS3_NMT sortnMTQ RS2_NMT idNMT rADnMT sepnMT)"], ["", "lemma domDA: \"dom (Cp (DenyAll \\<oplus> A)) = dom (Cp (DenyAll))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (Cp (DenyAll \\<oplus> A)) = dom (Cp DenyAll)", "by (rule domSubset3)"], ["", "lemmas domain_reasoningPr = domDA ConcAssoc2 domSubset1 domSubset2 \n  domSubset3 domSubset4  domSubset5 domSubsetDistr1\n  domSubsetDistr2 domSubsetDistrA domSubsetDistrD coerc_assoc ConcAssoc \n  ConcAssoc3"], ["", "text \\<open>The following lemmas help with the normalisation\\<close>"], ["", "lemma list2policyR_Start[rule_format]: \"p \\<in> dom (Cp a) \\<longrightarrow>\n                 Cp (list2policyR (a # list)) p = Cp a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> dom (Cp a) \\<longrightarrow>\n    Cp (list2policyR (a # list)) p = Cp a p", "by (induct \"a # list\" rule:list2policyR.induct)\n    (auto simp: Cp.simps dom_def map_add_def)"], ["", "lemma list2policyR_End: \"p \\<notin> dom (Cp a) \\<Longrightarrow>\n        Cp (list2policyR (a # list)) p = (Cp a \\<Oplus> list2policy (map Cp list)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<notin> dom (Cp a) \\<Longrightarrow>\n    Cp (list2policyR (a # list)) p =\n    (Cp a \\<Oplus> list2policy (map Cp list)) p", "by (rule list2policyR.induct)\n    (simp_all add: Cp.simps dom_def map_add_def list2policy_def split: option.splits)"], ["", "lemma l2polR_eq_el[rule_format]: \"N \\<noteq> [] \\<longrightarrow>\n Cp( list2policyR N) p =  (list2policy (map Cp N)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<noteq> [] \\<longrightarrow>\n    Cp (list2policyR N) p = list2policy (map Cp N) p", "proof (induct N)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2policyR []) p = list2policy (map Cp []) p\n 2. \\<And>a N.\n       N \\<noteq> [] \\<longrightarrow>\n       Cp (list2policyR N) p = list2policy (map Cp N) p \\<Longrightarrow>\n       a # N \\<noteq> [] \\<longrightarrow>\n       Cp (list2policyR (a # N)) p = list2policy (map Cp (a # N)) p", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2policyR []) p = list2policy (map Cp []) p\n 2. \\<And>a N.\n       N \\<noteq> [] \\<longrightarrow>\n       Cp (list2policyR N) p = list2policy (map Cp N) p \\<Longrightarrow>\n       a # N \\<noteq> [] \\<longrightarrow>\n       Cp (list2policyR (a # N)) p = list2policy (map Cp (a # N)) p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2policyR []) p = list2policy (map Cp []) p", "by simp"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  Cp (list2policyR []) p = list2policy (map Cp []) p\n\ngoal (1 subgoal):\n 1. \\<And>a N.\n       N \\<noteq> [] \\<longrightarrow>\n       Cp (list2policyR N) p = list2policy (map Cp N) p \\<Longrightarrow>\n       a # N \\<noteq> [] \\<longrightarrow>\n       Cp (list2policyR (a # N)) p = list2policy (map Cp (a # N)) p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a N.\n       N \\<noteq> [] \\<longrightarrow>\n       Cp (list2policyR N) p = list2policy (map Cp N) p \\<Longrightarrow>\n       a # N \\<noteq> [] \\<longrightarrow>\n       Cp (list2policyR (a # N)) p = list2policy (map Cp (a # N)) p", "case (Cons a p)"], ["proof (state)\nthis:\n  p \\<noteq> [] \\<longrightarrow>\n  Cp (list2policyR p) p = list2policy (map Cp p) p\n\ngoal (1 subgoal):\n 1. \\<And>a N.\n       N \\<noteq> [] \\<longrightarrow>\n       Cp (list2policyR N) p = list2policy (map Cp N) p \\<Longrightarrow>\n       a # N \\<noteq> [] \\<longrightarrow>\n       Cp (list2policyR (a # N)) p = list2policy (map Cp (a # N)) p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a # p \\<noteq> [] \\<longrightarrow>\n    Cp (list2policyR (a # p)) p = list2policy (map Cp (a # p)) p", "apply (insert Cons.hyps, simp_all add: list2policy_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    Cp (list2policyR p) p =\n    foldr (\\<lambda>x y. x \\<Oplus> y) (map Cp p) \\<emptyset>\n     p \\<Longrightarrow>\n    Cp (list2policyR (a # p)) p =\n    (Cp a \\<Oplus>\n     foldr (\\<lambda>x y. x \\<Oplus> y) (map Cp p) \\<emptyset>)\n     p", "by (metis list2policyR_End list2policyR_Start domStart list2policy_def)"], ["proof (state)\nthis:\n  a # p \\<noteq> [] \\<longrightarrow>\n  Cp (list2policyR (a # p)) p = list2policy (map Cp (a # p)) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma l2polR_eq: \n  \"N \\<noteq> [] \\<Longrightarrow> Cp( list2policyR N) =  (list2policy (map Cp N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<noteq> [] \\<Longrightarrow>\n    Cp (list2policyR N) = list2policy (map Cp N)", "by (auto simp: list2policy_def l2polR_eq_el )"], ["", "lemma list2FWpolicys_eq_el[rule_format]: \n  \"Filter \\<noteq> []  \\<longrightarrow>  Cp (list2policyR Filter) p =  Cp (list2FWpolicy (rev Filter)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filter \\<noteq> [] \\<longrightarrow>\n    Cp (list2policyR Filter) p = Cp (list2FWpolicy (rev Filter)) p", "apply (induct_tac Filter)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    Cp (list2policyR []) p = Cp (list2FWpolicy (rev [])) p\n 2. \\<And>a list.\n       list \\<noteq> [] \\<longrightarrow>\n       Cp (list2policyR list) p =\n       Cp (list2FWpolicy (rev list)) p \\<Longrightarrow>\n       a # list \\<noteq> [] \\<longrightarrow>\n       Cp (list2policyR (a # list)) p =\n       Cp (list2FWpolicy (rev (a # list))) p", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       list \\<noteq> [] \\<longrightarrow>\n       Cp (list2policyR list) p =\n       Cp (list2FWpolicy (rev list)) p \\<Longrightarrow>\n       Cp (list2policyR (a # list)) p =\n       Cp (list2FWpolicy (rev list @ [a])) p", "subgoal for a list"], ["proof (prove)\ngoal (1 subgoal):\n 1. list \\<noteq> [] \\<longrightarrow>\n    Cp (list2policyR list) p =\n    Cp (list2FWpolicy (rev list)) p \\<Longrightarrow>\n    Cp (list2policyR (a # list)) p = Cp (list2FWpolicy (rev list @ [a])) p", "apply (case_tac \"list = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>list \\<noteq> [] \\<longrightarrow>\n             Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list = []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p =\n                      Cp (list2FWpolicy (rev list @ [a])) p\n 2. \\<lbrakk>list \\<noteq> [] \\<longrightarrow>\n             Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p =\n                      Cp (list2FWpolicy (rev list @ [a])) p", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p =\n                      Cp (list2FWpolicy (rev list @ [a])) p", "apply (case_tac \"p \\<in> dom (Cp a)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p =\n                      Cp (list2FWpolicy (rev list @ [a])) p\n 2. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p =\n                      Cp (list2FWpolicy (rev list @ [a])) p", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p = Cp a p\n 2. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p =\n                      Cp (list2FWpolicy (rev list)) p", "apply (rule list2policyR_Start)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<in> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> p \\<in> dom (Cp a)\n 2. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p =\n                      Cp (list2FWpolicy (rev list)) p", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p =\n                      Cp (list2FWpolicy (rev list)) p", "apply (subgoal_tac \"Cp (list2policyR (a # list)) p = Cp (list2policyR list) p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a);\n     Cp (list2policyR (a # list)) p = Cp (list2policyR list) p\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p =\n                      Cp (list2FWpolicy (rev list)) p\n 2. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p =\n                      Cp (list2policyR list) p", "apply (subgoal_tac \"Cp (list2FWpolicy (rev list @ [a])) p = Cp (list2FWpolicy (rev list)) p\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a);\n     Cp (list2policyR (a # list)) p = Cp (list2policyR list) p;\n     Cp (list2FWpolicy (rev list @ [a])) p =\n     Cp (list2FWpolicy (rev list)) p\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p =\n                      Cp (list2FWpolicy (rev list)) p\n 2. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a);\n     Cp (list2policyR (a # list)) p = Cp (list2policyR list) p\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (rev list @ [a])) p =\n                      Cp (list2FWpolicy (rev list)) p\n 3. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p =\n                      Cp (list2policyR list) p", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a);\n     Cp (list2policyR (a # list)) p = Cp (list2policyR list) p\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (rev list @ [a])) p =\n                      Cp (list2FWpolicy (rev list)) p\n 2. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p =\n                      Cp (list2policyR list) p", "apply (rule CConcStart2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a);\n     Cp (list2policyR (a # list)) p = Cp (list2policyR list) p\\<rbrakk>\n    \\<Longrightarrow> rev list \\<noteq> []\n 2. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a);\n     Cp (list2policyR (a # list)) p = Cp (list2policyR list) p\\<rbrakk>\n    \\<Longrightarrow> p \\<notin> dom (Cp a)\n 3. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p =\n                      Cp (list2policyR list) p", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a);\n     Cp (list2policyR (a # list)) p = Cp (list2policyR list) p\\<rbrakk>\n    \\<Longrightarrow> p \\<notin> dom (Cp a)\n 2. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p =\n                      Cp (list2policyR list) p", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Cp (list2policyR list) p = Cp (list2FWpolicy (rev list)) p;\n     list \\<noteq> []; p \\<notin> dom (Cp a)\\<rbrakk>\n    \\<Longrightarrow> Cp (list2policyR (a # list)) p =\n                      Cp (list2policyR list) p", "apply (case_tac list,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa lista.\n       \\<lbrakk>Cp (list2policyR (aa # lista)) p =\n                Cp (list2FWpolicy (rev lista @ [aa])) p;\n        p \\<notin> dom (Cp a); list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> Cp (list2policyR (aa # lista) \\<oplus> a) p =\n                         Cp (list2FWpolicy (rev lista @ [aa])) p", "apply (simp_all add: Cp.simps dom_def map_add_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list2FWpolicys_eq: \n  \"Filter \\<noteq> []  \\<Longrightarrow>\n  Cp (list2policyR Filter) =  Cp (list2FWpolicy (rev Filter))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filter \\<noteq> [] \\<Longrightarrow>\n    Cp (list2policyR Filter) = Cp (list2FWpolicy (rev Filter))", "by (rule ext, erule list2FWpolicys_eq_el)"], ["", "lemma list2FWpolicys_eq_sym: \n  \"Filter \\<noteq> []  \\<Longrightarrow>\n  Cp (list2policyR (rev Filter)) =  Cp (list2FWpolicy Filter)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filter \\<noteq> [] \\<Longrightarrow>\n    Cp (list2policyR (rev Filter)) = Cp (list2FWpolicy Filter)", "by (metis list2FWpolicys_eq rev_is_Nil_conv rev_rev_ident)"], ["", "lemma p_eq[rule_format]: \"p \\<noteq> [] \\<longrightarrow> \n list2policy (map Cp (rev p)) = Cp (list2FWpolicy p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<longrightarrow>\n    list2policy (map Cp (rev p)) = Cp (list2FWpolicy p)", "by (metis l2polR_eq list2FWpolicys_eq_sym rev.simps(1) rev_rev_ident)"], ["", "lemma p_eq2[rule_format]: \"normalizePr x \\<noteq> [] \\<longrightarrow> \n  Cp (list2FWpolicy (normalizePr x)) = Cp x \\<longrightarrow>\n list2policy (map Cp (rev (normalizePr x))) = Cp x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalizePr x \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (normalizePr x)) = Cp x \\<longrightarrow>\n    list2policy (map Cp (rev (normalizePr x))) = Cp x", "by (simp add: p_eq)"], ["", "lemma p_eq2Q[rule_format]: \"normalizePrQ x \\<noteq> [] \\<longrightarrow> \n  Cp (list2FWpolicy (normalizePrQ x)) = Cp x \\<longrightarrow>\n list2policy (map Cp (rev (normalizePrQ x))) = Cp x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalizePrQ x \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (normalizePrQ x)) = Cp x \\<longrightarrow>\n    list2policy (map Cp (rev (normalizePrQ x))) = Cp x", "by (simp add: p_eq)"], ["", "lemma list2listNMT[rule_format]: \"x \\<noteq> [] \\<longrightarrow>map sem x \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<longrightarrow> map sem x \\<noteq> []", "by (case_tac x) (simp_all)"], ["", "lemma Norm_Distr2: \n  \"r o_f ((P \\<Otimes>\\<^sub>2 (list2policy Q)) o d) = \n  (list2policy ((P \\<Otimes>\\<^sub>L Q) (\\<Otimes>\\<^sub>2) r d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r o\\<^sub>f (P \\<Otimes>\\<^sub>2 list2policy Q \\<circ> d) =\n    list2policy ((P \\<Otimes>\\<^sub>L Q) (\\<Otimes>\\<^sub>2) r d)", "by (rule ext, rule Norm_Distr_2)"], ["", "lemma NATDistr: \n  \"N \\<noteq> [] \\<Longrightarrow> F = Cp (list2policyR N) \\<Longrightarrow> \n  ((\\<lambda> (x,y). x) o_f ((NAT \\<Otimes>\\<^sub>2 F) o (\\<lambda> x. (x,x)))  = \n   (list2policy (  ((NAT \\<Otimes>\\<^sub>L (map Cp N)) (\\<Otimes>\\<^sub>2) \n    (\\<lambda> (x,y). x) (\\<lambda> x. (x,x))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>N \\<noteq> []; F = Cp (list2policyR N)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>(x, y). x) o\\<^sub>f\n                      (NAT \\<Otimes>\\<^sub>2 F \\<circ>\n                       (\\<lambda>x. (x, x))) =\n                      list2policy\n                       ((NAT \\<Otimes>\\<^sub>L map Cp N) (\\<Otimes>\\<^sub>2)\n                         (\\<lambda>(x, y). x) (\\<lambda>x. (x, x)))", "by (simp add: l2polR_eq)  (rule ext,rule Norm_Distr_2)"], ["", "lemma C_eq_normalize_manual: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> allNetsDistinct (policy2list p) \\<Longrightarrow>\n   all_in_list (policy2list p) l \\<Longrightarrow> \n   Cp (list2FWpolicy (normalize_manual_orderPr p l)) = Cp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     allNetsDistinct (policy2list p); all_in_list (policy2list p) l\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (normalize_manual_orderPr p l)) =\n                      Cp p", "unfolding normalize_manual_orderPr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     allNetsDistinct (policy2list p); all_in_list (policy2list p) l\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy\n                           (removeAllDuplicates\n                             (insertDenies\n                               (separate\n                                 (FWNormalisationCore.sort\n                                   (removeShadowRules2\n                                     (remdups\n (rm_MT_rules Cp (insertDeny (removeShadowRules1 (policy2list p))))))\n                                   l))))) =\n                      Cp p", "by(simp_all add:C_eq_compile)"], ["", "lemma p_eq2_manualQ[rule_format]: \n  \"normalize_manual_orderPrQ x l \\<noteq> [] \\<longrightarrow> \n   Cp (list2FWpolicy (normalize_manual_orderPrQ x l)) = Cp x \\<longrightarrow>\n   list2policy (map Cp (rev (normalize_manual_orderPrQ x l))) = Cp x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize_manual_orderPrQ x l \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (normalize_manual_orderPrQ x l)) =\n    Cp x \\<longrightarrow>\n    list2policy (map Cp (rev (normalize_manual_orderPrQ x l))) = Cp x", "by (simp add: p_eq)"], ["", "lemma norm_notMT_manualQ: \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> normalize_manual_orderPrQ p l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set (policy2list p) \\<Longrightarrow>\n    normalize_manual_orderPrQ p l \\<noteq> []", "by (simp add: DAiniD RS3_NMT sortnMTQ RS2_NMT idNMT normalize_manual_orderPrQ_def rADnMT sepnMT)"], ["", "lemma C_eq_normalizePr_manualQ: \n  \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow>\n   allNetsDistinct (policy2list p) \\<Longrightarrow>\n   all_in_list (policy2list p) l \\<Longrightarrow> \n   Cp (list2FWpolicy (normalize_manual_orderPrQ p l)) = Cp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list p);\n     allNetsDistinct (policy2list p); all_in_list (policy2list p) l\\<rbrakk>\n    \\<Longrightarrow> Cp (list2FWpolicy (normalize_manual_orderPrQ p l)) =\n                      Cp p", "by (simp add: normalize_manual_orderPrQ_def C_eq_compileQ)"], ["", "lemma p_eq2_manual[rule_format]: \"normalize_manual_orderPr x l \\<noteq> [] \\<longrightarrow> \n  Cp (list2FWpolicy (normalize_manual_orderPr x l)) = Cp x \\<longrightarrow>\n list2policy (map Cp (rev (normalize_manual_orderPr x l))) = Cp x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize_manual_orderPr x l \\<noteq> [] \\<longrightarrow>\n    Cp (list2FWpolicy (normalize_manual_orderPr x l)) =\n    Cp x \\<longrightarrow>\n    list2policy (map Cp (rev (normalize_manual_orderPr x l))) = Cp x", "by (simp add: p_eq)"], ["", "lemma norm_notMT_manual: \"DenyAll \\<in> set (policy2list p) \\<Longrightarrow> normalize_manual_orderPr p l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set (policy2list p) \\<Longrightarrow>\n    normalize_manual_orderPr p l \\<noteq> []", "unfolding normalize_manual_orderPr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. DenyAll \\<in> set (policy2list p) \\<Longrightarrow>\n    removeAllDuplicates\n     (insertDenies\n       (separate\n         (FWNormalisationCore.sort\n           (removeShadowRules2\n             (remdups\n               (rm_MT_rules Cp\n                 (insertDeny (removeShadowRules1 (policy2list p))))))\n           l))) \\<noteq>\n    []", "by (simp add: idNMT rADnMT wellformed1_alternative_sorted wp1ID wp1_alternativesep wp1n_RS2)"], ["", "text\\<open>\n  As an example, how this theorems can be used for a concrete normalisation instantiation. \n\\<close>"], ["", "lemma normalizePrNAT: \n  \"DenyAll \\<in> set (policy2list Filter) \\<Longrightarrow> \n   allNetsDistinct (policy2list Filter) \\<Longrightarrow>  \n   all_in_list (policy2list Filter) (Nets_List Filter) \\<Longrightarrow> \n   ((\\<lambda> (x,y). x) o_f (((NAT \\<Otimes>\\<^sub>2 Cp Filter) o (\\<lambda>x. (x,x)))))  = \n   list2policy ((NAT \\<Otimes>\\<^sub>L (map Cp (rev (normalizePr Filter)))) (\\<Otimes>\\<^sub>2) (\\<lambda> (x,y). x) (\\<lambda> x. (x,x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DenyAll \\<in> set (policy2list Filter);\n     allNetsDistinct (policy2list Filter);\n     all_in_list (policy2list Filter) (Nets_List Filter)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>(x, y). x) o\\<^sub>f\n                      (NAT \\<Otimes>\\<^sub>2 Cp Filter \\<circ>\n                       (\\<lambda>x. (x, x))) =\n                      list2policy\n                       ((NAT \\<Otimes>\\<^sub>L\n                         map Cp (rev (normalizePr Filter)))\n                         (\\<Otimes>\\<^sub>2) (\\<lambda>(x, y). x)\n                         (\\<lambda>x. (x, x)))", "by (simp add: C_eq_normalizePr NATDistr list2FWpolicys_eq_sym norm_notMT)"], ["", "lemma domSimpl[simp]: \"dom (Cp (A \\<oplus> DenyAll)) = dom (Cp (DenyAll))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (Cp (A \\<oplus> DenyAll)) = dom (Cp DenyAll)", "by (simp add: PLemmas)"], ["", "end"]]}