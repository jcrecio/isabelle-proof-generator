{"file_name": "/home/qj213/afp-2021-10-22/thys/Inductive_Confidentiality/GeneralAttacker/EventGA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Inductive_Confidentiality", "problem_names": ["lemma Notes_imp_used [rule_format]: \"Notes A X \\<in> set evs \\<longrightarrow> X \\<in> used evs\"", "lemma Says_imp_used [rule_format]: \"Says A B X \\<in> set evs \\<longrightarrow> X \\<in> used evs\"", "lemmas parts_insert_knows_A = parts_insert [of _ \"knows A evs\"] for A evs", "lemma knows_Says [simp]:\n     \"knows A (Says A' B X # evs) = insert X (knows A evs)\"", "lemma knows_Notes [simp]:\n     \"knows A (Notes A' X # evs) =  \n          (if A=A' then insert X (knows A evs) else knows A evs)\"", "lemma knows_Gets [simp]: \"knows A (Gets A' X # evs) = knows A evs\"", "lemma Says_imp_knows [rule_format]:\n     \"Says A' B X \\<in> set evs \\<longrightarrow> (\\<forall>A. X \\<in> knows A evs)\"", "lemma Notes_imp_knows [rule_format]:\n\"Notes A' X \\<in> set evs \\<longrightarrow> X \\<in> knows A' evs\"", "lemmas Says_imp_parts_knows = \n       Says_imp_knows [THEN parts.Inj, THEN revcut_rl]", "lemmas knows_partsEs =\n     Says_imp_parts_knows parts.Body [THEN revcut_rl]", "lemmas Says_imp_analz = Says_imp_knows [THEN analz.Inj]", "lemma knows_subset_knows_Says: \"knows A evs \\<subseteq> knows A (Says A' B X # evs)\"", "lemma knows_subset_knows_Notes: \"knows A evs \\<subseteq> knows A (Notes A' X # evs)\"", "lemma knows_subset_knows_Gets: \"knows A evs \\<subseteq> knows A (Gets A' X # evs)\"", "lemma knows_imp_Says_Gets_Notes_initState [rule_format]:\n     \"X \\<in> knows A evs \\<Longrightarrow> \\<exists>A' B.  \n  Says A' B X \\<in> set evs \\<or> Notes A X \\<in> set evs \\<or> X \\<in> initState A\"", "lemma parts_knows_subset_used: \"parts (knows A evs) \\<subseteq> used evs\"", "lemmas usedI = parts_knows_subset_used [THEN subsetD, intro]", "lemma initState_into_used: \"X \\<in> parts (initState B) \\<Longrightarrow> X \\<in> used evs\"", "lemma used_Says [simp]: \"used (Says A B X # evs) = parts{X} \\<union> used evs\"", "lemma used_Notes [simp]: \"used (Notes A X # evs) = parts{X} \\<union> used evs\"", "lemma used_Gets [simp]: \"used (Gets A X # evs) = used evs\"", "lemma used_nil_subset: \"used [] \\<subseteq> used evs\"", "lemmas analz_mono_contra =\n       knows_subset_knows_Says [THEN analz_mono, THEN contra_subsetD]\n       knows_subset_knows_Notes [THEN analz_mono, THEN contra_subsetD]\n       knows_subset_knows_Gets [THEN analz_mono, THEN contra_subsetD]", "lemma knows_subset_knows_Cons: \"knows A evs \\<subseteq> knows A (e # evs)\"", "lemma initState_subset_knows: \"initState A \\<subseteq> knows A evs\"", "lemma keysFor_parts_insert:\n     \"[| K \\<in> keysFor (parts (insert X G));  X \\<in> synth (analz H) |] \n      ==> K \\<in> keysFor (parts (G \\<union> H)) | Key (invKey K) \\<in> parts H\"", "lemmas analz_impI = impI [where P = \"Y \\<notin> analz (knows A evs)\"] for Y A evs", "lemmas syan_impI = impI [where P = \"Y \\<notin> synth (analz (knows A evs))\"] for Y A evs"], "translations": [["", "lemma Notes_imp_used [rule_format]: \"Notes A X \\<in> set evs \\<longrightarrow> X \\<in> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Notes A X \\<in> set evs \\<longrightarrow> X \\<in> used evs", "apply (induct_tac evs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Notes A X \\<in> set [] \\<longrightarrow> X \\<in> used []\n 2. \\<And>a list.\n       Notes A X \\<in> set list \\<longrightarrow>\n       X \\<in> used list \\<Longrightarrow>\n       Notes A X \\<in> set (a # list) \\<longrightarrow>\n       X \\<in> used (a # list)", "apply (auto split: event.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Says_imp_used [rule_format]: \"Says A B X \\<in> set evs \\<longrightarrow> X \\<in> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Says A B X \\<in> set evs \\<longrightarrow> X \\<in> used evs", "apply (induct_tac evs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Says A B X \\<in> set [] \\<longrightarrow> X \\<in> used []\n 2. \\<And>a list.\n       Says A B X \\<in> set list \\<longrightarrow>\n       X \\<in> used list \\<Longrightarrow>\n       Says A B X \\<in> set (a # list) \\<longrightarrow>\n       X \\<in> used (a # list)", "apply (auto split: event.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Function @{term knows}\\<close>"], ["", "lemmas parts_insert_knows_A = parts_insert [of _ \"knows A evs\"] for A evs"], ["", "lemma knows_Says [simp]:\n     \"knows A (Says A' B X # evs) = insert X (knows A evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A (Says A' B X # evs) = insert X (knows A evs)", "by simp"], ["", "lemma knows_Notes [simp]:\n     \"knows A (Notes A' X # evs) =  \n          (if A=A' then insert X (knows A evs) else knows A evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A (Notes A' X # evs) =\n    (if A = A' then insert X (knows A evs) else knows A evs)", "by simp"], ["", "lemma knows_Gets [simp]: \"knows A (Gets A' X # evs) = knows A evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A (Gets A' X # evs) = knows A evs", "by simp"], ["", "text\\<open>Everybody sees what is sent on the traffic\\<close>"], ["", "lemma Says_imp_knows [rule_format]:\n     \"Says A' B X \\<in> set evs \\<longrightarrow> (\\<forall>A. X \\<in> knows A evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Says A' B X \\<in> set evs \\<longrightarrow>\n    (\\<forall>A. X \\<in> knows A evs)", "apply (induct_tac \"evs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. Says A' B X \\<in> set [] \\<longrightarrow>\n    (\\<forall>A. X \\<in> knows A [])\n 2. \\<And>a list.\n       Says A' B X \\<in> set list \\<longrightarrow>\n       (\\<forall>A. X \\<in> knows A list) \\<Longrightarrow>\n       Says A' B X \\<in> set (a # list) \\<longrightarrow>\n       (\\<forall>A. X \\<in> knows A (a # list))", "apply (simp_all (no_asm_simp) split: event.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Says A' B X \\<in> set list \\<longrightarrow>\n       (\\<forall>A. X \\<in> knows A list) \\<Longrightarrow>\n       Says A' B X = a \\<longrightarrow>\n       (\\<forall>A.\n           (\\<forall>x11 x12 x13.\n               a = Says x11 x12 x13 \\<longrightarrow>\n               X = x13 \\<or> X \\<in> knows A list) \\<and>\n           ((\\<exists>x21 x22. a = Gets x21 x22) \\<longrightarrow>\n            X \\<in> knows A list) \\<and>\n           (\\<forall>x31 x32.\n               (x31 = A \\<longrightarrow>\n                a = Notes A x32 \\<longrightarrow>\n                X = x32 \\<or> X \\<in> knows A list) \\<and>\n               (x31 \\<noteq> A \\<longrightarrow>\n                a = Notes x31 x32 \\<longrightarrow> X \\<in> knows A list)))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Notes_imp_knows [rule_format]:\n\"Notes A' X \\<in> set evs \\<longrightarrow> X \\<in> knows A' evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Notes A' X \\<in> set evs \\<longrightarrow> X \\<in> knows A' evs", "apply (induct_tac \"evs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. Notes A' X \\<in> set [] \\<longrightarrow> X \\<in> knows A' []\n 2. \\<And>a list.\n       Notes A' X \\<in> set list \\<longrightarrow>\n       X \\<in> knows A' list \\<Longrightarrow>\n       Notes A' X \\<in> set (a # list) \\<longrightarrow>\n       X \\<in> knows A' (a # list)", "apply (simp_all (no_asm_simp) split: event.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Elimination rules: derive contradictions from old Says events containing\n  items known to be fresh\\<close>"], ["", "lemmas Says_imp_parts_knows = \n       Says_imp_knows [THEN parts.Inj, THEN revcut_rl]"], ["", "lemmas knows_partsEs =\n     Says_imp_parts_knows parts.Body [THEN revcut_rl]"], ["", "lemmas Says_imp_analz = Says_imp_knows [THEN analz.Inj]"], ["", "subsection\\<open>Knowledge of generic agents\\<close>"], ["", "lemma knows_subset_knows_Says: \"knows A evs \\<subseteq> knows A (Says A' B X # evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A evs \\<subseteq> knows A (Says A' B X # evs)", "by (simp add: subset_insertI)"], ["", "lemma knows_subset_knows_Notes: \"knows A evs \\<subseteq> knows A (Notes A' X # evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A evs \\<subseteq> knows A (Notes A' X # evs)", "by (simp add: subset_insertI)"], ["", "lemma knows_subset_knows_Gets: \"knows A evs \\<subseteq> knows A (Gets A' X # evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A evs \\<subseteq> knows A (Gets A' X # evs)", "by (simp add: subset_insertI)"], ["", "lemma knows_imp_Says_Gets_Notes_initState [rule_format]:\n     \"X \\<in> knows A evs \\<Longrightarrow> \\<exists>A' B.  \n  Says A' B X \\<in> set evs \\<or> Notes A X \\<in> set evs \\<or> X \\<in> initState A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> knows A evs \\<Longrightarrow>\n    \\<exists>A' B.\n       Says A' B X \\<in> set evs \\<or>\n       Notes A X \\<in> set evs \\<or> X \\<in> initState A", "apply (erule rev_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> knows A evs \\<longrightarrow>\n    (\\<exists>A' B.\n        Says A' B X \\<in> set evs \\<or>\n        Notes A X \\<in> set evs \\<or> X \\<in> initState A)", "apply (induct_tac \"evs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. X \\<in> knows A [] \\<longrightarrow>\n    (\\<exists>A' B.\n        Says A' B X \\<in> set [] \\<or>\n        Notes A X \\<in> set [] \\<or> X \\<in> initState A)\n 2. \\<And>a list.\n       X \\<in> knows A list \\<longrightarrow>\n       (\\<exists>A' B.\n           Says A' B X \\<in> set list \\<or>\n           Notes A X \\<in> set list \\<or>\n           X \\<in> initState A) \\<Longrightarrow>\n       X \\<in> knows A (a # list) \\<longrightarrow>\n       (\\<exists>A' B.\n           Says A' B X \\<in> set (a # list) \\<or>\n           Notes A X \\<in> set (a # list) \\<or> X \\<in> initState A)", "apply (simp_all (no_asm_simp) split: event.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       X \\<in> knows A list \\<longrightarrow>\n       (\\<exists>A' B.\n           Says A' B X \\<in> set list \\<or>\n           Notes A X \\<in> set list \\<or>\n           X \\<in> initState A) \\<Longrightarrow>\n       (\\<forall>x11 x12 x13.\n           a = Says x11 x12 x13 \\<longrightarrow>\n           (X = x13 \\<longrightarrow>\n            (\\<exists>A' B.\n                A' = x11 \\<and> B = x12 \\<or>\n                Says A' B x13 \\<in> set list \\<or>\n                Notes A x13 \\<in> set list \\<or>\n                x13 \\<in> initState A)) \\<and>\n           (X \\<in> knows A list \\<longrightarrow>\n            (\\<exists>A' B.\n                A' = x11 \\<and> B = x12 \\<and> X = x13 \\<or>\n                Says A' B X \\<in> set list \\<or>\n                Notes A X \\<in> set list \\<or> X \\<in> initState A))) \\<and>\n       ((\\<exists>x21 x22. a = Gets x21 x22) \\<longrightarrow>\n        X \\<in> knows A list \\<longrightarrow>\n        (\\<exists>A' B. Says A' B X \\<in> set list) \\<or>\n        Notes A X \\<in> set list \\<or> X \\<in> initState A) \\<and>\n       (\\<forall>x31 x32.\n           (x31 = A \\<longrightarrow>\n            a = Notes A x32 \\<longrightarrow>\n            X \\<in> knows A list \\<longrightarrow>\n            (\\<exists>A' B. Says A' B X \\<in> set list) \\<or>\n            X = x32 \\<or>\n            Notes A X \\<in> set list \\<or> X \\<in> initState A) \\<and>\n           (x31 \\<noteq> A \\<longrightarrow>\n            a = Notes x31 x32 \\<longrightarrow>\n            X \\<in> knows A list \\<longrightarrow>\n            (\\<exists>A' B. Says A' B X \\<in> set list) \\<or>\n            Notes A X \\<in> set list \\<or> X \\<in> initState A))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_knows_subset_used: \"parts (knows A evs) \\<subseteq> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (knows A evs) \\<subseteq> used evs", "apply (induct_tac \"evs\", force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       parts (knows A list) \\<subseteq> used list \\<Longrightarrow>\n       parts (knows A (a # list)) \\<subseteq> used (a # list)", "apply (simp add: parts_insert_knows_A add: event.split, blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas usedI = parts_knows_subset_used [THEN subsetD, intro]"], ["", "lemma initState_into_used: \"X \\<in> parts (initState B) \\<Longrightarrow> X \\<in> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> parts (initState B) \\<Longrightarrow> X \\<in> used evs", "apply (induct_tac \"evs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. X \\<in> parts (initState B) \\<Longrightarrow> X \\<in> used []\n 2. \\<And>a list.\n       \\<lbrakk>X \\<in> parts (initState B); X \\<in> used list\\<rbrakk>\n       \\<Longrightarrow> X \\<in> used (a # list)", "apply (simp_all add: parts_insert_knows_A split: event.split, blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma used_Says [simp]: \"used (Says A B X # evs) = parts{X} \\<union> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. used (Says A B X # evs) = parts {X} \\<union> used evs", "by simp"], ["", "lemma used_Notes [simp]: \"used (Notes A X # evs) = parts{X} \\<union> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. used (Notes A X # evs) = parts {X} \\<union> used evs", "by simp"], ["", "lemma used_Gets [simp]: \"used (Gets A X # evs) = used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. used (Gets A X # evs) = used evs", "by simp"], ["", "lemma used_nil_subset: \"used [] \\<subseteq> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. used [] \\<subseteq> used evs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>B. parts (initState B)) \\<subseteq> used evs", "apply (blast intro: initState_into_used)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>NOTE REMOVAL--laws above are cleaner, as they don't involve \"case\"\\<close>"], ["", "declare knows_Cons [simp del]\n        used_Nil [simp del] used_Cons [simp del]"], ["", "lemmas analz_mono_contra =\n       knows_subset_knows_Says [THEN analz_mono, THEN contra_subsetD]\n       knows_subset_knows_Notes [THEN analz_mono, THEN contra_subsetD]\n       knows_subset_knows_Gets [THEN analz_mono, THEN contra_subsetD]"], ["", "lemma knows_subset_knows_Cons: \"knows A evs \\<subseteq> knows A (e # evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A evs \\<subseteq> knows A (e # evs)", "by (induct e, auto simp: knows_Cons)"], ["", "lemma initState_subset_knows: \"initState A \\<subseteq> knows A evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initState A \\<subseteq> knows A evs", "apply (induct_tac evs, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       initState A \\<subseteq> knows A list \\<Longrightarrow>\n       initState A \\<subseteq> knows A (a # list)", "apply (blast intro: knows_subset_knows_Cons [THEN subsetD])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>For proving \\<open>new_keys_not_used\\<close>\\<close>"], ["", "lemma keysFor_parts_insert:\n     \"[| K \\<in> keysFor (parts (insert X G));  X \\<in> synth (analz H) |] \n      ==> K \\<in> keysFor (parts (G \\<union> H)) | Key (invKey K) \\<in> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>K \\<in> keysFor (parts (insert X G));\n     X \\<in> synth (analz H)\\<rbrakk>\n    \\<Longrightarrow> K \\<in> keysFor (parts (G \\<union> H)) \\<or>\n                      Key (invKey K) \\<in> parts H", "by (force \n    dest!: parts_insert_subset_Un [THEN keysFor_mono, THEN [2] rev_subsetD]\n           analz_subset_parts [THEN keysFor_mono, THEN [2] rev_subsetD]\n    intro: analz_subset_parts [THEN subsetD] parts_mono [THEN [2] rev_subsetD])"], ["", "lemmas analz_impI = impI [where P = \"Y \\<notin> analz (knows A evs)\"] for Y A evs"], ["", "ML\n\\<open>\nfun analz_mono_contra_tac ctxt =\n  resolve_tac ctxt @{thms analz_impI} THEN' \n  REPEAT1 o (dresolve_tac ctxt @{thms analz_mono_contra})\n  THEN' mp_tac ctxt\n\\<close>"], ["", "method_setup analz_mono_contra = \\<open>\n    Scan.succeed (fn ctxt => SIMPLE_METHOD (REPEAT_FIRST (analz_mono_contra_tac ctxt)))\\<close>\n    \"for proving theorems of the form X \\<notin> analz (knows A evs) \\<longrightarrow> P\""], ["", "text\\<open>Useful for case analysis on whether a hash is a spoof or not\\<close>"], ["", "lemmas syan_impI = impI [where P = \"Y \\<notin> synth (analz (knows A evs))\"] for Y A evs"], ["", "ML\n\\<open>\nfun synth_analz_mono_contra_tac ctxt =\n  resolve_tac ctxt @{thms syan_impI} THEN'\n  REPEAT1 o \n    (dresolve_tac ctxt \n     [@{thm knows_subset_knows_Says} RS @{thm synth_analz_mono} RS @{thm contra_subsetD},\n      @{thm knows_subset_knows_Notes} RS @{thm synth_analz_mono} RS @{thm contra_subsetD},\n      @{thm knows_subset_knows_Gets} RS @{thm synth_analz_mono} RS @{thm contra_subsetD}])\n  THEN'\n  mp_tac ctxt\n\\<close>"], ["", "method_setup synth_analz_mono_contra = \\<open>\n    Scan.succeed (fn ctxt => SIMPLE_METHOD (REPEAT_FIRST (synth_analz_mono_contra_tac ctxt)))\\<close>\n    \"for proving theorems of the form X \\<notin> synth (analz (knows A evs)) \\<longrightarrow> P\""], ["", "end"]]}