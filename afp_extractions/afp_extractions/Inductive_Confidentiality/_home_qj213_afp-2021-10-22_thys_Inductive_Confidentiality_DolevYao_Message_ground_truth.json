{"file_name": "/home/qj213/afp-2021-10-22/thys/Inductive_Confidentiality/DolevYao/Message.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Inductive_Confidentiality", "problem_names": ["lemma [simp] : \"A \\<union> (B \\<union> A) = B \\<union> A\"", "lemma parts_mono: \"G \\<subseteq> H ==> parts(G) \\<subseteq> parts(H)\"", "lemma Friend_image_eq [simp]: \"(Friend x \\<in> Friend`A) = (x:A)\"", "lemma Key_image_eq [simp]: \"(Key x \\<in> Key`A) = (x\\<in>A)\"", "lemma Nonce_Key_image_eq [simp]: \"(Nonce x \\<notin> Key`A)\"", "lemma invKey_eq [simp]: \"(invKey K = invKey K') = (K=K')\"", "lemma keysFor_empty [simp]: \"keysFor {} = {}\"", "lemma keysFor_Un [simp]: \"keysFor (H \\<union> H') = keysFor H \\<union> keysFor H'\"", "lemma keysFor_UN [simp]: \"keysFor (\\<Union>i\\<in>A. H i) = (\\<Union>i\\<in>A. keysFor (H i))\"", "lemma keysFor_mono: \"G \\<subseteq> H ==> keysFor(G) \\<subseteq> keysFor(H)\"", "lemma keysFor_insert_Agent [simp]: \"keysFor (insert (Agent A) H) = keysFor H\"", "lemma keysFor_insert_Nonce [simp]: \"keysFor (insert (Nonce N) H) = keysFor H\"", "lemma keysFor_insert_Number [simp]: \"keysFor (insert (Number N) H) = keysFor H\"", "lemma keysFor_insert_Key [simp]: \"keysFor (insert (Key K) H) = keysFor H\"", "lemma keysFor_insert_Hash [simp]: \"keysFor (insert (Hash X) H) = keysFor H\"", "lemma keysFor_insert_MPair [simp]: \"keysFor (insert \\<lbrace>X,Y\\<rbrace> H) = keysFor H\"", "lemma keysFor_insert_Crypt [simp]: \n    \"keysFor (insert (Crypt K X) H) = insert (invKey K) (keysFor H)\"", "lemma keysFor_image_Key [simp]: \"keysFor (Key`E) = {}\"", "lemma Crypt_imp_invKey_keysFor: \"Crypt K X \\<in> H ==> invKey K \\<in> keysFor H\"", "lemma MPair_parts:\n     \"[| \\<lbrace>X,Y\\<rbrace> \\<in> parts H;        \n         [| X \\<in> parts H; Y \\<in> parts H |] ==> P |] ==> P\"", "lemma parts_increasing: \"H \\<subseteq> parts(H)\"", "lemmas parts_insertI = subset_insertI [THEN parts_mono, THEN subsetD]", "lemma parts_empty [simp]: \"parts{} = {}\"", "lemma parts_emptyE [elim!]: \"X\\<in> parts{} ==> P\"", "lemma parts_singleton: \"X\\<in> parts H ==> \\<exists>Y\\<in>H. X\\<in> parts {Y}\"", "lemma parts_Un_subset1: \"parts(G) \\<union> parts(H) \\<subseteq> parts(G \\<union> H)\"", "lemma parts_Un_subset2: \"parts(G \\<union> H) \\<subseteq> parts(G) \\<union> parts(H)\"", "lemma parts_Un [simp]: \"parts(G \\<union> H) = parts(G) \\<union> parts(H)\"", "lemma parts_insert: \"parts (insert X H) = parts {X} \\<union> parts H\"", "lemma parts_insert2:\n     \"parts (insert X (insert Y H)) = parts {X} \\<union> parts {Y} \\<union> parts H\"", "lemma parts_UN_subset1: \"(\\<Union>x\\<in>A. parts(H x)) \\<subseteq> parts(\\<Union>x\\<in>A. H x)\"", "lemma parts_UN_subset2: \"parts(\\<Union>x\\<in>A. H x) \\<subseteq> (\\<Union>x\\<in>A. parts(H x))\"", "lemma parts_UN [simp]: \"parts(\\<Union>x\\<in>A. H x) = (\\<Union>x\\<in>A. parts(H x))\"", "lemmas in_parts_UnE = parts_Un [THEN equalityD1, THEN subsetD, THEN UnE]", "lemma parts_insert_subset: \"insert X (parts H) \\<subseteq> parts(insert X H)\"", "lemma parts_partsD [dest!]: \"X\\<in> parts (parts H) ==> X\\<in> parts H\"", "lemma parts_idem [simp]: \"parts (parts H) = parts H\"", "lemma parts_subset_iff [simp]: \"(parts G \\<subseteq> parts H) = (G \\<subseteq> parts H)\"", "lemma parts_trans: \"[| X\\<in> parts G;  G \\<subseteq> parts H |] ==> X\\<in> parts H\"", "lemma parts_cut:\n     \"[| Y\\<in> parts (insert X G);  X\\<in> parts H |] ==> Y\\<in> parts (G \\<union> H)\"", "lemma parts_cut_eq [simp]: \"X\\<in> parts H ==> parts (insert X H) = parts H\"", "lemmas parts_insert_eq_I = equalityI [OF subsetI parts_insert_subset]", "lemma parts_insert_Agent [simp]:\n     \"parts (insert (Agent agt) H) = insert (Agent agt) (parts H)\"", "lemma parts_insert_Nonce [simp]:\n     \"parts (insert (Nonce N) H) = insert (Nonce N) (parts H)\"", "lemma parts_insert_Number [simp]:\n     \"parts (insert (Number N) H) = insert (Number N) (parts H)\"", "lemma parts_insert_Key [simp]:\n     \"parts (insert (Key K) H) = insert (Key K) (parts H)\"", "lemma parts_insert_Hash [simp]:\n     \"parts (insert (Hash X) H) = insert (Hash X) (parts H)\"", "lemma parts_insert_Crypt [simp]:\n     \"parts (insert (Crypt K X) H) = insert (Crypt K X) (parts (insert X H))\"", "lemma parts_insert_MPair [simp]:\n     \"parts (insert \\<lbrace>X,Y\\<rbrace> H) =  \n          insert \\<lbrace>X,Y\\<rbrace> (parts (insert X (insert Y H)))\"", "lemma parts_image_Key [simp]: \"parts (Key`N) = Key`N\"", "lemma msg_Nonce_supply: \"\\<exists>N. \\<forall>n. N\\<le>n --> Nonce n \\<notin> parts {msg}\"", "lemma analz_mono: \"G\\<subseteq>H ==> analz(G) \\<subseteq> analz(H)\"", "lemma MPair_analz [elim!]:\n     \"[| \\<lbrace>X,Y\\<rbrace> \\<in> analz H;        \n             [| X \\<in> analz H; Y \\<in> analz H |] ==> P   \n          |] ==> P\"", "lemma analz_increasing: \"H \\<subseteq> analz(H)\"", "lemma analz_subset_parts: \"analz H \\<subseteq> parts H\"", "lemmas analz_into_parts = analz_subset_parts [THEN subsetD]", "lemmas not_parts_not_analz = analz_subset_parts [THEN contra_subsetD]", "lemma parts_analz [simp]: \"parts (analz H) = parts H\"", "lemma analz_parts [simp]: \"analz (parts H) = parts H\"", "lemmas analz_insertI = subset_insertI [THEN analz_mono, THEN [2] rev_subsetD]", "lemma analz_empty [simp]: \"analz{} = {}\"", "lemma analz_Un: \"analz(G) \\<union> analz(H) \\<subseteq> analz(G \\<union> H)\"", "lemma analz_insert: \"insert X (analz H) \\<subseteq> analz(insert X H)\"", "lemmas analz_insert_eq_I = equalityI [OF subsetI analz_insert]", "lemma analz_insert_Agent [simp]:\n     \"analz (insert (Agent agt) H) = insert (Agent agt) (analz H)\"", "lemma analz_insert_Nonce [simp]:\n     \"analz (insert (Nonce N) H) = insert (Nonce N) (analz H)\"", "lemma analz_insert_Number [simp]:\n     \"analz (insert (Number N) H) = insert (Number N) (analz H)\"", "lemma analz_insert_Hash [simp]:\n     \"analz (insert (Hash X) H) = insert (Hash X) (analz H)\"", "lemma analz_insert_Key [simp]: \n    \"K \\<notin> keysFor (analz H) ==>   \n          analz (insert (Key K) H) = insert (Key K) (analz H)\"", "lemma analz_insert_MPair [simp]:\n     \"analz (insert \\<lbrace>X,Y\\<rbrace> H) =  \n          insert \\<lbrace>X,Y\\<rbrace> (analz (insert X (insert Y H)))\"", "lemma analz_insert_Crypt:\n     \"Key (invKey K) \\<notin> analz H \n      ==> analz (insert (Crypt K X) H) = insert (Crypt K X) (analz H)\"", "lemma lemma1: \"Key (invKey K) \\<in> analz H ==>   \n               analz (insert (Crypt K X) H) \\<subseteq>  \n               insert (Crypt K X) (analz (insert X H))\"", "lemma lemma2: \"Key (invKey K) \\<in> analz H ==>   \n               insert (Crypt K X) (analz (insert X H)) \\<subseteq>  \n               analz (insert (Crypt K X) H)\"", "lemma analz_insert_Decrypt:\n     \"Key (invKey K) \\<in> analz H ==>   \n               analz (insert (Crypt K X) H) =  \n               insert (Crypt K X) (analz (insert X H))\"", "lemma analz_Crypt_if [simp]:\n     \"analz (insert (Crypt K X) H) =                 \n          (if (Key (invKey K) \\<in> analz H)                 \n           then insert (Crypt K X) (analz (insert X H))  \n           else insert (Crypt K X) (analz H))\"", "lemma analz_insert_Crypt_subset:\n     \"analz (insert (Crypt K X) H) \\<subseteq>   \n           insert (Crypt K X) (analz (insert X H))\"", "lemma analz_image_Key [simp]: \"analz (Key`N) = Key`N\"", "lemma analz_analzD [dest!]: \"X\\<in> analz (analz H) ==> X\\<in> analz H\"", "lemma analz_idem [simp]: \"analz (analz H) = analz H\"", "lemma analz_subset_iff [simp]: \"(analz G \\<subseteq> analz H) = (G \\<subseteq> analz H)\"", "lemma analz_trans: \"[| X\\<in> analz G;  G \\<subseteq> analz H |] ==> X\\<in> analz H\"", "lemma analz_cut: \"[| Y\\<in> analz (insert X H);  X\\<in> analz H |] ==> Y\\<in> analz H\"", "lemma analz_insert_eq: \"X\\<in> analz H ==> analz (insert X H) = analz H\"", "lemma analz_subset_cong:\n     \"[| analz G \\<subseteq> analz G'; analz H \\<subseteq> analz H' |] \n      ==> analz (G \\<union> H) \\<subseteq> analz (G' \\<union> H')\"", "lemma analz_cong:\n     \"[| analz G = analz G'; analz H = analz H' |] \n      ==> analz (G \\<union> H) = analz (G' \\<union> H')\"", "lemma analz_insert_cong:\n     \"analz H = analz H' ==> analz(insert X H) = analz(insert X H')\"", "lemma analz_trivial:\n     \"[| \\<forall>X Y. \\<lbrace>X,Y\\<rbrace> \\<notin> H;  \\<forall>X K. Crypt K X \\<notin> H |] ==> analz H = H\"", "lemma analz_UN_analz_lemma:\n     \"X\\<in> analz (\\<Union>i\\<in>A. analz (H i)) ==> X\\<in> analz (\\<Union>i\\<in>A. H i)\"", "lemma analz_UN_analz [simp]: \"analz (\\<Union>i\\<in>A. analz (H i)) = analz (\\<Union>i\\<in>A. H i)\"", "lemma synth_mono: \"G\\<subseteq>H ==> synth(G) \\<subseteq> synth(H)\"", "lemma synth_increasing: \"H \\<subseteq> synth(H)\"", "lemma synth_Un: \"synth(G) \\<union> synth(H) \\<subseteq> synth(G \\<union> H)\"", "lemma synth_insert: \"insert X (synth H) \\<subseteq> synth(insert X H)\"", "lemma synth_synthD [dest!]: \"X\\<in> synth (synth H) ==> X\\<in> synth H\"", "lemma synth_idem: \"synth (synth H) = synth H\"", "lemma synth_subset_iff [simp]: \"(synth G \\<subseteq> synth H) = (G \\<subseteq> synth H)\"", "lemma synth_trans: \"[| X\\<in> synth G;  G \\<subseteq> synth H |] ==> X\\<in> synth H\"", "lemma synth_cut: \"[| Y\\<in> synth (insert X H);  X\\<in> synth H |] ==> Y\\<in> synth H\"", "lemma Agent_synth [simp]: \"Agent A \\<in> synth H\"", "lemma Number_synth [simp]: \"Number n \\<in> synth H\"", "lemma Nonce_synth_eq [simp]: \"(Nonce N \\<in> synth H) = (Nonce N \\<in> H)\"", "lemma Key_synth_eq [simp]: \"(Key K \\<in> synth H) = (Key K \\<in> H)\"", "lemma Crypt_synth_eq [simp]:\n     \"Key K \\<notin> H ==> (Crypt K X \\<in> synth H) = (Crypt K X \\<in> H)\"", "lemma keysFor_synth [simp]: \n    \"keysFor (synth H) = keysFor H \\<union> invKey`{K. Key K \\<in> H}\"", "lemma parts_synth [simp]: \"parts (synth H) = parts H \\<union> synth H\"", "lemma analz_analz_Un [simp]: \"analz (analz G \\<union> H) = analz (G \\<union> H)\"", "lemma analz_synth_Un [simp]: \"analz (synth G \\<union> H) = analz (G \\<union> H) \\<union> synth G\"", "lemma analz_synth [simp]: \"analz (synth H) = analz H \\<union> synth H\"", "lemma parts_insert_subset_Un: \"X\\<in> G ==> parts(insert X H) \\<subseteq> parts G \\<union> parts H\"", "lemma Fake_parts_insert:\n     \"X \\<in> synth (analz H) ==>  \n      parts (insert X H) \\<subseteq> synth (analz H) \\<union> parts H\"", "lemma Fake_parts_insert_in_Un:\n     \"[|Z \\<in> parts (insert X H);  X: synth (analz H)|] \n      ==> Z \\<in>  synth (analz H) \\<union> parts H\"", "lemma Fake_analz_insert:\n     \"X\\<in> synth (analz G) ==>  \n      analz (insert X H) \\<subseteq> synth (analz G) \\<union> analz (G \\<union> H)\"", "lemma analz_conj_parts [simp]:\n     \"(X \\<in> analz H \\<and> X \\<in> parts H) = (X \\<in> analz H)\"", "lemma analz_disj_parts [simp]:\n     \"(X \\<in> analz H | X \\<in> parts H) = (X \\<in> parts H)\"", "lemma MPair_synth_analz [iff]:\n     \"(\\<lbrace>X,Y\\<rbrace> \\<in> synth (analz H)) =  \n      (X \\<in> synth (analz H) \\<and> Y \\<in> synth (analz H))\"", "lemma Crypt_synth_analz:\n     \"[| Key K \\<in> analz H;  Key (invKey K) \\<in> analz H |]  \n       ==> (Crypt K X \\<in> synth (analz H)) = (X \\<in> synth (analz H))\"", "lemma Hash_synth_analz [simp]:\n     \"X \\<notin> synth (analz H)  \n      ==> (Hash\\<lbrace>X,Y\\<rbrace> \\<in> synth (analz H)) = (Hash\\<lbrace>X,Y\\<rbrace> \\<in> analz H)\"", "lemma Agent_neq_HPair: \"Agent A ~= Hash[X] Y\"", "lemma Nonce_neq_HPair: \"Nonce N ~= Hash[X] Y\"", "lemma Number_neq_HPair: \"Number N ~= Hash[X] Y\"", "lemma Key_neq_HPair: \"Key K ~= Hash[X] Y\"", "lemma Hash_neq_HPair: \"Hash Z ~= Hash[X] Y\"", "lemma Crypt_neq_HPair: \"Crypt K X' ~= Hash[X] Y\"", "lemmas HPair_neqs = Agent_neq_HPair Nonce_neq_HPair Number_neq_HPair \n                    Key_neq_HPair Hash_neq_HPair Crypt_neq_HPair", "lemma HPair_eq [iff]: \"(Hash[X'] Y' = Hash[X] Y) = (X' = X \\<and> Y'=Y)\"", "lemma MPair_eq_HPair [iff]:\n     \"(\\<lbrace>X',Y'\\<rbrace> = Hash[X] Y) = (X' = Hash\\<lbrace>X,Y\\<rbrace> \\<and> Y'=Y)\"", "lemma HPair_eq_MPair [iff]:\n     \"(Hash[X] Y = \\<lbrace>X',Y'\\<rbrace>) = (X' = Hash\\<lbrace>X,Y\\<rbrace> \\<and> Y'=Y)\"", "lemma keysFor_insert_HPair [simp]: \"keysFor (insert (Hash[X] Y) H) = keysFor H\"", "lemma parts_insert_HPair [simp]: \n    \"parts (insert (Hash[X] Y) H) =  \n     insert (Hash[X] Y) (insert (Hash\\<lbrace>X,Y\\<rbrace>) (parts (insert Y H)))\"", "lemma analz_insert_HPair [simp]: \n    \"analz (insert (Hash[X] Y) H) =  \n     insert (Hash[X] Y) (insert (Hash\\<lbrace>X,Y\\<rbrace>) (analz (insert Y H)))\"", "lemma HPair_synth_analz [simp]:\n     \"X \\<notin> synth (analz H)  \n    ==> (Hash[X] Y \\<in> synth (analz H)) =  \n        (Hash \\<lbrace>X, Y\\<rbrace> \\<in> analz H \\<and> Y \\<in> synth (analz H))\"", "lemmas pushKeys =\n  insert_commute [of \"Key K\" \"Agent C\"]\n  insert_commute [of \"Key K\" \"Nonce N\"]\n  insert_commute [of \"Key K\" \"Number N\"]\n  insert_commute [of \"Key K\" \"Hash X\"]\n  insert_commute [of \"Key K\" \"MPair X Y\"]\n  insert_commute [of \"Key K\" \"Crypt X K'\"]\n  for K C N X Y K'", "lemmas pushCrypts =\n  insert_commute [of \"Crypt X K\" \"Agent C\"]\n  insert_commute [of \"Crypt X K\" \"Agent C\"]\n  insert_commute [of \"Crypt X K\" \"Nonce N\"]\n  insert_commute [of \"Crypt X K\" \"Number N\"]\n  insert_commute [of \"Crypt X K\" \"Hash X'\"]\n  insert_commute [of \"Crypt X K\" \"MPair X' Y\"]\n  for X K C N X' Y", "lemmas pushes = pushKeys pushCrypts", "lemma parts_keyfree: \"parts (keyfree) \\<subseteq> keyfree\"", "lemma analz_keyfree_into_Un: \"\\<lbrakk>X \\<in> analz (G \\<union> H); G \\<subseteq> keyfree\\<rbrakk> \\<Longrightarrow> X \\<in> parts G \\<union> analz H\"", "lemma Crypt_notin_image_Key [simp]: \"Crypt K X \\<notin> Key ` A\"", "lemma Hash_notin_image_Key [simp] :\"Hash X \\<notin> Key ` A\"", "lemma synth_analz_mono: \"G\\<subseteq>H ==> synth (analz(G)) \\<subseteq> synth (analz(H))\"", "lemma Fake_analz_eq [simp]:\n     \"X \\<in> synth(analz H) ==> synth (analz (insert X H)) = synth (analz H)\"", "lemma gen_analz_insert_eq [rule_format]:\n     \"X \\<in> analz H ==> \\<forall>G. H \\<subseteq> G --> analz (insert X G) = analz G\"", "lemma synth_analz_insert_eq [rule_format]:\n     \"X \\<in> synth (analz H) \n      ==> \\<forall>G. H \\<subseteq> G --> (Key K \\<in> analz (insert X G)) = (Key K \\<in> analz G)\"", "lemma Fake_parts_sing:\n     \"X \\<in> synth (analz H) ==> parts{X} \\<subseteq> synth (analz H) \\<union> parts H\"", "lemmas Fake_parts_sing_imp_Un = Fake_parts_sing [THEN [2] rev_subsetD]"], "translations": [["", "lemma [simp] : \"A \\<union> (B \\<union> A) = B \\<union> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<union> (B \\<union> A) = B \\<union> A", "by blast"], ["", "type_synonym\n  key = nat"], ["", "consts\n  all_symmetric :: bool        \\<comment> \\<open>true if all keys are symmetric\\<close>\n  invKey        :: \"key=>key\"  \\<comment> \\<open>inverse of a symmetric key\\<close>"], ["", "specification (invKey)\n  invKey [simp]: \"invKey (invKey K) = K\"\n  invKey_symmetric: \"all_symmetric --> invKey = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>invKey.\n       (\\<forall>K. invKey (invKey K) = K) \\<and>\n       (all_symmetric \\<longrightarrow> invKey = id)", "by (rule exI [of _ id], auto)"], ["", "text\\<open>The inverse of a symmetric key is itself; that of a public key\n      is the private key and vice versa\\<close>"], ["", "definition symKeys :: \"key set\" where\n  \"symKeys == {K. invKey K = K}\""], ["", "datatype  \\<comment> \\<open>We allow any number of friendly agents\\<close>\n  agent = Server | Friend nat | Spy"], ["", "datatype\n     msg = Agent  agent     \\<comment> \\<open>Agent names\\<close>\n         | Number nat       \\<comment> \\<open>Ordinary integers, timestamps, ...\\<close>\n         | Nonce  nat       \\<comment> \\<open>Unguessable nonces\\<close>\n         | Key    key       \\<comment> \\<open>Crypto keys\\<close>\n         | Hash   msg       \\<comment> \\<open>Hashing\\<close>\n         | MPair  msg msg   \\<comment> \\<open>Compound messages\\<close>\n         | Crypt  key msg   \\<comment> \\<open>Encryption, public- or shared-key\\<close>"], ["", "text\\<open>Concrete syntax: messages appear as \\<open>\\<lbrace>A,B,NA\\<rbrace>\\<close>, etc...\\<close>"], ["", "syntax\n  \"_MTuple\" :: \"['a, args] => 'a * 'b\"  (\"(2\\<lbrace>_,/ _\\<rbrace>)\")"], ["", "translations\n  \"\\<lbrace>x, y, z\\<rbrace>\"   == \"\\<lbrace>x, \\<lbrace>y, z\\<rbrace>\\<rbrace>\"\n  \"\\<lbrace>x, y\\<rbrace>\"      == \"CONST MPair x y\""], ["", "definition HPair :: \"[msg,msg] => msg\" (\"(4Hash[_] /_)\" [0, 1000]) where\n    \\<comment> \\<open>Message Y paired with a MAC computed with the help of X\\<close>\n    \"Hash[X] Y == \\<lbrace> Hash\\<lbrace>X,Y\\<rbrace>, Y\\<rbrace>\""], ["", "definition keysFor :: \"msg set => key set\" where\n    \\<comment> \\<open>Keys useful to decrypt elements of a message set\\<close>\n  \"keysFor H == invKey ` {K. \\<exists>X. Crypt K X \\<in> H}\""], ["", "subsection\\<open>Inductive definition of all parts of a message\\<close>"], ["", "inductive_set\n  parts :: \"msg set => msg set\"\n  for H :: \"msg set\"\n  where\n    Inj [intro]:               \"X \\<in> H ==> X \\<in> parts H\"\n  | Fst:         \"\\<lbrace>X,Y\\<rbrace>   \\<in> parts H ==> X \\<in> parts H\"\n  | Snd:         \"\\<lbrace>X,Y\\<rbrace>   \\<in> parts H ==> Y \\<in> parts H\"\n  | Body:        \"Crypt K X \\<in> parts H ==> X \\<in> parts H\""], ["", "text\\<open>Monotonicity\\<close>"], ["", "lemma parts_mono: \"G \\<subseteq> H ==> parts(G) \\<subseteq> parts(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow> parts G \\<subseteq> parts H", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>G \\<subseteq> H; x \\<in> parts G\\<rbrakk>\n       \\<Longrightarrow> x \\<in> parts H", "apply (erule parts.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>G \\<subseteq> H; X \\<in> G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> parts H\n 2. \\<And>x X Y.\n       \\<lbrakk>G \\<subseteq> H; \\<lbrace>X, Y\\<rbrace> \\<in> parts G;\n        \\<lbrace>X, Y\\<rbrace> \\<in> parts H\\<rbrakk>\n       \\<Longrightarrow> X \\<in> parts H\n 3. \\<And>x X Y.\n       \\<lbrakk>G \\<subseteq> H; \\<lbrace>X, Y\\<rbrace> \\<in> parts G;\n        \\<lbrace>X, Y\\<rbrace> \\<in> parts H\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> parts H\n 4. \\<And>x K X.\n       \\<lbrakk>G \\<subseteq> H; Crypt K X \\<in> parts G;\n        Crypt K X \\<in> parts H\\<rbrakk>\n       \\<Longrightarrow> X \\<in> parts H", "apply (blast dest: parts.Fst parts.Snd parts.Body)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Equations hold because constructors are injective.\\<close>"], ["", "lemma Friend_image_eq [simp]: \"(Friend x \\<in> Friend`A) = (x:A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Friend x \\<in> Friend ` A) = (x \\<in> A)", "by auto"], ["", "lemma Key_image_eq [simp]: \"(Key x \\<in> Key`A) = (x\\<in>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Key x \\<in> Key ` A) = (x \\<in> A)", "by auto"], ["", "lemma Nonce_Key_image_eq [simp]: \"(Nonce x \\<notin> Key`A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nonce x \\<notin> Key ` A", "by auto"], ["", "subsection\\<open>Inverse of keys\\<close>"], ["", "lemma invKey_eq [simp]: \"(invKey K = invKey K') = (K=K')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invKey K = invKey K') = (K = K')", "by (metis invKey)"], ["", "subsection\\<open>keysFor operator\\<close>"], ["", "lemma keysFor_empty [simp]: \"keysFor {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor {} = {}", "by (unfold keysFor_def, blast)"], ["", "lemma keysFor_Un [simp]: \"keysFor (H \\<union> H') = keysFor H \\<union> keysFor H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (H \\<union> H') = keysFor H \\<union> keysFor H'", "by (unfold keysFor_def, blast)"], ["", "lemma keysFor_UN [simp]: \"keysFor (\\<Union>i\\<in>A. H i) = (\\<Union>i\\<in>A. keysFor (H i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (\\<Union> (H ` A)) = (\\<Union>i\\<in>A. keysFor (H i))", "by (unfold keysFor_def, blast)"], ["", "text\\<open>Monotonicity\\<close>"], ["", "lemma keysFor_mono: \"G \\<subseteq> H ==> keysFor(G) \\<subseteq> keysFor(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow> keysFor G \\<subseteq> keysFor H", "by (unfold keysFor_def, blast)"], ["", "lemma keysFor_insert_Agent [simp]: \"keysFor (insert (Agent A) H) = keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (insert (Agent A) H) = keysFor H", "by (unfold keysFor_def, auto)"], ["", "lemma keysFor_insert_Nonce [simp]: \"keysFor (insert (Nonce N) H) = keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (insert (Nonce N) H) = keysFor H", "by (unfold keysFor_def, auto)"], ["", "lemma keysFor_insert_Number [simp]: \"keysFor (insert (Number N) H) = keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (insert (Number N) H) = keysFor H", "by (unfold keysFor_def, auto)"], ["", "lemma keysFor_insert_Key [simp]: \"keysFor (insert (Key K) H) = keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (insert (Key K) H) = keysFor H", "by (unfold keysFor_def, auto)"], ["", "lemma keysFor_insert_Hash [simp]: \"keysFor (insert (Hash X) H) = keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (insert (Hash X) H) = keysFor H", "by (unfold keysFor_def, auto)"], ["", "lemma keysFor_insert_MPair [simp]: \"keysFor (insert \\<lbrace>X,Y\\<rbrace> H) = keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (insert \\<lbrace>X, Y\\<rbrace> H) = keysFor H", "by (unfold keysFor_def, auto)"], ["", "lemma keysFor_insert_Crypt [simp]: \n    \"keysFor (insert (Crypt K X) H) = insert (invKey K) (keysFor H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (insert (Crypt K X) H) = insert (invKey K) (keysFor H)", "by (unfold keysFor_def, auto)"], ["", "lemma keysFor_image_Key [simp]: \"keysFor (Key`E) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (Key ` E) = {}", "by (unfold keysFor_def, auto)"], ["", "lemma Crypt_imp_invKey_keysFor: \"Crypt K X \\<in> H ==> invKey K \\<in> keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Crypt K X \\<in> H \\<Longrightarrow> invKey K \\<in> keysFor H", "by (unfold keysFor_def, blast)"], ["", "subsection\\<open>Inductive relation \"parts\"\\<close>"], ["", "lemma MPair_parts:\n     \"[| \\<lbrace>X,Y\\<rbrace> \\<in> parts H;        \n         [| X \\<in> parts H; Y \\<in> parts H |] ==> P |] ==> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> parts H;\n     \\<lbrakk>X \\<in> parts H; Y \\<in> parts H\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (blast dest: parts.Fst parts.Snd)"], ["", "declare MPair_parts [elim!]  parts.Body [dest!]"], ["", "text\\<open>NB These two rules are UNSAFE in the formal sense, as they discard the\n     compound message.  They work well on THIS FILE.  \n  \\<open>MPair_parts\\<close> is left as SAFE because it speeds up proofs.\n  The Crypt rule is normally kept UNSAFE to avoid breaking up certificates.\\<close>"], ["", "lemma parts_increasing: \"H \\<subseteq> parts(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<subseteq> parts H", "by blast"], ["", "lemmas parts_insertI = subset_insertI [THEN parts_mono, THEN subsetD]"], ["", "lemma parts_empty [simp]: \"parts{} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts {} = {}", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> parts {} \\<Longrightarrow> x \\<in> {}", "apply (erule parts.induct, blast+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_emptyE [elim!]: \"X\\<in> parts{} ==> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> parts {} \\<Longrightarrow> P", "by simp"], ["", "text\\<open>WARNING: loops if H = {Y}, therefore must not be repeated!\\<close>"], ["", "lemma parts_singleton: \"X\\<in> parts H ==> \\<exists>Y\\<in>H. X\\<in> parts {Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> parts H \\<Longrightarrow> \\<exists>Y\\<in>H. X \\<in> parts {Y}", "by (erule parts.induct, fast+)"], ["", "subsubsection\\<open>Unions\\<close>"], ["", "lemma parts_Un_subset1: \"parts(G) \\<union> parts(H) \\<subseteq> parts(G \\<union> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts G \\<union> parts H \\<subseteq> parts (G \\<union> H)", "by (intro Un_least parts_mono Un_upper1 Un_upper2)"], ["", "lemma parts_Un_subset2: \"parts(G \\<union> H) \\<subseteq> parts(G) \\<union> parts(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (G \\<union> H) \\<subseteq> parts G \\<union> parts H", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parts (G \\<union> H) \\<Longrightarrow>\n       x \\<in> parts G \\<union> parts H", "apply (erule parts.induct, blast+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_Un [simp]: \"parts(G \\<union> H) = parts(G) \\<union> parts(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (G \\<union> H) = parts G \\<union> parts H", "by (intro equalityI parts_Un_subset1 parts_Un_subset2)"], ["", "lemma parts_insert: \"parts (insert X H) = parts {X} \\<union> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert X H) = parts {X} \\<union> parts H", "by (metis insert_is_Un parts_Un)"], ["", "text\\<open>TWO inserts to avoid looping.  This rewrite is better than nothing.\n  Not suitable for Addsimps: its behaviour can be strange.\\<close>"], ["", "lemma parts_insert2:\n     \"parts (insert X (insert Y H)) = parts {X} \\<union> parts {Y} \\<union> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert X (insert Y H)) =\n    parts {X} \\<union> parts {Y} \\<union> parts H", "by (metis Un_commute Un_empty_right Un_insert_right insert_is_Un parts_Un)"], ["", "lemma parts_UN_subset1: \"(\\<Union>x\\<in>A. parts(H x)) \\<subseteq> parts(\\<Union>x\\<in>A. H x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>A. parts (H x)) \\<subseteq> parts (\\<Union> (H ` A))", "by (intro UN_least parts_mono UN_upper)"], ["", "lemma parts_UN_subset2: \"parts(\\<Union>x\\<in>A. H x) \\<subseteq> (\\<Union>x\\<in>A. parts(H x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (\\<Union> (H ` A)) \\<subseteq> (\\<Union>x\\<in>A. parts (H x))", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parts (\\<Union> (H ` A)) \\<Longrightarrow>\n       x \\<in> (\\<Union>x\\<in>A. parts (H x))", "apply (erule parts.induct, blast+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_UN [simp]: \"parts(\\<Union>x\\<in>A. H x) = (\\<Union>x\\<in>A. parts(H x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (\\<Union> (H ` A)) = (\\<Union>x\\<in>A. parts (H x))", "by (intro equalityI parts_UN_subset1 parts_UN_subset2)"], ["", "text\\<open>Added to simplify arguments to parts, analz and synth.\n  NOTE: the UN versions are no longer used!\\<close>"], ["", "text\\<open>This allows \\<open>blast\\<close> to simplify occurrences of \n  @{term \"parts(G\\<union>H)\"} in the assumption.\\<close>"], ["", "lemmas in_parts_UnE = parts_Un [THEN equalityD1, THEN subsetD, THEN UnE]"], ["", "declare in_parts_UnE [elim!]"], ["", "lemma parts_insert_subset: \"insert X (parts H) \\<subseteq> parts(insert X H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert X (parts H) \\<subseteq> parts (insert X H)", "by (blast intro: parts_mono [THEN [2] rev_subsetD])"], ["", "subsubsection\\<open>Idempotence and transitivity\\<close>"], ["", "lemma parts_partsD [dest!]: \"X\\<in> parts (parts H) ==> X\\<in> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> parts (parts H) \\<Longrightarrow> X \\<in> parts H", "by (erule parts.induct, blast+)"], ["", "lemma parts_idem [simp]: \"parts (parts H) = parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (parts H) = parts H", "by blast"], ["", "lemma parts_subset_iff [simp]: \"(parts G \\<subseteq> parts H) = (G \\<subseteq> parts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (parts G \\<subseteq> parts H) = (G \\<subseteq> parts H)", "by (metis parts_idem parts_increasing parts_mono subset_trans)"], ["", "lemma parts_trans: \"[| X\\<in> parts G;  G \\<subseteq> parts H |] ==> X\\<in> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> parts G; G \\<subseteq> parts H\\<rbrakk>\n    \\<Longrightarrow> X \\<in> parts H", "by (metis parts_subset_iff subsetD)"], ["", "text\\<open>Cut\\<close>"], ["", "lemma parts_cut:\n     \"[| Y\\<in> parts (insert X G);  X\\<in> parts H |] ==> Y\\<in> parts (G \\<union> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Y \\<in> parts (insert X G); X \\<in> parts H\\<rbrakk>\n    \\<Longrightarrow> Y \\<in> parts (G \\<union> H)", "by (blast intro: parts_trans)"], ["", "lemma parts_cut_eq [simp]: \"X\\<in> parts H ==> parts (insert X H) = parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> parts H \\<Longrightarrow> parts (insert X H) = parts H", "by (metis insert_absorb parts_idem parts_insert)"], ["", "subsubsection\\<open>Rewrite rules for pulling out atomic messages\\<close>"], ["", "lemmas parts_insert_eq_I = equalityI [OF subsetI parts_insert_subset]"], ["", "lemma parts_insert_Agent [simp]:\n     \"parts (insert (Agent agt) H) = insert (Agent agt) (parts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert (Agent agt) H) = insert (Agent agt) (parts H)", "apply (rule parts_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parts (insert (Agent agt) H) \\<Longrightarrow>\n       x \\<in> insert (Agent agt) (parts H)", "apply (erule parts.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_insert_Nonce [simp]:\n     \"parts (insert (Nonce N) H) = insert (Nonce N) (parts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert (Nonce N) H) = insert (Nonce N) (parts H)", "apply (rule parts_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parts (insert (Nonce N) H) \\<Longrightarrow>\n       x \\<in> insert (Nonce N) (parts H)", "apply (erule parts.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_insert_Number [simp]:\n     \"parts (insert (Number N) H) = insert (Number N) (parts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert (Number N) H) = insert (Number N) (parts H)", "apply (rule parts_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parts (insert (Number N) H) \\<Longrightarrow>\n       x \\<in> insert (Number N) (parts H)", "apply (erule parts.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_insert_Key [simp]:\n     \"parts (insert (Key K) H) = insert (Key K) (parts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert (Key K) H) = insert (Key K) (parts H)", "apply (rule parts_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parts (insert (Key K) H) \\<Longrightarrow>\n       x \\<in> insert (Key K) (parts H)", "apply (erule parts.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_insert_Hash [simp]:\n     \"parts (insert (Hash X) H) = insert (Hash X) (parts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert (Hash X) H) = insert (Hash X) (parts H)", "apply (rule parts_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parts (insert (Hash X) H) \\<Longrightarrow>\n       x \\<in> insert (Hash X) (parts H)", "apply (erule parts.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_insert_Crypt [simp]:\n     \"parts (insert (Crypt K X) H) = insert (Crypt K X) (parts (insert X H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert (Crypt K X) H) = insert (Crypt K X) (parts (insert X H))", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. parts (insert (Crypt K X) H)\n    \\<subseteq> insert (Crypt K X) (parts (insert X H))\n 2. insert (Crypt K X) (parts (insert X H))\n    \\<subseteq> parts (insert (Crypt K X) H)", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> parts (insert (Crypt K X) H) \\<Longrightarrow>\n       x \\<in> insert (Crypt K X) (parts (insert X H))\n 2. insert (Crypt K X) (parts (insert X H))\n    \\<subseteq> parts (insert (Crypt K X) H)", "apply (erule parts.induct, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> parts (insert (Crypt K X) H)", "apply (blast intro: parts.Body)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_insert_MPair [simp]:\n     \"parts (insert \\<lbrace>X,Y\\<rbrace> H) =  \n          insert \\<lbrace>X,Y\\<rbrace> (parts (insert X (insert Y H)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert \\<lbrace>X, Y\\<rbrace> H) =\n    insert \\<lbrace>X, Y\\<rbrace> (parts (insert X (insert Y H)))", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. parts (insert \\<lbrace>X, Y\\<rbrace> H)\n    \\<subseteq> insert \\<lbrace>X, Y\\<rbrace>\n                 (parts (insert X (insert Y H)))\n 2. insert \\<lbrace>X, Y\\<rbrace> (parts (insert X (insert Y H)))\n    \\<subseteq> parts (insert \\<lbrace>X, Y\\<rbrace> H)", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> parts (insert \\<lbrace>X, Y\\<rbrace> H) \\<Longrightarrow>\n       x \\<in> insert \\<lbrace>X, Y\\<rbrace> (parts (insert X (insert Y H)))\n 2. insert \\<lbrace>X, Y\\<rbrace> (parts (insert X (insert Y H)))\n    \\<subseteq> parts (insert \\<lbrace>X, Y\\<rbrace> H)", "apply (erule parts.induct, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. X \\<in> parts (insert \\<lbrace>X, Y\\<rbrace> H)\n 2. Y \\<in> parts (insert \\<lbrace>X, Y\\<rbrace> H)", "apply (blast intro: parts.Fst parts.Snd)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_image_Key [simp]: \"parts (Key`N) = Key`N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (Key ` N) = Key ` N", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> parts (Key ` N) \\<Longrightarrow> x \\<in> Key ` N", "apply (erule parts.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>In any message, there is an upper bound N on its greatest nonce.\\<close>"], ["", "lemma msg_Nonce_supply: \"\\<exists>N. \\<forall>n. N\\<le>n --> Nonce n \\<notin> parts {msg}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {msg}", "apply (induct msg)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x. \\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {Agent x}\n 2. \\<And>x. \\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {Number x}\n 3. \\<And>x. \\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {Nonce x}\n 4. \\<And>x. \\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {Key x}\n 5. \\<And>msg.\n       \\<exists>N.\n          \\<forall>n\\<ge>N. Nonce n \\<notin> parts {msg} \\<Longrightarrow>\n       \\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {Hash msg}\n 6. \\<And>msg1 msg2.\n       \\<lbrakk>\\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {msg1};\n        \\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {msg2}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N.\n                            \\<forall>n\\<ge>N.\n                               Nonce n\n                               \\<notin> parts {\\<lbrace>msg1, msg2\\<rbrace>}\n 7. \\<And>x1a msg.\n       \\<exists>N.\n          \\<forall>n\\<ge>N. Nonce n \\<notin> parts {msg} \\<Longrightarrow>\n       \\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {Crypt x1a msg}", "apply (simp_all (no_asm_simp) add: exI parts_insert2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. \\<exists>N. \\<forall>n\\<ge>N. n \\<noteq> x\n 2. \\<And>msg1 msg2.\n       \\<lbrakk>\\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {msg1};\n        \\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {msg2}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N.\n                            \\<forall>n\\<ge>N.\n                               Nonce n \\<notin> parts {msg1} \\<and>\n                               Nonce n \\<notin> parts {msg2}", "txt\\<open>Nonce case\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. \\<exists>N. \\<forall>n\\<ge>N. n \\<noteq> x\n 2. \\<And>msg1 msg2.\n       \\<lbrakk>\\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {msg1};\n        \\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {msg2}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N.\n                            \\<forall>n\\<ge>N.\n                               Nonce n \\<notin> parts {msg1} \\<and>\n                               Nonce n \\<notin> parts {msg2}", "apply (metis Suc_n_not_le_n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>msg1 msg2.\n       \\<lbrakk>\\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {msg1};\n        \\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {msg2}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N.\n                            \\<forall>n\\<ge>N.\n                               Nonce n \\<notin> parts {msg1} \\<and>\n                               Nonce n \\<notin> parts {msg2}", "txt\\<open>MPair case: metis works out the necessary sum itself!\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>msg1 msg2.\n       \\<lbrakk>\\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {msg1};\n        \\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> parts {msg2}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N.\n                            \\<forall>n\\<ge>N.\n                               Nonce n \\<notin> parts {msg1} \\<and>\n                               Nonce n \\<notin> parts {msg2}", "apply (metis le_trans nat_le_linear)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Inductive relation \"analz\"\\<close>"], ["", "text\\<open>Inductive definition of \"analz\" -- what can be broken down from a set of\n    messages, including keys.  A form of downward closure.  Pairs can\n    be taken apart; messages decrypted with known keys.\\<close>"], ["", "inductive_set\n  analz :: \"msg set => msg set\"\n  for H :: \"msg set\"\n  where\n    Inj [intro,simp] :    \"X \\<in> H ==> X \\<in> analz H\"\n  | Fst:     \"\\<lbrace>X,Y\\<rbrace> \\<in> analz H ==> X \\<in> analz H\"\n  | Snd:     \"\\<lbrace>X,Y\\<rbrace> \\<in> analz H ==> Y \\<in> analz H\"\n  | Decrypt [dest]: \n             \"[|Crypt K X \\<in> analz H; Key(invKey K): analz H|] ==> X \\<in> analz H\""], ["", "text\\<open>Monotonicity; Lemma 1 of Lowe's paper\\<close>"], ["", "lemma analz_mono: \"G\\<subseteq>H ==> analz(G) \\<subseteq> analz(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow> analz G \\<subseteq> analz H", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>G \\<subseteq> H; x \\<in> analz G\\<rbrakk>\n       \\<Longrightarrow> x \\<in> analz H", "apply (erule analz.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>G \\<subseteq> H; X \\<in> G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz H\n 2. \\<And>x X Y.\n       \\<lbrakk>G \\<subseteq> H; \\<lbrace>X, Y\\<rbrace> \\<in> analz G;\n        \\<lbrace>X, Y\\<rbrace> \\<in> analz H\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz H\n 3. \\<And>x X Y.\n       \\<lbrakk>G \\<subseteq> H; \\<lbrace>X, Y\\<rbrace> \\<in> analz G;\n        \\<lbrace>X, Y\\<rbrace> \\<in> analz H\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz H\n 4. \\<And>x K X.\n       \\<lbrakk>G \\<subseteq> H; Crypt K X \\<in> analz G;\n        Crypt K X \\<in> analz H; Key (invKey K) \\<in> analz G;\n        Key (invKey K) \\<in> analz H\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz H", "apply (auto dest: analz.Fst analz.Snd)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Making it safe speeds up proofs\\<close>"], ["", "lemma MPair_analz [elim!]:\n     \"[| \\<lbrace>X,Y\\<rbrace> \\<in> analz H;        \n             [| X \\<in> analz H; Y \\<in> analz H |] ==> P   \n          |] ==> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> analz H;\n     \\<lbrakk>X \\<in> analz H; Y \\<in> analz H\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (blast dest: analz.Fst analz.Snd)"], ["", "lemma analz_increasing: \"H \\<subseteq> analz(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<subseteq> analz H", "by blast"], ["", "lemma analz_subset_parts: \"analz H \\<subseteq> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz H \\<subseteq> parts H", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> analz H \\<Longrightarrow> x \\<in> parts H", "apply (erule analz.induct, blast+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas analz_into_parts = analz_subset_parts [THEN subsetD]"], ["", "lemmas not_parts_not_analz = analz_subset_parts [THEN contra_subsetD]"], ["", "lemma parts_analz [simp]: \"parts (analz H) = parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (analz H) = parts H", "by (metis analz_increasing analz_subset_parts equalityI parts_mono parts_subset_iff)"], ["", "lemma analz_parts [simp]: \"analz (parts H) = parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (parts H) = parts H", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> analz (parts H) \\<Longrightarrow> x \\<in> parts H", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas analz_insertI = subset_insertI [THEN analz_mono, THEN [2] rev_subsetD]"], ["", "subsubsection\\<open>General equational properties\\<close>"], ["", "lemma analz_empty [simp]: \"analz{} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz {} = {}", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> analz {} \\<Longrightarrow> x \\<in> {}", "apply (erule analz.induct, blast+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Converse fails: we can analz more from the union than from the \n  separate parts, as a key in one might decrypt a message in the other\\<close>"], ["", "lemma analz_Un: \"analz(G) \\<union> analz(H) \\<subseteq> analz(G \\<union> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz G \\<union> analz H \\<subseteq> analz (G \\<union> H)", "by (intro Un_least analz_mono Un_upper1 Un_upper2)"], ["", "lemma analz_insert: \"insert X (analz H) \\<subseteq> analz(insert X H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert X (analz H) \\<subseteq> analz (insert X H)", "by (blast intro: analz_mono [THEN [2] rev_subsetD])"], ["", "subsubsection\\<open>Rewrite rules for pulling out atomic messages\\<close>"], ["", "lemmas analz_insert_eq_I = equalityI [OF subsetI analz_insert]"], ["", "lemma analz_insert_Agent [simp]:\n     \"analz (insert (Agent agt) H) = insert (Agent agt) (analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert (Agent agt) H) = insert (Agent agt) (analz H)", "apply (rule analz_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> analz (insert (Agent agt) H) \\<Longrightarrow>\n       x \\<in> insert (Agent agt) (analz H)", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_insert_Nonce [simp]:\n     \"analz (insert (Nonce N) H) = insert (Nonce N) (analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert (Nonce N) H) = insert (Nonce N) (analz H)", "apply (rule analz_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> analz (insert (Nonce N) H) \\<Longrightarrow>\n       x \\<in> insert (Nonce N) (analz H)", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_insert_Number [simp]:\n     \"analz (insert (Number N) H) = insert (Number N) (analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert (Number N) H) = insert (Number N) (analz H)", "apply (rule analz_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> analz (insert (Number N) H) \\<Longrightarrow>\n       x \\<in> insert (Number N) (analz H)", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_insert_Hash [simp]:\n     \"analz (insert (Hash X) H) = insert (Hash X) (analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert (Hash X) H) = insert (Hash X) (analz H)", "apply (rule analz_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> analz (insert (Hash X) H) \\<Longrightarrow>\n       x \\<in> insert (Hash X) (analz H)", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Can only pull out Keys if they are not needed to decrypt the rest\\<close>"], ["", "lemma analz_insert_Key [simp]: \n    \"K \\<notin> keysFor (analz H) ==>   \n          analz (insert (Key K) H) = insert (Key K) (analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<notin> keysFor (analz H) \\<Longrightarrow>\n    analz (insert (Key K) H) = insert (Key K) (analz H)", "apply (unfold keysFor_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<notin> invKey `\n               {K. \\<exists>X. Crypt K X \\<in> analz H} \\<Longrightarrow>\n    analz (insert (Key K) H) = insert (Key K) (analz H)", "apply (rule analz_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>K \\<notin> invKey `\n                           {K. \\<exists>X. Crypt K X \\<in> analz H};\n        x \\<in> analz (insert (Key K) H)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> insert (Key K) (analz H)", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_insert_MPair [simp]:\n     \"analz (insert \\<lbrace>X,Y\\<rbrace> H) =  \n          insert \\<lbrace>X,Y\\<rbrace> (analz (insert X (insert Y H)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert \\<lbrace>X, Y\\<rbrace> H) =\n    insert \\<lbrace>X, Y\\<rbrace> (analz (insert X (insert Y H)))", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. analz (insert \\<lbrace>X, Y\\<rbrace> H)\n    \\<subseteq> insert \\<lbrace>X, Y\\<rbrace>\n                 (analz (insert X (insert Y H)))\n 2. insert \\<lbrace>X, Y\\<rbrace> (analz (insert X (insert Y H)))\n    \\<subseteq> analz (insert \\<lbrace>X, Y\\<rbrace> H)", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H) \\<Longrightarrow>\n       x \\<in> insert \\<lbrace>X, Y\\<rbrace> (analz (insert X (insert Y H)))\n 2. insert \\<lbrace>X, Y\\<rbrace> (analz (insert X (insert Y H)))\n    \\<subseteq> analz (insert \\<lbrace>X, Y\\<rbrace> H)", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> analz (insert X (insert Y H)) \\<Longrightarrow>\n       x \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H)", "apply (erule analz.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x Xa.\n       Xa \\<in> insert X (insert Y H) \\<Longrightarrow>\n       Xa \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H)\n 2. \\<And>x Xa Ya.\n       \\<lbrakk>\\<lbrace>Xa, Ya\\<rbrace>\n                \\<in> analz (insert X (insert Y H));\n        \\<lbrace>Xa, Ya\\<rbrace>\n        \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H)\\<rbrakk>\n       \\<Longrightarrow> Xa \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H)\n 3. \\<And>x Xa Ya.\n       \\<lbrakk>\\<lbrace>Xa, Ya\\<rbrace>\n                \\<in> analz (insert X (insert Y H));\n        \\<lbrace>Xa, Ya\\<rbrace>\n        \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H)\\<rbrakk>\n       \\<Longrightarrow> Ya \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H)\n 4. \\<And>x K Xa.\n       \\<lbrakk>Crypt K Xa \\<in> analz (insert X (insert Y H));\n        Crypt K Xa \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H);\n        Key (invKey K) \\<in> analz (insert X (insert Y H));\n        Key (invKey K)\n        \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H)\\<rbrakk>\n       \\<Longrightarrow> Xa \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H)", "apply (blast intro: analz.Fst analz.Snd)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Can pull out enCrypted message if the Key is not known\\<close>"], ["", "lemma analz_insert_Crypt:\n     \"Key (invKey K) \\<notin> analz H \n      ==> analz (insert (Crypt K X) H) = insert (Crypt K X) (analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (invKey K) \\<notin> analz H \\<Longrightarrow>\n    analz (insert (Crypt K X) H) = insert (Crypt K X) (analz H)", "apply (rule analz_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Key (invKey K) \\<notin> analz H;\n        x \\<in> analz (insert (Crypt K X) H)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> insert (Crypt K X) (analz H)", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lemma1: \"Key (invKey K) \\<in> analz H ==>   \n               analz (insert (Crypt K X) H) \\<subseteq>  \n               insert (Crypt K X) (analz (insert X H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (invKey K) \\<in> analz H \\<Longrightarrow>\n    analz (insert (Crypt K X) H)\n    \\<subseteq> insert (Crypt K X) (analz (insert X H))", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Key (invKey K) \\<in> analz H;\n        x \\<in> analz (insert (Crypt K X) H)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> insert (Crypt K X) (analz (insert X H))", "apply (erule_tac x = x in analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lemma2: \"Key (invKey K) \\<in> analz H ==>   \n               insert (Crypt K X) (analz (insert X H)) \\<subseteq>  \n               analz (insert (Crypt K X) H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (invKey K) \\<in> analz H \\<Longrightarrow>\n    insert (Crypt K X) (analz (insert X H))\n    \\<subseteq> analz (insert (Crypt K X) H)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Key (invKey K) \\<in> analz H;\n        x \\<in> analz (insert X H)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> analz (insert (Crypt K X) H)", "apply (erule_tac x = x in analz.induct, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (invKey K) \\<in> analz H \\<Longrightarrow>\n    X \\<in> analz (insert (Crypt K X) H)", "apply (blast intro: analz_insertI analz.Decrypt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_insert_Decrypt:\n     \"Key (invKey K) \\<in> analz H ==>   \n               analz (insert (Crypt K X) H) =  \n               insert (Crypt K X) (analz (insert X H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (invKey K) \\<in> analz H \\<Longrightarrow>\n    analz (insert (Crypt K X) H) = insert (Crypt K X) (analz (insert X H))", "by (intro equalityI lemma1 lemma2)"], ["", "text\\<open>Case analysis: either the message is secure, or it is not! Effective,\nbut can cause subgoals to blow up! Use with \\<open>if_split\\<close>; apparently\n\\<open>split_tac\\<close> does not cope with patterns such as @{term\"analz (insert\n(Crypt K X) H)\"}\\<close>"], ["", "lemma analz_Crypt_if [simp]:\n     \"analz (insert (Crypt K X) H) =                 \n          (if (Key (invKey K) \\<in> analz H)                 \n           then insert (Crypt K X) (analz (insert X H))  \n           else insert (Crypt K X) (analz H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert (Crypt K X) H) =\n    (if Key (invKey K) \\<in> analz H\n     then insert (Crypt K X) (analz (insert X H))\n     else insert (Crypt K X) (analz H))", "by (simp add: analz_insert_Crypt analz_insert_Decrypt)"], ["", "text\\<open>This rule supposes \"for the sake of argument\" that we have the key.\\<close>"], ["", "lemma analz_insert_Crypt_subset:\n     \"analz (insert (Crypt K X) H) \\<subseteq>   \n           insert (Crypt K X) (analz (insert X H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert (Crypt K X) H)\n    \\<subseteq> insert (Crypt K X) (analz (insert X H))", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> analz (insert (Crypt K X) H) \\<Longrightarrow>\n       x \\<in> insert (Crypt K X) (analz (insert X H))", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_image_Key [simp]: \"analz (Key`N) = Key`N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (Key ` N) = Key ` N", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> analz (Key ` N) \\<Longrightarrow> x \\<in> Key ` N", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection\\<open>Idempotence and transitivity\\<close>"], ["", "lemma analz_analzD [dest!]: \"X\\<in> analz (analz H) ==> X\\<in> analz H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> analz (analz H) \\<Longrightarrow> X \\<in> analz H", "by (erule analz.induct, blast+)"], ["", "lemma analz_idem [simp]: \"analz (analz H) = analz H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (analz H) = analz H", "by blast"], ["", "lemma analz_subset_iff [simp]: \"(analz G \\<subseteq> analz H) = (G \\<subseteq> analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (analz G \\<subseteq> analz H) = (G \\<subseteq> analz H)", "by (metis analz_idem analz_increasing analz_mono subset_trans)"], ["", "lemma analz_trans: \"[| X\\<in> analz G;  G \\<subseteq> analz H |] ==> X\\<in> analz H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> analz G; G \\<subseteq> analz H\\<rbrakk>\n    \\<Longrightarrow> X \\<in> analz H", "by (drule analz_mono, blast)"], ["", "text\\<open>Cut; Lemma 2 of Lowe\\<close>"], ["", "lemma analz_cut: \"[| Y\\<in> analz (insert X H);  X\\<in> analz H |] ==> Y\\<in> analz H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Y \\<in> analz (insert X H); X \\<in> analz H\\<rbrakk>\n    \\<Longrightarrow> Y \\<in> analz H", "by (erule analz_trans, blast)"], ["", "(*Cut can be proved easily by induction on\n   \"Y: analz (insert X H) ==> X: analz H --> Y: analz H\"\n*)"], ["", "text\\<open>This rewrite rule helps in the simplification of messages that involve\n  the forwarding of unknown components (X).  Without it, removing occurrences\n  of X can be very complicated.\\<close>"], ["", "lemma analz_insert_eq: \"X\\<in> analz H ==> analz (insert X H) = analz H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> analz H \\<Longrightarrow> analz (insert X H) = analz H", "by (metis analz_cut analz_insert_eq_I insert_absorb)"], ["", "text\\<open>A congruence rule for \"analz\"\\<close>"], ["", "lemma analz_subset_cong:\n     \"[| analz G \\<subseteq> analz G'; analz H \\<subseteq> analz H' |] \n      ==> analz (G \\<union> H) \\<subseteq> analz (G' \\<union> H')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>analz G \\<subseteq> analz G';\n     analz H \\<subseteq> analz H'\\<rbrakk>\n    \\<Longrightarrow> analz (G \\<union> H)\n                      \\<subseteq> analz (G' \\<union> H')", "by (metis Un_mono analz_Un analz_subset_iff subset_trans)"], ["", "lemma analz_cong:\n     \"[| analz G = analz G'; analz H = analz H' |] \n      ==> analz (G \\<union> H) = analz (G' \\<union> H')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>analz G = analz G'; analz H = analz H'\\<rbrakk>\n    \\<Longrightarrow> analz (G \\<union> H) = analz (G' \\<union> H')", "by (intro equalityI analz_subset_cong, simp_all)"], ["", "lemma analz_insert_cong:\n     \"analz H = analz H' ==> analz(insert X H) = analz(insert X H')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz H = analz H' \\<Longrightarrow>\n    analz (insert X H) = analz (insert X H')", "by (force simp only: insert_def intro!: analz_cong)"], ["", "text\\<open>If there are no pairs or encryptions then analz does nothing\\<close>"], ["", "lemma analz_trivial:\n     \"[| \\<forall>X Y. \\<lbrace>X,Y\\<rbrace> \\<notin> H;  \\<forall>X K. Crypt K X \\<notin> H |] ==> analz H = H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>X Y. \\<lbrace>X, Y\\<rbrace> \\<notin> H;\n     \\<forall>X K. Crypt K X \\<notin> H\\<rbrakk>\n    \\<Longrightarrow> analz H = H", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>X Y. \\<lbrace>X, Y\\<rbrace> \\<notin> H;\n        \\<forall>X K. Crypt K X \\<notin> H; x \\<in> analz H\\<rbrakk>\n       \\<Longrightarrow> x \\<in> H\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>X Y. \\<lbrace>X, Y\\<rbrace> \\<notin> H;\n        \\<forall>X K. Crypt K X \\<notin> H; x \\<in> H\\<rbrakk>\n       \\<Longrightarrow> x \\<in> analz H", "apply (erule analz.induct, blast+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>These two are obsolete (with a single Spy) but cost little to prove...\\<close>"], ["", "lemma analz_UN_analz_lemma:\n     \"X\\<in> analz (\\<Union>i\\<in>A. analz (H i)) ==> X\\<in> analz (\\<Union>i\\<in>A. H i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> analz (\\<Union>i\\<in>A. analz (H i)) \\<Longrightarrow>\n    X \\<in> analz (\\<Union> (H ` A))", "apply (erule analz.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>X.\n       X \\<in> (\\<Union>i\\<in>A. analz (H i)) \\<Longrightarrow>\n       X \\<in> analz (\\<Union> (H ` A))\n 2. \\<And>X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace>\n                \\<in> analz (\\<Union>i\\<in>A. analz (H i));\n        \\<lbrace>X, Y\\<rbrace> \\<in> analz (\\<Union> (H ` A))\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz (\\<Union> (H ` A))\n 3. \\<And>X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace>\n                \\<in> analz (\\<Union>i\\<in>A. analz (H i));\n        \\<lbrace>X, Y\\<rbrace> \\<in> analz (\\<Union> (H ` A))\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz (\\<Union> (H ` A))\n 4. \\<And>K X.\n       \\<lbrakk>Crypt K X \\<in> analz (\\<Union>i\\<in>A. analz (H i));\n        Crypt K X \\<in> analz (\\<Union> (H ` A));\n        Key (invKey K) \\<in> analz (\\<Union>i\\<in>A. analz (H i));\n        Key (invKey K) \\<in> analz (\\<Union> (H ` A))\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz (\\<Union> (H ` A))", "apply (blast intro: analz_mono [THEN [2] rev_subsetD])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_UN_analz [simp]: \"analz (\\<Union>i\\<in>A. analz (H i)) = analz (\\<Union>i\\<in>A. H i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (\\<Union>i\\<in>A. analz (H i)) = analz (\\<Union> (H ` A))", "by (blast intro: analz_UN_analz_lemma analz_mono [THEN [2] rev_subsetD])"], ["", "subsection\\<open>Inductive relation \"synth\"\\<close>"], ["", "text\\<open>Inductive definition of \"synth\" -- what can be built up from a set of\n    messages.  A form of upward closure.  Pairs can be built, messages\n    encrypted with known keys.  Agent names are public domain.\n    Numbers can be guessed, but Nonces cannot be.\\<close>"], ["", "inductive_set\n  synth :: \"msg set => msg set\"\n  for H :: \"msg set\"\n  where\n    Inj    [intro]:   \"X \\<in> H ==> X \\<in> synth H\"\n  | Agent  [intro]:   \"Agent agt \\<in> synth H\"\n  | Number [intro]:   \"Number n  \\<in> synth H\"\n  | Hash   [intro]:   \"X \\<in> synth H ==> Hash X \\<in> synth H\"\n  | MPair  [intro]:   \"[|X \\<in> synth H;  Y \\<in> synth H|] ==> \\<lbrace>X,Y\\<rbrace> \\<in> synth H\"\n  | Crypt  [intro]:   \"[|X \\<in> synth H;  Key(K) \\<in> H|] ==> Crypt K X \\<in> synth H\""], ["", "text\\<open>Monotonicity\\<close>"], ["", "lemma synth_mono: \"G\\<subseteq>H ==> synth(G) \\<subseteq> synth(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow> synth G \\<subseteq> synth H", "by (auto, erule synth.induct, auto)"], ["", "text\\<open>NO \\<open>Agent_synth\\<close>, as any Agent name can be synthesized.  \n  The same holds for @{term Number}\\<close>"], ["", "inductive_simps synth_simps [iff]:\n \"Nonce n \\<in> synth H\"\n \"Key K \\<in> synth H\"\n \"Hash X \\<in> synth H\"\n \"\\<lbrace>X,Y\\<rbrace> \\<in> synth H\"\n \"Crypt K X \\<in> synth H\""], ["", "lemma synth_increasing: \"H \\<subseteq> synth(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<subseteq> synth H", "by blast"], ["", "subsubsection\\<open>Unions\\<close>"], ["", "text\\<open>Converse fails: we can synth more from the union than from the \n  separate parts, building a compound message using elements of each.\\<close>"], ["", "lemma synth_Un: \"synth(G) \\<union> synth(H) \\<subseteq> synth(G \\<union> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth G \\<union> synth H \\<subseteq> synth (G \\<union> H)", "by (intro Un_least synth_mono Un_upper1 Un_upper2)"], ["", "lemma synth_insert: \"insert X (synth H) \\<subseteq> synth(insert X H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert X (synth H) \\<subseteq> synth (insert X H)", "by (blast intro: synth_mono [THEN [2] rev_subsetD])"], ["", "subsubsection\\<open>Idempotence and transitivity\\<close>"], ["", "lemma synth_synthD [dest!]: \"X\\<in> synth (synth H) ==> X\\<in> synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> synth (synth H) \\<Longrightarrow> X \\<in> synth H", "by (erule synth.induct, auto)"], ["", "lemma synth_idem: \"synth (synth H) = synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth (synth H) = synth H", "by blast"], ["", "lemma synth_subset_iff [simp]: \"(synth G \\<subseteq> synth H) = (G \\<subseteq> synth H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (synth G \\<subseteq> synth H) = (G \\<subseteq> synth H)", "by (metis subset_trans synth_idem synth_increasing synth_mono)"], ["", "lemma synth_trans: \"[| X\\<in> synth G;  G \\<subseteq> synth H |] ==> X\\<in> synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> synth G; G \\<subseteq> synth H\\<rbrakk>\n    \\<Longrightarrow> X \\<in> synth H", "by (drule synth_mono, blast)"], ["", "text\\<open>Cut; Lemma 2 of Lowe\\<close>"], ["", "lemma synth_cut: \"[| Y\\<in> synth (insert X H);  X\\<in> synth H |] ==> Y\\<in> synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Y \\<in> synth (insert X H); X \\<in> synth H\\<rbrakk>\n    \\<Longrightarrow> Y \\<in> synth H", "by (erule synth_trans, blast)"], ["", "lemma Agent_synth [simp]: \"Agent A \\<in> synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Agent A \\<in> synth H", "by blast"], ["", "lemma Number_synth [simp]: \"Number n \\<in> synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Number n \\<in> synth H", "by blast"], ["", "lemma Nonce_synth_eq [simp]: \"(Nonce N \\<in> synth H) = (Nonce N \\<in> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Nonce N \\<in> synth H) = (Nonce N \\<in> H)", "by blast"], ["", "lemma Key_synth_eq [simp]: \"(Key K \\<in> synth H) = (Key K \\<in> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Key K \\<in> synth H) = (Key K \\<in> H)", "by blast"], ["", "lemma Crypt_synth_eq [simp]:\n     \"Key K \\<notin> H ==> (Crypt K X \\<in> synth H) = (Crypt K X \\<in> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key K \\<notin> H \\<Longrightarrow>\n    (Crypt K X \\<in> synth H) = (Crypt K X \\<in> H)", "by blast"], ["", "lemma keysFor_synth [simp]: \n    \"keysFor (synth H) = keysFor H \\<union> invKey`{K. Key K \\<in> H}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (synth H) = keysFor H \\<union> invKey ` {K. Key K \\<in> H}", "by (unfold keysFor_def, blast)"], ["", "subsubsection\\<open>Combinations of parts, analz and synth\\<close>"], ["", "lemma parts_synth [simp]: \"parts (synth H) = parts H \\<union> synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (synth H) = parts H \\<union> synth H", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. parts (synth H) \\<subseteq> parts H \\<union> synth H\n 2. parts H \\<union> synth H \\<subseteq> parts (synth H)", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> parts (synth H) \\<Longrightarrow>\n       x \\<in> parts H \\<union> synth H\n 2. parts H \\<union> synth H \\<subseteq> parts (synth H)", "apply (erule parts.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x X.\n       X \\<in> synth H \\<Longrightarrow> X \\<in> parts H \\<union> synth H\n 2. \\<And>x X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> parts (synth H);\n        \\<lbrace>X, Y\\<rbrace> \\<in> parts H \\<union> synth H\\<rbrakk>\n       \\<Longrightarrow> X \\<in> parts H \\<union> synth H\n 3. \\<And>x X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> parts (synth H);\n        \\<lbrace>X, Y\\<rbrace> \\<in> parts H \\<union> synth H\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> parts H \\<union> synth H\n 4. \\<And>x K X.\n       \\<lbrakk>Crypt K X \\<in> parts (synth H);\n        Crypt K X \\<in> parts H \\<union> synth H\\<rbrakk>\n       \\<Longrightarrow> X \\<in> parts H \\<union> synth H\n 5. parts H \\<union> synth H \\<subseteq> parts (synth H)", "apply (blast intro: synth_increasing [THEN parts_mono, THEN subsetD] \n                    parts.Fst parts.Snd parts.Body)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_analz_Un [simp]: \"analz (analz G \\<union> H) = analz (G \\<union> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (analz G \\<union> H) = analz (G \\<union> H)", "apply (intro equalityI analz_subset_cong)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. analz (analz G) \\<subseteq> analz G\n 2. analz H \\<subseteq> analz H\n 3. analz G \\<subseteq> analz (analz G)\n 4. analz H \\<subseteq> analz H", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_synth_Un [simp]: \"analz (synth G \\<union> H) = analz (G \\<union> H) \\<union> synth G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (synth G \\<union> H) = analz (G \\<union> H) \\<union> synth G", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. analz (synth G \\<union> H)\n    \\<subseteq> analz (G \\<union> H) \\<union> synth G\n 2. analz (G \\<union> H) \\<union> synth G\n    \\<subseteq> analz (synth G \\<union> H)", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> analz (synth G \\<union> H) \\<Longrightarrow>\n       x \\<in> analz (G \\<union> H) \\<union> synth G\n 2. analz (G \\<union> H) \\<union> synth G\n    \\<subseteq> analz (synth G \\<union> H)", "apply (erule analz.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x X.\n       X \\<in> synth G \\<union> H \\<Longrightarrow>\n       X \\<in> analz (G \\<union> H) \\<union> synth G\n 2. \\<And>x X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> analz (synth G \\<union> H);\n        \\<lbrace>X, Y\\<rbrace>\n        \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz (G \\<union> H) \\<union> synth G\n 3. \\<And>x X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> analz (synth G \\<union> H);\n        \\<lbrace>X, Y\\<rbrace>\n        \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz (G \\<union> H) \\<union> synth G\n 4. \\<And>x K X.\n       \\<lbrakk>Crypt K X \\<in> analz (synth G \\<union> H);\n        Crypt K X \\<in> analz (G \\<union> H) \\<union> synth G;\n        Key (invKey K) \\<in> analz (synth G \\<union> H);\n        Key (invKey K) \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz (G \\<union> H) \\<union> synth G\n 5. analz (G \\<union> H) \\<union> synth G\n    \\<subseteq> analz (synth G \\<union> H)", "prefer 5"], ["proof (prove)\ngoal (5 subgoals):\n 1. analz (G \\<union> H) \\<union> synth G\n    \\<subseteq> analz (synth G \\<union> H)\n 2. \\<And>x X.\n       X \\<in> synth G \\<union> H \\<Longrightarrow>\n       X \\<in> analz (G \\<union> H) \\<union> synth G\n 3. \\<And>x X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> analz (synth G \\<union> H);\n        \\<lbrace>X, Y\\<rbrace>\n        \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz (G \\<union> H) \\<union> synth G\n 4. \\<And>x X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> analz (synth G \\<union> H);\n        \\<lbrace>X, Y\\<rbrace>\n        \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz (G \\<union> H) \\<union> synth G\n 5. \\<And>x K X.\n       \\<lbrakk>Crypt K X \\<in> analz (synth G \\<union> H);\n        Crypt K X \\<in> analz (G \\<union> H) \\<union> synth G;\n        Key (invKey K) \\<in> analz (synth G \\<union> H);\n        Key (invKey K) \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz (G \\<union> H) \\<union> synth G", "apply (blast intro: analz_mono [THEN [2] rev_subsetD])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x X.\n       X \\<in> synth G \\<union> H \\<Longrightarrow>\n       X \\<in> analz (G \\<union> H) \\<union> synth G\n 2. \\<And>x X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> analz (synth G \\<union> H);\n        \\<lbrace>X, Y\\<rbrace>\n        \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz (G \\<union> H) \\<union> synth G\n 3. \\<And>x X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> analz (synth G \\<union> H);\n        \\<lbrace>X, Y\\<rbrace>\n        \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz (G \\<union> H) \\<union> synth G\n 4. \\<And>x K X.\n       \\<lbrakk>Crypt K X \\<in> analz (synth G \\<union> H);\n        Crypt K X \\<in> analz (G \\<union> H) \\<union> synth G;\n        Key (invKey K) \\<in> analz (synth G \\<union> H);\n        Key (invKey K) \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz (G \\<union> H) \\<union> synth G", "apply (blast intro: analz.Fst analz.Snd analz.Decrypt)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_synth [simp]: \"analz (synth H) = analz H \\<union> synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (synth H) = analz H \\<union> synth H", "by (metis Un_empty_right analz_synth_Un)"], ["", "subsubsection\\<open>For reasoning about the Fake rule in traces\\<close>"], ["", "lemma parts_insert_subset_Un: \"X\\<in> G ==> parts(insert X H) \\<subseteq> parts G \\<union> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> G \\<Longrightarrow>\n    parts (insert X H) \\<subseteq> parts G \\<union> parts H", "by (metis UnCI Un_upper2 insert_subset parts_Un parts_mono)"], ["", "text\\<open>More specifically for Fake. See also \\<open>Fake_parts_sing\\<close> below\\<close>"], ["", "lemma Fake_parts_insert:\n     \"X \\<in> synth (analz H) ==>  \n      parts (insert X H) \\<subseteq> synth (analz H) \\<union> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> synth (analz H) \\<Longrightarrow>\n    parts (insert X H) \\<subseteq> synth (analz H) \\<union> parts H", "by (metis Un_commute analz_increasing insert_subset parts_analz parts_mono \n          parts_synth synth_mono synth_subset_iff)"], ["", "lemma Fake_parts_insert_in_Un:\n     \"[|Z \\<in> parts (insert X H);  X: synth (analz H)|] \n      ==> Z \\<in>  synth (analz H) \\<union> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Z \\<in> parts (insert X H); X \\<in> synth (analz H)\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> synth (analz H) \\<union> parts H", "by (metis Fake_parts_insert subsetD)"], ["", "text\\<open>@{term H} is sometimes @{term\"Key ` KK \\<union> spies evs\"}, so can't put \n  @{term \"G=H\"}.\\<close>"], ["", "lemma Fake_analz_insert:\n     \"X\\<in> synth (analz G) ==>  \n      analz (insert X H) \\<subseteq> synth (analz G) \\<union> analz (G \\<union> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> synth (analz G) \\<Longrightarrow>\n    analz (insert X H)\n    \\<subseteq> synth (analz G) \\<union> analz (G \\<union> H)", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>X \\<in> synth (analz G); x \\<in> analz (insert X H)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> synth (analz G) \\<union>\n                                 analz (G \\<union> H)", "apply (subgoal_tac \"x \\<in> analz (synth (analz G) \\<union> H)\", force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>X \\<in> synth (analz G); x \\<in> analz (insert X H)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> analz (synth (analz G) \\<union> H)", "apply (blast intro: analz_mono [THEN [2] rev_subsetD] analz_mono [THEN synth_mono, THEN [2] rev_subsetD])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_conj_parts [simp]:\n     \"(X \\<in> analz H \\<and> X \\<in> parts H) = (X \\<in> analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<in> analz H \\<and> X \\<in> parts H) = (X \\<in> analz H)", "by (blast intro: analz_subset_parts [THEN subsetD])"], ["", "lemma analz_disj_parts [simp]:\n     \"(X \\<in> analz H | X \\<in> parts H) = (X \\<in> parts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<in> analz H \\<or> X \\<in> parts H) = (X \\<in> parts H)", "by (blast intro: analz_subset_parts [THEN subsetD])"], ["", "text\\<open>Without this equation, other rules for synth and analz would yield\n  redundant cases\\<close>"], ["", "lemma MPair_synth_analz [iff]:\n     \"(\\<lbrace>X,Y\\<rbrace> \\<in> synth (analz H)) =  \n      (X \\<in> synth (analz H) \\<and> Y \\<in> synth (analz H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrace>X, Y\\<rbrace> \\<in> synth (analz H)) =\n    (X \\<in> synth (analz H) \\<and> Y \\<in> synth (analz H))", "by blast"], ["", "lemma Crypt_synth_analz:\n     \"[| Key K \\<in> analz H;  Key (invKey K) \\<in> analz H |]  \n       ==> (Crypt K X \\<in> synth (analz H)) = (X \\<in> synth (analz H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Key K \\<in> analz H; Key (invKey K) \\<in> analz H\\<rbrakk>\n    \\<Longrightarrow> (Crypt K X \\<in> synth (analz H)) =\n                      (X \\<in> synth (analz H))", "by blast"], ["", "lemma Hash_synth_analz [simp]:\n     \"X \\<notin> synth (analz H)  \n      ==> (Hash\\<lbrace>X,Y\\<rbrace> \\<in> synth (analz H)) = (Hash\\<lbrace>X,Y\\<rbrace> \\<in> analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<notin> synth (analz H) \\<Longrightarrow>\n    (Hash \\<lbrace>X, Y\\<rbrace> \\<in> synth (analz H)) =\n    (Hash \\<lbrace>X, Y\\<rbrace> \\<in> analz H)", "by blast"], ["", "subsection\\<open>HPair: a combination of Hash and MPair\\<close>"], ["", "subsubsection\\<open>Freeness\\<close>"], ["", "lemma Agent_neq_HPair: \"Agent A ~= Hash[X] Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Agent A \\<noteq> Hash[X] Y", "by (unfold HPair_def, simp)"], ["", "lemma Nonce_neq_HPair: \"Nonce N ~= Hash[X] Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nonce N \\<noteq> Hash[X] Y", "by (unfold HPair_def, simp)"], ["", "lemma Number_neq_HPair: \"Number N ~= Hash[X] Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Number N \\<noteq> Hash[X] Y", "by (unfold HPair_def, simp)"], ["", "lemma Key_neq_HPair: \"Key K ~= Hash[X] Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key K \\<noteq> Hash[X] Y", "by (unfold HPair_def, simp)"], ["", "lemma Hash_neq_HPair: \"Hash Z ~= Hash[X] Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hash Z \\<noteq> Hash[X] Y", "by (unfold HPair_def, simp)"], ["", "lemma Crypt_neq_HPair: \"Crypt K X' ~= Hash[X] Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Crypt K X' \\<noteq> Hash[X] Y", "by (unfold HPair_def, simp)"], ["", "lemmas HPair_neqs = Agent_neq_HPair Nonce_neq_HPair Number_neq_HPair \n                    Key_neq_HPair Hash_neq_HPair Crypt_neq_HPair"], ["", "declare HPair_neqs [iff]"], ["", "declare HPair_neqs [symmetric, iff]"], ["", "lemma HPair_eq [iff]: \"(Hash[X'] Y' = Hash[X] Y) = (X' = X \\<and> Y'=Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Hash[X'] Y' = Hash[X] Y) = (X' = X \\<and> Y' = Y)", "by (simp add: HPair_def)"], ["", "lemma MPair_eq_HPair [iff]:\n     \"(\\<lbrace>X',Y'\\<rbrace> = Hash[X] Y) = (X' = Hash\\<lbrace>X,Y\\<rbrace> \\<and> Y'=Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrace>X', Y'\\<rbrace> = Hash[X] Y) =\n    (X' = Hash \\<lbrace>X, Y\\<rbrace> \\<and> Y' = Y)", "by (simp add: HPair_def)"], ["", "lemma HPair_eq_MPair [iff]:\n     \"(Hash[X] Y = \\<lbrace>X',Y'\\<rbrace>) = (X' = Hash\\<lbrace>X,Y\\<rbrace> \\<and> Y'=Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Hash[X] Y = \\<lbrace>X', Y'\\<rbrace>) =\n    (X' = Hash \\<lbrace>X, Y\\<rbrace> \\<and> Y' = Y)", "by (auto simp add: HPair_def)"], ["", "subsubsection\\<open>Specialized laws, proved in terms of those for Hash and MPair\\<close>"], ["", "lemma keysFor_insert_HPair [simp]: \"keysFor (insert (Hash[X] Y) H) = keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (insert Hash[X] Y H) = keysFor H", "by (simp add: HPair_def)"], ["", "lemma parts_insert_HPair [simp]: \n    \"parts (insert (Hash[X] Y) H) =  \n     insert (Hash[X] Y) (insert (Hash\\<lbrace>X,Y\\<rbrace>) (parts (insert Y H)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert Hash[X] Y H) =\n    insert Hash[X] Y\n     (insert (Hash \\<lbrace>X, Y\\<rbrace>) (parts (insert Y H)))", "by (simp add: HPair_def)"], ["", "lemma analz_insert_HPair [simp]: \n    \"analz (insert (Hash[X] Y) H) =  \n     insert (Hash[X] Y) (insert (Hash\\<lbrace>X,Y\\<rbrace>) (analz (insert Y H)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert Hash[X] Y H) =\n    insert Hash[X] Y\n     (insert (Hash \\<lbrace>X, Y\\<rbrace>) (analz (insert Y H)))", "by (simp add: HPair_def)"], ["", "lemma HPair_synth_analz [simp]:\n     \"X \\<notin> synth (analz H)  \n    ==> (Hash[X] Y \\<in> synth (analz H)) =  \n        (Hash \\<lbrace>X, Y\\<rbrace> \\<in> analz H \\<and> Y \\<in> synth (analz H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<notin> synth (analz H) \\<Longrightarrow>\n    (Hash[X] Y \\<in> synth (analz H)) =\n    (Hash \\<lbrace>X, Y\\<rbrace> \\<in> analz H \\<and>\n     Y \\<in> synth (analz H))", "by (auto simp add: HPair_def)"], ["", "text\\<open>We do NOT want Crypt... messages broken up in protocols!!\\<close>"], ["", "declare parts.Body [rule del]"], ["", "text\\<open>Rewrites to push in Key and Crypt messages, so that other messages can\n    be pulled out using the \\<open>analz_insert\\<close> rules\\<close>"], ["", "lemmas pushKeys =\n  insert_commute [of \"Key K\" \"Agent C\"]\n  insert_commute [of \"Key K\" \"Nonce N\"]\n  insert_commute [of \"Key K\" \"Number N\"]\n  insert_commute [of \"Key K\" \"Hash X\"]\n  insert_commute [of \"Key K\" \"MPair X Y\"]\n  insert_commute [of \"Key K\" \"Crypt X K'\"]\n  for K C N X Y K'"], ["", "lemmas pushCrypts =\n  insert_commute [of \"Crypt X K\" \"Agent C\"]\n  insert_commute [of \"Crypt X K\" \"Agent C\"]\n  insert_commute [of \"Crypt X K\" \"Nonce N\"]\n  insert_commute [of \"Crypt X K\" \"Number N\"]\n  insert_commute [of \"Crypt X K\" \"Hash X'\"]\n  insert_commute [of \"Crypt X K\" \"MPair X' Y\"]\n  for X K C N X' Y"], ["", "text\\<open>Cannot be added with \\<open>[simp]\\<close> -- messages should not always be\n  re-ordered.\\<close>"], ["", "lemmas pushes = pushKeys pushCrypts"], ["", "subsection\\<open>The set of key-free messages\\<close>"], ["", "(*Note that even the encryption of a key-free message remains key-free.\n  This concept is valuable because of the theorem analz_keyfree_into_Un, proved below. *)"], ["", "inductive_set\n  keyfree :: \"msg set\"\n  where\n    Agent:  \"Agent A \\<in> keyfree\"\n  | Number: \"Number N \\<in> keyfree\"\n  | Nonce:  \"Nonce N \\<in> keyfree\"\n  | Hash:   \"Hash X \\<in> keyfree\"\n  | MPair:  \"[|X \\<in> keyfree;  Y \\<in> keyfree|] ==> \\<lbrace>X,Y\\<rbrace> \\<in> keyfree\"\n  | Crypt:  \"[|X \\<in> keyfree|] ==> Crypt K X \\<in> keyfree\""], ["", "declare keyfree.intros [intro]"], ["", "inductive_cases keyfree_KeyE: \"Key K \\<in> keyfree\""], ["", "inductive_cases keyfree_MPairE: \"\\<lbrace>X,Y\\<rbrace> \\<in> keyfree\""], ["", "inductive_cases keyfree_CryptE: \"Crypt K X \\<in> keyfree\""], ["", "lemma parts_keyfree: \"parts (keyfree) \\<subseteq> keyfree\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts keyfree \\<subseteq> keyfree", "by (clarify, erule parts.induct, auto elim!: keyfree_KeyE keyfree_MPairE keyfree_CryptE)"], ["", "(*The key-free part of a set of messages can be removed from the scope of the analz operator.*)"], ["", "lemma analz_keyfree_into_Un: \"\\<lbrakk>X \\<in> analz (G \\<union> H); G \\<subseteq> keyfree\\<rbrakk> \\<Longrightarrow> X \\<in> parts G \\<union> analz H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> analz (G \\<union> H); G \\<subseteq> keyfree\\<rbrakk>\n    \\<Longrightarrow> X \\<in> parts G \\<union> analz H", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>K X.\n       \\<lbrakk>G \\<subseteq> keyfree; Crypt K X \\<in> analz (G \\<union> H);\n        Key (invKey K) \\<in> analz (G \\<union> H); X \\<notin> analz H;\n        Crypt K X \\<in> parts G; Key (invKey K) \\<in> parts G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> parts G\n 2. \\<And>K X.\n       \\<lbrakk>G \\<subseteq> keyfree; Crypt K X \\<in> analz (G \\<union> H);\n        Key (invKey K) \\<in> analz (G \\<union> H); X \\<notin> analz H;\n        Crypt K X \\<in> parts G; Key (invKey K) \\<in> analz H\\<rbrakk>\n       \\<Longrightarrow> X \\<in> parts G\n 3. \\<And>K X.\n       \\<lbrakk>G \\<subseteq> keyfree; Crypt K X \\<in> analz (G \\<union> H);\n        Key (invKey K) \\<in> analz (G \\<union> H); X \\<notin> analz H;\n        Crypt K X \\<in> analz H; Key (invKey K) \\<in> parts G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> parts G", "apply (blast dest:parts.Body)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>K X.\n       \\<lbrakk>G \\<subseteq> keyfree; Crypt K X \\<in> analz (G \\<union> H);\n        Key (invKey K) \\<in> analz (G \\<union> H); X \\<notin> analz H;\n        Crypt K X \\<in> parts G; Key (invKey K) \\<in> analz H\\<rbrakk>\n       \\<Longrightarrow> X \\<in> parts G\n 2. \\<And>K X.\n       \\<lbrakk>G \\<subseteq> keyfree; Crypt K X \\<in> analz (G \\<union> H);\n        Key (invKey K) \\<in> analz (G \\<union> H); X \\<notin> analz H;\n        Crypt K X \\<in> analz H; Key (invKey K) \\<in> parts G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> parts G", "apply (blast dest: parts.Body)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>K X.\n       \\<lbrakk>G \\<subseteq> keyfree; Crypt K X \\<in> analz (G \\<union> H);\n        Key (invKey K) \\<in> analz (G \\<union> H); X \\<notin> analz H;\n        Crypt K X \\<in> analz H; Key (invKey K) \\<in> parts G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> parts G", "apply (metis Un_absorb2 keyfree_KeyE parts_Un parts_keyfree UnI2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Tactics useful for many protocol proofs\\<close>"], ["", "ML\n\\<open>\n(*Analysis of Fake cases.  Also works for messages that forward unknown parts,\n  but this application is no longer necessary if analz_insert_eq is used.\n  DEPENDS UPON \"X\" REFERRING TO THE FRADULENT MESSAGE *)\n\nfun impOfSubs th = th RSN (2, @{thm rev_subsetD})\n\n(*Apply rules to break down assumptions of the form\n  Y \\<in> parts(insert X H)  and  Y \\<in> analz(insert X H)\n*)\nfun Fake_insert_tac ctxt = \n    dresolve_tac ctxt [impOfSubs @{thm Fake_analz_insert},\n                  impOfSubs @{thm Fake_parts_insert}] THEN'\n    eresolve_tac ctxt [asm_rl, @{thm synth.Inj}];\n\nfun Fake_insert_simp_tac ctxt i = \n  REPEAT (Fake_insert_tac ctxt i) THEN asm_full_simp_tac ctxt i;\n\nfun atomic_spy_analz_tac ctxt =\n  SELECT_GOAL\n   (Fake_insert_simp_tac ctxt 1 THEN\n    IF_UNSOLVED\n      (Blast.depth_tac\n        (ctxt addIs [@{thm analz_insertI}, impOfSubs @{thm analz_subset_parts}]) 4 1));\n\nfun spy_analz_tac ctxt i =\n  DETERM\n   (SELECT_GOAL\n     (EVERY \n      [  (*push in occurrences of X...*)\n       (REPEAT o CHANGED)\n         (Rule_Insts.res_inst_tac ctxt [(((\"x\", 1), Position.none), \"X\")] []\n          (insert_commute RS ssubst) 1),\n       (*...allowing further simplifications*)\n       simp_tac ctxt 1,\n       REPEAT (FIRSTGOAL (resolve_tac ctxt [allI,impI,notI,conjI,iffI])),\n       DEPTH_SOLVE (atomic_spy_analz_tac ctxt 1)]) i);\n\\<close>"], ["", "text\\<open>By default only \\<open>o_apply\\<close> is built-in.  But in the presence of\neta-expansion this means that some terms displayed as @{term \"f o g\"} will be\nrewritten, and others will not!\\<close>"], ["", "declare o_def [simp]"], ["", "lemma Crypt_notin_image_Key [simp]: \"Crypt K X \\<notin> Key ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Crypt K X \\<notin> Key ` A", "by auto"], ["", "lemma Hash_notin_image_Key [simp] :\"Hash X \\<notin> Key ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hash X \\<notin> Key ` A", "by auto"], ["", "lemma synth_analz_mono: \"G\\<subseteq>H ==> synth (analz(G)) \\<subseteq> synth (analz(H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow>\n    synth (analz G) \\<subseteq> synth (analz H)", "by (iprover intro: synth_mono analz_mono)"], ["", "lemma Fake_analz_eq [simp]:\n     \"X \\<in> synth(analz H) ==> synth (analz (insert X H)) = synth (analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> synth (analz H) \\<Longrightarrow>\n    synth (analz (insert X H)) = synth (analz H)", "by (metis Fake_analz_insert Un_absorb Un_absorb1 Un_commute \n          subset_insertI synth_analz_mono synth_increasing synth_subset_iff)"], ["", "text\\<open>Two generalizations of \\<open>analz_insert_eq\\<close>\\<close>"], ["", "lemma gen_analz_insert_eq [rule_format]:\n     \"X \\<in> analz H ==> \\<forall>G. H \\<subseteq> G --> analz (insert X G) = analz G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> analz H \\<Longrightarrow>\n    \\<forall>G.\n       H \\<subseteq> G \\<longrightarrow> analz (insert X G) = analz G", "by (blast intro: analz_cut analz_insertI analz_mono [THEN [2] rev_subsetD])"], ["", "lemma synth_analz_insert_eq [rule_format]:\n     \"X \\<in> synth (analz H) \n      ==> \\<forall>G. H \\<subseteq> G --> (Key K \\<in> analz (insert X G)) = (Key K \\<in> analz G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> synth (analz H) \\<Longrightarrow>\n    \\<forall>G.\n       H \\<subseteq> G \\<longrightarrow>\n       (Key K \\<in> analz (insert X G)) = (Key K \\<in> analz G)", "apply (erule synth.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>X.\n       X \\<in> analz H \\<Longrightarrow>\n       \\<forall>G.\n          H \\<subseteq> G \\<longrightarrow>\n          (Key K \\<in> analz (insert X G)) = (Key K \\<in> analz G)\n 2. \\<And>agt.\n       \\<forall>G.\n          H \\<subseteq> G \\<longrightarrow>\n          (Key K \\<in> analz (insert (Agent agt) G)) = (Key K \\<in> analz G)\n 3. \\<And>n.\n       \\<forall>G.\n          H \\<subseteq> G \\<longrightarrow>\n          (Key K \\<in> analz (insert (Number n) G)) = (Key K \\<in> analz G)\n 4. \\<And>X.\n       \\<lbrakk>X \\<in> synth (analz H);\n        \\<forall>G.\n           H \\<subseteq> G \\<longrightarrow>\n           (Key K \\<in> analz (insert X G)) = (Key K \\<in> analz G)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>G.\n                            H \\<subseteq> G \\<longrightarrow>\n                            (Key K \\<in> analz (insert (Hash X) G)) =\n                            (Key K \\<in> analz G)\n 5. \\<And>X Y.\n       \\<lbrakk>X \\<in> synth (analz H);\n        \\<forall>G.\n           H \\<subseteq> G \\<longrightarrow>\n           (Key K \\<in> analz (insert X G)) = (Key K \\<in> analz G);\n        Y \\<in> synth (analz H);\n        \\<forall>G.\n           H \\<subseteq> G \\<longrightarrow>\n           (Key K \\<in> analz (insert Y G)) = (Key K \\<in> analz G)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>G.\n                            H \\<subseteq> G \\<longrightarrow>\n                            (Key K\n                             \\<in> analz\n                                    (insert \\<lbrace>X, Y\\<rbrace> G)) =\n                            (Key K \\<in> analz G)\n 6. \\<And>X Ka.\n       \\<lbrakk>X \\<in> synth (analz H);\n        \\<forall>G.\n           H \\<subseteq> G \\<longrightarrow>\n           (Key K \\<in> analz (insert X G)) = (Key K \\<in> analz G);\n        Key Ka \\<in> analz H\\<rbrakk>\n       \\<Longrightarrow> \\<forall>G.\n                            H \\<subseteq> G \\<longrightarrow>\n                            (Key K \\<in> analz (insert (Crypt Ka X) G)) =\n                            (Key K \\<in> analz G)", "apply (simp_all add: gen_analz_insert_eq subset_trans [OF _ subset_insertI])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Fake_parts_sing:\n     \"X \\<in> synth (analz H) ==> parts{X} \\<subseteq> synth (analz H) \\<union> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> synth (analz H) \\<Longrightarrow>\n    parts {X} \\<subseteq> synth (analz H) \\<union> parts H", "by (metis Fake_parts_insert empty_subsetI insert_mono parts_mono subset_trans)"], ["", "lemmas Fake_parts_sing_imp_Un = Fake_parts_sing [THEN [2] rev_subsetD]"], ["", "method_setup spy_analz = \\<open>\n    Scan.succeed (SIMPLE_METHOD' o spy_analz_tac)\\<close>\n    \"for proving the Fake case when analz is involved\""], ["", "method_setup atomic_spy_analz = \\<open>\n    Scan.succeed (SIMPLE_METHOD' o atomic_spy_analz_tac)\\<close>\n    \"for debugging spy_analz\""], ["", "method_setup Fake_insert_simp = \\<open>\n    Scan.succeed (SIMPLE_METHOD' o Fake_insert_simp_tac)\\<close>\n    \"for debugging spy_analz\""], ["", "end"]]}