{"file_name": "/home/qj213/afp-2021-10-22/thys/Inductive_Confidentiality/DolevYao/Event.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Inductive_Confidentiality", "problem_names": ["lemma Notes_imp_used [rule_format]: \"Notes A X \\<in> set evs --> X \\<in> used evs\"", "lemma Says_imp_used [rule_format]: \"Says A B X \\<in> set evs --> X \\<in> used evs\"", "lemmas parts_insert_knows_A = parts_insert [of _ \"knows A evs\"] for A evs", "lemma knows_Spy_Says [simp]:\n     \"knows Spy (Says A B X # evs) = insert X (knows Spy evs)\"", "lemma knows_Spy_Notes [simp]:\n     \"knows Spy (Notes A X # evs) =  \n          (if A:bad then insert X (knows Spy evs) else knows Spy evs)\"", "lemma knows_Spy_Gets [simp]: \"knows Spy (Gets A X # evs) = knows Spy evs\"", "lemma knows_Spy_subset_knows_Spy_Says:\n     \"knows Spy evs \\<subseteq> knows Spy (Says A B X # evs)\"", "lemma knows_Spy_subset_knows_Spy_Notes:\n     \"knows Spy evs \\<subseteq> knows Spy (Notes A X # evs)\"", "lemma knows_Spy_subset_knows_Spy_Gets:\n     \"knows Spy evs \\<subseteq> knows Spy (Gets A X # evs)\"", "lemma Says_imp_knows_Spy [rule_format]:\n     \"Says A B X \\<in> set evs --> X \\<in> knows Spy evs\"", "lemma Notes_imp_knows_Spy [rule_format]:\n     \"Notes A X \\<in> set evs --> A: bad --> X \\<in> knows Spy evs\"", "lemmas Says_imp_parts_knows_Spy = \n       Says_imp_knows_Spy [THEN parts.Inj, THEN revcut_rl]", "lemmas knows_Spy_partsEs =\n     Says_imp_parts_knows_Spy parts.Body [THEN revcut_rl]", "lemmas Says_imp_analz_Spy = Says_imp_knows_Spy [THEN analz.Inj]", "lemmas spies_partsEs = knows_Spy_partsEs", "lemmas Says_imp_spies = Says_imp_knows_Spy", "lemmas parts_insert_spies = parts_insert_knows_A [of _ Spy]", "lemma knows_Says: \"knows A (Says A B X # evs) = insert X (knows A evs)\"", "lemma knows_Notes: \"knows A (Notes A X # evs) = insert X (knows A evs)\"", "lemma knows_Gets:\n     \"A \\<noteq> Spy --> knows A (Gets A X # evs) = insert X (knows A evs)\"", "lemma knows_subset_knows_Says: \"knows A evs \\<subseteq> knows A (Says A' B X # evs)\"", "lemma knows_subset_knows_Notes: \"knows A evs \\<subseteq> knows A (Notes A' X # evs)\"", "lemma knows_subset_knows_Gets: \"knows A evs \\<subseteq> knows A (Gets A' X # evs)\"", "lemma Says_imp_knows [rule_format]: \"Says A B X \\<in> set evs --> X \\<in> knows A evs\"", "lemma Notes_imp_knows [rule_format]: \"Notes A X \\<in> set evs --> X \\<in> knows A evs\"", "lemma Gets_imp_knows_agents [rule_format]:\n     \"A \\<noteq> Spy --> Gets A X \\<in> set evs --> X \\<in> knows A evs\"", "lemma knows_imp_Says_Gets_Notes_initState [rule_format]:\n     \"[| X \\<in> knows A evs; A \\<noteq> Spy |] ==> \\<exists>B.  \n  Says A B X \\<in> set evs | Gets A X \\<in> set evs | Notes A X \\<in> set evs | X \\<in> initState A\"", "lemma knows_Spy_imp_Says_Notes_initState [rule_format]:\n     \"[| X \\<in> knows Spy evs |] ==> \\<exists>A B.  \n  Says A B X \\<in> set evs | Notes A X \\<in> set evs | X \\<in> initState Spy\"", "lemma parts_knows_Spy_subset_used: \"parts (knows Spy evs) \\<subseteq> used evs\"", "lemmas usedI = parts_knows_Spy_subset_used [THEN subsetD, intro]", "lemma initState_into_used: \"X \\<in> parts (initState B) ==> X \\<in> used evs\"", "lemma used_Says [simp]: \"used (Says A B X # evs) = parts{X} \\<union> used evs\"", "lemma used_Notes [simp]: \"used (Notes A X # evs) = parts{X} \\<union> used evs\"", "lemma used_Gets [simp]: \"used (Gets A X # evs) = used evs\"", "lemma used_nil_subset: \"used [] \\<subseteq> used evs\"", "lemmas analz_mono_contra =\n       knows_Spy_subset_knows_Spy_Says [THEN analz_mono, THEN contra_subsetD]\n       knows_Spy_subset_knows_Spy_Notes [THEN analz_mono, THEN contra_subsetD]\n       knows_Spy_subset_knows_Spy_Gets [THEN analz_mono, THEN contra_subsetD]", "lemma knows_subset_knows_Cons: \"knows A evs \\<subseteq> knows A (e # evs)\"", "lemma initState_subset_knows: \"initState A \\<subseteq> knows A evs\"", "lemma keysFor_parts_insert:\n     \"[| K \\<in> keysFor (parts (insert X G));  X \\<in> synth (analz H) |] \n      ==> K \\<in> keysFor (parts (G \\<union> H)) | Key (invKey K) \\<in> parts H\"", "lemmas analz_impI = impI [where P = \"Y \\<notin> analz (knows Spy evs)\"] for Y evs", "lemmas syan_impI = impI [where P = \"Y \\<notin> synth (analz (knows Spy evs))\"] for Y evs"], "translations": [["", "lemma Notes_imp_used [rule_format]: \"Notes A X \\<in> set evs --> X \\<in> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Notes A X \\<in> set evs \\<longrightarrow> X \\<in> used evs", "apply (induct_tac evs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Notes A X \\<in> set [] \\<longrightarrow> X \\<in> used []\n 2. \\<And>a list.\n       Notes A X \\<in> set list \\<longrightarrow>\n       X \\<in> used list \\<Longrightarrow>\n       Notes A X \\<in> set (a # list) \\<longrightarrow>\n       X \\<in> used (a # list)", "apply (auto split: event.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Says_imp_used [rule_format]: \"Says A B X \\<in> set evs --> X \\<in> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Says A B X \\<in> set evs \\<longrightarrow> X \\<in> used evs", "apply (induct_tac evs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Says A B X \\<in> set [] \\<longrightarrow> X \\<in> used []\n 2. \\<And>a list.\n       Says A B X \\<in> set list \\<longrightarrow>\n       X \\<in> used list \\<Longrightarrow>\n       Says A B X \\<in> set (a # list) \\<longrightarrow>\n       X \\<in> used (a # list)", "apply (auto split: event.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Function @{term knows}\\<close>"], ["", "(*Simplifying   \n parts(insert X (knows Spy evs)) = parts{X} \\<union> parts(knows Spy evs).\n  This version won't loop with the simplifier.*)"], ["", "lemmas parts_insert_knows_A = parts_insert [of _ \"knows A evs\"] for A evs"], ["", "lemma knows_Spy_Says [simp]:\n     \"knows Spy (Says A B X # evs) = insert X (knows Spy evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows Spy (Says A B X # evs) = insert X (knows Spy evs)", "by simp"], ["", "text\\<open>Letting the Spy see \"bad\" agents' notes avoids redundant case-splits\n      on whether @{term \"A=Spy\"} and whether @{term \"A\\<in>bad\"}\\<close>"], ["", "lemma knows_Spy_Notes [simp]:\n     \"knows Spy (Notes A X # evs) =  \n          (if A:bad then insert X (knows Spy evs) else knows Spy evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows Spy (Notes A X # evs) =\n    (if A \\<in> bad then insert X (knows Spy evs) else knows Spy evs)", "by simp"], ["", "lemma knows_Spy_Gets [simp]: \"knows Spy (Gets A X # evs) = knows Spy evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows Spy (Gets A X # evs) = knows Spy evs", "by simp"], ["", "lemma knows_Spy_subset_knows_Spy_Says:\n     \"knows Spy evs \\<subseteq> knows Spy (Says A B X # evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows Spy evs \\<subseteq> knows Spy (Says A B X # evs)", "by (simp add: subset_insertI)"], ["", "lemma knows_Spy_subset_knows_Spy_Notes:\n     \"knows Spy evs \\<subseteq> knows Spy (Notes A X # evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows Spy evs \\<subseteq> knows Spy (Notes A X # evs)", "by force"], ["", "lemma knows_Spy_subset_knows_Spy_Gets:\n     \"knows Spy evs \\<subseteq> knows Spy (Gets A X # evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows Spy evs \\<subseteq> knows Spy (Gets A X # evs)", "by (simp add: subset_insertI)"], ["", "text\\<open>Spy sees what is sent on the traffic\\<close>"], ["", "lemma Says_imp_knows_Spy [rule_format]:\n     \"Says A B X \\<in> set evs --> X \\<in> knows Spy evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Says A B X \\<in> set evs \\<longrightarrow> X \\<in> knows Spy evs", "apply (induct_tac \"evs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. Says A B X \\<in> set [] \\<longrightarrow> X \\<in> knows Spy []\n 2. \\<And>a list.\n       Says A B X \\<in> set list \\<longrightarrow>\n       X \\<in> knows Spy list \\<Longrightarrow>\n       Says A B X \\<in> set (a # list) \\<longrightarrow>\n       X \\<in> knows Spy (a # list)", "apply (simp_all (no_asm_simp) split: event.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Notes_imp_knows_Spy [rule_format]:\n     \"Notes A X \\<in> set evs --> A: bad --> X \\<in> knows Spy evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Notes A X \\<in> set evs \\<longrightarrow>\n    A \\<in> bad \\<longrightarrow> X \\<in> knows Spy evs", "apply (induct_tac \"evs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. Notes A X \\<in> set [] \\<longrightarrow>\n    A \\<in> bad \\<longrightarrow> X \\<in> knows Spy []\n 2. \\<And>a list.\n       Notes A X \\<in> set list \\<longrightarrow>\n       A \\<in> bad \\<longrightarrow>\n       X \\<in> knows Spy list \\<Longrightarrow>\n       Notes A X \\<in> set (a # list) \\<longrightarrow>\n       A \\<in> bad \\<longrightarrow> X \\<in> knows Spy (a # list)", "apply (simp_all (no_asm_simp) split: event.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Elimination rules: derive contradictions from old Says events containing\n  items known to be fresh\\<close>"], ["", "lemmas Says_imp_parts_knows_Spy = \n       Says_imp_knows_Spy [THEN parts.Inj, THEN revcut_rl]"], ["", "lemmas knows_Spy_partsEs =\n     Says_imp_parts_knows_Spy parts.Body [THEN revcut_rl]"], ["", "lemmas Says_imp_analz_Spy = Says_imp_knows_Spy [THEN analz.Inj]"], ["", "text\\<open>Compatibility for the old \"spies\" function\\<close>"], ["", "lemmas spies_partsEs = knows_Spy_partsEs"], ["", "lemmas Says_imp_spies = Says_imp_knows_Spy"], ["", "lemmas parts_insert_spies = parts_insert_knows_A [of _ Spy]"], ["", "subsection\\<open>Knowledge of Agents\\<close>"], ["", "lemma knows_Says: \"knows A (Says A B X # evs) = insert X (knows A evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A (Says A B X # evs) = insert X (knows A evs)", "by simp"], ["", "lemma knows_Notes: \"knows A (Notes A X # evs) = insert X (knows A evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A (Notes A X # evs) = insert X (knows A evs)", "by simp"], ["", "lemma knows_Gets:\n     \"A \\<noteq> Spy --> knows A (Gets A X # evs) = insert X (knows A evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> Spy \\<longrightarrow>\n    knows A (Gets A X # evs) = insert X (knows A evs)", "by simp"], ["", "lemma knows_subset_knows_Says: \"knows A evs \\<subseteq> knows A (Says A' B X # evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A evs \\<subseteq> knows A (Says A' B X # evs)", "by (simp add: subset_insertI)"], ["", "lemma knows_subset_knows_Notes: \"knows A evs \\<subseteq> knows A (Notes A' X # evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A evs \\<subseteq> knows A (Notes A' X # evs)", "by (simp add: subset_insertI)"], ["", "lemma knows_subset_knows_Gets: \"knows A evs \\<subseteq> knows A (Gets A' X # evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A evs \\<subseteq> knows A (Gets A' X # evs)", "by (simp add: subset_insertI)"], ["", "text\\<open>Agents know what they say\\<close>"], ["", "lemma Says_imp_knows [rule_format]: \"Says A B X \\<in> set evs --> X \\<in> knows A evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Says A B X \\<in> set evs \\<longrightarrow> X \\<in> knows A evs", "apply (induct_tac \"evs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. Says A B X \\<in> set [] \\<longrightarrow> X \\<in> knows A []\n 2. \\<And>a list.\n       Says A B X \\<in> set list \\<longrightarrow>\n       X \\<in> knows A list \\<Longrightarrow>\n       Says A B X \\<in> set (a # list) \\<longrightarrow>\n       X \\<in> knows A (a # list)", "apply (simp_all (no_asm_simp) split: event.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Says A B X \\<in> set list \\<longrightarrow>\n       X \\<in> knows A list \\<Longrightarrow>\n       (\\<forall>x11 x12 x13.\n           (x11 = A \\<longrightarrow>\n            a = Says A x12 x13 \\<longrightarrow>\n            A = Spy \\<longrightarrow>\n            Says Spy B X \\<in> set list \\<longrightarrow>\n            X = x13 \\<or> X \\<in> knows Spy list) \\<and>\n           (x11 \\<noteq> A \\<longrightarrow>\n            a = Says x11 x12 x13 \\<longrightarrow>\n            A = Spy \\<longrightarrow>\n            Says Spy B X \\<in> set list \\<longrightarrow>\n            X = x13 \\<or> X \\<in> knows Spy list)) \\<and>\n       (\\<forall>x21 x22.\n           (x21 = A \\<longrightarrow>\n            a = Gets A x22 \\<longrightarrow>\n            A = Spy \\<longrightarrow>\n            Says Spy B X \\<in> set list \\<longrightarrow>\n            X \\<in> knows Spy list) \\<and>\n           (x21 \\<noteq> A \\<longrightarrow>\n            a = Gets x21 x22 \\<longrightarrow>\n            A = Spy \\<longrightarrow>\n            Says Spy B X \\<in> set list \\<longrightarrow>\n            X \\<in> knows Spy list)) \\<and>\n       (\\<forall>x31 x32.\n           (x31 \\<in> bad \\<longrightarrow>\n            (x31 = A \\<longrightarrow>\n             a = Notes A x32 \\<longrightarrow>\n             A = Spy \\<longrightarrow>\n             Says Spy B X \\<in> set list \\<longrightarrow>\n             X = x32 \\<or> X \\<in> knows Spy list) \\<and>\n            (x31 \\<noteq> A \\<longrightarrow>\n             a = Notes x31 x32 \\<longrightarrow>\n             A = Spy \\<longrightarrow>\n             Says Spy B X \\<in> set list \\<longrightarrow>\n             X = x32 \\<or> X \\<in> knows Spy list)) \\<and>\n           (x31 \\<notin> bad \\<longrightarrow>\n            (x31 = A \\<longrightarrow>\n             a = Notes A x32 \\<longrightarrow>\n             A = Spy \\<longrightarrow>\n             Says Spy B X \\<in> set list \\<longrightarrow>\n             X = x32 \\<or> X \\<in> knows Spy list) \\<and>\n            (x31 \\<noteq> A \\<longrightarrow>\n             a = Notes x31 x32 \\<longrightarrow>\n             A = Spy \\<longrightarrow>\n             Says Spy B X \\<in> set list \\<longrightarrow>\n             X \\<in> knows Spy list)))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Agents know what they note\\<close>"], ["", "lemma Notes_imp_knows [rule_format]: \"Notes A X \\<in> set evs --> X \\<in> knows A evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Notes A X \\<in> set evs \\<longrightarrow> X \\<in> knows A evs", "apply (induct_tac \"evs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. Notes A X \\<in> set [] \\<longrightarrow> X \\<in> knows A []\n 2. \\<And>a list.\n       Notes A X \\<in> set list \\<longrightarrow>\n       X \\<in> knows A list \\<Longrightarrow>\n       Notes A X \\<in> set (a # list) \\<longrightarrow>\n       X \\<in> knows A (a # list)", "apply (simp_all (no_asm_simp) split: event.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Notes A X \\<in> set list \\<longrightarrow>\n       X \\<in> knows A list \\<Longrightarrow>\n       (\\<forall>x11 x12 x13.\n           (x11 = A \\<longrightarrow>\n            a = Says A x12 x13 \\<longrightarrow>\n            A = Spy \\<longrightarrow>\n            Notes Spy X \\<in> set list \\<longrightarrow>\n            X = x13 \\<or> X \\<in> knows Spy list) \\<and>\n           (x11 \\<noteq> A \\<longrightarrow>\n            a = Says x11 x12 x13 \\<longrightarrow>\n            A = Spy \\<longrightarrow>\n            Notes Spy X \\<in> set list \\<longrightarrow>\n            X = x13 \\<or> X \\<in> knows Spy list)) \\<and>\n       (\\<forall>x21 x22.\n           (x21 = A \\<longrightarrow>\n            a = Gets A x22 \\<longrightarrow>\n            A = Spy \\<longrightarrow>\n            Notes Spy X \\<in> set list \\<longrightarrow>\n            X \\<in> knows Spy list) \\<and>\n           (x21 \\<noteq> A \\<longrightarrow>\n            a = Gets x21 x22 \\<longrightarrow>\n            A = Spy \\<longrightarrow>\n            Notes Spy X \\<in> set list \\<longrightarrow>\n            X \\<in> knows Spy list)) \\<and>\n       (\\<forall>x31 x32.\n           (x31 \\<in> bad \\<longrightarrow>\n            (x31 = A \\<longrightarrow>\n             a = Notes A x32 \\<longrightarrow>\n             A = Spy \\<longrightarrow>\n             Notes Spy X \\<in> set list \\<longrightarrow>\n             X = x32 \\<or> X \\<in> knows Spy list) \\<and>\n            (x31 \\<noteq> A \\<longrightarrow>\n             a = Notes x31 x32 \\<longrightarrow>\n             A = Spy \\<longrightarrow>\n             Notes Spy X \\<in> set list \\<longrightarrow>\n             X = x32 \\<or> X \\<in> knows Spy list)) \\<and>\n           (x31 \\<notin> bad \\<longrightarrow>\n            (x31 = A \\<longrightarrow>\n             a = Notes A x32 \\<longrightarrow>\n             A = Spy \\<longrightarrow>\n             Notes Spy X \\<in> set list \\<longrightarrow>\n             X = x32 \\<or> X \\<in> knows Spy list) \\<and>\n            (x31 \\<noteq> A \\<longrightarrow>\n             a = Notes x31 x32 \\<longrightarrow>\n             A = Spy \\<longrightarrow>\n             Notes Spy X \\<in> set list \\<longrightarrow>\n             X \\<in> knows Spy list)))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Agents know what they receive\\<close>"], ["", "lemma Gets_imp_knows_agents [rule_format]:\n     \"A \\<noteq> Spy --> Gets A X \\<in> set evs --> X \\<in> knows A evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> Spy \\<longrightarrow>\n    Gets A X \\<in> set evs \\<longrightarrow> X \\<in> knows A evs", "apply (induct_tac \"evs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. A \\<noteq> Spy \\<longrightarrow>\n    Gets A X \\<in> set [] \\<longrightarrow> X \\<in> knows A []\n 2. \\<And>a list.\n       A \\<noteq> Spy \\<longrightarrow>\n       Gets A X \\<in> set list \\<longrightarrow>\n       X \\<in> knows A list \\<Longrightarrow>\n       A \\<noteq> Spy \\<longrightarrow>\n       Gets A X \\<in> set (a # list) \\<longrightarrow>\n       X \\<in> knows A (a # list)", "apply (simp_all (no_asm_simp) split: event.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>What agents DIFFERENT FROM Spy know \n  was either said, or noted, or got, or known initially\\<close>"], ["", "lemma knows_imp_Says_Gets_Notes_initState [rule_format]:\n     \"[| X \\<in> knows A evs; A \\<noteq> Spy |] ==> \\<exists>B.  \n  Says A B X \\<in> set evs | Gets A X \\<in> set evs | Notes A X \\<in> set evs | X \\<in> initState A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> knows A evs; A \\<noteq> Spy\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B.\n                         Says A B X \\<in> set evs \\<or>\n                         Gets A X \\<in> set evs \\<or>\n                         Notes A X \\<in> set evs \\<or> X \\<in> initState A", "apply (erule rev_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> Spy \\<Longrightarrow>\n    X \\<in> knows A evs \\<longrightarrow>\n    (\\<exists>B.\n        Says A B X \\<in> set evs \\<or>\n        Gets A X \\<in> set evs \\<or>\n        Notes A X \\<in> set evs \\<or> X \\<in> initState A)", "apply (induct_tac \"evs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. A \\<noteq> Spy \\<Longrightarrow>\n    X \\<in> knows A [] \\<longrightarrow>\n    (\\<exists>B.\n        Says A B X \\<in> set [] \\<or>\n        Gets A X \\<in> set [] \\<or>\n        Notes A X \\<in> set [] \\<or> X \\<in> initState A)\n 2. \\<And>a list.\n       \\<lbrakk>A \\<noteq> Spy;\n        X \\<in> knows A list \\<longrightarrow>\n        (\\<exists>B.\n            Says A B X \\<in> set list \\<or>\n            Gets A X \\<in> set list \\<or>\n            Notes A X \\<in> set list \\<or> X \\<in> initState A)\\<rbrakk>\n       \\<Longrightarrow> X \\<in> knows A (a # list) \\<longrightarrow>\n                         (\\<exists>B.\n                             Says A B X \\<in> set (a # list) \\<or>\n                             Gets A X \\<in> set (a # list) \\<or>\n                             Notes A X \\<in> set (a # list) \\<or>\n                             X \\<in> initState A)", "apply (simp_all (no_asm_simp) split: event.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>A \\<noteq> Spy;\n        X \\<in> knows A list \\<longrightarrow>\n        (\\<exists>B.\n            Says A B X \\<in> set list \\<or>\n            Gets A X \\<in> set list \\<or>\n            Notes A X \\<in> set list \\<or> X \\<in> initState A)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x11 x12 x13.\n                             (x11 = A \\<longrightarrow>\n                              a = Says A x12 x13 \\<longrightarrow>\n                              (X = x13 \\<longrightarrow>\n                               (\\<exists>B.\n                                   B = x12 \\<or>\n                                   Says A B x13 \\<in> set list \\<or>\n                                   Gets A x13 \\<in> set list \\<or>\n                                   Notes A x13 \\<in> set list \\<or>\n                                   x13 \\<in> initState A)) \\<and>\n                              (X \\<in> knows A list \\<longrightarrow>\n                               (\\<exists>B.\n                                   B = x12 \\<and> X = x13 \\<or>\n                                   Says A B X \\<in> set list \\<or>\n                                   Gets A X \\<in> set list \\<or>\n                                   Notes A X \\<in> set list \\<or>\n                                   X \\<in> initState A))) \\<and>\n                             (x11 \\<noteq> A \\<longrightarrow>\n                              a = Says x11 x12 x13 \\<longrightarrow>\n                              X \\<in> knows A list \\<longrightarrow>\n                              (\\<exists>B. Says A B X \\<in> set list) \\<or>\n                              Gets A X \\<in> set list \\<or>\n                              Notes A X \\<in> set list \\<or>\n                              X \\<in> initState A)) \\<and>\n                         (\\<forall>x21 x22.\n                             (x21 = A \\<longrightarrow>\n                              a = Gets A x22 \\<longrightarrow>\n                              X \\<in> knows A list \\<longrightarrow>\n                              (\\<exists>B. Says A B X \\<in> set list) \\<or>\n                              X = x22 \\<or>\n                              Gets A X \\<in> set list \\<or>\n                              Notes A X \\<in> set list \\<or>\n                              X \\<in> initState A) \\<and>\n                             (x21 \\<noteq> A \\<longrightarrow>\n                              a = Gets x21 x22 \\<longrightarrow>\n                              X \\<in> knows A list \\<longrightarrow>\n                              (\\<exists>B. Says A B X \\<in> set list) \\<or>\n                              Gets A X \\<in> set list \\<or>\n                              Notes A X \\<in> set list \\<or>\n                              X \\<in> initState A)) \\<and>\n                         (\\<forall>x31 x32.\n                             (x31 = A \\<longrightarrow>\n                              a = Notes A x32 \\<longrightarrow>\n                              X \\<in> knows A list \\<longrightarrow>\n                              (\\<exists>B. Says A B X \\<in> set list) \\<or>\n                              Gets A X \\<in> set list \\<or>\n                              X = x32 \\<or>\n                              Notes A X \\<in> set list \\<or>\n                              X \\<in> initState A) \\<and>\n                             (x31 \\<noteq> A \\<longrightarrow>\n                              a = Notes x31 x32 \\<longrightarrow>\n                              X \\<in> knows A list \\<longrightarrow>\n                              (\\<exists>B. Says A B X \\<in> set list) \\<or>\n                              Gets A X \\<in> set list \\<or>\n                              Notes A X \\<in> set list \\<or>\n                              X \\<in> initState A))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>What the Spy knows -- for the time being --\n  was either said or noted, or known initially\\<close>"], ["", "lemma knows_Spy_imp_Says_Notes_initState [rule_format]:\n     \"[| X \\<in> knows Spy evs |] ==> \\<exists>A B.  \n  Says A B X \\<in> set evs | Notes A X \\<in> set evs | X \\<in> initState Spy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> knows Spy evs \\<Longrightarrow>\n    \\<exists>A B.\n       Says A B X \\<in> set evs \\<or>\n       Notes A X \\<in> set evs \\<or> X \\<in> initState Spy", "apply (erule rev_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> knows Spy evs \\<longrightarrow>\n    (\\<exists>A B.\n        Says A B X \\<in> set evs \\<or>\n        Notes A X \\<in> set evs \\<or> X \\<in> initState Spy)", "apply (induct_tac \"evs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. X \\<in> knows Spy [] \\<longrightarrow>\n    (\\<exists>A B.\n        Says A B X \\<in> set [] \\<or>\n        Notes A X \\<in> set [] \\<or> X \\<in> initState Spy)\n 2. \\<And>a list.\n       X \\<in> knows Spy list \\<longrightarrow>\n       (\\<exists>A B.\n           Says A B X \\<in> set list \\<or>\n           Notes A X \\<in> set list \\<or>\n           X \\<in> initState Spy) \\<Longrightarrow>\n       X \\<in> knows Spy (a # list) \\<longrightarrow>\n       (\\<exists>A B.\n           Says A B X \\<in> set (a # list) \\<or>\n           Notes A X \\<in> set (a # list) \\<or> X \\<in> initState Spy)", "apply (simp_all (no_asm_simp) split: event.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       X \\<in> knows Spy list \\<longrightarrow>\n       (\\<exists>A B.\n           Says A B X \\<in> set list \\<or>\n           Notes A X \\<in> set list \\<or>\n           X \\<in> initState Spy) \\<Longrightarrow>\n       (\\<forall>x11 x12 x13.\n           a = Says x11 x12 x13 \\<longrightarrow>\n           (X = x13 \\<longrightarrow>\n            (\\<exists>A B.\n                A = x11 \\<and> B = x12 \\<or>\n                Says A B x13 \\<in> set list \\<or>\n                Notes A x13 \\<in> set list \\<or>\n                x13 \\<in> initState Spy)) \\<and>\n           (X \\<in> knows Spy list \\<longrightarrow>\n            (\\<exists>A B.\n                A = x11 \\<and> B = x12 \\<and> X = x13 \\<or>\n                Says A B X \\<in> set list \\<or>\n                Notes A X \\<in> set list \\<or>\n                X \\<in> initState Spy))) \\<and>\n       ((\\<exists>x21 x22. a = Gets x21 x22) \\<longrightarrow>\n        X \\<in> knows Spy list \\<longrightarrow>\n        (\\<exists>A.\n            (\\<exists>B. Says A B X \\<in> set list) \\<or>\n            Notes A X \\<in> set list \\<or> X \\<in> initState Spy)) \\<and>\n       (\\<forall>x31 x32.\n           (x31 \\<in> bad \\<longrightarrow>\n            a = Notes x31 x32 \\<longrightarrow>\n            (X = x32 \\<longrightarrow>\n             (\\<exists>A.\n                 (\\<exists>B. Says A B x32 \\<in> set list) \\<or>\n                 A = x31 \\<or>\n                 Notes A x32 \\<in> set list \\<or>\n                 x32 \\<in> initState Spy)) \\<and>\n            (X \\<in> knows Spy list \\<longrightarrow>\n             (\\<exists>A.\n                 (\\<exists>B. Says A B X \\<in> set list) \\<or>\n                 A = x31 \\<and> X = x32 \\<or>\n                 Notes A X \\<in> set list \\<or>\n                 X \\<in> initState Spy))) \\<and>\n           (x31 \\<notin> bad \\<longrightarrow>\n            a = Notes x31 x32 \\<longrightarrow>\n            X \\<in> knows Spy list \\<longrightarrow>\n            (\\<exists>A.\n                (\\<exists>B. Says A B X \\<in> set list) \\<or>\n                A = x31 \\<and> X = x32 \\<or>\n                Notes A X \\<in> set list \\<or> X \\<in> initState Spy)))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_knows_Spy_subset_used: \"parts (knows Spy evs) \\<subseteq> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (knows Spy evs) \\<subseteq> used evs", "apply (induct_tac \"evs\", force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       parts (knows Spy list) \\<subseteq> used list \\<Longrightarrow>\n       parts (knows Spy (a # list)) \\<subseteq> used (a # list)", "apply (simp add: parts_insert_knows_A knows_Cons add: event.split, blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas usedI = parts_knows_Spy_subset_used [THEN subsetD, intro]"], ["", "lemma initState_into_used: \"X \\<in> parts (initState B) ==> X \\<in> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> parts (initState B) \\<Longrightarrow> X \\<in> used evs", "apply (induct_tac \"evs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. X \\<in> parts (initState B) \\<Longrightarrow> X \\<in> used []\n 2. \\<And>a list.\n       \\<lbrakk>X \\<in> parts (initState B); X \\<in> used list\\<rbrakk>\n       \\<Longrightarrow> X \\<in> used (a # list)", "apply (simp_all add: parts_insert_knows_A split: event.split, blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma used_Says [simp]: \"used (Says A B X # evs) = parts{X} \\<union> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. used (Says A B X # evs) = parts {X} \\<union> used evs", "by simp"], ["", "lemma used_Notes [simp]: \"used (Notes A X # evs) = parts{X} \\<union> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. used (Notes A X # evs) = parts {X} \\<union> used evs", "by simp"], ["", "lemma used_Gets [simp]: \"used (Gets A X # evs) = used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. used (Gets A X # evs) = used evs", "by simp"], ["", "lemma used_nil_subset: \"used [] \\<subseteq> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. used [] \\<subseteq> used evs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>B. parts (initState B)) \\<subseteq> used evs", "apply (blast intro: initState_into_used)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>NOTE REMOVAL--laws above are cleaner, as they don't involve \"case\"\\<close>"], ["", "declare knows_Cons [simp del]\n        used_Nil [simp del] used_Cons [simp del]"], ["", "text\\<open>For proving theorems of the form @{term \"X \\<notin> analz (knows Spy evs) --> P\"}\n  New events added by induction to \"evs\" are discarded.  Provided \n  this information isn't needed, the proof will be much shorter, since\n  it will omit complicated reasoning about @{term analz}.\\<close>"], ["", "lemmas analz_mono_contra =\n       knows_Spy_subset_knows_Spy_Says [THEN analz_mono, THEN contra_subsetD]\n       knows_Spy_subset_knows_Spy_Notes [THEN analz_mono, THEN contra_subsetD]\n       knows_Spy_subset_knows_Spy_Gets [THEN analz_mono, THEN contra_subsetD]"], ["", "lemma knows_subset_knows_Cons: \"knows A evs \\<subseteq> knows A (e # evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A evs \\<subseteq> knows A (e # evs)", "by (induct e, auto simp: knows_Cons)"], ["", "lemma initState_subset_knows: \"initState A \\<subseteq> knows A evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initState A \\<subseteq> knows A evs", "apply (induct_tac evs, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       initState A \\<subseteq> knows A list \\<Longrightarrow>\n       initState A \\<subseteq> knows A (a # list)", "apply (blast intro: knows_subset_knows_Cons [THEN subsetD])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>For proving \\<open>new_keys_not_used\\<close>\\<close>"], ["", "lemma keysFor_parts_insert:\n     \"[| K \\<in> keysFor (parts (insert X G));  X \\<in> synth (analz H) |] \n      ==> K \\<in> keysFor (parts (G \\<union> H)) | Key (invKey K) \\<in> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>K \\<in> keysFor (parts (insert X G));\n     X \\<in> synth (analz H)\\<rbrakk>\n    \\<Longrightarrow> K \\<in> keysFor (parts (G \\<union> H)) \\<or>\n                      Key (invKey K) \\<in> parts H", "by (force \n    dest!: parts_insert_subset_Un [THEN keysFor_mono, THEN [2] rev_subsetD]\n           analz_subset_parts [THEN keysFor_mono, THEN [2] rev_subsetD]\n    intro: analz_subset_parts [THEN subsetD] parts_mono [THEN [2] rev_subsetD])"], ["", "lemmas analz_impI = impI [where P = \"Y \\<notin> analz (knows Spy evs)\"] for Y evs"], ["", "ML\n\\<open>\nfun analz_mono_contra_tac ctxt =\n  resolve_tac ctxt @{thms analz_impI} THEN' \n  REPEAT1 o (dresolve_tac ctxt @{thms analz_mono_contra})\n  THEN' mp_tac ctxt\n\\<close>"], ["", "method_setup analz_mono_contra = \\<open>\n    Scan.succeed (fn ctxt => SIMPLE_METHOD (REPEAT_FIRST (analz_mono_contra_tac ctxt)))\\<close>\n    \"for proving theorems of the form X \\<notin> analz (knows Spy evs) --> P\""], ["", "text\\<open>Useful for case analysis on whether a hash is a spoof or not\\<close>"], ["", "lemmas syan_impI = impI [where P = \"Y \\<notin> synth (analz (knows Spy evs))\"] for Y evs"], ["", "ML\n\\<open>\nfun synth_analz_mono_contra_tac ctxt =\n  resolve_tac ctxt @{thms syan_impI} THEN'\n  REPEAT1 o \n    (dresolve_tac ctxt \n     [@{thm knows_Spy_subset_knows_Spy_Says} RS @{thm synth_analz_mono} RS @{thm contra_subsetD},\n      @{thm knows_Spy_subset_knows_Spy_Notes} RS @{thm synth_analz_mono} RS @{thm contra_subsetD},\n      @{thm knows_Spy_subset_knows_Spy_Gets} RS @{thm synth_analz_mono} RS @{thm contra_subsetD}])\n  THEN'\n  mp_tac ctxt\n\\<close>"], ["", "method_setup synth_analz_mono_contra = \\<open>\n    Scan.succeed (fn ctxt => SIMPLE_METHOD (REPEAT_FIRST (synth_analz_mono_contra_tac ctxt)))\\<close>\n    \"for proving theorems of the form X \\<notin> synth (analz (knows Spy evs)) --> P\""], ["", "end"]]}