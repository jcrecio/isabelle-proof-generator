{"file_name": "/home/qj213/afp-2021-10-22/thys/Inductive_Confidentiality/GeneralAttacker/Knowledge.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Inductive_Confidentiality", "problem_names": ["theorem knowledge_equiv:\n \"\\<lbrakk> X \\<in> knows A evs; Notes A X \\<notin> set evs;\n   X \\<notin> {Key (priEK A), Key (priSK A), Key (shrK A)} \\<rbrakk>\n \\<Longrightarrow> X \\<in> knows B evs\"", "lemma knowledge_equiv_bis:\n \"\\<lbrakk> X \\<in> knows A evs; Notes A X \\<notin> set evs \\<rbrakk>\n \\<Longrightarrow> X \\<in> {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union> knows B evs\"", "lemma knowledge_equiv_ter:\n \"\\<lbrakk> X \\<in> knows A evs; X \\<notin> {Key (priEK A), Key (priSK A), Key (shrK A)} \\<rbrakk>\n\\<Longrightarrow> X \\<in> knows B evs \\<or> Notes A X \\<in> set evs\"", "lemma knowledge_equiv_quater:\n \" X \\<in> knows A evs\n\\<Longrightarrow> X \\<in> knows B evs \\<or> Notes A X \\<in> set evs \\<or> \n   X \\<in> {Key (priEK A), Key (priSK A), Key (shrK A)}\"", "lemma setdiff_diff_insert: \"A-B-C=D-E-F \\<Longrightarrow> insert m (A-B-C) = insert m (D-E-F)\"", "lemma \"A-B-C=D-E-F \\<Longrightarrow> insert m A-B-C = insert m D-E-F\"", "lemma knowledge_equiv_eq_setdiff:\n \"knows A evs  -\n   {Key (priEK A), Key (priSK A), Key (shrK A)} -\n     {X. Notes A X \\<in> set evs}\n  =\n  knows B evs -\n   {Key (priEK B), Key (priSK B), Key (shrK B)} -\n     {X. Notes B X \\<in> set evs}\"", "lemma knowledge_equiv_eq_old:\n \"knows A evs  \\<union>  \n   {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union> \n     {X. Notes B X \\<in> set evs} \n  = \n  knows B evs \\<union> \n   {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union> \n     {X. Notes A X \\<in> set evs}\"", "theorem knowledge_eval: \"knows A evs = \n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union> \n       (Key ` range pubEK) \\<union> (Key ` range pubSK) \\<union>\n       {X. \\<exists> S R. Says S R X \\<in> set evs} \\<union>\n       {X. Notes A X \\<in> set evs}\"", "lemma knowledge_eval_setdiff:\n \"knows A evs  - \n   {Key (priEK A), Key (priSK A), Key (shrK A)} -\n     {X. Notes A X \\<in> set evs}\n  = \n       (Key ` range pubEK) \\<union> (Key ` range pubSK) \\<union>\n       {X. \\<exists> S R. Says S R X \\<in> set evs}\"", "theorem knowledge_equiv_eq: \"knows A evs  \\<union>  \n   {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union> \n     {X. Notes B X \\<in> set evs} \n  = \n  knows B evs \\<union> \n   {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union> \n     {X. Notes A X \\<in> set evs}\"", "lemma \"knows A evs  \\<union>  \n   {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union> \n     {X. Notes B X \\<in> set evs} -\n(  {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union> \n     {X. Notes B X \\<in> set evs} ) = knows A evs\"", "theorem parts_knowledge_equiv_eq: \"\nparts(knows A evs)  \\<union>  \n   {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union> \n     parts({X. Notes B X \\<in> set evs}) \n  = \nparts(knows B evs) \\<union> \n   {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union> \n     parts({X. Notes A X \\<in> set evs})\"", "lemmas parts_knowledge_equiv = parts_knowledge_equiv_eq [THEN equalityD1, THEN subsetD]", "theorem noprishr_parts_knowledge_equiv: \"\n\\<lbrakk> X \\<notin> {Key (priEK A), Key (priSK A), Key (shrK A)};\n  X \\<in> parts(knows A evs) \\<rbrakk>\n\\<Longrightarrow>  X \\<in> parts(knows B evs) \\<union> \n      parts({X. Notes A X \\<in> set evs})\"", "lemma knowledge_equiv_eq_NS: \" \n  evs \\<in> ns_public \\<Longrightarrow>\n  knows A evs  \\<union> {Key (priEK B), Key (priSK B), Key (shrK B)}  = \n  knows B evs \\<union> {Key (priEK A), Key (priSK A), Key (shrK A)}\"", "lemma parts_knowledge_equiv_eq_NS: \" \n  evs \\<in> ns_public \\<Longrightarrow>\n  parts(knows A evs) \\<union> {Key (priEK B), Key (priSK B), Key (shrK B)}  = \n  parts(knows B evs) \\<union> {Key (priEK A), Key (priSK A), Key (shrK A)}\"", "theorem noprishr_parts_knowledge_equiv_NS: \" \n\\<lbrakk> X \\<notin> {Key (priEK A), Key (priSK A), Key (shrK A)};\n  X \\<in> parts(knows A evs); evs \\<in> ns_public \\<rbrakk>\n\\<Longrightarrow>  X \\<in> parts(knows B evs)\"", "theorem Agent_not_analz_N:\n\"\\<lbrakk> Nonce N \\<notin> parts(knows A evs); evs \\<in> ns_public \\<rbrakk>\n \\<Longrightarrow> Nonce N \\<notin> analz(knows B evs)\""], "translations": [["", "theorem knowledge_equiv:\n \"\\<lbrakk> X \\<in> knows A evs; Notes A X \\<notin> set evs;\n   X \\<notin> {Key (priEK A), Key (priSK A), Key (shrK A)} \\<rbrakk>\n \\<Longrightarrow> X \\<in> knows B evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> knows A evs; Notes A X \\<notin> set evs;\n     X \\<notin> {Key (priEK A), Key (priSK A), Key (shrK A)}\\<rbrakk>\n    \\<Longrightarrow> X \\<in> knows B evs", "apply (erule rev_mp, erule rev_mp, erule rev_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<notin> {Key (priEK A), Key (priSK A),\n                Key (shrK A)} \\<longrightarrow>\n    Notes A X \\<notin> set evs \\<longrightarrow>\n    X \\<in> knows A evs \\<longrightarrow> X \\<in> knows B evs", "apply (induct_tac \"A\", induct_tac \"B\", induct_tac \"evs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xaa.\n       X \\<notin> {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n                   Key (shrK (Friend xa))} \\<longrightarrow>\n       Notes (Friend xa) X \\<notin> set [] \\<longrightarrow>\n       X \\<in> knows (Friend xa) [] \\<longrightarrow>\n       X \\<in> knows (Friend xaa) []\n 2. \\<And>xa xaa a list.\n       X \\<notin> {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n                   Key (shrK (Friend xa))} \\<longrightarrow>\n       Notes (Friend xa) X \\<notin> set list \\<longrightarrow>\n       X \\<in> knows (Friend xa) list \\<longrightarrow>\n       X \\<in> knows (Friend xaa) list \\<Longrightarrow>\n       X \\<notin> {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n                   Key (shrK (Friend xa))} \\<longrightarrow>\n       Notes (Friend xa) X \\<notin> set (a # list) \\<longrightarrow>\n       X \\<in> knows (Friend xa) (a # list) \\<longrightarrow>\n       X \\<in> knows (Friend xaa) (a # list)", "apply (induct_tac [2] \"a\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa xaa.\n       X \\<notin> {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n                   Key (shrK (Friend xa))} \\<longrightarrow>\n       Notes (Friend xa) X \\<notin> set [] \\<longrightarrow>\n       X \\<in> knows (Friend xa) [] \\<longrightarrow>\n       X \\<in> knows (Friend xaa) []\n 2. \\<And>xa xaa a list x1 x2 x3.\n       X \\<notin> {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n                   Key (shrK (Friend xa))} \\<longrightarrow>\n       Notes (Friend xa) X \\<notin> set list \\<longrightarrow>\n       X \\<in> knows (Friend xa) list \\<longrightarrow>\n       X \\<in> knows (Friend xaa) list \\<Longrightarrow>\n       X \\<notin> {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n                   Key (shrK (Friend xa))} \\<longrightarrow>\n       Notes (Friend xa) X\n       \\<notin> set (Says x1 x2 x3 # list) \\<longrightarrow>\n       X \\<in> knows (Friend xa) (Says x1 x2 x3 # list) \\<longrightarrow>\n       X \\<in> knows (Friend xaa) (Says x1 x2 x3 # list)\n 3. \\<And>xa xaa a list x1 x2.\n       X \\<notin> {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n                   Key (shrK (Friend xa))} \\<longrightarrow>\n       Notes (Friend xa) X \\<notin> set list \\<longrightarrow>\n       X \\<in> knows (Friend xa) list \\<longrightarrow>\n       X \\<in> knows (Friend xaa) list \\<Longrightarrow>\n       X \\<notin> {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n                   Key (shrK (Friend xa))} \\<longrightarrow>\n       Notes (Friend xa) X\n       \\<notin> set (Gets x1 x2 # list) \\<longrightarrow>\n       X \\<in> knows (Friend xa) (Gets x1 x2 # list) \\<longrightarrow>\n       X \\<in> knows (Friend xaa) (Gets x1 x2 # list)\n 4. \\<And>xa xaa a list x1 x2.\n       X \\<notin> {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n                   Key (shrK (Friend xa))} \\<longrightarrow>\n       Notes (Friend xa) X \\<notin> set list \\<longrightarrow>\n       X \\<in> knows (Friend xa) list \\<longrightarrow>\n       X \\<in> knows (Friend xaa) list \\<Longrightarrow>\n       X \\<notin> {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n                   Key (shrK (Friend xa))} \\<longrightarrow>\n       Notes (Friend xa) X\n       \\<notin> set (Notes x1 x2 # list) \\<longrightarrow>\n       X \\<in> knows (Friend xa) (Notes x1 x2 # list) \\<longrightarrow>\n       X \\<in> knows (Friend xaa) (Notes x1 x2 # list)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma knowledge_equiv_bis:\n \"\\<lbrakk> X \\<in> knows A evs; Notes A X \\<notin> set evs \\<rbrakk>\n \\<Longrightarrow> X \\<in> {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union> knows B evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> knows A evs; Notes A X \\<notin> set evs\\<rbrakk>\n    \\<Longrightarrow> X \\<in> {Key (priEK A), Key (priSK A),\n                               Key (shrK A)} \\<union>\n                              knows B evs", "apply (blast dest: knowledge_equiv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma knowledge_equiv_ter:\n \"\\<lbrakk> X \\<in> knows A evs; X \\<notin> {Key (priEK A), Key (priSK A), Key (shrK A)} \\<rbrakk>\n\\<Longrightarrow> X \\<in> knows B evs \\<or> Notes A X \\<in> set evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> knows A evs;\n     X \\<notin> {Key (priEK A), Key (priSK A), Key (shrK A)}\\<rbrakk>\n    \\<Longrightarrow> X \\<in> knows B evs \\<or> Notes A X \\<in> set evs", "apply (blast dest: knowledge_equiv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma knowledge_equiv_quater:\n \" X \\<in> knows A evs\n\\<Longrightarrow> X \\<in> knows B evs \\<or> Notes A X \\<in> set evs \\<or> \n   X \\<in> {Key (priEK A), Key (priSK A), Key (shrK A)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> knows A evs \\<Longrightarrow>\n    X \\<in> knows B evs \\<or>\n    Notes A X \\<in> set evs \\<or>\n    X \\<in> {Key (priEK A), Key (priSK A), Key (shrK A)}", "apply (blast dest: knowledge_equiv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma setdiff_diff_insert: \"A-B-C=D-E-F \\<Longrightarrow> insert m (A-B-C) = insert m (D-E-F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - B - C = D - E - F \\<Longrightarrow>\n    insert m (A - B - C) = insert m (D - E - F)", "by simp"], ["", "(*IMPORTANT NOTE TO PREVIOUS LEMMA: removing parentheses from rhs falsifies\nthe lemma because set insertion seems to have higher priority than set\ndifference, hence insert m A-B-C \\<noteq> insert m (A-B-C)!\nSeen such operand priority, it can be understood why the lemma wouldn't hold\nwithout parentheses*)"], ["", "lemma \"A-B-C=D-E-F \\<Longrightarrow> insert m A-B-C = insert m D-E-F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - B - C = D - E - F \\<Longrightarrow>\n    insert m A - B - C = insert m D - E - F", "oops"], ["", "lemma knowledge_equiv_eq_setdiff:\n \"knows A evs  -\n   {Key (priEK A), Key (priSK A), Key (shrK A)} -\n     {X. Notes A X \\<in> set evs}\n  =\n  knows B evs -\n   {Key (priEK B), Key (priSK B), Key (shrK B)} -\n     {X. Notes B X \\<in> set evs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A evs - {Key (priEK A), Key (priSK A), Key (shrK A)} -\n    {X. Notes A X \\<in> set evs} =\n    knows B evs - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n    {X. Notes B X \\<in> set evs}", "apply (induct_tac \"evs\", induct_tac \"A\", induct_tac \"B\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xaa.\n       knows (Friend xa) [] -\n       {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n        Key (shrK (Friend xa))} -\n       {X. Notes (Friend xa) X \\<in> set []} =\n       knows (Friend xaa) [] -\n       {Key (priEK (Friend xaa)), Key (priSK (Friend xaa)),\n        Key (shrK (Friend xaa))} -\n       {X. Notes (Friend xaa) X \\<in> set []}\n 2. \\<And>a list.\n       knows A list - {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set list} =\n       knows B list - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set list} \\<Longrightarrow>\n       knows A (a # list) - {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set (a # list)} =\n       knows B (a # list) - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set (a # list)}", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       knows A list - {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set list} =\n       knows B list - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set list} \\<Longrightarrow>\n       knows A (a # list) - {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set (a # list)} =\n       knows B (a # list) - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set (a # list)}", "apply (induct_tac \"a\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a list x1 x2 x3.\n       knows A list - {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set list} =\n       knows B list - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set list} \\<Longrightarrow>\n       knows A (Says x1 x2 x3 # list) -\n       {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set (Says x1 x2 x3 # list)} =\n       knows B (Says x1 x2 x3 # list) -\n       {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set (Says x1 x2 x3 # list)}\n 2. \\<And>a list x1 x2.\n       knows A list - {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set list} =\n       knows B list - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set list} \\<Longrightarrow>\n       knows A (Gets x1 x2 # list) -\n       {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set (Gets x1 x2 # list)} =\n       knows B (Gets x1 x2 # list) -\n       {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set (Gets x1 x2 # list)}\n 3. \\<And>a list x1 x2.\n       knows A list - {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set list} =\n       knows B list - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set list} \\<Longrightarrow>\n       knows A (Notes x1 x2 # list) -\n       {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set (Notes x1 x2 # list)} =\n       knows B (Notes x1 x2 # list) -\n       {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set (Notes x1 x2 # list)}", "(*Gets case solves because this event doesn't touch any agent knowledge*)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a list x1 x2 x3.\n       knows A list - {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set list} =\n       knows B list - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set list} \\<Longrightarrow>\n       knows A (Says x1 x2 x3 # list) -\n       {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set (Says x1 x2 x3 # list)} =\n       knows B (Says x1 x2 x3 # list) -\n       {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set (Says x1 x2 x3 # list)}\n 2. \\<And>a list x1 x2.\n       knows A list - {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set list} =\n       knows B list - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set list} \\<Longrightarrow>\n       knows A (Gets x1 x2 # list) -\n       {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set (Gets x1 x2 # list)} =\n       knows B (Gets x1 x2 # list) -\n       {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set (Gets x1 x2 # list)}\n 3. \\<And>a list x1 x2.\n       knows A list - {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set list} =\n       knows B list - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set list} \\<Longrightarrow>\n       knows A (Notes x1 x2 # list) -\n       {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set (Notes x1 x2 # list)} =\n       knows B (Notes x1 x2 # list) -\n       {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set (Notes x1 x2 # list)}", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list x3.\n       knows A list - {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set list} =\n       knows B list - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set list} \\<Longrightarrow>\n       insert x3 (knows A list) -\n       {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set list} =\n       insert x3 (knows B list) -\n       {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set list}\n 2. \\<And>list x1 x2.\n       knows A list - {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set list} =\n       knows B list - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set list} \\<Longrightarrow>\n       (A = x1 \\<longrightarrow>\n        B \\<noteq> x1 \\<longrightarrow>\n        insert x2 (knows x1 list) -\n        {Key (priEK x1), Key (priSK x1), Key (shrK x1)} -\n        {X. X = x2 \\<or> Notes x1 X \\<in> set list} =\n        knows B list - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n        {X. Notes B X \\<in> set list}) \\<and>\n       (A \\<noteq> x1 \\<longrightarrow>\n        B = x1 \\<longrightarrow>\n        knows x1 list - {Key (priEK x1), Key (priSK x1), Key (shrK x1)} -\n        {X. Notes x1 X \\<in> set list} =\n        insert x2 (knows x1 list) -\n        {Key (priEK x1), Key (priSK x1), Key (shrK x1)} -\n        {X. X = x2 \\<or> Notes x1 X \\<in> set list})", "(*Says case fails because both agents extract the said message, plus\ndiscussion on lemma setdiff_diff_insert*)\n\n(*Notes case solves in case neither of the two agents is the agent of the\n  current step, because no notes are extracted and inductive premise applies;\n  it fails in the two subcases when either of them is the agent of the current\n  step, because a note would be extracted i.e. inserted in his knowledge, and\n  hence falsification by discussion on lemma setdiff_diff_insert*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list x3.\n       knows A list - {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set list} =\n       knows B list - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set list} \\<Longrightarrow>\n       insert x3 (knows A list) -\n       {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set list} =\n       insert x3 (knows B list) -\n       {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set list}\n 2. \\<And>list x1 x2.\n       knows A list - {Key (priEK A), Key (priSK A), Key (shrK A)} -\n       {X. Notes A X \\<in> set list} =\n       knows B list - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n       {X. Notes B X \\<in> set list} \\<Longrightarrow>\n       (A = x1 \\<longrightarrow>\n        B \\<noteq> x1 \\<longrightarrow>\n        insert x2 (knows x1 list) -\n        {Key (priEK x1), Key (priSK x1), Key (shrK x1)} -\n        {X. X = x2 \\<or> Notes x1 X \\<in> set list} =\n        knows B list - {Key (priEK B), Key (priSK B), Key (shrK B)} -\n        {X. Notes B X \\<in> set list}) \\<and>\n       (A \\<noteq> x1 \\<longrightarrow>\n        B = x1 \\<longrightarrow>\n        knows x1 list - {Key (priEK x1), Key (priSK x1), Key (shrK x1)} -\n        {X. Notes x1 X \\<in> set list} =\n        insert x2 (knows x1 list) -\n        {Key (priEK x1), Key (priSK x1), Key (shrK x1)} -\n        {X. X = x2 \\<or> Notes x1 X \\<in> set list})", "oops"], ["", "(*So we have clear counterexamples of why this theorem CANNOT be proved inductively. Alternative stretegy using symbolic evaluation introduces clear counterexamples such as when an agent says A's shared key: it would be in the rhs but not in the lhs!*)\n\n(* Old proof*)"], ["", "lemma knowledge_equiv_eq_old:\n \"knows A evs  \\<union>  \n   {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union> \n     {X. Notes B X \\<in> set evs} \n  = \n  knows B evs \\<union> \n   {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union> \n     {X. Notes A X \\<in> set evs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A evs \\<union>\n    {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n    {X. Notes B X \\<in> set evs} =\n    knows B evs \\<union>\n    {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n    {X. Notes A X \\<in> set evs}", "apply (induct_tac \"evs\", induct_tac \"A\", induct_tac \"B\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xaa.\n       knows (Friend xa) [] \\<union>\n       {Key (priEK (Friend xaa)), Key (priSK (Friend xaa)),\n        Key (shrK (Friend xaa))} \\<union>\n       {X. Notes (Friend xaa) X \\<in> set []} =\n       knows (Friend xaa) [] \\<union>\n       {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n        Key (shrK (Friend xa))} \\<union>\n       {X. Notes (Friend xa) X \\<in> set []}\n 2. \\<And>a list.\n       knows A list \\<union>\n       {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n       {X. Notes B X \\<in> set list} =\n       knows B list \\<union>\n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n       {X. Notes A X \\<in> set list} \\<Longrightarrow>\n       knows A (a # list) \\<union>\n       {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n       {X. Notes B X \\<in> set (a # list)} =\n       knows B (a # list) \\<union>\n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n       {X. Notes A X \\<in> set (a # list)}", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       knows A list \\<union>\n       {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n       {X. Notes B X \\<in> set list} =\n       knows B list \\<union>\n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n       {X. Notes A X \\<in> set list} \\<Longrightarrow>\n       knows A (a # list) \\<union>\n       {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n       {X. Notes B X \\<in> set (a # list)} =\n       knows B (a # list) \\<union>\n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n       {X. Notes A X \\<in> set (a # list)}", "apply (induct_tac \"a\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a list x1 x2 x3.\n       knows A list \\<union>\n       {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n       {X. Notes B X \\<in> set list} =\n       knows B list \\<union>\n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n       {X. Notes A X \\<in> set list} \\<Longrightarrow>\n       knows A (Says x1 x2 x3 # list) \\<union>\n       {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n       {X. Notes B X \\<in> set (Says x1 x2 x3 # list)} =\n       knows B (Says x1 x2 x3 # list) \\<union>\n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n       {X. Notes A X \\<in> set (Says x1 x2 x3 # list)}\n 2. \\<And>a list x1 x2.\n       knows A list \\<union>\n       {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n       {X. Notes B X \\<in> set list} =\n       knows B list \\<union>\n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n       {X. Notes A X \\<in> set list} \\<Longrightarrow>\n       knows A (Gets x1 x2 # list) \\<union>\n       {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n       {X. Notes B X \\<in> set (Gets x1 x2 # list)} =\n       knows B (Gets x1 x2 # list) \\<union>\n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n       {X. Notes A X \\<in> set (Gets x1 x2 # list)}\n 3. \\<And>a list x1 x2.\n       knows A list \\<union>\n       {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n       {X. Notes B X \\<in> set list} =\n       knows B list \\<union>\n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n       {X. Notes A X \\<in> set list} \\<Longrightarrow>\n       knows A (Notes x1 x2 # list) \\<union>\n       {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n       {X. Notes B X \\<in> set (Notes x1 x2 # list)} =\n       knows B (Notes x1 x2 # list) \\<union>\n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n       {X. Notes A X \\<in> set (Notes x1 x2 # list)}", "txt\\<open>Gets case solves because this event doesn't touch any agent knowledge\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a list x1 x2 x3.\n       knows A list \\<union>\n       {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n       {X. Notes B X \\<in> set list} =\n       knows B list \\<union>\n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n       {X. Notes A X \\<in> set list} \\<Longrightarrow>\n       knows A (Says x1 x2 x3 # list) \\<union>\n       {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n       {X. Notes B X \\<in> set (Says x1 x2 x3 # list)} =\n       knows B (Says x1 x2 x3 # list) \\<union>\n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n       {X. Notes A X \\<in> set (Says x1 x2 x3 # list)}\n 2. \\<And>a list x1 x2.\n       knows A list \\<union>\n       {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n       {X. Notes B X \\<in> set list} =\n       knows B list \\<union>\n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n       {X. Notes A X \\<in> set list} \\<Longrightarrow>\n       knows A (Gets x1 x2 # list) \\<union>\n       {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n       {X. Notes B X \\<in> set (Gets x1 x2 # list)} =\n       knows B (Gets x1 x2 # list) \\<union>\n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n       {X. Notes A X \\<in> set (Gets x1 x2 # list)}\n 3. \\<And>a list x1 x2.\n       knows A list \\<union>\n       {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n       {X. Notes B X \\<in> set list} =\n       knows B list \\<union>\n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n       {X. Notes A X \\<in> set list} \\<Longrightarrow>\n       knows A (Notes x1 x2 # list) \\<union>\n       {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n       {X. Notes B X \\<in> set (Notes x1 x2 # list)} =\n       knows B (Notes x1 x2 # list) \\<union>\n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n       {X. Notes A X \\<in> set (Notes x1 x2 # list)}", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list x3.\n       insert (Key (priEK B))\n        (insert (Key (priSK B))\n          (insert (Key (shrK B))\n            (knows A list \\<union> {X. Notes B X \\<in> set list}))) =\n       insert (Key (priEK A))\n        (insert (Key (priSK A))\n          (insert (Key (shrK A))\n            (knows B list \\<union>\n             {X. Notes A X \\<in> set list}))) \\<Longrightarrow>\n       insert (Key (priEK B))\n        (insert (Key (priSK B))\n          (insert (Key (shrK B))\n            (insert x3\n              (knows A list \\<union> {X. Notes B X \\<in> set list})))) =\n       insert (Key (priEK A))\n        (insert (Key (priSK A))\n          (insert (Key (shrK A))\n            (insert x3\n              (knows B list \\<union> {X. Notes A X \\<in> set list}))))\n 2. \\<And>list x1 x2.\n       insert (Key (priEK B))\n        (insert (Key (priSK B))\n          (insert (Key (shrK B))\n            (knows A list \\<union> {X. Notes B X \\<in> set list}))) =\n       insert (Key (priEK A))\n        (insert (Key (priSK A))\n          (insert (Key (shrK A))\n            (knows B list \\<union>\n             {X. Notes A X \\<in> set list}))) \\<Longrightarrow>\n       (A = x1 \\<longrightarrow>\n        B \\<noteq> x1 \\<longrightarrow>\n        insert (Key (priEK B))\n         (insert (Key (priSK B))\n           (insert (Key (shrK B))\n             (insert x2\n               (knows x1 list \\<union> {X. Notes B X \\<in> set list})))) =\n        insert (Key (priEK x1))\n         (insert (Key (priSK x1))\n           (insert (Key (shrK x1))\n             (knows B list \\<union>\n              {X. X = x2 \\<or> Notes x1 X \\<in> set list})))) \\<and>\n       (A \\<noteq> x1 \\<longrightarrow>\n        B = x1 \\<longrightarrow>\n        insert (Key (priEK x1))\n         (insert (Key (priSK x1))\n           (insert (Key (shrK x1))\n             (knows A list \\<union>\n              {X. X = x2 \\<or> Notes x1 X \\<in> set list}))) =\n        insert (Key (priEK A))\n         (insert (Key (priSK A))\n           (insert (Key (shrK A))\n             (insert x2\n               (knows x1 list \\<union> {X. Notes A X \\<in> set list})))))", "apply safe"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>list x3 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        Key (priEK B) \\<noteq> x3; Key (priEK B) \\<notin> knows B list;\n        Notes A (Key (priEK B)) \\<notin> set list; priEK B \\<noteq> priEK A;\n        priEK B \\<noteq> priSK A\\<rbrakk>\n       \\<Longrightarrow> priEK B = shrK A\n 2. \\<And>list x3 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        Key (priSK B) \\<noteq> x3; Key (priSK B) \\<notin> knows B list;\n        Notes A (Key (priSK B)) \\<notin> set list; priSK B \\<noteq> priEK A;\n        priSK B \\<noteq> priSK A\\<rbrakk>\n       \\<Longrightarrow> priSK B = shrK A\n 3. \\<And>list x3 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        x \\<noteq> Key (priEK A); x \\<noteq> Key (priSK A);\n        x \\<noteq> Key (shrK A); x \\<noteq> x3; x \\<notin> knows B list;\n        x \\<in> knows A list\\<rbrakk>\n       \\<Longrightarrow> Notes A x \\<in> set list\n 4. \\<And>list x3 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        x \\<noteq> Key (priEK A); x \\<noteq> Key (priSK A);\n        x \\<noteq> Key (shrK A); x \\<noteq> x3; x \\<notin> knows B list;\n        Notes B x \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Notes A x \\<in> set list\n 5. \\<And>list x3 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        Key (priEK A) \\<noteq> x3; Key (priEK A) \\<notin> knows A list;\n        Notes B (Key (priEK A)) \\<notin> set list; priEK A \\<noteq> priEK B;\n        priEK A \\<noteq> priSK B\\<rbrakk>\n       \\<Longrightarrow> priEK A = shrK B\n 6. \\<And>list x3 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        Key (priSK A) \\<noteq> x3; Key (priSK A) \\<notin> knows A list;\n        Notes B (Key (priSK A)) \\<notin> set list; priSK A \\<noteq> priEK B;\n        priSK A \\<noteq> priSK B\\<rbrakk>\n       \\<Longrightarrow> priSK A = shrK B\n 7. \\<And>list x3 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        x \\<noteq> Key (priEK B); x \\<noteq> Key (priSK B);\n        x \\<noteq> Key (shrK B); x \\<noteq> x3; x \\<notin> knows A list;\n        x \\<in> knows B list\\<rbrakk>\n       \\<Longrightarrow> Notes B x \\<in> set list\n 8. \\<And>list x3 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        x \\<noteq> Key (priEK B); x \\<noteq> Key (priSK B);\n        x \\<noteq> Key (shrK B); x \\<noteq> x3; x \\<notin> knows A list;\n        Notes A x \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Notes B x \\<in> set list\n 9. \\<And>list x1 x2 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        B \\<noteq> A; Key (priEK B) \\<notin> knows B list;\n        Notes A (Key (priEK B)) \\<notin> set list;\n        Key (priEK B) \\<noteq> x2; priEK B \\<noteq> priEK A;\n        priEK B \\<noteq> priSK A\\<rbrakk>\n       \\<Longrightarrow> priEK B = shrK A\n 10. \\<And>list x1 x2 x.\n        \\<lbrakk>insert (Key (priEK B))\n                  (insert (Key (priSK B))\n                    (insert (Key (shrK B))\n                      (knows A list \\<union>\n                       {X. Notes B X \\<in> set list}))) =\n                 insert (Key (priEK A))\n                  (insert (Key (priSK A))\n                    (insert (Key (shrK A))\n                      (knows B list \\<union>\n                       {X. Notes A X \\<in> set list})));\n         B \\<noteq> A; Key (priSK B) \\<notin> knows B list;\n         Notes A (Key (priSK B)) \\<notin> set list;\n         Key (priSK B) \\<noteq> x2; priSK B \\<noteq> priEK A;\n         priSK B \\<noteq> priSK A\\<rbrakk>\n        \\<Longrightarrow> priSK B = shrK A\nA total of 24 subgoals...", "txt\\<open>speeds up subsequent blasting\\<close>"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>list x3 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        Key (priEK B) \\<noteq> x3; Key (priEK B) \\<notin> knows B list;\n        Notes A (Key (priEK B)) \\<notin> set list; priEK B \\<noteq> priEK A;\n        priEK B \\<noteq> priSK A\\<rbrakk>\n       \\<Longrightarrow> priEK B = shrK A\n 2. \\<And>list x3 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        Key (priSK B) \\<noteq> x3; Key (priSK B) \\<notin> knows B list;\n        Notes A (Key (priSK B)) \\<notin> set list; priSK B \\<noteq> priEK A;\n        priSK B \\<noteq> priSK A\\<rbrakk>\n       \\<Longrightarrow> priSK B = shrK A\n 3. \\<And>list x3 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        x \\<noteq> Key (priEK A); x \\<noteq> Key (priSK A);\n        x \\<noteq> Key (shrK A); x \\<noteq> x3; x \\<notin> knows B list;\n        x \\<in> knows A list\\<rbrakk>\n       \\<Longrightarrow> Notes A x \\<in> set list\n 4. \\<And>list x3 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        x \\<noteq> Key (priEK A); x \\<noteq> Key (priSK A);\n        x \\<noteq> Key (shrK A); x \\<noteq> x3; x \\<notin> knows B list;\n        Notes B x \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Notes A x \\<in> set list\n 5. \\<And>list x3 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        Key (priEK A) \\<noteq> x3; Key (priEK A) \\<notin> knows A list;\n        Notes B (Key (priEK A)) \\<notin> set list; priEK A \\<noteq> priEK B;\n        priEK A \\<noteq> priSK B\\<rbrakk>\n       \\<Longrightarrow> priEK A = shrK B\n 6. \\<And>list x3 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        Key (priSK A) \\<noteq> x3; Key (priSK A) \\<notin> knows A list;\n        Notes B (Key (priSK A)) \\<notin> set list; priSK A \\<noteq> priEK B;\n        priSK A \\<noteq> priSK B\\<rbrakk>\n       \\<Longrightarrow> priSK A = shrK B\n 7. \\<And>list x3 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        x \\<noteq> Key (priEK B); x \\<noteq> Key (priSK B);\n        x \\<noteq> Key (shrK B); x \\<noteq> x3; x \\<notin> knows A list;\n        x \\<in> knows B list\\<rbrakk>\n       \\<Longrightarrow> Notes B x \\<in> set list\n 8. \\<And>list x3 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        x \\<noteq> Key (priEK B); x \\<noteq> Key (priSK B);\n        x \\<noteq> Key (shrK B); x \\<noteq> x3; x \\<notin> knows A list;\n        Notes A x \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Notes B x \\<in> set list\n 9. \\<And>list x1 x2 x.\n       \\<lbrakk>insert (Key (priEK B))\n                 (insert (Key (priSK B))\n                   (insert (Key (shrK B))\n                     (knows A list \\<union>\n                      {X. Notes B X \\<in> set list}))) =\n                insert (Key (priEK A))\n                 (insert (Key (priSK A))\n                   (insert (Key (shrK A))\n                     (knows B list \\<union>\n                      {X. Notes A X \\<in> set list})));\n        B \\<noteq> A; Key (priEK B) \\<notin> knows B list;\n        Notes A (Key (priEK B)) \\<notin> set list;\n        Key (priEK B) \\<noteq> x2; priEK B \\<noteq> priEK A;\n        priEK B \\<noteq> priSK A\\<rbrakk>\n       \\<Longrightarrow> priEK B = shrK A\n 10. \\<And>list x1 x2 x.\n        \\<lbrakk>insert (Key (priEK B))\n                  (insert (Key (priSK B))\n                    (insert (Key (shrK B))\n                      (knows A list \\<union>\n                       {X. Notes B X \\<in> set list}))) =\n                 insert (Key (priEK A))\n                  (insert (Key (priSK A))\n                    (insert (Key (shrK A))\n                      (knows B list \\<union>\n                       {X. Notes A X \\<in> set list})));\n         B \\<noteq> A; Key (priSK B) \\<notin> knows B list;\n         Notes A (Key (priSK B)) \\<notin> set list;\n         Key (priSK B) \\<noteq> x2; priSK B \\<noteq> priEK A;\n         priSK B \\<noteq> priSK A\\<rbrakk>\n        \\<Longrightarrow> priSK B = shrK A\nA total of 24 subgoals...", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "txt\\<open>very very slow\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* New proof*)"], ["", "theorem knowledge_eval: \"knows A evs = \n       {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union> \n       (Key ` range pubEK) \\<union> (Key ` range pubSK) \\<union>\n       {X. \\<exists> S R. Says S R X \\<in> set evs} \\<union>\n       {X. Notes A X \\<in> set evs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A evs =\n    {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n    Key ` range pubK \\<union>\n    Key ` range pubSK \\<union>\n    {X. \\<exists>S R. Says S R X \\<in> set evs} \\<union>\n    {X. Notes A X \\<in> set evs}", "apply (induct_tac \"A\", induct_tac \"evs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       knows (Friend xa) [] =\n       {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n        Key (shrK (Friend xa))} \\<union>\n       Key ` range pubK \\<union>\n       Key ` range pubSK \\<union>\n       {X. \\<exists>S R. Says S R X \\<in> set []} \\<union>\n       {X. Notes (Friend xa) X \\<in> set []}\n 2. \\<And>xa a list.\n       knows (Friend xa) list =\n       {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n        Key (shrK (Friend xa))} \\<union>\n       Key ` range pubK \\<union>\n       Key ` range pubSK \\<union>\n       {X. \\<exists>S R. Says S R X \\<in> set list} \\<union>\n       {X. Notes (Friend xa) X \\<in> set list} \\<Longrightarrow>\n       knows (Friend xa) (a # list) =\n       {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n        Key (shrK (Friend xa))} \\<union>\n       Key ` range pubK \\<union>\n       Key ` range pubSK \\<union>\n       {X. \\<exists>S R. Says S R X \\<in> set (a # list)} \\<union>\n       {X. Notes (Friend xa) X \\<in> set (a # list)}", "apply (induct_tac [2] \"a\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa.\n       knows (Friend xa) [] =\n       {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n        Key (shrK (Friend xa))} \\<union>\n       Key ` range pubK \\<union>\n       Key ` range pubSK \\<union>\n       {X. \\<exists>S R. Says S R X \\<in> set []} \\<union>\n       {X. Notes (Friend xa) X \\<in> set []}\n 2. \\<And>xa a list x1 x2 x3.\n       knows (Friend xa) list =\n       {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n        Key (shrK (Friend xa))} \\<union>\n       Key ` range pubK \\<union>\n       Key ` range pubSK \\<union>\n       {X. \\<exists>S R. Says S R X \\<in> set list} \\<union>\n       {X. Notes (Friend xa) X \\<in> set list} \\<Longrightarrow>\n       knows (Friend xa) (Says x1 x2 x3 # list) =\n       {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n        Key (shrK (Friend xa))} \\<union>\n       Key ` range pubK \\<union>\n       Key ` range pubSK \\<union>\n       {X. \\<exists>S R.\n              Says S R X \\<in> set (Says x1 x2 x3 # list)} \\<union>\n       {X. Notes (Friend xa) X \\<in> set (Says x1 x2 x3 # list)}\n 3. \\<And>xa a list x1 x2.\n       knows (Friend xa) list =\n       {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n        Key (shrK (Friend xa))} \\<union>\n       Key ` range pubK \\<union>\n       Key ` range pubSK \\<union>\n       {X. \\<exists>S R. Says S R X \\<in> set list} \\<union>\n       {X. Notes (Friend xa) X \\<in> set list} \\<Longrightarrow>\n       knows (Friend xa) (Gets x1 x2 # list) =\n       {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n        Key (shrK (Friend xa))} \\<union>\n       Key ` range pubK \\<union>\n       Key ` range pubSK \\<union>\n       {X. \\<exists>S R. Says S R X \\<in> set (Gets x1 x2 # list)} \\<union>\n       {X. Notes (Friend xa) X \\<in> set (Gets x1 x2 # list)}\n 4. \\<And>xa a list x1 x2.\n       knows (Friend xa) list =\n       {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n        Key (shrK (Friend xa))} \\<union>\n       Key ` range pubK \\<union>\n       Key ` range pubSK \\<union>\n       {X. \\<exists>S R. Says S R X \\<in> set list} \\<union>\n       {X. Notes (Friend xa) X \\<in> set list} \\<Longrightarrow>\n       knows (Friend xa) (Notes x1 x2 # list) =\n       {Key (priEK (Friend xa)), Key (priSK (Friend xa)),\n        Key (shrK (Friend xa))} \\<union>\n       Key ` range pubK \\<union>\n       Key ` range pubSK \\<union>\n       {X. \\<exists>S R. Says S R X \\<in> set (Notes x1 x2 # list)} \\<union>\n       {X. Notes (Friend xa) X \\<in> set (Notes x1 x2 # list)}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma knowledge_eval_setdiff:\n \"knows A evs  - \n   {Key (priEK A), Key (priSK A), Key (shrK A)} -\n     {X. Notes A X \\<in> set evs}\n  = \n       (Key ` range pubEK) \\<union> (Key ` range pubSK) \\<union>\n       {X. \\<exists> S R. Says S R X \\<in> set evs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A evs - {Key (priEK A), Key (priSK A), Key (shrK A)} -\n    {X. Notes A X \\<in> set evs} =\n    Key ` range pubK \\<union> Key ` range pubSK \\<union>\n    {X. \\<exists>S R. Says S R X \\<in> set evs}", "apply (simp only: knowledge_eval)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n    Key ` range pubK \\<union>\n    Key ` range pubSK \\<union>\n    {X. \\<exists>S R. Says S R X \\<in> set evs} \\<union>\n    {X. Notes A X \\<in> set evs} -\n    {Key (priEK A), Key (priSK A), Key (shrK A)} -\n    {X. Notes A X \\<in> set evs} =\n    Key ` range pubK \\<union> Key ` range pubSK \\<union>\n    {X. \\<exists>S R. Says S R X \\<in> set evs}", "apply auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>S R.\n       Says S R (Key (priEK A)) \\<in> set evs \\<Longrightarrow> False\n 2. \\<And>S R.\n       Says S R (Key (priSK A)) \\<in> set evs \\<Longrightarrow> False\n 3. \\<And>S R. Says S R (Key (shrK A)) \\<in> set evs \\<Longrightarrow> False\n 4. \\<And>xb. Notes A (Key (pubK xb)) \\<in> set evs \\<Longrightarrow> False\n 5. \\<And>xb. Notes A (Key (pubSK xb)) \\<in> set evs \\<Longrightarrow> False\n 6. \\<And>x S R.\n       \\<lbrakk>Notes A x \\<in> set evs; Says S R x \\<in> set evs\\<rbrakk>\n       \\<Longrightarrow> False", "oops"], ["", "(*here are clear counterexamples!*)"], ["", "theorem knowledge_equiv_eq: \"knows A evs  \\<union>  \n   {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union> \n     {X. Notes B X \\<in> set evs} \n  = \n  knows B evs \\<union> \n   {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union> \n     {X. Notes A X \\<in> set evs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A evs \\<union>\n    {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n    {X. Notes B X \\<in> set evs} =\n    knows B evs \\<union>\n    {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n    {X. Notes A X \\<in> set evs}", "apply (force simp only: knowledge_eval)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"knows A evs  \\<union>  \n   {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union> \n     {X. Notes B X \\<in> set evs} -\n(  {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union> \n     {X. Notes B X \\<in> set evs} ) = knows A evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knows A evs \\<union>\n    {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n    {X. Notes B X \\<in> set evs} -\n    ({Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n     {X. Notes B X \\<in> set evs}) =\n    knows A evs", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. Key (priEK B) \\<in> knows A evs \\<Longrightarrow> False\n 2. Key (priSK B) \\<in> knows A evs \\<Longrightarrow> False\n 3. Key (shrK B) \\<in> knows A evs \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>x \\<in> knows A evs; Notes B x \\<in> set evs\\<rbrakk>\n       \\<Longrightarrow> False", "oops"], ["", "(*Here the prover tells you why this fails*)"], ["", "theorem parts_knowledge_equiv_eq: \"\nparts(knows A evs)  \\<union>  \n   {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union> \n     parts({X. Notes B X \\<in> set evs}) \n  = \nparts(knows B evs) \\<union> \n   {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union> \n     parts({X. Notes A X \\<in> set evs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (knows A evs) \\<union>\n    {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n    parts {X. Notes B X \\<in> set evs} =\n    parts (knows B evs) \\<union>\n    {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n    parts {X. Notes A X \\<in> set evs}", "apply (simp only: knowledge_eval parts_Un)"], ["proof (prove)\ngoal (1 subgoal):\n 1. parts {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n    parts (Key ` range pubK) \\<union>\n    parts (Key ` range pubSK) \\<union>\n    parts {X. \\<exists>S R. Says S R X \\<in> set evs} \\<union>\n    parts {X. Notes A X \\<in> set evs} \\<union>\n    {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n    parts {X. Notes B X \\<in> set evs} =\n    parts {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n    parts (Key ` range pubK) \\<union>\n    parts (Key ` range pubSK) \\<union>\n    parts {X. \\<exists>S R. Says S R X \\<in> set evs} \\<union>\n    parts {X. Notes B X \\<in> set evs} \\<union>\n    {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n    parts {X. Notes A X \\<in> set evs}", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas parts_knowledge_equiv = parts_knowledge_equiv_eq [THEN equalityD1, THEN subsetD]"], ["", "thm parts_knowledge_equiv"], ["", "theorem noprishr_parts_knowledge_equiv: \"\n\\<lbrakk> X \\<notin> {Key (priEK A), Key (priSK A), Key (shrK A)};\n  X \\<in> parts(knows A evs) \\<rbrakk>\n\\<Longrightarrow>  X \\<in> parts(knows B evs) \\<union> \n      parts({X. Notes A X \\<in> set evs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<notin> {Key (priEK A), Key (priSK A), Key (shrK A)};\n     X \\<in> parts (knows A evs)\\<rbrakk>\n    \\<Longrightarrow> X \\<in> parts (knows B evs) \\<union>\n                              parts {X. Notes A X \\<in> set evs}", "apply (force dest: UnI1 [THEN UnI1, THEN parts_knowledge_equiv])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*Protocol-dependent study*)"], ["", "lemma knowledge_equiv_eq_NS: \" \n  evs \\<in> ns_public \\<Longrightarrow>\n  knows A evs  \\<union> {Key (priEK B), Key (priSK B), Key (shrK B)}  = \n  knows B evs \\<union> {Key (priEK A), Key (priSK A), Key (shrK A)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evs \\<in> ns_public \\<Longrightarrow>\n    knows A evs \\<union> {Key (priEK B), Key (priSK B), Key (shrK B)} =\n    knows B evs \\<union> {Key (priEK A), Key (priSK A), Key (shrK A)}", "apply (force simp only: knowledge_eval NS_no_Notes)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_knowledge_equiv_eq_NS: \" \n  evs \\<in> ns_public \\<Longrightarrow>\n  parts(knows A evs) \\<union> {Key (priEK B), Key (priSK B), Key (shrK B)}  = \n  parts(knows B evs) \\<union> {Key (priEK A), Key (priSK A), Key (shrK A)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evs \\<in> ns_public \\<Longrightarrow>\n    parts (knows A evs) \\<union>\n    {Key (priEK B), Key (priSK B), Key (shrK B)} =\n    parts (knows B evs) \\<union>\n    {Key (priEK A), Key (priSK A), Key (shrK A)}", "apply (simp only: knowledge_eval NS_no_Notes parts_Un)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evs \\<in> ns_public \\<Longrightarrow>\n    parts {Key (priEK A), Key (priSK A), Key (shrK A)} \\<union>\n    parts (Key ` range pubK) \\<union>\n    parts (Key ` range pubSK) \\<union>\n    parts {X. \\<exists>S R. Says S R X \\<in> set evs} \\<union>\n    parts {X. False} \\<union>\n    {Key (priEK B), Key (priSK B), Key (shrK B)} =\n    parts {Key (priEK B), Key (priSK B), Key (shrK B)} \\<union>\n    parts (Key ` range pubK) \\<union>\n    parts (Key ` range pubSK) \\<union>\n    parts {X. \\<exists>S R. Says S R X \\<in> set evs} \\<union>\n    parts {X. False} \\<union>\n    {Key (priEK A), Key (priSK A), Key (shrK A)}", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem noprishr_parts_knowledge_equiv_NS: \" \n\\<lbrakk> X \\<notin> {Key (priEK A), Key (priSK A), Key (shrK A)};\n  X \\<in> parts(knows A evs); evs \\<in> ns_public \\<rbrakk>\n\\<Longrightarrow>  X \\<in> parts(knows B evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<notin> {Key (priEK A), Key (priSK A), Key (shrK A)};\n     X \\<in> parts (knows A evs); evs \\<in> ns_public\\<rbrakk>\n    \\<Longrightarrow> X \\<in> parts (knows B evs)", "apply (drule noprishr_parts_knowledge_equiv, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> parts (knows A evs); evs \\<in> ns_public;\n     X \\<in> parts (knows ?B evs) \\<union>\n             parts {X. Notes A X \\<in> set evs}\\<rbrakk>\n    \\<Longrightarrow> X \\<in> parts (knows B evs)", "apply (simp add: NS_no_Notes)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem Agent_not_analz_N:\n\"\\<lbrakk> Nonce N \\<notin> parts(knows A evs); evs \\<in> ns_public \\<rbrakk>\n \\<Longrightarrow> Nonce N \\<notin> analz(knows B evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Nonce N \\<notin> parts (knows A evs);\n     evs \\<in> ns_public\\<rbrakk>\n    \\<Longrightarrow> Nonce N \\<notin> analz (knows B evs)", "apply (force intro: noprishr_parts_knowledge_equiv_NS analz_into_parts)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*Conclusion in terms of analz because we are more used to it. It would have been a stronger law in terms of parts, though*)"], ["", "end"]]}