{"file_name": "/home/qj213/afp-2021-10-22/thys/Inductive_Confidentiality/GeneralAttacker/PublicGA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Inductive_Confidentiality", "problem_names": ["lemma invKey_K: \"K \\<in> symKeys \\<Longrightarrow> invKey K = K\"", "lemmas publicKey_neq_privateKey = privateKey_neq_publicKey [THEN not_sym]", "lemma publicKey_inject [iff]: \"(publicKey b A = publicKey c A') = (b=c \\<and> A=A')\"", "lemma not_symKeys_pubK [iff]: \"publicKey b A \\<notin> symKeys\"", "lemma not_symKeys_priK [iff]: \"privateKey b A \\<notin> symKeys\"", "lemma symKey_neq_priEK: \"K \\<in> symKeys \\<Longrightarrow> K \\<noteq> priEK A\"", "lemma symKeys_neq_imp_neq: \"(K \\<in> symKeys) \\<noteq> (K' \\<in> symKeys) \\<Longrightarrow> K \\<noteq> K'\"", "lemma symKeys_invKey_iff [iff]: \"(invKey K \\<in> symKeys) = (K \\<in> symKeys)\"", "lemma analz_symKeys_Decrypt:\n     \"[| Crypt K X \\<in> analz H;  K \\<in> symKeys;  Key K \\<in> analz H |]  \n      ==> X \\<in> analz H\"", "lemma invKey_image_eq [simp]: \"(invKey x \\<in> invKey`A) = (x \\<in> A)\"", "lemma publicKey_image_eq [simp]:\n     \"(publicKey b x \\<in> publicKey c ` AA) = (b=c \\<and> x \\<in> AA)\"", "lemma privateKey_notin_image_publicKey [simp]: \"privateKey b x \\<notin> publicKey c ` AA\"", "lemma privateKey_image_eq [simp]:\n     \"(privateKey b A \\<in> invKey ` publicKey c ` AS) = (b=c \\<and> A\\<in>AS)\"", "lemma publicKey_notin_image_privateKey [simp]: \"publicKey b A \\<notin> invKey ` publicKey c ` AS\"", "lemmas shrK_injective = inj_shrK [THEN inj_eq]", "lemma invKey_shrK [simp]: \"invKey (shrK A) = shrK A\"", "lemma analz_shrK_Decrypt:\n     \"[| Crypt (shrK A) X \\<in> analz H; Key(shrK A) \\<in> analz H |] ==> X \\<in> analz H\"", "lemma analz_Decrypt':\n     \"[| Crypt K X \\<in> analz H; K \\<in> symKeys; Key K \\<in> analz H |] ==> X \\<in> analz H\"", "lemma priK_neq_shrK [iff]: \"shrK A \\<noteq> privateKey b C\"", "lemmas shrK_neq_priK = priK_neq_shrK [THEN not_sym]", "lemma pubK_neq_shrK [iff]: \"shrK A \\<noteq> publicKey b C\"", "lemmas shrK_neq_pubK = pubK_neq_shrK [THEN not_sym]", "lemma priEK_noteq_shrK [simp]: \"priEK A \\<noteq> shrK B\"", "lemma publicKey_notin_image_shrK [simp]: \"publicKey b x \\<notin> shrK ` AA\"", "lemma privateKey_notin_image_shrK [simp]: \"privateKey b x \\<notin> shrK ` AA\"", "lemma shrK_notin_image_publicKey [simp]: \"shrK x \\<notin> publicKey b ` AA\"", "lemma shrK_notin_image_privateKey [simp]: \"shrK x \\<notin> invKey ` publicKey b ` AA\"", "lemma shrK_image_eq [simp]: \"(shrK x \\<in> shrK ` AA) = (x \\<in> AA)\"", "lemma used_parts_subset_parts [rule_format]:\n     \"\\<forall>X \\<in> used evs. parts {X} \\<subseteq> used evs\"", "lemma MPair_used_D: \"\\<lbrace>X,Y\\<rbrace> \\<in> used H \\<Longrightarrow> X \\<in> used H \\<and> Y \\<in> used H\"", "lemma MPair_used [elim!]:\n     \"[| \\<lbrace>X,Y\\<rbrace> \\<in> used H;\n         [| X \\<in> used H; Y \\<in> used H |] ==> P |] \n      ==> P\"", "lemma keysFor_parts_initState [simp]: \"keysFor (parts (initState C)) = {}\"", "lemma Crypt_notin_initState: \"Crypt K X \\<notin> parts (initState B)\"", "lemma Crypt_notin_used_empty [simp]: \"Crypt K X \\<notin> used []\"", "lemma shrK_in_initState [iff]: \"Key (shrK A) \\<in> initState A\"", "lemma shrK_in_knows [iff]: \"Key (shrK A) \\<in> knows A evs\"", "lemma shrK_in_used [iff]: \"Key (shrK A) \\<in> used evs\"", "lemma Key_not_used [simp]: \"Key K \\<notin> used evs \\<Longrightarrow> K \\<notin> range shrK\"", "lemma shrK_neq: \"Key K \\<notin> used evs \\<Longrightarrow> shrK B \\<noteq> K\"", "lemmas neq_shrK = shrK_neq [THEN not_sym]", "lemma not_SignatureE [elim!]: \"b \\<noteq> Signature \\<Longrightarrow> b = Encryption\"", "lemma priK_in_initState [iff]: \"Key (privateKey b A) \\<in> initState A\"", "lemma publicKey_in_initState [iff]: \"Key (publicKey b A) \\<in> initState B\"", "lemma spies_pubK [iff]: \"Key (publicKey b A) \\<in> knows B evs\"", "lemmas analz_spies_pubK = spies_pubK [THEN analz.Inj]", "lemma publicKey_into_used [iff] :\"Key (publicKey b A) \\<in> used evs\"", "lemma privateKey_into_used [iff]: \"Key (privateKey b A) \\<in> used evs\"", "lemma Crypt_analz_bad:\n     \"[| Crypt (shrK A) X \\<in> analz (knows A evs) |]  \n      ==> X \\<in> analz (knows A evs)\"", "lemma Nonce_notin_initState [iff]: \"Nonce N \\<notin> parts (initState B)\"", "lemma Nonce_notin_used_empty [simp]: \"Nonce N \\<notin> used []\"", "lemma Nonce_supply_lemma: \"\\<exists>N. \\<forall>n. N\\<le>n \\<longrightarrow> Nonce n \\<notin> used evs\"", "lemma Nonce_supply1: \"\\<exists>N. Nonce N \\<notin> used evs\"", "lemma Nonce_supply: \"Nonce (SOME N. Nonce N \\<notin> used evs) \\<notin> used evs\"", "lemma insert_Key_singleton: \"insert (Key K) H = Key ` {K} \\<union> H\"", "lemma insert_Key_image: \"insert (Key K) (Key`KK \\<union> C) = Key ` (insert K KK) \\<union> C\"", "lemma Crypt_imp_keysFor :\"[|Crypt K X \\<in> H; K \\<in> symKeys|] ==> K \\<in> keysFor H\"", "lemma analz_image_freshK_lemma:\n     \"(Key K \\<in> analz (Key`nE \\<union> H)) \\<longrightarrow> (K \\<in> nE | Key K \\<in> analz H)  \\<Longrightarrow>  \n         (Key K \\<in> analz (Key`nE \\<union> H)) = (K \\<in> nE | Key K \\<in> analz H)\"", "lemmas analz_image_freshK_simps =\n       simp_thms mem_simps \\<comment> \\<open>these two allow its use with @{text \"only:\"}\\<close>\n       disj_comms \n       image_insert [THEN sym] image_Un [THEN sym] empty_subsetI insert_subset\n       analz_insert_eq Un_upper2 [THEN analz_mono, THEN subsetD]\n       insert_Key_singleton \n       Key_not_used insert_Key_image Un_assoc [THEN sym]"], "translations": [["", "lemma invKey_K: \"K \\<in> symKeys \\<Longrightarrow> invKey K = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<in> symKeys \\<Longrightarrow> invKey K = K", "by (simp add: symKeys_def)"], ["", "subsection\\<open>Asymmetric Keys\\<close>"], ["", "datatype keymode = Signature | Encryption"], ["", "consts\n  publicKey :: \"[keymode,agent] => key\""], ["", "abbreviation\n  pubEK :: \"agent => key\" where\n  \"pubEK == publicKey Encryption\""], ["", "abbreviation\n  pubSK :: \"agent => key\" where\n  \"pubSK == publicKey Signature\""], ["", "abbreviation\n  privateKey :: \"[keymode, agent] => key\" where\n  \"privateKey b A == invKey (publicKey b A)\""], ["", "abbreviation\n  (*BEWARE!! priEK, priSK DON'T WORK with inj, range, image, etc.*)\n  priEK :: \"agent => key\" where\n  \"priEK A == privateKey Encryption A\""], ["", "abbreviation\n  priSK :: \"agent => key\" where\n  \"priSK A == privateKey Signature A\""], ["", "text\\<open>These abbreviations give backward compatibility.  They represent the\nsimple situation where the signature and encryption keys are the same.\\<close>"], ["", "abbreviation\n  pubK :: \"agent => key\" where\n  \"pubK A == pubEK A\""], ["", "abbreviation\n  priK :: \"agent => key\" where\n  \"priK A == invKey (pubEK A)\""], ["", "text\\<open>By freeness of agents, no two agents have the same key.  Since\n  @{term \"True\\<noteq>False\"}, no agent has identical signing and encryption keys\\<close>"], ["", "specification (publicKey)\n  injective_publicKey:\n    \"publicKey b A = publicKey c A' \\<Longrightarrow> b=c \\<and> A=A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>publicKey.\n       \\<forall>A A' b c.\n          publicKey b A = publicKey c A' \\<longrightarrow>\n          b = c \\<and> A = A'", "apply (rule exI [of _ \n       \"%b A. 2 * case_agent (\\<lambda>n. n + 2) A + case_keymode 0 1 b\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A A' b c.\n       2 * (case A of Friend n \\<Rightarrow> n + 2) +\n       (case b of Signature \\<Rightarrow> 0 | Encryption \\<Rightarrow> 1) =\n       2 * (case A' of Friend n \\<Rightarrow> n + 2) +\n       (case c of Signature \\<Rightarrow> 0\n        | Encryption \\<Rightarrow> 1) \\<longrightarrow>\n       b = c \\<and> A = A'", "apply (auto simp add: inj_on_def split: agent.split keymode.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa. 2 * x = Suc (2 * xa) \\<Longrightarrow> False\n 2. \\<And>x xa. Suc (2 * x) = 2 * xa \\<Longrightarrow> False", "apply presburger"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. Suc (2 * x) = 2 * xa \\<Longrightarrow> False", "apply presburger"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "axiomatization where\n  (*No private key equals any public key (essential to ensure that private\n    keys are private!) *)\n  privateKey_neq_publicKey [iff]: \"privateKey b A \\<noteq> publicKey c A'\""], ["", "lemmas publicKey_neq_privateKey = privateKey_neq_publicKey [THEN not_sym]"], ["", "declare publicKey_neq_privateKey [iff]"], ["", "subsection\\<open>Basic properties of @{term pubK} and @{term priK}\\<close>"], ["", "lemma publicKey_inject [iff]: \"(publicKey b A = publicKey c A') = (b=c \\<and> A=A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (publicKey b A = publicKey c A') = (b = c \\<and> A = A')", "by (blast dest!: injective_publicKey)"], ["", "lemma not_symKeys_pubK [iff]: \"publicKey b A \\<notin> symKeys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. publicKey b A \\<notin> symKeys", "by (simp add: symKeys_def)"], ["", "lemma not_symKeys_priK [iff]: \"privateKey b A \\<notin> symKeys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. privateKey b A \\<notin> symKeys", "by (simp add: symKeys_def)"], ["", "lemma symKey_neq_priEK: \"K \\<in> symKeys \\<Longrightarrow> K \\<noteq> priEK A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<in> symKeys \\<Longrightarrow> K \\<noteq> priEK A", "by auto"], ["", "lemma symKeys_neq_imp_neq: \"(K \\<in> symKeys) \\<noteq> (K' \\<in> symKeys) \\<Longrightarrow> K \\<noteq> K'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (K \\<in> symKeys) \\<noteq> (K' \\<in> symKeys) \\<Longrightarrow>\n    K \\<noteq> K'", "by blast"], ["", "lemma symKeys_invKey_iff [iff]: \"(invKey K \\<in> symKeys) = (K \\<in> symKeys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invKey K \\<in> symKeys) = (K \\<in> symKeys)", "by (unfold symKeys_def, auto)"], ["", "lemma analz_symKeys_Decrypt:\n     \"[| Crypt K X \\<in> analz H;  K \\<in> symKeys;  Key K \\<in> analz H |]  \n      ==> X \\<in> analz H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Crypt K X \\<in> analz H; K \\<in> symKeys;\n     Key K \\<in> analz H\\<rbrakk>\n    \\<Longrightarrow> X \\<in> analz H", "by (auto simp add: symKeys_def)"], ["", "subsection\\<open>\"Image\" equations that hold for injective functions\\<close>"], ["", "lemma invKey_image_eq [simp]: \"(invKey x \\<in> invKey`A) = (x \\<in> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invKey x \\<in> invKey ` A) = (x \\<in> A)", "by auto"], ["", "(*holds because invKey is injective*)"], ["", "lemma publicKey_image_eq [simp]:\n     \"(publicKey b x \\<in> publicKey c ` AA) = (b=c \\<and> x \\<in> AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (publicKey b x \\<in> publicKey c ` AA) = (b = c \\<and> x \\<in> AA)", "by auto"], ["", "lemma privateKey_notin_image_publicKey [simp]: \"privateKey b x \\<notin> publicKey c ` AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. privateKey b x \\<notin> publicKey c ` AA", "by auto"], ["", "lemma privateKey_image_eq [simp]:\n     \"(privateKey b A \\<in> invKey ` publicKey c ` AS) = (b=c \\<and> A\\<in>AS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (privateKey b A \\<in> invKey ` publicKey c ` AS) =\n    (b = c \\<and> A \\<in> AS)", "by auto"], ["", "lemma publicKey_notin_image_privateKey [simp]: \"publicKey b A \\<notin> invKey ` publicKey c ` AS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. publicKey b A \\<notin> invKey ` publicKey c ` AS", "by auto"], ["", "subsection\\<open>Symmetric Keys\\<close>"], ["", "text\\<open>For some protocols, it is convenient to equip agents with symmetric as\nwell as asymmetric keys.  The theory \\<open>Shared\\<close> assumes that all keys\nare symmetric.\\<close>"], ["", "consts\n  shrK    :: \"agent => key\"    \\<comment> \\<open>long-term shared keys\\<close>"], ["", "specification (shrK)\n  inj_shrK: \"inj shrK\"\n  \\<comment> \\<open>No two agents have the same long-term key\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>shrK. inj shrK", "apply (rule exI [of _ \"case_agent (\\<lambda>n. n + 2)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (case_agent (\\<lambda>n. n + 2))", "apply (simp add: inj_on_def split: agent.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "axiomatization where\n  sym_shrK [iff]: \"shrK X \\<in> symKeys\" \\<comment> \\<open>All shared keys are symmetric\\<close>"], ["", "text\\<open>Injectiveness: Agents' long-term keys are distinct.\\<close>"], ["", "lemmas shrK_injective = inj_shrK [THEN inj_eq]"], ["", "declare shrK_injective [iff]"], ["", "lemma invKey_shrK [simp]: \"invKey (shrK A) = shrK A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invKey (shrK A) = shrK A", "by (simp add: invKey_K)"], ["", "lemma analz_shrK_Decrypt:\n     \"[| Crypt (shrK A) X \\<in> analz H; Key(shrK A) \\<in> analz H |] ==> X \\<in> analz H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Crypt (shrK A) X \\<in> analz H;\n     Key (shrK A) \\<in> analz H\\<rbrakk>\n    \\<Longrightarrow> X \\<in> analz H", "by auto"], ["", "lemma analz_Decrypt':\n     \"[| Crypt K X \\<in> analz H; K \\<in> symKeys; Key K \\<in> analz H |] ==> X \\<in> analz H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Crypt K X \\<in> analz H; K \\<in> symKeys;\n     Key K \\<in> analz H\\<rbrakk>\n    \\<Longrightarrow> X \\<in> analz H", "by (auto simp add: invKey_K)"], ["", "lemma priK_neq_shrK [iff]: \"shrK A \\<noteq> privateKey b C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shrK A \\<noteq> privateKey b C", "by (simp add: symKeys_neq_imp_neq)"], ["", "lemmas shrK_neq_priK = priK_neq_shrK [THEN not_sym]"], ["", "declare shrK_neq_priK [simp]"], ["", "lemma pubK_neq_shrK [iff]: \"shrK A \\<noteq> publicKey b C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shrK A \\<noteq> publicKey b C", "by (simp add: symKeys_neq_imp_neq)"], ["", "lemmas shrK_neq_pubK = pubK_neq_shrK [THEN not_sym]"], ["", "declare shrK_neq_pubK [simp]"], ["", "lemma priEK_noteq_shrK [simp]: \"priEK A \\<noteq> shrK B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. priEK A \\<noteq> shrK B", "by auto"], ["", "lemma publicKey_notin_image_shrK [simp]: \"publicKey b x \\<notin> shrK ` AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. publicKey b x \\<notin> shrK ` AA", "by auto"], ["", "lemma privateKey_notin_image_shrK [simp]: \"privateKey b x \\<notin> shrK ` AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. privateKey b x \\<notin> shrK ` AA", "by auto"], ["", "lemma shrK_notin_image_publicKey [simp]: \"shrK x \\<notin> publicKey b ` AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shrK x \\<notin> publicKey b ` AA", "by auto"], ["", "lemma shrK_notin_image_privateKey [simp]: \"shrK x \\<notin> invKey ` publicKey b ` AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shrK x \\<notin> invKey ` publicKey b ` AA", "by auto"], ["", "lemma shrK_image_eq [simp]: \"(shrK x \\<in> shrK ` AA) = (x \\<in> AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (shrK x \\<in> shrK ` AA) = (x \\<in> AA)", "by auto"], ["", "text\\<open>For some reason, moving this up can make some proofs loop!\\<close>"], ["", "declare invKey_K [simp]"], ["", "subsection\\<open>Initial States of Agents\\<close>"], ["", "overloading\n  initState \\<equiv> initState\nbegin"], ["", "primrec initState where\n\n  initState_Friend:\n    \"initState (Friend i) =    \n       {Key (priEK (Friend i)), Key (priSK (Friend i)), Key (shrK (Friend i))} \\<union> \n       (Key ` range pubEK) \\<union> (Key ` range pubSK)\""], ["", "end"], ["", "lemma used_parts_subset_parts [rule_format]:\n     \"\\<forall>X \\<in> used evs. parts {X} \\<subseteq> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>used evs. parts {X} \\<subseteq> used evs", "apply (induct evs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>X\\<in>used []. parts {X} \\<subseteq> used []\n 2. \\<And>a evs.\n       \\<forall>X\\<in>used evs.\n          parts {X} \\<subseteq> used evs \\<Longrightarrow>\n       \\<forall>X\\<in>used (a # evs). parts {X} \\<subseteq> used (a # evs)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a evs.\n       \\<forall>X\\<in>used evs.\n          parts {X} \\<subseteq> used evs \\<Longrightarrow>\n       \\<forall>X\\<in>used (a # evs). parts {X} \\<subseteq> used (a # evs)\n 2. \\<forall>X\\<in>used []. parts {X} \\<subseteq> used []", "apply (simp add: used_Cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a evs.\n       \\<forall>X\\<in>used evs.\n          parts {X} \\<subseteq> used evs \\<Longrightarrow>\n       \\<forall>X\\<in>case a of\n                      Says A B X \\<Rightarrow> parts {X} \\<union> used evs\n                      | Gets A X \\<Rightarrow> used evs\n                      | Notes A X \\<Rightarrow> parts {X} \\<union> used evs.\n          parts {X}\n          \\<subseteq> (case a of\n                       Says A B X \\<Rightarrow> parts {X} \\<union> used evs\n                       | Gets A X \\<Rightarrow> used evs\n                       | Notes A X \\<Rightarrow>\n                           parts {X} \\<union> used evs)\n 2. \\<forall>X\\<in>used []. parts {X} \\<subseteq> used []", "apply (rule ballI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a evs X.\n       \\<lbrakk>\\<forall>X\\<in>used evs. parts {X} \\<subseteq> used evs;\n        X \\<in> (case a of\n                 Says A B X \\<Rightarrow> parts {X} \\<union> used evs\n                 | Gets A X \\<Rightarrow> used evs\n                 | Notes A X \\<Rightarrow>\n                     parts {X} \\<union> used evs)\\<rbrakk>\n       \\<Longrightarrow> parts {X}\n                         \\<subseteq> (case a of\nSays A B X \\<Rightarrow> parts {X} \\<union> used evs\n| Gets A X \\<Rightarrow> used evs\n| Notes A X \\<Rightarrow> parts {X} \\<union> used evs)\n 2. \\<forall>X\\<in>used []. parts {X} \\<subseteq> used []", "apply (case_tac a, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>evs X x13 x.\n       \\<lbrakk>\\<forall>X\\<in>used evs. parts {X} \\<subseteq> used evs;\n        x \\<in> parts {X}; x \\<notin> used evs; X \\<in> parts {x13}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> parts {x13}\n 2. \\<And>evs X x32 x.\n       \\<lbrakk>\\<forall>X\\<in>used evs. parts {X} \\<subseteq> used evs;\n        x \\<in> parts {X}; x \\<notin> used evs; X \\<in> parts {x32}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> parts {x32}\n 3. \\<And>X x.\n       \\<lbrakk>X \\<in> used []; x \\<in> parts {X}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> used []", "apply (auto dest!: parts_cut)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>X \\<in> used []; x \\<in> parts (used [])\\<rbrakk>\n       \\<Longrightarrow> x \\<in> used []", "txt\\<open>Base case\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>X \\<in> used []; x \\<in> parts (used [])\\<rbrakk>\n       \\<Longrightarrow> x \\<in> used []", "apply (simp add: used_Nil)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma MPair_used_D: \"\\<lbrace>X,Y\\<rbrace> \\<in> used H \\<Longrightarrow> X \\<in> used H \\<and> Y \\<in> used H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>X, Y\\<rbrace> \\<in> used H \\<Longrightarrow>\n    X \\<in> used H \\<and> Y \\<in> used H", "by (drule used_parts_subset_parts, simp, blast)"], ["", "text\\<open>There was a similar theorem in Event.thy, so perhaps this one can\n  be moved up if proved directly by induction.\\<close>"], ["", "lemma MPair_used [elim!]:\n     \"[| \\<lbrace>X,Y\\<rbrace> \\<in> used H;\n         [| X \\<in> used H; Y \\<in> used H |] ==> P |] \n      ==> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> used H;\n     \\<lbrakk>X \\<in> used H; Y \\<in> used H\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (blast dest: MPair_used_D)"], ["", "text\\<open>Rewrites should not refer to  @{term \"initState(Friend i)\"} because\n  that expression is not in normal form.\\<close>"], ["", "lemma keysFor_parts_initState [simp]: \"keysFor (parts (initState C)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (parts (initState C)) = {}", "apply (unfold keysFor_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invKey ` {K. \\<exists>X. Crypt K X \\<in> parts (initState C)} = {}", "apply (induct_tac \"C\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       invKey `\n       {K. \\<exists>X. Crypt K X \\<in> parts (initState (Friend xa))} =\n       {}", "apply (auto intro: range_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Crypt_notin_initState: \"Crypt K X \\<notin> parts (initState B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Crypt K X \\<notin> parts (initState B)", "by (induct B, auto)"], ["", "lemma Crypt_notin_used_empty [simp]: \"Crypt K X \\<notin> used []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Crypt K X \\<notin> used []", "by (simp add: Crypt_notin_initState used_Nil)"], ["", "(*** Basic properties of shrK ***)\n\n(*Agents see their own shared keys!*)"], ["", "lemma shrK_in_initState [iff]: \"Key (shrK A) \\<in> initState A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (shrK A) \\<in> initState A", "by (induct_tac \"A\", auto)"], ["", "lemma shrK_in_knows [iff]: \"Key (shrK A) \\<in> knows A evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (shrK A) \\<in> knows A evs", "by (simp add: initState_subset_knows [THEN subsetD])"], ["", "lemma shrK_in_used [iff]: \"Key (shrK A) \\<in> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (shrK A) \\<in> used evs", "by (rule initState_into_used, blast)"], ["", "(** Fresh keys never clash with long-term shared keys **)\n\n(*Used in parts_induct_tac and analz_Fake_tac to distinguish session keys\n  from long-term shared keys*)"], ["", "lemma Key_not_used [simp]: \"Key K \\<notin> used evs \\<Longrightarrow> K \\<notin> range shrK\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key K \\<notin> used evs \\<Longrightarrow> K \\<notin> range shrK", "by blast"], ["", "lemma shrK_neq: \"Key K \\<notin> used evs \\<Longrightarrow> shrK B \\<noteq> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key K \\<notin> used evs \\<Longrightarrow> shrK B \\<noteq> K", "by blast"], ["", "lemmas neq_shrK = shrK_neq [THEN not_sym]"], ["", "declare neq_shrK [simp]"], ["", "subsection\\<open>Function @{term \"knows Spy\"}\\<close>"], ["", "lemma not_SignatureE [elim!]: \"b \\<noteq> Signature \\<Longrightarrow> b = Encryption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> Signature \\<Longrightarrow> b = Encryption", "by (cases b, auto)"], ["", "text\\<open>Agents see their own private keys!\\<close>"], ["", "lemma priK_in_initState [iff]: \"Key (privateKey b A) \\<in> initState A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (privateKey b A) \\<in> initState A", "by (cases A, auto)"], ["", "text\\<open>Agents see all public keys!\\<close>"], ["", "lemma publicKey_in_initState [iff]: \"Key (publicKey b A) \\<in> initState B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (publicKey b A) \\<in> initState B", "by (cases B, auto)"], ["", "text\\<open>All public keys are visible\\<close>"], ["", "lemma spies_pubK [iff]: \"Key (publicKey b A) \\<in> knows B evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (publicKey b A) \\<in> knows B evs", "apply (induct_tac \"evs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. Key (publicKey b A) \\<in> knows B []\n 2. \\<And>a list.\n       Key (publicKey b A) \\<in> knows B list \\<Longrightarrow>\n       Key (publicKey b A) \\<in> knows B (a # list)", "apply (auto simp add: imageI knows_Cons split: event.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas analz_spies_pubK = spies_pubK [THEN analz.Inj]"], ["", "declare analz_spies_pubK [iff]"], ["", "(*Note: there never is at this stage a lemma about what an agent cannot know*)"], ["", "lemma publicKey_into_used [iff] :\"Key (publicKey b A) \\<in> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (publicKey b A) \\<in> used evs", "apply (rule initState_into_used)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (publicKey b A) \\<in> parts (initState ?B)", "apply (rule publicKey_in_initState [THEN parts.Inj])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma privateKey_into_used [iff]: \"Key (privateKey b A) \\<in> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (privateKey b A) \\<in> used evs", "apply(rule initState_into_used)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (privateKey b A) \\<in> parts (initState ?B)", "apply(rule priK_in_initState [THEN parts.Inj])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Crypt_analz_bad:\n     \"[| Crypt (shrK A) X \\<in> analz (knows A evs) |]  \n      ==> X \\<in> analz (knows A evs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Crypt (shrK A) X \\<in> analz (knows A evs) \\<Longrightarrow>\n    X \\<in> analz (knows A evs)", "by force"], ["", "subsection\\<open>Fresh Nonces\\<close>"], ["", "lemma Nonce_notin_initState [iff]: \"Nonce N \\<notin> parts (initState B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nonce N \\<notin> parts (initState B)", "by (induct_tac \"B\", auto)"], ["", "lemma Nonce_notin_used_empty [simp]: \"Nonce N \\<notin> used []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nonce N \\<notin> used []", "by (simp add: used_Nil)"], ["", "subsection\\<open>Supply fresh nonces for possibility theorems\\<close>"], ["", "text\\<open>In any trace, there is an upper bound N on the greatest nonce in use\\<close>"], ["", "lemma Nonce_supply_lemma: \"\\<exists>N. \\<forall>n. N\\<le>n \\<longrightarrow> Nonce n \\<notin> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> used evs", "apply (induct_tac \"evs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> used []\n 2. \\<And>a list.\n       \\<exists>N.\n          \\<forall>n\\<ge>N. Nonce n \\<notin> used list \\<Longrightarrow>\n       \\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> used (a # list)", "apply (rule_tac x = 0 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>n\\<ge>0. Nonce n \\<notin> used []\n 2. \\<And>a list.\n       \\<exists>N.\n          \\<forall>n\\<ge>N. Nonce n \\<notin> used list \\<Longrightarrow>\n       \\<exists>N. \\<forall>n\\<ge>N. Nonce n \\<notin> used (a # list)", "apply (simp_all (no_asm_simp) add: used_Cons split: event.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<exists>N.\n          \\<forall>n\\<ge>N. Nonce n \\<notin> used list \\<Longrightarrow>\n       (\\<forall>x11 x12 x13.\n           a = Says x11 x12 x13 \\<longrightarrow>\n           (\\<exists>N.\n               \\<forall>n\\<ge>N.\n                  Nonce n \\<notin> parts {x13} \\<and>\n                  Nonce n \\<notin> used list)) \\<and>\n       (\\<forall>x31 x32.\n           a = Notes x31 x32 \\<longrightarrow>\n           (\\<exists>N.\n               \\<forall>n\\<ge>N.\n                  Nonce n \\<notin> parts {x32} \\<and>\n                  Nonce n \\<notin> used list))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list N x11 x12 x13.\n       \\<forall>n\\<ge>N. Nonce n \\<notin> used list \\<Longrightarrow>\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             Nonce n \\<notin> parts {x13} \\<and> Nonce n \\<notin> used list\n 2. \\<And>a list N x31 x32.\n       \\<forall>n\\<ge>N. Nonce n \\<notin> used list \\<Longrightarrow>\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             Nonce n \\<notin> parts {x32} \\<and> Nonce n \\<notin> used list", "apply (rule msg_Nonce_supply [THEN exE], blast elim!: add_leE)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Nonce_supply1: \"\\<exists>N. Nonce N \\<notin> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N. Nonce N \\<notin> used evs", "by (rule Nonce_supply_lemma [THEN exE], blast)"], ["", "lemma Nonce_supply: \"Nonce (SOME N. Nonce N \\<notin> used evs) \\<notin> used evs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nonce (SOME N. Nonce N \\<notin> used evs) \\<notin> used evs", "apply (rule Nonce_supply_lemma [THEN exE])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>n\\<ge>x. Nonce n \\<notin> used ?evs1 \\<Longrightarrow>\n       Nonce (SOME N. Nonce N \\<notin> used evs) \\<notin> used evs", "apply (rule someI, fast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Specialized Rewriting for Theorems About @{term analz} and Image\\<close>"], ["", "lemma insert_Key_singleton: \"insert (Key K) H = Key ` {K} \\<union> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Key K) H = Key ` {K} \\<union> H", "by blast"], ["", "lemma insert_Key_image: \"insert (Key K) (Key`KK \\<union> C) = Key ` (insert K KK) \\<union> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Key K) (Key ` KK \\<union> C) = Key ` insert K KK \\<union> C", "by blast"], ["", "lemma Crypt_imp_keysFor :\"[|Crypt K X \\<in> H; K \\<in> symKeys|] ==> K \\<in> keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Crypt K X \\<in> H; K \\<in> symKeys\\<rbrakk>\n    \\<Longrightarrow> K \\<in> keysFor H", "by (drule Crypt_imp_invKey_keysFor, simp)"], ["", "text\\<open>Lemma for the trivial direction of the if-and-only-if of the \nSession Key Compromise Theorem\\<close>"], ["", "lemma analz_image_freshK_lemma:\n     \"(Key K \\<in> analz (Key`nE \\<union> H)) \\<longrightarrow> (K \\<in> nE | Key K \\<in> analz H)  \\<Longrightarrow>  \n         (Key K \\<in> analz (Key`nE \\<union> H)) = (K \\<in> nE | Key K \\<in> analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key K \\<in> analz (Key ` nE \\<union> H) \\<longrightarrow>\n    K \\<in> nE \\<or> Key K \\<in> analz H \\<Longrightarrow>\n    (Key K \\<in> analz (Key ` nE \\<union> H)) =\n    (K \\<in> nE \\<or> Key K \\<in> analz H)", "by (blast intro: analz_mono [THEN [2] rev_subsetD])"], ["", "lemmas analz_image_freshK_simps =\n       simp_thms mem_simps \\<comment> \\<open>these two allow its use with @{text \"only:\"}\\<close>\n       disj_comms \n       image_insert [THEN sym] image_Un [THEN sym] empty_subsetI insert_subset\n       analz_insert_eq Un_upper2 [THEN analz_mono, THEN subsetD]\n       insert_Key_singleton \n       Key_not_used insert_Key_image Un_assoc [THEN sym]"], ["", "ML \\<open>\nstructure Public =\nstruct\n\nval analz_image_freshK_ss =\n  simpset_of (@{context}\n    delsimps [image_insert, image_Un]\n    delsimps [@{thm imp_disjL}]    (*reduces blow-up*)\n    addsimps @{thms analz_image_freshK_simps})\n\n(*Tactic for possibility theorems*)\nfun possibility_tac ctxt =\n    REPEAT (*omit used_Says so that Nonces start from different traces!*)\n    (ALLGOALS (simp_tac (ctxt delsimps [@{thm used_Says}]))\n     THEN\n     REPEAT_FIRST (eq_assume_tac ORELSE' \n                   resolve_tac ctxt [refl, conjI, @{thm Nonce_supply}]))\n\n(*For harder protocols (such as Recur) where we have to set up some\n  nonces and keys initially*)\nfun basic_possibility_tac ctxt =\n    REPEAT \n    (ALLGOALS (asm_simp_tac (ctxt setSolver safe_solver))\n     THEN\n     REPEAT_FIRST (resolve_tac ctxt [refl, conjI]))\n\nend\n\\<close>"], ["", "method_setup analz_freshK = \\<open>\n    Scan.succeed (fn ctxt =>\n     (SIMPLE_METHOD\n      (EVERY [REPEAT_FIRST (resolve_tac ctxt [allI, ballI, impI]),\n          REPEAT_FIRST (resolve_tac ctxt @{thms analz_image_freshK_lemma}),\n          ALLGOALS (asm_simp_tac (put_simpset Public.analz_image_freshK_ss ctxt))])))\\<close>\n    \"for proving the Session Key Compromise theorem\""], ["", "subsection\\<open>Specialized Methods for Possibility Theorems\\<close>"], ["", "method_setup possibility = \\<open>\n    Scan.succeed (SIMPLE_METHOD o Public.possibility_tac)\\<close>\n    \"for proving possibility theorems\""], ["", "method_setup basic_possibility = \\<open>\n    Scan.succeed (SIMPLE_METHOD o Public.basic_possibility_tac)\\<close>\n    \"for proving possibility theorems\""], ["", "end"]]}