{"file_name": "/home/qj213/afp-2021-10-22/thys/Linear_Recurrences/Linear_Recurrences_Misc.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Linear_Recurrences", "problem_names": ["lemma length_zip_with [simp]: \"length (zip_with f xs ys) = min (length xs) (length ys)\"", "lemma zip_with_altdef: \"zip_with f xs ys = map (\\<lambda>(x,y). f x y) (zip xs ys)\"", "lemma zip_with_nth [simp]:\n  \"n < length xs \\<Longrightarrow> n < length ys \\<Longrightarrow> zip_with f xs ys ! n = f (xs!n) (ys!n)\"", "lemma take_zip_with: \"take n (zip_with f xs ys) = zip_with f (take n xs) (take n ys)\"", "lemma drop_zip_with: \"drop n (zip_with f xs ys) = zip_with f (drop n xs) (drop n ys)\"", "lemma map_zip_with: \"map f (zip_with g xs ys) = zip_with (\\<lambda>x y. f (g x y)) xs ys\"", "lemma zip_with_map: \"zip_with f (map g xs) (map h ys) = zip_with (\\<lambda>x y. f (g x) (h y)) xs ys\"", "lemma zip_with_map_left: \"zip_with f (map g xs) ys = zip_with (\\<lambda>x y. f (g x) y) xs ys\"", "lemma zip_with_map_right: \"zip_with f xs (map g ys) = zip_with (\\<lambda>x y. f x (g y)) xs ys\"", "lemma zip_with_swap: \"zip_with (\\<lambda>x y. f y x) xs ys = zip_with f ys xs\"", "lemma set_zip_with: \"set (zip_with f xs ys) = (\\<lambda>(x,y). f x y) ` set (zip xs ys)\"", "lemma zip_with_Pair: \"zip_with Pair (xs :: 'a list) (ys :: 'b list) = zip xs ys\"", "lemma zip_with_altdef': \n    \"zip_with f xs ys = [f (xs!i) (ys!i). i \\<leftarrow> [0..<min (length xs) (length ys)]]\"", "lemma zip_altdef: \"zip xs ys = [(xs!i, ys!i). i \\<leftarrow> [0..<min (length xs) (length ys)]]\"", "lemma card_poly_roots_bound:\n  fixes p :: \"'a::{comm_ring_1,ring_no_zero_divisors} poly\"\n  assumes \"p \\<noteq> 0\"\n  shows   \"card {x. poly p x = 0} \\<le> degree p\"", "lemma poly_eqI_degree:\n  fixes p q :: \"'a :: {comm_ring_1, ring_no_zero_divisors} poly\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> poly p x = poly q x\"\n  assumes \"card A > degree p\" \"card A > degree q\"\n  shows   \"p = q\"", "lemma poly_root_order_induct [case_names 0 no_roots root]:\n  fixes p :: \"'a :: idom poly\"\n  assumes \"P 0\" \"\\<And>p. (\\<And>x. poly p x \\<noteq> 0) \\<Longrightarrow> P p\" \n          \"\\<And>p x n. n > 0 \\<Longrightarrow> poly p x \\<noteq> 0 \\<Longrightarrow> P p \\<Longrightarrow> P ([:-x, 1:] ^ n * p)\"\n  shows   \"P p\"", "lemma complex_poly_decompose:\n  \"smult (lead_coeff p) (\\<Prod>z|poly p z = 0. [:-z, 1:] ^ order z p) = (p :: complex poly)\"", "lemma normalize_field: \n  \"normalize (x :: 'a :: {normalization_semidom,field}) = (if x = 0 then 0 else 1)\"", "lemma unit_factor_field [simp]:\n  \"unit_factor (x :: 'a :: {normalization_semidom,field}) = x\"", "lemma coprime_linear_poly: \n  fixes c :: \"'a :: field_gcd\"\n  assumes \"c \\<noteq> c'\"\n  shows   \"coprime [:c,1:] [:c',1:]\"", "lemma coprime_linear_poly': \n  fixes c :: \"'a :: field_gcd\"\n  assumes \"c \\<noteq> c'\" \"c \\<noteq> 0\" \"c' \\<noteq> 0\"\n  shows   \"coprime [:1,c:] [:1,c':]\""], "translations": [["", "lemma length_zip_with [simp]: \"length (zip_with f xs ys) = min (length xs) (length ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (zip_with f xs ys) = min (length xs) (length ys)", "by (induction f xs ys rule: zip_with.induct) simp_all"], ["", "lemma zip_with_altdef: \"zip_with f xs ys = map (\\<lambda>(x,y). f x y) (zip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip_with f xs ys = map2 f xs ys", "by (induction f xs ys rule: zip_with.induct) simp_all"], ["", "lemma zip_with_nth [simp]:\n  \"n < length xs \\<Longrightarrow> n < length ys \\<Longrightarrow> zip_with f xs ys ! n = f (xs!n) (ys!n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length xs; n < length ys\\<rbrakk>\n    \\<Longrightarrow> zip_with f xs ys ! n = f (xs ! n) (ys ! n)", "by (simp add: zip_with_altdef)"], ["", "lemma take_zip_with: \"take n (zip_with f xs ys) = zip_with f (take n xs) (take n ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n (zip_with f xs ys) = zip_with f (take n xs) (take n ys)", "proof (induction f xs ys arbitrary: n rule: zip_with.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f x xs y ys n.\n       (\\<And>n.\n           take n (zip_with f xs ys) =\n           zip_with f (take n xs) (take n ys)) \\<Longrightarrow>\n       take n (zip_with f (x # xs) (y # ys)) =\n       zip_with f (take n (x # xs)) (take n (y # ys))\n 2. \\<And>f uv_ n.\n       take n (zip_with f [] uv_) = zip_with f (take n []) (take n uv_)\n 3. \\<And>f uu_ n.\n       take n (zip_with f uu_ []) = zip_with f (take n uu_) (take n [])", "case (1 f x xs y ys n)"], ["proof (state)\nthis:\n  take ?n (zip_with f xs ys) = zip_with f (take ?n xs) (take ?n ys)\n\ngoal (3 subgoals):\n 1. \\<And>f x xs y ys n.\n       (\\<And>n.\n           take n (zip_with f xs ys) =\n           zip_with f (take n xs) (take n ys)) \\<Longrightarrow>\n       take n (zip_with f (x # xs) (y # ys)) =\n       zip_with f (take n (x # xs)) (take n (y # ys))\n 2. \\<And>f uv_ n.\n       take n (zip_with f [] uv_) = zip_with f (take n []) (take n uv_)\n 3. \\<And>f uu_ n.\n       take n (zip_with f uu_ []) = zip_with f (take n uu_) (take n [])", "thus ?case"], ["proof (prove)\nusing this:\n  take ?n (zip_with f xs ys) = zip_with f (take ?n xs) (take ?n ys)\n\ngoal (1 subgoal):\n 1. take n (zip_with f (x # xs) (y # ys)) =\n    zip_with f (take n (x # xs)) (take n (y # ys))", "by (cases n) simp_all"], ["proof (state)\nthis:\n  take n (zip_with f (x # xs) (y # ys)) =\n  zip_with f (take n (x # xs)) (take n (y # ys))\n\ngoal (2 subgoals):\n 1. \\<And>f uv_ n.\n       take n (zip_with f [] uv_) = zip_with f (take n []) (take n uv_)\n 2. \\<And>f uu_ n.\n       take n (zip_with f uu_ []) = zip_with f (take n uu_) (take n [])", "qed simp_all"], ["", "lemma drop_zip_with: \"drop n (zip_with f xs ys) = zip_with f (drop n xs) (drop n ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop n (zip_with f xs ys) = zip_with f (drop n xs) (drop n ys)", "proof (induction f xs ys arbitrary: n rule: zip_with.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f x xs y ys n.\n       (\\<And>n.\n           drop n (zip_with f xs ys) =\n           zip_with f (drop n xs) (drop n ys)) \\<Longrightarrow>\n       drop n (zip_with f (x # xs) (y # ys)) =\n       zip_with f (drop n (x # xs)) (drop n (y # ys))\n 2. \\<And>f uv_ n.\n       drop n (zip_with f [] uv_) = zip_with f (drop n []) (drop n uv_)\n 3. \\<And>f uu_ n.\n       drop n (zip_with f uu_ []) = zip_with f (drop n uu_) (drop n [])", "case (1 f x xs y ys n)"], ["proof (state)\nthis:\n  drop ?n (zip_with f xs ys) = zip_with f (drop ?n xs) (drop ?n ys)\n\ngoal (3 subgoals):\n 1. \\<And>f x xs y ys n.\n       (\\<And>n.\n           drop n (zip_with f xs ys) =\n           zip_with f (drop n xs) (drop n ys)) \\<Longrightarrow>\n       drop n (zip_with f (x # xs) (y # ys)) =\n       zip_with f (drop n (x # xs)) (drop n (y # ys))\n 2. \\<And>f uv_ n.\n       drop n (zip_with f [] uv_) = zip_with f (drop n []) (drop n uv_)\n 3. \\<And>f uu_ n.\n       drop n (zip_with f uu_ []) = zip_with f (drop n uu_) (drop n [])", "thus ?case"], ["proof (prove)\nusing this:\n  drop ?n (zip_with f xs ys) = zip_with f (drop ?n xs) (drop ?n ys)\n\ngoal (1 subgoal):\n 1. drop n (zip_with f (x # xs) (y # ys)) =\n    zip_with f (drop n (x # xs)) (drop n (y # ys))", "by (cases n) simp_all"], ["proof (state)\nthis:\n  drop n (zip_with f (x # xs) (y # ys)) =\n  zip_with f (drop n (x # xs)) (drop n (y # ys))\n\ngoal (2 subgoals):\n 1. \\<And>f uv_ n.\n       drop n (zip_with f [] uv_) = zip_with f (drop n []) (drop n uv_)\n 2. \\<And>f uu_ n.\n       drop n (zip_with f uu_ []) = zip_with f (drop n uu_) (drop n [])", "qed simp_all"], ["", "lemma map_zip_with: \"map f (zip_with g xs ys) = zip_with (\\<lambda>x y. f (g x y)) xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (zip_with g xs ys) = zip_with (\\<lambda>x y. f (g x y)) xs ys", "by (induction g xs ys rule: zip_with.induct) simp_all"], ["", "lemma zip_with_map: \"zip_with f (map g xs) (map h ys) = zip_with (\\<lambda>x y. f (g x) (h y)) xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip_with f (map g xs) (map h ys) =\n    zip_with (\\<lambda>x y. f (g x) (h y)) xs ys", "by (induction \"\\<lambda>x y. f (g x) (h y)\" xs ys rule: zip_with.induct) simp_all"], ["", "lemma zip_with_map_left: \"zip_with f (map g xs) ys = zip_with (\\<lambda>x y. f (g x) y) xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip_with f (map g xs) ys = zip_with (\\<lambda>x. f (g x)) xs ys", "using zip_with_map[of f g xs \"\\<lambda>x. x\" ys]"], ["proof (prove)\nusing this:\n  zip_with f (map g xs) (map (\\<lambda>x. x) ys) =\n  zip_with (\\<lambda>x. f (g x)) xs ys\n\ngoal (1 subgoal):\n 1. zip_with f (map g xs) ys = zip_with (\\<lambda>x. f (g x)) xs ys", "by simp"], ["", "lemma zip_with_map_right: \"zip_with f xs (map g ys) = zip_with (\\<lambda>x y. f x (g y)) xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip_with f xs (map g ys) = zip_with (\\<lambda>x y. f x (g y)) xs ys", "using zip_with_map[of f \"\\<lambda>x. x\" xs g ys]"], ["proof (prove)\nusing this:\n  zip_with f (map (\\<lambda>x. x) xs) (map g ys) =\n  zip_with (\\<lambda>x y. f x (g y)) xs ys\n\ngoal (1 subgoal):\n 1. zip_with f xs (map g ys) = zip_with (\\<lambda>x y. f x (g y)) xs ys", "by simp"], ["", "lemma zip_with_swap: \"zip_with (\\<lambda>x y. f y x) xs ys = zip_with f ys xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip_with (\\<lambda>x y. f y x) xs ys = zip_with f ys xs", "by (induction f ys xs rule: zip_with.induct) simp_all"], ["", "lemma set_zip_with: \"set (zip_with f xs ys) = (\\<lambda>(x,y). f x y) ` set (zip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (zip_with f xs ys) = (\\<lambda>(x, y). f x y) ` set (zip xs ys)", "by (induction f xs ys rule: zip_with.induct) simp_all"], ["", "lemma zip_with_Pair: \"zip_with Pair (xs :: 'a list) (ys :: 'b list) = zip xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip_with Pair xs ys = zip xs ys", "by (induction \"Pair :: 'a \\<Rightarrow> 'b \\<Rightarrow> _\" xs ys rule: zip_with.induct) simp_all"], ["", "lemma zip_with_altdef': \n    \"zip_with f xs ys = [f (xs!i) (ys!i). i \\<leftarrow> [0..<min (length xs) (length ys)]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip_with f xs ys =\n    map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<min (length xs) (length ys)]", "by (induction f xs ys rule: zip_with.induct) (simp_all add: map_upt_Suc del: upt_Suc)"], ["", "lemma zip_altdef: \"zip xs ys = [(xs!i, ys!i). i \\<leftarrow> [0..<min (length xs) (length ys)]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip xs ys =\n    map (\\<lambda>i. (xs ! i, ys ! i)) [0..<min (length xs) (length ys)]", "by (simp add: zip_with_Pair [symmetric] zip_with_altdef')"], ["", "lemma card_poly_roots_bound:\n  fixes p :: \"'a::{comm_ring_1,ring_no_zero_divisors} poly\"\n  assumes \"p \\<noteq> 0\"\n  shows   \"card {x. poly p x = 0} \\<le> degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} \\<le> degree p", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} \\<le> degree p", "proof (induction \"degree p\" arbitrary: p rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>degree pa < degree p; pa \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> card {x. poly pa x = (0::'a)}\n                                     \\<le> degree pa;\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card {x. poly p x = (0::'a)} \\<le> degree p", "case (less p)"], ["proof (state)\nthis:\n  \\<lbrakk>degree ?p < degree p; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> card {x. poly ?p x = (0::'a)} \\<le> degree ?p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>degree pa < degree p; pa \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> card {x. poly pa x = (0::'a)}\n                                     \\<le> degree pa;\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card {x. poly p x = (0::'a)} \\<le> degree p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} \\<le> degree p", "proof (cases \"\\<exists>x. poly p x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "case False"], ["proof (state)\nthis:\n  \\<nexists>x. poly p x = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "hence \"{x. poly p x = 0} = {}\""], ["proof (prove)\nusing this:\n  \\<nexists>x. poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} = {}", "by blast"], ["proof (state)\nthis:\n  {x. poly p x = (0::'a)} = {}\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "thus ?thesis"], ["proof (prove)\nusing this:\n  {x. poly p x = (0::'a)} = {}\n\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} \\<le> degree p", "by simp"], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} \\<le> degree p\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "case True"], ["proof (state)\nthis:\n  \\<exists>x. poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. poly p x = (0::'a)", "obtain x where x: \"poly p x = 0\""], ["proof (prove)\nusing this:\n  \\<exists>x. poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>x. poly p x = (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "hence \"[:-x, 1:] dvd p\""], ["proof (prove)\nusing this:\n  poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] dvd p", "by (subst (asm) poly_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  [:- x, 1::'a:] dvd p\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "then"], ["proof (chain)\npicking this:\n  [:- x, 1::'a:] dvd p", "obtain q where q: \"p = [:-x, 1:] * q\""], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = [:- x, 1::'a:] * q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: dvd_def)"], ["proof (state)\nthis:\n  p = [:- x, 1::'a:] * q\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "with \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  p = [:- x, 1::'a:] * q", "have [simp]: \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p = [:- x, 1::'a:] * q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "have deg: \"degree p = Suc (degree q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = Suc (degree q)", "by (subst q, subst degree_mult_eq) auto"], ["proof (state)\nthis:\n  degree p = Suc (degree q)\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "have \"card {x. poly p x = 0} \\<le> card (insert x {x. poly q x = 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)}\n    \\<le> card (insert x {x. poly q x = (0::'a)})", "by (intro card_mono) (auto intro: poly_roots_finite simp: q)"], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} \\<le> card (insert x {x. poly q x = (0::'a)})\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "also"], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} \\<le> card (insert x {x. poly q x = (0::'a)})\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "have \"\\<dots> \\<le> Suc (card {x. poly q x = 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert x {x. poly q x = (0::'a)})\n    \\<le> Suc (card {x. poly q x = (0::'a)})", "by (rule card_insert_le_m1) auto"], ["proof (state)\nthis:\n  card (insert x {x. poly q x = (0::'a)})\n  \\<le> Suc (card {x. poly q x = (0::'a)})\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "also"], ["proof (state)\nthis:\n  card (insert x {x. poly q x = (0::'a)})\n  \\<le> Suc (card {x. poly q x = (0::'a)})\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "from deg"], ["proof (chain)\npicking this:\n  degree p = Suc (degree q)", "have  \"card {x. poly q x = 0} \\<le> degree q\""], ["proof (prove)\nusing this:\n  degree p = Suc (degree q)\n\ngoal (1 subgoal):\n 1. card {x. poly q x = (0::'a)} \\<le> degree q", "using \\<open>p \\<noteq> 0\\<close> and q"], ["proof (prove)\nusing this:\n  degree p = Suc (degree q)\n  p \\<noteq> 0\n  p = [:- x, 1::'a:] * q\n\ngoal (1 subgoal):\n 1. card {x. poly q x = (0::'a)} \\<le> degree q", "by (intro less) auto"], ["proof (state)\nthis:\n  card {x. poly q x = (0::'a)} \\<le> degree q\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "also"], ["proof (state)\nthis:\n  card {x. poly q x = (0::'a)} \\<le> degree q\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "have \"Suc \\<dots> = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (degree q) = degree p", "by (simp add: deg)"], ["proof (state)\nthis:\n  Suc (degree q) = degree p\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> Suc x \\<le> Suc y) \\<Longrightarrow>\n  card {x. poly p x = (0::'a)} \\<le> degree p", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> Suc x \\<le> Suc y) \\<Longrightarrow>\n  card {x. poly p x = (0::'a)} \\<le> degree p\n\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} \\<le> degree p", "by - simp_all"], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} \\<le> degree p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} \\<le> degree p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_eqI_degree:\n  fixes p q :: \"'a :: {comm_ring_1, ring_no_zero_divisors} poly\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> poly p x = poly q x\"\n  assumes \"card A > degree p\" \"card A > degree q\"\n  shows   \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "assume neq: \"p \\<noteq> q\""], ["proof (state)\nthis:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "have \"degree (p - q) \\<le> max (degree p) (degree q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (p - q) \\<le> max (degree p) (degree q)", "by (rule degree_diff_le_max)"], ["proof (state)\nthis:\n  degree (p - q) \\<le> max (degree p) (degree q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree (p - q) \\<le> max (degree p) (degree q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  ?x \\<in> A \\<Longrightarrow> poly p ?x = poly q ?x\n  degree p < card A\n  degree q < card A", "have \"\\<dots> < card A\""], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> poly p ?x = poly q ?x\n  degree p < card A\n  degree q < card A\n\ngoal (1 subgoal):\n 1. max (degree p) (degree q) < card A", "by linarith"], ["proof (state)\nthis:\n  max (degree p) (degree q) < card A\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  max (degree p) (degree q) < card A\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "have \"\\<dots> \\<le> card {x. poly (p - q) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card A \\<le> card {x. poly (p - q) x = (0::'a)}", "using neq and assms"], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  ?x \\<in> A \\<Longrightarrow> poly p ?x = poly q ?x\n  degree p < card A\n  degree q < card A\n\ngoal (1 subgoal):\n 1. card A \\<le> card {x. poly (p - q) x = (0::'a)}", "by (intro card_mono poly_roots_finite) auto"], ["proof (state)\nthis:\n  card A \\<le> card {x. poly (p - q) x = (0::'a)}\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  degree (p - q) < card {x. poly (p - q) x = (0::'a)}", "have \"degree (p - q) < card {x. poly (p - q) x = 0}\""], ["proof (prove)\nusing this:\n  degree (p - q) < card {x. poly (p - q) x = (0::'a)}\n\ngoal (1 subgoal):\n 1. degree (p - q) < card {x. poly (p - q) x = (0::'a)}", "."], ["proof (state)\nthis:\n  degree (p - q) < card {x. poly (p - q) x = (0::'a)}\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  degree (p - q) < card {x. poly (p - q) x = (0::'a)}\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "have \"degree (p - q) \\<ge> card {x. poly (p - q) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly (p - q) x = (0::'a)} \\<le> degree (p - q)", "using neq"], ["proof (prove)\nusing this:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. card {x. poly (p - q) x = (0::'a)} \\<le> degree (p - q)", "by (intro card_poly_roots_bound) auto"], ["proof (state)\nthis:\n  card {x. poly (p - q) x = (0::'a)} \\<le> degree (p - q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  degree (p - q) < card {x. poly (p - q) x = (0::'a)}\n  card {x. poly (p - q) x = (0::'a)} \\<le> degree (p - q)", "show False"], ["proof (prove)\nusing this:\n  degree (p - q) < card {x. poly (p - q) x = (0::'a)}\n  card {x. poly (p - q) x = (0::'a)} \\<le> degree (p - q)\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_root_order_induct [case_names 0 no_roots root]:\n  fixes p :: \"'a :: idom poly\"\n  assumes \"P 0\" \"\\<And>p. (\\<And>x. poly p x \\<noteq> 0) \\<Longrightarrow> P p\" \n          \"\\<And>p x n. n > 0 \\<Longrightarrow> poly p x \\<noteq> 0 \\<Longrightarrow> P p \\<Longrightarrow> P ([:-x, 1:] ^ n * p)\"\n  shows   \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof (induction \"degree p\" arbitrary: p rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>pa.\n           degree pa < degree p \\<Longrightarrow> P pa) \\<Longrightarrow>\n       P p", "case (less p)"], ["proof (state)\nthis:\n  degree ?p < degree p \\<Longrightarrow> P ?p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>pa.\n           degree pa < degree p \\<Longrightarrow> P pa) \\<Longrightarrow>\n       P p", "consider \"p = 0\" | \"p \\<noteq> 0\" \"\\<exists>x. poly p x = 0\" | \"\\<And>x. poly p x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = 0 \\<Longrightarrow> thesis;\n     \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     (\\<And>x. poly p x \\<noteq> (0::'a)) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>p = 0 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   (\\<And>x. poly p x \\<noteq> (0::'a)) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>pa.\n           degree pa < degree p \\<Longrightarrow> P pa) \\<Longrightarrow>\n       P p", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>p = 0 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   (\\<And>x. poly p x \\<noteq> (0::'a)) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. P p", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p\n 3. (\\<And>x. poly p x \\<noteq> (0::'a)) \\<Longrightarrow> P p", "case 3"], ["proof (state)\nthis:\n  poly p ?x \\<noteq> (0::'a)\n\ngoal (3 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p\n 3. (\\<And>x. poly p x \\<noteq> (0::'a)) \\<Longrightarrow> P p", "with assms(2)[of p]"], ["proof (chain)\npicking this:\n  (\\<And>x. poly p x \\<noteq> (0::'a)) \\<Longrightarrow> P p\n  poly p ?x \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x. poly p x \\<noteq> (0::'a)) \\<Longrightarrow> P p\n  poly p ?x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. P p", "by simp"], ["proof (state)\nthis:\n  P p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "case 2"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  \\<exists>x. poly p x = (0::'a)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  \\<exists>x. poly p x = (0::'a)", "obtain x where x: \"poly p x = 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  \\<exists>x. poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>x. poly p x = (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly p x = (0::'a)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "have \"[:-x, 1:] ^ order x p dvd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] ^ order x p dvd p", "by (intro order_1)"], ["proof (state)\nthis:\n  [:- x, 1::'a:] ^ order x p dvd p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  [:- x, 1::'a:] ^ order x p dvd p", "obtain q where q: \"p = [:-x, 1:] ^ order x p * q\""], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] ^ order x p dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = [:- x, 1::'a:] ^ order x p * q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: dvd_def)"], ["proof (state)\nthis:\n  p = [:- x, 1::'a:] ^ order x p * q\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "with 2"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  \\<exists>x. poly p x = (0::'a)\n  p = [:- x, 1::'a:] ^ order x p * q", "have [simp]: \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  \\<exists>x. poly p x = (0::'a)\n  p = [:- x, 1::'a:] ^ order x p * q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "have order_pos: \"order x p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order x p", "using \\<open>p \\<noteq> 0\\<close> and x"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < order x p", "by (auto simp: order_root)"], ["proof (state)\nthis:\n  0 < order x p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "have \"order x p = order x p + order x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p = order x p + order x q", "by (subst q, subst order_mult) (auto simp: order_power_n_n)"], ["proof (state)\nthis:\n  order x p = order x p + order x q\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "hence [simp]: \"order x q = 0\""], ["proof (prove)\nusing this:\n  order x p = order x p + order x q\n\ngoal (1 subgoal):\n 1. order x q = 0", "by simp"], ["proof (state)\nthis:\n  order x q = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "have deg: \"degree p = order x p + degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = order x p + degree q", "by (subst q, subst degree_mult_eq) (auto simp: degree_power_eq)"], ["proof (state)\nthis:\n  degree p = order x p + degree q\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "with order_pos"], ["proof (chain)\npicking this:\n  0 < order x p\n  degree p = order x p + degree q", "have \"degree q < degree p\""], ["proof (prove)\nusing this:\n  0 < order x p\n  degree p = order x p + degree q\n\ngoal (1 subgoal):\n 1. degree q < degree p", "by simp"], ["proof (state)\nthis:\n  degree q < degree p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "hence \"P q\""], ["proof (prove)\nusing this:\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. P q", "by (rule less)"], ["proof (state)\nthis:\n  P q\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "with order_pos"], ["proof (chain)\npicking this:\n  0 < order x p\n  P q", "have \"P ([:-x, 1:] ^ order x p * q)\""], ["proof (prove)\nusing this:\n  0 < order x p\n  P q\n\ngoal (1 subgoal):\n 1. P ([:- x, 1::'a:] ^ order x p * q)", "by (intro assms(3)) (auto simp: order_root)"], ["proof (state)\nthis:\n  P ([:- x, 1::'a:] ^ order x p * q)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "with q"], ["proof (chain)\npicking this:\n  p = [:- x, 1::'a:] ^ order x p * q\n  P ([:- x, 1::'a:] ^ order x p * q)", "show ?thesis"], ["proof (prove)\nusing this:\n  p = [:- x, 1::'a:] ^ order x p * q\n  P ([:- x, 1::'a:] ^ order x p * q)\n\ngoal (1 subgoal):\n 1. P p", "by simp"], ["proof (state)\nthis:\n  P p\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> P p", "qed (simp_all add: assms(1))"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complex_poly_decompose:\n  \"smult (lead_coeff p) (\\<Prod>z|poly p z = 0. [:-z, 1:] ^ order z p) = (p :: complex poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p", "proof (induction p rule: poly_root_order_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p.\n       (\\<And>x. poly p x \\<noteq> 0) \\<Longrightarrow>\n       smult (lead_coeff p)\n        (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n       p\n 3. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "case (no_roots p)"], ["proof (state)\nthis:\n  poly p ?x \\<noteq> 0\n\ngoal (3 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p.\n       (\\<And>x. poly p x \\<noteq> 0) \\<Longrightarrow>\n       smult (lead_coeff p)\n        (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n       p\n 3. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p", "proof (cases \"degree p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p", "hence \"\\<not>constant (poly p)\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> constant (poly p)", "by (subst constant_degree)"], ["proof (state)\nthis:\n  \\<not> constant (poly p)\n\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p", "with fundamental_theorem_of_algebra and no_roots"], ["proof (chain)\npicking this:\n  \\<not> constant (poly ?p) \\<Longrightarrow> \\<exists>z. poly ?p z = 0\n  poly p ?x \\<noteq> 0\n  \\<not> constant (poly p)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> constant (poly ?p) \\<Longrightarrow> \\<exists>z. poly ?p z = 0\n  poly p ?x \\<noteq> 0\n  \\<not> constant (poly p)\n\ngoal (1 subgoal):\n 1. smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p", "by blast"], ["proof (state)\nthis:\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n\ngoal (1 subgoal):\n 1. degree p = 0 \\<Longrightarrow>\n    smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p", "qed (auto elim!: degree_eq_zeroE)"], ["proof (state)\nthis:\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "case (root p x n)"], ["proof (state)\nthis:\n  0 < n\n  poly p x \\<noteq> 0\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "from root"], ["proof (chain)\npicking this:\n  0 < n\n  poly p x \\<noteq> 0\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p", "have *: \"{z. poly ([:- x, 1:] ^ n * p) z = 0} = insert x {z. poly p z = 0}\""], ["proof (prove)\nusing this:\n  0 < n\n  poly p x \\<noteq> 0\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n\ngoal (1 subgoal):\n 1. {z. poly ([:- x, 1:] ^ n * p) z = 0} = insert x {z. poly p z = 0}", "by auto"], ["proof (state)\nthis:\n  {z. poly ([:- x, 1:] ^ n * p) z = 0} = insert x {z. poly p z = 0}\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "have \"smult (lead_coeff ([:-x, 1:] ^ n * p)) \n           (\\<Prod>z|poly ([:-x,1:] ^ n * p) z = 0. [:-z, 1:] ^ order z ([:- x, 1:] ^ n * p)) = \n        [:- x, 1:] ^ order x ([:- x, 1:] ^ n * p) * \n          smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (lead_coeff ([:- x, 1:] ^ n * p))\n     (\\<Prod>z\\<in>{z. poly ([:- x, 1:] ^ n * p) z = 0}.\n        [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n    [:- x, 1:] ^ order x ([:- x, 1:] ^ n * p) *\n    smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}.\n        [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p))", "by (subst *, subst prod.insert) \n       (insert root, auto intro: poly_roots_finite simp: mult_ac lead_coeff_mult lead_coeff_power)"], ["proof (state)\nthis:\n  smult (lead_coeff ([:- x, 1:] ^ n * p))\n   (\\<Prod>z\\<in>{z. poly ([:- x, 1:] ^ n * p) z = 0}.\n      [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n  [:- x, 1:] ^ order x ([:- x, 1:] ^ n * p) *\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}.\n      [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p))\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "also"], ["proof (state)\nthis:\n  smult (lead_coeff ([:- x, 1:] ^ n * p))\n   (\\<Prod>z\\<in>{z. poly ([:- x, 1:] ^ n * p) z = 0}.\n      [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n  [:- x, 1:] ^ order x ([:- x, 1:] ^ n * p) *\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}.\n      [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p))\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "have \"order x ([:- x, 1:] ^ n * p) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x ([:- x, 1:] ^ n * p) = n", "using root"], ["proof (prove)\nusing this:\n  0 < n\n  poly p x \\<noteq> 0\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n\ngoal (1 subgoal):\n 1. order x ([:- x, 1:] ^ n * p) = n", "by (subst order_mult) (auto simp: order_power_n_n order_0I)"], ["proof (state)\nthis:\n  order x ([:- x, 1:] ^ n * p) = n\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "also"], ["proof (state)\nthis:\n  order x ([:- x, 1:] ^ n * p) = n\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "have \"(\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n               (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>z\\<in>{z. poly p z = 0}.\n       [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n    (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p)", "proof (intro prod.cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {z. poly p z = 0} \\<Longrightarrow>\n       [:- xa, 1:] ^ order xa ([:- x, 1:] ^ n * p) =\n       [:- xa, 1:] ^ order xa p", "case (1 y)"], ["proof (state)\nthis:\n  y \\<in> {z. poly p z = 0}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {z. poly p z = 0} \\<Longrightarrow>\n       [:- xa, 1:] ^ order xa ([:- x, 1:] ^ n * p) =\n       [:- xa, 1:] ^ order xa p", "with root"], ["proof (chain)\npicking this:\n  0 < n\n  poly p x \\<noteq> 0\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n  y \\<in> {z. poly p z = 0}", "have \"order y ([:-x,1:] ^ n) = 0\""], ["proof (prove)\nusing this:\n  0 < n\n  poly p x \\<noteq> 0\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n  y \\<in> {z. poly p z = 0}\n\ngoal (1 subgoal):\n 1. order y ([:- x, 1:] ^ n) = 0", "by (intro order_0I) auto"], ["proof (state)\nthis:\n  order y ([:- x, 1:] ^ n) = 0\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {z. poly p z = 0} \\<Longrightarrow>\n       [:- xa, 1:] ^ order xa ([:- x, 1:] ^ n * p) =\n       [:- xa, 1:] ^ order xa p", "thus ?case"], ["proof (prove)\nusing this:\n  order y ([:- x, 1:] ^ n) = 0\n\ngoal (1 subgoal):\n 1. [:- y, 1:] ^ order y ([:- x, 1:] ^ n * p) = [:- y, 1:] ^ order y p", "using root"], ["proof (prove)\nusing this:\n  order y ([:- x, 1:] ^ n) = 0\n  0 < n\n  poly p x \\<noteq> 0\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n\ngoal (1 subgoal):\n 1. [:- y, 1:] ^ order y ([:- x, 1:] ^ n * p) = [:- y, 1:] ^ order y p", "by (subst order_mult) auto"], ["proof (state)\nthis:\n  [:- y, 1:] ^ order y ([:- x, 1:] ^ n * p) = [:- y, 1:] ^ order y p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>z\\<in>{z. poly p z = 0}.\n     [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n  (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p)\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "also"], ["proof (state)\nthis:\n  (\\<Prod>z\\<in>{z. poly p z = 0}.\n     [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n  (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p)\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "note root.IH"], ["proof (state)\nthis:\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "finally"], ["proof (chain)\npicking this:\n  smult (lead_coeff ([:- x, 1:] ^ n * p))\n   (\\<Prod>z\\<in>{z. poly ([:- x, 1:] ^ n * p) z = 0}.\n      [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n  [:- x, 1:] ^ n * p", "show ?case"], ["proof (prove)\nusing this:\n  smult (lead_coeff ([:- x, 1:] ^ n * p))\n   (\\<Prod>z\\<in>{z. poly ([:- x, 1:] ^ n * p) z = 0}.\n      [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n  [:- x, 1:] ^ n * p\n\ngoal (1 subgoal):\n 1. smult (lead_coeff ([:- x, 1:] ^ n * p))\n     (\\<Prod>z\\<in>{z. poly ([:- x, 1:] ^ n * p) z = 0}.\n        [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n    [:- x, 1:] ^ n * p", "."], ["proof (state)\nthis:\n  smult (lead_coeff ([:- x, 1:] ^ n * p))\n   (\\<Prod>z\\<in>{z. poly ([:- x, 1:] ^ n * p) z = 0}.\n      [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n  [:- x, 1:] ^ n * p\n\ngoal (1 subgoal):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0", "qed simp_all"], ["", "lemma normalize_field: \n  \"normalize (x :: 'a :: {normalization_semidom,field}) = (if x = 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize x = (if x = (0::'a) then 0::'a else (1::'a))", "by (auto simp: normalize_1_iff dvd_field_iff)"], ["", "lemma unit_factor_field [simp]:\n  \"unit_factor (x :: 'a :: {normalization_semidom,field}) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_factor x = x", "using unit_factor_mult_normalize[of x] normalize_field[of x]"], ["proof (prove)\nusing this:\n  unit_factor x * normalize x = x\n  normalize x = (if x = (0::'a) then 0::'a else (1::'a))\n\ngoal (1 subgoal):\n 1. unit_factor x = x", "by (simp split: if_splits)"], ["", "lemma coprime_linear_poly: \n  fixes c :: \"'a :: field_gcd\"\n  assumes \"c \\<noteq> c'\"\n  shows   \"coprime [:c,1:] [:c',1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime [:c, 1::'a:] [:c', 1::'a:]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coprime [:c, 1::'a:] [:c', 1::'a:]", "have \"gcd [:c,1:] [:c',1:] = gcd ([:c,1:] - [:c',1:]) [:c',1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd [:c, 1::'a:] [:c', 1::'a:] =\n    gcd ([:c, 1::'a:] - [:c', 1::'a:]) [:c', 1::'a:]", "by (rule gcd_diff1 [symmetric])"], ["proof (state)\nthis:\n  gcd [:c, 1::'a:] [:c', 1::'a:] =\n  gcd ([:c, 1::'a:] - [:c', 1::'a:]) [:c', 1::'a:]\n\ngoal (1 subgoal):\n 1. coprime [:c, 1::'a:] [:c', 1::'a:]", "also"], ["proof (state)\nthis:\n  gcd [:c, 1::'a:] [:c', 1::'a:] =\n  gcd ([:c, 1::'a:] - [:c', 1::'a:]) [:c', 1::'a:]\n\ngoal (1 subgoal):\n 1. coprime [:c, 1::'a:] [:c', 1::'a:]", "have \"[:c,1:] - [:c',1:] = [:c-c':]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:c, 1::'a:] - [:c', 1::'a:] = [:c - c':]", "by simp"], ["proof (state)\nthis:\n  [:c, 1::'a:] - [:c', 1::'a:] = [:c - c':]\n\ngoal (1 subgoal):\n 1. coprime [:c, 1::'a:] [:c', 1::'a:]", "also"], ["proof (state)\nthis:\n  [:c, 1::'a:] - [:c', 1::'a:] = [:c - c':]\n\ngoal (1 subgoal):\n 1. coprime [:c, 1::'a:] [:c', 1::'a:]", "from assms"], ["proof (chain)\npicking this:\n  c \\<noteq> c'", "have \"gcd \\<dots> [:c',1:] = normalize [:c-c':]\""], ["proof (prove)\nusing this:\n  c \\<noteq> c'\n\ngoal (1 subgoal):\n 1. gcd [:c - c':] [:c', 1::'a:] = normalize [:c - c':]", "by (intro gcd_proj1_if_dvd) (auto simp: const_poly_dvd_iff dvd_field_iff)"], ["proof (state)\nthis:\n  gcd [:c - c':] [:c', 1::'a:] = normalize [:c - c':]\n\ngoal (1 subgoal):\n 1. coprime [:c, 1::'a:] [:c', 1::'a:]", "also"], ["proof (state)\nthis:\n  gcd [:c - c':] [:c', 1::'a:] = normalize [:c - c':]\n\ngoal (1 subgoal):\n 1. coprime [:c, 1::'a:] [:c', 1::'a:]", "from assms"], ["proof (chain)\npicking this:\n  c \\<noteq> c'", "have \"\\<dots> = 1\""], ["proof (prove)\nusing this:\n  c \\<noteq> c'\n\ngoal (1 subgoal):\n 1. normalize [:c - c':] = 1", "by (simp add: normalize_poly_def)"], ["proof (state)\nthis:\n  normalize [:c - c':] = 1\n\ngoal (1 subgoal):\n 1. coprime [:c, 1::'a:] [:c', 1::'a:]", "finally"], ["proof (chain)\npicking this:\n  gcd [:c, 1::'a:] [:c', 1::'a:] = 1", "show \"coprime [:c,1:] [:c',1:]\""], ["proof (prove)\nusing this:\n  gcd [:c, 1::'a:] [:c', 1::'a:] = 1\n\ngoal (1 subgoal):\n 1. coprime [:c, 1::'a:] [:c', 1::'a:]", "by (simp add: gcd_eq_1_imp_coprime)"], ["proof (state)\nthis:\n  coprime [:c, 1::'a:] [:c', 1::'a:]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coprime_linear_poly': \n  fixes c :: \"'a :: field_gcd\"\n  assumes \"c \\<noteq> c'\" \"c \\<noteq> 0\" \"c' \\<noteq> 0\"\n  shows   \"coprime [:1,c:] [:1,c':]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime [:1::'a, c:] [:1::'a, c':]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coprime [:1::'a, c:] [:1::'a, c':]", "have \"gcd [:1,c:] [:1,c':] = gcd ([:1,c:] mod [:1,c':]) [:1,c':]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd [:1::'a, c:] [:1::'a, c':] =\n    gcd ([:1::'a, c:] mod [:1::'a, c':]) [:1::'a, c':]", "by simp"], ["proof (state)\nthis:\n  gcd [:1::'a, c:] [:1::'a, c':] =\n  gcd ([:1::'a, c:] mod [:1::'a, c':]) [:1::'a, c':]\n\ngoal (1 subgoal):\n 1. coprime [:1::'a, c:] [:1::'a, c':]", "also"], ["proof (state)\nthis:\n  gcd [:1::'a, c:] [:1::'a, c':] =\n  gcd ([:1::'a, c:] mod [:1::'a, c':]) [:1::'a, c':]\n\ngoal (1 subgoal):\n 1. coprime [:1::'a, c:] [:1::'a, c':]", "have \"eucl_rel_poly [:1, c:] [:1, c':] ([:c/c':], [:1-c/c':])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_rel_poly [:1::'a, c:] [:1::'a, c':]\n     ([:c / c':], [:(1::'a) - c / c':])", "using assms"], ["proof (prove)\nusing this:\n  c \\<noteq> c'\n  c \\<noteq> (0::'a)\n  c' \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. eucl_rel_poly [:1::'a, c:] [:1::'a, c':]\n     ([:c / c':], [:(1::'a) - c / c':])", "by (auto simp add: eucl_rel_poly_iff one_pCons)"], ["proof (state)\nthis:\n  eucl_rel_poly [:1::'a, c:] [:1::'a, c':]\n   ([:c / c':], [:(1::'a) - c / c':])\n\ngoal (1 subgoal):\n 1. coprime [:1::'a, c:] [:1::'a, c':]", "hence \"[:1,c:] mod [:1,c':] = [:1 - c / c':]\""], ["proof (prove)\nusing this:\n  eucl_rel_poly [:1::'a, c:] [:1::'a, c':]\n   ([:c / c':], [:(1::'a) - c / c':])\n\ngoal (1 subgoal):\n 1. [:1::'a, c:] mod [:1::'a, c':] = [:(1::'a) - c / c':]", "by (rule mod_poly_eq)"], ["proof (state)\nthis:\n  [:1::'a, c:] mod [:1::'a, c':] = [:(1::'a) - c / c':]\n\ngoal (1 subgoal):\n 1. coprime [:1::'a, c:] [:1::'a, c':]", "also"], ["proof (state)\nthis:\n  [:1::'a, c:] mod [:1::'a, c':] = [:(1::'a) - c / c':]\n\ngoal (1 subgoal):\n 1. coprime [:1::'a, c:] [:1::'a, c':]", "from assms"], ["proof (chain)\npicking this:\n  c \\<noteq> c'\n  c \\<noteq> (0::'a)\n  c' \\<noteq> (0::'a)", "have \"gcd \\<dots> [:1,c':] = normalize ([:1 - c / c':])\""], ["proof (prove)\nusing this:\n  c \\<noteq> c'\n  c \\<noteq> (0::'a)\n  c' \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. gcd [:(1::'a) - c / c':] [:1::'a, c':] = normalize [:(1::'a) - c / c':]", "by (intro gcd_proj1_if_dvd) (auto simp: const_poly_dvd_iff dvd_field_iff)"], ["proof (state)\nthis:\n  gcd [:(1::'a) - c / c':] [:1::'a, c':] = normalize [:(1::'a) - c / c':]\n\ngoal (1 subgoal):\n 1. coprime [:1::'a, c:] [:1::'a, c':]", "also"], ["proof (state)\nthis:\n  gcd [:(1::'a) - c / c':] [:1::'a, c':] = normalize [:(1::'a) - c / c':]\n\ngoal (1 subgoal):\n 1. coprime [:1::'a, c:] [:1::'a, c':]", "from assms"], ["proof (chain)\npicking this:\n  c \\<noteq> c'\n  c \\<noteq> (0::'a)\n  c' \\<noteq> (0::'a)", "have \"\\<dots> = 1\""], ["proof (prove)\nusing this:\n  c \\<noteq> c'\n  c \\<noteq> (0::'a)\n  c' \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. normalize [:(1::'a) - c / c':] = 1", "by (auto simp: normalize_poly_def)"], ["proof (state)\nthis:\n  normalize [:(1::'a) - c / c':] = 1\n\ngoal (1 subgoal):\n 1. coprime [:1::'a, c:] [:1::'a, c':]", "finally"], ["proof (chain)\npicking this:\n  gcd [:1::'a, c:] [:1::'a, c':] = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  gcd [:1::'a, c:] [:1::'a, c':] = 1\n\ngoal (1 subgoal):\n 1. coprime [:1::'a, c:] [:1::'a, c':]", "by (rule gcd_eq_1_imp_coprime)"], ["proof (state)\nthis:\n  coprime [:1::'a, c:] [:1::'a, c':]\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}