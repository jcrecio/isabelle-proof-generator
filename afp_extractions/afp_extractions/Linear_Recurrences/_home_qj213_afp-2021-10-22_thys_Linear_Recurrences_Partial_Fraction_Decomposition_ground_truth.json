{"file_name": "/home/qj213/afp-2021-10-22/thys/Linear_Recurrences/Partial_Fraction_Decomposition.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Linear_Recurrences", "problem_names": ["lemma decompose_rec:\n  \"ys \\<noteq> [] \\<Longrightarrow> decompose x (y#ys) = \n     (case bezout_coefficients y (prod_list ys) of \n        (a, b) \\<Rightarrow> (b*x) # decompose (a*x) ys)\"", "lemma length_decompose [simp]: \"length (decompose x ys) = length ys\"", "lemma decompose_code [code]:\n  \"decompose x ys = decompose' x ys (tl (rev (decompose_aux 1 (rev ys))))\"", "lemma length_normalise_decomp [simp]: \"length (snd (normalise_decomp x y n)) = n\"", "lemma length_pfd1 [simp]:\n  \"length (snd (partial_fraction_decomposition x ys)) = length ys\"", "lemma length_pfd2 [simp]:\n  \"i < length ys \\<Longrightarrow> length (snd (partial_fraction_decomposition x ys) ! i) = snd (ys ! i) + 1\"", "lemma size_normalise_decomp:\n  \"a \\<in> set (snd (normalise_decomp x y n)) \\<Longrightarrow> y \\<noteq> 0 \\<Longrightarrow> euclidean_size a < euclidean_size y\"", "lemma size_partial_fraction_decomposition:\n \"i < length xs \\<Longrightarrow> fst (xs ! i) \\<noteq> 0 \\<Longrightarrow> x \\<in> set (snd (partial_fraction_decomposition y xs) ! i)\n    \\<Longrightarrow> euclidean_size x < euclidean_size (fst (xs ! i))\"", "lemma lift_power:\n  \"lift (a ^ n) = lift a ^ n\"", "lemma decompose:\n  assumes \"ys \\<noteq> []\" \"pairwise coprime (set ys)\" \"distinct ys\"\n          \"\\<And>y. y \\<in> set ys \\<Longrightarrow> is_unit (lift y)\"\n  shows   \"(\\<Sum>i<length ys. lift (decompose x ys ! i) div lift (ys ! i)) = \n             lift x div lift (prod_list ys)\"", "lemma normalise_decomp:\n  fixes x y :: 'a and n :: nat\n  assumes \"is_unit (lift y)\"\n  defines \"xs \\<equiv> snd (normalise_decomp x y n)\"\n  shows   \"lift (fst (normalise_decomp x y n)) + (\\<Sum>i<n. from_decomp (xs!i) y (n-i)) =\n             lift x div lift y ^ n\"", "lemma lift_prod_list: \"lift (prod_list xs) = prod_list (map lift xs)\"", "lemma lift_sum: \"lift (sum f A) = sum (\\<lambda>x. lift (f x)) A\"", "lemma partial_fraction_decomposition:\n  fixes   ys :: \"('a \\<times> nat) list\"\n  defines \"ys' \\<equiv> map (\\<lambda>(x,n). x ^ Suc n) ys :: 'a list\"\n  assumes unit: \"\\<And>y. y \\<in> fst ` set ys \\<Longrightarrow> is_unit (lift y)\" \n  assumes coprime: \"pairwise coprime (set ys')\"\n  assumes distinct: \"distinct ys'\"\n  assumes \"partial_fraction_decomposition x ys = (a, zs)\"\n  shows   \"lift a + (\\<Sum>i<length ys. \\<Sum>j\\<le>snd (ys!i). \n                       from_decomp (zs!i!j) (fst (ys!i)) (snd (ys!i)+1 - j)) = \n             lift x div lift (prod_list ys')\"", "lemma divmod_field_poly_code [code]:\n  \"divmod_field_poly p q =\n   (let cg = coeffs q\n    in if cg = [] then (0, p)\n       else let cf = coeffs p; ilc = inverse (last cg);\n                ch = map ((*) ilc) cg;\n                (q, r) =\n                  divmod_poly_one_main_list [] (rev cf) (rev ch)\n                  (1 + length cf - length cg)\n            in (poly_of_list (map ((*) ilc) q), poly_of_list (rev r)))\"", "lemma normalise_decomp_poly_code [code]:\n  \"normalise_decomp_poly x y 0 = (x, [])\"\n  \"normalise_decomp_poly x y (Suc n) = (\n     let (x', r) = divmod_field_poly x y;\n         (z, rs) = normalise_decomp_poly x' y n\n     in  (z, r # rs))\"", "lemma poly_pfd_simple_code [code]:\n  \"poly_pfd_simple x cs = \n    (if cs = [] then (x, []) else\n       let zs = zip_with (\\<lambda>(c,n) decomp. normalise_decomp_poly decomp [:1,-c:] (n+1))\n                  cs (decompose x (map (\\<lambda>(c,n). [:1,-c:] ^ Suc n) cs))\n      in  (sum_list (map fst zs), map (map (\\<lambda>p. coeff p 0) \\<circ> snd) zs))\"", "lemma fst_poly_pfd_simple: \n  \"fst (poly_pfd_simple x cs) = \n      fst (partial_fraction_decomposition x (map (\\<lambda>(c,n). ([:1,-c:],n)) cs))\"", "lemma const_polyI: \"degree p = 0 \\<Longrightarrow> [:coeff p 0:] = p\"", "lemma snd_poly_pfd_simple:\n  \"map (map (\\<lambda>c. [:c :: 'a :: field_gcd:])) (snd (poly_pfd_simple x cs)) = \n      (snd (partial_fraction_decomposition x (map (\\<lambda>(c,n). ([:1,-c:],n)) cs)))\"", "lemma poly_pfd_simple:\n  \"partial_fraction_decomposition x (map (\\<lambda>(c,n). ([:1,-c:],n)) cs) =\n         (fst (poly_pfd_simple x cs), map (map (\\<lambda>c. [:c:])) (snd (poly_pfd_simple x cs)))\""], "translations": [["", "lemma decompose_rec:\n  \"ys \\<noteq> [] \\<Longrightarrow> decompose x (y#ys) = \n     (case bezout_coefficients y (prod_list ys) of \n        (a, b) \\<Rightarrow> (b*x) # decompose (a*x) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow>\n    decompose x (y # ys) =\n    (case bezout_coefficients y (prod_list ys) of\n     (a, b) \\<Rightarrow> b * x # decompose (a * x) ys)", "by (cases ys) simp_all"], ["", "lemma length_decompose [simp]: \"length (decompose x ys) = length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (decompose x ys) = length ys", "proof (induction x ys rule: decompose.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. length (decompose x []) = length []\n 2. \\<And>x y. length (decompose x [y]) = length [y]\n 3. \\<And>x y v va.\n       (\\<And>xa ya.\n           (xa, ya) =\n           bezout_coefficients y (prod_list (v # va)) \\<Longrightarrow>\n           length (decompose (xa * x) (v # va)) =\n           length (v # va)) \\<Longrightarrow>\n       length (decompose x (y # v # va)) = length (y # v # va)", "case (3 x y z ys)"], ["proof (state)\nthis:\n  (?xa, ?ya) = bezout_coefficients y (prod_list (z # ys)) \\<Longrightarrow>\n  length (decompose (?xa * x) (z # ys)) = length (z # ys)\n\ngoal (3 subgoals):\n 1. \\<And>x. length (decompose x []) = length []\n 2. \\<And>x y. length (decompose x [y]) = length [y]\n 3. \\<And>x y v va.\n       (\\<And>xa ya.\n           (xa, ya) =\n           bezout_coefficients y (prod_list (v # va)) \\<Longrightarrow>\n           length (decompose (xa * x) (v # va)) =\n           length (v # va)) \\<Longrightarrow>\n       length (decompose x (y # v # va)) = length (y # v # va)", "obtain a b where ab: \"(a,b) = bezout_coefficients y (prod_list (z#ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        (a, b) =\n        bezout_coefficients y (prod_list (z # ys)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"bezout_coefficients y (z * prod_list ys)\") simp_all"], ["proof (state)\nthis:\n  (a, b) = bezout_coefficients y (prod_list (z # ys))\n\ngoal (3 subgoals):\n 1. \\<And>x. length (decompose x []) = length []\n 2. \\<And>x y. length (decompose x [y]) = length [y]\n 3. \\<And>x y v va.\n       (\\<And>xa ya.\n           (xa, ya) =\n           bezout_coefficients y (prod_list (v # va)) \\<Longrightarrow>\n           length (decompose (xa * x) (v # va)) =\n           length (v # va)) \\<Longrightarrow>\n       length (decompose x (y # v # va)) = length (y # v # va)", "from 3[OF ab] ab[symmetric]"], ["proof (chain)\npicking this:\n  length (decompose (a * x) (z # ys)) = length (z # ys)\n  bezout_coefficients y (prod_list (z # ys)) = (a, b)", "show ?case"], ["proof (prove)\nusing this:\n  length (decompose (a * x) (z # ys)) = length (z # ys)\n  bezout_coefficients y (prod_list (z # ys)) = (a, b)\n\ngoal (1 subgoal):\n 1. length (decompose x (y # z # ys)) = length (y # z # ys)", "by simp"], ["proof (state)\nthis:\n  length (decompose x (y # z # ys)) = length (y # z # ys)\n\ngoal (2 subgoals):\n 1. \\<And>x. length (decompose x []) = length []\n 2. \\<And>x y. length (decompose x [y]) = length [y]", "qed simp_all"], ["", "fun decompose' :: \"('a :: euclidean_ring_gcd) \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"decompose' x [] _ = []\"\n| \"decompose' x [y] _ = [x]\"\n| \"decompose' _ _ [] = []\"\n| \"decompose' x (y#ys) (p#ps) = \n     (case bezout_coefficients y p of\n        (a, b) \\<Rightarrow> (b*x) # decompose' (a*x) ys ps)\""], ["", "primrec decompose_aux :: \"'a :: {ab_semigroup_mult,monoid_mult} \\<Rightarrow> _\" where\n  \"decompose_aux acc [] = [acc]\"\n| \"decompose_aux acc (x#xs) = acc # decompose_aux (x * acc) xs\""], ["", "lemma decompose_code [code]:\n  \"decompose x ys = decompose' x ys (tl (rev (decompose_aux 1 (rev ys))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decompose x ys =\n    decompose' x ys (tl (rev (decompose_aux (1::'a) (rev ys))))", "proof (induction x ys rule: decompose.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       decompose x [] =\n       decompose' x [] (tl (rev (decompose_aux (1::'a) (rev []))))\n 2. \\<And>x y.\n       decompose x [y] =\n       decompose' x [y] (tl (rev (decompose_aux (1::'a) (rev [y]))))\n 3. \\<And>x y v va.\n       (\\<And>xa ya.\n           (xa, ya) =\n           bezout_coefficients y (prod_list (v # va)) \\<Longrightarrow>\n           decompose (xa * x) (v # va) =\n           decompose' (xa * x) (v # va)\n            (tl (rev (decompose_aux (1::'a)\n                       (rev (v # va)))))) \\<Longrightarrow>\n       decompose x (y # v # va) =\n       decompose' x (y # v # va)\n        (tl (rev (decompose_aux (1::'a) (rev (y # v # va)))))", "case (3 x y1 y2 ys)"], ["proof (state)\nthis:\n  (?xa, ?ya) =\n  bezout_coefficients y1 (prod_list (y2 # ys)) \\<Longrightarrow>\n  decompose (?xa * x) (y2 # ys) =\n  decompose' (?xa * x) (y2 # ys)\n   (tl (rev (decompose_aux (1::'a) (rev (y2 # ys)))))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       decompose x [] =\n       decompose' x [] (tl (rev (decompose_aux (1::'a) (rev []))))\n 2. \\<And>x y.\n       decompose x [y] =\n       decompose' x [y] (tl (rev (decompose_aux (1::'a) (rev [y]))))\n 3. \\<And>x y v va.\n       (\\<And>xa ya.\n           (xa, ya) =\n           bezout_coefficients y (prod_list (v # va)) \\<Longrightarrow>\n           decompose (xa * x) (v # va) =\n           decompose' (xa * x) (v # va)\n            (tl (rev (decompose_aux (1::'a)\n                       (rev (v # va)))))) \\<Longrightarrow>\n       decompose x (y # v # va) =\n       decompose' x (y # v # va)\n        (tl (rev (decompose_aux (1::'a) (rev (y # v # va)))))", "have [simp]: \n    \"decompose_aux acc xs = map (\\<lambda>x. prod_list x * acc) (prefixes xs)\" for acc :: 'a and xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. decompose_aux acc xs = map (\\<lambda>x. prod_list x * acc) (prefixes xs)", "by (induction xs arbitrary: acc) (simp_all add: mult_ac)"], ["proof (state)\nthis:\n  decompose_aux ?acc ?xs =\n  map (\\<lambda>x. prod_list x * ?acc) (prefixes ?xs)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       decompose x [] =\n       decompose' x [] (tl (rev (decompose_aux (1::'a) (rev []))))\n 2. \\<And>x y.\n       decompose x [y] =\n       decompose' x [y] (tl (rev (decompose_aux (1::'a) (rev [y]))))\n 3. \\<And>x y v va.\n       (\\<And>xa ya.\n           (xa, ya) =\n           bezout_coefficients y (prod_list (v # va)) \\<Longrightarrow>\n           decompose (xa * x) (v # va) =\n           decompose' (xa * x) (v # va)\n            (tl (rev (decompose_aux (1::'a)\n                       (rev (v # va)))))) \\<Longrightarrow>\n       decompose x (y # v # va) =\n       decompose' x (y # v # va)\n        (tl (rev (decompose_aux (1::'a) (rev (y # v # va)))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. decompose x (y1 # y2 # ys) =\n    decompose' x (y1 # y2 # ys)\n     (tl (rev (decompose_aux (1::'a) (rev (y1 # y2 # ys)))))", "using 3[of \"fst (bezout_coefficients y1 (y2 * prod_list ys))\"\n               \"snd (bezout_coefficients y1 (y2 * prod_list ys))\"]"], ["proof (prove)\nusing this:\n  (fst (bezout_coefficients y1 (y2 * prod_list ys)),\n   snd (bezout_coefficients y1 (y2 * prod_list ys))) =\n  bezout_coefficients y1 (prod_list (y2 # ys)) \\<Longrightarrow>\n  decompose (fst (bezout_coefficients y1 (y2 * prod_list ys)) * x)\n   (y2 # ys) =\n  decompose' (fst (bezout_coefficients y1 (y2 * prod_list ys)) * x)\n   (y2 # ys) (tl (rev (decompose_aux (1::'a) (rev (y2 # ys)))))\n\ngoal (1 subgoal):\n 1. decompose x (y1 # y2 # ys) =\n    decompose' x (y1 # y2 # ys)\n     (tl (rev (decompose_aux (1::'a) (rev (y1 # y2 # ys)))))", "by (simp add: case_prod_unfold rev_map prefixes_conv_suffixes o_def mult_ac)"], ["proof (state)\nthis:\n  decompose x (y1 # y2 # ys) =\n  decompose' x (y1 # y2 # ys)\n   (tl (rev (decompose_aux (1::'a) (rev (y1 # y2 # ys)))))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       decompose x [] =\n       decompose' x [] (tl (rev (decompose_aux (1::'a) (rev []))))\n 2. \\<And>x y.\n       decompose x [y] =\n       decompose' x [y] (tl (rev (decompose_aux (1::'a) (rev [y]))))", "qed simp_all"], ["", "text \\<open>\n  The next function performs the second step: Given a quotient of the form $x / y^n$, it \n  returns a list of $x_0, \\ldots, x_n$ such that $x / y^n = x_0 / y^n + \\ldots + x_{n-1} / y + x_n$\n  and all $x_i$ have a Euclidean size less than that of $y$.\n\\<close>"], ["", "fun normalise_decomp :: \"('a :: semiring_modulo) \\<Rightarrow> 'a \\<Rightarrow> nat \\<Rightarrow> 'a \\<times> ('a list)\" where\n  \"normalise_decomp x y 0 = (x, [])\"\n| \"normalise_decomp x y (Suc n) = (\n     case normalise_decomp (x div y) y n of\n       (z, rs) \\<Rightarrow> (z, x mod y # rs))\""], ["", "lemma length_normalise_decomp [simp]: \"length (snd (normalise_decomp x y n)) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (snd (normalise_decomp x y n)) = n", "by (induction x y n rule: normalise_decomp.induct) (auto split: prod.split)"], ["", "text \\<open>\n  The following constant implements the full process of partial fraction decomposition: \n  The input is a quotient $x / (y_1 ^ {k_1} \\ldots y_n ^ {k_n})$ and the output is a sum of \n  an entire element and terms of the form $a / y_i ^ k$ where $a$ has a Euclidean size less \n  than $y_i$.\n\\<close>"], ["", "definition partial_fraction_decomposition :: \n    \"'a :: euclidean_ring_gcd \\<Rightarrow> ('a \\<times> nat) list \\<Rightarrow> 'a \\<times> 'a list list\" where\n  \"partial_fraction_decomposition x ys = (if ys = [] then (x, []) else\n     (let zs = [let (y, n) = ys ! i\n                in  normalise_decomp (decompose x (map (\\<lambda>(y,n). y ^ Suc n) ys) ! i) y (Suc n). \n                  i \\<leftarrow> [0..<length ys]]\n      in  (sum_list (map fst zs), map snd zs)))\""], ["", "lemma length_pfd1 [simp]:\n  \"length (snd (partial_fraction_decomposition x ys)) = length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (snd (partial_fraction_decomposition x ys)) = length ys", "by (simp add: partial_fraction_decomposition_def)"], ["", "lemma length_pfd2 [simp]:\n  \"i < length ys \\<Longrightarrow> length (snd (partial_fraction_decomposition x ys) ! i) = snd (ys ! i) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length ys \\<Longrightarrow>\n    length (snd (partial_fraction_decomposition x ys) ! i) =\n    snd (ys ! i) + 1", "by (auto simp: partial_fraction_decomposition_def case_prod_unfold Let_def)"], ["", "lemma size_normalise_decomp:\n  \"a \\<in> set (snd (normalise_decomp x y n)) \\<Longrightarrow> y \\<noteq> 0 \\<Longrightarrow> euclidean_size a < euclidean_size y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> set (snd (normalise_decomp x y n));\n     y \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> euclidean_size a < euclidean_size y", "by (induction x y n rule: normalise_decomp.induct)\n     (auto simp: case_prod_unfold Let_def mod_size_less)"], ["", "lemma size_partial_fraction_decomposition:\n \"i < length xs \\<Longrightarrow> fst (xs ! i) \\<noteq> 0 \\<Longrightarrow> x \\<in> set (snd (partial_fraction_decomposition y xs) ! i)\n    \\<Longrightarrow> euclidean_size x < euclidean_size (fst (xs ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; fst (xs ! i) \\<noteq> (0::'a);\n     x \\<in> set (snd (partial_fraction_decomposition y xs) ! i)\\<rbrakk>\n    \\<Longrightarrow> euclidean_size x < euclidean_size (fst (xs ! i))", "by (auto simp: partial_fraction_decomposition_def Let_def case_prod_unfold\n          simp del: normalise_decomp.simps split: if_split_asm intro!: size_normalise_decomp)"], ["", "text \\<open>\n  A homomorphism $\\varphi$ from a Euclidean ring $R$ into another ring $S$ with a notion of \n  division. We will show that for any $x,y\\in R$ such that $\\phi(y)$ is a unit, we can perform \n  partial fraction decomposition on the quotient $\\varphi(x) / \\varphi(y)$.\n  \n  The obvious choice for $S$ is the fraction field of $R$, but other choices may also make sense: \n  If, for example, $R$ is a ring of polynomials $K[X]$, then one could let $S = K$ and $\\varphi$ \n  the evaluation homomorphism. Or one could let $S = K[[X]]$ (the ring of formal power series) and \n  $\\varphi$ the canonical homomorphism from polynomials to formal power series.\n\\<close>"], ["", "locale pfd_homomorphism =\nfixes lift :: \"('a :: euclidean_ring_gcd) \\<Rightarrow> ('b :: euclidean_semiring_cancel)\"\nassumes lift_add: \"lift (a + b) = lift a + lift b\"                   \nassumes lift_mult: \"lift (a * b) = lift a * lift b\"\nassumes lift_0 [simp]: \"lift 0 = 0\"\nassumes lift_1 [simp]: \"lift 1 = 1\"\nbegin"], ["", "lemma lift_power:\n  \"lift (a ^ n) = lift a ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (a ^ n) = lift a ^ n", "by (induction n) (simp_all add: lift_mult)"], ["", "definition from_decomp :: \"'a \\<Rightarrow> 'a \\<Rightarrow> nat \\<Rightarrow> 'b\" where\n  \"from_decomp x y n = lift x div lift y ^ n\""], ["", "lemma decompose:\n  assumes \"ys \\<noteq> []\" \"pairwise coprime (set ys)\" \"distinct ys\"\n          \"\\<And>y. y \\<in> set ys \\<Longrightarrow> is_unit (lift y)\"\n  shows   \"(\\<Sum>i<length ys. lift (decompose x ys ! i) div lift (ys ! i)) = \n             lift x div lift (prod_list ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length ys. lift (decompose x ys ! i) div lift (ys ! i)) =\n    lift x div lift (prod_list ys)", "using assms"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  pairwise coprime (set ys)\n  distinct ys\n  ?y \\<in> set ys \\<Longrightarrow> is_unit (lift ?y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length ys. lift (decompose x ys ! i) div lift (ys ! i)) =\n    lift x div lift (prod_list ys)", "proof (induction ys arbitrary: x rule: list_nonempty_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "case (cons y ys x)"], ["proof (state)\nthis:\n  ys \\<noteq> []\n  \\<lbrakk>pairwise coprime (set ys); distinct ys;\n   \\<And>y. y \\<in> set ys \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i<length ys.\n                        lift (decompose ?x ys ! i) div lift (ys ! i)) =\n                    lift ?x div lift (prod_list ys)\n  pairwise coprime (set (y # ys))\n  distinct (y # ys)\n  ?y \\<in> set (y # ys) \\<Longrightarrow> is_unit (lift ?y)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "from cons.prems"], ["proof (chain)\npicking this:\n  pairwise coprime (set (y # ys))\n  distinct (y # ys)\n  ?y \\<in> set (y # ys) \\<Longrightarrow> is_unit (lift ?y)", "have \"coprime (prod_list ys) y\""], ["proof (prove)\nusing this:\n  pairwise coprime (set (y # ys))\n  distinct (y # ys)\n  ?y \\<in> set (y # ys) \\<Longrightarrow> is_unit (lift ?y)\n\ngoal (1 subgoal):\n 1. coprime (prod_list ys) y", "by (auto simp add: pairwise_insert intro: prod_list_coprime_left)"], ["proof (state)\nthis:\n  coprime (prod_list ys) y\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "from cons.prems"], ["proof (chain)\npicking this:\n  pairwise coprime (set (y # ys))\n  distinct (y # ys)\n  ?y \\<in> set (y # ys) \\<Longrightarrow> is_unit (lift ?y)", "have unit: \"is_unit (lift y)\""], ["proof (prove)\nusing this:\n  pairwise coprime (set (y # ys))\n  distinct (y # ys)\n  ?y \\<in> set (y # ys) \\<Longrightarrow> is_unit (lift ?y)\n\ngoal (1 subgoal):\n 1. is_unit (lift y)", "by simp"], ["proof (state)\nthis:\n  is_unit (lift y)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "moreover"], ["proof (state)\nthis:\n  is_unit (lift y)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "from cons.prems"], ["proof (chain)\npicking this:\n  pairwise coprime (set (y # ys))\n  distinct (y # ys)\n  ?y \\<in> set (y # ys) \\<Longrightarrow> is_unit (lift ?y)", "have \"\\<forall>y\\<in>set ys. is_unit (lift y)\""], ["proof (prove)\nusing this:\n  pairwise coprime (set (y # ys))\n  distinct (y # ys)\n  ?y \\<in> set (y # ys) \\<Longrightarrow> is_unit (lift ?y)\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set ys. is_unit (lift y)", "by simp"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ys. is_unit (lift y)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "hence unit': \"is_unit (lift (prod_list ys))\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set ys. is_unit (lift y)\n\ngoal (1 subgoal):\n 1. is_unit (lift (prod_list ys))", "by (induction ys) (auto simp: lift_mult)"], ["proof (state)\nthis:\n  is_unit (lift (prod_list ys))\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "ultimately"], ["proof (chain)\npicking this:\n  is_unit (lift y)\n  is_unit (lift (prod_list ys))", "have unit: \"lift y dvd b\" \"lift (prod_list ys) dvd b\" for b"], ["proof (prove)\nusing this:\n  is_unit (lift y)\n  is_unit (lift (prod_list ys))\n\ngoal (1 subgoal):\n 1. lift y dvd b &&& lift (prod_list ys) dvd b", "by auto"], ["proof (state)\nthis:\n  lift y dvd ?b\n  lift (prod_list ys) dvd ?b\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "obtain s t where st: \"bezout_coefficients y (prod_list ys) = (s, t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s t.\n        bezout_coefficients y (prod_list ys) = (s, t) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"bezout_coefficients y (prod_list ys)\") simp_all"], ["proof (state)\nthis:\n  bezout_coefficients y (prod_list ys) = (s, t)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "from \\<open>pairwise coprime (set (y#ys))\\<close>"], ["proof (chain)\npicking this:\n  pairwise coprime (set (y # ys))", "have  coprime:\"pairwise coprime (set ys)\""], ["proof (prove)\nusing this:\n  pairwise coprime (set (y # ys))\n\ngoal (1 subgoal):\n 1. pairwise coprime (set ys)", "by (rule pairwise_subset) auto"], ["proof (state)\nthis:\n  pairwise coprime (set ys)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "have \"(\\<Sum>i<length (y # ys). lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) = \n          lift (t * x) div lift y + lift (s * x) div lift (prod_list ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (y # ys).\n        lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) =\n    lift (t * x) div lift y + lift (s * x) div lift (prod_list ys)", "using cons.hyps cons.prems coprime"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  pairwise coprime (set (y # ys))\n  distinct (y # ys)\n  ?y \\<in> set (y # ys) \\<Longrightarrow> is_unit (lift ?y)\n  pairwise coprime (set ys)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (y # ys).\n        lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) =\n    lift (t * x) div lift y + lift (s * x) div lift (prod_list ys)", "unfolding length_Cons atLeast0LessThan [symmetric]"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  pairwise coprime (set (y # ys))\n  distinct (y # ys)\n  ?y \\<in> set (y # ys) \\<Longrightarrow> is_unit (lift ?y)\n  pairwise coprime (set ys)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<Suc (length ys).\n        lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) =\n    lift (t * x) div lift y + lift (s * x) div lift (prod_list ys)", "by (subst sum.atLeast_Suc_lessThan, simp, subst sum.shift_bounds_Suc_ivl)\n       (simp add: atLeast0LessThan decompose_rec st cons.IH lift_mult)"], ["proof (state)\nthis:\n  (\\<Sum>i<length (y # ys).\n      lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) =\n  lift (t * x) div lift y + lift (s * x) div lift (prod_list ys)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length (y # ys).\n      lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) =\n  lift (t * x) div lift y + lift (s * x) div lift (prod_list ys)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "have \"(lift (t * x) div lift y + lift (s * x) div lift (prod_list ys)) *\n                lift (prod_list (y#ys)) = \n             lift (prod_list ys) * (lift y * (lift (t * x) div lift y)) + \n             lift y * (lift (prod_list ys) * (lift (s * x) div lift (prod_list ys)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lift (t * x) div lift y + lift (s * x) div lift (prod_list ys)) *\n    lift (prod_list (y # ys)) =\n    lift (prod_list ys) * (lift y * (lift (t * x) div lift y)) +\n    lift y * (lift (prod_list ys) * (lift (s * x) div lift (prod_list ys)))", "by (simp_all add: lift_mult algebra_simps)"], ["proof (state)\nthis:\n  (lift (t * x) div lift y + lift (s * x) div lift (prod_list ys)) *\n  lift (prod_list (y # ys)) =\n  lift (prod_list ys) * (lift y * (lift (t * x) div lift y)) +\n  lift y * (lift (prod_list ys) * (lift (s * x) div lift (prod_list ys)))\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "also"], ["proof (state)\nthis:\n  (lift (t * x) div lift y + lift (s * x) div lift (prod_list ys)) *\n  lift (prod_list (y # ys)) =\n  lift (prod_list ys) * (lift y * (lift (t * x) div lift y)) +\n  lift y * (lift (prod_list ys) * (lift (s * x) div lift (prod_list ys)))\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "have \"\\<dots> = lift (prod_list ys * t * x + y * s * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (prod_list ys) * (lift y * (lift (t * x) div lift y)) +\n    lift y *\n    (lift (prod_list ys) * (lift (s * x) div lift (prod_list ys))) =\n    lift (prod_list ys * t * x + y * s * x)", "using assms unit"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  pairwise coprime (set ys)\n  distinct ys\n  ?y \\<in> set ys \\<Longrightarrow> is_unit (lift ?y)\n  lift y dvd ?b\n  lift (prod_list ys) dvd ?b\n\ngoal (1 subgoal):\n 1. lift (prod_list ys) * (lift y * (lift (t * x) div lift y)) +\n    lift y *\n    (lift (prod_list ys) * (lift (s * x) div lift (prod_list ys))) =\n    lift (prod_list ys * t * x + y * s * x)", "by (simp add: lift_mult lift_add algebra_simps)"], ["proof (state)\nthis:\n  lift (prod_list ys) * (lift y * (lift (t * x) div lift y)) +\n  lift y * (lift (prod_list ys) * (lift (s * x) div lift (prod_list ys))) =\n  lift (prod_list ys * t * x + y * s * x)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i<length (y # ys).\n      lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) *\n  lift (prod_list (y # ys)) =\n  lift (prod_list ys * t * x + y * s * x)", "have \"(\\<Sum>i<length (y # ys). lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) =\n                  lift ((s * y + t * prod_list ys) * x) div lift (prod_list (y#ys))\""], ["proof (prove)\nusing this:\n  (\\<Sum>i<length (y # ys).\n      lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) *\n  lift (prod_list (y # ys)) =\n  lift (prod_list ys * t * x + y * s * x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (y # ys).\n        lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) =\n    lift ((s * y + t * prod_list ys) * x) div lift (prod_list (y # ys))", "using unit"], ["proof (prove)\nusing this:\n  (\\<Sum>i<length (y # ys).\n      lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) *\n  lift (prod_list (y # ys)) =\n  lift (prod_list ys * t * x + y * s * x)\n  lift y dvd ?b\n  lift (prod_list ys) dvd ?b\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (y # ys).\n        lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) =\n    lift ((s * y + t * prod_list ys) * x) div lift (prod_list (y # ys))", "by (subst unit_eq_div2) (auto simp: lift_mult lift_add algebra_simps)"], ["proof (state)\nthis:\n  (\\<Sum>i<length (y # ys).\n      lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) =\n  lift ((s * y + t * prod_list ys) * x) div lift (prod_list (y # ys))\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length (y # ys).\n      lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) =\n  lift ((s * y + t * prod_list ys) * x) div lift (prod_list (y # ys))\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "have \"s * y + t * prod_list ys = gcd (prod_list ys) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s * y + t * prod_list ys = gcd (prod_list ys) y", "using bezout_coefficients_fst_snd[of y \"prod_list ys\"]"], ["proof (prove)\nusing this:\n  fst (bezout_coefficients y (prod_list ys)) * y +\n  snd (bezout_coefficients y (prod_list ys)) * prod_list ys =\n  gcd y (prod_list ys)\n\ngoal (1 subgoal):\n 1. s * y + t * prod_list ys = gcd (prod_list ys) y", "by (simp add: st gcd.commute)"], ["proof (state)\nthis:\n  s * y + t * prod_list ys = gcd (prod_list ys) y\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "also"], ["proof (state)\nthis:\n  s * y + t * prod_list ys = gcd (prod_list ys) y\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (prod_list ys) y = (1::'a)", "using \\<open>coprime (prod_list ys) y\\<close>"], ["proof (prove)\nusing this:\n  coprime (prod_list ys) y\n\ngoal (1 subgoal):\n 1. gcd (prod_list ys) y = (1::'a)", "by simp"], ["proof (state)\nthis:\n  gcd (prod_list ys) y = (1::'a)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])\n 2. \\<And>x xs xa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>x.\n           \\<lbrakk>pairwise coprime (set xs); distinct xs;\n            \\<And>y.\n               y \\<in> set xs \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n           \\<Longrightarrow> (\\<Sum>i<length xs.\n                                 lift (decompose x xs ! i) div\n                                 lift (xs ! i)) =\n                             lift x div lift (prod_list xs);\n        pairwise coprime (set (x # xs)); distinct (x # xs);\n        \\<And>y.\n           y \\<in> set (x # xs) \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length (x # xs).\n                             lift (decompose xa (x # xs) ! i) div\n                             lift ((x # xs) ! i)) =\n                         lift xa div lift (prod_list (x # xs))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i<length (y # ys).\n      lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) =\n  lift ((1::'a) * x) div lift (prod_list (y # ys))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>i<length (y # ys).\n      lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) =\n  lift ((1::'a) * x) div lift (prod_list (y # ys))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length (y # ys).\n        lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) =\n    lift x div lift (prod_list (y # ys))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<length (y # ys).\n      lift (decompose x (y # ys) ! i) div lift ((y # ys) ! i)) =\n  lift x div lift (prod_list (y # ys))\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>pairwise coprime (set [x]); distinct [x];\n        \\<And>y. y \\<in> set [x] \\<Longrightarrow> is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i<length [x].\n                             lift (decompose xa [x] ! i) div\n                             lift ([x] ! i)) =\n                         lift xa div lift (prod_list [x])", "qed simp_all"], ["", "lemma normalise_decomp:\n  fixes x y :: 'a and n :: nat\n  assumes \"is_unit (lift y)\"\n  defines \"xs \\<equiv> snd (normalise_decomp x y n)\"\n  shows   \"lift (fst (normalise_decomp x y n)) + (\\<Sum>i<n. from_decomp (xs!i) y (n-i)) =\n             lift x div lift y ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (fst (normalise_decomp x y n)) +\n    (\\<Sum>i<n. from_decomp (xs ! i) y (n - i)) =\n    lift x div lift y ^ n", "using assms"], ["proof (prove)\nusing this:\n  is_unit (lift y)\n  xs \\<equiv> snd (normalise_decomp x y n)\n\ngoal (1 subgoal):\n 1. lift (fst (normalise_decomp x y n)) +\n    (\\<Sum>i<n. from_decomp (xs ! i) y (n - i)) =\n    lift x div lift y ^ n", "unfolding xs_def"], ["proof (prove)\nusing this:\n  is_unit (lift y)\n  snd (normalise_decomp x y n) \\<equiv> snd (normalise_decomp x y n)\n\ngoal (1 subgoal):\n 1. lift (fst (normalise_decomp x y n)) +\n    (\\<Sum>i<n. from_decomp (snd (normalise_decomp x y n) ! i) y (n - i)) =\n    lift x div lift y ^ n", "proof (induction x y n rule: normalise_decomp.induct, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_unit (lift y) \\<Longrightarrow>\n       lift (fst (normalise_decomp x y 0)) +\n       (\\<Sum>i<0.\n           from_decomp (snd (normalise_decomp x y 0) ! i) y (0 - i)) =\n       lift x div lift y ^ 0\n 2. \\<And>x y n.\n       \\<lbrakk>is_unit (lift y) \\<Longrightarrow>\n                lift (fst (normalise_decomp (x div y) y n)) +\n                (\\<Sum>i<n.\n                    from_decomp (snd (normalise_decomp (x div y) y n) ! i) y\n                     (n - i)) =\n                lift (x div y) div lift y ^ n;\n        is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> lift (fst (normalise_decomp x y (Suc n))) +\n                         (\\<Sum>i<Suc n.\n                             from_decomp\n                              (snd (normalise_decomp x y (Suc n)) ! i) y\n                              (Suc n - i)) =\n                         lift x div lift y ^ Suc n", "case (2 x y n)"], ["proof (state)\nthis:\n  is_unit (lift y) \\<Longrightarrow>\n  lift (fst (normalise_decomp (x div y) y n)) +\n  (\\<Sum>i<n.\n      from_decomp (snd (normalise_decomp (x div y) y n) ! i) y (n - i)) =\n  lift (x div y) div lift y ^ n\n  is_unit (lift y)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_unit (lift y) \\<Longrightarrow>\n       lift (fst (normalise_decomp x y 0)) +\n       (\\<Sum>i<0.\n           from_decomp (snd (normalise_decomp x y 0) ! i) y (0 - i)) =\n       lift x div lift y ^ 0\n 2. \\<And>x y n.\n       \\<lbrakk>is_unit (lift y) \\<Longrightarrow>\n                lift (fst (normalise_decomp (x div y) y n)) +\n                (\\<Sum>i<n.\n                    from_decomp (snd (normalise_decomp (x div y) y n) ! i) y\n                     (n - i)) =\n                lift (x div y) div lift y ^ n;\n        is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> lift (fst (normalise_decomp x y (Suc n))) +\n                         (\\<Sum>i<Suc n.\n                             from_decomp\n                              (snd (normalise_decomp x y (Suc n)) ! i) y\n                              (Suc n - i)) =\n                         lift x div lift y ^ Suc n", "from 2(2)"], ["proof (chain)\npicking this:\n  is_unit (lift y)", "have unit: \"is_unit (lift y ^ n)\""], ["proof (prove)\nusing this:\n  is_unit (lift y)\n\ngoal (1 subgoal):\n 1. is_unit (lift y ^ n)", "by (simp add: is_unit_power_iff)"], ["proof (state)\nthis:\n  is_unit (lift y ^ n)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_unit (lift y) \\<Longrightarrow>\n       lift (fst (normalise_decomp x y 0)) +\n       (\\<Sum>i<0.\n           from_decomp (snd (normalise_decomp x y 0) ! i) y (0 - i)) =\n       lift x div lift y ^ 0\n 2. \\<And>x y n.\n       \\<lbrakk>is_unit (lift y) \\<Longrightarrow>\n                lift (fst (normalise_decomp (x div y) y n)) +\n                (\\<Sum>i<n.\n                    from_decomp (snd (normalise_decomp (x div y) y n) ! i) y\n                     (n - i)) =\n                lift (x div y) div lift y ^ n;\n        is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> lift (fst (normalise_decomp x y (Suc n))) +\n                         (\\<Sum>i<Suc n.\n                             from_decomp\n                              (snd (normalise_decomp x y (Suc n)) ! i) y\n                              (Suc n - i)) =\n                         lift x div lift y ^ Suc n", "obtain a b where ab: \"normalise_decomp (x div y) y n = (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        normalise_decomp (x div y) y n = (a, b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"normalise_decomp (x div y) y n\") simp_all"], ["proof (state)\nthis:\n  normalise_decomp (x div y) y n = (a, b)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_unit (lift y) \\<Longrightarrow>\n       lift (fst (normalise_decomp x y 0)) +\n       (\\<Sum>i<0.\n           from_decomp (snd (normalise_decomp x y 0) ! i) y (0 - i)) =\n       lift x div lift y ^ 0\n 2. \\<And>x y n.\n       \\<lbrakk>is_unit (lift y) \\<Longrightarrow>\n                lift (fst (normalise_decomp (x div y) y n)) +\n                (\\<Sum>i<n.\n                    from_decomp (snd (normalise_decomp (x div y) y n) ! i) y\n                     (n - i)) =\n                lift (x div y) div lift y ^ n;\n        is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> lift (fst (normalise_decomp x y (Suc n))) +\n                         (\\<Sum>i<Suc n.\n                             from_decomp\n                              (snd (normalise_decomp x y (Suc n)) ! i) y\n                              (Suc n - i)) =\n                         lift x div lift y ^ Suc n", "have \"lift (fst (normalise_decomp x y (Suc n))) + \n            (\\<Sum>i<Suc n. from_decomp (snd (normalise_decomp x y (Suc n)) ! i) y (Suc n - i)) =\n          lift a + (\\<Sum>i<n. from_decomp (b ! i) y (n - i)) + from_decomp (x mod y) y (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (fst (normalise_decomp x y (Suc n))) +\n    (\\<Sum>i<Suc n.\n        from_decomp (snd (normalise_decomp x y (Suc n)) ! i) y\n         (Suc n - i)) =\n    lift a + (\\<Sum>i<n. from_decomp (b ! i) y (n - i)) +\n    from_decomp (x mod y) y (Suc n)", "unfolding atLeast0LessThan[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (fst (normalise_decomp x y (Suc n))) +\n    (\\<Sum>i = 0..<Suc n.\n        from_decomp (snd (normalise_decomp x y (Suc n)) ! i) y\n         (Suc n - i)) =\n    lift a + (\\<Sum>i = 0..<n. from_decomp (b ! i) y (n - i)) +\n    from_decomp (x mod y) y (Suc n)", "apply (subst sum.atLeast_Suc_lessThan)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < Suc n\n 2. lift (fst (normalise_decomp x y (Suc n))) +\n    (from_decomp (snd (normalise_decomp x y (Suc n)) ! 0) y (Suc n - 0) +\n     (\\<Sum>i = Suc 0..<Suc n.\n         from_decomp (snd (normalise_decomp x y (Suc n)) ! i) y\n          (Suc n - i))) =\n    lift a + (\\<Sum>i = 0..<n. from_decomp (b ! i) y (n - i)) +\n    from_decomp (x mod y) y (Suc n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (fst (normalise_decomp x y (Suc n))) +\n    (from_decomp (snd (normalise_decomp x y (Suc n)) ! 0) y (Suc n - 0) +\n     (\\<Sum>i = Suc 0..<Suc n.\n         from_decomp (snd (normalise_decomp x y (Suc n)) ! i) y\n          (Suc n - i))) =\n    lift a + (\\<Sum>i = 0..<n. from_decomp (b ! i) y (n - i)) +\n    from_decomp (x mod y) y (Suc n)", "apply (subst sum.shift_bounds_Suc_ivl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (fst (normalise_decomp x y (Suc n))) +\n    (from_decomp (snd (normalise_decomp x y (Suc n)) ! 0) y (Suc n - 0) +\n     (\\<Sum>i = 0..<n.\n         from_decomp (snd (normalise_decomp x y (Suc n)) ! Suc i) y\n          (Suc n - Suc i))) =\n    lift a + (\\<Sum>i = 0..<n. from_decomp (b ! i) y (n - i)) +\n    from_decomp (x mod y) y (Suc n)", "apply (simp add: ab atLeast0LessThan ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lift (fst (normalise_decomp x y (Suc n))) +\n  (\\<Sum>i<Suc n.\n      from_decomp (snd (normalise_decomp x y (Suc n)) ! i) y (Suc n - i)) =\n  lift a + (\\<Sum>i<n. from_decomp (b ! i) y (n - i)) +\n  from_decomp (x mod y) y (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_unit (lift y) \\<Longrightarrow>\n       lift (fst (normalise_decomp x y 0)) +\n       (\\<Sum>i<0.\n           from_decomp (snd (normalise_decomp x y 0) ! i) y (0 - i)) =\n       lift x div lift y ^ 0\n 2. \\<And>x y n.\n       \\<lbrakk>is_unit (lift y) \\<Longrightarrow>\n                lift (fst (normalise_decomp (x div y) y n)) +\n                (\\<Sum>i<n.\n                    from_decomp (snd (normalise_decomp (x div y) y n) ! i) y\n                     (n - i)) =\n                lift (x div y) div lift y ^ n;\n        is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> lift (fst (normalise_decomp x y (Suc n))) +\n                         (\\<Sum>i<Suc n.\n                             from_decomp\n                              (snd (normalise_decomp x y (Suc n)) ! i) y\n                              (Suc n - i)) =\n                         lift x div lift y ^ Suc n", "also"], ["proof (state)\nthis:\n  lift (fst (normalise_decomp x y (Suc n))) +\n  (\\<Sum>i<Suc n.\n      from_decomp (snd (normalise_decomp x y (Suc n)) ! i) y (Suc n - i)) =\n  lift a + (\\<Sum>i<n. from_decomp (b ! i) y (n - i)) +\n  from_decomp (x mod y) y (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_unit (lift y) \\<Longrightarrow>\n       lift (fst (normalise_decomp x y 0)) +\n       (\\<Sum>i<0.\n           from_decomp (snd (normalise_decomp x y 0) ! i) y (0 - i)) =\n       lift x div lift y ^ 0\n 2. \\<And>x y n.\n       \\<lbrakk>is_unit (lift y) \\<Longrightarrow>\n                lift (fst (normalise_decomp (x div y) y n)) +\n                (\\<Sum>i<n.\n                    from_decomp (snd (normalise_decomp (x div y) y n) ! i) y\n                     (n - i)) =\n                lift (x div y) div lift y ^ n;\n        is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> lift (fst (normalise_decomp x y (Suc n))) +\n                         (\\<Sum>i<Suc n.\n                             from_decomp\n                              (snd (normalise_decomp x y (Suc n)) ! i) y\n                              (Suc n - i)) =\n                         lift x div lift y ^ Suc n", "have \"lift a + (\\<Sum>i<n. from_decomp (b ! i) y (n - i)) = \n               lift (x div y) div lift y ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift a + (\\<Sum>i<n. from_decomp (b ! i) y (n - i)) =\n    lift (x div y) div lift y ^ n", "using 2"], ["proof (prove)\nusing this:\n  is_unit (lift y) \\<Longrightarrow>\n  lift (fst (normalise_decomp (x div y) y n)) +\n  (\\<Sum>i<n.\n      from_decomp (snd (normalise_decomp (x div y) y n) ! i) y (n - i)) =\n  lift (x div y) div lift y ^ n\n  is_unit (lift y)\n\ngoal (1 subgoal):\n 1. lift a + (\\<Sum>i<n. from_decomp (b ! i) y (n - i)) =\n    lift (x div y) div lift y ^ n", "by (simp add: ab)"], ["proof (state)\nthis:\n  lift a + (\\<Sum>i<n. from_decomp (b ! i) y (n - i)) =\n  lift (x div y) div lift y ^ n\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_unit (lift y) \\<Longrightarrow>\n       lift (fst (normalise_decomp x y 0)) +\n       (\\<Sum>i<0.\n           from_decomp (snd (normalise_decomp x y 0) ! i) y (0 - i)) =\n       lift x div lift y ^ 0\n 2. \\<And>x y n.\n       \\<lbrakk>is_unit (lift y) \\<Longrightarrow>\n                lift (fst (normalise_decomp (x div y) y n)) +\n                (\\<Sum>i<n.\n                    from_decomp (snd (normalise_decomp (x div y) y n) ! i) y\n                     (n - i)) =\n                lift (x div y) div lift y ^ n;\n        is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> lift (fst (normalise_decomp x y (Suc n))) +\n                         (\\<Sum>i<Suc n.\n                             from_decomp\n                              (snd (normalise_decomp x y (Suc n)) ! i) y\n                              (Suc n - i)) =\n                         lift x div lift y ^ Suc n", "also"], ["proof (state)\nthis:\n  lift a + (\\<Sum>i<n. from_decomp (b ! i) y (n - i)) =\n  lift (x div y) div lift y ^ n\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_unit (lift y) \\<Longrightarrow>\n       lift (fst (normalise_decomp x y 0)) +\n       (\\<Sum>i<0.\n           from_decomp (snd (normalise_decomp x y 0) ! i) y (0 - i)) =\n       lift x div lift y ^ 0\n 2. \\<And>x y n.\n       \\<lbrakk>is_unit (lift y) \\<Longrightarrow>\n                lift (fst (normalise_decomp (x div y) y n)) +\n                (\\<Sum>i<n.\n                    from_decomp (snd (normalise_decomp (x div y) y n) ! i) y\n                     (n - i)) =\n                lift (x div y) div lift y ^ n;\n        is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> lift (fst (normalise_decomp x y (Suc n))) +\n                         (\\<Sum>i<Suc n.\n                             from_decomp\n                              (snd (normalise_decomp x y (Suc n)) ! i) y\n                              (Suc n - i)) =\n                         lift x div lift y ^ Suc n", "from 2(2) unit"], ["proof (chain)\npicking this:\n  is_unit (lift y)\n  is_unit (lift y ^ n)", "have \"(\\<dots> + from_decomp (x mod y) y (Suc n)) * lift y = \n      (lift ((x div y) * y + x mod y) div lift y ^ n)\" (is \"?A * _ = ?B div _\")"], ["proof (prove)\nusing this:\n  is_unit (lift y)\n  is_unit (lift y ^ n)\n\ngoal (1 subgoal):\n 1. (lift (x div y) div lift y ^ n + from_decomp (x mod y) y (Suc n)) *\n    lift y =\n    lift (x div y * y + x mod y) div lift y ^ n", "unfolding lift_add lift_mult"], ["proof (prove)\nusing this:\n  is_unit (lift y)\n  is_unit (lift y ^ n)\n\ngoal (1 subgoal):\n 1. (lift (x div y) div lift y ^ n + from_decomp (x mod y) y (Suc n)) *\n    lift y =\n    (lift (x div y) * lift y + lift (x mod y)) div lift y ^ n", "apply (subst div_add)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_unit (lift y); is_unit (lift y ^ n)\\<rbrakk>\n    \\<Longrightarrow> lift y ^ n dvd lift (x div y) * lift y\n 2. \\<lbrakk>is_unit (lift y); is_unit (lift y ^ n)\\<rbrakk>\n    \\<Longrightarrow> lift y ^ n dvd lift (x mod y)\n 3. \\<lbrakk>is_unit (lift y); is_unit (lift y ^ n)\\<rbrakk>\n    \\<Longrightarrow> (lift (x div y) div lift y ^ n +\n                       from_decomp (x mod y) y (Suc n)) *\n                      lift y =\n                      lift (x div y) * lift y div lift y ^ n +\n                      lift (x mod y) div lift y ^ n", "apply (auto simp add: from_decomp_def algebra_simps dvd_div_mult2_eq \n        unit_div_mult_swap dvd_div_mult2_eq[OF unit_imp_dvd] is_unit_mult_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (lift (x div y) div lift y ^ n + from_decomp (x mod y) y (Suc n)) *\n  lift y =\n  lift (x div y * y + x mod y) div lift y ^ n\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_unit (lift y) \\<Longrightarrow>\n       lift (fst (normalise_decomp x y 0)) +\n       (\\<Sum>i<0.\n           from_decomp (snd (normalise_decomp x y 0) ! i) y (0 - i)) =\n       lift x div lift y ^ 0\n 2. \\<And>x y n.\n       \\<lbrakk>is_unit (lift y) \\<Longrightarrow>\n                lift (fst (normalise_decomp (x div y) y n)) +\n                (\\<Sum>i<n.\n                    from_decomp (snd (normalise_decomp (x div y) y n) ! i) y\n                     (n - i)) =\n                lift (x div y) div lift y ^ n;\n        is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> lift (fst (normalise_decomp x y (Suc n))) +\n                         (\\<Sum>i<Suc n.\n                             from_decomp\n                              (snd (normalise_decomp x y (Suc n)) ! i) y\n                              (Suc n - i)) =\n                         lift x div lift y ^ Suc n", "with 2(2)"], ["proof (chain)\npicking this:\n  is_unit (lift y)\n  (lift (x div y) div lift y ^ n + from_decomp (x mod y) y (Suc n)) *\n  lift y =\n  lift (x div y * y + x mod y) div lift y ^ n", "have \"?A = \\<dots> div lift y\""], ["proof (prove)\nusing this:\n  is_unit (lift y)\n  (lift (x div y) div lift y ^ n + from_decomp (x mod y) y (Suc n)) *\n  lift y =\n  lift (x div y * y + x mod y) div lift y ^ n\n\ngoal (1 subgoal):\n 1. lift (x div y) div lift y ^ n + from_decomp (x mod y) y (Suc n) =\n    lift (x div y * y + x mod y) div lift y ^ n div lift y", "by (subst eq_commute, subst dvd_div_eq_mult) auto"], ["proof (state)\nthis:\n  lift (x div y) div lift y ^ n + from_decomp (x mod y) y (Suc n) =\n  lift (x div y * y + x mod y) div lift y ^ n div lift y\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_unit (lift y) \\<Longrightarrow>\n       lift (fst (normalise_decomp x y 0)) +\n       (\\<Sum>i<0.\n           from_decomp (snd (normalise_decomp x y 0) ! i) y (0 - i)) =\n       lift x div lift y ^ 0\n 2. \\<And>x y n.\n       \\<lbrakk>is_unit (lift y) \\<Longrightarrow>\n                lift (fst (normalise_decomp (x div y) y n)) +\n                (\\<Sum>i<n.\n                    from_decomp (snd (normalise_decomp (x div y) y n) ! i) y\n                     (n - i)) =\n                lift (x div y) div lift y ^ n;\n        is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> lift (fst (normalise_decomp x y (Suc n))) +\n                         (\\<Sum>i<Suc n.\n                             from_decomp\n                              (snd (normalise_decomp x y (Suc n)) ! i) y\n                              (Suc n - i)) =\n                         lift x div lift y ^ Suc n", "also"], ["proof (state)\nthis:\n  lift (x div y) div lift y ^ n + from_decomp (x mod y) y (Suc n) =\n  lift (x div y * y + x mod y) div lift y ^ n div lift y\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_unit (lift y) \\<Longrightarrow>\n       lift (fst (normalise_decomp x y 0)) +\n       (\\<Sum>i<0.\n           from_decomp (snd (normalise_decomp x y 0) ! i) y (0 - i)) =\n       lift x div lift y ^ 0\n 2. \\<And>x y n.\n       \\<lbrakk>is_unit (lift y) \\<Longrightarrow>\n                lift (fst (normalise_decomp (x div y) y n)) +\n                (\\<Sum>i<n.\n                    from_decomp (snd (normalise_decomp (x div y) y n) ! i) y\n                     (n - i)) =\n                lift (x div y) div lift y ^ n;\n        is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> lift (fst (normalise_decomp x y (Suc n))) +\n                         (\\<Sum>i<Suc n.\n                             from_decomp\n                              (snd (normalise_decomp x y (Suc n)) ! i) y\n                              (Suc n - i)) =\n                         lift x div lift y ^ Suc n", "from 2(2) unit"], ["proof (chain)\npicking this:\n  is_unit (lift y)\n  is_unit (lift y ^ n)", "have \"\\<dots> = ?B div (lift y ^ Suc n)\""], ["proof (prove)\nusing this:\n  is_unit (lift y)\n  is_unit (lift y ^ n)\n\ngoal (1 subgoal):\n 1. lift (x div y * y + x mod y) div lift y ^ n div lift y =\n    lift (x div y * y + x mod y) div lift y ^ Suc n", "by (subst is_unit_div_mult2_eq [symmetric]) (auto simp: mult_ac)"], ["proof (state)\nthis:\n  lift (x div y * y + x mod y) div lift y ^ n div lift y =\n  lift (x div y * y + x mod y) div lift y ^ Suc n\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_unit (lift y) \\<Longrightarrow>\n       lift (fst (normalise_decomp x y 0)) +\n       (\\<Sum>i<0.\n           from_decomp (snd (normalise_decomp x y 0) ! i) y (0 - i)) =\n       lift x div lift y ^ 0\n 2. \\<And>x y n.\n       \\<lbrakk>is_unit (lift y) \\<Longrightarrow>\n                lift (fst (normalise_decomp (x div y) y n)) +\n                (\\<Sum>i<n.\n                    from_decomp (snd (normalise_decomp (x div y) y n) ! i) y\n                     (n - i)) =\n                lift (x div y) div lift y ^ n;\n        is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> lift (fst (normalise_decomp x y (Suc n))) +\n                         (\\<Sum>i<Suc n.\n                             from_decomp\n                              (snd (normalise_decomp x y (Suc n)) ! i) y\n                              (Suc n - i)) =\n                         lift x div lift y ^ Suc n", "also"], ["proof (state)\nthis:\n  lift (x div y * y + x mod y) div lift y ^ n div lift y =\n  lift (x div y * y + x mod y) div lift y ^ Suc n\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_unit (lift y) \\<Longrightarrow>\n       lift (fst (normalise_decomp x y 0)) +\n       (\\<Sum>i<0.\n           from_decomp (snd (normalise_decomp x y 0) ! i) y (0 - i)) =\n       lift x div lift y ^ 0\n 2. \\<And>x y n.\n       \\<lbrakk>is_unit (lift y) \\<Longrightarrow>\n                lift (fst (normalise_decomp (x div y) y n)) +\n                (\\<Sum>i<n.\n                    from_decomp (snd (normalise_decomp (x div y) y n) ! i) y\n                     (n - i)) =\n                lift (x div y) div lift y ^ n;\n        is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> lift (fst (normalise_decomp x y (Suc n))) +\n                         (\\<Sum>i<Suc n.\n                             from_decomp\n                              (snd (normalise_decomp x y (Suc n)) ! i) y\n                              (Suc n - i)) =\n                         lift x div lift y ^ Suc n", "have \"x div y * y + x mod y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y * y + x mod y = x", "by (rule div_mult_mod_eq)"], ["proof (state)\nthis:\n  x div y * y + x mod y = x\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       is_unit (lift y) \\<Longrightarrow>\n       lift (fst (normalise_decomp x y 0)) +\n       (\\<Sum>i<0.\n           from_decomp (snd (normalise_decomp x y 0) ! i) y (0 - i)) =\n       lift x div lift y ^ 0\n 2. \\<And>x y n.\n       \\<lbrakk>is_unit (lift y) \\<Longrightarrow>\n                lift (fst (normalise_decomp (x div y) y n)) +\n                (\\<Sum>i<n.\n                    from_decomp (snd (normalise_decomp (x div y) y n) ! i) y\n                     (n - i)) =\n                lift (x div y) div lift y ^ n;\n        is_unit (lift y)\\<rbrakk>\n       \\<Longrightarrow> lift (fst (normalise_decomp x y (Suc n))) +\n                         (\\<Sum>i<Suc n.\n                             from_decomp\n                              (snd (normalise_decomp x y (Suc n)) ! i) y\n                              (Suc n - i)) =\n                         lift x div lift y ^ Suc n", "finally"], ["proof (chain)\npicking this:\n  lift (fst (normalise_decomp x y (Suc n))) +\n  (\\<Sum>i<Suc n.\n      from_decomp (snd (normalise_decomp x y (Suc n)) ! i) y (Suc n - i)) =\n  lift x div lift y ^ Suc n", "show ?case"], ["proof (prove)\nusing this:\n  lift (fst (normalise_decomp x y (Suc n))) +\n  (\\<Sum>i<Suc n.\n      from_decomp (snd (normalise_decomp x y (Suc n)) ! i) y (Suc n - i)) =\n  lift x div lift y ^ Suc n\n\ngoal (1 subgoal):\n 1. lift (fst (normalise_decomp x y (Suc n))) +\n    (\\<Sum>i<Suc n.\n        from_decomp (snd (normalise_decomp x y (Suc n)) ! i) y\n         (Suc n - i)) =\n    lift x div lift y ^ Suc n", "."], ["proof (state)\nthis:\n  lift (fst (normalise_decomp x y (Suc n))) +\n  (\\<Sum>i<Suc n.\n      from_decomp (snd (normalise_decomp x y (Suc n)) ! i) y (Suc n - i)) =\n  lift x div lift y ^ Suc n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       is_unit (lift y) \\<Longrightarrow>\n       lift (fst (normalise_decomp x y 0)) +\n       (\\<Sum>i<0.\n           from_decomp (snd (normalise_decomp x y 0) ! i) y (0 - i)) =\n       lift x div lift y ^ 0", "qed simp_all"], ["", "lemma lift_prod_list: \"lift (prod_list xs) = prod_list (map lift xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (prod_list xs) = prod_list (map lift xs)", "by (induction xs) (simp_all add: lift_mult)"], ["", "lemma lift_sum: \"lift (sum f A) = sum (\\<lambda>x. lift (f x)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (sum f A) = (\\<Sum>x\\<in>A. lift (f x))", "by (cases \"finite A\", induction A rule: finite_induct) (simp_all add: lift_add)"], ["", "lemma partial_fraction_decomposition:\n  fixes   ys :: \"('a \\<times> nat) list\"\n  defines \"ys' \\<equiv> map (\\<lambda>(x,n). x ^ Suc n) ys :: 'a list\"\n  assumes unit: \"\\<And>y. y \\<in> fst ` set ys \\<Longrightarrow> is_unit (lift y)\" \n  assumes coprime: \"pairwise coprime (set ys')\"\n  assumes distinct: \"distinct ys'\"\n  assumes \"partial_fraction_decomposition x ys = (a, zs)\"\n  shows   \"lift a + (\\<Sum>i<length ys. \\<Sum>j\\<le>snd (ys!i). \n                       from_decomp (zs!i!j) (fst (ys!i)) (snd (ys!i)+1 - j)) = \n             lift x div lift (prod_list ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')", "proof (cases \"ys = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')\n 2. ys \\<noteq> [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')", "assume [simp]: \"ys \\<noteq> []\""], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')\n 2. ys \\<noteq> [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')", "define n where \"n = length ys\""], ["proof (state)\nthis:\n  n = length ys\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')\n 2. ys \\<noteq> [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')", "have \"lift x div lift (prod_list ys') = (\\<Sum>i<n. lift (decompose x ys' ! i) div lift (ys' ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift x div lift (prod_list ys') =\n    (\\<Sum>i<n. lift (decompose x ys' ! i) div lift (ys' ! i))", "using assms"], ["proof (prove)\nusing this:\n  ys' \\<equiv> map (\\<lambda>(x, n). x ^ Suc n) ys\n  ?y \\<in> fst ` set ys \\<Longrightarrow> is_unit (lift ?y)\n  pairwise coprime (set ys')\n  distinct ys'\n  partial_fraction_decomposition x ys = (a, zs)\n\ngoal (1 subgoal):\n 1. lift x div lift (prod_list ys') =\n    (\\<Sum>i<n. lift (decompose x ys' ! i) div lift (ys' ! i))", "by (subst decompose [symmetric])\n      (force simp: lift_prod_list prod_list_zero_iff lift_power lift_mult o_def n_def \n        is_unit_mult_iff is_unit_power_iff)+"], ["proof (state)\nthis:\n  lift x div lift (prod_list ys') =\n  (\\<Sum>i<n. lift (decompose x ys' ! i) div lift (ys' ! i))\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')\n 2. ys \\<noteq> [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')", "also"], ["proof (state)\nthis:\n  lift x div lift (prod_list ys') =\n  (\\<Sum>i<n. lift (decompose x ys' ! i) div lift (ys' ! i))\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')\n 2. ys \\<noteq> [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')", "have \"\\<dots> = \n    (\\<Sum>i<n. lift (fst (normalise_decomp (decompose x ys' ! i) (fst (ys!i)) (snd (ys!i)+1)))) +\n    (\\<Sum>i<n. (\\<Sum>j\\<le>snd (ys!i). from_decomp (zs!i!j) (fst (ys!i)) (snd (ys!i)+1 - j)))\" (is \"_ = ?A + ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. lift (decompose x ys' ! i) div lift (ys' ! i)) =\n    (\\<Sum>i<n.\n        lift\n         (fst (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n                (snd (ys ! i) + 1)))) +\n    (\\<Sum>i<n.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j))", "proof (subst sum.distrib [symmetric], intro sum.cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<n} \\<Longrightarrow>\n       lift (decompose x ys' ! xa) div lift (ys' ! xa) =\n       lift\n        (fst (normalise_decomp (decompose x ys' ! xa) (fst (ys ! xa))\n               (snd (ys ! xa) + 1))) +\n       (\\<Sum>j\\<le>snd (ys ! xa).\n           from_decomp (zs ! xa ! j) (fst (ys ! xa))\n            (snd (ys ! xa) + 1 - j))", "case (1 i)"], ["proof (state)\nthis:\n  i \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<n} \\<Longrightarrow>\n       lift (decompose x ys' ! xa) div lift (ys' ! xa) =\n       lift\n        (fst (normalise_decomp (decompose x ys' ! xa) (fst (ys ! xa))\n               (snd (ys ! xa) + 1))) +\n       (\\<Sum>j\\<le>snd (ys ! xa).\n           from_decomp (zs ! xa ! j) (fst (ys ! xa))\n            (snd (ys ! xa) + 1 - j))", "from 1"], ["proof (chain)\npicking this:\n  i \\<in> {..<n}", "have \"lift (ys' ! i) = lift (fst (ys ! i)) ^ Suc (snd (ys ! i))\""], ["proof (prove)\nusing this:\n  i \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. lift (ys' ! i) = lift (fst (ys ! i)) ^ Suc (snd (ys ! i))", "by (simp add: ys'_def n_def lift_power lift_mult split: prod.split)"], ["proof (state)\nthis:\n  lift (ys' ! i) = lift (fst (ys ! i)) ^ Suc (snd (ys ! i))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<n} \\<Longrightarrow>\n       lift (decompose x ys' ! xa) div lift (ys' ! xa) =\n       lift\n        (fst (normalise_decomp (decompose x ys' ! xa) (fst (ys ! xa))\n               (snd (ys ! xa) + 1))) +\n       (\\<Sum>j\\<le>snd (ys ! xa).\n           from_decomp (zs ! xa ! j) (fst (ys ! xa))\n            (snd (ys ! xa) + 1 - j))", "also"], ["proof (state)\nthis:\n  lift (ys' ! i) = lift (fst (ys ! i)) ^ Suc (snd (ys ! i))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<n} \\<Longrightarrow>\n       lift (decompose x ys' ! xa) div lift (ys' ! xa) =\n       lift\n        (fst (normalise_decomp (decompose x ys' ! xa) (fst (ys ! xa))\n               (snd (ys ! xa) + 1))) +\n       (\\<Sum>j\\<le>snd (ys ! xa).\n           from_decomp (zs ! xa ! j) (fst (ys ! xa))\n            (snd (ys ! xa) + 1 - j))", "from 1"], ["proof (chain)\npicking this:\n  i \\<in> {..<n}", "have \"lift (decompose x ys' ! i) div \\<dots> = \n      lift (fst (normalise_decomp (decompose x ys' ! i) (fst (ys!i)) (snd (ys!i)+1))) +\n      (\\<Sum>j<Suc (snd (ys ! i)). from_decomp (snd (normalise_decomp (decompose x ys' ! i)\n             (fst (ys!i)) (snd (ys!i)+1)) ! j) (fst (ys ! i)) (snd (ys!i)+1 - j))\" (is \"_ = _ + ?C\")"], ["proof (prove)\nusing this:\n  i \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. lift (decompose x ys' ! i) div\n    lift (fst (ys ! i)) ^ Suc (snd (ys ! i)) =\n    lift\n     (fst (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n            (snd (ys ! i) + 1))) +\n    (\\<Sum>j<Suc (snd (ys ! i)).\n        from_decomp\n         (snd (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n                (snd (ys ! i) + 1)) !\n          j)\n         (fst (ys ! i)) (snd (ys ! i) + 1 - j))", "by (subst normalise_decomp [symmetric]) (simp_all add: n_def unit)"], ["proof (state)\nthis:\n  lift (decompose x ys' ! i) div lift (fst (ys ! i)) ^ Suc (snd (ys ! i)) =\n  lift\n   (fst (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n          (snd (ys ! i) + 1))) +\n  (\\<Sum>j<Suc (snd (ys ! i)).\n      from_decomp\n       (snd (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n              (snd (ys ! i) + 1)) !\n        j)\n       (fst (ys ! i)) (snd (ys ! i) + 1 - j))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<n} \\<Longrightarrow>\n       lift (decompose x ys' ! xa) div lift (ys' ! xa) =\n       lift\n        (fst (normalise_decomp (decompose x ys' ! xa) (fst (ys ! xa))\n               (snd (ys ! xa) + 1))) +\n       (\\<Sum>j\\<le>snd (ys ! xa).\n           from_decomp (zs ! xa ! j) (fst (ys ! xa))\n            (snd (ys ! xa) + 1 - j))", "also"], ["proof (state)\nthis:\n  lift (decompose x ys' ! i) div lift (fst (ys ! i)) ^ Suc (snd (ys ! i)) =\n  lift\n   (fst (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n          (snd (ys ! i) + 1))) +\n  (\\<Sum>j<Suc (snd (ys ! i)).\n      from_decomp\n       (snd (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n              (snd (ys ! i) + 1)) !\n        j)\n       (fst (ys ! i)) (snd (ys ! i) + 1 - j))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<n} \\<Longrightarrow>\n       lift (decompose x ys' ! xa) div lift (ys' ! xa) =\n       lift\n        (fst (normalise_decomp (decompose x ys' ! xa) (fst (ys ! xa))\n               (snd (ys ! xa) + 1))) +\n       (\\<Sum>j\\<le>snd (ys ! xa).\n           from_decomp (zs ! xa ! j) (fst (ys ! xa))\n            (snd (ys ! xa) + 1 - j))", "have \"?C = (\\<Sum>j\\<le>snd (ys!i). from_decomp (zs!i!j) (fst (ys!i)) (snd (ys!i)+1 - j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<Suc (snd (ys ! i)).\n        from_decomp\n         (snd (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n                (snd (ys ! i) + 1)) !\n          j)\n         (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    (\\<Sum>j\\<le>snd (ys ! i).\n        from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j))", "using assms 1"], ["proof (prove)\nusing this:\n  ys' \\<equiv> map (\\<lambda>(x, n). x ^ Suc n) ys\n  ?y \\<in> fst ` set ys \\<Longrightarrow> is_unit (lift ?y)\n  pairwise coprime (set ys')\n  distinct ys'\n  partial_fraction_decomposition x ys = (a, zs)\n  i \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<Suc (snd (ys ! i)).\n        from_decomp\n         (snd (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n                (snd (ys ! i) + 1)) !\n          j)\n         (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    (\\<Sum>j\\<le>snd (ys ! i).\n        from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j))", "by (intro sum.cong refl)\n         (auto simp: partial_fraction_decomposition_def case_prod_unfold Let_def o_def n_def\n               simp del: normalise_decomp.simps)"], ["proof (state)\nthis:\n  (\\<Sum>j<Suc (snd (ys ! i)).\n      from_decomp\n       (snd (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n              (snd (ys ! i) + 1)) !\n        j)\n       (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n  (\\<Sum>j\\<le>snd (ys ! i).\n      from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<n} \\<Longrightarrow>\n       lift (decompose x ys' ! xa) div lift (ys' ! xa) =\n       lift\n        (fst (normalise_decomp (decompose x ys' ! xa) (fst (ys ! xa))\n               (snd (ys ! xa) + 1))) +\n       (\\<Sum>j\\<le>snd (ys ! xa).\n           from_decomp (zs ! xa ! j) (fst (ys ! xa))\n            (snd (ys ! xa) + 1 - j))", "finally"], ["proof (chain)\npicking this:\n  lift (decompose x ys' ! i) div lift (ys' ! i) =\n  lift\n   (fst (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n          (snd (ys ! i) + 1))) +\n  (\\<Sum>j\\<le>snd (ys ! i).\n      from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j))", "show ?case"], ["proof (prove)\nusing this:\n  lift (decompose x ys' ! i) div lift (ys' ! i) =\n  lift\n   (fst (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n          (snd (ys ! i) + 1))) +\n  (\\<Sum>j\\<le>snd (ys ! i).\n      from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j))\n\ngoal (1 subgoal):\n 1. lift (decompose x ys' ! i) div lift (ys' ! i) =\n    lift\n     (fst (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n            (snd (ys ! i) + 1))) +\n    (\\<Sum>j\\<le>snd (ys ! i).\n        from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j))", "."], ["proof (state)\nthis:\n  lift (decompose x ys' ! i) div lift (ys' ! i) =\n  lift\n   (fst (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n          (snd (ys ! i) + 1))) +\n  (\\<Sum>j\\<le>snd (ys ! i).\n      from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i<n. lift (decompose x ys' ! i) div lift (ys' ! i)) =\n  (\\<Sum>i<n.\n      lift\n       (fst (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n              (snd (ys ! i) + 1)))) +\n  (\\<Sum>i<n.\n      \\<Sum>j\\<le>snd (ys ! i).\n         from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j))\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')\n 2. ys \\<noteq> [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. lift (decompose x ys' ! i) div lift (ys' ! i)) =\n  (\\<Sum>i<n.\n      lift\n       (fst (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n              (snd (ys ! i) + 1)))) +\n  (\\<Sum>i<n.\n      \\<Sum>j\\<le>snd (ys ! i).\n         from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j))\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')\n 2. ys \\<noteq> [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')", "from assms"], ["proof (chain)\npicking this:\n  ys' \\<equiv> map (\\<lambda>(x, n). x ^ Suc n) ys\n  ?y \\<in> fst ` set ys \\<Longrightarrow> is_unit (lift ?y)\n  pairwise coprime (set ys')\n  distinct ys'\n  partial_fraction_decomposition x ys = (a, zs)", "have \"?A = lift a\""], ["proof (prove)\nusing this:\n  ys' \\<equiv> map (\\<lambda>(x, n). x ^ Suc n) ys\n  ?y \\<in> fst ` set ys \\<Longrightarrow> is_unit (lift ?y)\n  pairwise coprime (set ys')\n  distinct ys'\n  partial_fraction_decomposition x ys = (a, zs)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        lift\n         (fst (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n                (snd (ys ! i) + 1)))) =\n    lift a", "by (auto simp: partial_fraction_decomposition_def o_def sum_list_sum_nth atLeast0LessThan\n                   case_prod_unfold Let_def lift_sum n_def intro!: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      lift\n       (fst (normalise_decomp (decompose x ys' ! i) (fst (ys ! i))\n              (snd (ys ! i) + 1)))) =\n  lift a\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')\n 2. ys \\<noteq> [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')", "finally"], ["proof (chain)\npicking this:\n  lift x div lift (prod_list ys') =\n  lift a +\n  (\\<Sum>i<n.\n      \\<Sum>j\\<le>snd (ys ! i).\n         from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j))", "show ?thesis"], ["proof (prove)\nusing this:\n  lift x div lift (prod_list ys') =\n  lift a +\n  (\\<Sum>i<n.\n      \\<Sum>j\\<le>snd (ys ! i).\n         from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j))\n\ngoal (1 subgoal):\n 1. lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')", "by (simp add: n_def)"], ["proof (state)\nthis:\n  lift a +\n  (\\<Sum>i<length ys.\n      \\<Sum>j\\<le>snd (ys ! i).\n         from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n  lift x div lift (prod_list ys')\n\ngoal (1 subgoal):\n 1. ys = [] \\<Longrightarrow>\n    lift a +\n    (\\<Sum>i<length ys.\n        \\<Sum>j\\<le>snd (ys ! i).\n           from_decomp (zs ! i ! j) (fst (ys ! i)) (snd (ys ! i) + 1 - j)) =\n    lift x div lift (prod_list ys')", "qed (insert assms, simp add: partial_fraction_decomposition_def)"], ["", "end"], ["", "subsection \\<open>Specific results for polynomials\\<close>"], ["", "definition divmod_field_poly :: \"'a :: field poly \\<Rightarrow> 'a poly \\<Rightarrow> 'a poly \\<times> 'a poly\" where\n  \"divmod_field_poly p q = (p div q, p mod q)\""], ["", "lemma divmod_field_poly_code [code]:\n  \"divmod_field_poly p q =\n   (let cg = coeffs q\n    in if cg = [] then (0, p)\n       else let cf = coeffs p; ilc = inverse (last cg);\n                ch = map ((*) ilc) cg;\n                (q, r) =\n                  divmod_poly_one_main_list [] (rev cf) (rev ch)\n                  (1 + length cf - length cg)\n            in (poly_of_list (map ((*) ilc) q), poly_of_list (rev r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divmod_field_poly p q =\n    (let cg = coeffs q\n     in if cg = [] then (0, p)\n        else let cf = coeffs p; ilc = inverse (last cg);\n                 ch = map ((*) ilc) cg;\n                 (q, r) =\n                   divmod_poly_one_main_list [] (rev cf) (rev ch)\n                    (1 + length cf - length cg)\n             in (poly_of_list (map ((*) ilc) q), poly_of_list (rev r)))", "unfolding divmod_field_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p div q, p mod q) =\n    (let cg = coeffs q\n     in if cg = [] then (0, p)\n        else let cf = coeffs p; ilc = inverse (last cg);\n                 ch = map ((*) ilc) cg;\n                 (q, r) =\n                   divmod_poly_one_main_list [] (rev cf) (rev ch)\n                    (1 + length cf - length cg)\n             in (poly_of_list (map ((*) ilc) q), poly_of_list (rev r)))", "by (rule pdivmod_via_divmod_list)"], ["", "definition normalise_decomp_poly :: \"'a::field_gcd poly \\<Rightarrow> 'a poly \\<Rightarrow> nat \\<Rightarrow> 'a poly \\<times> 'a poly list\" \n  where [simp]: \"normalise_decomp_poly (p :: _ poly) q n = normalise_decomp p q n\""], ["", "lemma normalise_decomp_poly_code [code]:\n  \"normalise_decomp_poly x y 0 = (x, [])\"\n  \"normalise_decomp_poly x y (Suc n) = (\n     let (x', r) = divmod_field_poly x y;\n         (z, rs) = normalise_decomp_poly x' y n\n     in  (z, r # rs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalise_decomp_poly x y 0 = (x, []) &&&\n    normalise_decomp_poly x y (Suc n) =\n    (let (x', r) = divmod_field_poly x y;\n         (z, rs) = normalise_decomp_poly x' y n\n     in (z, r # rs))", "by (simp_all add: divmod_field_poly_def)"], ["", "definition poly_pfd_simple where\n  \"poly_pfd_simple x cs = (if cs = [] then (x, []) else\n     (let zs = [let (c, n) = cs ! i\n                in  normalise_decomp_poly (decompose x \n                      (map (\\<lambda>(c,n). [:1,-c:] ^ Suc n) cs) ! i) [:1,-c:] (n+1). \n                i \\<leftarrow> [0..<length cs]]\n      in  (sum_list (map fst zs), map (map (\\<lambda>p. coeff p 0) \\<circ> snd) zs)))\""], ["", "lemma poly_pfd_simple_code [code]:\n  \"poly_pfd_simple x cs = \n    (if cs = [] then (x, []) else\n       let zs = zip_with (\\<lambda>(c,n) decomp. normalise_decomp_poly decomp [:1,-c:] (n+1))\n                  cs (decompose x (map (\\<lambda>(c,n). [:1,-c:] ^ Suc n) cs))\n      in  (sum_list (map fst zs), map (map (\\<lambda>p. coeff p 0) \\<circ> snd) zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_pfd_simple x cs =\n    (if cs = [] then (x, [])\n     else let zs = zip_with\n                    (\\<lambda>(c, n) decomp.\n                        normalise_decomp_poly decomp [:1::'a, - c:] (n + 1))\n                    cs (decompose x\n                         (map (\\<lambda>(c, n). [:1::'a, - c:] ^ Suc n) cs))\n          in (sum_list (map fst zs),\n              map (map (\\<lambda>p. coeff p 0) \\<circ> snd) zs))", "unfolding poly_pfd_simple_def zip_with_altdef'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if cs = [] then (x, [])\n     else let zs = map (\\<lambda>i.\n                           let (c, n) = cs ! i\n                           in normalise_decomp_poly\n                               (decompose x\n                                 (map (\\<lambda>(c, n).\n    [:1::'a, - c:] ^ Suc n)\n                                   cs) !\n                                i)\n                               [:1::'a, - c:] (n + 1))\n                    [0..<length cs]\n          in (sum_list (map fst zs),\n              map (map (\\<lambda>p. coeff p 0) \\<circ> snd) zs)) =\n    (if cs = [] then (x, [])\n     else let zs = map (\\<lambda>i.\n                           (case cs ! i of\n                            (c, n) \\<Rightarrow>\n                              \\<lambda>decomp.\n                                 normalise_decomp_poly decomp [:1::'a, - c:]\n                                  (n + 1))\n                            (decompose x\n                              (map (\\<lambda>(c, n). [:1::'a, - c:] ^ Suc n)\n                                cs) !\n                             i))\n                    [0..<\n                     min (length cs)\n                      (length\n                        (decompose x\n                          (map (\\<lambda>(c, n). [:1::'a, - c:] ^ Suc n)\n                            cs)))]\n          in (sum_list (map fst zs),\n              map (map (\\<lambda>p. coeff p 0) \\<circ> snd) zs))", "by (simp add: Let_def case_prod_unfold)"], ["", "lemma fst_poly_pfd_simple: \n  \"fst (poly_pfd_simple x cs) = \n      fst (partial_fraction_decomposition x (map (\\<lambda>(c,n). ([:1,-c:],n)) cs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (poly_pfd_simple x cs) =\n    fst (partial_fraction_decomposition x\n          (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs))", "by (auto simp: poly_pfd_simple_def partial_fraction_decomposition_def o_def\n             case_prod_unfold Let_def sum_list_sum_nth intro!: sum.cong)"], ["", "lemma const_polyI: \"degree p = 0 \\<Longrightarrow> [:coeff p 0:] = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = 0 \\<Longrightarrow> [:coeff p 0:] = p", "by (elim degree_eq_zeroE) simp_all"], ["", "lemma snd_poly_pfd_simple:\n  \"map (map (\\<lambda>c. [:c :: 'a :: field_gcd:])) (snd (poly_pfd_simple x cs)) = \n      (snd (partial_fraction_decomposition x (map (\\<lambda>(c,n). ([:1,-c:],n)) cs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map (\\<lambda>c. [:c:])) (snd (poly_pfd_simple x cs)) =\n    snd (partial_fraction_decomposition x\n          (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (map (\\<lambda>c. [:c:])) (snd (poly_pfd_simple x cs)) =\n    snd (partial_fraction_decomposition x\n          (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs))", "have \"snd (poly_pfd_simple x cs) = map (map (\\<lambda>p. coeff p 0))\n          (snd (partial_fraction_decomposition x (map (\\<lambda>(c,n). ([:1,-c:],n)) cs)))\"\n       (is \"_ = map ?f ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (poly_pfd_simple x cs) =\n    map (map (\\<lambda>p. coeff p 0))\n     (snd (partial_fraction_decomposition x\n            (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)))", "by (auto simp: poly_pfd_simple_def partial_fraction_decomposition_def o_def\n               case_prod_unfold Let_def sum_list_sum_nth intro!: sum.cong)"], ["proof (state)\nthis:\n  snd (poly_pfd_simple x cs) =\n  map (map (\\<lambda>p. coeff p 0))\n   (snd (partial_fraction_decomposition x\n          (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)))\n\ngoal (1 subgoal):\n 1. map (map (\\<lambda>c. [:c:])) (snd (poly_pfd_simple x cs)) =\n    snd (partial_fraction_decomposition x\n          (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs))", "also"], ["proof (state)\nthis:\n  snd (poly_pfd_simple x cs) =\n  map (map (\\<lambda>p. coeff p 0))\n   (snd (partial_fraction_decomposition x\n          (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)))\n\ngoal (1 subgoal):\n 1. map (map (\\<lambda>c. [:c:])) (snd (poly_pfd_simple x cs)) =\n    snd (partial_fraction_decomposition x\n          (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs))", "have \"map (map (\\<lambda>c. [:c:])) (map ?f ?B) = map (map (\\<lambda>x. x)) ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map (\\<lambda>c. [:c:]))\n     (map (map (\\<lambda>p. coeff p 0))\n       (snd (partial_fraction_decomposition x\n              (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)))) =\n    map (map (\\<lambda>x. x))\n     (snd (partial_fraction_decomposition x\n            (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)))", "unfolding map_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map (\\<lambda>x. [:coeff x 0:]))\n     (snd (partial_fraction_decomposition x\n            (map (\\<lambda>(c, y). ([:1::'a, - c:], y)) cs))) =\n    map (map (\\<lambda>x. x))\n     (snd (partial_fraction_decomposition x\n            (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)))", "proof (intro map_cong refl const_polyI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> set (snd (partial_fraction_decomposition x\n                                    (map\n(\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)));\n        xaa \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> degree xaa = 0", "case (1 ys y)"], ["proof (state)\nthis:\n  ys \\<in> set (snd (partial_fraction_decomposition x\n                      (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)))\n  y \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> set (snd (partial_fraction_decomposition x\n                                    (map\n(\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)));\n        xaa \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> degree xaa = 0", "from 1"], ["proof (chain)\npicking this:\n  ys \\<in> set (snd (partial_fraction_decomposition x\n                      (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)))\n  y \\<in> set ys", "obtain i where i: \"i < length cs\"\n      \"ys = snd (partial_fraction_decomposition x (map (\\<lambda>(c,n). ([:1,-c:],n)) cs)) ! i\""], ["proof (prove)\nusing this:\n  ys \\<in> set (snd (partial_fraction_decomposition x\n                      (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)))\n  y \\<in> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length cs;\n         ys =\n         snd (partial_fraction_decomposition x\n               (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)) !\n         i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length cs\n  ys =\n  snd (partial_fraction_decomposition x\n        (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)) !\n  i\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> set (snd (partial_fraction_decomposition x\n                                    (map\n(\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)));\n        xaa \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> degree xaa = 0", "with 1"], ["proof (chain)\npicking this:\n  ys \\<in> set (snd (partial_fraction_decomposition x\n                      (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)))\n  y \\<in> set ys\n  i < length cs\n  ys =\n  snd (partial_fraction_decomposition x\n        (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)) !\n  i", "have \"euclidean_size y < euclidean_size (fst (map (\\<lambda>(c,n). ([:1,-c:],n)) cs ! i))\""], ["proof (prove)\nusing this:\n  ys \\<in> set (snd (partial_fraction_decomposition x\n                      (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)))\n  y \\<in> set ys\n  i < length cs\n  ys =\n  snd (partial_fraction_decomposition x\n        (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)) !\n  i\n\ngoal (1 subgoal):\n 1. euclidean_size y\n    < euclidean_size\n       (fst (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs ! i))", "by (intro size_partial_fraction_decomposition[of i _ _ x])\n         (auto simp: case_prod_unfold Let_def)"], ["proof (state)\nthis:\n  euclidean_size y\n  < euclidean_size (fst (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs ! i))\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> set (snd (partial_fraction_decomposition x\n                                    (map\n(\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)));\n        xaa \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> degree xaa = 0", "with i(1)"], ["proof (chain)\npicking this:\n  i < length cs\n  euclidean_size y\n  < euclidean_size (fst (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs ! i))", "have \"euclidean_size y < 2\""], ["proof (prove)\nusing this:\n  i < length cs\n  euclidean_size y\n  < euclidean_size (fst (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs ! i))\n\ngoal (1 subgoal):\n 1. euclidean_size y < 2", "by (auto simp: case_prod_unfold Let_def euclidean_size_poly_def split: if_split_asm)"], ["proof (state)\nthis:\n  euclidean_size y < 2\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> set (snd (partial_fraction_decomposition x\n                                    (map\n(\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)));\n        xaa \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> degree xaa = 0", "thus ?case"], ["proof (prove)\nusing this:\n  euclidean_size y < 2\n\ngoal (1 subgoal):\n 1. degree y = 0", "by (cases y rule: pCons_cases) (auto simp: euclidean_size_poly_def split: if_split_asm)"], ["proof (state)\nthis:\n  degree y = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (map (\\<lambda>c. [:c:]))\n   (map (map (\\<lambda>p. coeff p 0))\n     (snd (partial_fraction_decomposition x\n            (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)))) =\n  map (map (\\<lambda>x. x))\n   (snd (partial_fraction_decomposition x\n          (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs)))\n\ngoal (1 subgoal):\n 1. map (map (\\<lambda>c. [:c:])) (snd (poly_pfd_simple x cs)) =\n    snd (partial_fraction_decomposition x\n          (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs))", "finally"], ["proof (chain)\npicking this:\n  map (map (\\<lambda>c. [:c:])) (snd (poly_pfd_simple x cs)) =\n  map (map (\\<lambda>x. x))\n   (snd (partial_fraction_decomposition x\n          (map (\\<lambda>a.\n                   case a of (c, n) \\<Rightarrow> ([:1::'a, - c:], n))\n            cs)))", "show ?thesis"], ["proof (prove)\nusing this:\n  map (map (\\<lambda>c. [:c:])) (snd (poly_pfd_simple x cs)) =\n  map (map (\\<lambda>x. x))\n   (snd (partial_fraction_decomposition x\n          (map (\\<lambda>a.\n                   case a of (c, n) \\<Rightarrow> ([:1::'a, - c:], n))\n            cs)))\n\ngoal (1 subgoal):\n 1. map (map (\\<lambda>c. [:c:])) (snd (poly_pfd_simple x cs)) =\n    snd (partial_fraction_decomposition x\n          (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs))", "by simp"], ["proof (state)\nthis:\n  map (map (\\<lambda>c. [:c:])) (snd (poly_pfd_simple x cs)) =\n  snd (partial_fraction_decomposition x\n        (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_pfd_simple:\n  \"partial_fraction_decomposition x (map (\\<lambda>(c,n). ([:1,-c:],n)) cs) =\n         (fst (poly_pfd_simple x cs), map (map (\\<lambda>c. [:c:])) (snd (poly_pfd_simple x cs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_fraction_decomposition x\n     (map (\\<lambda>(c, n). ([:1::'a, - c:], n)) cs) =\n    (fst (poly_pfd_simple x cs),\n     map (map (\\<lambda>c. [:c:])) (snd (poly_pfd_simple x cs)))", "by (simp add: fst_poly_pfd_simple snd_poly_pfd_simple)"], ["", "end"]]}