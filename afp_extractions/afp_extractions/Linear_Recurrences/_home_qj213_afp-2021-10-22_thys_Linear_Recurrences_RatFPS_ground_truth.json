{"file_name": "/home/qj213/afp-2021-10-22/thys/Linear_Recurrences/RatFPS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Linear_Recurrences", "problem_names": ["lemma coeff_0_mult: \"coeff (p * q) 0 = coeff p 0 * coeff q 0\"", "lemma coeff_0_div: \n  assumes \"coeff p 0 \\<noteq> 0\" \n  assumes \"(q :: 'a :: field poly) dvd p\"\n  shows   \"coeff (p div q) 0 = coeff p 0 div coeff q 0\"", "lemma coeff_0_add_fract_nonzero:\n  assumes \"coeff (snd (quot_of_fract x)) 0 \\<noteq> 0\" \"coeff (snd (quot_of_fract y)) 0 \\<noteq> 0\"\n  shows   \"coeff (snd (quot_of_fract (x + y))) 0 \\<noteq> 0\"", "lemma coeff_0_normalize_quot_nonzero [simp]:\n  assumes \"coeff (snd x) 0 \\<noteq> 0\"\n  shows   \"coeff (snd (normalize_quot x)) 0 \\<noteq> 0\"", "lemma constant_term_denominator_nonzero_imp_constant_term_denominator_div_gcd_nonzero:\n  \"constant_term (denominator x div gcd a (denominator x)) \\<noteq> 0\"\n  if \"constant_term (denominator x) \\<noteq> 0\"", "lemma ratfps_nth_aux_correct: \"ratfps_nth_aux p n = natfun_inverse (fps_of_poly p) n\"", "lemma RatFPS_parametric: \"(rel_prod (=) (=) ===> (=))\n  (\\<lambda>(p,q). if coeff q 0 = 0 then 0 else quot_to_fract (p, q))\n  (\\<lambda>(p,q). if coeff q 0 = 0 then 0 else quot_to_fract (p, q))\"", "lemma normalize_quot_quot_of_fract [simp]: \n  \"normalize_quot (quot_of_fract x) = quot_of_fract x\"", "lemma quot_to_ratfps_quot_of_ratfps [code abstype]:\n  \"quot_to_ratfps (quot_of_ratfps x) = x\"", "lemma coeff_0_snd_quot_of_ratfps_nonzero [simp]: \n  \"coeff (snd (quot_of_ratfps x)) 0 \\<noteq> 0\"", "lemma quot_of_ratfps_quot_to_ratfps:\n  \"coeff (snd x) 0 \\<noteq> 0 \\<Longrightarrow> x \\<in> normalized_fracts \\<Longrightarrow> quot_of_ratfps (quot_to_ratfps x) = x\"", "lemma quot_of_ratfps_0 [simp, code abstract]: \"quot_of_ratfps 0 = (0, 1)\"", "lemma quot_of_ratfps_1 [simp, code abstract]: \"quot_of_ratfps 1 = (1, 1)\"", "lemma ratfps_of_poly_code [code abstract]:\n  \"quot_of_ratfps (ratfps_of_poly p) = (p, 1)\"", "lemmas zero_ratfps_code = quot_of_ratfps_0", "lemmas one_ratfps_code = quot_of_ratfps_1", "lemma uminus_ratfps_code [code abstract]: \n  \"quot_of_ratfps (- x) = (let (a, b) = quot_of_ratfps x in (-a, b))\"", "lemma plus_ratfps_code [code abstract]:\n  \"quot_of_ratfps (x + y) = \n     (let (a,b) = quot_of_ratfps x; (c,d) = quot_of_ratfps y\n      in  normalize_quot (a * d + b * c, b * d))\"", "lemma minus_ratfps_code [code abstract]:\n  \"quot_of_ratfps (x - y) = \n     (let (a,b) = quot_of_ratfps x; (c,d) = quot_of_ratfps y\n      in  normalize_quot (a * d - b * c, b * d))\"", "lemma times_ratfps_code [code abstract]:\n  \"quot_of_ratfps (x * y) = \n     (let (a,b) = quot_of_ratfps x; (c,d) = quot_of_ratfps y;\n          (e,f) = normalize_quot (a,d); (g,h) = normalize_quot (c,b)\n      in  (e*g, f*h))\"", "lemma ratfps_nth_code [code]:\n  \"ratfps_nth x n = \n    (let (a,b) = quot_of_ratfps x\n     in  \\<Sum>i = 0..n. coeff a i * ratfps_nth_aux b (n - i))\"", "lemma ratfps_subdegree_code [code]:\n  \"ratfps_subdegree x = poly_subdegree (fst (quot_of_ratfps x))\"", "lemma ratfps_inverse_code [code abstract]:\n  \"quot_of_ratfps (inverse x) = \n     (let (a,b) = quot_of_ratfps x\n      in  if coeff a 0 = 0 then (0, 1)\n          else let u = unit_factor a in (b div u, a div u))\"", "lemma quot_of_fract_eq_iff [simp]: \"quot_of_fract x = quot_of_fract y \\<longleftrightarrow> x = y\"", "lemma equal_ratfps_code [code]: \"HOL.equal x y \\<longleftrightarrow> quot_of_ratfps x = quot_of_ratfps y\"", "lemma fps_of_poly_quot_normalize_quot [simp]:\n  \"fps_of_poly (fst (normalize_quot x)) / fps_of_poly (snd (normalize_quot x)) =\n     fps_of_poly (fst x) / fps_of_poly (snd x)\"\n  if \"(snd x :: 'a :: field_gcd poly) \\<noteq> 0\"", "lemma fps_of_poly_quot_normalize_quot' [simp]:\n  \"fps_of_poly (fst (normalize_quot x)) / fps_of_poly (snd (normalize_quot x)) =\n     fps_of_poly (fst x) / fps_of_poly (snd x)\"\n  if \"coeff (snd x) 0 \\<noteq> (0 :: 'a :: field_gcd)\"", "lemma fps_of_ratfps_altdef: \n  \"fps_of_ratfps x = (case quot_of_ratfps x of (a, b) \\<Rightarrow> fps_of_poly a / fps_of_poly b)\"", "lemma fps_of_ratfps_ratfps_of_poly [simp]: \"fps_of_ratfps (ratfps_of_poly p) = fps_of_poly p\"", "lemma fps_of_ratfps_0 [simp]: \"fps_of_ratfps 0 = 0\"", "lemma fps_of_ratfps_1 [simp]: \"fps_of_ratfps 1 = 1\"", "lemma fps_of_ratfps_uminus [simp]: \"fps_of_ratfps (-x) = - fps_of_ratfps x\"", "lemma fps_of_ratfps_add [simp]: \"fps_of_ratfps (x + y) = fps_of_ratfps x + fps_of_ratfps y\"", "lemma fps_of_ratfps_diff [simp]: \"fps_of_ratfps (x - y) = fps_of_ratfps x - fps_of_ratfps y\"", "lemma is_unit_div_div_commute: \"is_unit b \\<Longrightarrow> is_unit c \\<Longrightarrow> a div b div c = a div c div b\"", "lemma fps_of_ratfps_mult [simp]: \"fps_of_ratfps (x * y) = fps_of_ratfps x * fps_of_ratfps y\"", "lemma div_const_unit_poly: \"is_unit c \\<Longrightarrow> p div [:c:] = smult (1 div c) p\"", "lemma normalize_field: \n  \"normalize (x :: 'a :: {normalization_semidom,field}) = (if x = 0 then 0 else 1)\"", "lemma unit_factor_field [simp]:\n  \"unit_factor (x :: 'a :: {normalization_semidom,field}) = x\"", "lemma fps_of_poly_normalize_field: \n  \"fps_of_poly (normalize (p :: 'a :: {field, normalization_semidom} poly)) = \n     fps_of_poly p * fps_const (inverse (lead_coeff p))\"", "lemma unit_factor_poly_altdef: \"unit_factor p = monom (unit_factor (lead_coeff p)) 0\"", "lemma div_const_poly: \"p div [:c::'a::field:] = smult (inverse c) p\"", "lemma fps_of_ratfps_inverse [simp]: \"fps_of_ratfps (inverse x) = inverse (fps_of_ratfps x)\"", "lemma ratfps_nth_altdef: \"ratfps_nth x n = fps_of_ratfps x $ n\"", "lemma fps_of_ratfps_is_unit: \"fps_of_ratfps a $ 0 \\<noteq> 0 \\<longleftrightarrow> ratfps_nth a 0 \\<noteq> 0\"", "lemma ratfps_nth_0 [simp]: \"ratfps_nth 0 n = 0\"", "lemma fps_of_ratfps_cases:\n  obtains p q where \"coeff q 0 \\<noteq> 0\" \"fps_of_ratfps f = fps_of_poly p / fps_of_poly q\"", "lemma fps_of_ratfps_cutoff [simp]:\n    \"fps_of_poly (ratfps_cutoff n x) = fps_cutoff n (fps_of_ratfps x)\"", "lemma subdegree_fps_of_ratfps:\n  \"subdegree (fps_of_ratfps x) = ratfps_subdegree x\"", "lemma ratfps_subdegree_altdef:\n  \"ratfps_subdegree x = subdegree (fps_of_ratfps x)\"", "lemma fps_zero_code [code]: \"0 = fps_of_ratfps 0\"", "lemma fps_one_code [code]: \"1 = fps_of_ratfps 1\"", "lemma fps_const_code [code]: \"fps_const c = fps_of_poly [:c:]\"", "lemma fps_of_poly_code [code]: \"fps_of_poly p = fps_of_ratfps (ratfps_of_poly p)\"", "lemma fps_X_code [code]: \"fps_X = fps_of_ratfps (ratfps_of_poly [:0,1:])\"", "lemma fps_nth_code [code]: \"fps_nth (fps_of_ratfps x) n = ratfps_nth x n\"", "lemma fps_uminus_code [code]: \"- fps_of_ratfps x = fps_of_ratfps (-x)\"", "lemma fps_add_code [code]: \"fps_of_ratfps x + fps_of_ratfps y = fps_of_ratfps (x + y)\"", "lemma fps_diff_code [code]: \"fps_of_ratfps x - fps_of_ratfps y = fps_of_ratfps (x - y)\"", "lemma fps_mult_code [code]: \"fps_of_ratfps x * fps_of_ratfps y = fps_of_ratfps (x * y)\"", "lemma fps_inverse_code [code]: \"inverse (fps_of_ratfps x) = fps_of_ratfps (inverse x)\"", "lemma fps_cutoff_code [code]: \"fps_cutoff n (fps_of_ratfps x) = fps_of_poly (ratfps_cutoff n x)\"", "lemmas subdegree_code [code] = subdegree_fps_of_ratfps", "lemma fractrel_normalize_quot:\n  \"fractrel p p \\<Longrightarrow> fractrel q q \\<Longrightarrow> \n     fractrel (normalize_quot p) (normalize_quot q) \\<longleftrightarrow> fractrel p q\"", "lemma fps_of_ratfps_eq_iff [simp]:\n  \"fps_of_ratfps p = fps_of_ratfps q \\<longleftrightarrow> p = q\"", "lemma fps_of_ratfps_eq_zero_iff [simp]:\n  \"fps_of_ratfps p = 0 \\<longleftrightarrow> p = 0\"", "lemma unit_factor_snd_quot_of_ratfps [simp]: \n  \"unit_factor (snd (quot_of_ratfps x)) = 1\"", "lemma poly_shift_times_monom_le: \n  \"n \\<le> m \\<Longrightarrow> poly_shift n (monom c m * p) = monom c (m - n) * p\"", "lemma poly_shift_times_monom_ge: \n  \"n \\<ge> m \\<Longrightarrow> poly_shift n (monom c m * p) = smult c (poly_shift (n - m) p)\"", "lemma poly_shift_times_monom:\n  \"poly_shift n (monom c n * p) = smult c p\"", "lemma monom_times_poly_shift:\n  assumes \"poly_subdegree p \\<ge> n\"\n  shows   \"monom c n * poly_shift n p = smult c p\" (is \"?lhs = ?rhs\")", "lemma monom_times_poly_shift':\n  assumes \"poly_subdegree p \\<ge> n\"\n  shows   \"monom (1 :: 'a :: comm_semiring_1) n * poly_shift n p = p\"", "lemma subdegree_minus_cutoff_ge:\n  assumes \"f - fps_cutoff n (f :: 'a :: ab_group_add fps) \\<noteq> 0\"\n  shows   \"subdegree (f - fps_cutoff n f) \\<ge> n\"", "lemma fps_shift_times_X_power'': \"fps_shift n (fps_X ^ n * f :: 'a :: comm_ring_1 fps) = f\"", "lemma \n  ratfps_shift_code [code abstract]:\n    \"quot_of_ratfps (ratfps_shift n x) = \n       (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n        in  (poly_shift n a, b))\" (is \"?lhs1 = ?rhs1\") and\n  fps_of_ratfps_shift [simp]:\n    \"fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)\"", "lemma fps_shift_code [code]: \"fps_shift n (fps_of_ratfps x) = fps_of_ratfps (ratfps_shift n x)\"", "lemma equal_fps_code [code]: \"HOL.equal (fps_of_ratfps f) (fps_of_ratfps g) \\<longleftrightarrow> f = g\"", "lemma fps_of_ratfps_divide [simp]:\n  \"fps_of_ratfps (f div g) = fps_of_ratfps f div fps_of_ratfps g\"", "lemma ratfps_eqI: \"fps_of_ratfps x = fps_of_ratfps y \\<Longrightarrow> x = y\"", "lemma fps_of_ratfps_dvd [simp]:\n  \"fps_of_ratfps x dvd fps_of_ratfps y \\<longleftrightarrow> x dvd y\"", "lemma is_unit_ratfps_iff [simp]:\n  \"is_unit x \\<longleftrightarrow> ratfps_nth x 0 \\<noteq> 0\"", "lemma fps_of_ratfps_unit_factor [simp]: \n  \"fps_of_ratfps (unit_factor x) = unit_factor (fps_of_ratfps x)\"", "lemma fps_of_ratfps_normalize [simp]: \n  \"fps_of_ratfps (normalize x) = normalize (fps_of_ratfps x)\"", "lemma fps_of_ratfps_mod [simp]: \n   \"fps_of_ratfps (f mod g :: 'a ratfps) = fps_of_ratfps f mod fps_of_ratfps g\"", "lemma fps_of_ratfps_euclidean_size [simp]:\n  \"euclidean_size x = euclidean_size (fps_of_ratfps x)\"", "lemma quot_of_ratfps_eq_iff [simp]: \"quot_of_ratfps x = quot_of_ratfps y \\<longleftrightarrow> x = y\"", "lemma ratfps_eq_0_code: \"x = 0 \\<longleftrightarrow> fst (quot_of_ratfps x) = 0\"", "lemma fps_dvd_code [code_unfold]:\n  \"x dvd y \\<longleftrightarrow> y = 0 \\<or> ((x::'a::field_gcd fps) \\<noteq> 0 \\<and> subdegree x \\<le> subdegree y)\"", "lemma ratfps_dvd_code [code_unfold]: \n  \"x dvd y \\<longleftrightarrow> y = 0 \\<or> (x \\<noteq> 0 \\<and> ratfps_subdegree x \\<le> ratfps_subdegree y)\"", "lemma ratfps_eq_0_iff: \"x = 0 \\<longleftrightarrow> fps_of_ratfps x = 0\"", "lemma ratfps_of_poly_eq_0_iff: \"ratfps_of_poly x = 0 \\<longleftrightarrow> x = 0\"", "lemma ratfps_gcd:\n  assumes [simp]: \"f \\<noteq> 0\" \"g \\<noteq> 0\"\n  shows   \"gcd f g = ratfps_of_poly (monom 1 (min (ratfps_subdegree f) (ratfps_subdegree g)))\"", "lemma ratfps_gcd_altdef: \"gcd (f :: 'a :: field_gcd ratfps) g =\n  (if f = 0 \\<and> g = 0 then 0 else\n   if f = 0 then ratfps_of_poly (monom 1 (ratfps_subdegree g)) else\n   if g = 0 then ratfps_of_poly (monom 1 (ratfps_subdegree f)) else\n     ratfps_of_poly (monom 1 (min (ratfps_subdegree f) (ratfps_subdegree g))))\"", "lemma ratfps_lcm:\n  assumes [simp]: \"f \\<noteq> 0\" \"g \\<noteq> 0\"\n  shows   \"lcm f g = ratfps_of_poly (monom 1 (max (ratfps_subdegree f) (ratfps_subdegree g)))\"", "lemma ratfps_lcm_altdef: \"lcm (f :: 'a :: field_gcd ratfps) g =\n  (if f = 0 \\<or> g = 0 then 0 else \n     ratfps_of_poly (monom 1 (max (ratfps_subdegree f) (ratfps_subdegree g))))\"", "lemma ratfps_Gcd:\n  assumes \"A - {0} \\<noteq> {}\"\n  shows   \"Gcd A = ratfps_of_poly (monom 1 (INF f\\<in>A-{0}. ratfps_subdegree f))\"", "lemma ratfps_Gcd_altdef: \"Gcd (A :: 'a :: field_gcd ratfps set) =\n  (if A \\<subseteq> {0} then 0 else ratfps_of_poly (monom 1 (INF f\\<in>A-{0}. ratfps_subdegree f)))\"", "lemma ratfps_Lcm:\n  assumes \"A \\<noteq> {}\" \"0 \\<notin> A\" \"bdd_above (ratfps_subdegree`A)\"\n  shows   \"Lcm A = ratfps_of_poly (monom 1 (SUP f\\<in>A. ratfps_subdegree f))\"", "lemma ratfps_Lcm_altdef:\n  \"Lcm (A :: 'a :: field_gcd ratfps set) =\n     (if 0 \\<in> A \\<or> \\<not>bdd_above (ratfps_subdegree`A) then 0 else\n      if A = {} then 1 else ratfps_of_poly (monom 1 (SUP f\\<in>A. ratfps_subdegree f)))\"", "lemma fps_of_ratfps_quot_to_ratfps:\n  \"coeff y 0 \\<noteq> 0 \\<Longrightarrow> fps_of_ratfps (quot_to_ratfps (x,y)) = fps_of_poly x / fps_of_poly y\"", "lemma fps_of_ratfps_quot_to_ratfps_code_post1:\n  \"fps_of_ratfps (quot_to_ratfps (x,pCons 1 y)) = fps_of_poly x / fps_of_poly (pCons 1 y)\"\n  \"fps_of_ratfps (quot_to_ratfps (x,pCons (-1) y)) = fps_of_poly x / fps_of_poly (pCons (-1) y)\"", "lemma fps_of_ratfps_quot_to_ratfps_code_post2:\n  \"fps_of_ratfps (quot_to_ratfps (x'::'a::{field_char_0,field_gcd} poly,pCons (numeral n) y')) = \n     fps_of_poly x' / fps_of_poly (pCons (numeral n) y')\"\n  \"fps_of_ratfps (quot_to_ratfps (x'::'a::{field_char_0,field_gcd} poly,pCons (-numeral n) y')) = \n     fps_of_poly x' / fps_of_poly (pCons (-numeral n) y')\"", "lemmas fps_of_ratfps_quot_to_ratfps_code_post [code_post] =\n  fps_of_ratfps_quot_to_ratfps_code_post1\n  fps_of_ratfps_quot_to_ratfps_code_post2", "lemma fps_dehorner: \n  fixes a b c :: \"'a :: semiring_1 fps\" and d e f :: \"'b :: ring_1 fps\"\n  shows\n  \"(b + c) * fps_X = b * fps_X + c * fps_X\" \"(a * fps_X) * fps_X = a * fps_X ^ 2\" \n  \"a * fps_X ^ m * fps_X = a * fps_X ^ (Suc m)\" \"a * fps_X * fps_X ^ m = a * fps_X ^ (Suc m)\" \n  \"a * fps_X^m * fps_X^n = a * fps_X^(m+n)\" \"a + (b + c) = a + b + c\" \"a * 1 = a\" \"1 * a = a\"\n  \"d + - e = d - e\" \"(-d) * e = - (d * e)\" \"d + (e - f) = d + e - f\"\n  \"(d - e) * fps_X = d * fps_X - e * fps_X\" \"fps_X * fps_X = fps_X^2\" \"fps_X * fps_X^m = fps_X^(Suc m)\" \"fps_X^m * fps_X = fps_X^Suc m\"\n  \"fps_X^m * fps_X^n = fps_X^(m + n)\"", "lemma fps_divide_1: \"(a :: 'a :: field fps) / 1 = a\"", "lemmas fps_of_poly_code_post [code_post] = \n  fps_of_poly_simps fps_const_0_eq_0 fps_const_1_eq_1 numeral_fps_const [symmetric]\n  fps_const_neg [symmetric] fps_const_divide [symmetric]\n  fps_dehorner Suc_numeral arith_simps fps_divide_1"], "translations": [["", "lemma coeff_0_mult: \"coeff (p * q) 0 = coeff p 0 * coeff q 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_term (p * q) = constant_term p * constant_term q", "by (simp add: coeff_mult)"], ["", "lemma coeff_0_div: \n  assumes \"coeff p 0 \\<noteq> 0\" \n  assumes \"(q :: 'a :: field poly) dvd p\"\n  shows   \"coeff (p div q) 0 = coeff p 0 div coeff q 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_term (p div q) = constant_term p / constant_term q", "proof (cases \"q = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    constant_term (p div q) = constant_term p / constant_term q\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    constant_term (p div q) = constant_term p / constant_term q", "case False"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    constant_term (p div q) = constant_term p / constant_term q\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    constant_term (p div q) = constant_term p / constant_term q", "from assms"], ["proof (chain)\npicking this:\n  constant_term p \\<noteq> (0::'a)\n  q dvd p", "have \"p = p div q * q\""], ["proof (prove)\nusing this:\n  constant_term p \\<noteq> (0::'a)\n  q dvd p\n\ngoal (1 subgoal):\n 1. p = p div q * q", "by simp"], ["proof (state)\nthis:\n  p = p div q * q\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    constant_term (p div q) = constant_term p / constant_term q\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    constant_term (p div q) = constant_term p / constant_term q", "also"], ["proof (state)\nthis:\n  p = p div q * q\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    constant_term (p div q) = constant_term p / constant_term q\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    constant_term (p div q) = constant_term p / constant_term q", "have \"coeff \\<dots> 0 = coeff (p div q) 0 * coeff q 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_term (p div q * q) = constant_term (p div q) * constant_term q", "by (simp add: coeff_0_mult)"], ["proof (state)\nthis:\n  constant_term (p div q * q) = constant_term (p div q) * constant_term q\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    constant_term (p div q) = constant_term p / constant_term q\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    constant_term (p div q) = constant_term p / constant_term q", "finally"], ["proof (chain)\npicking this:\n  constant_term p = constant_term (p div q) * constant_term q", "show ?thesis"], ["proof (prove)\nusing this:\n  constant_term p = constant_term (p div q) * constant_term q\n\ngoal (1 subgoal):\n 1. constant_term (p div q) = constant_term p / constant_term q", "using assms"], ["proof (prove)\nusing this:\n  constant_term p = constant_term (p div q) * constant_term q\n  constant_term p \\<noteq> (0::'a)\n  q dvd p\n\ngoal (1 subgoal):\n 1. constant_term (p div q) = constant_term p / constant_term q", "by auto"], ["proof (state)\nthis:\n  constant_term (p div q) = constant_term p / constant_term q\n\ngoal (1 subgoal):\n 1. q = 0 \\<Longrightarrow>\n    constant_term (p div q) = constant_term p / constant_term q", "qed simp_all"], ["", "lemma coeff_0_add_fract_nonzero:\n  assumes \"coeff (snd (quot_of_fract x)) 0 \\<noteq> 0\" \"coeff (snd (quot_of_fract y)) 0 \\<noteq> 0\"\n  shows   \"coeff (snd (quot_of_fract (x + y))) 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_term (snd (quot_of_fract (x + y))) \\<noteq> (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. constant_term (snd (quot_of_fract (x + y))) \\<noteq> (0::'a)", "define num where \"num = fst (quot_of_fract x) * snd (quot_of_fract y) + \n    snd (quot_of_fract x) * fst (quot_of_fract y)\""], ["proof (state)\nthis:\n  num =\n  fst (quot_of_fract x) * snd (quot_of_fract y) +\n  snd (quot_of_fract x) * fst (quot_of_fract y)\n\ngoal (1 subgoal):\n 1. constant_term (snd (quot_of_fract (x + y))) \\<noteq> (0::'a)", "define denom where \"denom = snd (quot_of_fract x) * snd (quot_of_fract y)\""], ["proof (state)\nthis:\n  denom = snd (quot_of_fract x) * snd (quot_of_fract y)\n\ngoal (1 subgoal):\n 1. constant_term (snd (quot_of_fract (x + y))) \\<noteq> (0::'a)", "define z where \"z = (num, denom)\""], ["proof (state)\nthis:\n  z = (num, denom)\n\ngoal (1 subgoal):\n 1. constant_term (snd (quot_of_fract (x + y))) \\<noteq> (0::'a)", "from assms"], ["proof (chain)\npicking this:\n  constant_term (snd (quot_of_fract x)) \\<noteq> (0::'a)\n  constant_term (snd (quot_of_fract y)) \\<noteq> (0::'a)", "have \"snd z \\<noteq> 0\""], ["proof (prove)\nusing this:\n  constant_term (snd (quot_of_fract x)) \\<noteq> (0::'a)\n  constant_term (snd (quot_of_fract y)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0", "by (auto simp: denom_def z_def)"], ["proof (state)\nthis:\n  snd z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. constant_term (snd (quot_of_fract (x + y))) \\<noteq> (0::'a)", "from normalize_quotE'[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>d.\n      \\<lbrakk>fst z = fst (normalize_quot z) * d;\n       snd z = snd (normalize_quot z) * d; d dvd fst z; d dvd snd z;\n       d \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "guess d"], ["proof (prove)\nusing this:\n  (\\<And>d.\n      \\<lbrakk>fst z = fst (normalize_quot z) * d;\n       snd z = snd (normalize_quot z) * d; d dvd fst z; d dvd snd z;\n       d \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  fst z = fst (normalize_quot z) * d\n  snd z = snd (normalize_quot z) * d\n  d dvd fst z\n  d dvd snd z\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. constant_term (snd (quot_of_fract (x + y))) \\<noteq> (0::'a)", "note d = this"], ["proof (state)\nthis:\n  fst z = fst (normalize_quot z) * d\n  snd z = snd (normalize_quot z) * d\n  d dvd fst z\n  d dvd snd z\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. constant_term (snd (quot_of_fract (x + y))) \\<noteq> (0::'a)", "from assms"], ["proof (chain)\npicking this:\n  constant_term (snd (quot_of_fract x)) \\<noteq> (0::'a)\n  constant_term (snd (quot_of_fract y)) \\<noteq> (0::'a)", "have z: \"coeff (snd z) 0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  constant_term (snd (quot_of_fract x)) \\<noteq> (0::'a)\n  constant_term (snd (quot_of_fract y)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. constant_term (snd z) \\<noteq> (0::'a)", "by (simp add: z_def denom_def coeff_0_mult)"], ["proof (state)\nthis:\n  constant_term (snd z) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. constant_term (snd (quot_of_fract (x + y))) \\<noteq> (0::'a)", "have \"coeff (snd (quot_of_fract (x + y))) 0 = coeff (snd (normalize_quot z)) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_term (snd (quot_of_fract (x + y))) =\n    constant_term (snd (normalize_quot z))", "by (simp add: quot_of_fract_add Let_def case_prod_unfold z_def num_def denom_def)"], ["proof (state)\nthis:\n  constant_term (snd (quot_of_fract (x + y))) =\n  constant_term (snd (normalize_quot z))\n\ngoal (1 subgoal):\n 1. constant_term (snd (quot_of_fract (x + y))) \\<noteq> (0::'a)", "also"], ["proof (state)\nthis:\n  constant_term (snd (quot_of_fract (x + y))) =\n  constant_term (snd (normalize_quot z))\n\ngoal (1 subgoal):\n 1. constant_term (snd (quot_of_fract (x + y))) \\<noteq> (0::'a)", "from z"], ["proof (chain)\npicking this:\n  constant_term (snd z) \\<noteq> (0::'a)", "have \"\\<dots> \\<noteq> 0\""], ["proof (prove)\nusing this:\n  constant_term (snd z) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. constant_term (snd (normalize_quot z)) \\<noteq> (0::'a)", "using d"], ["proof (prove)\nusing this:\n  constant_term (snd z) \\<noteq> (0::'a)\n  fst z = fst (normalize_quot z) * d\n  snd z = snd (normalize_quot z) * d\n  d dvd fst z\n  d dvd snd z\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. constant_term (snd (normalize_quot z)) \\<noteq> (0::'a)", "by (simp add: d coeff_0_mult)"], ["proof (state)\nthis:\n  constant_term (snd (normalize_quot z)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. constant_term (snd (quot_of_fract (x + y))) \\<noteq> (0::'a)", "finally"], ["proof (chain)\npicking this:\n  constant_term (snd (quot_of_fract (x + y))) \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  constant_term (snd (quot_of_fract (x + y))) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. constant_term (snd (quot_of_fract (x + y))) \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  constant_term (snd (quot_of_fract (x + y))) \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_0_normalize_quot_nonzero [simp]:\n  assumes \"coeff (snd x) 0 \\<noteq> 0\"\n  shows   \"coeff (snd (normalize_quot x)) 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_term (snd (normalize_quot x)) \\<noteq> (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. constant_term (snd (normalize_quot x)) \\<noteq> (0::'a)", "from assms"], ["proof (chain)\npicking this:\n  constant_term (snd x) \\<noteq> (0::'a)", "have \"snd x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  constant_term (snd x) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. snd x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  snd x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. constant_term (snd (normalize_quot x)) \\<noteq> (0::'a)", "from normalize_quotE'[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>d.\n      \\<lbrakk>fst x = fst (normalize_quot x) * d;\n       snd x = snd (normalize_quot x) * d; d dvd fst x; d dvd snd x;\n       d \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "guess d"], ["proof (prove)\nusing this:\n  (\\<And>d.\n      \\<lbrakk>fst x = fst (normalize_quot x) * d;\n       snd x = snd (normalize_quot x) * d; d dvd fst x; d dvd snd x;\n       d \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  fst x = fst (normalize_quot x) * d\n  snd x = snd (normalize_quot x) * d\n  d dvd fst x\n  d dvd snd x\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. constant_term (snd (normalize_quot x)) \\<noteq> (0::'a)", "with assms"], ["proof (chain)\npicking this:\n  constant_term (snd x) \\<noteq> (0::'a)\n  fst x = fst (normalize_quot x) * d\n  snd x = snd (normalize_quot x) * d\n  d dvd fst x\n  d dvd snd x\n  d \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  constant_term (snd x) \\<noteq> (0::'a)\n  fst x = fst (normalize_quot x) * d\n  snd x = snd (normalize_quot x) * d\n  d dvd fst x\n  d dvd snd x\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. constant_term (snd (normalize_quot x)) \\<noteq> (0::'a)", "by (auto simp: coeff_0_mult)"], ["proof (state)\nthis:\n  constant_term (snd (normalize_quot x)) \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation numerator :: \"'a fract \\<Rightarrow> 'a::{ring_gcd,idom_divide,semiring_gcd_mult_normalize}\"\n  where \"numerator x \\<equiv> fst (quot_of_fract x)\""], ["", "abbreviation denominator :: \"'a fract \\<Rightarrow> 'a::{ring_gcd,idom_divide,semiring_gcd_mult_normalize}\"\n  where \"denominator x \\<equiv> snd (quot_of_fract x)\""], ["", "declare unit_factor_snd_quot_of_fract [simp]\n  normalize_snd_quot_of_fract [simp]"], ["", "lemma constant_term_denominator_nonzero_imp_constant_term_denominator_div_gcd_nonzero:\n  \"constant_term (denominator x div gcd a (denominator x)) \\<noteq> 0\"\n  if \"constant_term (denominator x) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_term (denominator x div gcd a (denominator x)) \\<noteq> (0::'a)", "using that coeff_0_normalize_quot_nonzero [of \"(a, denominator x)\"]\n  normalize_quot_proj(2) [of \"denominator x\" a]"], ["proof (prove)\nusing this:\n  constant_term (denominator x) \\<noteq> (0::'a)\n  constant_term (snd (a, denominator x)) \\<noteq> (0::'a) \\<Longrightarrow>\n  constant_term (snd (normalize_quot (a, denominator x))) \\<noteq> (0::'a)\n  denominator x \\<noteq> 0 \\<Longrightarrow>\n  snd (normalize_quot (a, denominator x)) =\n  normalize (denominator x) div gcd a (denominator x)\n\ngoal (1 subgoal):\n 1. constant_term (denominator x div gcd a (denominator x)) \\<noteq> (0::'a)", "by simp"], ["", "subsection \\<open>The type of rational formal power series\\<close>"], ["", "typedef (overloaded) 'a :: field_gcd ratfps = \n  \"{x :: 'a poly fract. constant_term (denominator x) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {x. constant_term (denominator x) \\<noteq> (0::'a)}", "by (rule exI [of _ 0]) simp"], ["", "setup_lifting type_definition_ratfps"], ["", "instantiation ratfps :: (field_gcd) idom\nbegin"], ["", "lift_definition zero_ratfps :: \"'a ratfps\" is \"0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_term (denominator 0) \\<noteq> (0::'a)", "by simp"], ["", "lift_definition one_ratfps :: \"'a ratfps\" is \"1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_term (denominator 1) \\<noteq> (0::'a)", "by simp"], ["", "lift_definition uminus_ratfps :: \"'a ratfps \\<Rightarrow> 'a ratfps\" is \"uminus\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fract.\n       constant_term (denominator fract) \\<noteq> (0::'a) \\<Longrightarrow>\n       constant_term (denominator (- fract)) \\<noteq> (0::'a)", "by (simp add: quot_of_fract_uminus case_prod_unfold Let_def)"], ["", "lift_definition plus_ratfps :: \"'a ratfps \\<Rightarrow> 'a ratfps \\<Rightarrow> 'a ratfps\" is \"(+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fract1 fract2.\n       \\<lbrakk>constant_term (denominator fract1) \\<noteq> (0::'a);\n        constant_term (denominator fract2) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> constant_term\n                          (denominator (fract1 + fract2)) \\<noteq>\n                         (0::'a)", "by (rule coeff_0_add_fract_nonzero)"], ["", "lift_definition minus_ratfps :: \"'a ratfps \\<Rightarrow> 'a ratfps \\<Rightarrow> 'a ratfps\" is \"(-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fract1 fract2.\n       \\<lbrakk>constant_term (denominator fract1) \\<noteq> (0::'a);\n        constant_term (denominator fract2) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> constant_term\n                          (denominator (fract1 - fract2)) \\<noteq>\n                         (0::'a)", "by (simp only: diff_conv_add_uminus, rule coeff_0_add_fract_nonzero)\n     (simp_all add: quot_of_fract_uminus Let_def case_prod_unfold)"], ["", "lift_definition times_ratfps :: \"'a ratfps \\<Rightarrow> 'a ratfps \\<Rightarrow> 'a ratfps\" is \"(*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fract1 fract2.\n       \\<lbrakk>constant_term (denominator fract1) \\<noteq> (0::'a);\n        constant_term (denominator fract2) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> constant_term\n                          (denominator (fract1 * fract2)) \\<noteq>\n                         (0::'a)", "by (simp add: quot_of_fract_mult Let_def case_prod_unfold coeff_0_mult\n    constant_term_denominator_nonzero_imp_constant_term_denominator_div_gcd_nonzero)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ratfps, idom_class)", "by (standard; transfer) (simp_all add: ring_distribs)"], ["", "end"], ["", "fun ratfps_nth_aux :: \"('a::field) poly \\<Rightarrow> nat \\<Rightarrow> 'a\"\nwhere\n  \"ratfps_nth_aux p 0 = inverse (coeff p 0)\"\n| \"ratfps_nth_aux p n = \n     - inverse (coeff p 0) * sum (\\<lambda>i. coeff p i * ratfps_nth_aux p (n - i)) {1..n}\""], ["", "lemma ratfps_nth_aux_correct: \"ratfps_nth_aux p n = natfun_inverse (fps_of_poly p) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ratfps_nth_aux p n = natfun_inverse (fps_of_poly p) n", "by (induction p n rule: ratfps_nth_aux.induct) simp_all"], ["", "lift_definition ratfps_nth :: \"'a :: field_gcd ratfps \\<Rightarrow> nat \\<Rightarrow> 'a\" is\n  \"\\<lambda>x n. let (a,b) = quot_of_fract x\n         in  (\\<Sum>i = 0..n. coeff a i * ratfps_nth_aux b (n - i))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition ratfps_subdegree :: \"'a :: field_gcd ratfps \\<Rightarrow> nat\" is\n  \"\\<lambda>x. poly_subdegree (fst (quot_of_fract x))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "context\nincludes lifting_syntax\nbegin"], ["", "lemma RatFPS_parametric: \"(rel_prod (=) (=) ===> (=))\n  (\\<lambda>(p,q). if coeff q 0 = 0 then 0 else quot_to_fract (p, q))\n  (\\<lambda>(p,q). if coeff q 0 = 0 then 0 else quot_to_fract (p, q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_prod (=) (=) ===> (=))\n     (\\<lambda>(p, q).\n         if constant_term q = (0::'a) then 0 else quot_to_fract (p, q))\n     (\\<lambda>(p, q).\n         if constant_term q = (0::'a) then 0 else quot_to_fract (p, q))", "by transfer_prover"], ["", "end"], ["", "lemma normalize_quot_quot_of_fract [simp]: \n  \"normalize_quot (quot_of_fract x) = quot_of_fract x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize_quot (quot_of_fract x) = quot_of_fract x", "by (rule normalize_quot_id, rule quot_of_fract_in_normalized_fracts)"], ["", "context\nassumes \"SORT_CONSTRAINT('a::field_gcd)\"\nbegin"], ["", "lift_definition quot_of_ratfps :: \"'a ratfps \\<Rightarrow> ('a poly \\<times> 'a poly)\" is\n  \"quot_of_fract :: 'a poly fract \\<Rightarrow> ('a poly \\<times> 'a poly)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition quot_to_ratfps :: \"('a poly \\<times> 'a poly) \\<Rightarrow> 'a ratfps\" is\n  \"\\<lambda>(x,y). let (x',y') = normalize_quot (x,y) \n           in  if coeff y' 0 = 0 then 0 else quot_to_fract (x',y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod.\n       constant_term\n        (denominator\n          (case prod of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) \\<noteq>\n       (0::'a)", "by (simp add: case_prod_unfold Let_def quot_of_fract_quot_to_fract)"], ["", "lemma quot_to_ratfps_quot_of_ratfps [code abstype]:\n  \"quot_to_ratfps (quot_of_ratfps x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.quot_to_ratfps (local.quot_of_ratfps x) = x", "by transfer (simp add: case_prod_unfold Let_def)"], ["", "lemma coeff_0_snd_quot_of_ratfps_nonzero [simp]: \n  \"coeff (snd (quot_of_ratfps x)) 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_term (snd (local.quot_of_ratfps x)) \\<noteq> (0::'a)", "by transfer simp"], ["", "lemma quot_of_ratfps_quot_to_ratfps:\n  \"coeff (snd x) 0 \\<noteq> 0 \\<Longrightarrow> x \\<in> normalized_fracts \\<Longrightarrow> quot_of_ratfps (quot_to_ratfps x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>constant_term (snd x) \\<noteq> (0::'a);\n     x \\<in> normalized_fracts\\<rbrakk>\n    \\<Longrightarrow> local.quot_of_ratfps (local.quot_to_ratfps x) = x", "by transfer (simp add: Let_def case_prod_unfold coeff_0_normalize_quot_nonzero \n                 quot_of_fract_quot_to_fract normalize_quot_id)"], ["", "lemma quot_of_ratfps_0 [simp, code abstract]: \"quot_of_ratfps 0 = (0, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.quot_of_ratfps 0 = (0, 1)", "by transfer simp_all"], ["", "lemma quot_of_ratfps_1 [simp, code abstract]: \"quot_of_ratfps 1 = (1, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.quot_of_ratfps 1 = (1, 1)", "by transfer simp_all"], ["", "lift_definition ratfps_of_poly :: \"'a poly \\<Rightarrow> 'a ratfps\" is\n  \"to_fract :: 'a poly \\<Rightarrow> _\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>poly. constant_term (denominator (to_fract poly)) \\<noteq> (0::'a)", "by transfer simp"], ["", "lemma ratfps_of_poly_code [code abstract]:\n  \"quot_of_ratfps (ratfps_of_poly p) = (p, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.quot_of_ratfps (local.ratfps_of_poly p) = (p, 1)", "by transfer' simp"], ["", "lemmas zero_ratfps_code = quot_of_ratfps_0"], ["", "lemmas one_ratfps_code = quot_of_ratfps_1"], ["", "lemma uminus_ratfps_code [code abstract]: \n  \"quot_of_ratfps (- x) = (let (a, b) = quot_of_ratfps x in (-a, b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.quot_of_ratfps (- x) =\n    (let (a, b) = local.quot_of_ratfps x in (- a, b))", "by transfer (rule quot_of_fract_uminus)"], ["", "lemma plus_ratfps_code [code abstract]:\n  \"quot_of_ratfps (x + y) = \n     (let (a,b) = quot_of_ratfps x; (c,d) = quot_of_ratfps y\n      in  normalize_quot (a * d + b * c, b * d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.quot_of_ratfps (x + y) =\n    (let (a, b) = local.quot_of_ratfps x; (c, d) = local.quot_of_ratfps y\n     in normalize_quot (a * d + b * c, b * d))", "by transfer' (rule quot_of_fract_add)"], ["", "lemma minus_ratfps_code [code abstract]:\n  \"quot_of_ratfps (x - y) = \n     (let (a,b) = quot_of_ratfps x; (c,d) = quot_of_ratfps y\n      in  normalize_quot (a * d - b * c, b * d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.quot_of_ratfps (x - y) =\n    (let (a, b) = local.quot_of_ratfps x; (c, d) = local.quot_of_ratfps y\n     in normalize_quot (a * d - b * c, b * d))", "by transfer' (rule quot_of_fract_diff)"], ["", "definition ratfps_cutoff :: \"nat \\<Rightarrow> 'a :: field_gcd ratfps \\<Rightarrow> 'a poly\" where\n  \"ratfps_cutoff n x = poly_of_list (map (ratfps_nth x) [0..<n])\""], ["", "definition ratfps_shift :: \"nat \\<Rightarrow> 'a :: field_gcd ratfps \\<Rightarrow> 'a ratfps\" where\n  \"ratfps_shift n x = (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n                       in  quot_to_ratfps (poly_shift n a, b))\""], ["", "lemma times_ratfps_code [code abstract]:\n  \"quot_of_ratfps (x * y) = \n     (let (a,b) = quot_of_ratfps x; (c,d) = quot_of_ratfps y;\n          (e,f) = normalize_quot (a,d); (g,h) = normalize_quot (c,b)\n      in  (e*g, f*h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.quot_of_ratfps (x * y) =\n    (let (a, b) = local.quot_of_ratfps x; (c, d) = local.quot_of_ratfps y;\n         (e, f) = normalize_quot (a, d); (g, h) = normalize_quot (c, b)\n     in (e * g, f * h))", "by transfer' (rule quot_of_fract_mult)"], ["", "lemma ratfps_nth_code [code]:\n  \"ratfps_nth x n = \n    (let (a,b) = quot_of_ratfps x\n     in  \\<Sum>i = 0..n. coeff a i * ratfps_nth_aux b (n - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ratfps_nth x n =\n    (let (a, b) = local.quot_of_ratfps x\n     in \\<Sum>i = 0..n. coeff a i * ratfps_nth_aux b (n - i))", "by transfer' simp"], ["", "lemma ratfps_subdegree_code [code]:\n  \"ratfps_subdegree x = poly_subdegree (fst (quot_of_ratfps x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ratfps_subdegree x = poly_subdegree (fst (local.quot_of_ratfps x))", "by transfer simp"], ["", "end"], ["", "instantiation ratfps :: (\"field_gcd\") inverse\nbegin"], ["", "lift_definition inverse_ratfps :: \"'a ratfps \\<Rightarrow> 'a ratfps\" is\n  \"\\<lambda>x. let (a,b) = quot_of_fract x\n       in  if coeff a 0 = 0 then 0 else inverse x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fract.\n       constant_term (denominator fract) \\<noteq> (0::'a) \\<Longrightarrow>\n       constant_term\n        (denominator\n          (let (a, b) = quot_of_fract fract\n           in if constant_term a = (0::'a) then 0\n              else inverse fract)) \\<noteq>\n       (0::'a)", "by (auto simp: case_prod_unfold Let_def quot_of_fract_inverse)"], ["", "lift_definition divide_ratfps :: \"'a ratfps \\<Rightarrow> 'a ratfps \\<Rightarrow> 'a ratfps\" is\n  \"\\<lambda>f g. (if g = 0 then 0 else \n           let n = ratfps_subdegree g; h = ratfps_shift n g\n           in  ratfps_shift n (f * inverse h))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ratfps, inverse_class)", ".."], ["", "end"], ["", "lemma ratfps_inverse_code [code abstract]:\n  \"quot_of_ratfps (inverse x) = \n     (let (a,b) = quot_of_ratfps x\n      in  if coeff a 0 = 0 then (0, 1)\n          else let u = unit_factor a in (b div u, a div u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quot_of_ratfps (inverse x) =\n    (let (a, b) = quot_of_ratfps x\n     in if constant_term a = (0::'a) then (0, 1)\n        else let u = unit_factor a in (b div u, a div u))", "by transfer' (simp_all add: Let_def case_prod_unfold quot_of_fract_inverse)"], ["", "instantiation ratfps :: (equal) equal\nbegin"], ["", "definition equal_ratfps :: \"'a ratfps \\<Rightarrow> 'a ratfps \\<Rightarrow> bool\" where\n  [simp]: \"equal_ratfps x y \\<longleftrightarrow> x = y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ratfps, equal_class)", "by standard simp"], ["", "end"], ["", "lemma quot_of_fract_eq_iff [simp]: \"quot_of_fract x = quot_of_fract y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (quot_of_fract x = quot_of_fract y) = (x = y)", "by transfer (auto simp: normalize_quot_eq_iff)"], ["", "lemma equal_ratfps_code [code]: \"HOL.equal x y \\<longleftrightarrow> quot_of_ratfps x = quot_of_ratfps y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal x y = (quot_of_ratfps x = quot_of_ratfps y)", "unfolding equal_ratfps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = y) = (quot_of_ratfps x = quot_of_ratfps y)", "by transfer simp"], ["", "lemma fps_of_poly_quot_normalize_quot [simp]:\n  \"fps_of_poly (fst (normalize_quot x)) / fps_of_poly (snd (normalize_quot x)) =\n     fps_of_poly (fst x) / fps_of_poly (snd x)\"\n  if \"(snd x :: 'a :: field_gcd poly) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_poly (fst (normalize_quot x)) /\n    fps_of_poly (snd (normalize_quot x)) =\n    fps_of_poly (fst x) / fps_of_poly (snd x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fps_of_poly (fst (normalize_quot x)) /\n    fps_of_poly (snd (normalize_quot x)) =\n    fps_of_poly (fst x) / fps_of_poly (snd x)", "from that"], ["proof (chain)\npicking this:\n  snd x \\<noteq> 0", "obtain d where \"fst x = fst (normalize_quot x) * d\"\n    and \"snd x = snd (normalize_quot x) * d\" and \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  snd x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>fst x = fst (normalize_quot x) * d;\n         snd x = snd (normalize_quot x) * d; d \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule normalize_quotE')"], ["proof (state)\nthis:\n  fst x = fst (normalize_quot x) * d\n  snd x = snd (normalize_quot x) * d\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fps_of_poly (fst (normalize_quot x)) /\n    fps_of_poly (snd (normalize_quot x)) =\n    fps_of_poly (fst x) / fps_of_poly (snd x)", "then"], ["proof (chain)\npicking this:\n  fst x = fst (normalize_quot x) * d\n  snd x = snd (normalize_quot x) * d\n  d \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  fst x = fst (normalize_quot x) * d\n  snd x = snd (normalize_quot x) * d\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fps_of_poly (fst (normalize_quot x)) /\n    fps_of_poly (snd (normalize_quot x)) =\n    fps_of_poly (fst x) / fps_of_poly (snd x)", "by (simp add: fps_of_poly_mult)"], ["proof (state)\nthis:\n  fps_of_poly (fst (normalize_quot x)) /\n  fps_of_poly (snd (normalize_quot x)) =\n  fps_of_poly (fst x) / fps_of_poly (snd x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fps_of_poly_quot_normalize_quot' [simp]:\n  \"fps_of_poly (fst (normalize_quot x)) / fps_of_poly (snd (normalize_quot x)) =\n     fps_of_poly (fst x) / fps_of_poly (snd x)\"\n  if \"coeff (snd x) 0 \\<noteq> (0 :: 'a :: field_gcd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_poly (fst (normalize_quot x)) /\n    fps_of_poly (snd (normalize_quot x)) =\n    fps_of_poly (fst x) / fps_of_poly (snd x)", "using that"], ["proof (prove)\nusing this:\n  constant_term (snd x) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. fps_of_poly (fst (normalize_quot x)) /\n    fps_of_poly (snd (normalize_quot x)) =\n    fps_of_poly (fst x) / fps_of_poly (snd x)", "by (auto intro: fps_of_poly_quot_normalize_quot)"], ["", "lift_definition fps_of_ratfps :: \"'a :: field_gcd ratfps \\<Rightarrow> 'a fps\" is\n  \"\\<lambda>x. fps_of_poly (numerator x) / fps_of_poly (denominator x)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma fps_of_ratfps_altdef: \n  \"fps_of_ratfps x = (case quot_of_ratfps x of (a, b) \\<Rightarrow> fps_of_poly a / fps_of_poly b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps x =\n    (case quot_of_ratfps x of\n     (a, b) \\<Rightarrow> fps_of_poly a / fps_of_poly b)", "by transfer (simp add: case_prod_unfold)"], ["", "lemma fps_of_ratfps_ratfps_of_poly [simp]: \"fps_of_ratfps (ratfps_of_poly p) = fps_of_poly p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (ratfps_of_poly p) = fps_of_poly p", "by transfer simp"], ["", "lemma fps_of_ratfps_0 [simp]: \"fps_of_ratfps 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps 0 = 0", "by transfer simp"], ["", "lemma fps_of_ratfps_1 [simp]: \"fps_of_ratfps 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps 1 = 1", "by transfer simp"], ["", "lemma fps_of_ratfps_uminus [simp]: \"fps_of_ratfps (-x) = - fps_of_ratfps x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (- x) = - fps_of_ratfps x", "by transfer (simp add: quot_of_fract_uminus case_prod_unfold Let_def fps_of_poly_simps dvd_neg_div)"], ["", "lemma fps_of_ratfps_add [simp]: \"fps_of_ratfps (x + y) = fps_of_ratfps x + fps_of_ratfps y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (x + y) = fps_of_ratfps x + fps_of_ratfps y", "by transfer (simp add: quot_of_fract_add Let_def case_prod_unfold fps_of_poly_simps)"], ["", "lemma fps_of_ratfps_diff [simp]: \"fps_of_ratfps (x - y) = fps_of_ratfps x - fps_of_ratfps y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (x - y) = fps_of_ratfps x - fps_of_ratfps y", "by transfer (simp add: quot_of_fract_diff Let_def case_prod_unfold fps_of_poly_simps)"], ["", "lemma is_unit_div_div_commute: \"is_unit b \\<Longrightarrow> is_unit c \\<Longrightarrow> a div b div c = a div c div b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_unit b; is_unit c\\<rbrakk>\n    \\<Longrightarrow> a div b div c = a div c div b", "by (metis is_unit_div_mult2_eq mult.commute)"], ["", "lemma fps_of_ratfps_mult [simp]: \"fps_of_ratfps (x * y) = fps_of_ratfps x * fps_of_ratfps y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (x * y) = fps_of_ratfps x * fps_of_ratfps y", "proof (transfer, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>constant_term (denominator x) \\<noteq> (0::'a);\n        constant_term (denominator y) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> fps_of_poly (numerator (x * y)) /\n                         fps_of_poly (denominator (x * y)) =\n                         fps_of_poly (numerator x) /\n                         fps_of_poly (denominator x) *\n                         (fps_of_poly (numerator y) /\n                          fps_of_poly (denominator y))", "case (1 x y)"], ["proof (state)\nthis:\n  constant_term (denominator x) \\<noteq> (0::'a)\n  constant_term (denominator y) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>constant_term (denominator x) \\<noteq> (0::'a);\n        constant_term (denominator y) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> fps_of_poly (numerator (x * y)) /\n                         fps_of_poly (denominator (x * y)) =\n                         fps_of_poly (numerator x) /\n                         fps_of_poly (denominator x) *\n                         (fps_of_poly (numerator y) /\n                          fps_of_poly (denominator y))", "moreover"], ["proof (state)\nthis:\n  constant_term (denominator x) \\<noteq> (0::'a)\n  constant_term (denominator y) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>constant_term (denominator x) \\<noteq> (0::'a);\n        constant_term (denominator y) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> fps_of_poly (numerator (x * y)) /\n                         fps_of_poly (denominator (x * y)) =\n                         fps_of_poly (numerator x) /\n                         fps_of_poly (denominator x) *\n                         (fps_of_poly (numerator y) /\n                          fps_of_poly (denominator y))", "define x' y' where \"x' = quot_of_fract x\" and \"y' = quot_of_fract y\""], ["proof (state)\nthis:\n  x' = quot_of_fract x\n  y' = quot_of_fract y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>constant_term (denominator x) \\<noteq> (0::'a);\n        constant_term (denominator y) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> fps_of_poly (numerator (x * y)) /\n                         fps_of_poly (denominator (x * y)) =\n                         fps_of_poly (numerator x) /\n                         fps_of_poly (denominator x) *\n                         (fps_of_poly (numerator y) /\n                          fps_of_poly (denominator y))", "ultimately"], ["proof (chain)\npicking this:\n  constant_term (denominator x) \\<noteq> (0::'a)\n  constant_term (denominator y) \\<noteq> (0::'a)\n  x' = quot_of_fract x\n  y' = quot_of_fract y", "have assms: \"coeff (snd x') 0 \\<noteq> 0\" \"coeff (snd y') 0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  constant_term (denominator x) \\<noteq> (0::'a)\n  constant_term (denominator y) \\<noteq> (0::'a)\n  x' = quot_of_fract x\n  y' = quot_of_fract y\n\ngoal (1 subgoal):\n 1. constant_term (snd x') \\<noteq> (0::'a) &&&\n    constant_term (snd y') \\<noteq> (0::'a)", "by simp_all"], ["proof (state)\nthis:\n  constant_term (snd x') \\<noteq> (0::'a)\n  constant_term (snd y') \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>constant_term (denominator x) \\<noteq> (0::'a);\n        constant_term (denominator y) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> fps_of_poly (numerator (x * y)) /\n                         fps_of_poly (denominator (x * y)) =\n                         fps_of_poly (numerator x) /\n                         fps_of_poly (denominator x) *\n                         (fps_of_poly (numerator y) /\n                          fps_of_poly (denominator y))", "moreover"], ["proof (state)\nthis:\n  constant_term (snd x') \\<noteq> (0::'a)\n  constant_term (snd y') \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>constant_term (denominator x) \\<noteq> (0::'a);\n        constant_term (denominator y) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> fps_of_poly (numerator (x * y)) /\n                         fps_of_poly (denominator (x * y)) =\n                         fps_of_poly (numerator x) /\n                         fps_of_poly (denominator x) *\n                         (fps_of_poly (numerator y) /\n                          fps_of_poly (denominator y))", "define w z where \"w = normalize_quot (fst x', snd y')\" and \"z = normalize_quot (fst y', snd x')\""], ["proof (state)\nthis:\n  w = normalize_quot (fst x', snd y')\n  z = normalize_quot (fst y', snd x')\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>constant_term (denominator x) \\<noteq> (0::'a);\n        constant_term (denominator y) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> fps_of_poly (numerator (x * y)) /\n                         fps_of_poly (denominator (x * y)) =\n                         fps_of_poly (numerator x) /\n                         fps_of_poly (denominator x) *\n                         (fps_of_poly (numerator y) /\n                          fps_of_poly (denominator y))", "ultimately"], ["proof (chain)\npicking this:\n  constant_term (snd x') \\<noteq> (0::'a)\n  constant_term (snd y') \\<noteq> (0::'a)\n  w = normalize_quot (fst x', snd y')\n  z = normalize_quot (fst y', snd x')", "have unit: \"coeff (snd x') 0 \\<noteq> 0\" \"coeff (snd y') 0 \\<noteq> 0\" \n    \"coeff (snd w) 0 \\<noteq> 0\" \"coeff (snd z) 0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  constant_term (snd x') \\<noteq> (0::'a)\n  constant_term (snd y') \\<noteq> (0::'a)\n  w = normalize_quot (fst x', snd y')\n  z = normalize_quot (fst y', snd x')\n\ngoal (1 subgoal):\n 1. (constant_term (snd x') \\<noteq> (0::'a) &&&\n     constant_term (snd y') \\<noteq> (0::'a)) &&&\n    constant_term (snd w) \\<noteq> (0::'a) &&&\n    constant_term (snd z) \\<noteq> (0::'a)", "by (simp_all add: coeff_0_normalize_quot_nonzero)"], ["proof (state)\nthis:\n  constant_term (snd x') \\<noteq> (0::'a)\n  constant_term (snd y') \\<noteq> (0::'a)\n  constant_term (snd w) \\<noteq> (0::'a)\n  constant_term (snd z) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>constant_term (denominator x) \\<noteq> (0::'a);\n        constant_term (denominator y) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> fps_of_poly (numerator (x * y)) /\n                         fps_of_poly (denominator (x * y)) =\n                         fps_of_poly (numerator x) /\n                         fps_of_poly (denominator x) *\n                         (fps_of_poly (numerator y) /\n                          fps_of_poly (denominator y))", "have \"fps_of_poly (fst w * fst z) / fps_of_poly (snd w * snd z) =\n          (fps_of_poly (fst w) / fps_of_poly (snd w)) *\n          (fps_of_poly (fst z) / fps_of_poly (snd z))\" (is \"_ = ?A * ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_poly (fst w * fst z) / fps_of_poly (snd w * snd z) =\n    fps_of_poly (fst w) / fps_of_poly (snd w) *\n    (fps_of_poly (fst z) / fps_of_poly (snd z))", "by (simp add: is_unit_div_mult2_eq fps_of_poly_mult unit_div_mult_swap unit_div_commute unit)"], ["proof (state)\nthis:\n  fps_of_poly (fst w * fst z) / fps_of_poly (snd w * snd z) =\n  fps_of_poly (fst w) / fps_of_poly (snd w) *\n  (fps_of_poly (fst z) / fps_of_poly (snd z))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>constant_term (denominator x) \\<noteq> (0::'a);\n        constant_term (denominator y) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> fps_of_poly (numerator (x * y)) /\n                         fps_of_poly (denominator (x * y)) =\n                         fps_of_poly (numerator x) /\n                         fps_of_poly (denominator x) *\n                         (fps_of_poly (numerator y) /\n                          fps_of_poly (denominator y))", "also"], ["proof (state)\nthis:\n  fps_of_poly (fst w * fst z) / fps_of_poly (snd w * snd z) =\n  fps_of_poly (fst w) / fps_of_poly (snd w) *\n  (fps_of_poly (fst z) / fps_of_poly (snd z))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>constant_term (denominator x) \\<noteq> (0::'a);\n        constant_term (denominator y) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> fps_of_poly (numerator (x * y)) /\n                         fps_of_poly (denominator (x * y)) =\n                         fps_of_poly (numerator x) /\n                         fps_of_poly (denominator x) *\n                         (fps_of_poly (numerator y) /\n                          fps_of_poly (denominator y))", "have \"\\<dots> = (fps_of_poly (fst x') / fps_of_poly (snd x')) * \n                    (fps_of_poly (fst y') / fps_of_poly (snd y'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_poly (fst w) / fps_of_poly (snd w) *\n    (fps_of_poly (fst z) / fps_of_poly (snd z)) =\n    fps_of_poly (fst x') / fps_of_poly (snd x') *\n    (fps_of_poly (fst y') / fps_of_poly (snd y'))", "using unit"], ["proof (prove)\nusing this:\n  constant_term (snd x') \\<noteq> (0::'a)\n  constant_term (snd y') \\<noteq> (0::'a)\n  constant_term (snd w) \\<noteq> (0::'a)\n  constant_term (snd z) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. fps_of_poly (fst w) / fps_of_poly (snd w) *\n    (fps_of_poly (fst z) / fps_of_poly (snd z)) =\n    fps_of_poly (fst x') / fps_of_poly (snd x') *\n    (fps_of_poly (fst y') / fps_of_poly (snd y'))", "by (simp add: w_def z_def unit_div_commute unit_div_mult_swap is_unit_div_div_commute)"], ["proof (state)\nthis:\n  fps_of_poly (fst w) / fps_of_poly (snd w) *\n  (fps_of_poly (fst z) / fps_of_poly (snd z)) =\n  fps_of_poly (fst x') / fps_of_poly (snd x') *\n  (fps_of_poly (fst y') / fps_of_poly (snd y'))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>constant_term (denominator x) \\<noteq> (0::'a);\n        constant_term (denominator y) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> fps_of_poly (numerator (x * y)) /\n                         fps_of_poly (denominator (x * y)) =\n                         fps_of_poly (numerator x) /\n                         fps_of_poly (denominator x) *\n                         (fps_of_poly (numerator y) /\n                          fps_of_poly (denominator y))", "finally"], ["proof (chain)\npicking this:\n  fps_of_poly (fst w * fst z) / fps_of_poly (snd w * snd z) =\n  fps_of_poly (fst x') / fps_of_poly (snd x') *\n  (fps_of_poly (fst y') / fps_of_poly (snd y'))", "show ?case"], ["proof (prove)\nusing this:\n  fps_of_poly (fst w * fst z) / fps_of_poly (snd w * snd z) =\n  fps_of_poly (fst x') / fps_of_poly (snd x') *\n  (fps_of_poly (fst y') / fps_of_poly (snd y'))\n\ngoal (1 subgoal):\n 1. fps_of_poly (numerator (x * y)) / fps_of_poly (denominator (x * y)) =\n    fps_of_poly (numerator x) / fps_of_poly (denominator x) *\n    (fps_of_poly (numerator y) / fps_of_poly (denominator y))", "by (simp add: w_def z_def x'_def y'_def Let_def case_prod_unfold quot_of_fract_mult mult_ac)"], ["proof (state)\nthis:\n  fps_of_poly (numerator (x * y)) / fps_of_poly (denominator (x * y)) =\n  fps_of_poly (numerator x) / fps_of_poly (denominator x) *\n  (fps_of_poly (numerator y) / fps_of_poly (denominator y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma div_const_unit_poly: \"is_unit c \\<Longrightarrow> p div [:c:] = smult (1 div c) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit c \\<Longrightarrow> p div [:c:] = smult ((1::'a) div c) p", "by (simp add: is_unit_const_poly_iff unit_eq_div1)"], ["", "lemma normalize_field: \n  \"normalize (x :: 'a :: {normalization_semidom,field}) = (if x = 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize x = (if x = (0::'a) then 0::'a else (1::'a))", "by (auto simp: normalize_1_iff dvd_field_iff)"], ["", "lemma unit_factor_field [simp]:\n  \"unit_factor (x :: 'a :: {normalization_semidom,field}) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_factor x = x", "using unit_factor_mult_normalize[of x] normalize_field[of x]"], ["proof (prove)\nusing this:\n  unit_factor x * normalize x = x\n  normalize x = (if x = (0::'a) then 0::'a else (1::'a))\n\ngoal (1 subgoal):\n 1. unit_factor x = x", "by (simp split: if_splits)"], ["", "lemma fps_of_poly_normalize_field: \n  \"fps_of_poly (normalize (p :: 'a :: {field, normalization_semidom} poly)) = \n     fps_of_poly p * fps_const (inverse (lead_coeff p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_poly (normalize p) =\n    fps_of_poly p * fps_const (inverse (lead_coeff p))", "by (cases \"p = 0\")\n     (simp_all add: normalize_poly_def div_const_unit_poly divide_simps dvd_field_iff)"], ["", "lemma unit_factor_poly_altdef: \"unit_factor p = monom (unit_factor (lead_coeff p)) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_factor p = monom (unit_factor (lead_coeff p)) 0", "by (simp add: unit_factor_poly_def monom_altdef)"], ["", "lemma div_const_poly: \"p div [:c::'a::field:] = smult (inverse c) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p div [:c:] = smult (inverse c) p", "by (cases \"c = 0\") (simp_all add: unit_eq_div1 is_unit_triv)"], ["", "lemma fps_of_ratfps_inverse [simp]: \"fps_of_ratfps (inverse x) = inverse (fps_of_ratfps x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (inverse x) = inverse (fps_of_ratfps x)", "proof (transfer, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       constant_term (denominator x) \\<noteq> (0::'a) \\<Longrightarrow>\n       fps_of_poly\n        (numerator\n          (let (a, b) = quot_of_fract x\n           in if constant_term a = (0::'a) then 0 else inverse x)) /\n       fps_of_poly\n        (denominator\n          (let (a, b) = quot_of_fract x\n           in if constant_term a = (0::'a) then 0 else inverse x)) =\n       inverse (fps_of_poly (numerator x) / fps_of_poly (denominator x))", "case (1 x)"], ["proof (state)\nthis:\n  constant_term (denominator x) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       constant_term (denominator x) \\<noteq> (0::'a) \\<Longrightarrow>\n       fps_of_poly\n        (numerator\n          (let (a, b) = quot_of_fract x\n           in if constant_term a = (0::'a) then 0 else inverse x)) /\n       fps_of_poly\n        (denominator\n          (let (a, b) = quot_of_fract x\n           in if constant_term a = (0::'a) then 0 else inverse x)) =\n       inverse (fps_of_poly (numerator x) / fps_of_poly (denominator x))", "hence \"smult (lead_coeff (fst (quot_of_fract x))) (snd (quot_of_fract x)) div\n           unit_factor (fst (quot_of_fract x)) = snd (quot_of_fract x)\"\n    if \"fst (quot_of_fract x) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  constant_term (denominator x) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. smult (lead_coeff (numerator x)) (denominator x) div\n    unit_factor (numerator x) =\n    denominator x", "using that"], ["proof (prove)\nusing this:\n  constant_term (denominator x) \\<noteq> (0::'a)\n  numerator x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. smult (lead_coeff (numerator x)) (denominator x) div\n    unit_factor (numerator x) =\n    denominator x", "by (simp add: unit_factor_poly_altdef monom_0 div_const_poly)"], ["proof (state)\nthis:\n  numerator x \\<noteq> 0 \\<Longrightarrow>\n  smult (lead_coeff (numerator x)) (denominator x) div\n  unit_factor (numerator x) =\n  denominator x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       constant_term (denominator x) \\<noteq> (0::'a) \\<Longrightarrow>\n       fps_of_poly\n        (numerator\n          (let (a, b) = quot_of_fract x\n           in if constant_term a = (0::'a) then 0 else inverse x)) /\n       fps_of_poly\n        (denominator\n          (let (a, b) = quot_of_fract x\n           in if constant_term a = (0::'a) then 0 else inverse x)) =\n       inverse (fps_of_poly (numerator x) / fps_of_poly (denominator x))", "with 1"], ["proof (chain)\npicking this:\n  constant_term (denominator x) \\<noteq> (0::'a)\n  numerator x \\<noteq> 0 \\<Longrightarrow>\n  smult (lead_coeff (numerator x)) (denominator x) div\n  unit_factor (numerator x) =\n  denominator x", "show ?case"], ["proof (prove)\nusing this:\n  constant_term (denominator x) \\<noteq> (0::'a)\n  numerator x \\<noteq> 0 \\<Longrightarrow>\n  smult (lead_coeff (numerator x)) (denominator x) div\n  unit_factor (numerator x) =\n  denominator x\n\ngoal (1 subgoal):\n 1. fps_of_poly\n     (numerator\n       (let (a, b) = quot_of_fract x\n        in if constant_term a = (0::'a) then 0 else inverse x)) /\n    fps_of_poly\n     (denominator\n       (let (a, b) = quot_of_fract x\n        in if constant_term a = (0::'a) then 0 else inverse x)) =\n    inverse (fps_of_poly (numerator x) / fps_of_poly (denominator x))", "by (auto simp: Let_def case_prod_unfold fps_divide_unit fps_inverse_mult\n          quot_of_fract_inverse mult_ac\n          fps_of_poly_simps fps_const_inverse\n          fps_of_poly_normalize_field div_smult_left [symmetric])"], ["proof (state)\nthis:\n  fps_of_poly\n   (numerator\n     (let (a, b) = quot_of_fract x\n      in if constant_term a = (0::'a) then 0 else inverse x)) /\n  fps_of_poly\n   (denominator\n     (let (a, b) = quot_of_fract x\n      in if constant_term a = (0::'a) then 0 else inverse x)) =\n  inverse (fps_of_poly (numerator x) / fps_of_poly (denominator x))\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  includes fps_notation\nbegin"], ["", "lemma ratfps_nth_altdef: \"ratfps_nth x n = fps_of_ratfps x $ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ratfps_nth x n = fps_of_ratfps x $ n", "by transfer\n     (simp_all add: case_prod_unfold fps_divide_unit fps_times_def fps_inverse_def \n        ratfps_nth_aux_correct Let_def)"], ["", "lemma fps_of_ratfps_is_unit: \"fps_of_ratfps a $ 0 \\<noteq> 0 \\<longleftrightarrow> ratfps_nth a 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_of_ratfps a $ 0 \\<noteq> (0::'a)) =\n    (ratfps_nth a 0 \\<noteq> (0::'a))", "by (simp add: ratfps_nth_altdef)"], ["", "lemma ratfps_nth_0 [simp]: \"ratfps_nth 0 n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ratfps_nth 0 n = (0::'a)", "by (simp add: ratfps_nth_altdef)"], ["", "lemma fps_of_ratfps_cases:\n  obtains p q where \"coeff q 0 \\<noteq> 0\" \"fps_of_ratfps f = fps_of_poly p / fps_of_poly q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q p.\n        \\<lbrakk>constant_term q \\<noteq> (0::'a);\n         fps_of_ratfps f = fps_of_poly p / fps_of_poly q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule that[of \"snd (quot_of_ratfps f)\" \"fst (quot_of_ratfps f)\"])\n     (simp_all add: fps_of_ratfps_altdef case_prod_unfold)"], ["", "lemma fps_of_ratfps_cutoff [simp]:\n    \"fps_of_poly (ratfps_cutoff n x) = fps_cutoff n (fps_of_ratfps x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_poly (ratfps_cutoff n x) = fps_cutoff n (fps_of_ratfps x)", "by (simp add: fps_eq_iff ratfps_cutoff_def nth_default_def ratfps_nth_altdef)"], ["", "lemma subdegree_fps_of_ratfps:\n  \"subdegree (fps_of_ratfps x) = ratfps_subdegree x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subdegree (fps_of_ratfps x) = ratfps_subdegree x", "by transfer (simp_all add: case_prod_unfold subdegree_div_unit poly_subdegree_def)"], ["", "lemma ratfps_subdegree_altdef:\n  \"ratfps_subdegree x = subdegree (fps_of_ratfps x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ratfps_subdegree x = subdegree (fps_of_ratfps x)", "using subdegree_fps_of_ratfps"], ["proof (prove)\nusing this:\n  subdegree (fps_of_ratfps ?x) = ratfps_subdegree ?x\n\ngoal (1 subgoal):\n 1. ratfps_subdegree x = subdegree (fps_of_ratfps x)", ".."], ["", "end"], ["", "code_datatype fps_of_ratfps"], ["", "lemma fps_zero_code [code]: \"0 = fps_of_ratfps 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = fps_of_ratfps 0", "by simp"], ["", "lemma fps_one_code [code]: \"1 = fps_of_ratfps 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = fps_of_ratfps 1", "by simp"], ["", "lemma fps_const_code [code]: \"fps_const c = fps_of_poly [:c:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_const c = fps_of_poly [:c:]", "by simp"], ["", "lemma fps_of_poly_code [code]: \"fps_of_poly p = fps_of_ratfps (ratfps_of_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_poly p = fps_of_ratfps (ratfps_of_poly p)", "by simp"], ["", "lemma fps_X_code [code]: \"fps_X = fps_of_ratfps (ratfps_of_poly [:0,1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_X = fps_of_ratfps (ratfps_of_poly [:0::'a, 1::'a:])", "by simp"], ["", "lemma fps_nth_code [code]: \"fps_nth (fps_of_ratfps x) n = ratfps_nth x n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps x $ n = ratfps_nth x n", "by (simp add: ratfps_nth_altdef)"], ["", "lemma fps_uminus_code [code]: \"- fps_of_ratfps x = fps_of_ratfps (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - fps_of_ratfps x = fps_of_ratfps (- x)", "by simp"], ["", "lemma fps_add_code [code]: \"fps_of_ratfps x + fps_of_ratfps y = fps_of_ratfps (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps x + fps_of_ratfps y = fps_of_ratfps (x + y)", "by simp"], ["", "lemma fps_diff_code [code]: \"fps_of_ratfps x - fps_of_ratfps y = fps_of_ratfps (x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps x - fps_of_ratfps y = fps_of_ratfps (x - y)", "by simp"], ["", "lemma fps_mult_code [code]: \"fps_of_ratfps x * fps_of_ratfps y = fps_of_ratfps (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps x * fps_of_ratfps y = fps_of_ratfps (x * y)", "by simp"], ["", "lemma fps_inverse_code [code]: \"inverse (fps_of_ratfps x) = fps_of_ratfps (inverse x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (fps_of_ratfps x) = fps_of_ratfps (inverse x)", "by simp"], ["", "lemma fps_cutoff_code [code]: \"fps_cutoff n (fps_of_ratfps x) = fps_of_poly (ratfps_cutoff n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_cutoff n (fps_of_ratfps x) = fps_of_poly (ratfps_cutoff n x)", "by simp"], ["", "lemmas subdegree_code [code] = subdegree_fps_of_ratfps"], ["", "lemma fractrel_normalize_quot:\n  \"fractrel p p \\<Longrightarrow> fractrel q q \\<Longrightarrow> \n     fractrel (normalize_quot p) (normalize_quot q) \\<longleftrightarrow> fractrel p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fractrel p p; fractrel q q\\<rbrakk>\n    \\<Longrightarrow> fractrel (normalize_quot p) (normalize_quot q) =\n                      fractrel p q", "by (subst fractrel_normalize_quot_left fractrel_normalize_quot_right, simp)+ (rule refl)"], ["", "lemma fps_of_ratfps_eq_iff [simp]:\n  \"fps_of_ratfps p = fps_of_ratfps q \\<longleftrightarrow> p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_of_ratfps p = fps_of_ratfps q) = (p = q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (fps_of_ratfps p = fps_of_ratfps q) = (p = q)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (fps_of_ratfps p = fps_of_ratfps q) = (p = q)", "fix p q :: \"'a poly fract\""], ["proof (state)\ngoal (1 subgoal):\n 1. (fps_of_ratfps p = fps_of_ratfps q) = (p = q)", "assume \"fractrel (quot_of_fract p) (quot_of_fract q)\""], ["proof (state)\nthis:\n  fractrel (quot_of_fract p) (quot_of_fract q)\n\ngoal (1 subgoal):\n 1. (fps_of_ratfps p = fps_of_ratfps q) = (p = q)", "hence \"p = q\""], ["proof (prove)\nusing this:\n  fractrel (quot_of_fract p) (quot_of_fract q)\n\ngoal (1 subgoal):\n 1. p = q", "by transfer (simp only: fractrel_normalize_quot)"], ["proof (state)\nthis:\n  p = q\n\ngoal (1 subgoal):\n 1. (fps_of_ratfps p = fps_of_ratfps q) = (p = q)", "}"], ["proof (state)\nthis:\n  fractrel (quot_of_fract ?pa2) (quot_of_fract ?qa2) \\<Longrightarrow>\n  ?pa2 = ?qa2\n\ngoal (1 subgoal):\n 1. (fps_of_ratfps p = fps_of_ratfps q) = (p = q)", "note A = this"], ["proof (state)\nthis:\n  fractrel (quot_of_fract ?pa2) (quot_of_fract ?qa2) \\<Longrightarrow>\n  ?pa2 = ?qa2\n\ngoal (1 subgoal):\n 1. (fps_of_ratfps p = fps_of_ratfps q) = (p = q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_of_ratfps p = fps_of_ratfps q) = (p = q)", "by transfer (auto simp: case_prod_unfold unit_eq_div1 unit_eq_div2 unit_div_commute intro: A)"], ["proof (state)\nthis:\n  (fps_of_ratfps p = fps_of_ratfps q) = (p = q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fps_of_ratfps_eq_zero_iff [simp]:\n  \"fps_of_ratfps p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_of_ratfps p = 0) = (p = 0)", "by (simp del: fps_of_ratfps_0 add: fps_of_ratfps_0 [symmetric])"], ["", "lemma unit_factor_snd_quot_of_ratfps [simp]: \n  \"unit_factor (snd (quot_of_ratfps x)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_factor (snd (quot_of_ratfps x)) = 1", "by transfer simp"], ["", "lemma poly_shift_times_monom_le: \n  \"n \\<le> m \\<Longrightarrow> poly_shift n (monom c m * p) = monom c (m - n) * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow>\n    poly_shift n (monom c m * p) = monom c (m - n) * p", "by (intro poly_eqI) (auto simp: coeff_monom_mult coeff_poly_shift)"], ["", "lemma poly_shift_times_monom_ge: \n  \"n \\<ge> m \\<Longrightarrow> poly_shift n (monom c m * p) = smult c (poly_shift (n - m) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow>\n    poly_shift n (monom c m * p) = smult c (poly_shift (n - m) p)", "by (intro poly_eqI) (auto simp: coeff_monom_mult coeff_poly_shift)"], ["", "lemma poly_shift_times_monom:\n  \"poly_shift n (monom c n * p) = smult c p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_shift n (monom c n * p) = smult c p", "by (intro poly_eqI) (auto simp: coeff_monom_mult coeff_poly_shift)"], ["", "lemma monom_times_poly_shift:\n  assumes \"poly_subdegree p \\<ge> n\"\n  shows   \"monom c n * poly_shift n p = smult c p\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom c n * poly_shift n p = smult c p", "proof (intro poly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na. coeff (monom c n * poly_shift n p) na = coeff (smult c p) na", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na. coeff (monom c n * poly_shift n p) na = coeff (smult c p) na", "show \"coeff ?lhs k = coeff ?rhs k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (monom c n * poly_shift n p) k = coeff (smult c p) k", "proof (cases \"k < n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < n \\<Longrightarrow>\n    coeff (monom c n * poly_shift n p) k = coeff (smult c p) k\n 2. \\<not> k < n \\<Longrightarrow>\n    coeff (monom c n * poly_shift n p) k = coeff (smult c p) k", "case True"], ["proof (state)\nthis:\n  k < n\n\ngoal (2 subgoals):\n 1. k < n \\<Longrightarrow>\n    coeff (monom c n * poly_shift n p) k = coeff (smult c p) k\n 2. \\<not> k < n \\<Longrightarrow>\n    coeff (monom c n * poly_shift n p) k = coeff (smult c p) k", "with assms"], ["proof (chain)\npicking this:\n  n \\<le> poly_subdegree p\n  k < n", "have \"k < poly_subdegree p\""], ["proof (prove)\nusing this:\n  n \\<le> poly_subdegree p\n  k < n\n\ngoal (1 subgoal):\n 1. k < poly_subdegree p", "by simp"], ["proof (state)\nthis:\n  k < poly_subdegree p\n\ngoal (2 subgoals):\n 1. k < n \\<Longrightarrow>\n    coeff (monom c n * poly_shift n p) k = coeff (smult c p) k\n 2. \\<not> k < n \\<Longrightarrow>\n    coeff (monom c n * poly_shift n p) k = coeff (smult c p) k", "hence \"coeff p k = 0\""], ["proof (prove)\nusing this:\n  k < poly_subdegree p\n\ngoal (1 subgoal):\n 1. coeff p k = (0::'a)", "by (simp add: coeff_less_poly_subdegree)"], ["proof (state)\nthis:\n  coeff p k = (0::'a)\n\ngoal (2 subgoals):\n 1. k < n \\<Longrightarrow>\n    coeff (monom c n * poly_shift n p) k = coeff (smult c p) k\n 2. \\<not> k < n \\<Longrightarrow>\n    coeff (monom c n * poly_shift n p) k = coeff (smult c p) k", "thus ?thesis"], ["proof (prove)\nusing this:\n  coeff p k = (0::'a)\n\ngoal (1 subgoal):\n 1. coeff (monom c n * poly_shift n p) k = coeff (smult c p) k", "by (auto simp: coeff_monom_mult coeff_poly_shift)"], ["proof (state)\nthis:\n  coeff (monom c n * poly_shift n p) k = coeff (smult c p) k\n\ngoal (1 subgoal):\n 1. \\<not> k < n \\<Longrightarrow>\n    coeff (monom c n * poly_shift n p) k = coeff (smult c p) k", "qed (auto simp: coeff_monom_mult coeff_poly_shift)"], ["proof (state)\nthis:\n  coeff (monom c n * poly_shift n p) k = coeff (smult c p) k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monom_times_poly_shift':\n  assumes \"poly_subdegree p \\<ge> n\"\n  shows   \"monom (1 :: 'a :: comm_semiring_1) n * poly_shift n p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) n * poly_shift n p = p", "by (simp add: monom_times_poly_shift[OF assms])"], ["", "lemma subdegree_minus_cutoff_ge:\n  assumes \"f - fps_cutoff n (f :: 'a :: ab_group_add fps) \\<noteq> 0\"\n  shows   \"subdegree (f - fps_cutoff n f) \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> subdegree (f - fps_cutoff n f)", "using assms"], ["proof (prove)\nusing this:\n  f - fps_cutoff n f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<le> subdegree (f - fps_cutoff n f)", "by (rule subdegree_geI) simp_all"], ["", "lemma fps_shift_times_X_power'': \"fps_shift n (fps_X ^ n * f :: 'a :: comm_ring_1 fps) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_shift n (fps_X ^ n * f) = f", "using fps_shift_times_fps_X_power'[of n f]"], ["proof (prove)\nusing this:\n  fps_shift n (f * fps_X ^ n) = f\n\ngoal (1 subgoal):\n 1. fps_shift n (fps_X ^ n * f) = f", "by (simp add: mult.commute)"], ["", "lemma \n  ratfps_shift_code [code abstract]:\n    \"quot_of_ratfps (ratfps_shift n x) = \n       (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n        in  (poly_shift n a, b))\" (is \"?lhs1 = ?rhs1\") and\n  fps_of_ratfps_shift [simp]:\n    \"fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quot_of_ratfps (ratfps_shift n x) =\n    (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n     in (poly_shift n a, b)) &&&\n    fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. quot_of_ratfps (ratfps_shift n x) =\n    (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n     in (poly_shift n a, b))\n 2. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "include fps_notation"], ["proof (state)\ngoal (2 subgoals):\n 1. quot_of_ratfps (ratfps_shift n x) =\n    (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n     in (poly_shift n a, b))\n 2. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "define x' where \"x' = ratfps_of_poly (ratfps_cutoff n x)\""], ["proof (state)\nthis:\n  x' = ratfps_of_poly (ratfps_cutoff n x)\n\ngoal (2 subgoals):\n 1. quot_of_ratfps (ratfps_shift n x) =\n    (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n     in (poly_shift n a, b))\n 2. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "define y where \"y = quot_of_ratfps (x - x')\""], ["proof (state)\nthis:\n  y = quot_of_ratfps (x - x')\n\ngoal (2 subgoals):\n 1. quot_of_ratfps (ratfps_shift n x) =\n    (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n     in (poly_shift n a, b))\n 2. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "have \"coprime (fst y) (snd y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (fst y) (snd y)", "unfolding y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (fst (quot_of_ratfps (x - x'))) (snd (quot_of_ratfps (x - x')))", "by transfer (rule coprime_quot_of_fract)"], ["proof (state)\nthis:\n  coprime (fst y) (snd y)\n\ngoal (2 subgoals):\n 1. quot_of_ratfps (ratfps_shift n x) =\n    (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n     in (poly_shift n a, b))\n 2. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "also"], ["proof (state)\nthis:\n  coprime (fst y) (snd y)\n\ngoal (2 subgoals):\n 1. quot_of_ratfps (ratfps_shift n x) =\n    (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n     in (poly_shift n a, b))\n 2. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "have fst_y: \"fst y = monom 1 n * poly_shift n (fst y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst y = monom (1::'a) n * poly_shift n (fst y)", "proof (cases \"x = x'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow> fst y = monom (1::'a) n * poly_shift n (fst y)\n 2. x \\<noteq> x' \\<Longrightarrow>\n    fst y = monom (1::'a) n * poly_shift n (fst y)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> x'\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow> fst y = monom (1::'a) n * poly_shift n (fst y)\n 2. x \\<noteq> x' \\<Longrightarrow>\n    fst y = monom (1::'a) n * poly_shift n (fst y)", "have \"poly_subdegree (fst y) = subdegree (fps_of_poly (fst y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subdegree (fst y) = subdegree (fps_of_poly (fst y))", "by (simp add: poly_subdegree_def)"], ["proof (state)\nthis:\n  poly_subdegree (fst y) = subdegree (fps_of_poly (fst y))\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow> fst y = monom (1::'a) n * poly_shift n (fst y)\n 2. x \\<noteq> x' \\<Longrightarrow>\n    fst y = monom (1::'a) n * poly_shift n (fst y)", "also"], ["proof (state)\nthis:\n  poly_subdegree (fst y) = subdegree (fps_of_poly (fst y))\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow> fst y = monom (1::'a) n * poly_shift n (fst y)\n 2. x \\<noteq> x' \\<Longrightarrow>\n    fst y = monom (1::'a) n * poly_shift n (fst y)", "have \"\\<dots> = subdegree (fps_of_poly (fst y) / fps_of_poly (snd y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subdegree (fps_of_poly (fst y)) =\n    subdegree (fps_of_poly (fst y) / fps_of_poly (snd y))", "by (subst subdegree_div_unit) (simp_all add: y_def)"], ["proof (state)\nthis:\n  subdegree (fps_of_poly (fst y)) =\n  subdegree (fps_of_poly (fst y) / fps_of_poly (snd y))\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow> fst y = monom (1::'a) n * poly_shift n (fst y)\n 2. x \\<noteq> x' \\<Longrightarrow>\n    fst y = monom (1::'a) n * poly_shift n (fst y)", "also"], ["proof (state)\nthis:\n  subdegree (fps_of_poly (fst y)) =\n  subdegree (fps_of_poly (fst y) / fps_of_poly (snd y))\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow> fst y = monom (1::'a) n * poly_shift n (fst y)\n 2. x \\<noteq> x' \\<Longrightarrow>\n    fst y = monom (1::'a) n * poly_shift n (fst y)", "have \"fps_of_poly (fst y) / fps_of_poly (snd y) = fps_of_ratfps (x - x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_poly (fst y) / fps_of_poly (snd y) = fps_of_ratfps (x - x')", "unfolding y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_poly (fst (quot_of_ratfps (x - x'))) /\n    fps_of_poly (snd (quot_of_ratfps (x - x'))) =\n    fps_of_ratfps (x - x')", "by transfer (simp add: case_prod_unfold)"], ["proof (state)\nthis:\n  fps_of_poly (fst y) / fps_of_poly (snd y) = fps_of_ratfps (x - x')\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow> fst y = monom (1::'a) n * poly_shift n (fst y)\n 2. x \\<noteq> x' \\<Longrightarrow>\n    fst y = monom (1::'a) n * poly_shift n (fst y)", "also"], ["proof (state)\nthis:\n  fps_of_poly (fst y) / fps_of_poly (snd y) = fps_of_ratfps (x - x')\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow> fst y = monom (1::'a) n * poly_shift n (fst y)\n 2. x \\<noteq> x' \\<Longrightarrow>\n    fst y = monom (1::'a) n * poly_shift n (fst y)", "from False"], ["proof (chain)\npicking this:\n  x \\<noteq> x'", "have \"subdegree \\<dots> \\<ge> n\""], ["proof (prove)\nusing this:\n  x \\<noteq> x'\n\ngoal (1 subgoal):\n 1. n \\<le> subdegree (fps_of_ratfps (x - x'))", "proof (intro subdegree_geI)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<noteq> x' \\<Longrightarrow> fps_of_ratfps (x - x') \\<noteq> 0\n 2. \\<And>i.\n       \\<lbrakk>x \\<noteq> x'; i < n\\<rbrakk>\n       \\<Longrightarrow> fps_of_ratfps (x - x') $ i = (0::'a)", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<noteq> x' \\<Longrightarrow> fps_of_ratfps (x - x') \\<noteq> 0\n 2. \\<And>i.\n       \\<lbrakk>x \\<noteq> x'; i < n\\<rbrakk>\n       \\<Longrightarrow> fps_of_ratfps (x - x') $ i = (0::'a)", "assume \"k < n\""], ["proof (state)\nthis:\n  k < n\n\ngoal (2 subgoals):\n 1. x \\<noteq> x' \\<Longrightarrow> fps_of_ratfps (x - x') \\<noteq> 0\n 2. \\<And>i.\n       \\<lbrakk>x \\<noteq> x'; i < n\\<rbrakk>\n       \\<Longrightarrow> fps_of_ratfps (x - x') $ i = (0::'a)", "thus \"fps_of_ratfps (x - x') $ k = 0\""], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. fps_of_ratfps (x - x') $ k = (0::'a)", "by (simp add: x'_def)"], ["proof (state)\nthis:\n  fps_of_ratfps (x - x') $ k = (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<noteq> x' \\<Longrightarrow> fps_of_ratfps (x - x') \\<noteq> 0", "qed simp_all"], ["proof (state)\nthis:\n  n \\<le> subdegree (fps_of_ratfps (x - x'))\n\ngoal (2 subgoals):\n 1. x = x' \\<Longrightarrow> fst y = monom (1::'a) n * poly_shift n (fst y)\n 2. x \\<noteq> x' \\<Longrightarrow>\n    fst y = monom (1::'a) n * poly_shift n (fst y)", "finally"], ["proof (chain)\npicking this:\n  n \\<le> poly_subdegree (fst y)", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> poly_subdegree (fst y)\n\ngoal (1 subgoal):\n 1. fst y = monom (1::'a) n * poly_shift n (fst y)", "by (rule monom_times_poly_shift' [symmetric])"], ["proof (state)\nthis:\n  fst y = monom (1::'a) n * poly_shift n (fst y)\n\ngoal (1 subgoal):\n 1. x = x' \\<Longrightarrow> fst y = monom (1::'a) n * poly_shift n (fst y)", "qed (simp_all add: y_def)"], ["proof (state)\nthis:\n  fst y = monom (1::'a) n * poly_shift n (fst y)\n\ngoal (2 subgoals):\n 1. quot_of_ratfps (ratfps_shift n x) =\n    (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n     in (poly_shift n a, b))\n 2. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "finally"], ["proof (chain)\npicking this:\n  coprime (monom (1::'a) n * poly_shift n (fst y)) (snd y)", "have coprime: \"coprime (poly_shift n (fst y)) (snd y)\""], ["proof (prove)\nusing this:\n  coprime (monom (1::'a) n * poly_shift n (fst y)) (snd y)\n\ngoal (1 subgoal):\n 1. coprime (poly_shift n (fst y)) (snd y)", "by simp"], ["proof (state)\nthis:\n  coprime (poly_shift n (fst y)) (snd y)\n\ngoal (2 subgoals):\n 1. quot_of_ratfps (ratfps_shift n x) =\n    (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n     in (poly_shift n a, b))\n 2. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "have \"quot_of_ratfps (ratfps_shift n x) = \n          quot_of_ratfps (quot_to_ratfps (poly_shift n (fst y), snd y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quot_of_ratfps (ratfps_shift n x) =\n    quot_of_ratfps (quot_to_ratfps (poly_shift n (fst y), snd y))", "by (simp add: ratfps_shift_def Let_def case_prod_unfold x'_def y_def)"], ["proof (state)\nthis:\n  quot_of_ratfps (ratfps_shift n x) =\n  quot_of_ratfps (quot_to_ratfps (poly_shift n (fst y), snd y))\n\ngoal (2 subgoals):\n 1. quot_of_ratfps (ratfps_shift n x) =\n    (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n     in (poly_shift n a, b))\n 2. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "also"], ["proof (state)\nthis:\n  quot_of_ratfps (ratfps_shift n x) =\n  quot_of_ratfps (quot_to_ratfps (poly_shift n (fst y), snd y))\n\ngoal (2 subgoals):\n 1. quot_of_ratfps (ratfps_shift n x) =\n    (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n     in (poly_shift n a, b))\n 2. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "from coprime"], ["proof (chain)\npicking this:\n  coprime (poly_shift n (fst y)) (snd y)", "have \"\\<dots> = (poly_shift n (fst y), snd y)\""], ["proof (prove)\nusing this:\n  coprime (poly_shift n (fst y)) (snd y)\n\ngoal (1 subgoal):\n 1. quot_of_ratfps (quot_to_ratfps (poly_shift n (fst y), snd y)) =\n    (poly_shift n (fst y), snd y)", "by (intro quot_of_ratfps_quot_to_ratfps) (simp_all add: y_def normalized_fracts_def)"], ["proof (state)\nthis:\n  quot_of_ratfps (quot_to_ratfps (poly_shift n (fst y), snd y)) =\n  (poly_shift n (fst y), snd y)\n\ngoal (2 subgoals):\n 1. quot_of_ratfps (ratfps_shift n x) =\n    (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n     in (poly_shift n a, b))\n 2. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "also"], ["proof (state)\nthis:\n  quot_of_ratfps (quot_to_ratfps (poly_shift n (fst y), snd y)) =\n  (poly_shift n (fst y), snd y)\n\ngoal (2 subgoals):\n 1. quot_of_ratfps (ratfps_shift n x) =\n    (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n     in (poly_shift n a, b))\n 2. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "have \"\\<dots> = ?rhs1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_shift n (fst y), snd y) =\n    (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n     in (poly_shift n a, b))", "by (simp add: case_prod_unfold Let_def y_def x'_def)"], ["proof (state)\nthis:\n  (poly_shift n (fst y), snd y) =\n  (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n   in (poly_shift n a, b))\n\ngoal (2 subgoals):\n 1. quot_of_ratfps (ratfps_shift n x) =\n    (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n     in (poly_shift n a, b))\n 2. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "finally"], ["proof (chain)\npicking this:\n  quot_of_ratfps (ratfps_shift n x) =\n  (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n   in (poly_shift n a, b))", "show eq: \"?lhs1 = ?rhs1\""], ["proof (prove)\nusing this:\n  quot_of_ratfps (ratfps_shift n x) =\n  (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n   in (poly_shift n a, b))\n\ngoal (1 subgoal):\n 1. quot_of_ratfps (ratfps_shift n x) =\n    (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n     in (poly_shift n a, b))", "."], ["proof (state)\nthis:\n  quot_of_ratfps (ratfps_shift n x) =\n  (let (a, b) = quot_of_ratfps (x - ratfps_of_poly (ratfps_cutoff n x))\n   in (poly_shift n a, b))\n\ngoal (1 subgoal):\n 1. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "have \"fps_shift n (fps_of_ratfps x) = fps_shift n (fps_of_ratfps (x - x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_shift n (fps_of_ratfps x) = fps_shift n (fps_of_ratfps (x - x'))", "by (intro fps_ext) (simp_all add: x'_def)"], ["proof (state)\nthis:\n  fps_shift n (fps_of_ratfps x) = fps_shift n (fps_of_ratfps (x - x'))\n\ngoal (1 subgoal):\n 1. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "also"], ["proof (state)\nthis:\n  fps_shift n (fps_of_ratfps x) = fps_shift n (fps_of_ratfps (x - x'))\n\ngoal (1 subgoal):\n 1. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "have \"fps_of_ratfps (x - x') = fps_of_poly (fst y) / fps_of_poly (snd y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (x - x') = fps_of_poly (fst y) / fps_of_poly (snd y)", "by (simp add: fps_of_ratfps_altdef y_def case_prod_unfold)"], ["proof (state)\nthis:\n  fps_of_ratfps (x - x') = fps_of_poly (fst y) / fps_of_poly (snd y)\n\ngoal (1 subgoal):\n 1. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "also"], ["proof (state)\nthis:\n  fps_of_ratfps (x - x') = fps_of_poly (fst y) / fps_of_poly (snd y)\n\ngoal (1 subgoal):\n 1. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "have \"fps_shift n \\<dots> = fps_of_ratfps (ratfps_shift n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_shift n (fps_of_poly (fst y) / fps_of_poly (snd y)) =\n    fps_of_ratfps (ratfps_shift n x)", "by (subst fst_y, subst fps_of_poly_mult, subst unit_div_mult_swap [symmetric])\n       (simp_all add: y_def fps_of_poly_monom fps_shift_times_X_power'' eq \n          fps_of_ratfps_altdef case_prod_unfold Let_def x'_def)"], ["proof (state)\nthis:\n  fps_shift n (fps_of_poly (fst y) / fps_of_poly (snd y)) =\n  fps_of_ratfps (ratfps_shift n x)\n\ngoal (1 subgoal):\n 1. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", "finally"], ["proof (chain)\npicking this:\n  fps_shift n (fps_of_ratfps x) = fps_of_ratfps (ratfps_shift n x)", "show \"fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)\""], ["proof (prove)\nusing this:\n  fps_shift n (fps_of_ratfps x) = fps_of_ratfps (ratfps_shift n x)\n\ngoal (1 subgoal):\n 1. fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)", ".."], ["proof (state)\nthis:\n  fps_of_ratfps (ratfps_shift n x) = fps_shift n (fps_of_ratfps x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fps_shift_code [code]: \"fps_shift n (fps_of_ratfps x) = fps_of_ratfps (ratfps_shift n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_shift n (fps_of_ratfps x) = fps_of_ratfps (ratfps_shift n x)", "by simp"], ["", "instantiation fps :: (equal) equal\nbegin"], ["", "definition equal_fps :: \"'a fps \\<Rightarrow> 'a fps \\<Rightarrow> bool\" where\n  [simp]: \"equal_fps f g \\<longleftrightarrow> f = g\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a fps, equal_class)", "by standard simp_all"], ["", "end"], ["", "lemma equal_fps_code [code]: \"HOL.equal (fps_of_ratfps f) (fps_of_ratfps g) \\<longleftrightarrow> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal (fps_of_ratfps f) (fps_of_ratfps g) = (f = g)", "by simp"], ["", "lemma fps_of_ratfps_divide [simp]:\n  \"fps_of_ratfps (f div g) = fps_of_ratfps f div fps_of_ratfps g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (f / g) = fps_of_ratfps f / fps_of_ratfps g", "unfolding fps_divide_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (f / g) =\n    fps_shift (subdegree (fps_of_ratfps g))\n     (fps_of_ratfps f * inverse (unit_factor (fps_of_ratfps g)))", "by transfer' (simp add: Let_def ratfps_subdegree_altdef)"], ["", "lemma ratfps_eqI: \"fps_of_ratfps x = fps_of_ratfps y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps x = fps_of_ratfps y \\<Longrightarrow> x = y", "by simp"], ["", "instance ratfps :: (\"field_gcd\") algebraic_semidom"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ratfps, algebraic_semidom_class)", "by standard (auto intro: ratfps_eqI)"], ["", "lemma fps_of_ratfps_dvd [simp]:\n  \"fps_of_ratfps x dvd fps_of_ratfps y \\<longleftrightarrow> x dvd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_of_ratfps x dvd fps_of_ratfps y) = (x dvd y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fps_of_ratfps x dvd fps_of_ratfps y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> fps_of_ratfps x dvd fps_of_ratfps y", "assume \"fps_of_ratfps x dvd fps_of_ratfps y\""], ["proof (state)\nthis:\n  fps_of_ratfps x dvd fps_of_ratfps y\n\ngoal (2 subgoals):\n 1. fps_of_ratfps x dvd fps_of_ratfps y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> fps_of_ratfps x dvd fps_of_ratfps y", "hence \"fps_of_ratfps y = fps_of_ratfps y div fps_of_ratfps x * fps_of_ratfps x\""], ["proof (prove)\nusing this:\n  fps_of_ratfps x dvd fps_of_ratfps y\n\ngoal (1 subgoal):\n 1. fps_of_ratfps y = fps_of_ratfps y / fps_of_ratfps x * fps_of_ratfps x", "by simp"], ["proof (state)\nthis:\n  fps_of_ratfps y = fps_of_ratfps y / fps_of_ratfps x * fps_of_ratfps x\n\ngoal (2 subgoals):\n 1. fps_of_ratfps x dvd fps_of_ratfps y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> fps_of_ratfps x dvd fps_of_ratfps y", "also"], ["proof (state)\nthis:\n  fps_of_ratfps y = fps_of_ratfps y / fps_of_ratfps x * fps_of_ratfps x\n\ngoal (2 subgoals):\n 1. fps_of_ratfps x dvd fps_of_ratfps y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> fps_of_ratfps x dvd fps_of_ratfps y", "have \"\\<dots> = fps_of_ratfps (y div x * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps y / fps_of_ratfps x * fps_of_ratfps x =\n    fps_of_ratfps (y / x * x)", "by simp"], ["proof (state)\nthis:\n  fps_of_ratfps y / fps_of_ratfps x * fps_of_ratfps x =\n  fps_of_ratfps (y / x * x)\n\ngoal (2 subgoals):\n 1. fps_of_ratfps x dvd fps_of_ratfps y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> fps_of_ratfps x dvd fps_of_ratfps y", "finally"], ["proof (chain)\npicking this:\n  fps_of_ratfps y = fps_of_ratfps (y / x * x)", "have \"y = y div x * x\""], ["proof (prove)\nusing this:\n  fps_of_ratfps y = fps_of_ratfps (y / x * x)\n\ngoal (1 subgoal):\n 1. y = y / x * x", "by (subst (asm) fps_of_ratfps_eq_iff)"], ["proof (state)\nthis:\n  y = y / x * x\n\ngoal (2 subgoals):\n 1. fps_of_ratfps x dvd fps_of_ratfps y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> fps_of_ratfps x dvd fps_of_ratfps y", "thus \"x dvd y\""], ["proof (prove)\nusing this:\n  y = y / x * x\n\ngoal (1 subgoal):\n 1. x dvd y", "by (intro dvdI[of _ _ \"y div x\"]) (simp add: mult_ac)"], ["proof (state)\nthis:\n  x dvd y\n\ngoal (1 subgoal):\n 1. x dvd y \\<Longrightarrow> fps_of_ratfps x dvd fps_of_ratfps y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x dvd y \\<Longrightarrow> fps_of_ratfps x dvd fps_of_ratfps y", "assume \"x dvd y\""], ["proof (state)\nthis:\n  x dvd y\n\ngoal (1 subgoal):\n 1. x dvd y \\<Longrightarrow> fps_of_ratfps x dvd fps_of_ratfps y", "hence \"y = y div x * x\""], ["proof (prove)\nusing this:\n  x dvd y\n\ngoal (1 subgoal):\n 1. y = y / x * x", "by simp"], ["proof (state)\nthis:\n  y = y / x * x\n\ngoal (1 subgoal):\n 1. x dvd y \\<Longrightarrow> fps_of_ratfps x dvd fps_of_ratfps y", "also"], ["proof (state)\nthis:\n  y = y / x * x\n\ngoal (1 subgoal):\n 1. x dvd y \\<Longrightarrow> fps_of_ratfps x dvd fps_of_ratfps y", "have \"fps_of_ratfps \\<dots> = fps_of_ratfps (y div x) * fps_of_ratfps x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (y / x * x) = fps_of_ratfps (y / x) * fps_of_ratfps x", "by simp"], ["proof (state)\nthis:\n  fps_of_ratfps (y / x * x) = fps_of_ratfps (y / x) * fps_of_ratfps x\n\ngoal (1 subgoal):\n 1. x dvd y \\<Longrightarrow> fps_of_ratfps x dvd fps_of_ratfps y", "finally"], ["proof (chain)\npicking this:\n  fps_of_ratfps y = fps_of_ratfps (y / x) * fps_of_ratfps x", "show \"fps_of_ratfps x dvd fps_of_ratfps y\""], ["proof (prove)\nusing this:\n  fps_of_ratfps y = fps_of_ratfps (y / x) * fps_of_ratfps x\n\ngoal (1 subgoal):\n 1. fps_of_ratfps x dvd fps_of_ratfps y", "by (simp del: fps_of_ratfps_divide)"], ["proof (state)\nthis:\n  fps_of_ratfps x dvd fps_of_ratfps y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_unit_ratfps_iff [simp]:\n  \"is_unit x \\<longleftrightarrow> ratfps_nth x 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit x = (ratfps_nth x 0 \\<noteq> (0::'a))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. is_unit x \\<Longrightarrow> ratfps_nth x 0 \\<noteq> (0::'a)\n 2. ratfps_nth x 0 \\<noteq> (0::'a) \\<Longrightarrow> is_unit x", "assume \"is_unit x\""], ["proof (state)\nthis:\n  is_unit x\n\ngoal (2 subgoals):\n 1. is_unit x \\<Longrightarrow> ratfps_nth x 0 \\<noteq> (0::'a)\n 2. ratfps_nth x 0 \\<noteq> (0::'a) \\<Longrightarrow> is_unit x", "then"], ["proof (chain)\npicking this:\n  is_unit x", "obtain y where \"1 = x * y\""], ["proof (prove)\nusing this:\n  is_unit x\n\ngoal (1 subgoal):\n 1. (\\<And>y. 1 = x * y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto elim!: dvdE)"], ["proof (state)\nthis:\n  1 = x * y\n\ngoal (2 subgoals):\n 1. is_unit x \\<Longrightarrow> ratfps_nth x 0 \\<noteq> (0::'a)\n 2. ratfps_nth x 0 \\<noteq> (0::'a) \\<Longrightarrow> is_unit x", "hence \"1 = fps_of_ratfps (x * y)\""], ["proof (prove)\nusing this:\n  1 = x * y\n\ngoal (1 subgoal):\n 1. 1 = fps_of_ratfps (x * y)", "by (simp del: fps_of_ratfps_mult)"], ["proof (state)\nthis:\n  1 = fps_of_ratfps (x * y)\n\ngoal (2 subgoals):\n 1. is_unit x \\<Longrightarrow> ratfps_nth x 0 \\<noteq> (0::'a)\n 2. ratfps_nth x 0 \\<noteq> (0::'a) \\<Longrightarrow> is_unit x", "also"], ["proof (state)\nthis:\n  1 = fps_of_ratfps (x * y)\n\ngoal (2 subgoals):\n 1. is_unit x \\<Longrightarrow> ratfps_nth x 0 \\<noteq> (0::'a)\n 2. ratfps_nth x 0 \\<noteq> (0::'a) \\<Longrightarrow> is_unit x", "have \"\\<dots> = fps_of_ratfps x * fps_of_ratfps y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (x * y) = fps_of_ratfps x * fps_of_ratfps y", "by simp"], ["proof (state)\nthis:\n  fps_of_ratfps (x * y) = fps_of_ratfps x * fps_of_ratfps y\n\ngoal (2 subgoals):\n 1. is_unit x \\<Longrightarrow> ratfps_nth x 0 \\<noteq> (0::'a)\n 2. ratfps_nth x 0 \\<noteq> (0::'a) \\<Longrightarrow> is_unit x", "finally"], ["proof (chain)\npicking this:\n  1 = fps_of_ratfps x * fps_of_ratfps y", "have \"is_unit (fps_of_ratfps x)\""], ["proof (prove)\nusing this:\n  1 = fps_of_ratfps x * fps_of_ratfps y\n\ngoal (1 subgoal):\n 1. is_unit (fps_of_ratfps x)", "by (rule dvdI[of _ _ \"fps_of_ratfps y\"])"], ["proof (state)\nthis:\n  is_unit (fps_of_ratfps x)\n\ngoal (2 subgoals):\n 1. is_unit x \\<Longrightarrow> ratfps_nth x 0 \\<noteq> (0::'a)\n 2. ratfps_nth x 0 \\<noteq> (0::'a) \\<Longrightarrow> is_unit x", "thus \"ratfps_nth x 0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  is_unit (fps_of_ratfps x)\n\ngoal (1 subgoal):\n 1. ratfps_nth x 0 \\<noteq> (0::'a)", "by (simp add: ratfps_nth_altdef)"], ["proof (state)\nthis:\n  ratfps_nth x 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. ratfps_nth x 0 \\<noteq> (0::'a) \\<Longrightarrow> is_unit x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ratfps_nth x 0 \\<noteq> (0::'a) \\<Longrightarrow> is_unit x", "assume \"ratfps_nth x 0 \\<noteq> 0\""], ["proof (state)\nthis:\n  ratfps_nth x 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. ratfps_nth x 0 \\<noteq> (0::'a) \\<Longrightarrow> is_unit x", "hence \"fps_of_ratfps (x * inverse x) = 1\""], ["proof (prove)\nusing this:\n  ratfps_nth x 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. fps_of_ratfps (x * inverse x) = 1", "by (simp add: ratfps_nth_altdef inverse_mult_eq_1')"], ["proof (state)\nthis:\n  fps_of_ratfps (x * inverse x) = 1\n\ngoal (1 subgoal):\n 1. ratfps_nth x 0 \\<noteq> (0::'a) \\<Longrightarrow> is_unit x", "also"], ["proof (state)\nthis:\n  fps_of_ratfps (x * inverse x) = 1\n\ngoal (1 subgoal):\n 1. ratfps_nth x 0 \\<noteq> (0::'a) \\<Longrightarrow> is_unit x", "have \"\\<dots> = fps_of_ratfps 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = fps_of_ratfps 1", "by simp"], ["proof (state)\nthis:\n  1 = fps_of_ratfps 1\n\ngoal (1 subgoal):\n 1. ratfps_nth x 0 \\<noteq> (0::'a) \\<Longrightarrow> is_unit x", "finally"], ["proof (chain)\npicking this:\n  fps_of_ratfps (x * inverse x) = fps_of_ratfps 1", "have \"x * inverse x = 1\""], ["proof (prove)\nusing this:\n  fps_of_ratfps (x * inverse x) = fps_of_ratfps 1\n\ngoal (1 subgoal):\n 1. x * inverse x = 1", "by (subst (asm) fps_of_ratfps_eq_iff)"], ["proof (state)\nthis:\n  x * inverse x = 1\n\ngoal (1 subgoal):\n 1. ratfps_nth x 0 \\<noteq> (0::'a) \\<Longrightarrow> is_unit x", "thus \"is_unit x\""], ["proof (prove)\nusing this:\n  x * inverse x = 1\n\ngoal (1 subgoal):\n 1. is_unit x", "by (intro dvdI[of _ _ \"inverse x\"]) simp_all"], ["proof (state)\nthis:\n  is_unit x\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation ratfps :: (\"field_gcd\") normalization_semidom\nbegin"], ["", "definition unit_factor_ratfps :: \"'a ratfps \\<Rightarrow> 'a ratfps\" where\n  \"unit_factor x = ratfps_shift (ratfps_subdegree x) x\""], ["", "definition normalize_ratfps :: \"'a ratfps \\<Rightarrow> 'a ratfps\" where\n  \"normalize x = (if x = 0 then 0 else ratfps_of_poly (monom 1 (ratfps_subdegree x)))\""], ["", "lemma fps_of_ratfps_unit_factor [simp]: \n  \"fps_of_ratfps (unit_factor x) = unit_factor (fps_of_ratfps x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (unit_factor x) = unit_factor (fps_of_ratfps x)", "unfolding unit_factor_ratfps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (ratfps_shift (ratfps_subdegree x) x) =\n    unit_factor (fps_of_ratfps x)", "by (simp add: ratfps_subdegree_altdef)"], ["", "lemma fps_of_ratfps_normalize [simp]: \n  \"fps_of_ratfps (normalize x) = normalize (fps_of_ratfps x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (normalize x) = normalize (fps_of_ratfps x)", "unfolding normalize_ratfps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps\n     (if x = 0 then 0\n      else ratfps_of_poly (monom (1::'a) (ratfps_subdegree x))) =\n    normalize (fps_of_ratfps x)", "by (simp add: fps_of_poly_monom ratfps_subdegree_altdef)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ratfps, normalization_semidom_class)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. unit_factor 0 = 0\n 2. \\<And>a. is_unit a \\<Longrightarrow> unit_factor a = a\n 3. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> is_unit (unit_factor a)\n 4. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b\n 5. \\<And>a. unit_factor a * normalize a = a\n 6. normalize 0 = 0", "show \"unit_factor x * normalize x = x\" \"normalize (0 :: 'a ratfps) = 0\" \n       \"unit_factor (0 :: 'a ratfps) = 0\" for x :: \"'a ratfps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_factor x * normalize x = x &&&\n    normalize 0 = 0 &&& unit_factor 0 = 0", "by (rule ratfps_eqI, simp add: ratfps_subdegree_code \n          del: fps_of_ratfps_eq_iff fps_unit_factor_def fps_normalize_def)+"], ["proof (state)\nthis:\n  unit_factor ?x * normalize ?x = ?x\n  normalize 0 = 0\n  unit_factor 0 = 0\n\ngoal (3 subgoals):\n 1. \\<And>a. is_unit a \\<Longrightarrow> unit_factor a = a\n 2. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> is_unit (unit_factor a)\n 3. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "show \"is_unit (unit_factor a)\" if \"a \\<noteq> 0\" for a :: \"'a ratfps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (unit_factor a)", "using that"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_unit (unit_factor a)", "by (auto simp: ratfps_nth_altdef)"], ["proof (state)\nthis:\n  ?a \\<noteq> 0 \\<Longrightarrow> is_unit (unit_factor ?a)\n\ngoal (2 subgoals):\n 1. \\<And>a. is_unit a \\<Longrightarrow> unit_factor a = a\n 2. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "fix a b :: \"'a ratfps\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. is_unit a \\<Longrightarrow> unit_factor a = a\n 2. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "assume \"is_unit a\""], ["proof (state)\nthis:\n  is_unit a\n\ngoal (2 subgoals):\n 1. \\<And>a. is_unit a \\<Longrightarrow> unit_factor a = a\n 2. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "thus \"unit_factor (a * b) = a * unit_factor b\""], ["proof (prove)\nusing this:\n  is_unit a\n\ngoal (1 subgoal):\n 1. unit_factor (a * b) = a * unit_factor b", "by (intro ratfps_eqI, unfold fps_of_ratfps_unit_factor fps_of_ratfps_mult,\n        subst unit_factor_mult_unit_left) (auto simp: ratfps_nth_altdef)"], ["proof (state)\nthis:\n  unit_factor (a * b) = a * unit_factor b\n\ngoal (1 subgoal):\n 1. \\<And>a. is_unit a \\<Longrightarrow> unit_factor a = a", "show \"unit_factor a = a\" if \"is_unit a\" for a :: \"'a ratfps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_factor a = a", "by (rule ratfps_eqI) (insert that, auto simp: fps_of_ratfps_is_unit)"], ["proof (state)\nthis:\n  is_unit ?a \\<Longrightarrow> unit_factor ?a = ?a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instance ratfps :: (\"field_gcd\") normalization_semidom_multiplicative"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ratfps, normalization_semidom_multiplicative_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. unit_factor (a * b) = unit_factor a * unit_factor b", "show \"unit_factor (a * b) = unit_factor a * unit_factor b\" for a b :: \"'a ratfps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_factor (a * b) = unit_factor a * unit_factor b", "by (rule ratfps_eqI, insert unit_factor_mult[of \"fps_of_ratfps a\" \"fps_of_ratfps b\"])\n       (simp del: fps_of_ratfps_eq_iff)"], ["proof (state)\nthis:\n  unit_factor (?a * ?b) = unit_factor ?a * unit_factor ?b\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation ratfps :: (\"field_gcd\") semidom_modulo\nbegin"], ["", "lift_definition modulo_ratfps :: \"'a ratfps \\<Rightarrow> 'a ratfps \\<Rightarrow> 'a ratfps\" is\n  \"\\<lambda>f g. if g = 0 then f else \n           let n = ratfps_subdegree g; h = ratfps_shift n g\n           in  ratfps_of_poly (ratfps_cutoff n (f * inverse h)) * h\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma fps_of_ratfps_mod [simp]: \n   \"fps_of_ratfps (f mod g :: 'a ratfps) = fps_of_ratfps f mod fps_of_ratfps g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (f mod g) = fps_of_ratfps f mod fps_of_ratfps g", "unfolding fps_mod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (f mod g) =\n    (if fps_of_ratfps g = 0 then fps_of_ratfps f\n     else let h = unit_factor (fps_of_ratfps g)\n          in fps_cutoff (subdegree (fps_of_ratfps g))\n              (fps_of_ratfps f * inverse h) *\n             h)", "by transfer' (simp add: Let_def ratfps_subdegree_altdef)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ratfps, semidom_modulo_class)", "by standard (auto intro: ratfps_eqI)"], ["", "end"], ["", "instantiation ratfps :: (\"field_gcd\") euclidean_ring\nbegin"], ["", "definition euclidean_size_ratfps :: \"'a ratfps \\<Rightarrow> nat\" where\n  \"euclidean_size_ratfps x = (if x = 0 then 0 else 2 ^ ratfps_subdegree x)\""], ["", "lemma fps_of_ratfps_euclidean_size [simp]:\n  \"euclidean_size x = euclidean_size (fps_of_ratfps x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean_size x = euclidean_size (fps_of_ratfps x)", "unfolding euclidean_size_ratfps_def fps_euclidean_size_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x = 0 then 0 else 2 ^ ratfps_subdegree x) =\n    (if fps_of_ratfps x = 0 then 0 else 2 ^ subdegree (fps_of_ratfps x))", "by (simp add: ratfps_subdegree_altdef)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ratfps, euclidean_ring_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. euclidean_size 0 = 0\n 2. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size (a mod b) < euclidean_size b\n 3. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size a \\<le> euclidean_size (a * b)", "show \"euclidean_size (0 :: 'a ratfps) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean_size 0 = 0", "by simp"], ["proof (state)\nthis:\n  euclidean_size 0 = 0\n\ngoal (2 subgoals):\n 1. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size (a mod b) < euclidean_size b\n 2. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size a \\<le> euclidean_size (a * b)", "show \"euclidean_size (a mod b) < euclidean_size b\"\n       \"euclidean_size a \\<le> euclidean_size (a * b)\" if \"b \\<noteq> 0\" for a b :: \"'a ratfps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean_size (a mod b) < euclidean_size b &&&\n    euclidean_size a \\<le> euclidean_size (a * b)", "using that"], ["proof (prove)\nusing this:\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. euclidean_size (a mod b) < euclidean_size b &&&\n    euclidean_size a \\<le> euclidean_size (a * b)", "by (simp_all add: mod_size_less size_mult_mono)"], ["proof (state)\nthis:\n  ?b \\<noteq> 0 \\<Longrightarrow>\n  euclidean_size (?a mod ?b) < euclidean_size ?b\n  ?b \\<noteq> 0 \\<Longrightarrow>\n  euclidean_size ?a \\<le> euclidean_size (?a * ?b)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation ratfps :: (\"field_gcd\") euclidean_ring_cancel\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ratfps, euclidean_ring_cancel_class)", "by standard (auto intro: ratfps_eqI)"], ["", "end"], ["", "lemma quot_of_ratfps_eq_iff [simp]: \"quot_of_ratfps x = quot_of_ratfps y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (quot_of_ratfps x = quot_of_ratfps y) = (x = y)", "by transfer simp"], ["", "lemma ratfps_eq_0_code: \"x = 0 \\<longleftrightarrow> fst (quot_of_ratfps x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = 0) = (fst (quot_of_ratfps x) = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> fst (quot_of_ratfps x) = 0\n 2. fst (quot_of_ratfps x) = 0 \\<Longrightarrow> x = 0", "assume \"fst (quot_of_ratfps x) = 0\""], ["proof (state)\nthis:\n  fst (quot_of_ratfps x) = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> fst (quot_of_ratfps x) = 0\n 2. fst (quot_of_ratfps x) = 0 \\<Longrightarrow> x = 0", "moreover"], ["proof (state)\nthis:\n  fst (quot_of_ratfps x) = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> fst (quot_of_ratfps x) = 0\n 2. fst (quot_of_ratfps x) = 0 \\<Longrightarrow> x = 0", "have \"coprime (fst (quot_of_ratfps x)) (snd (quot_of_ratfps x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (fst (quot_of_ratfps x)) (snd (quot_of_ratfps x))", "by transfer (simp add: coprime_quot_of_fract)"], ["proof (state)\nthis:\n  coprime (fst (quot_of_ratfps x)) (snd (quot_of_ratfps x))\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> fst (quot_of_ratfps x) = 0\n 2. fst (quot_of_ratfps x) = 0 \\<Longrightarrow> x = 0", "moreover"], ["proof (state)\nthis:\n  coprime (fst (quot_of_ratfps x)) (snd (quot_of_ratfps x))\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> fst (quot_of_ratfps x) = 0\n 2. fst (quot_of_ratfps x) = 0 \\<Longrightarrow> x = 0", "have \"normalize (snd (quot_of_ratfps x)) = snd (quot_of_ratfps x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (snd (quot_of_ratfps x)) = snd (quot_of_ratfps x)", "by (simp add: div_unit_factor [symmetric] del: div_unit_factor)"], ["proof (state)\nthis:\n  normalize (snd (quot_of_ratfps x)) = snd (quot_of_ratfps x)\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> fst (quot_of_ratfps x) = 0\n 2. fst (quot_of_ratfps x) = 0 \\<Longrightarrow> x = 0", "ultimately"], ["proof (chain)\npicking this:\n  fst (quot_of_ratfps x) = 0\n  coprime (fst (quot_of_ratfps x)) (snd (quot_of_ratfps x))\n  normalize (snd (quot_of_ratfps x)) = snd (quot_of_ratfps x)", "have \"quot_of_ratfps x = (0,1)\""], ["proof (prove)\nusing this:\n  fst (quot_of_ratfps x) = 0\n  coprime (fst (quot_of_ratfps x)) (snd (quot_of_ratfps x))\n  normalize (snd (quot_of_ratfps x)) = snd (quot_of_ratfps x)\n\ngoal (1 subgoal):\n 1. quot_of_ratfps x = (0, 1)", "by (simp add: prod_eq_iff normalize_idem_imp_is_unit_iff)"], ["proof (state)\nthis:\n  quot_of_ratfps x = (0, 1)\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> fst (quot_of_ratfps x) = 0\n 2. fst (quot_of_ratfps x) = 0 \\<Longrightarrow> x = 0", "also"], ["proof (state)\nthis:\n  quot_of_ratfps x = (0, 1)\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> fst (quot_of_ratfps x) = 0\n 2. fst (quot_of_ratfps x) = 0 \\<Longrightarrow> x = 0", "have \"\\<dots> = quot_of_ratfps 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0, 1) = quot_of_ratfps 0", "by simp"], ["proof (state)\nthis:\n  (0, 1) = quot_of_ratfps 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> fst (quot_of_ratfps x) = 0\n 2. fst (quot_of_ratfps x) = 0 \\<Longrightarrow> x = 0", "finally"], ["proof (chain)\npicking this:\n  quot_of_ratfps x = quot_of_ratfps 0", "show \"x = 0\""], ["proof (prove)\nusing this:\n  quot_of_ratfps x = quot_of_ratfps 0\n\ngoal (1 subgoal):\n 1. x = 0", "by (subst (asm) quot_of_ratfps_eq_iff)"], ["proof (state)\nthis:\n  x = 0\n\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow> fst (quot_of_ratfps x) = 0", "qed simp_all"], ["", "lemma fps_dvd_code [code_unfold]:\n  \"x dvd y \\<longleftrightarrow> y = 0 \\<or> ((x::'a::field_gcd fps) \\<noteq> 0 \\<and> subdegree x \\<le> subdegree y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x dvd y) =\n    (y = 0 \\<or> x \\<noteq> 0 \\<and> subdegree x \\<le> subdegree y)", "using fps_dvd_iff[of x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<noteq> 0; y \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (x dvd y) = (subdegree x \\<le> subdegree y)\n\ngoal (1 subgoal):\n 1. (x dvd y) =\n    (y = 0 \\<or> x \\<noteq> 0 \\<and> subdegree x \\<le> subdegree y)", "by (cases \"x = 0\") auto"], ["", "lemma ratfps_dvd_code [code_unfold]: \n  \"x dvd y \\<longleftrightarrow> y = 0 \\<or> (x \\<noteq> 0 \\<and> ratfps_subdegree x \\<le> ratfps_subdegree y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x dvd y) =\n    (y = 0 \\<or>\n     x \\<noteq> 0 \\<and> ratfps_subdegree x \\<le> ratfps_subdegree y)", "using fps_dvd_code [of \"fps_of_ratfps x\" \"fps_of_ratfps y\"]"], ["proof (prove)\nusing this:\n  (fps_of_ratfps x dvd fps_of_ratfps y) =\n  (fps_of_ratfps y = 0 \\<or>\n   fps_of_ratfps x \\<noteq> 0 \\<and>\n   subdegree (fps_of_ratfps x) \\<le> subdegree (fps_of_ratfps y))\n\ngoal (1 subgoal):\n 1. (x dvd y) =\n    (y = 0 \\<or>\n     x \\<noteq> 0 \\<and> ratfps_subdegree x \\<le> ratfps_subdegree y)", "by (simp add: ratfps_subdegree_altdef)"], ["", "instance ratfps :: (\"field_gcd\") normalization_euclidean_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ratfps, normalization_euclidean_semiring_class)", ".."], ["", "instantiation ratfps :: (\"field_gcd\") euclidean_ring_gcd\nbegin"], ["", "definition \"gcd_ratfps = (Euclidean_Algorithm.gcd :: 'a ratfps \\<Rightarrow> _)\""], ["", "definition \"lcm_ratfps = (Euclidean_Algorithm.lcm :: 'a ratfps \\<Rightarrow> _)\""], ["", "definition \"Gcd_ratfps = (Euclidean_Algorithm.Gcd :: 'a ratfps set \\<Rightarrow> _)\""], ["", "definition \"Lcm_ratfps = (Euclidean_Algorithm.Lcm:: 'a ratfps set \\<Rightarrow> _)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ratfps, euclidean_ring_gcd_class)", "by standard (simp_all add: gcd_ratfps_def lcm_ratfps_def Gcd_ratfps_def Lcm_ratfps_def)"], ["", "end"], ["", "lemma ratfps_eq_0_iff: \"x = 0 \\<longleftrightarrow> fps_of_ratfps x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = 0) = (fps_of_ratfps x = 0)", "using fps_of_ratfps_eq_iff[of x 0]"], ["proof (prove)\nusing this:\n  (fps_of_ratfps x = fps_of_ratfps 0) = (x = 0)\n\ngoal (1 subgoal):\n 1. (x = 0) = (fps_of_ratfps x = 0)", "unfolding fps_of_ratfps_0"], ["proof (prove)\nusing this:\n  (fps_of_ratfps x = 0) = (x = 0)\n\ngoal (1 subgoal):\n 1. (x = 0) = (fps_of_ratfps x = 0)", "by simp"], ["", "lemma ratfps_of_poly_eq_0_iff: \"ratfps_of_poly x = 0 \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ratfps_of_poly x = 0) = (x = 0)", "by (auto simp: ratfps_eq_0_iff)"], ["", "lemma ratfps_gcd:\n  assumes [simp]: \"f \\<noteq> 0\" \"g \\<noteq> 0\"\n  shows   \"gcd f g = ratfps_of_poly (monom 1 (min (ratfps_subdegree f) (ratfps_subdegree g)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f g =\n    ratfps_of_poly\n     (monom (1::'a) (min (ratfps_subdegree f) (ratfps_subdegree g)))", "by (rule sym, rule gcdI)\n     (auto simp: ratfps_subdegree_altdef ratfps_dvd_code subdegree_fps_of_poly\n         ratfps_of_poly_eq_0_iff normalize_ratfps_def)"], ["", "lemma ratfps_gcd_altdef: \"gcd (f :: 'a :: field_gcd ratfps) g =\n  (if f = 0 \\<and> g = 0 then 0 else\n   if f = 0 then ratfps_of_poly (monom 1 (ratfps_subdegree g)) else\n   if g = 0 then ratfps_of_poly (monom 1 (ratfps_subdegree f)) else\n     ratfps_of_poly (monom 1 (min (ratfps_subdegree f) (ratfps_subdegree g))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f g =\n    (if f = 0 \\<and> g = 0 then 0\n     else if f = 0 then ratfps_of_poly (monom (1::'a) (ratfps_subdegree g))\n          else if g = 0\n               then ratfps_of_poly (monom (1::'a) (ratfps_subdegree f))\n               else ratfps_of_poly\n                     (monom (1::'a)\n                       (min (ratfps_subdegree f) (ratfps_subdegree g))))", "by (simp add: ratfps_gcd normalize_ratfps_def)"], ["", "lemma ratfps_lcm:\n  assumes [simp]: \"f \\<noteq> 0\" \"g \\<noteq> 0\"\n  shows   \"lcm f g = ratfps_of_poly (monom 1 (max (ratfps_subdegree f) (ratfps_subdegree g)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcm f g =\n    ratfps_of_poly\n     (monom (1::'a) (max (ratfps_subdegree f) (ratfps_subdegree g)))", "by (rule sym, rule lcmI)\n     (auto simp: ratfps_subdegree_altdef ratfps_dvd_code subdegree_fps_of_poly\n         ratfps_of_poly_eq_0_iff normalize_ratfps_def)"], ["", "lemma ratfps_lcm_altdef: \"lcm (f :: 'a :: field_gcd ratfps) g =\n  (if f = 0 \\<or> g = 0 then 0 else \n     ratfps_of_poly (monom 1 (max (ratfps_subdegree f) (ratfps_subdegree g))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcm f g =\n    (if f = 0 \\<or> g = 0 then 0\n     else ratfps_of_poly\n           (monom (1::'a) (max (ratfps_subdegree f) (ratfps_subdegree g))))", "by (simp add: ratfps_lcm)"], ["", "lemma ratfps_Gcd:\n  assumes \"A - {0} \\<noteq> {}\"\n  shows   \"Gcd A = ratfps_of_poly (monom 1 (INF f\\<in>A-{0}. ratfps_subdegree f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gcd A =\n    ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))", "proof (rule sym, rule GcdI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ratfps_of_poly\n        (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0})))) dvd\n       a\n 2. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> c dvd a) \\<Longrightarrow>\n       c dvd\n       ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))\n 3. normalize\n     (ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))) =\n    ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))", "fix f"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ratfps_of_poly\n        (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0})))) dvd\n       a\n 2. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> c dvd a) \\<Longrightarrow>\n       c dvd\n       ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))\n 3. normalize\n     (ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))) =\n    ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))", "assume \"f \\<in> A\""], ["proof (state)\nthis:\n  f \\<in> A\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ratfps_of_poly\n        (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0})))) dvd\n       a\n 2. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> c dvd a) \\<Longrightarrow>\n       c dvd\n       ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))\n 3. normalize\n     (ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))) =\n    ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))", "thus \"ratfps_of_poly (monom 1 (INF f\\<in>A - {0}. ratfps_subdegree f)) dvd f\""], ["proof (prove)\nusing this:\n  f \\<in> A\n\ngoal (1 subgoal):\n 1. ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0})))) dvd\n    f", "by (cases \"f = 0\") (auto simp: ratfps_dvd_code ratfps_of_poly_eq_0_iff ratfps_subdegree_altdef\n                          subdegree_fps_of_poly intro!: cINF_lower)"], ["proof (state)\nthis:\n  ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0})))) dvd f\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> c dvd a) \\<Longrightarrow>\n       c dvd\n       ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))\n 2. normalize\n     (ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))) =\n    ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> c dvd a) \\<Longrightarrow>\n       c dvd\n       ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))\n 2. normalize\n     (ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))) =\n    ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))", "fix d"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> c dvd a) \\<Longrightarrow>\n       c dvd\n       ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))\n 2. normalize\n     (ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))) =\n    ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))", "assume d: \"\\<And>f. f \\<in> A \\<Longrightarrow> d dvd f\""], ["proof (state)\nthis:\n  ?f \\<in> A \\<Longrightarrow> d dvd ?f\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> c dvd a) \\<Longrightarrow>\n       c dvd\n       ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))\n 2. normalize\n     (ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))) =\n    ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))", "from assms"], ["proof (chain)\npicking this:\n  A - {0} \\<noteq> {}", "obtain f where \"f \\<in> A - {0}\""], ["proof (prove)\nusing this:\n  A - {0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>f. f \\<in> A - {0} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f \\<in> A - {0}\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> c dvd a) \\<Longrightarrow>\n       c dvd\n       ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))\n 2. normalize\n     (ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))) =\n    ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))", "with d[of f]"], ["proof (chain)\npicking this:\n  f \\<in> A \\<Longrightarrow> d dvd f\n  f \\<in> A - {0}", "have [simp]: \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f \\<in> A \\<Longrightarrow> d dvd f\n  f \\<in> A - {0}\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> c dvd a) \\<Longrightarrow>\n       c dvd\n       ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))\n 2. normalize\n     (ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))) =\n    ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))", "from d assms"], ["proof (chain)\npicking this:\n  ?f \\<in> A \\<Longrightarrow> d dvd ?f\n  A - {0} \\<noteq> {}", "have \"ratfps_subdegree d \\<le> (INF f\\<in>A-{0}. ratfps_subdegree f)\""], ["proof (prove)\nusing this:\n  ?f \\<in> A \\<Longrightarrow> d dvd ?f\n  A - {0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. ratfps_subdegree d \\<le> Inf (ratfps_subdegree ` (A - {0}))", "by (intro cINF_greatest) (auto simp: ratfps_dvd_code)"], ["proof (state)\nthis:\n  ratfps_subdegree d \\<le> Inf (ratfps_subdegree ` (A - {0}))\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> c dvd a) \\<Longrightarrow>\n       c dvd\n       ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))\n 2. normalize\n     (ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))) =\n    ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))", "with d assms"], ["proof (chain)\npicking this:\n  ?f \\<in> A \\<Longrightarrow> d dvd ?f\n  A - {0} \\<noteq> {}\n  ratfps_subdegree d \\<le> Inf (ratfps_subdegree ` (A - {0}))", "show \"d dvd ratfps_of_poly (monom 1 (INF f\\<in>A-{0}. ratfps_subdegree f))\""], ["proof (prove)\nusing this:\n  ?f \\<in> A \\<Longrightarrow> d dvd ?f\n  A - {0} \\<noteq> {}\n  ratfps_subdegree d \\<le> Inf (ratfps_subdegree ` (A - {0}))\n\ngoal (1 subgoal):\n 1. d dvd\n    ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))", "by (simp add: ratfps_dvd_code ratfps_subdegree_altdef subdegree_fps_of_poly)"], ["proof (state)\nthis:\n  d dvd ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))\n\ngoal (1 subgoal):\n 1. normalize\n     (ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))) =\n    ratfps_of_poly (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0}))))", "qed (simp_all add: ratfps_subdegree_altdef subdegree_fps_of_poly normalize_ratfps_def)"], ["", "lemma ratfps_Gcd_altdef: \"Gcd (A :: 'a :: field_gcd ratfps set) =\n  (if A \\<subseteq> {0} then 0 else ratfps_of_poly (monom 1 (INF f\\<in>A-{0}. ratfps_subdegree f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gcd A =\n    (if A \\<subseteq> {0} then 0\n     else ratfps_of_poly\n           (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0})))))", "using ratfps_Gcd"], ["proof (prove)\nusing this:\n  ?A - {0} \\<noteq> {} \\<Longrightarrow>\n  Gcd ?A =\n  ratfps_of_poly (monom (1::?'a) (Inf (ratfps_subdegree ` (?A - {0}))))\n\ngoal (1 subgoal):\n 1. Gcd A =\n    (if A \\<subseteq> {0} then 0\n     else ratfps_of_poly\n           (monom (1::'a) (Inf (ratfps_subdegree ` (A - {0})))))", "by auto"], ["", "lemma ratfps_Lcm:\n  assumes \"A \\<noteq> {}\" \"0 \\<notin> A\" \"bdd_above (ratfps_subdegree`A)\"\n  shows   \"Lcm A = ratfps_of_poly (monom 1 (SUP f\\<in>A. ratfps_subdegree f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lcm A = ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))", "proof (rule sym, rule LcmI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       a dvd ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))\n 2. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> a dvd c) \\<Longrightarrow>\n       ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd c\n 3. normalize\n     (ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))) =\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))", "fix f"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       a dvd ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))\n 2. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> a dvd c) \\<Longrightarrow>\n       ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd c\n 3. normalize\n     (ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))) =\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))", "assume \"f \\<in> A\""], ["proof (state)\nthis:\n  f \\<in> A\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       a dvd ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))\n 2. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> a dvd c) \\<Longrightarrow>\n       ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd c\n 3. normalize\n     (ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))) =\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))", "moreover"], ["proof (state)\nthis:\n  f \\<in> A\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       a dvd ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))\n 2. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> a dvd c) \\<Longrightarrow>\n       ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd c\n 3. normalize\n     (ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))) =\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))", "from assms(3)"], ["proof (chain)\npicking this:\n  bdd_above (ratfps_subdegree ` A)", "have \"bdd_above (ratfps_subdegree ` A)\""], ["proof (prove)\nusing this:\n  bdd_above (ratfps_subdegree ` A)\n\ngoal (1 subgoal):\n 1. bdd_above (ratfps_subdegree ` A)", "by auto"], ["proof (state)\nthis:\n  bdd_above (ratfps_subdegree ` A)\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       a dvd ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))\n 2. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> a dvd c) \\<Longrightarrow>\n       ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd c\n 3. normalize\n     (ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))) =\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))", "ultimately"], ["proof (chain)\npicking this:\n  f \\<in> A\n  bdd_above (ratfps_subdegree ` A)", "show \"f dvd ratfps_of_poly (monom 1 (SUP f\\<in>A. ratfps_subdegree f))\""], ["proof (prove)\nusing this:\n  f \\<in> A\n  bdd_above (ratfps_subdegree ` A)\n\ngoal (1 subgoal):\n 1. f dvd ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))", "using assms(2)"], ["proof (prove)\nusing this:\n  f \\<in> A\n  bdd_above (ratfps_subdegree ` A)\n  0 \\<notin> A\n\ngoal (1 subgoal):\n 1. f dvd ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))", "by (cases \"f = 0\") (auto simp: ratfps_dvd_code ratfps_of_poly_eq_0_iff subdegree_fps_of_poly \n                          ratfps_subdegree_altdef [abs_def] intro!: cSUP_upper)"], ["proof (state)\nthis:\n  f dvd ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> a dvd c) \\<Longrightarrow>\n       ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd c\n 2. normalize\n     (ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))) =\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> a dvd c) \\<Longrightarrow>\n       ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd c\n 2. normalize\n     (ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))) =\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))", "fix d"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> a dvd c) \\<Longrightarrow>\n       ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd c\n 2. normalize\n     (ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))) =\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))", "assume d: \"\\<And>f. f \\<in> A \\<Longrightarrow> f dvd d\""], ["proof (state)\nthis:\n  ?f \\<in> A \\<Longrightarrow> ?f dvd d\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> a dvd c) \\<Longrightarrow>\n       ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd c\n 2. normalize\n     (ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))) =\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))", "from assms"], ["proof (chain)\npicking this:\n  A \\<noteq> {}\n  0 \\<notin> A\n  bdd_above (ratfps_subdegree ` A)", "obtain f where f: \"f \\<in> A\" \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n  0 \\<notin> A\n  bdd_above (ratfps_subdegree ` A)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> A; f \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f \\<in> A\n  f \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       (\\<And>a. a \\<in> A \\<Longrightarrow> a dvd c) \\<Longrightarrow>\n       ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd c\n 2. normalize\n     (ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))) =\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))", "show \"ratfps_of_poly (monom 1 (SUP f\\<in>A. ratfps_subdegree f)) dvd d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd d", "proof (cases \"d = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d = 0 \\<Longrightarrow>\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd d\n 2. d \\<noteq> 0 \\<Longrightarrow>\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd d", "assume \"d \\<noteq> 0\""], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (2 subgoals):\n 1. d = 0 \\<Longrightarrow>\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd d\n 2. d \\<noteq> 0 \\<Longrightarrow>\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd d", "moreover"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (2 subgoals):\n 1. d = 0 \\<Longrightarrow>\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd d\n 2. d \\<noteq> 0 \\<Longrightarrow>\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd d", "from d"], ["proof (chain)\npicking this:\n  ?f \\<in> A \\<Longrightarrow> ?f dvd d", "have \"\\<And>f. f \\<in> A \\<Longrightarrow> f \\<noteq> 0 \\<Longrightarrow> f dvd d\""], ["proof (prove)\nusing this:\n  ?f \\<in> A \\<Longrightarrow> ?f dvd d\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> A; f \\<noteq> 0\\<rbrakk> \\<Longrightarrow> f dvd d", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> A; ?f \\<noteq> 0\\<rbrakk> \\<Longrightarrow> ?f dvd d\n\ngoal (2 subgoals):\n 1. d = 0 \\<Longrightarrow>\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd d\n 2. d \\<noteq> 0 \\<Longrightarrow>\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd d", "ultimately"], ["proof (chain)\npicking this:\n  d \\<noteq> 0\n  \\<lbrakk>?f \\<in> A; ?f \\<noteq> 0\\<rbrakk> \\<Longrightarrow> ?f dvd d", "have \"ratfps_subdegree d \\<ge> (SUP f\\<in>A. ratfps_subdegree f)\""], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n  \\<lbrakk>?f \\<in> A; ?f \\<noteq> 0\\<rbrakk> \\<Longrightarrow> ?f dvd d\n\ngoal (1 subgoal):\n 1. Sup (ratfps_subdegree ` A) \\<le> ratfps_subdegree d", "using assms"], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n  \\<lbrakk>?f \\<in> A; ?f \\<noteq> 0\\<rbrakk> \\<Longrightarrow> ?f dvd d\n  A \\<noteq> {}\n  0 \\<notin> A\n  bdd_above (ratfps_subdegree ` A)\n\ngoal (1 subgoal):\n 1. Sup (ratfps_subdegree ` A) \\<le> ratfps_subdegree d", "by (intro cSUP_least) (auto simp: ratfps_dvd_code)"], ["proof (state)\nthis:\n  Sup (ratfps_subdegree ` A) \\<le> ratfps_subdegree d\n\ngoal (2 subgoals):\n 1. d = 0 \\<Longrightarrow>\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd d\n 2. d \\<noteq> 0 \\<Longrightarrow>\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd d", "with \\<open>d \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  d \\<noteq> 0\n  Sup (ratfps_subdegree ` A) \\<le> ratfps_subdegree d", "show ?thesis"], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n  Sup (ratfps_subdegree ` A) \\<le> ratfps_subdegree d\n\ngoal (1 subgoal):\n 1. ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd d", "by (simp add: ratfps_dvd_code ratfps_of_poly_eq_0_iff \n          ratfps_subdegree_altdef subdegree_fps_of_poly)"], ["proof (state)\nthis:\n  ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd d\n\ngoal (1 subgoal):\n 1. d = 0 \\<Longrightarrow>\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd d", "qed simp_all"], ["proof (state)\nthis:\n  ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))) dvd d\n\ngoal (1 subgoal):\n 1. normalize\n     (ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))) =\n    ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A)))", "qed (simp_all add: ratfps_subdegree_altdef subdegree_fps_of_poly normalize_ratfps_def)"], ["", "lemma ratfps_Lcm_altdef:\n  \"Lcm (A :: 'a :: field_gcd ratfps set) =\n     (if 0 \\<in> A \\<or> \\<not>bdd_above (ratfps_subdegree`A) then 0 else\n      if A = {} then 1 else ratfps_of_poly (monom 1 (SUP f\\<in>A. ratfps_subdegree f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lcm A =\n    (if 0 \\<in> A \\<or> \\<not> bdd_above (ratfps_subdegree ` A) then 0\n     else if A = {} then 1\n          else ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))))", "proof (cases \"bdd_above (ratfps_subdegree`A)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. bdd_above (ratfps_subdegree ` A) \\<Longrightarrow>\n    Lcm A =\n    (if 0 \\<in> A \\<or> \\<not> bdd_above (ratfps_subdegree ` A) then 0\n     else if A = {} then 1\n          else ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))))\n 2. \\<not> bdd_above (ratfps_subdegree ` A) \\<Longrightarrow>\n    Lcm A =\n    (if 0 \\<in> A \\<or> \\<not> bdd_above (ratfps_subdegree ` A) then 0\n     else if A = {} then 1\n          else ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))))", "assume unbounded: \"\\<not>bdd_above (ratfps_subdegree`A)\""], ["proof (state)\nthis:\n  \\<not> bdd_above (ratfps_subdegree ` A)\n\ngoal (2 subgoals):\n 1. bdd_above (ratfps_subdegree ` A) \\<Longrightarrow>\n    Lcm A =\n    (if 0 \\<in> A \\<or> \\<not> bdd_above (ratfps_subdegree ` A) then 0\n     else if A = {} then 1\n          else ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))))\n 2. \\<not> bdd_above (ratfps_subdegree ` A) \\<Longrightarrow>\n    Lcm A =\n    (if 0 \\<in> A \\<or> \\<not> bdd_above (ratfps_subdegree ` A) then 0\n     else if A = {} then 1\n          else ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))))", "have \"Lcm A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lcm A = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. Lcm A \\<noteq> 0 \\<Longrightarrow> False", "assume \"Lcm A \\<noteq> 0\""], ["proof (state)\nthis:\n  Lcm A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Lcm A \\<noteq> 0 \\<Longrightarrow> False", "from unbounded"], ["proof (chain)\npicking this:\n  \\<not> bdd_above (ratfps_subdegree ` A)", "obtain f where f: \"f \\<in> A\" \"ratfps_subdegree (Lcm A) < ratfps_subdegree f\""], ["proof (prove)\nusing this:\n  \\<not> bdd_above (ratfps_subdegree ` A)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> A;\n         ratfps_subdegree (Lcm A) < ratfps_subdegree f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding bdd_above_def"], ["proof (prove)\nusing this:\n  \\<nexists>M. \\<forall>x\\<in>ratfps_subdegree ` A. x \\<le> M\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> A;\n         ratfps_subdegree (Lcm A) < ratfps_subdegree f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: not_le)"], ["proof (state)\nthis:\n  f \\<in> A\n  ratfps_subdegree (Lcm A) < ratfps_subdegree f\n\ngoal (1 subgoal):\n 1. Lcm A \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  f \\<in> A\n  ratfps_subdegree (Lcm A) < ratfps_subdegree f\n\ngoal (1 subgoal):\n 1. Lcm A \\<noteq> 0 \\<Longrightarrow> False", "from this and \\<open>Lcm A \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> A\n  ratfps_subdegree (Lcm A) < ratfps_subdegree f\n  Lcm A \\<noteq> 0", "have \"ratfps_subdegree f \\<le> ratfps_subdegree (Lcm A)\""], ["proof (prove)\nusing this:\n  f \\<in> A\n  ratfps_subdegree (Lcm A) < ratfps_subdegree f\n  Lcm A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ratfps_subdegree f \\<le> ratfps_subdegree (Lcm A)", "using dvd_Lcm[of f A]"], ["proof (prove)\nusing this:\n  f \\<in> A\n  ratfps_subdegree (Lcm A) < ratfps_subdegree f\n  Lcm A \\<noteq> 0\n  f \\<in> A \\<Longrightarrow> f dvd Lcm A\n\ngoal (1 subgoal):\n 1. ratfps_subdegree f \\<le> ratfps_subdegree (Lcm A)", "by (auto simp: ratfps_dvd_code)"], ["proof (state)\nthis:\n  ratfps_subdegree f \\<le> ratfps_subdegree (Lcm A)\n\ngoal (1 subgoal):\n 1. Lcm A \\<noteq> 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  f \\<in> A\n  ratfps_subdegree (Lcm A) < ratfps_subdegree f\n  ratfps_subdegree f \\<le> ratfps_subdegree (Lcm A)", "show False"], ["proof (prove)\nusing this:\n  f \\<in> A\n  ratfps_subdegree (Lcm A) < ratfps_subdegree f\n  ratfps_subdegree f \\<le> ratfps_subdegree (Lcm A)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Lcm A = 0\n\ngoal (2 subgoals):\n 1. bdd_above (ratfps_subdegree ` A) \\<Longrightarrow>\n    Lcm A =\n    (if 0 \\<in> A \\<or> \\<not> bdd_above (ratfps_subdegree ` A) then 0\n     else if A = {} then 1\n          else ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))))\n 2. \\<not> bdd_above (ratfps_subdegree ` A) \\<Longrightarrow>\n    Lcm A =\n    (if 0 \\<in> A \\<or> \\<not> bdd_above (ratfps_subdegree ` A) then 0\n     else if A = {} then 1\n          else ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))))", "with unbounded"], ["proof (chain)\npicking this:\n  \\<not> bdd_above (ratfps_subdegree ` A)\n  Lcm A = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> bdd_above (ratfps_subdegree ` A)\n  Lcm A = 0\n\ngoal (1 subgoal):\n 1. Lcm A =\n    (if 0 \\<in> A \\<or> \\<not> bdd_above (ratfps_subdegree ` A) then 0\n     else if A = {} then 1\n          else ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))))", "by simp"], ["proof (state)\nthis:\n  Lcm A =\n  (if 0 \\<in> A \\<or> \\<not> bdd_above (ratfps_subdegree ` A) then 0\n   else if A = {} then 1\n        else ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))))\n\ngoal (1 subgoal):\n 1. bdd_above (ratfps_subdegree ` A) \\<Longrightarrow>\n    Lcm A =\n    (if 0 \\<in> A \\<or> \\<not> bdd_above (ratfps_subdegree ` A) then 0\n     else if A = {} then 1\n          else ratfps_of_poly (monom (1::'a) (Sup (ratfps_subdegree ` A))))", "qed (simp_all add: ratfps_Lcm Lcm_eq_0_I)"], ["", "lemma fps_of_ratfps_quot_to_ratfps:\n  \"coeff y 0 \\<noteq> 0 \\<Longrightarrow> fps_of_ratfps (quot_to_ratfps (x,y)) = fps_of_poly x / fps_of_poly y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_term y \\<noteq> (0::'a) \\<Longrightarrow>\n    fps_of_ratfps (quot_to_ratfps (x, y)) = fps_of_poly x / fps_of_poly y", "proof (transfer, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       constant_term y \\<noteq> (0::'a) \\<Longrightarrow>\n       fps_of_poly\n        (numerator\n          (case (x, y) of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) /\n       fps_of_poly\n        (denominator\n          (case (x, y) of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) =\n       fps_of_poly x / fps_of_poly y", "case (1 y x)"], ["proof (state)\nthis:\n  constant_term y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y x.\n       constant_term y \\<noteq> (0::'a) \\<Longrightarrow>\n       fps_of_poly\n        (numerator\n          (case (x, y) of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) /\n       fps_of_poly\n        (denominator\n          (case (x, y) of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) =\n       fps_of_poly x / fps_of_poly y", "define x' y' where \"x' = fst (normalize_quot (x,y))\" and \"y' = snd (normalize_quot (x,y))\""], ["proof (state)\nthis:\n  x' = fst (normalize_quot (x, y))\n  y' = snd (normalize_quot (x, y))\n\ngoal (1 subgoal):\n 1. \\<And>y x.\n       constant_term y \\<noteq> (0::'a) \\<Longrightarrow>\n       fps_of_poly\n        (numerator\n          (case (x, y) of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) /\n       fps_of_poly\n        (denominator\n          (case (x, y) of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) =\n       fps_of_poly x / fps_of_poly y", "from 1"], ["proof (chain)\npicking this:\n  constant_term y \\<noteq> (0::'a)", "have nz: \"y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  constant_term y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>y x.\n       constant_term y \\<noteq> (0::'a) \\<Longrightarrow>\n       fps_of_poly\n        (numerator\n          (case (x, y) of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) /\n       fps_of_poly\n        (denominator\n          (case (x, y) of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) =\n       fps_of_poly x / fps_of_poly y", "have eq: \"normalize_quot (x', y') = (x', y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize_quot (x', y') = (x', y')", "by (simp add: x'_def y'_def)"], ["proof (state)\nthis:\n  normalize_quot (x', y') = (x', y')\n\ngoal (1 subgoal):\n 1. \\<And>y x.\n       constant_term y \\<noteq> (0::'a) \\<Longrightarrow>\n       fps_of_poly\n        (numerator\n          (case (x, y) of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) /\n       fps_of_poly\n        (denominator\n          (case (x, y) of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) =\n       fps_of_poly x / fps_of_poly y", "from normalize_quotE[OF nz, of x]"], ["proof (chain)\npicking this:\n  (\\<And>d.\n      \\<lbrakk>x = fst (normalize_quot (x, y)) * d;\n       y = snd (normalize_quot (x, y)) * d; d dvd x; d dvd y;\n       d \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "guess d"], ["proof (prove)\nusing this:\n  (\\<And>d.\n      \\<lbrakk>x = fst (normalize_quot (x, y)) * d;\n       y = snd (normalize_quot (x, y)) * d; d dvd x; d dvd y;\n       d \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  x = fst (normalize_quot (x, y)) * d\n  y = snd (normalize_quot (x, y)) * d\n  d dvd x\n  d dvd y\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>y x.\n       constant_term y \\<noteq> (0::'a) \\<Longrightarrow>\n       fps_of_poly\n        (numerator\n          (case (x, y) of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) /\n       fps_of_poly\n        (denominator\n          (case (x, y) of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) =\n       fps_of_poly x / fps_of_poly y", "note d = this [folded x'_def y'_def]"], ["proof (state)\nthis:\n  x = x' * d\n  y = y' * d\n  d dvd x\n  d dvd y\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>y x.\n       constant_term y \\<noteq> (0::'a) \\<Longrightarrow>\n       fps_of_poly\n        (numerator\n          (case (x, y) of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) /\n       fps_of_poly\n        (denominator\n          (case (x, y) of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) =\n       fps_of_poly x / fps_of_poly y", "have \"(case quot_of_fract (if coeff y' 0 = 0 then 0 else quot_to_fract (x', y')) of\n          (a, b) \\<Rightarrow> fps_of_poly a / fps_of_poly b) = fps_of_poly x / fps_of_poly y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case quot_of_fract\n           (if constant_term y' = (0::'a) then 0\n            else quot_to_fract (x', y')) of\n     (a, b) \\<Rightarrow> fps_of_poly a / fps_of_poly b) =\n    fps_of_poly x / fps_of_poly y", "using d eq 1"], ["proof (prove)\nusing this:\n  x = x' * d\n  y = y' * d\n  d dvd x\n  d dvd y\n  d \\<noteq> 0\n  normalize_quot (x', y') = (x', y')\n  constant_term y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (case quot_of_fract\n           (if constant_term y' = (0::'a) then 0\n            else quot_to_fract (x', y')) of\n     (a, b) \\<Rightarrow> fps_of_poly a / fps_of_poly b) =\n    fps_of_poly x / fps_of_poly y", "by (auto simp: case_prod_unfold fps_of_poly_simps quot_of_fract_quot_to_fract \n                                Let_def coeff_0_mult)"], ["proof (state)\nthis:\n  (case quot_of_fract\n         (if constant_term y' = (0::'a) then 0\n          else quot_to_fract (x', y')) of\n   (a, b) \\<Rightarrow> fps_of_poly a / fps_of_poly b) =\n  fps_of_poly x / fps_of_poly y\n\ngoal (1 subgoal):\n 1. \\<And>y x.\n       constant_term y \\<noteq> (0::'a) \\<Longrightarrow>\n       fps_of_poly\n        (numerator\n          (case (x, y) of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) /\n       fps_of_poly\n        (denominator\n          (case (x, y) of\n           (x, y) \\<Rightarrow>\n             let (x', y') = normalize_quot (x, y)\n             in if constant_term y' = (0::'a) then 0\n                else quot_to_fract (x', y'))) =\n       fps_of_poly x / fps_of_poly y", "thus ?case"], ["proof (prove)\nusing this:\n  (case quot_of_fract\n         (if constant_term y' = (0::'a) then 0\n          else quot_to_fract (x', y')) of\n   (a, b) \\<Rightarrow> fps_of_poly a / fps_of_poly b) =\n  fps_of_poly x / fps_of_poly y\n\ngoal (1 subgoal):\n 1. fps_of_poly\n     (numerator\n       (case (x, y) of\n        (x, y) \\<Rightarrow>\n          let (x', y') = normalize_quot (x, y)\n          in if constant_term y' = (0::'a) then 0\n             else quot_to_fract (x', y'))) /\n    fps_of_poly\n     (denominator\n       (case (x, y) of\n        (x, y) \\<Rightarrow>\n          let (x', y') = normalize_quot (x, y)\n          in if constant_term y' = (0::'a) then 0\n             else quot_to_fract (x', y'))) =\n    fps_of_poly x / fps_of_poly y", "by (auto simp add: Let_def case_prod_unfold x'_def y'_def)"], ["proof (state)\nthis:\n  fps_of_poly\n   (numerator\n     (case (x, y) of\n      (x, y) \\<Rightarrow>\n        let (x', y') = normalize_quot (x, y)\n        in if constant_term y' = (0::'a) then 0\n           else quot_to_fract (x', y'))) /\n  fps_of_poly\n   (denominator\n     (case (x, y) of\n      (x, y) \\<Rightarrow>\n        let (x', y') = normalize_quot (x, y)\n        in if constant_term y' = (0::'a) then 0\n           else quot_to_fract (x', y'))) =\n  fps_of_poly x / fps_of_poly y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fps_of_ratfps_quot_to_ratfps_code_post1:\n  \"fps_of_ratfps (quot_to_ratfps (x,pCons 1 y)) = fps_of_poly x / fps_of_poly (pCons 1 y)\"\n  \"fps_of_ratfps (quot_to_ratfps (x,pCons (-1) y)) = fps_of_poly x / fps_of_poly (pCons (-1) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (quot_to_ratfps (x, pCons (1::'a) y)) =\n    fps_of_poly x / fps_of_poly (pCons (1::'a) y) &&&\n    fps_of_ratfps (quot_to_ratfps (x, pCons (- (1::'a)) y)) =\n    fps_of_poly x / fps_of_poly (pCons (- (1::'a)) y)", "by (simp_all add: fps_of_ratfps_quot_to_ratfps)"], ["", "lemma fps_of_ratfps_quot_to_ratfps_code_post2:\n  \"fps_of_ratfps (quot_to_ratfps (x'::'a::{field_char_0,field_gcd} poly,pCons (numeral n) y')) = \n     fps_of_poly x' / fps_of_poly (pCons (numeral n) y')\"\n  \"fps_of_ratfps (quot_to_ratfps (x'::'a::{field_char_0,field_gcd} poly,pCons (-numeral n) y')) = \n     fps_of_poly x' / fps_of_poly (pCons (-numeral n) y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_of_ratfps (quot_to_ratfps (x', pCons (numeral n) y')) =\n    fps_of_poly x' / fps_of_poly (pCons (numeral n) y') &&&\n    fps_of_ratfps (quot_to_ratfps (x', pCons (- numeral n) y')) =\n    fps_of_poly x' / fps_of_poly (pCons (- numeral n) y')", "by (simp_all add: fps_of_ratfps_quot_to_ratfps)"], ["", "lemmas fps_of_ratfps_quot_to_ratfps_code_post [code_post] =\n  fps_of_ratfps_quot_to_ratfps_code_post1\n  fps_of_ratfps_quot_to_ratfps_code_post2"], ["", "lemma fps_dehorner: \n  fixes a b c :: \"'a :: semiring_1 fps\" and d e f :: \"'b :: ring_1 fps\"\n  shows\n  \"(b + c) * fps_X = b * fps_X + c * fps_X\" \"(a * fps_X) * fps_X = a * fps_X ^ 2\" \n  \"a * fps_X ^ m * fps_X = a * fps_X ^ (Suc m)\" \"a * fps_X * fps_X ^ m = a * fps_X ^ (Suc m)\" \n  \"a * fps_X^m * fps_X^n = a * fps_X^(m+n)\" \"a + (b + c) = a + b + c\" \"a * 1 = a\" \"1 * a = a\"\n  \"d + - e = d - e\" \"(-d) * e = - (d * e)\" \"d + (e - f) = d + e - f\"\n  \"(d - e) * fps_X = d * fps_X - e * fps_X\" \"fps_X * fps_X = fps_X^2\" \"fps_X * fps_X^m = fps_X^(Suc m)\" \"fps_X^m * fps_X = fps_X^Suc m\"\n  \"fps_X^m * fps_X^n = fps_X^(m + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((b + c) * fps_X = b * fps_X + c * fps_X &&&\n       a * fps_X * fps_X = a * fps_X\\<^sup>2) &&&\n      a * fps_X ^ m * fps_X = a * fps_X ^ Suc m &&&\n      a * fps_X * fps_X ^ m = a * fps_X ^ Suc m) &&&\n     (a * fps_X ^ m * fps_X ^ n = a * fps_X ^ (m + n) &&&\n      a + (b + c) = a + b + c) &&&\n     a * 1 = a &&& 1 * a = a) &&&\n    ((d + - e = d - e &&& - d * e = - (d * e)) &&&\n     d + (e - f) = d + e - f &&&\n     (d - e) * fps_X = d * fps_X - e * fps_X) &&&\n    (fps_X * fps_X = fps_X\\<^sup>2 &&&\n     fps_X * fps_X ^ m = fps_X ^ Suc m) &&&\n    fps_X ^ m * fps_X = fps_X ^ Suc m &&&\n    fps_X ^ m * fps_X ^ n = fps_X ^ (m + n)", "by (simp_all add: algebra_simps power2_eq_square power_add power_commutes)"], ["", "lemma fps_divide_1: \"(a :: 'a :: field fps) / 1 = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a / 1 = a", "by simp"], ["", "lemmas fps_of_poly_code_post [code_post] = \n  fps_of_poly_simps fps_const_0_eq_0 fps_const_1_eq_1 numeral_fps_const [symmetric]\n  fps_const_neg [symmetric] fps_const_divide [symmetric]\n  fps_dehorner Suc_numeral arith_simps fps_divide_1"], ["", "context\n  includes term_syntax\nbegin"], ["", "definition\n  valterm_ratfps :: \n    \"'a ::{field_gcd, typerep} poly \\<times> (unit \\<Rightarrow> Code_Evaluation.term) \\<Rightarrow> \n     'a poly \\<times> (unit \\<Rightarrow> Code_Evaluation.term) \\<Rightarrow> 'a ratfps \\<times> (unit \\<Rightarrow> Code_Evaluation.term)\" where\n  [code_unfold]: \"valterm_ratfps k l = \n    Code_Evaluation.valtermify (/) {\\<cdot>} \n      (Code_Evaluation.valtermify ratfps_of_poly {\\<cdot>} k) {\\<cdot>} \n      (Code_Evaluation.valtermify ratfps_of_poly {\\<cdot>} l)\""], ["", "end"], ["", "instantiation ratfps :: (\"{field_gcd,random}\") random\nbegin"], ["", "context\n  includes state_combinator_syntax term_syntax\nbegin"], ["", "definition\n  \"Quickcheck_Random.random i = \n     Quickcheck_Random.random i \\<circ>\\<rightarrow> (\\<lambda>num::'a poly \\<times> (unit \\<Rightarrow> term). \n       Quickcheck_Random.random i \\<circ>\\<rightarrow> (\\<lambda>denom::'a poly \\<times> (unit \\<Rightarrow> term). \n         Pair (let denom = (if fst denom = 0 then Code_Evaluation.valtermify 1 else denom)\n               in  valterm_ratfps num denom)))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ratfps, random_class)", ".."], ["", "end"], ["", "end"], ["", "instantiation ratfps :: (\"{field,factorial_ring_gcd,exhaustive}\") exhaustive\nbegin"], ["", "definition\n  \"exhaustive_ratfps f d = \n     Quickcheck_Exhaustive.exhaustive (\\<lambda>num. \n       Quickcheck_Exhaustive.exhaustive (\\<lambda>denom. f (\n         let denom = if denom = 0 then 1 else denom\n         in  ratfps_of_poly num / ratfps_of_poly denom)) d) d\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ratfps, exhaustive_class)", ".."], ["", "end"], ["", "instantiation ratfps :: (\"{field_gcd,full_exhaustive}\") full_exhaustive\nbegin"], ["", "definition\n  \"full_exhaustive_ratfps f d = \n     Quickcheck_Exhaustive.full_exhaustive (\\<lambda>num::'a poly \\<times> (unit \\<Rightarrow> term).\n       Quickcheck_Exhaustive.full_exhaustive (\\<lambda>denom::'a poly \\<times> (unit \\<Rightarrow> term).\n         f (let denom = if fst denom = 0 then Code_Evaluation.valtermify 1 else denom\n            in  valterm_ratfps num denom)) d) d\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ratfps, full_exhaustive_class)", ".."], ["", "end"], ["", "quickcheck_generator fps constructors: fps_of_ratfps"], ["", "end"]]}