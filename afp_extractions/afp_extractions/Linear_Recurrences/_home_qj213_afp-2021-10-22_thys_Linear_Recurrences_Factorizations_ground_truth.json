{"file_name": "/home/qj213/afp-2021-10-22/thys/Linear_Recurrences/Factorizations.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Linear_Recurrences", "problem_names": ["lemma interp_factorization_reflect:\n  assumes \"(0::'a::idom) \\<notin> fst ` set (snd fctrs)\"\n  shows   \"reflect_poly (interp_factorization fctrs) = interp_alt_factorization fctrs\"", "lemma interp_alt_factorization_reflect:\n  assumes \"(0::'a::idom) \\<notin> fst ` set (snd fctrs)\"\n  shows   \"reflect_poly (interp_alt_factorization fctrs) = interp_factorization fctrs\"", "lemma coeff_0_interp_factorization:\n  \"coeff (interp_factorization fctrs) 0 = (0 :: 'a :: idom) \\<longleftrightarrow>\n     fst fctrs = 0 \\<or> 0 \\<in> fst ` set (snd fctrs)\"", "lemma reflect_factorization:\n  assumes \"coeff p 0 \\<noteq> (0::'a::idom)\"\n  assumes \"is_factorization_of fctrs p\"\n  shows   \"is_alt_factorization_of fctrs (reflect_poly p)\"", "lemma reflect_factorization':\n  assumes \"coeff p 0 \\<noteq> (0::'a::idom)\"\n  assumes \"is_alt_factorization_of fctrs p\"\n  shows   \"is_factorization_of fctrs (reflect_poly p)\"", "lemma zero_in_factorization_iff:\n  assumes \"is_factorization_of fctrs p\"\n  shows   \"coeff p 0 = 0 \\<longleftrightarrow> p = 0 \\<or> (0::'a::idom) \\<in> fst ` set (snd fctrs)\"", "lemma poly_prod_list [simp]: \"poly (prod_list ps) x = prod_list (map (\\<lambda>p. poly p x) ps)\"", "lemma is_factorization_of_roots:\n  fixes a :: \"'a :: idom\"\n  assumes \"is_factorization_of (a, fctrs) p\" \"p \\<noteq> 0\"\n  shows   \"set (map fst fctrs) = {x. poly p x = 0}\"", "lemma (in monoid_mult) prod_list_prod_nth: \"prod_list xs = (\\<Prod>i<length xs. xs ! i)\"", "lemma order_prod:\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0\"\n  assumes \"\\<And>x y. x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> coprime (f x) (f y)\"\n  shows   \"order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))\"", "lemma is_factorization_of_order:\n  fixes p :: \"'a :: field_gcd poly\"\n  assumes \"p \\<noteq> 0\"\n  assumes \"is_factorization_of (a, fctrs) p\"\n  assumes \"(c, n) \\<in> set fctrs\"\n  shows   \"order c p = Suc n\"", "lemma complex_factorization_exists:\n  \"\\<exists>fctrs. is_factorization_of fctrs (p :: complex poly)\""], "translations": [["", "lemma interp_factorization_reflect:\n  assumes \"(0::'a::idom) \\<notin> fst ` set (snd fctrs)\"\n  shows   \"reflect_poly (interp_factorization fctrs) = interp_alt_factorization fctrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflect_poly (interp_factorization fctrs) =\n    interp_alt_factorization fctrs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reflect_poly (interp_factorization fctrs) =\n    interp_alt_factorization fctrs", "have \"reflect_poly (interp_factorization fctrs) =\n          Polynomial.smult (fst fctrs) (\\<Prod>x\\<leftarrow>snd fctrs. reflect_poly [:- fst x, 1:] ^ Suc (snd x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflect_poly (interp_factorization fctrs) =\n    smult (fst fctrs)\n     (\\<Prod>x\\<leftarrow>snd fctrs. reflect_poly [:- fst x, 1::'a:] ^\n                                     Suc (snd x))", "by (simp add: interp_factorization_def interp_alt_factorization_def case_prod_unfold\n             reflect_poly_smult reflect_poly_prod_list reflect_poly_power o_def del: power_Suc)"], ["proof (state)\nthis:\n  reflect_poly (interp_factorization fctrs) =\n  smult (fst fctrs)\n   (\\<Prod>x\\<leftarrow>snd fctrs. reflect_poly [:- fst x, 1::'a:] ^\n                                   Suc (snd x))\n\ngoal (1 subgoal):\n 1. reflect_poly (interp_factorization fctrs) =\n    interp_alt_factorization fctrs", "also"], ["proof (state)\nthis:\n  reflect_poly (interp_factorization fctrs) =\n  smult (fst fctrs)\n   (\\<Prod>x\\<leftarrow>snd fctrs. reflect_poly [:- fst x, 1::'a:] ^\n                                   Suc (snd x))\n\ngoal (1 subgoal):\n 1. reflect_poly (interp_factorization fctrs) =\n    interp_alt_factorization fctrs", "have \"map (\\<lambda>x. reflect_poly [:- fst x, 1:] ^ Suc (snd x)) (snd fctrs) =\n               map (\\<lambda>x. [:1, - fst x:] ^ Suc (snd x)) (snd fctrs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. reflect_poly [:- fst x, 1::'a:] ^ Suc (snd x))\n     (snd fctrs) =\n    map (\\<lambda>x. [:1::'a, - fst x:] ^ Suc (snd x)) (snd fctrs)", "using assms"], ["proof (prove)\nusing this:\n  (0::'a) \\<notin> fst ` set (snd fctrs)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. reflect_poly [:- fst x, 1::'a:] ^ Suc (snd x))\n     (snd fctrs) =\n    map (\\<lambda>x. [:1::'a, - fst x:] ^ Suc (snd x)) (snd fctrs)", "by (intro list.map_cong0, subst reflect_poly_pCons) auto"], ["proof (state)\nthis:\n  map (\\<lambda>x. reflect_poly [:- fst x, 1::'a:] ^ Suc (snd x))\n   (snd fctrs) =\n  map (\\<lambda>x. [:1::'a, - fst x:] ^ Suc (snd x)) (snd fctrs)\n\ngoal (1 subgoal):\n 1. reflect_poly (interp_factorization fctrs) =\n    interp_alt_factorization fctrs", "also"], ["proof (state)\nthis:\n  map (\\<lambda>x. reflect_poly [:- fst x, 1::'a:] ^ Suc (snd x))\n   (snd fctrs) =\n  map (\\<lambda>x. [:1::'a, - fst x:] ^ Suc (snd x)) (snd fctrs)\n\ngoal (1 subgoal):\n 1. reflect_poly (interp_factorization fctrs) =\n    interp_alt_factorization fctrs", "have \"Polynomial.smult (fst fctrs) (prod_list \\<dots>) = interp_alt_factorization fctrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (fst fctrs)\n     (\\<Prod>x\\<leftarrow>snd fctrs. [:1::'a, - fst x:] ^ Suc (snd x)) =\n    interp_alt_factorization fctrs", "by (simp add: interp_alt_factorization_def case_prod_unfold)"], ["proof (state)\nthis:\n  smult (fst fctrs)\n   (\\<Prod>x\\<leftarrow>snd fctrs. [:1::'a, - fst x:] ^ Suc (snd x)) =\n  interp_alt_factorization fctrs\n\ngoal (1 subgoal):\n 1. reflect_poly (interp_factorization fctrs) =\n    interp_alt_factorization fctrs", "finally"], ["proof (chain)\npicking this:\n  reflect_poly (interp_factorization fctrs) = interp_alt_factorization fctrs", "show ?thesis"], ["proof (prove)\nusing this:\n  reflect_poly (interp_factorization fctrs) = interp_alt_factorization fctrs\n\ngoal (1 subgoal):\n 1. reflect_poly (interp_factorization fctrs) =\n    interp_alt_factorization fctrs", "."], ["proof (state)\nthis:\n  reflect_poly (interp_factorization fctrs) = interp_alt_factorization fctrs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interp_alt_factorization_reflect:\n  assumes \"(0::'a::idom) \\<notin> fst ` set (snd fctrs)\"\n  shows   \"reflect_poly (interp_alt_factorization fctrs) = interp_factorization fctrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflect_poly (interp_alt_factorization fctrs) =\n    interp_factorization fctrs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reflect_poly (interp_alt_factorization fctrs) =\n    interp_factorization fctrs", "have \"reflect_poly (interp_alt_factorization fctrs) =\n          Polynomial.smult (fst fctrs) (\\<Prod>x\\<leftarrow>snd fctrs. reflect_poly [:1, - fst x:] ^ Suc (snd x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflect_poly (interp_alt_factorization fctrs) =\n    smult (fst fctrs)\n     (\\<Prod>x\\<leftarrow>snd fctrs. reflect_poly [:1::'a, - fst x:] ^\n                                     Suc (snd x))", "by (simp add: interp_factorization_def interp_alt_factorization_def case_prod_unfold\n             reflect_poly_smult reflect_poly_prod_list reflect_poly_power o_def del: power_Suc)"], ["proof (state)\nthis:\n  reflect_poly (interp_alt_factorization fctrs) =\n  smult (fst fctrs)\n   (\\<Prod>x\\<leftarrow>snd fctrs. reflect_poly [:1::'a, - fst x:] ^\n                                   Suc (snd x))\n\ngoal (1 subgoal):\n 1. reflect_poly (interp_alt_factorization fctrs) =\n    interp_factorization fctrs", "also"], ["proof (state)\nthis:\n  reflect_poly (interp_alt_factorization fctrs) =\n  smult (fst fctrs)\n   (\\<Prod>x\\<leftarrow>snd fctrs. reflect_poly [:1::'a, - fst x:] ^\n                                   Suc (snd x))\n\ngoal (1 subgoal):\n 1. reflect_poly (interp_alt_factorization fctrs) =\n    interp_factorization fctrs", "have \"map (\\<lambda>x. reflect_poly [:1, - fst x:] ^ Suc (snd x)) (snd fctrs) =\n               map (\\<lambda>x. [:- fst x, 1:] ^ Suc (snd x)) (snd fctrs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. reflect_poly [:1::'a, - fst x:] ^ Suc (snd x))\n     (snd fctrs) =\n    map (\\<lambda>x. [:- fst x, 1::'a:] ^ Suc (snd x)) (snd fctrs)", "proof (intro list.map_cong0, clarsimp simp del: power_Suc, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (snd fctrs) \\<Longrightarrow>\n       reflect_poly [:1::'a, - a:] ^ Suc b = [:- a, 1::'a:] ^ Suc b", "fix c n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (snd fctrs) \\<Longrightarrow>\n       reflect_poly [:1::'a, - a:] ^ Suc b = [:- a, 1::'a:] ^ Suc b", "assume \"(c, n) \\<in> set (snd fctrs)\""], ["proof (state)\nthis:\n  (c, n) \\<in> set (snd fctrs)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (snd fctrs) \\<Longrightarrow>\n       reflect_poly [:1::'a, - a:] ^ Suc b = [:- a, 1::'a:] ^ Suc b", "with assms"], ["proof (chain)\npicking this:\n  (0::'a) \\<notin> fst ` set (snd fctrs)\n  (c, n) \\<in> set (snd fctrs)", "have \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (0::'a) \\<notin> fst ` set (snd fctrs)\n  (c, n) \\<in> set (snd fctrs)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a)", "by force"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (snd fctrs) \\<Longrightarrow>\n       reflect_poly [:1::'a, - a:] ^ Suc b = [:- a, 1::'a:] ^ Suc b", "thus \"reflect_poly [:1, -c:] ^ Suc n = [:-c, 1:] ^ Suc n\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. reflect_poly [:1::'a, - c:] ^ Suc n = [:- c, 1::'a:] ^ Suc n", "by (simp add: reflect_poly_pCons del: power_Suc)"], ["proof (state)\nthis:\n  reflect_poly [:1::'a, - c:] ^ Suc n = [:- c, 1::'a:] ^ Suc n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>x. reflect_poly [:1::'a, - fst x:] ^ Suc (snd x))\n   (snd fctrs) =\n  map (\\<lambda>x. [:- fst x, 1::'a:] ^ Suc (snd x)) (snd fctrs)\n\ngoal (1 subgoal):\n 1. reflect_poly (interp_alt_factorization fctrs) =\n    interp_factorization fctrs", "also"], ["proof (state)\nthis:\n  map (\\<lambda>x. reflect_poly [:1::'a, - fst x:] ^ Suc (snd x))\n   (snd fctrs) =\n  map (\\<lambda>x. [:- fst x, 1::'a:] ^ Suc (snd x)) (snd fctrs)\n\ngoal (1 subgoal):\n 1. reflect_poly (interp_alt_factorization fctrs) =\n    interp_factorization fctrs", "have \"Polynomial.smult (fst fctrs) (prod_list \\<dots>) = interp_factorization fctrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (fst fctrs)\n     (\\<Prod>x\\<leftarrow>snd fctrs. [:- fst x, 1::'a:] ^ Suc (snd x)) =\n    interp_factorization fctrs", "by (simp add: interp_factorization_def case_prod_unfold)"], ["proof (state)\nthis:\n  smult (fst fctrs)\n   (\\<Prod>x\\<leftarrow>snd fctrs. [:- fst x, 1::'a:] ^ Suc (snd x)) =\n  interp_factorization fctrs\n\ngoal (1 subgoal):\n 1. reflect_poly (interp_alt_factorization fctrs) =\n    interp_factorization fctrs", "finally"], ["proof (chain)\npicking this:\n  reflect_poly (interp_alt_factorization fctrs) = interp_factorization fctrs", "show ?thesis"], ["proof (prove)\nusing this:\n  reflect_poly (interp_alt_factorization fctrs) = interp_factorization fctrs\n\ngoal (1 subgoal):\n 1. reflect_poly (interp_alt_factorization fctrs) =\n    interp_factorization fctrs", "."], ["proof (state)\nthis:\n  reflect_poly (interp_alt_factorization fctrs) = interp_factorization fctrs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_0_interp_factorization:\n  \"coeff (interp_factorization fctrs) 0 = (0 :: 'a :: idom) \\<longleftrightarrow>\n     fst fctrs = 0 \\<or> 0 \\<in> fst ` set (snd fctrs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (coeff (interp_factorization fctrs) 0 = (0::'a)) =\n    (fst fctrs = (0::'a) \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "by (force simp: interp_factorization_def case_prod_unfold coeff_0_prod_list o_def\n                  coeff_0_power prod_list_zero_iff simp del: power_Suc)"], ["", "lemma reflect_factorization:\n  assumes \"coeff p 0 \\<noteq> (0::'a::idom)\"\n  assumes \"is_factorization_of fctrs p\"\n  shows   \"is_alt_factorization_of fctrs (reflect_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_alt_factorization_of fctrs (reflect_poly p)", "using assms"], ["proof (prove)\nusing this:\n  coeff p 0 \\<noteq> (0::'a)\n  is_factorization_of fctrs p\n\ngoal (1 subgoal):\n 1. is_alt_factorization_of fctrs (reflect_poly p)", "by (force simp: interp_factorization_reflect is_factorization_of_def\n                    is_alt_factorization_of_def coeff_0_interp_factorization)"], ["", "lemma reflect_factorization':\n  assumes \"coeff p 0 \\<noteq> (0::'a::idom)\"\n  assumes \"is_alt_factorization_of fctrs p\"\n  shows   \"is_factorization_of fctrs (reflect_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_factorization_of fctrs (reflect_poly p)", "using assms"], ["proof (prove)\nusing this:\n  coeff p 0 \\<noteq> (0::'a)\n  is_alt_factorization_of fctrs p\n\ngoal (1 subgoal):\n 1. is_factorization_of fctrs (reflect_poly p)", "by (force simp: interp_alt_factorization_reflect is_factorization_of_def\n                    is_alt_factorization_of_def coeff_0_interp_factorization)"], ["", "lemma zero_in_factorization_iff:\n  assumes \"is_factorization_of fctrs p\"\n  shows   \"coeff p 0 = 0 \\<longleftrightarrow> p = 0 \\<or> (0::'a::idom) \\<in> fst ` set (snd fctrs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "assume \"p \\<noteq> 0\""], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "with assms"], ["proof (chain)\npicking this:\n  is_factorization_of fctrs p\n  p \\<noteq> 0", "have [simp]: \"fst fctrs \\<noteq> 0\""], ["proof (prove)\nusing this:\n  is_factorization_of fctrs p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fst fctrs \\<noteq> (0::'a)", "by (auto simp: is_factorization_of_def interp_factorization_def case_prod_unfold)"], ["proof (state)\nthis:\n  fst fctrs \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "from assms"], ["proof (chain)\npicking this:\n  is_factorization_of fctrs p", "have \"p = interp_factorization fctrs\""], ["proof (prove)\nusing this:\n  is_factorization_of fctrs p\n\ngoal (1 subgoal):\n 1. p = interp_factorization fctrs", "by (simp add: is_factorization_of_def)"], ["proof (state)\nthis:\n  p = interp_factorization fctrs\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "also"], ["proof (state)\nthis:\n  p = interp_factorization fctrs\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "have \"coeff \\<dots> 0 = 0 \\<longleftrightarrow> 0 \\<in> fst ` set (snd fctrs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (coeff (interp_factorization fctrs) 0 = (0::'a)) =\n    ((0::'a) \\<in> fst ` set (snd fctrs))", "by (force simp add: interp_factorization_def case_prod_unfold coeff_0_prod_list\n                        prod_list_zero_iff o_def coeff_0_power)"], ["proof (state)\nthis:\n  (coeff (interp_factorization fctrs) 0 = (0::'a)) =\n  ((0::'a) \\<in> fst ` set (snd fctrs))\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "finally"], ["proof (chain)\npicking this:\n  (coeff p 0 = (0::'a)) = ((0::'a) \\<in> fst ` set (snd fctrs))", "show ?thesis"], ["proof (prove)\nusing this:\n  (coeff p 0 = (0::'a)) = ((0::'a) \\<in> fst ` set (snd fctrs))\n\ngoal (1 subgoal):\n 1. (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "using \\<open>p \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  (coeff p 0 = (0::'a)) = ((0::'a) \\<in> fst ` set (snd fctrs))\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "by blast"], ["proof (state)\nthis:\n  (coeff p 0 = (0::'a)) = (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "assume p: \"p = 0\""], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "with assms"], ["proof (chain)\npicking this:\n  is_factorization_of fctrs p\n  p = 0", "have \"interp_factorization fctrs = 0\""], ["proof (prove)\nusing this:\n  is_factorization_of fctrs p\n  p = 0\n\ngoal (1 subgoal):\n 1. interp_factorization fctrs = 0", "by (simp add: is_factorization_of_def)"], ["proof (state)\nthis:\n  interp_factorization fctrs = 0\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "also"], ["proof (state)\nthis:\n  interp_factorization fctrs = 0\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "have \"interp_factorization fctrs = 0 \\<longleftrightarrow>\n                 fst fctrs = 0 \\<or> (\\<Prod>(c,n)\\<leftarrow>snd fctrs. [:-c,1:]^Suc n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (interp_factorization fctrs = 0) =\n    (fst fctrs = (0::'a) \\<or>\n     (\\<Prod>(c, n)\\<leftarrow>snd fctrs. [:- c, 1::'a:] ^ Suc n) = 0)", "by (simp add: interp_factorization_def case_prod_unfold)"], ["proof (state)\nthis:\n  (interp_factorization fctrs = 0) =\n  (fst fctrs = (0::'a) \\<or>\n   (\\<Prod>(c, n)\\<leftarrow>snd fctrs. [:- c, 1::'a:] ^ Suc n) = 0)\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "also"], ["proof (state)\nthis:\n  (interp_factorization fctrs = 0) =\n  (fst fctrs = (0::'a) \\<or>\n   (\\<Prod>(c, n)\\<leftarrow>snd fctrs. [:- c, 1::'a:] ^ Suc n) = 0)\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "have \"(\\<Prod>(c,n)\\<leftarrow>snd fctrs. [:-c,1:]^Suc n) = 0 \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Prod>(c, n)\\<leftarrow>snd fctrs. [:- c, 1::'a:] ^ Suc n) = 0) =\n    False", "by (auto simp: prod_list_zero_iff simp del: power_Suc)"], ["proof (state)\nthis:\n  ((\\<Prod>(c, n)\\<leftarrow>snd fctrs. [:- c, 1::'a:] ^ Suc n) = 0) = False\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "finally"], ["proof (chain)\npicking this:\n  fst fctrs = (0::'a) \\<or> False", "show ?thesis"], ["proof (prove)\nusing this:\n  fst fctrs = (0::'a) \\<or> False\n\ngoal (1 subgoal):\n 1. (coeff p 0 = (0::'a)) =\n    (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))", "by (simp add: \\<open>p = 0\\<close>)"], ["proof (state)\nthis:\n  (coeff p 0 = (0::'a)) = (p = 0 \\<or> (0::'a) \\<in> fst ` set (snd fctrs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_prod_list [simp]: \"poly (prod_list ps) x = prod_list (map (\\<lambda>p. poly p x) ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (prod_list ps) x = (\\<Prod>p\\<leftarrow>ps. poly p x)", "by (induction ps) auto"], ["", "lemma is_factorization_of_roots:\n  fixes a :: \"'a :: idom\"\n  assumes \"is_factorization_of (a, fctrs) p\" \"p \\<noteq> 0\"\n  shows   \"set (map fst fctrs) = {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst fctrs) = {x. poly p x = (0::'a)}", "using assms"], ["proof (prove)\nusing this:\n  is_factorization_of (a, fctrs) p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. set (map fst fctrs) = {x. poly p x = (0::'a)}", "by (force simp: is_factorization_of_def interp_factorization_def o_def\n        case_prod_unfold prod_list_zero_iff simp del: power_Suc)"], ["", "lemma (in monoid_mult) prod_list_prod_nth: \"prod_list xs = (\\<Prod>i<length xs. xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list xs = prod ((!) xs) {..<length xs}", "by (induction xs) (auto simp: prod.lessThan_Suc_shift simp del: prod.lessThan_Suc)"], ["", "lemma order_prod:\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0\"\n  assumes \"\\<And>x y. x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> coprime (f x) (f y)\"\n  shows   \"order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> f ?x \\<noteq> 0\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> coprime (f ?x) (f ?y)\n\ngoal (1 subgoal):\n 1. order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))", "proof (induction A rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n           \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n       \\<Longrightarrow> order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))\n 2. \\<lbrakk>\\<And>x. x \\<in> {} \\<Longrightarrow> f x \\<noteq> 0;\n     \\<And>x y.\n        \\<lbrakk>x \\<in> {}; y \\<in> {}; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n    \\<Longrightarrow> order c (prod f {}) = (\\<Sum>x\\<in>{}. order c (f x))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>x. x \\<in> F \\<Longrightarrow> f x \\<noteq> 0;\n         \\<And>x y.\n            \\<lbrakk>x \\<in> F; y \\<in> F; x \\<noteq> y\\<rbrakk>\n            \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n        \\<Longrightarrow> order c (prod f F) =\n                          (\\<Sum>x\\<in>F. order c (f x));\n        \\<And>xa. xa \\<in> insert x F \\<Longrightarrow> f xa \\<noteq> 0;\n        \\<And>xa y.\n           \\<lbrakk>xa \\<in> insert x F; y \\<in> insert x F;\n            xa \\<noteq> y\\<rbrakk>\n           \\<Longrightarrow> coprime (f xa) (f y)\\<rbrakk>\n       \\<Longrightarrow> order c (prod f (insert x F)) =\n                         (\\<Sum>x\\<in>insert x F. order c (f x))", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0;\n   \\<And>x y.\n      \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n      \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n  \\<Longrightarrow> order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))\n  ?x \\<in> insert x A \\<Longrightarrow> f ?x \\<noteq> 0\n  \\<lbrakk>?x \\<in> insert x A; ?y \\<in> insert x A; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> coprime (f ?x) (f ?y)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n           \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n       \\<Longrightarrow> order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))\n 2. \\<lbrakk>\\<And>x. x \\<in> {} \\<Longrightarrow> f x \\<noteq> 0;\n     \\<And>x y.\n        \\<lbrakk>x \\<in> {}; y \\<in> {}; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n    \\<Longrightarrow> order c (prod f {}) = (\\<Sum>x\\<in>{}. order c (f x))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>x. x \\<in> F \\<Longrightarrow> f x \\<noteq> 0;\n         \\<And>x y.\n            \\<lbrakk>x \\<in> F; y \\<in> F; x \\<noteq> y\\<rbrakk>\n            \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n        \\<Longrightarrow> order c (prod f F) =\n                          (\\<Sum>x\\<in>F. order c (f x));\n        \\<And>xa. xa \\<in> insert x F \\<Longrightarrow> f xa \\<noteq> 0;\n        \\<And>xa y.\n           \\<lbrakk>xa \\<in> insert x F; y \\<in> insert x F;\n            xa \\<noteq> y\\<rbrakk>\n           \\<Longrightarrow> coprime (f xa) (f y)\\<rbrakk>\n       \\<Longrightarrow> order c (prod f (insert x F)) =\n                         (\\<Sum>x\\<in>insert x F. order c (f x))", "from insert.hyps"], ["proof (chain)\npicking this:\n  finite A\n  x \\<notin> A", "have \"order c (prod f (insert x A)) = order c (f x * prod f A)\""], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n\ngoal (1 subgoal):\n 1. order c (prod f (insert x A)) = order c (f x * prod f A)", "by simp"], ["proof (state)\nthis:\n  order c (prod f (insert x A)) = order c (f x * prod f A)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n           \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n       \\<Longrightarrow> order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))\n 2. \\<lbrakk>\\<And>x. x \\<in> {} \\<Longrightarrow> f x \\<noteq> 0;\n     \\<And>x y.\n        \\<lbrakk>x \\<in> {}; y \\<in> {}; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n    \\<Longrightarrow> order c (prod f {}) = (\\<Sum>x\\<in>{}. order c (f x))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>x. x \\<in> F \\<Longrightarrow> f x \\<noteq> 0;\n         \\<And>x y.\n            \\<lbrakk>x \\<in> F; y \\<in> F; x \\<noteq> y\\<rbrakk>\n            \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n        \\<Longrightarrow> order c (prod f F) =\n                          (\\<Sum>x\\<in>F. order c (f x));\n        \\<And>xa. xa \\<in> insert x F \\<Longrightarrow> f xa \\<noteq> 0;\n        \\<And>xa y.\n           \\<lbrakk>xa \\<in> insert x F; y \\<in> insert x F;\n            xa \\<noteq> y\\<rbrakk>\n           \\<Longrightarrow> coprime (f xa) (f y)\\<rbrakk>\n       \\<Longrightarrow> order c (prod f (insert x F)) =\n                         (\\<Sum>x\\<in>insert x F. order c (f x))", "also"], ["proof (state)\nthis:\n  order c (prod f (insert x A)) = order c (f x * prod f A)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n           \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n       \\<Longrightarrow> order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))\n 2. \\<lbrakk>\\<And>x. x \\<in> {} \\<Longrightarrow> f x \\<noteq> 0;\n     \\<And>x y.\n        \\<lbrakk>x \\<in> {}; y \\<in> {}; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n    \\<Longrightarrow> order c (prod f {}) = (\\<Sum>x\\<in>{}. order c (f x))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>x. x \\<in> F \\<Longrightarrow> f x \\<noteq> 0;\n         \\<And>x y.\n            \\<lbrakk>x \\<in> F; y \\<in> F; x \\<noteq> y\\<rbrakk>\n            \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n        \\<Longrightarrow> order c (prod f F) =\n                          (\\<Sum>x\\<in>F. order c (f x));\n        \\<And>xa. xa \\<in> insert x F \\<Longrightarrow> f xa \\<noteq> 0;\n        \\<And>xa y.\n           \\<lbrakk>xa \\<in> insert x F; y \\<in> insert x F;\n            xa \\<noteq> y\\<rbrakk>\n           \\<Longrightarrow> coprime (f xa) (f y)\\<rbrakk>\n       \\<Longrightarrow> order c (prod f (insert x F)) =\n                         (\\<Sum>x\\<in>insert x F. order c (f x))", "have \"\\<dots> = order c (f x) + order c (prod f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order c (f x * prod f A) = order c (f x) + order c (prod f A)", "using insert.prems and insert.hyps"], ["proof (prove)\nusing this:\n  ?x \\<in> insert x A \\<Longrightarrow> f ?x \\<noteq> 0\n  \\<lbrakk>?x \\<in> insert x A; ?y \\<in> insert x A; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> coprime (f ?x) (f ?y)\n  finite A\n  x \\<notin> A\n\ngoal (1 subgoal):\n 1. order c (f x * prod f A) = order c (f x) + order c (prod f A)", "by (intro order_mult) auto"], ["proof (state)\nthis:\n  order c (f x * prod f A) = order c (f x) + order c (prod f A)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n           \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n       \\<Longrightarrow> order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))\n 2. \\<lbrakk>\\<And>x. x \\<in> {} \\<Longrightarrow> f x \\<noteq> 0;\n     \\<And>x y.\n        \\<lbrakk>x \\<in> {}; y \\<in> {}; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n    \\<Longrightarrow> order c (prod f {}) = (\\<Sum>x\\<in>{}. order c (f x))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>x. x \\<in> F \\<Longrightarrow> f x \\<noteq> 0;\n         \\<And>x y.\n            \\<lbrakk>x \\<in> F; y \\<in> F; x \\<noteq> y\\<rbrakk>\n            \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n        \\<Longrightarrow> order c (prod f F) =\n                          (\\<Sum>x\\<in>F. order c (f x));\n        \\<And>xa. xa \\<in> insert x F \\<Longrightarrow> f xa \\<noteq> 0;\n        \\<And>xa y.\n           \\<lbrakk>xa \\<in> insert x F; y \\<in> insert x F;\n            xa \\<noteq> y\\<rbrakk>\n           \\<Longrightarrow> coprime (f xa) (f y)\\<rbrakk>\n       \\<Longrightarrow> order c (prod f (insert x F)) =\n                         (\\<Sum>x\\<in>insert x F. order c (f x))", "also"], ["proof (state)\nthis:\n  order c (f x * prod f A) = order c (f x) + order c (prod f A)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n           \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n       \\<Longrightarrow> order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))\n 2. \\<lbrakk>\\<And>x. x \\<in> {} \\<Longrightarrow> f x \\<noteq> 0;\n     \\<And>x y.\n        \\<lbrakk>x \\<in> {}; y \\<in> {}; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n    \\<Longrightarrow> order c (prod f {}) = (\\<Sum>x\\<in>{}. order c (f x))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>x. x \\<in> F \\<Longrightarrow> f x \\<noteq> 0;\n         \\<And>x y.\n            \\<lbrakk>x \\<in> F; y \\<in> F; x \\<noteq> y\\<rbrakk>\n            \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n        \\<Longrightarrow> order c (prod f F) =\n                          (\\<Sum>x\\<in>F. order c (f x));\n        \\<And>xa. xa \\<in> insert x F \\<Longrightarrow> f xa \\<noteq> 0;\n        \\<And>xa y.\n           \\<lbrakk>xa \\<in> insert x F; y \\<in> insert x F;\n            xa \\<noteq> y\\<rbrakk>\n           \\<Longrightarrow> coprime (f xa) (f y)\\<rbrakk>\n       \\<Longrightarrow> order c (prod f (insert x F)) =\n                         (\\<Sum>x\\<in>insert x F. order c (f x))", "have \"order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))", "using insert.prems and insert.hyps"], ["proof (prove)\nusing this:\n  ?x \\<in> insert x A \\<Longrightarrow> f ?x \\<noteq> 0\n  \\<lbrakk>?x \\<in> insert x A; ?y \\<in> insert x A; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> coprime (f ?x) (f ?y)\n  finite A\n  x \\<notin> A\n\ngoal (1 subgoal):\n 1. order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))", "by (intro insert.IH) auto"], ["proof (state)\nthis:\n  order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n           \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n       \\<Longrightarrow> order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))\n 2. \\<lbrakk>\\<And>x. x \\<in> {} \\<Longrightarrow> f x \\<noteq> 0;\n     \\<And>x y.\n        \\<lbrakk>x \\<in> {}; y \\<in> {}; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n    \\<Longrightarrow> order c (prod f {}) = (\\<Sum>x\\<in>{}. order c (f x))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>x. x \\<in> F \\<Longrightarrow> f x \\<noteq> 0;\n         \\<And>x y.\n            \\<lbrakk>x \\<in> F; y \\<in> F; x \\<noteq> y\\<rbrakk>\n            \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n        \\<Longrightarrow> order c (prod f F) =\n                          (\\<Sum>x\\<in>F. order c (f x));\n        \\<And>xa. xa \\<in> insert x F \\<Longrightarrow> f xa \\<noteq> 0;\n        \\<And>xa y.\n           \\<lbrakk>xa \\<in> insert x F; y \\<in> insert x F;\n            xa \\<noteq> y\\<rbrakk>\n           \\<Longrightarrow> coprime (f xa) (f y)\\<rbrakk>\n       \\<Longrightarrow> order c (prod f (insert x F)) =\n                         (\\<Sum>x\\<in>insert x F. order c (f x))", "finally"], ["proof (chain)\npicking this:\n  order c (prod f (insert x A)) =\n  order c (f x) + (\\<Sum>x\\<in>A. order c (f x))", "show ?case"], ["proof (prove)\nusing this:\n  order c (prod f (insert x A)) =\n  order c (f x) + (\\<Sum>x\\<in>A. order c (f x))\n\ngoal (1 subgoal):\n 1. order c (prod f (insert x A)) = (\\<Sum>x\\<in>insert x A. order c (f x))", "using insert.hyps"], ["proof (prove)\nusing this:\n  order c (prod f (insert x A)) =\n  order c (f x) + (\\<Sum>x\\<in>A. order c (f x))\n  finite A\n  x \\<notin> A\n\ngoal (1 subgoal):\n 1. order c (prod f (insert x A)) = (\\<Sum>x\\<in>insert x A. order c (f x))", "by simp"], ["proof (state)\nthis:\n  order c (prod f (insert x A)) = (\\<Sum>x\\<in>insert x A. order c (f x))\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n           \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n       \\<Longrightarrow> order c (prod f A) = (\\<Sum>x\\<in>A. order c (f x))\n 2. \\<lbrakk>\\<And>x. x \\<in> {} \\<Longrightarrow> f x \\<noteq> 0;\n     \\<And>x y.\n        \\<lbrakk>x \\<in> {}; y \\<in> {}; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> coprime (f x) (f y)\\<rbrakk>\n    \\<Longrightarrow> order c (prod f {}) = (\\<Sum>x\\<in>{}. order c (f x))", "qed auto"], ["", "lemma is_factorization_of_order:\n  fixes p :: \"'a :: field_gcd poly\"\n  assumes \"p \\<noteq> 0\"\n  assumes \"is_factorization_of (a, fctrs) p\"\n  assumes \"(c, n) \\<in> set fctrs\"\n  shows   \"order c p = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order c p = Suc n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order c p = Suc n", "from assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  is_factorization_of (a, fctrs) p\n  (c, n) \\<in> set fctrs", "have distinct: \"distinct (map fst (fctrs))\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  is_factorization_of (a, fctrs) p\n  (c, n) \\<in> set fctrs\n\ngoal (1 subgoal):\n 1. distinct (map fst fctrs)", "by (simp add: is_factorization_of_def)"], ["proof (state)\nthis:\n  distinct (map fst fctrs)\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "from assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  is_factorization_of (a, fctrs) p\n  (c, n) \\<in> set fctrs", "have [simp]: \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  is_factorization_of (a, fctrs) p\n  (c, n) \\<in> set fctrs\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a)", "by (auto simp: is_factorization_of_def interp_factorization_def)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "from assms(2)"], ["proof (chain)\npicking this:\n  is_factorization_of (a, fctrs) p", "have \"p = interp_factorization (a, fctrs)\""], ["proof (prove)\nusing this:\n  is_factorization_of (a, fctrs) p\n\ngoal (1 subgoal):\n 1. p = interp_factorization (a, fctrs)", "unfolding is_factorization_of_def"], ["proof (prove)\nusing this:\n  interp_factorization (a, fctrs) = p \\<and>\n  distinct (map fst (snd (a, fctrs)))\n\ngoal (1 subgoal):\n 1. p = interp_factorization (a, fctrs)", "by simp"], ["proof (state)\nthis:\n  p = interp_factorization (a, fctrs)\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "also"], ["proof (state)\nthis:\n  p = interp_factorization (a, fctrs)\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "have \"order c \\<dots> = order c (\\<Prod>(c,n)\\<leftarrow>fctrs. [:-c, 1:] ^ Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order c (interp_factorization (a, fctrs)) =\n    order c (\\<Prod>(c, n)\\<leftarrow>fctrs. [:- c, 1::'a:] ^ Suc n)", "unfolding interp_factorization_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. order c\n     (case (a, fctrs) of\n      (a, cs) \\<Rightarrow>\n        smult a (\\<Prod>(c, n)\\<leftarrow>cs. [:- c, 1::'a:] ^ Suc n)) =\n    order c (\\<Prod>(c, n)\\<leftarrow>fctrs. [:- c, 1::'a:] ^ Suc n)", "by (simp add: order_smult)"], ["proof (state)\nthis:\n  order c (interp_factorization (a, fctrs)) =\n  order c (\\<Prod>(c, n)\\<leftarrow>fctrs. [:- c, 1::'a:] ^ Suc n)\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "also"], ["proof (state)\nthis:\n  order c (interp_factorization (a, fctrs)) =\n  order c (\\<Prod>(c, n)\\<leftarrow>fctrs. [:- c, 1::'a:] ^ Suc n)\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "have \"(\\<Prod>(c,n)\\<leftarrow>fctrs. [:-c, 1:] ^ Suc n) =\n               (\\<Prod>i\\<in>{..<length fctrs}. [:-fst (fctrs ! i), 1:] ^ Suc (snd (fctrs ! i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(c, n)\\<leftarrow>fctrs. [:- c, 1::'a:] ^ Suc n) =\n    (\\<Prod>i<length fctrs.\n        [:- fst (fctrs ! i), 1::'a:] ^ Suc (snd (fctrs ! i)))", "by (simp add: prod_list_prod_nth case_prod_unfold)"], ["proof (state)\nthis:\n  (\\<Prod>(c, n)\\<leftarrow>fctrs. [:- c, 1::'a:] ^ Suc n) =\n  (\\<Prod>i<length fctrs.\n      [:- fst (fctrs ! i), 1::'a:] ^ Suc (snd (fctrs ! i)))\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "also"], ["proof (state)\nthis:\n  (\\<Prod>(c, n)\\<leftarrow>fctrs. [:- c, 1::'a:] ^ Suc n) =\n  (\\<Prod>i<length fctrs.\n      [:- fst (fctrs ! i), 1::'a:] ^ Suc (snd (fctrs ! i)))\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "have \"order c \\<dots> =\n               (\\<Sum>x<length fctrs. order c ([:- fst (fctrs ! x), 1:] ^ Suc (snd (fctrs ! x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order c\n     (\\<Prod>i<length fctrs.\n         [:- fst (fctrs ! i), 1::'a:] ^ Suc (snd (fctrs ! i))) =\n    (\\<Sum>x<length fctrs.\n        order c ([:- fst (fctrs ! x), 1::'a:] ^ Suc (snd (fctrs ! x))))", "proof (rule order_prod)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<length fctrs} \\<Longrightarrow>\n       [:- fst (fctrs ! x), 1::'a:] ^ Suc (snd (fctrs ! x)) \\<noteq> 0\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> {..<length fctrs}; y \\<in> {..<length fctrs};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> coprime\n                          ([:- fst (fctrs ! x), 1::'a:] ^\n                           Suc (snd (fctrs ! x)))\n                          ([:- fst (fctrs ! y), 1::'a:] ^\n                           Suc (snd (fctrs ! y)))", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<length fctrs} \\<Longrightarrow>\n       [:- fst (fctrs ! x), 1::'a:] ^ Suc (snd (fctrs ! x)) \\<noteq> 0\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> {..<length fctrs}; y \\<in> {..<length fctrs};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> coprime\n                          ([:- fst (fctrs ! x), 1::'a:] ^\n                           Suc (snd (fctrs ! x)))\n                          ([:- fst (fctrs ! y), 1::'a:] ^\n                           Suc (snd (fctrs ! y)))", "assume \"i \\<in> {..<length fctrs}\""], ["proof (state)\nthis:\n  i \\<in> {..<length fctrs}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<length fctrs} \\<Longrightarrow>\n       [:- fst (fctrs ! x), 1::'a:] ^ Suc (snd (fctrs ! x)) \\<noteq> 0\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> {..<length fctrs}; y \\<in> {..<length fctrs};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> coprime\n                          ([:- fst (fctrs ! x), 1::'a:] ^\n                           Suc (snd (fctrs ! x)))\n                          ([:- fst (fctrs ! y), 1::'a:] ^\n                           Suc (snd (fctrs ! y)))", "then"], ["proof (chain)\npicking this:\n  i \\<in> {..<length fctrs}", "show \"[:- fst (fctrs ! i), 1:] ^ Suc (snd (fctrs ! i)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i \\<in> {..<length fctrs}\n\ngoal (1 subgoal):\n 1. [:- fst (fctrs ! i), 1::'a:] ^ Suc (snd (fctrs ! i)) \\<noteq> 0", "by (simp only: power_eq_0_iff) simp"], ["proof (state)\nthis:\n  [:- fst (fctrs ! i), 1::'a:] ^ Suc (snd (fctrs ! i)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {..<length fctrs}; y \\<in> {..<length fctrs};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> coprime\n                          ([:- fst (fctrs ! x), 1::'a:] ^\n                           Suc (snd (fctrs ! x)))\n                          ([:- fst (fctrs ! y), 1::'a:] ^\n                           Suc (snd (fctrs ! y)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {..<length fctrs}; y \\<in> {..<length fctrs};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> coprime\n                          ([:- fst (fctrs ! x), 1::'a:] ^\n                           Suc (snd (fctrs ! x)))\n                          ([:- fst (fctrs ! y), 1::'a:] ^\n                           Suc (snd (fctrs ! y)))", "fix i j :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {..<length fctrs}; y \\<in> {..<length fctrs};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> coprime\n                          ([:- fst (fctrs ! x), 1::'a:] ^\n                           Suc (snd (fctrs ! x)))\n                          ([:- fst (fctrs ! y), 1::'a:] ^\n                           Suc (snd (fctrs ! y)))", "assume \"i \\<noteq> j\" \"i \\<in> {..<length fctrs}\" \"j \\<in> {..<length fctrs}\""], ["proof (state)\nthis:\n  i \\<noteq> j\n  i \\<in> {..<length fctrs}\n  j \\<in> {..<length fctrs}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {..<length fctrs}; y \\<in> {..<length fctrs};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> coprime\n                          ([:- fst (fctrs ! x), 1::'a:] ^\n                           Suc (snd (fctrs ! x)))\n                          ([:- fst (fctrs ! y), 1::'a:] ^\n                           Suc (snd (fctrs ! y)))", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  i \\<in> {..<length fctrs}\n  j \\<in> {..<length fctrs}", "have \"fst (fctrs ! i) \\<noteq> fst (fctrs ! j)\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  i \\<in> {..<length fctrs}\n  j \\<in> {..<length fctrs}\n\ngoal (1 subgoal):\n 1. fst (fctrs ! i) \\<noteq> fst (fctrs ! j)", "using nth_eq_iff_index_eq [OF distinct, of i j]"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  i \\<in> {..<length fctrs}\n  j \\<in> {..<length fctrs}\n  \\<lbrakk>i < length (map fst fctrs); j < length (map fst fctrs)\\<rbrakk>\n  \\<Longrightarrow> (map fst fctrs ! i = map fst fctrs ! j) = (i = j)\n\ngoal (1 subgoal):\n 1. fst (fctrs ! i) \\<noteq> fst (fctrs ! j)", "by simp"], ["proof (state)\nthis:\n  fst (fctrs ! i) \\<noteq> fst (fctrs ! j)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {..<length fctrs}; y \\<in> {..<length fctrs};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> coprime\n                          ([:- fst (fctrs ! x), 1::'a:] ^\n                           Suc (snd (fctrs ! x)))\n                          ([:- fst (fctrs ! y), 1::'a:] ^\n                           Suc (snd (fctrs ! y)))", "then"], ["proof (chain)\npicking this:\n  fst (fctrs ! i) \\<noteq> fst (fctrs ! j)", "show \"coprime ([:- fst (fctrs ! i), 1:] ^ Suc (snd (fctrs ! i)))\n      ([:- fst (fctrs ! j), 1:] ^ Suc (snd (fctrs ! j)))\""], ["proof (prove)\nusing this:\n  fst (fctrs ! i) \\<noteq> fst (fctrs ! j)\n\ngoal (1 subgoal):\n 1. coprime ([:- fst (fctrs ! i), 1::'a:] ^ Suc (snd (fctrs ! i)))\n     ([:- fst (fctrs ! j), 1::'a:] ^ Suc (snd (fctrs ! j)))", "by (simp only: coprime_power_left_iff coprime_power_right_iff)\n        (auto simp add: coprime_linear_poly)"], ["proof (state)\nthis:\n  coprime ([:- fst (fctrs ! i), 1::'a:] ^ Suc (snd (fctrs ! i)))\n   ([:- fst (fctrs ! j), 1::'a:] ^ Suc (snd (fctrs ! j)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order c\n   (\\<Prod>i<length fctrs.\n       [:- fst (fctrs ! i), 1::'a:] ^ Suc (snd (fctrs ! i))) =\n  (\\<Sum>x<length fctrs.\n      order c ([:- fst (fctrs ! x), 1::'a:] ^ Suc (snd (fctrs ! x))))\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "also"], ["proof (state)\nthis:\n  order c\n   (\\<Prod>i<length fctrs.\n       [:- fst (fctrs ! i), 1::'a:] ^ Suc (snd (fctrs ! i))) =\n  (\\<Sum>x<length fctrs.\n      order c ([:- fst (fctrs ! x), 1::'a:] ^ Suc (snd (fctrs ! x))))\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "have \"\\<dots> = (\\<Sum>(c',n')\\<leftarrow>fctrs. order c ([:-c', 1:] ^ Suc n'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x<length fctrs.\n        order c ([:- fst (fctrs ! x), 1::'a:] ^ Suc (snd (fctrs ! x)))) =\n    (\\<Sum>(c', n')\\<leftarrow>fctrs. order c ([:- c', 1::'a:] ^ Suc n'))", "by (simp add: sum_list_sum_nth case_prod_unfold atLeast0LessThan)"], ["proof (state)\nthis:\n  (\\<Sum>x<length fctrs.\n      order c ([:- fst (fctrs ! x), 1::'a:] ^ Suc (snd (fctrs ! x)))) =\n  (\\<Sum>(c', n')\\<leftarrow>fctrs. order c ([:- c', 1::'a:] ^ Suc n'))\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "also"], ["proof (state)\nthis:\n  (\\<Sum>x<length fctrs.\n      order c ([:- fst (fctrs ! x), 1::'a:] ^ Suc (snd (fctrs ! x)))) =\n  (\\<Sum>(c', n')\\<leftarrow>fctrs. order c ([:- c', 1::'a:] ^ Suc n'))\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "have \"\\<dots> = (\\<Sum>(c',n')\\<leftarrow>fctrs. if c = c' then Suc n' else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(c', n')\\<leftarrow>fctrs. order c ([:- c', 1::'a:] ^ Suc n')) =\n    (\\<Sum>(c', n')\\<leftarrow>fctrs. if c = c' then Suc n' else 0)", "by (intro arg_cong[OF map_cong]) (auto simp add: order_power_n_n order_0I simp del: power_Suc)"], ["proof (state)\nthis:\n  (\\<Sum>(c', n')\\<leftarrow>fctrs. order c ([:- c', 1::'a:] ^ Suc n')) =\n  (\\<Sum>(c', n')\\<leftarrow>fctrs. if c = c' then Suc n' else 0)\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "also"], ["proof (state)\nthis:\n  (\\<Sum>(c', n')\\<leftarrow>fctrs. order c ([:- c', 1::'a:] ^ Suc n')) =\n  (\\<Sum>(c', n')\\<leftarrow>fctrs. if c = c' then Suc n' else 0)\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "have \"\\<dots> = (\\<Sum>x\\<leftarrow>fctrs. if x = (c, n) then Suc (snd x) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(c', n')\\<leftarrow>fctrs. if c = c' then Suc n' else 0) =\n    (\\<Sum>x\\<leftarrow>fctrs. if x = (c, n) then Suc (snd x) else 0)", "using distinct assms"], ["proof (prove)\nusing this:\n  distinct (map fst fctrs)\n  p \\<noteq> 0\n  is_factorization_of (a, fctrs) p\n  (c, n) \\<in> set fctrs\n\ngoal (1 subgoal):\n 1. (\\<Sum>(c', n')\\<leftarrow>fctrs. if c = c' then Suc n' else 0) =\n    (\\<Sum>x\\<leftarrow>fctrs. if x = (c, n) then Suc (snd x) else 0)", "by (intro arg_cong[OF map_cong]) (force simp: distinct_map inj_on_def)+"], ["proof (state)\nthis:\n  (\\<Sum>(c', n')\\<leftarrow>fctrs. if c = c' then Suc n' else 0) =\n  (\\<Sum>x\\<leftarrow>fctrs. if x = (c, n) then Suc (snd x) else 0)\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "also"], ["proof (state)\nthis:\n  (\\<Sum>(c', n')\\<leftarrow>fctrs. if c = c' then Suc n' else 0) =\n  (\\<Sum>x\\<leftarrow>fctrs. if x = (c, n) then Suc (snd x) else 0)\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "from distinct"], ["proof (chain)\npicking this:\n  distinct (map fst fctrs)", "have \"\\<dots> = (\\<Sum>x\\<in>set fctrs. if x = (c, n) then Suc (snd x) else 0)\""], ["proof (prove)\nusing this:\n  distinct (map fst fctrs)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>fctrs. if x = (c, n) then Suc (snd x) else 0) =\n    (\\<Sum>x\\<in>set fctrs. if x = (c, n) then Suc (snd x) else 0)", "by (intro sum_list_distinct_conv_sum_set) (simp_all add: distinct_map)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>fctrs. if x = (c, n) then Suc (snd x) else 0) =\n  (\\<Sum>x\\<in>set fctrs. if x = (c, n) then Suc (snd x) else 0)\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>fctrs. if x = (c, n) then Suc (snd x) else 0) =\n  (\\<Sum>x\\<in>set fctrs. if x = (c, n) then Suc (snd x) else 0)\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "from assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  is_factorization_of (a, fctrs) p\n  (c, n) \\<in> set fctrs", "have \"\\<dots> = Suc n\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  is_factorization_of (a, fctrs) p\n  (c, n) \\<in> set fctrs\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set fctrs. if x = (c, n) then Suc (snd x) else 0) = Suc n", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set fctrs. if x = (c, n) then Suc (snd x) else 0) = Suc n\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "finally"], ["proof (chain)\npicking this:\n  order c p = Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  order c p = Suc n\n\ngoal (1 subgoal):\n 1. order c p = Suc n", "."], ["proof (state)\nthis:\n  order c p = Suc n\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  For complex polynomials, a factorisation in the above sense always exists.\n\\<close>"], ["", "lemma complex_factorization_exists:\n  \"\\<exists>fctrs. is_factorization_of fctrs (p :: complex poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fctrs. is_factorization_of fctrs p", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> \\<exists>fctrs. is_factorization_of fctrs p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>fctrs. is_factorization_of fctrs p", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> \\<exists>fctrs. is_factorization_of fctrs p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>fctrs. is_factorization_of fctrs p", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<exists>fctrs. is_factorization_of fctrs p", "by (intro exI[of _ \"(0, [])\"]) (auto simp: is_factorization_of_def interp_factorization_def)"], ["proof (state)\nthis:\n  \\<exists>fctrs. is_factorization_of fctrs p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>fctrs. is_factorization_of fctrs p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>fctrs. is_factorization_of fctrs p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>fctrs. is_factorization_of fctrs p", "hence \"\\<exists>xs. set xs = {x. poly p x = 0} \\<and> distinct xs\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>xs. set xs = {x. poly p x = 0} \\<and> distinct xs", "by (intro finite_distinct_list poly_roots_finite)"], ["proof (state)\nthis:\n  \\<exists>xs. set xs = {x. poly p x = 0} \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>fctrs. is_factorization_of fctrs p", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. set xs = {x. poly p x = 0} \\<and> distinct xs", "obtain xs where [simp]: \"set xs = {x. poly p x = 0}\" \"distinct xs\""], ["proof (prove)\nusing this:\n  \\<exists>xs. set xs = {x. poly p x = 0} \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>set xs = {x. poly p x = 0}; distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set xs = {x. poly p x = 0}\n  distinct xs\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>fctrs. is_factorization_of fctrs p", "have \"interp_factorization (lead_coeff p, map (\\<lambda>x. (x, order x p - 1)) xs) =\n          smult (lead_coeff p) (\\<Prod>x\\<leftarrow>xs. [:- x, 1:] ^ Suc (order x p - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interp_factorization\n     (lead_coeff p, map (\\<lambda>x. (x, order x p - 1)) xs) =\n    smult (lead_coeff p)\n     (\\<Prod>x\\<leftarrow>xs. [:- x, 1:] ^ Suc (order x p - 1))", "by (simp add: interp_factorization_def o_def)"], ["proof (state)\nthis:\n  interp_factorization\n   (lead_coeff p, map (\\<lambda>x. (x, order x p - 1)) xs) =\n  smult (lead_coeff p)\n   (\\<Prod>x\\<leftarrow>xs. [:- x, 1:] ^ Suc (order x p - 1))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>fctrs. is_factorization_of fctrs p", "also"], ["proof (state)\nthis:\n  interp_factorization\n   (lead_coeff p, map (\\<lambda>x. (x, order x p - 1)) xs) =\n  smult (lead_coeff p)\n   (\\<Prod>x\\<leftarrow>xs. [:- x, 1:] ^ Suc (order x p - 1))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>fctrs. is_factorization_of fctrs p", "have \"(\\<Prod>x\\<leftarrow>xs. [:- x, 1:] ^ Suc (order x p - 1)) =\n               (\\<Prod>x|poly p x = 0. [:- x, 1:] ^ Suc (order x p - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>xs. [:- x, 1:] ^ Suc (order x p - 1)) =\n    (\\<Prod>x\\<in>{x. poly p x = 0}. [:- x, 1:] ^ Suc (order x p - 1))", "by (subst prod.distinct_set_conv_list [symmetric]) simp_all"], ["proof (state)\nthis:\n  (\\<Prod>x\\<leftarrow>xs. [:- x, 1:] ^ Suc (order x p - 1)) =\n  (\\<Prod>x\\<in>{x. poly p x = 0}. [:- x, 1:] ^ Suc (order x p - 1))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>fctrs. is_factorization_of fctrs p", "also"], ["proof (state)\nthis:\n  (\\<Prod>x\\<leftarrow>xs. [:- x, 1:] ^ Suc (order x p - 1)) =\n  (\\<Prod>x\\<in>{x. poly p x = 0}. [:- x, 1:] ^ Suc (order x p - 1))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>fctrs. is_factorization_of fctrs p", "have \"\\<dots> = (\\<Prod>x|poly p x = 0. [:- x, 1:] ^ order x p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>{x. poly p x = 0}. [:- x, 1:] ^ Suc (order x p - 1)) =\n    (\\<Prod>x\\<in>{x. poly p x = 0}. [:- x, 1:] ^ order x p)", "proof (intro prod.cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       [:- x, 1:] ^ Suc (order x p - 1) = [:- x, 1:] ^ order x p", "case (1 x)"], ["proof (state)\nthis:\n  x \\<in> {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       [:- x, 1:] ^ Suc (order x p - 1) = [:- x, 1:] ^ order x p", "with False"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}", "have \"order x p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0", "by (subst (asm) order_root) auto"], ["proof (state)\nthis:\n  order x p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       [:- x, 1:] ^ Suc (order x p - 1) = [:- x, 1:] ^ order x p", "hence *: \"Suc (order x p - 1) = order x p\""], ["proof (prove)\nusing this:\n  order x p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Suc (order x p - 1) = order x p", "by simp"], ["proof (state)\nthis:\n  Suc (order x p - 1) = order x p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       [:- x, 1:] ^ Suc (order x p - 1) = [:- x, 1:] ^ order x p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- x, 1:] ^ Suc (order x p - 1) = [:- x, 1:] ^ order x p", "by (simp only: *)"], ["proof (state)\nthis:\n  [:- x, 1:] ^ Suc (order x p - 1) = [:- x, 1:] ^ order x p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>{x. poly p x = 0}. [:- x, 1:] ^ Suc (order x p - 1)) =\n  (\\<Prod>x\\<in>{x. poly p x = 0}. [:- x, 1:] ^ order x p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>fctrs. is_factorization_of fctrs p", "also"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>{x. poly p x = 0}. [:- x, 1:] ^ Suc (order x p - 1)) =\n  (\\<Prod>x\\<in>{x. poly p x = 0}. [:- x, 1:] ^ order x p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>fctrs. is_factorization_of fctrs p", "have \"smult (lead_coeff p) \\<dots> = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (lead_coeff p)\n     (\\<Prod>x\\<in>{x. poly p x = 0}. [:- x, 1:] ^ order x p) =\n    p", "by (rule complex_poly_decompose)"], ["proof (state)\nthis:\n  smult (lead_coeff p)\n   (\\<Prod>x\\<in>{x. poly p x = 0}. [:- x, 1:] ^ order x p) =\n  p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>fctrs. is_factorization_of fctrs p", "finally"], ["proof (chain)\npicking this:\n  interp_factorization\n   (lead_coeff p, map (\\<lambda>x. (x, order x p - 1)) xs) =\n  p", "have \"is_factorization_of (lead_coeff p, map (\\<lambda>x. (x, order x p - 1)) xs) p\""], ["proof (prove)\nusing this:\n  interp_factorization\n   (lead_coeff p, map (\\<lambda>x. (x, order x p - 1)) xs) =\n  p\n\ngoal (1 subgoal):\n 1. is_factorization_of\n     (lead_coeff p, map (\\<lambda>x. (x, order x p - 1)) xs) p", "by (auto simp: is_factorization_of_def o_def)"], ["proof (state)\nthis:\n  is_factorization_of\n   (lead_coeff p, map (\\<lambda>x. (x, order x p - 1)) xs) p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>fctrs. is_factorization_of fctrs p", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_factorization_of\n   (lead_coeff p, map (\\<lambda>x. (x, order x p - 1)) xs) p\n\ngoal (1 subgoal):\n 1. \\<exists>fctrs. is_factorization_of fctrs p", ".."], ["proof (state)\nthis:\n  \\<exists>fctrs. is_factorization_of fctrs p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  By reflecting the polynomial, this means that for complex polynomials with non-zero\n  constant coefficient, the alternative factorisation also exists.\n\\<close>"], ["", "corollary complex_alt_factorization_exists:\n  assumes \"coeff p 0 \\<noteq> 0\"\n  shows   \"\\<exists>fctrs. is_alt_factorization_of fctrs (p :: complex poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fctrs. is_alt_factorization_of fctrs p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>fctrs. is_alt_factorization_of fctrs p", "from assms"], ["proof (chain)\npicking this:\n  coeff p 0 \\<noteq> 0", "have \"coeff (reflect_poly p) 0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  coeff p 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coeff (reflect_poly p) 0 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  coeff (reflect_poly p) 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>fctrs. is_alt_factorization_of fctrs p", "moreover"], ["proof (state)\nthis:\n  coeff (reflect_poly p) 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>fctrs. is_alt_factorization_of fctrs p", "from complex_factorization_exists [of \"reflect_poly p\"]"], ["proof (chain)\npicking this:\n  \\<exists>fctrs. is_factorization_of fctrs (reflect_poly p)", "obtain fctrs where \"is_factorization_of fctrs (reflect_poly p)\""], ["proof (prove)\nusing this:\n  \\<exists>fctrs. is_factorization_of fctrs (reflect_poly p)\n\ngoal (1 subgoal):\n 1. (\\<And>fctrs.\n        is_factorization_of fctrs (reflect_poly p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  is_factorization_of fctrs (reflect_poly p)\n\ngoal (1 subgoal):\n 1. \\<exists>fctrs. is_alt_factorization_of fctrs p", "ultimately"], ["proof (chain)\npicking this:\n  coeff (reflect_poly p) 0 \\<noteq> 0\n  is_factorization_of fctrs (reflect_poly p)", "have \"is_alt_factorization_of fctrs (reflect_poly (reflect_poly p))\""], ["proof (prove)\nusing this:\n  coeff (reflect_poly p) 0 \\<noteq> 0\n  is_factorization_of fctrs (reflect_poly p)\n\ngoal (1 subgoal):\n 1. is_alt_factorization_of fctrs (reflect_poly (reflect_poly p))", "by (rule reflect_factorization)"], ["proof (state)\nthis:\n  is_alt_factorization_of fctrs (reflect_poly (reflect_poly p))\n\ngoal (1 subgoal):\n 1. \\<exists>fctrs. is_alt_factorization_of fctrs p", "also"], ["proof (state)\nthis:\n  is_alt_factorization_of fctrs (reflect_poly (reflect_poly p))\n\ngoal (1 subgoal):\n 1. \\<exists>fctrs. is_alt_factorization_of fctrs p", "from assms"], ["proof (chain)\npicking this:\n  coeff p 0 \\<noteq> 0", "have \"reflect_poly (reflect_poly p) = p\""], ["proof (prove)\nusing this:\n  coeff p 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. reflect_poly (reflect_poly p) = p", "by simp"], ["proof (state)\nthis:\n  reflect_poly (reflect_poly p) = p\n\ngoal (1 subgoal):\n 1. \\<exists>fctrs. is_alt_factorization_of fctrs p", "finally"], ["proof (chain)\npicking this:\n  is_alt_factorization_of fctrs p", "show ?thesis"], ["proof (prove)\nusing this:\n  is_alt_factorization_of fctrs p\n\ngoal (1 subgoal):\n 1. \\<exists>fctrs. is_alt_factorization_of fctrs p", ".."], ["proof (state)\nthis:\n  \\<exists>fctrs. is_alt_factorization_of fctrs p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}