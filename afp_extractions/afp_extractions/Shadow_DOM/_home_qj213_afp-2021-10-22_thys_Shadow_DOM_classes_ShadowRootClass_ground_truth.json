{"file_name": "/home/qj213/afp-2021-10-22/thys/Shadow_DOM/classes/ShadowRootClass.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Shadow_DOM", "problem_names": ["lemma shadow_root_ptr_kinds_simp [simp]:\n  \"shadow_root_ptr_kinds (Heap (fmupd (cast shadow_root_ptr) shadow_root (the_heap h))) =\n{|shadow_root_ptr|} |\\<union>| shadow_root_ptr_kinds h\"", "lemma shadow_root_ptr_kinds_heap_upd [simp]:\n  \"shadow_root_ptr_kinds (Heap (fmupd (cast shadow_root_ptr) shadow_root (the_heap h))) =\n{|shadow_root_ptr|} |\\<union>| shadow_root_ptr_kinds h\"", "lemma shadow_root_ptr_kinds_commutes [simp]:\n  \"cast shadow_root_ptr |\\<in>| object_ptr_kinds h \\<longleftrightarrow> shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\"", "lemmas type_wf_defs = a_type_wf_def", "lemma type_wf_implies_previous: \"type_wf h \\<Longrightarrow> DocumentClass.type_wf h\"", "lemma get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_type_wf:\n  assumes \"type_wf h\"\n  shows \"shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h \\<longleftrightarrow> get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h \\<noteq> None\"", "lemma put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_in_heap:\n  assumes \"put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr shadow_root h = h'\"\n  shows \"shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\"", "lemma put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_put_ptrs:\n  assumes \"put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr shadow_root h = h'\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast shadow_root_ptr|}\"", "lemma cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_inject [simp]: \"cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x = cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t y \\<longleftrightarrow> x = y\"", "lemma cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_none [simp]:\n  \"cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t obj = None \\<longleftrightarrow> \\<not> (\\<exists>shadow_root. cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t shadow_root = obj)\"", "lemma cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_some [simp]:\n  \"cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t obj = Some shadow_root \\<longleftrightarrow> cast shadow_root = obj\"", "lemma cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_inv [simp]: \"cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t (cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t shadow_root) = Some shadow_root\"", "lemma cast_shadow_root_not_node [simp]:\n  \"cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t shadow_root \\<noteq> cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t node\"\n  \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t node \\<noteq> cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t shadow_root\"", "lemma get_shadow_root_ptr_simp1 [simp]:\n  \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr shadow_root h) = Some shadow_root\"", "lemma get_shadow_root_ptr_simp2 [simp]:\n  \"shadow_root_ptr \\<noteq> shadow_root_ptr'\n   \\<Longrightarrow> get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' shadow_root h) =\nget\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h\"", "lemma get_shadow_root_ptr_simp3 [simp]:\n  \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr f h) = get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr h\"", "lemma get_shadow_root_ptr_simp4 [simp]:\n  \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr f h) = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h\"", "lemma get_shadow_root_ptr_simp5 [simp]:\n  \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr f h) = get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr h\"", "lemma get_shadow_root_ptr_simp6 [simp]:\n  \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr f h) = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h\"", "lemma get_shadow_root_ptr_simp7 [simp]:\n  \"get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr f h) = get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr h\"", "lemma get_shadow_root_ptr_simp8 [simp]:\n  \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr f h) = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h\"", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t [simp]:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  shows \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h'\"", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t [simp]:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  shows \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h'\"", "lemma new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t [simp]:\n  assumes \"new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_document_ptr, h')\"\n  shows \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h'\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_in_heap:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  shows \"new_shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\"", "lemma new_shadow_root_ptr_new:\n  \"shadow_root_ptr.Ref (Suc (fMax (finsert 0 (shadow_root_ptr.the_ref |`| shadow_root_ptrs h)))) |\\<notin>|\nshadow_root_ptrs h\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_not_in_heap:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  shows \"new_shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_new_ptr:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_shadow_root_ptr|}\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_is_shadow_root_ptr:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  shows \"is_shadow_root_ptr new_shadow_root_ptr\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t [simp]:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  assumes \"ptr \\<noteq> cast new_shadow_root_ptr\"\n  shows \"get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h = get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h'\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e [simp]:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  shows \"get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr h = get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr h'\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t [simp]:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  shows \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr h = get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr h'\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a [simp]:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  shows \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr h = get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr h'\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t [simp]:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  shows \"get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr h = get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr h'\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t [simp]:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  assumes \"ptr \\<noteq> new_shadow_root_ptr\"\n  shows \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h'\"", "lemma known_ptr_not_shadow_root_ptr: \"a_known_ptr ptr \\<Longrightarrow> \\<not>is_shadow_root_ptr ptr \\<Longrightarrow> known_ptr ptr\"", "lemma known_ptr_new_shadow_root_ptr: \"a_known_ptr ptr \\<Longrightarrow> \\<not>known_ptr ptr \\<Longrightarrow> is_shadow_root_ptr ptr\"", "lemmas known_ptr_defs = a_known_ptr_def", "lemma known_ptrs_known_ptr: \"a_known_ptrs h \\<Longrightarrow> ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> known_ptr ptr\"", "lemma known_ptrs_preserved:\n  \"object_ptr_kinds h = object_ptr_kinds h' \\<Longrightarrow> a_known_ptrs h = a_known_ptrs h'\"", "lemma known_ptrs_subset:\n  \"object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h \\<Longrightarrow> a_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\"", "lemma known_ptrs_new_ptr:\n  \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|new_ptr|} \\<Longrightarrow> known_ptr new_ptr \\<Longrightarrow>\na_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\"", "lemmas known_ptrs_defs = a_known_ptrs_def", "lemma known_ptrs_is_l_known_ptrs  [instances]: \"l_known_ptrs known_ptr known_ptrs\"", "lemma shadow_root_get_put_1 [simp]:\n  \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr shadow_root h) = Some shadow_root\"", "lemma shadow_root_different_get_put [simp]:\n  \"shadow_root_ptr \\<noteq> shadow_root_ptr' \\<Longrightarrow>\nget\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' shadow_root h) = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h\"", "lemma shadow_root_get_put_2 [simp]:\n  \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr f h) = get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr h\"", "lemma shadow_root_get_put_3 [simp]:\n  \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t element_ptr (put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t shadow_root_ptr f h) = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t element_ptr h\"", "lemma shadow_root_get_put_4 [simp]:\n  \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr f h) = get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr h\"", "lemma shadow_root_get_put_5 [simp]:\n  \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t character_data_ptr (put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a shadow_root_ptr f h) = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t character_data_ptr h\"", "lemma shadow_root_get_put_6 [simp]:\n  \"get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr f h) = get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr h\"", "lemma shadow_root_get_put_7 [simp]:\n  \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t document_ptr (put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t shadow_root_ptr f h) = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t document_ptr h\"", "lemma known_ptrs_implies: \"DocumentClass.known_ptrs h \\<Longrightarrow> ShadowRootClass.known_ptrs h\"", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_pointer_removed:\n  assumes \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h = Some h'\"\n  shows \"ptr |\\<notin>| shadow_root_ptr_kinds h'\"", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_pointer_ptr_in_heap:\n  assumes \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h = Some h'\"\n  shows \"ptr |\\<in>| shadow_root_ptr_kinds h\"", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ok:\n  assumes \"ptr |\\<in>| shadow_root_ptr_kinds h\"\n  shows \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h \\<noteq> None\"", "lemma shadow_root_delete_get_1 [simp]:\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h = Some h' \\<Longrightarrow> get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h' = None\"", "lemma shadow_root_different_delete_get [simp]:\n  \"shadow_root_ptr \\<noteq> shadow_root_ptr' \\<Longrightarrow> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' h = Some h' \\<Longrightarrow>\nget\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h' = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h\"", "lemma shadow_root_delete_get_2 [simp]:\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h = Some h' \\<Longrightarrow> object_ptr \\<noteq> cast shadow_root_ptr \\<Longrightarrow>\nget\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr h' = get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr h\"", "lemma shadow_root_delete_get_3 [simp]:\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h = Some h' \\<Longrightarrow> get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr h' = get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr h\"", "lemma shadow_root_delete_get_4 [simp]:\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h = Some h' \\<Longrightarrow> get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr h' = get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr h\"", "lemma shadow_root_delete_get_5 [simp]:\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h = Some h' \\<Longrightarrow>\nget\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr h' = get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr h\"", "lemma shadow_root_delete_get_6 [simp]:\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h = Some h' \\<Longrightarrow> get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr h' = get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr h\"", "lemma shadow_root_delete_get_7 [simp]:\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h = Some h' \\<Longrightarrow> shadow_root_ptr' \\<noteq> shadow_root_ptr \\<Longrightarrow>\nget\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' h' = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' h\""], "translations": [["", "lemma shadow_root_ptr_kinds_simp [simp]:\n  \"shadow_root_ptr_kinds (Heap (fmupd (cast shadow_root_ptr) shadow_root (the_heap h))) =\n{|shadow_root_ptr|} |\\<union>| shadow_root_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds\n     (Heap (fmupd (cast shadow_root_ptr) shadow_root (the_heap h))) =\n    {|shadow_root_ptr|} |\\<union>| shadow_root_ptr_kinds h", "apply(auto simp add: shadow_root_ptr_kinds_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr |\\<in>|\n    (the \\<circ> cast) |`|\n    ffilter is_shadow_root_ptr_kind\n     (finsert (cast shadow_root_ptr) (object_ptr_kinds h))", "by force"], ["", "definition shadow_root_ptrs :: \"(_) heap \\<Rightarrow> (_) shadow_root_ptr fset\"\n  where\n    \"shadow_root_ptrs heap = ffilter is_shadow_root_ptr (shadow_root_ptr_kinds heap)\""], ["", "definition cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t :: \"(_) Object \\<Rightarrow> (_) ShadowRoot option\"\n  where\n    \"cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t obj = (case RObject.more obj of\n      Inr (Inr (Inl shadow_root)) \\<Rightarrow> Some (RObject.extend (RObject.truncate obj) shadow_root)\n    | _ \\<Rightarrow> None)\""], ["", "adhoc_overloading cast cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t"], ["", "definition cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t:: \"(_) ShadowRoot \\<Rightarrow> (_) Object\"\n  where\n    \"cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t shadow_root =\n(RObject.extend (RObject.truncate shadow_root) (Inr (Inr (Inl (RObject.more shadow_root)))))\""], ["", "adhoc_overloading cast cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t"], ["", "definition is_shadow_root_kind :: \"(_) Object \\<Rightarrow> bool\"\n  where\n    \"is_shadow_root_kind ptr \\<longleftrightarrow> cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr \\<noteq> None\""], ["", "lemma shadow_root_ptr_kinds_heap_upd [simp]:\n  \"shadow_root_ptr_kinds (Heap (fmupd (cast shadow_root_ptr) shadow_root (the_heap h))) =\n{|shadow_root_ptr|} |\\<union>| shadow_root_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds\n     (Heap (fmupd (cast shadow_root_ptr) shadow_root (the_heap h))) =\n    {|shadow_root_ptr|} |\\<union>| shadow_root_ptr_kinds h", "apply(auto simp add: shadow_root_ptr_kinds_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr |\\<in>|\n    (the \\<circ> cast) |`|\n    ffilter is_shadow_root_ptr_kind\n     (finsert (cast shadow_root_ptr) (object_ptr_kinds h))", "by force"], ["", "lemma shadow_root_ptr_kinds_commutes [simp]:\n  \"cast shadow_root_ptr |\\<in>| object_ptr_kinds h \\<longleftrightarrow> shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast shadow_root_ptr |\\<in>| object_ptr_kinds h) =\n    (shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h)", "apply(auto simp add: object_ptr_kinds_def shadow_root_ptr_kinds_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. cast shadow_root_ptr |\\<in>| fmdom (the_heap h) \\<Longrightarrow>\n    shadow_root_ptr |\\<in>|\n    (the \\<circ> cast) |`|\n    ffilter is_shadow_root_ptr_kind (fmdom (the_heap h))", "by (metis (no_types, lifting) shadow_root_ptr_casts_commute2 shadow_root_ptr_shadow_root_ptr_cast\n      ffmember_filter fimage_eqI\n      fset.map_comp option.sel)"], ["", "definition get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t :: \"(_) shadow_root_ptr \\<Rightarrow> (_) heap \\<Rightarrow> (_) ShadowRoot option\"\n  where\n    \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h = Option.bind (get (cast shadow_root_ptr) h) cast\""], ["", "adhoc_overloading get get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t"], ["", "locale l_type_wf_def\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\nbegin"], ["", "definition a_type_wf :: \"(_) heap \\<Rightarrow> bool\"\n  where\n    \"a_type_wf h = (DocumentClass.type_wf h \\<and> (\\<forall>shadow_root_ptr \\<in> fset (shadow_root_ptr_kinds h).\nget\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h \\<noteq> None))\""], ["", "end"], ["", "global_interpretation l_type_wf_def\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t defines type_wf = a_type_wf"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas type_wf_defs = a_type_wf_def"], ["", "locale l_type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t = l_type_wf type_wf for type_wf :: \"((_) heap \\<Rightarrow> bool)\" +\n  assumes type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t: \"type_wf h \\<Longrightarrow> ShadowRootClass.type_wf h\""], ["", "sublocale l_type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t \\<subseteq> l_type_wf\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_type_wf\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n     type_wf", "apply(unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h. type_wf h \\<Longrightarrow> DocumentClass.type_wf h", "by (metis (full_types) ShadowRootClass.type_wf_def a_type_wf_def l_type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_axioms\n      l_type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["", "lemma type_wf_implies_previous: \"type_wf h \\<Longrightarrow> DocumentClass.type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h \\<Longrightarrow> DocumentClass.type_wf h", "by(simp add: type_wf_defs)"], ["", "locale l_get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_lemmas = l_type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\nbegin"], ["", "sublocale l_get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas\n     type_wf", "by unfold_locales"], ["", "lemma get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_type_wf:\n  assumes \"type_wf h\"\n  shows \"shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h \\<longleftrightarrow> get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h) =\n    (get shadow_root_ptr h \\<noteq> None)", "using l_type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_axioms assms"], ["proof (prove)\nusing this:\n  l_type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   type_wf\n  type_wf h\n\ngoal (1 subgoal):\n 1. (shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h) =\n    (get shadow_root_ptr h \\<noteq> None)", "apply(simp add: type_wf_defs get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def l_type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>h.\n                type_wf h \\<longrightarrow>\n                DocumentClass.type_wf h \\<and>\n                (\\<forall>shadow_root_ptr\n                          \\<in>fset (shadow_root_ptr_kinds h).\n                    \\<exists>y.\n                       Option.bind (get (cast shadow_root_ptr) h) cast =\n                       Some y);\n     type_wf h\\<rbrakk>\n    \\<Longrightarrow> (shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h) =\n                      (\\<exists>y.\n                          Option.bind (get (cast shadow_root_ptr) h) cast =\n                          Some y)", "by (metis is_none_bind is_none_simps(1) is_none_simps(2) local.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf notin_fset\n      shadow_root_ptr_kinds_commutes)"], ["", "end"], ["", "global_interpretation l_get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_lemmas\n     ShadowRootClass.type_wf", "by unfold_locales"], ["", "definition put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t :: \"(_) shadow_root_ptr \\<Rightarrow> (_) ShadowRoot \\<Rightarrow> (_) heap \\<Rightarrow> (_) heap\"\n  where\n    \"put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr shadow_root = put (cast shadow_root_ptr) (cast shadow_root)\""], ["", "adhoc_overloading put put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t"], ["", "lemma put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_in_heap:\n  assumes \"put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr shadow_root h = h'\"\n  shows \"shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  put shadow_root_ptr shadow_root h = h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'", "unfolding put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def"], ["proof (prove)\nusing this:\n  put (cast shadow_root_ptr) (cast shadow_root) h = h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'", "by (metis shadow_root_ptr_kinds_commutes put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ptr_in_heap)"], ["", "lemma put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_put_ptrs:\n  assumes \"put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr shadow_root h = h'\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast shadow_root_ptr|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast shadow_root_ptr|}", "using assms"], ["proof (prove)\nusing this:\n  put shadow_root_ptr shadow_root h = h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast shadow_root_ptr|}", "by (simp add: put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_put_ptrs)"], ["", "lemma cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_inject [simp]: \"cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x = cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast x = cast y) = (x = y)", "apply(simp add: cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def RObject.extend_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RObject.more x = RObject.more y) = (x = y)", "by (metis (full_types) RObject.surjective old.unit.exhaust)"], ["", "lemma cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_none [simp]:\n  \"cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t obj = None \\<longleftrightarrow> \\<not> (\\<exists>shadow_root. cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t shadow_root = obj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast obj = None) = (\\<nexists>shadow_root. cast shadow_root = obj)", "apply(auto simp add: cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def RObject.extend_def\n      split: sum.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       RObject.more obj = Inr (Inr (Inl x1)) \\<Longrightarrow>\n       \\<exists>shadow_root.\n          \\<lparr>RObject.nothing = (),\n             \\<dots> = Inr (Inr (Inl (RObject.more shadow_root)))\\<rparr> =\n          obj", "by (metis (full_types) RObject.select_convs(2) RObject.surjective old.unit.exhaust)"], ["", "lemma cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_some [simp]:\n  \"cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t obj = Some shadow_root \\<longleftrightarrow> cast shadow_root = obj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast obj = Some shadow_root) = (cast shadow_root = obj)", "by(auto simp add: cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def RObject.extend_def split: sum.splits)"], ["", "lemma cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_inv [simp]: \"cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t (cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t shadow_root) = Some shadow_root\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cast (cast shadow_root) = Some shadow_root", "by simp"], ["", "lemma cast_shadow_root_not_node [simp]:\n  \"cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t shadow_root \\<noteq> cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t node\"\n  \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t node \\<noteq> cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t shadow_root\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cast shadow_root \\<noteq> cast node &&&\n    cast node \\<noteq> cast shadow_root", "by(auto simp add: cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def RObject.extend_def)"], ["", "lemma get_shadow_root_ptr_simp1 [simp]:\n  \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr shadow_root h) = Some shadow_root\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get shadow_root_ptr (put shadow_root_ptr shadow_root h) =\n    Some shadow_root", "by(auto simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["", "lemma get_shadow_root_ptr_simp2 [simp]:\n  \"shadow_root_ptr \\<noteq> shadow_root_ptr'\n   \\<Longrightarrow> get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' shadow_root h) =\nget\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr \\<noteq> shadow_root_ptr' \\<Longrightarrow>\n    get shadow_root_ptr (put shadow_root_ptr' shadow_root h) =\n    get shadow_root_ptr h", "by(auto simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["", "lemma get_shadow_root_ptr_simp3 [simp]:\n  \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr f h) = get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get element_ptr (put shadow_root_ptr f h) = get element_ptr h", "by(auto simp add: get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["", "lemma get_shadow_root_ptr_simp4 [simp]:\n  \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr f h) = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get shadow_root_ptr (put element_ptr f h) = get shadow_root_ptr h", "by(auto simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def)"], ["", "lemma get_shadow_root_ptr_simp5 [simp]:\n  \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr f h) = get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get character_data_ptr (put shadow_root_ptr f h) =\n    get character_data_ptr h", "by(auto simp add: get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["", "lemma get_shadow_root_ptr_simp6 [simp]:\n  \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr f h) = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get shadow_root_ptr (put character_data_ptr f h) = get shadow_root_ptr h", "by(auto simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def)"], ["", "lemma get_shadow_root_ptr_simp7 [simp]:\n  \"get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr f h) = get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get document_ptr (put shadow_root_ptr f h) = get document_ptr h", "by(auto simp add: get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["", "lemma get_shadow_root_ptr_simp8 [simp]:\n  \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr f h) = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get shadow_root_ptr (put document_ptr f h) = get shadow_root_ptr h", "by(auto simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def)"], ["", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t [simp]:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  shows \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h =\n  (new_element_ptr, h')\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "by(auto simp add: new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def)"], ["", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t [simp]:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  shows \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n   h =\n  (new_character_data_ptr, h')\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "by(auto simp add: new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def Let_def)"], ["", "lemma new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t [simp]:\n  assumes \"new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_document_ptr, h')\"\n  shows \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h =\n  (new_document_ptr, h')\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "by(auto simp add: new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def)"], ["", "abbreviation \"create_shadow_root_obj mode_arg child_nodes_arg\n  \\<equiv> \\<lparr> RObject.nothing = (), RShadowRoot.nothing = (), mode = mode_arg,\nRShadowRoot.child_nodes = child_nodes_arg, \\<dots> = None \\<rparr>\""], ["", "definition new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t :: \"(_)heap \\<Rightarrow> ((_) shadow_root_ptr \\<times> (_) heap)\"\n  where\n    \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (let new_shadow_root_ptr =\nshadow_root_ptr.Ref (Suc (fMax (shadow_root_ptr.the_ref |`| (shadow_root_ptrs h)))) in\n      (new_shadow_root_ptr, put new_shadow_root_ptr (create_shadow_root_obj Open []) h))\""], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_in_heap:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  shows \"new_shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   h =\n  (new_shadow_root_ptr, h')\n\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'", "unfolding new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def"], ["proof (prove)\nusing this:\n  (shadow_root_ptr.Ref\n    (Suc (fMax (shadow_root_ptr.the_ref |`| shadow_root_ptrs h))),\n   put (shadow_root_ptr.Ref\n         (Suc (fMax (shadow_root_ptr.the_ref |`| shadow_root_ptrs h))))\n    (create_shadow_root_obj Open []) h) =\n  (new_shadow_root_ptr, h')\n\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'", "using put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_in_heap"], ["proof (prove)\nusing this:\n  (shadow_root_ptr.Ref\n    (Suc (fMax (shadow_root_ptr.the_ref |`| shadow_root_ptrs h))),\n   put (shadow_root_ptr.Ref\n         (Suc (fMax (shadow_root_ptr.the_ref |`| shadow_root_ptrs h))))\n    (create_shadow_root_obj Open []) h) =\n  (new_shadow_root_ptr, h')\n  put ?shadow_root_ptr ?shadow_root ?h = ?h' \\<Longrightarrow>\n  ?shadow_root_ptr |\\<in>| shadow_root_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'", "by blast"], ["", "lemma new_shadow_root_ptr_new:\n  \"shadow_root_ptr.Ref (Suc (fMax (finsert 0 (shadow_root_ptr.the_ref |`| shadow_root_ptrs h)))) |\\<notin>|\nshadow_root_ptrs h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr.Ref\n     (Suc (fMax\n            (finsert 0\n              (shadow_root_ptr.the_ref |`| shadow_root_ptrs h)))) |\\<notin>|\n    shadow_root_ptrs h", "by (metis Suc_n_not_le_n shadow_root_ptr.sel(1) fMax_ge fimage_finsert finsertI1 finsertI2 set_finsert)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_not_in_heap:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  shows \"new_shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   h =\n  (new_shadow_root_ptr, h')\n\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h", "unfolding new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def"], ["proof (prove)\nusing this:\n  (let new_shadow_root_ptr =\n         shadow_root_ptr.Ref\n          (Suc (fMax (shadow_root_ptr.the_ref |`| shadow_root_ptrs h)))\n   in (new_shadow_root_ptr,\n       put new_shadow_root_ptr (create_shadow_root_obj Open []) h)) =\n  (new_shadow_root_ptr, h')\n\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h", "by (metis Pair_inject shadow_root_ptrs_def fMax_finsert fempty_iff ffmember_filter\n      fimage_is_fempty is_shadow_root_ptr_ref max_0L new_shadow_root_ptr_new)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_new_ptr:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_shadow_root_ptr|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast new_shadow_root_ptr|}", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   h =\n  (new_shadow_root_ptr, h')\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast new_shadow_root_ptr|}", "by (metis Pair_inject new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_put_ptrs)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_is_shadow_root_ptr:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  shows \"is_shadow_root_ptr new_shadow_root_ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_shadow_root_ptr new_shadow_root_ptr", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   h =\n  (new_shadow_root_ptr, h')\n\ngoal (1 subgoal):\n 1. is_shadow_root_ptr new_shadow_root_ptr", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t [simp]:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  assumes \"ptr \\<noteq> cast new_shadow_root_ptr\"\n  shows \"get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h = get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   h =\n  (new_shadow_root_ptr, h')\n  ptr \\<noteq> cast new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e [simp]:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  shows \"get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr h = get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   h =\n  (new_shadow_root_ptr, h')\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "apply(simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr.Ref\n     (Suc (fMax (shadow_root_ptr.the_ref |`| shadow_root_ptrs h))) =\n    new_shadow_root_ptr \\<and>\n    put (cast\n          (shadow_root_ptr.Ref\n            (Suc (fMax (shadow_root_ptr.the_ref |`| shadow_root_ptrs h)))))\n     (cast (create_shadow_root_obj Open [])) h =\n    h' \\<Longrightarrow>\n    get ptr h = get ptr h'", "by(auto simp add: get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t [simp]:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  shows \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr h = get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   h =\n  (new_shadow_root_ptr, h')\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a [simp]:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  shows \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr h = get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   h =\n  (new_shadow_root_ptr, h')\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t [simp]:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  shows \"get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr h = get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   h =\n  (new_shadow_root_ptr, h')\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "apply(simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr.Ref\n     (Suc (fMax (shadow_root_ptr.the_ref |`| shadow_root_ptrs h))) =\n    new_shadow_root_ptr \\<and>\n    put (cast\n          (shadow_root_ptr.Ref\n            (Suc (fMax (shadow_root_ptr.the_ref |`| shadow_root_ptrs h)))))\n     (cast (create_shadow_root_obj Open [])) h =\n    h' \\<Longrightarrow>\n    get ptr h = get ptr h'", "by(auto simp add: get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t [simp]:\n  assumes \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h = (new_shadow_root_ptr, h')\"\n  assumes \"ptr \\<noteq> new_shadow_root_ptr\"\n  shows \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   h =\n  (new_shadow_root_ptr, h')\n  ptr \\<noteq> new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def)"], ["", "locale l_known_ptr\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\nbegin"], ["", "definition a_known_ptr :: \"(_) object_ptr \\<Rightarrow> bool\"\n  where\n    \"a_known_ptr ptr = (known_ptr ptr \\<or> is_shadow_root_ptr ptr)\""], ["", "lemma known_ptr_not_shadow_root_ptr: \"a_known_ptr ptr \\<Longrightarrow> \\<not>is_shadow_root_ptr ptr \\<Longrightarrow> known_ptr ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.a_known_ptr ptr;\n     \\<not> (case cast ptr of None \\<Rightarrow> False\n             | Some shadow_root_ptr \\<Rightarrow>\n                 is_shadow_root_ptr shadow_root_ptr)\\<rbrakk>\n    \\<Longrightarrow> DocumentClass.known_ptr ptr", "by(simp add: a_known_ptr_def)"], ["", "lemma known_ptr_new_shadow_root_ptr: \"a_known_ptr ptr \\<Longrightarrow> \\<not>known_ptr ptr \\<Longrightarrow> is_shadow_root_ptr ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.a_known_ptr ptr;\n     \\<not> DocumentClass.known_ptr ptr\\<rbrakk>\n    \\<Longrightarrow> case cast ptr of None \\<Rightarrow> False\n                      | Some shadow_root_ptr \\<Rightarrow>\n                          is_shadow_root_ptr shadow_root_ptr", "using l_known_ptr\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t.known_ptr_not_shadow_root_ptr"], ["proof (prove)\nusing this:\n  \\<lbrakk>local.a_known_ptr ?ptr;\n   \\<not> (case cast ?ptr of None \\<Rightarrow> False\n           | Some shadow_root_ptr \\<Rightarrow>\n               is_shadow_root_ptr shadow_root_ptr)\\<rbrakk>\n  \\<Longrightarrow> DocumentClass.known_ptr ?ptr\n\ngoal (1 subgoal):\n 1. \\<lbrakk>local.a_known_ptr ptr;\n     \\<not> DocumentClass.known_ptr ptr\\<rbrakk>\n    \\<Longrightarrow> case cast ptr of None \\<Rightarrow> False\n                      | Some shadow_root_ptr \\<Rightarrow>\n                          is_shadow_root_ptr shadow_root_ptr", "by blast"], ["", "end"], ["", "global_interpretation l_known_ptr\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t defines known_ptr = a_known_ptr"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas known_ptr_defs = a_known_ptr_def"], ["", "locale l_known_ptrs\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t = l_known_ptr known_ptr for known_ptr :: \"(_) object_ptr \\<Rightarrow> bool\"\nbegin"], ["", "definition a_known_ptrs :: \"(_) heap \\<Rightarrow> bool\"\n  where\n    \"a_known_ptrs h = (\\<forall>ptr \\<in> fset (object_ptr_kinds h). known_ptr ptr)\""], ["", "lemma known_ptrs_known_ptr: \"a_known_ptrs h \\<Longrightarrow> ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> known_ptr ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.a_known_ptrs h; ptr |\\<in>| object_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> known_ptr ptr", "apply(simp add: a_known_ptrs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ptr\\<in>fset (object_ptr_kinds h). known_ptr ptr;\n     ptr |\\<in>| object_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> known_ptr ptr", "using notin_fset"], ["proof (prove)\nusing this:\n  (?x |\\<notin>| ?S) = (?x \\<notin> fset ?S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ptr\\<in>fset (object_ptr_kinds h). known_ptr ptr;\n     ptr |\\<in>| object_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> known_ptr ptr", "by fastforce"], ["", "lemma known_ptrs_preserved:\n  \"object_ptr_kinds h = object_ptr_kinds h' \\<Longrightarrow> a_known_ptrs h = a_known_ptrs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h' \\<Longrightarrow>\n    local.a_known_ptrs h = local.a_known_ptrs h'", "by(auto simp add: a_known_ptrs_def)"], ["", "lemma known_ptrs_subset:\n  \"object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h \\<Longrightarrow> a_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h;\n     local.a_known_ptrs h\\<rbrakk>\n    \\<Longrightarrow> local.a_known_ptrs h'", "by (simp add: less_eq_fset.rep_eq local.a_known_ptrs_def subsetD)"], ["", "lemma known_ptrs_new_ptr:\n  \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|new_ptr|} \\<Longrightarrow> known_ptr new_ptr \\<Longrightarrow>\na_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>object_ptr_kinds h' =\n             object_ptr_kinds h |\\<union>| {|new_ptr|};\n     known_ptr new_ptr; local.a_known_ptrs h\\<rbrakk>\n    \\<Longrightarrow> local.a_known_ptrs h'", "by(simp add: a_known_ptrs_def)"], ["", "end"], ["", "global_interpretation l_known_ptrs\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t known_ptr defines known_ptrs = a_known_ptrs"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas known_ptrs_defs = a_known_ptrs_def"], ["", "lemma known_ptrs_is_l_known_ptrs  [instances]: \"l_known_ptrs known_ptr known_ptrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_known_ptrs ShadowRootClass.known_ptr ShadowRootClass.known_ptrs", "using known_ptrs_known_ptr known_ptrs_preserved l_known_ptrs_def known_ptrs_subset\n    known_ptrs_new_ptr"], ["proof (prove)\nusing this:\n  \\<lbrakk>ShadowRootClass.known_ptrs ?h;\n   ?ptr |\\<in>| object_ptr_kinds ?h\\<rbrakk>\n  \\<Longrightarrow> ShadowRootClass.known_ptr ?ptr\n  object_ptr_kinds ?h = object_ptr_kinds ?h' \\<Longrightarrow>\n  ShadowRootClass.known_ptrs ?h = ShadowRootClass.known_ptrs ?h'\n  l_known_ptrs ?known_ptr ?known_ptrs \\<equiv>\n  ((\\<forall>h ptr.\n       ?known_ptrs h \\<longrightarrow>\n       ptr |\\<in>| object_ptr_kinds h \\<longrightarrow>\n       ?known_ptr ptr) \\<and>\n   (\\<forall>h h'.\n       object_ptr_kinds h = object_ptr_kinds h' \\<longrightarrow>\n       ?known_ptrs h = ?known_ptrs h')) \\<and>\n  (\\<forall>h' h.\n      object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h \\<longrightarrow>\n      ?known_ptrs h \\<longrightarrow> ?known_ptrs h') \\<and>\n  (\\<forall>h' h new_ptr.\n      object_ptr_kinds h' =\n      object_ptr_kinds h |\\<union>| {|new_ptr|} \\<longrightarrow>\n      ?known_ptr new_ptr \\<longrightarrow>\n      ?known_ptrs h \\<longrightarrow> ?known_ptrs h')\n  \\<lbrakk>object_ptr_kinds ?h' |\\<subseteq>| object_ptr_kinds ?h;\n   ShadowRootClass.known_ptrs ?h\\<rbrakk>\n  \\<Longrightarrow> ShadowRootClass.known_ptrs ?h'\n  \\<lbrakk>object_ptr_kinds ?h' =\n           object_ptr_kinds ?h |\\<union>| {|?new_ptr|};\n   ShadowRootClass.known_ptr ?new_ptr;\n   ShadowRootClass.known_ptrs ?h\\<rbrakk>\n  \\<Longrightarrow> ShadowRootClass.known_ptrs ?h'\n\ngoal (1 subgoal):\n 1. l_known_ptrs ShadowRootClass.known_ptr ShadowRootClass.known_ptrs", "by blast"], ["", "lemma shadow_root_get_put_1 [simp]:\n  \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr shadow_root h) = Some shadow_root\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get shadow_root_ptr (put shadow_root_ptr shadow_root h) =\n    Some shadow_root", "by(auto simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["", "lemma shadow_root_different_get_put [simp]:\n  \"shadow_root_ptr \\<noteq> shadow_root_ptr' \\<Longrightarrow>\nget\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' shadow_root h) = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr \\<noteq> shadow_root_ptr' \\<Longrightarrow>\n    get shadow_root_ptr (put shadow_root_ptr' shadow_root h) =\n    get shadow_root_ptr h", "by(auto simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["", "lemma shadow_root_get_put_2 [simp]:\n  \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr f h) = get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get element_ptr (put shadow_root_ptr f h) = get element_ptr h", "by(auto simp add: get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["", "lemma shadow_root_get_put_3 [simp]:\n  \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t element_ptr (put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t shadow_root_ptr f h) = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t element_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get element_ptr (put shadow_root_ptr f h) = get element_ptr h", "by(auto simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def)"], ["", "lemma shadow_root_get_put_4 [simp]:\n  \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr f h) = get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get character_data_ptr (put shadow_root_ptr f h) =\n    get character_data_ptr h", "by(auto simp add: get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["", "lemma shadow_root_get_put_5 [simp]:\n  \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t character_data_ptr (put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a shadow_root_ptr f h) = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t character_data_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get character_data_ptr (put shadow_root_ptr f h) =\n    get character_data_ptr h", "by(auto simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def)"], ["", "lemma shadow_root_get_put_6 [simp]:\n  \"get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr (put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr f h) = get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get document_ptr (put shadow_root_ptr f h) = get document_ptr h", "by(auto simp add: get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["", "lemma shadow_root_get_put_7 [simp]:\n  \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t document_ptr (put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t shadow_root_ptr f h) = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t document_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get document_ptr (put shadow_root_ptr f h) = get document_ptr h", "by(auto simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def)"], ["", "lemma known_ptrs_implies: \"DocumentClass.known_ptrs h \\<Longrightarrow> ShadowRootClass.known_ptrs h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DocumentClass.known_ptrs h \\<Longrightarrow>\n    ShadowRootClass.known_ptrs h", "by(auto simp add: DocumentClass.known_ptrs_defs DocumentClass.known_ptr_defs\n      ShadowRootClass.known_ptrs_defs ShadowRootClass.known_ptr_defs)"], ["", "definition delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t :: \"(_) shadow_root_ptr \\<Rightarrow> (_) heap \\<Rightarrow> (_) heap option\" where\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr = delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (cast shadow_root_ptr)\""], ["", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_pointer_removed:\n  assumes \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h = Some h'\"\n  shows \"ptr |\\<notin>| shadow_root_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ptr |\\<notin>| shadow_root_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   ptr h =\n  Some h'\n\ngoal (1 subgoal):\n 1. ptr |\\<notin>| shadow_root_ptr_kinds h'", "by(auto simp add: delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_pointer_removed delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def shadow_root_ptr_kinds_def\n      split: if_splits)"], ["", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_pointer_ptr_in_heap:\n  assumes \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h = Some h'\"\n  shows \"ptr |\\<in>| shadow_root_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ptr |\\<in>| shadow_root_ptr_kinds h", "using assms"], ["proof (prove)\nusing this:\n  delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   ptr h =\n  Some h'\n\ngoal (1 subgoal):\n 1. ptr |\\<in>| shadow_root_ptr_kinds h", "apply(auto simp add: delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_pointer_ptr_in_heap delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def split: if_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (cast ptr) h =\n    Some h' \\<Longrightarrow>\n    ptr |\\<in>| shadow_root_ptr_kinds h", "using delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_pointer_ptr_in_heap"], ["proof (prove)\nusing this:\n  delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ?ptr ?h =\n  Some ?h' \\<Longrightarrow>\n  ?ptr |\\<in>| object_ptr_kinds ?h\n\ngoal (1 subgoal):\n 1. delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (cast ptr) h =\n    Some h' \\<Longrightarrow>\n    ptr |\\<in>| shadow_root_ptr_kinds h", "by fastforce"], ["", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ok:\n  assumes \"ptr |\\<in>| shadow_root_ptr_kinds h\"\n  shows \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr h \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n     ptr h \\<noteq>\n    None", "using assms"], ["proof (prove)\nusing this:\n  ptr |\\<in>| shadow_root_ptr_kinds h\n\ngoal (1 subgoal):\n 1. delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n     ptr h \\<noteq>\n    None", "by (simp add: delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ok delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["", "lemma shadow_root_delete_get_1 [simp]:\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h = Some h' \\<Longrightarrow> get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h' = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n     shadow_root_ptr h =\n    Some h' \\<Longrightarrow>\n    get shadow_root_ptr h' = None", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def split: if_splits)"], ["", "lemma shadow_root_different_delete_get [simp]:\n  \"shadow_root_ptr \\<noteq> shadow_root_ptr' \\<Longrightarrow> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' h = Some h' \\<Longrightarrow>\nget\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h' = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>shadow_root_ptr \\<noteq> shadow_root_ptr';\n     delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n      shadow_root_ptr' h =\n     Some h'\\<rbrakk>\n    \\<Longrightarrow> get shadow_root_ptr h' = get shadow_root_ptr h", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def split: if_splits)"], ["", "lemma shadow_root_delete_get_2 [simp]:\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h = Some h' \\<Longrightarrow> object_ptr \\<noteq> cast shadow_root_ptr \\<Longrightarrow>\nget\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr h' = get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n              shadow_root_ptr h =\n             Some h';\n     object_ptr \\<noteq> cast shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> get object_ptr h' = get object_ptr h", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def split: if_splits)"], ["", "lemma shadow_root_delete_get_3 [simp]:\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h = Some h' \\<Longrightarrow> get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr h' = get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n     shadow_root_ptr h =\n    Some h' \\<Longrightarrow>\n    get node_ptr h' = get node_ptr h", "by(auto simp add: get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def)"], ["", "lemma shadow_root_delete_get_4 [simp]:\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h = Some h' \\<Longrightarrow> get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr h' = get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n     shadow_root_ptr h =\n    Some h' \\<Longrightarrow>\n    get element_ptr h' = get element_ptr h", "by(simp add: get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def)"], ["", "lemma shadow_root_delete_get_5 [simp]:\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h = Some h' \\<Longrightarrow>\nget\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr h' = get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n     shadow_root_ptr h =\n    Some h' \\<Longrightarrow>\n    get character_data_ptr h' = get character_data_ptr h", "by(simp add: get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def)"], ["", "lemma shadow_root_delete_get_6 [simp]:\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h = Some h' \\<Longrightarrow> get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr h' = get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n     shadow_root_ptr h =\n    Some h' \\<Longrightarrow>\n    get document_ptr h' = get document_ptr h", "by(simp add: get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def)"], ["", "lemma shadow_root_delete_get_7 [simp]:\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h = Some h' \\<Longrightarrow> shadow_root_ptr' \\<noteq> shadow_root_ptr \\<Longrightarrow>\nget\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' h' = get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n              shadow_root_ptr h =\n             Some h';\n     shadow_root_ptr' \\<noteq> shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> get shadow_root_ptr' h' = get shadow_root_ptr' h", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def split: if_splits)"], ["", "end"]]}