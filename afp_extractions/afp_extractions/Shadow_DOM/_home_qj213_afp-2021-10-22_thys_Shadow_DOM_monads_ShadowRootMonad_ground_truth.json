{"file_name": "/home/qj213/afp-2021-10-22/thys/Shadow_DOM/monads/ShadowRootMonad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Shadow_DOM", "problem_names": ["lemmas shadow_root_ptr_kinds_M_defs = a_ptr_kinds_M_def", "lemma shadow_root_ptr_kinds_M_eq:\n  assumes \"|h \\<turnstile> object_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> object_ptr_kinds_M|\\<^sub>r\"\n  shows \"|h \\<turnstile> shadow_root_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> shadow_root_ptr_kinds_M|\\<^sub>r\"", "lemma get_M_is_l_get_M: \"l_get_M get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t type_wf shadow_root_ptr_kinds\"", "lemmas get_M_defs = get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def[unfolded l_get_M.a_get_M_def[OF get_M_is_l_get_M]]", "lemmas get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ok = get_M_ok[folded get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def]", "lemmas get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_in_heap = get_M_ptr_in_heap[folded get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def]", "lemmas put_M_defs = a_put_M_def", "lemmas put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ok = put_M_ok[folded put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def]", "lemma shadow_root_put_get [simp]: \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n  \\<Longrightarrow> (\\<And>x. getter (setter (\\<lambda>_. v) x) = v)\n  \\<Longrightarrow> h' \\<turnstile> get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter \\<rightarrow>\\<^sub>r v\"", "lemma get_M_Mshadow_root_preserved1 [simp]:\n  \"shadow_root_ptr \\<noteq> shadow_root_ptr'\n    \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' getter) h h'\"", "lemma shadow_root_put_get_preserved [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> (\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x)\n   \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' getter) h h'\"", "lemma get_M_Mshadow_root_preserved2 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved3 [simp]:\n  \"cast shadow_root_ptr \\<noteq> object_ptr\n   \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved4  [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x))\n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved5 [simp]:\n  \"cast shadow_root_ptr \\<noteq> object_ptr\n  \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr setter v \\<rightarrow>\\<^sub>h h'\n  \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved6 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved7 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved8 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved9 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved10 [simp]:\n  \"(\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x))\n    \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma new_element_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr getter) h h'\"", "lemma new_character_data_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr getter) h h'\"", "lemma new_document_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr getter) h h'\"", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ok [simp]:\n  assumes \"shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\"\n  shows \"h \\<turnstile> ok (delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr)\"", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ptr_in_heap:\n  assumes \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\"\n  shows \"shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\"", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ptr_not_in_heap:\n  assumes \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\"\n  shows \"shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h'\"", "lemma delete_shadow_root_pointers:\n  assumes \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\"\n  shows \"object_ptr_kinds h = object_ptr_kinds h' |\\<union>| {|cast shadow_root_ptr|}\"", "lemma delete_shadow_root_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t: \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\nptr \\<noteq> cast shadow_root_ptr \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr getter) h h'\"", "lemma delete_shadow_root_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e: \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr getter) h h'\"", "lemma delete_shadow_root_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\"", "lemma delete_shadow_root_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a: \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr getter) h h'\"", "lemma delete_shadow_root_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\"", "lemma delete_shadow_root_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t: \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\nshadow_root_ptr \\<noteq> shadow_root_ptr' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' getter) h h'\"", "lemma shadow_root_put_get_1 [simp]: \"shadow_root_ptr \\<noteq> shadow_root_ptr' \\<Longrightarrow>\nh \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' getter) h h'\"", "lemma shadow_root_put_get_2 [simp]: \"(\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x) \\<Longrightarrow>\nh \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' getter) h h'\"", "lemma shadow_root_put_get_3 [simp]: \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr getter) h h'\"", "lemma shadow_root_put_get_4 [simp]: \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\"", "lemma shadow_root_put_get_5 [simp]: \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr getter) h h'\"", "lemma shadow_root_put_get_6 [simp]: \"h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\"", "lemma shadow_root_put_get_7 [simp]: \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter) h h'\"", "lemma shadow_root_put_get_8 [simp]: \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\"", "lemma shadow_root_put_get_9 [simp]: \"(\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \\<Longrightarrow>\nh \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ok [simp]:\n  \"h \\<turnstile> ok new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ptr_in_heap:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"new_shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ptr_not_in_heap:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"new_shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_new_ptr:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_shadow_root_ptr|}\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_is_shadow_root_ptr:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"is_shadow_root_ptr new_shadow_root_ptr\"", "lemma new_shadow_root_mode:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"h' \\<turnstile> get_M new_shadow_root_ptr mode \\<rightarrow>\\<^sub>r Open\"", "lemma new_shadow_root_children:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"h' \\<turnstile> get_M new_shadow_root_ptr child_nodes \\<rightarrow>\\<^sub>r []\"", "lemma new_shadow_root_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n    \\<Longrightarrow> ptr \\<noteq> cast new_shadow_root_ptr \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr getter) h h'\"", "lemma new_shadow_root_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n    \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr getter) h h'\"", "lemma new_shadow_root_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n     \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\"", "lemma new_shadow_root_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n    \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr getter) h h'\"", "lemma new_shadow_root_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\n     \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n     \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\"", "lemma new_shadow_root_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\n     \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr \\<Longrightarrow> ptr \\<noteq> new_shadow_root_ptr\n     \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr getter) h h'\"", "lemma shadow_root_get_put_1 [simp]: \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) = (if ptr = cast shadow_root_ptr\nthen cast obj else get shadow_root_ptr h)\"", "lemma shadow_root_ptr_kinds_new[simp]: \"shadow_root_ptr_kinds (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) = shadow_root_ptr_kinds h |\\<union>|\n(if is_shadow_root_ptr_kind ptr then {|the (cast ptr)|} else {||})\"", "lemma type_wf_put_I:\n  assumes \"type_wf h\"\n  assumes \"DocumentClass.type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"is_shadow_root_ptr_kind ptr \\<Longrightarrow> is_shadow_root_kind obj\"\n  shows \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"", "lemma type_wf_put_ptr_not_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<notin>| object_ptr_kinds h\"\n  shows \"type_wf h\"", "lemma type_wf_put_ptr_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<in>| object_ptr_kinds h\"\n  assumes \"DocumentClass.type_wf h\"\n  assumes \"is_shadow_root_ptr_kind ptr \\<Longrightarrow> is_shadow_root_kind (the (get ptr h))\"\n  shows \"type_wf h\"", "lemma new_element_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_tag_name_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M element_ptr tag_name_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_child_nodes_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M element_ptr RElement.child_nodes_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_attrs_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_shadow_root_opt_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M element_ptr shadow_root_opt_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma new_character_data_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_val_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M character_data_ptr val_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma new_document_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_doctype_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M document_ptr doctype_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_document_element_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M document_ptr document_element_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_disconnected_nodes_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M document_ptr disconnected_nodes_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_mode_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M shadow_root_ptr mode_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_child_nodes_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M shadow_root_ptr RShadowRoot.child_nodes_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma shadow_root_ptr_kinds_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  shows \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\"", "lemma shadow_root_ptr_kinds_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n(\\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h')\"\n  shows \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\"", "lemma new_shadow_root_known_ptr:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"known_ptr (cast new_shadow_root_ptr)\"", "lemma new_shadow_root_type_wf_preserved [simp]: \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma new_shadow_root_is_l_new_shadow_root  [instances]: \"l_new_shadow_root type_wf\"", "lemma type_wf_preserved_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  assumes \"\\<And>character_data_ptr. preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr RCharacterData.nothing) h h'\"\n  assumes \"\\<And>document_ptr. preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr RDocument.nothing) h h'\"\n  assumes \"\\<And>shadow_root_ptr. preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr RShadowRoot.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma new_element_is_l_new_element [instances]:\n  \"l_new_element type_wf\"", "lemma new_character_data_is_l_new_character_data [instances]:\n  \"l_new_character_data type_wf\"", "lemma new_document_is_l_new_document [instances]:\n  \"l_new_document type_wf\"", "lemma type_wf_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n\\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n\\<forall>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n\\<forall>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n\\<forall>character_data_ptr. preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr RCharacterData.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n\\<forall>document_ptr. preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr RDocument.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n\\<forall>shadow_root_ptr. preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr RShadowRoot.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma type_wf_drop: \"type_wf h \\<Longrightarrow> type_wf (Heap (fmdrop ptr (the_heap h)))\"", "lemma delete_shadow_root_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\"\n  assumes \"type_wf h\"\n  shows \"type_wf h'\""], "translations": [["", "lemmas shadow_root_ptr_kinds_M_defs = a_ptr_kinds_M_def"], ["", "lemma shadow_root_ptr_kinds_M_eq:\n  assumes \"|h \\<turnstile> object_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> object_ptr_kinds_M|\\<^sub>r\"\n  shows \"|h \\<turnstile> shadow_root_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> shadow_root_ptr_kinds_M|\\<^sub>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |h \\<turnstile> shadow_root_ptr_kinds_M|\\<^sub>r =\n    |h' \\<turnstile> shadow_root_ptr_kinds_M|\\<^sub>r", "using assms"], ["proof (prove)\nusing this:\n  |h \\<turnstile> object_ptr_kinds_M|\\<^sub>r =\n  |h' \\<turnstile> object_ptr_kinds_M|\\<^sub>r\n\ngoal (1 subgoal):\n 1. |h \\<turnstile> shadow_root_ptr_kinds_M|\\<^sub>r =\n    |h' \\<turnstile> shadow_root_ptr_kinds_M|\\<^sub>r", "by(auto simp add: shadow_root_ptr_kinds_M_defs object_ptr_kinds_M_defs shadow_root_ptr_kinds_def)"], ["", "global_interpretation l_dummy defines get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t = \"l_get_M.a_get_M get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma get_M_is_l_get_M: \"l_get_M get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t type_wf shadow_root_ptr_kinds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M get ShadowRootClass.type_wf shadow_root_ptr_kinds", "apply(simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_type_wf l_get_M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ptr h.\n       (\\<exists>y. get ptr h = Some y) \\<longrightarrow>\n       ptr |\\<in>| shadow_root_ptr_kinds h", "by (metis ObjectClass.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf ObjectClass.type_wf_defs bind_eq_None_conv\n      shadow_root_ptr_kinds_commutes get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def option.simps(3))"], ["", "lemmas get_M_defs = get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def[unfolded l_get_M.a_get_M_def[OF get_M_is_l_get_M]]"], ["", "adhoc_overloading get_M get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t"], ["", "locale l_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_lemmas = l_type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\nbegin"], ["", "sublocale l_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas\n     type_wf", "by unfold_locales"], ["", "interpretation l_get_M get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t type_wf shadow_root_ptr_kinds"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M get type_wf shadow_root_ptr_kinds", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ptr.\n       \\<lbrakk>type_wf h; ptr |\\<in>| shadow_root_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> get ptr h \\<noteq> None\n 2. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| shadow_root_ptr_kinds h", "apply (simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_type_wf local.type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| shadow_root_ptr_kinds h", "by (meson ShadowRootMonad.get_M_is_l_get_M l_get_M_def)"], ["", "lemmas get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ok = get_M_ok[folded get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def]"], ["", "lemmas get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_in_heap = get_M_ptr_in_heap[folded get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def]"], ["", "end"], ["", "global_interpretation l_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_lemmas\n     ShadowRootClass.type_wf", "by unfold_locales"], ["", "global_interpretation l_put_M type_wf shadow_root_ptr_kinds get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t rewrites\n  \"a_get_M = get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\" defines put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t = a_put_M"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M ShadowRootClass.type_wf shadow_root_ptr_kinds get &&&\n    l_get_M.a_get_M get = get_M", "apply (simp add: get_M_is_l_get_M l_put_M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M.a_get_M get = get_M", "by (simp add: get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["", "lemmas put_M_defs = a_put_M_def"], ["", "adhoc_overloading put_M put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t"], ["", "locale l_put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_lemmas = l_type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\nbegin"], ["", "sublocale l_put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas\n     type_wf", "by unfold_locales"], ["", "interpretation l_put_M type_wf shadow_root_ptr_kinds get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M type_wf shadow_root_ptr_kinds get", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ptr.\n       \\<lbrakk>type_wf h; ptr |\\<in>| shadow_root_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> get ptr h \\<noteq> None\n 2. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| shadow_root_ptr_kinds h", "apply (simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_type_wf local.type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| shadow_root_ptr_kinds h", "by (meson ShadowRootMonad.get_M_is_l_get_M l_get_M_def)"], ["", "lemmas put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ok = put_M_ok[folded put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def]"], ["", "end"], ["", "global_interpretation l_put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_lemmas\n     ShadowRootClass.type_wf", "by unfold_locales"], ["", "lemma shadow_root_put_get [simp]: \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n  \\<Longrightarrow> (\\<And>x. getter (setter (\\<lambda>_. v) x) = v)\n  \\<Longrightarrow> h' \\<turnstile> get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter \\<rightarrow>\\<^sub>r v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (setter (\\<lambda>_. v) x) = v\\<rbrakk>\n    \\<Longrightarrow> h' \\<turnstile> get_M shadow_root_ptr getter\n                      \\<rightarrow>\\<^sub>r v", "by(auto simp add: put_M_defs get_M_defs split: option.splits)"], ["", "lemma get_M_Mshadow_root_preserved1 [simp]:\n  \"shadow_root_ptr \\<noteq> shadow_root_ptr'\n    \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>shadow_root_ptr \\<noteq> shadow_root_ptr';\n     h \\<turnstile> put_M shadow_root_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr' getter) h h'", "by(auto simp add: put_M_defs get_M_defs preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma shadow_root_put_get_preserved [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> (\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x)\n   \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (setter (\\<lambda>_. v) x) = getter x\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr' getter) h h'", "apply(cases \"shadow_root_ptr = shadow_root_ptr'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (setter (\\<lambda>_. v) x) = getter x;\n     shadow_root_ptr = shadow_root_ptr'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr' getter) h h'\n 2. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (setter (\\<lambda>_. v) x) = getter x;\n     shadow_root_ptr \\<noteq> shadow_root_ptr'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr' getter) h h'", "by(auto simp add: put_M_defs get_M_defs preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved2 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M shadow_root_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M node_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs NodeMonad.get_M_defs get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def\n      put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved3 [simp]:\n  \"cast shadow_root_ptr \\<noteq> object_ptr\n   \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast shadow_root_ptr \\<noteq> object_ptr;\n     h \\<turnstile> put_M shadow_root_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def ObjectMonad.get_M_defs\n      preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved4  [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x))\n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "apply(cases \"cast shadow_root_ptr \\<noteq> object_ptr\")[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     cast shadow_root_ptr \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'\n 2. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     \\<not> cast shadow_root_ptr \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def\n      ObjectMonad.get_M_defs preserved_def\n      split: option.splits bind_splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved5 [simp]:\n  \"cast shadow_root_ptr \\<noteq> object_ptr\n  \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr setter v \\<rightarrow>\\<^sub>h h'\n  \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast shadow_root_ptr \\<noteq> object_ptr;\n     h \\<turnstile> put_M object_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr getter) h h'", "by(auto simp add: ObjectMonad.put_M_defs get_M_defs get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def ObjectMonad.get_M_defs\n      preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved6 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M shadow_root_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M element_ptr getter) h h'", "by(auto simp add: put_M_defs ElementMonad.get_M_defs preserved_def\n      split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved7 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M shadow_root_ptr getter) h h'", "by(auto simp add: ElementMonad.put_M_defs get_M_defs preserved_def\n      split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved8 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M shadow_root_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M character_data_ptr getter) h h'", "by(auto simp add: put_M_defs CharacterDataMonad.get_M_defs preserved_def\n      split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved9 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M character_data_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M shadow_root_ptr getter) h h'", "by(auto simp add: CharacterDataMonad.put_M_defs get_M_defs preserved_def\n      split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved10 [simp]:\n  \"(\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x))\n    \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     h \\<turnstile> put_M shadow_root_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "apply(cases \"cast shadow_root_ptr = object_ptr\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     h \\<turnstile> put_M shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h';\n     cast shadow_root_ptr = object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'\n 2. \\<lbrakk>\\<And>x.\n                getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     h \\<turnstile> put_M shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h';\n     cast shadow_root_ptr \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs ObjectMonad.get_M_defs NodeMonad.get_M_defs get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def\n      get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def preserved_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def bind_eq_Some_conv\n      split: option.splits)"], ["", "lemma new_element_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M ptr getter) h h'", "by(auto simp add: new_element_def get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_character_data_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> new_character_data\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M ptr getter) h h'", "by(auto simp add: new_character_data_def get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_document_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M ptr getter) h h'", "by(auto simp add: new_document_def get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "definition delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M :: \"(_) shadow_root_ptr \\<Rightarrow> (_, unit) dom_prog\" where\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr = do {\n    h \\<leftarrow> get_heap;\n    (case delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h of\n      Some h \\<Rightarrow> return_heap h |\n      None \\<Rightarrow> error HierarchyRequestError)\n  }\""], ["", "adhoc_overloading delete_M delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M"], ["", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ok [simp]:\n  assumes \"shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\"\n  shows \"h \\<turnstile> ok (delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok delete_M shadow_root_ptr", "using assms"], ["proof (prove)\nusing this:\n  shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\n\ngoal (1 subgoal):\n 1. h \\<turnstile> ok delete_M shadow_root_ptr", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def split: prod.splits)"], ["", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ptr_in_heap:\n  assumes \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\"\n  shows \"shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> delete_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def split: if_splits)"], ["", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ptr_not_in_heap:\n  assumes \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\"\n  shows \"shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> delete_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h'", "apply(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def split: if_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h;\n     h' = Heap (fmdrop (cast shadow_root_ptr) (the_heap h));\n     shadow_root_ptr |\\<in>|\n     shadow_root_ptr_kinds\n      (Heap (fmdrop (cast shadow_root_ptr) (the_heap h)))\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis comp_apply fmdom_notI fmdrop_lookup heap.sel object_ptr_kinds_def shadow_root_ptr_kinds_commutes)"], ["", "lemma delete_shadow_root_pointers:\n  assumes \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\"\n  shows \"object_ptr_kinds h = object_ptr_kinds h' |\\<union>| {|cast shadow_root_ptr|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h =\n    object_ptr_kinds h' |\\<union>| {|cast shadow_root_ptr|}", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> delete_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h =\n    object_ptr_kinds h' |\\<union>| {|cast shadow_root_ptr|}", "apply(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def split: option.splits)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n                 shadow_root_ptr h =\n                Some h';\n        x |\\<in>| object_ptr_kinds h;\n        x |\\<notin>| object_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> x = cast shadow_root_ptr\n 2. delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n     shadow_root_ptr h =\n    Some h' \\<Longrightarrow>\n    shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\n 3. \\<And>x.\n       \\<lbrakk>delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n                 shadow_root_ptr h =\n                Some h';\n        x |\\<in>| object_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| object_ptr_kinds h", "apply (metis (no_types, lifting) ObjectClass.a_type_wf_def ObjectClass.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def\n      delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_pointer_ptr_in_heap fmlookup_drop get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def heap.sel option.sel\n      shadow_root_ptr_kinds_commutes)"], ["proof (prove)\ngoal (2 subgoals):\n 1. delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n     shadow_root_ptr h =\n    Some h' \\<Longrightarrow>\n    shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\n 2. \\<And>x.\n       \\<lbrakk>delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n                 shadow_root_ptr h =\n                Some h';\n        x |\\<in>| object_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| object_ptr_kinds h", "using delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_pointer_ptr_in_heap"], ["proof (prove)\nusing this:\n  delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   ?ptr ?h =\n  Some ?h' \\<Longrightarrow>\n  ?ptr |\\<in>| shadow_root_ptr_kinds ?h\n\ngoal (2 subgoals):\n 1. delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n     shadow_root_ptr h =\n    Some h' \\<Longrightarrow>\n    shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\n 2. \\<And>x.\n       \\<lbrakk>delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n                 shadow_root_ptr h =\n                Some h';\n        x |\\<in>| object_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| object_ptr_kinds h", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n                 shadow_root_ptr h =\n                Some h';\n        x |\\<in>| object_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| object_ptr_kinds h", "by (metis (no_types, lifting) ObjectClass.a_type_wf_def ObjectClass.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def\n      delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_pointer_ptr_in_heap fmlookup_drop get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def heap.sel option.sel\n      shadow_root_ptr_kinds_commutes)"], ["", "lemma delete_shadow_root_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t: \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\nptr \\<noteq> cast shadow_root_ptr \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> delete_M shadow_root_ptr\n             \\<rightarrow>\\<^sub>h h';\n     ptr \\<noteq> cast shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def ObjectMonad.get_M_defs preserved_def\n      split: prod.splits option.splits if_splits elim!: bind_returns_heap_E)"], ["", "lemma delete_shadow_root_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e: \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> delete_M shadow_root_ptr\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M ptr getter) h h'", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def NodeMonad.get_M_defs ObjectMonad.get_M_defs\n      preserved_def split: prod.splits option.splits if_splits elim!: bind_returns_heap_E)"], ["", "lemma delete_shadow_root_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> delete_M shadow_root_ptr\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M ptr getter) h h'", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def ElementMonad.get_M_defs NodeMonad.get_M_defs\n      ObjectMonad.get_M_defs preserved_def split: prod.splits option.splits if_splits elim!: bind_returns_heap_E)"], ["", "lemma delete_shadow_root_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a: \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> delete_M shadow_root_ptr\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M ptr getter) h h'", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def CharacterDataMonad.get_M_defs\n      NodeMonad.get_M_defs ObjectMonad.get_M_defs preserved_def split: prod.splits option.splits if_splits\n      elim!: bind_returns_heap_E)"], ["", "lemma delete_shadow_root_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> delete_M shadow_root_ptr\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M ptr getter) h h'", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def DocumentMonad.get_M_defs ObjectMonad.get_M_defs\n      preserved_def split: prod.splits option.splits if_splits elim!: bind_returns_heap_E)"], ["", "lemma delete_shadow_root_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t: \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\nshadow_root_ptr \\<noteq> shadow_root_ptr' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> delete_M shadow_root_ptr\n             \\<rightarrow>\\<^sub>h h';\n     shadow_root_ptr \\<noteq> shadow_root_ptr'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr' getter) h h'", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def get_M_defs ObjectMonad.get_M_defs\n      preserved_def split: prod.splits option.splits if_splits elim!: bind_returns_heap_E)"], ["", "lemma shadow_root_put_get_1 [simp]: \"shadow_root_ptr \\<noteq> shadow_root_ptr' \\<Longrightarrow>\nh \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>shadow_root_ptr \\<noteq> shadow_root_ptr';\n     h \\<turnstile> put_M shadow_root_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr' getter) h h'", "by(auto simp add: put_M_defs get_M_defs preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma shadow_root_put_get_2 [simp]: \"(\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x) \\<Longrightarrow>\nh \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x;\n     h \\<turnstile> put_M shadow_root_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr' getter) h h'", "by (cases \"shadow_root_ptr = shadow_root_ptr'\") (auto simp add: put_M_defs get_M_defs preserved_def\n      split: option.splits dest: get_heap_E)"], ["", "lemma shadow_root_put_get_3 [simp]: \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M shadow_root_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M element_ptr getter) h h'", "by(auto simp add: put_M_defs ElementMonad.get_M_defs preserved_def split: option.splits\n      dest: get_heap_E)"], ["", "lemma shadow_root_put_get_4 [simp]: \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M shadow_root_ptr getter) h h'", "by(auto simp add: ElementMonad.put_M_defs get_M_defs preserved_def split: option.splits\n      dest: get_heap_E)"], ["", "lemma shadow_root_put_get_5 [simp]: \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M shadow_root_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M character_data_ptr getter) h h'", "by(auto simp add: put_M_defs CharacterDataMonad.get_M_defs preserved_def split: option.splits\n      dest: get_heap_E)"], ["", "lemma shadow_root_put_get_6 [simp]: \"h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M character_data_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M shadow_root_ptr getter) h h'", "by(auto simp add: CharacterDataMonad.put_M_defs get_M_defs preserved_def split: option.splits\n      dest: get_heap_E)"], ["", "lemma shadow_root_put_get_7 [simp]: \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M shadow_root_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M document_ptr getter) h h'", "by(auto simp add: put_M_defs DocumentMonad.get_M_defs preserved_def split: option.splits\n      dest: get_heap_E)"], ["", "lemma shadow_root_put_get_8 [simp]: \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\npreserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M document_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M shadow_root_ptr getter) h h'", "by(auto simp add: DocumentMonad.put_M_defs get_M_defs preserved_def split: option.splits\n      dest: get_heap_E)"], ["", "lemma shadow_root_put_get_9 [simp]: \"(\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \\<Longrightarrow>\nh \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     h \\<turnstile> put_M shadow_root_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by (cases \"cast shadow_root_ptr = object_ptr\") (auto simp add: put_M_defs get_M_defs\n      ObjectMonad.get_M_defs NodeMonad.get_M_defs get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def preserved_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def\n      put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def bind_eq_Some_conv split: option.splits)"], ["", "subsection \\<open>new\\_M\\<close>"], ["", "definition new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M :: \"(_, (_) shadow_root_ptr) dom_prog\"\n  where\n    \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M = do {\n      h \\<leftarrow> get_heap;\n      (new_ptr, h') \\<leftarrow> return (new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h);\n      return_heap h';\n      return new_ptr\n    }\""], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ok [simp]:\n  \"h \\<turnstile> ok new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def split: prod.splits)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ptr_in_heap:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"new_shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'", "unfolding new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def"], ["proof (prove)\nusing this:\n  h \\<turnstile> get_heap \\<bind>\n                 (\\<lambda>h.\n                     return\n                      (new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n                        h) \\<bind>\n                     (\\<lambda>(new_ptr, h').\n                         return_heap h' \\<bind>\n                         (\\<lambda>_. return new_ptr)))\n  \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> get_heap \\<bind>\n                 (\\<lambda>h.\n                     return\n                      (new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n                        h) \\<bind>\n                     (\\<lambda>(new_ptr, h').\n                         return_heap h' \\<bind>\n                         (\\<lambda>_. return new_ptr)))\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_in_heap is_OK_returns_result_I\n      elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ptr_not_in_heap:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"new_shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h", "using assms new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_not_in_heap"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n  new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   ?h =\n  (?new_shadow_root_ptr, ?h') \\<Longrightarrow>\n  ?new_shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds ?h\n\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def split: prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_new_ptr:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_shadow_root_ptr|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast new_shadow_root_ptr|}", "using assms new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_new_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n  new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   ?h =\n  (?new_shadow_root_ptr, ?h') \\<Longrightarrow>\n  object_ptr_kinds ?h' =\n  object_ptr_kinds ?h |\\<union>| {|cast ?new_shadow_root_ptr|}\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast new_shadow_root_ptr|}", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def split: prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_is_shadow_root_ptr:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"is_shadow_root_ptr new_shadow_root_ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_shadow_root_ptr new_shadow_root_ptr", "using assms new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_is_shadow_root_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n  new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   ?h =\n  (?new_shadow_root_ptr, ?h') \\<Longrightarrow>\n  is_shadow_root_ptr ?new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. is_shadow_root_ptr new_shadow_root_ptr", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def elim!: bind_returns_result_E split: prod.splits)"], ["", "lemma new_shadow_root_mode:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"h' \\<turnstile> get_M new_shadow_root_ptr mode \\<rightarrow>\\<^sub>r Open\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_shadow_root_ptr mode\n    \\<rightarrow>\\<^sub>r Open", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_shadow_root_ptr mode\n    \\<rightarrow>\\<^sub>r Open", "by(auto simp add: get_M_defs new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def\n      split: option.splits prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_shadow_root_children:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"h' \\<turnstile> get_M new_shadow_root_ptr child_nodes \\<rightarrow>\\<^sub>r []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_shadow_root_ptr RShadowRoot.child_nodes\n    \\<rightarrow>\\<^sub>r []", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_shadow_root_ptr RShadowRoot.child_nodes\n    \\<rightarrow>\\<^sub>r []", "by(auto simp add: get_M_defs new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def\n      split: option.splits prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_shadow_root_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n    \\<Longrightarrow> ptr \\<noteq> cast new_shadow_root_ptr \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n             \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n     \\<rightarrow>\\<^sub>r new_shadow_root_ptr;\n     ptr \\<noteq> cast new_shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def ObjectMonad.get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_shadow_root_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n    \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n             \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n     \\<rightarrow>\\<^sub>r new_shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def NodeMonad.get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_shadow_root_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n     \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n             \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n     \\<rightarrow>\\<^sub>r new_shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def ElementMonad.get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_shadow_root_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n    \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n             \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n     \\<rightarrow>\\<^sub>r new_shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def CharacterDataMonad.get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_shadow_root_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\n     \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n     \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n             \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n     \\<rightarrow>\\<^sub>r new_shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def DocumentMonad.get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_shadow_root_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\n     \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr \\<Longrightarrow> ptr \\<noteq> new_shadow_root_ptr\n     \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n             \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n     \\<rightarrow>\\<^sub>r new_shadow_root_ptr;\n     ptr \\<noteq> new_shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "subsection \\<open>modified heaps\\<close>"], ["", "lemma shadow_root_get_put_1 [simp]: \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) = (if ptr = cast shadow_root_ptr\nthen cast obj else get shadow_root_ptr h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get shadow_root_ptr (put ptr obj h) =\n    (if ptr = cast shadow_root_ptr then cast obj else get shadow_root_ptr h)", "by(auto simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def split: option.splits Option.bind_splits)"], ["", "lemma shadow_root_ptr_kinds_new[simp]: \"shadow_root_ptr_kinds (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) = shadow_root_ptr_kinds h |\\<union>|\n(if is_shadow_root_ptr_kind ptr then {|the (cast ptr)|} else {||})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds (put ptr obj h) =\n    shadow_root_ptr_kinds h |\\<union>|\n    (if is_shadow_root_ptr_kind ptr then {|the (cast ptr)|} else {||})", "by(auto simp add: shadow_root_ptr_kinds_def split: option.splits)"], ["", "lemma type_wf_put_I:\n  assumes \"type_wf h\"\n  assumes \"DocumentClass.type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"is_shadow_root_ptr_kind ptr \\<Longrightarrow> is_shadow_root_kind obj\"\n  shows \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf (put ptr obj h)", "using assms"], ["proof (prove)\nusing this:\n  ShadowRootClass.type_wf h\n  DocumentClass.type_wf (put ptr obj h)\n  is_shadow_root_ptr_kind ptr \\<Longrightarrow> is_shadow_root_kind obj\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf (put ptr obj h)", "by(auto simp add: type_wf_defs is_shadow_root_kind_def split: option.splits)"], ["", "lemma type_wf_put_ptr_not_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<notin>| object_ptr_kinds h\"\n  shows \"type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "using assms"], ["proof (prove)\nusing this:\n  ShadowRootClass.type_wf (put ptr obj h)\n  ptr |\\<notin>| object_ptr_kinds h\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "by(auto simp add: type_wf_defs elim!: DocumentMonad.type_wf_put_ptr_not_in_heap_E\n      split: option.splits if_splits)"], ["", "lemma type_wf_put_ptr_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<in>| object_ptr_kinds h\"\n  assumes \"DocumentClass.type_wf h\"\n  assumes \"is_shadow_root_ptr_kind ptr \\<Longrightarrow> is_shadow_root_kind (the (get ptr h))\"\n  shows \"type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "using assms"], ["proof (prove)\nusing this:\n  ShadowRootClass.type_wf (put ptr obj h)\n  ptr |\\<in>| object_ptr_kinds h\n  DocumentClass.type_wf h\n  is_shadow_root_ptr_kind ptr \\<Longrightarrow>\n  is_shadow_root_kind (the (get ptr h))\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "apply(auto simp add: type_wf_defs elim!: DocumentMonad.type_wf_put_ptr_in_heap_E\n      split: option.splits if_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y shadow_root_ptr.\n       \\<lbrakk>ptr |\\<in>| object_ptr_kinds h; DocumentClass.type_wf h;\n        is_shadow_root_kind (the (get ptr h)); is_shadow_root_ptr_kind ptr;\n        DocumentClass.type_wf (put ptr (cast y) h);\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h).\n           ptr = cast shadow_root_ptr \\<or>\n           (\\<exists>y. get shadow_root_ptr h = Some y);\n        obj = cast y;\n        shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get shadow_root_ptr h = Some y", "by (metis (no_types, hide_lams) ObjectClass.a_type_wf_def ObjectClass.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf\n      bind.bind_lunit finite_set_in get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def is_shadow_root_kind_def option.exhaust_sel)"], ["", "subsection \\<open>type\\_wf\\<close>"], ["", "lemma new_element_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "obtain new_element_ptr where \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>new_element_ptr.\n        h \\<turnstile> new_element\n        \\<rightarrow>\\<^sub>r new_element_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. (\\<And>new_element_ptr.\n        h \\<turnstile> new_element\n        \\<rightarrow>\\<^sub>r new_element_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson is_OK_returns_heap_I is_OK_returns_result_E)"], ["proof (state)\nthis:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr", "have \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_element_ptr|}\""], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_element_ptr)|}", "using new_element_new_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\n  \\<lbrakk>?h \\<turnstile> new_element \\<rightarrow>\\<^sub>h ?h';\n   ?h \\<turnstile> new_element\n   \\<rightarrow>\\<^sub>r ?new_element_ptr\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h' =\n                    object_ptr_kinds ?h |\\<union>|\n                    {|cast (cast ?new_element_ptr)|}\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_element_ptr)|}", "by auto"], ["proof (state)\nthis:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast (cast new_element_ptr)|}\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast (cast new_element_ptr)|}", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast (cast new_element_ptr)|}\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "unfolding shadow_root_ptr_kinds_def"], ["proof (prove)\nusing this:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast (cast new_element_ptr)|}\n\ngoal (1 subgoal):\n 1. the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h) =\n    the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h')", "by auto"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: ElementMonad.new_element_def type_wf_defs Let_def elim!: bind_returns_heap_E\n        split: prod.splits)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_tag_name_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M element_ptr tag_name_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "have \"object_ptr_kinds h = object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "using writes_singleton assms object_ptr_kinds_preserved"], ["proof (prove)\nusing this:\n  writes (all_args ?f) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M element_ptr tag_name_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "unfolding all_args_def"], ["proof (prove)\nusing this:\n  writes (\\<Union>arg. {?f arg}) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M element_ptr tag_name_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "by fastforce"], ["proof (state)\nthis:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h = object_ptr_kinds h'", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "unfolding shadow_root_ptr_kinds_def"], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h) =\n    the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h')", "by simp"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> put_M element_ptr tag_name_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> put_M element_ptr tag_name_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: ElementMonad.put_M_defs type_wf_defs)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_child_nodes_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M element_ptr RElement.child_nodes_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "have \"object_ptr_kinds h = object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "using writes_singleton assms object_ptr_kinds_preserved"], ["proof (prove)\nusing this:\n  writes (all_args ?f) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M element_ptr RElement.child_nodes_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "unfolding all_args_def"], ["proof (prove)\nusing this:\n  writes (\\<Union>arg. {?f arg}) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M element_ptr RElement.child_nodes_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "by fastforce"], ["proof (state)\nthis:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h = object_ptr_kinds h'", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "unfolding shadow_root_ptr_kinds_def"], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h) =\n    the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h')", "by simp"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> put_M element_ptr RElement.child_nodes_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> put_M element_ptr RElement.child_nodes_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: ElementMonad.put_M_defs type_wf_defs)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_attrs_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "have \"object_ptr_kinds h = object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "using writes_singleton assms object_ptr_kinds_preserved"], ["proof (prove)\nusing this:\n  writes (all_args ?f) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "unfolding all_args_def"], ["proof (prove)\nusing this:\n  writes (\\<Union>arg. {?f arg}) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "by fastforce"], ["proof (state)\nthis:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h = object_ptr_kinds h'", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "unfolding shadow_root_ptr_kinds_def"], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h) =\n    the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h')", "by simp"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: ElementMonad.put_M_defs type_wf_defs)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_shadow_root_opt_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M element_ptr shadow_root_opt_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "have \"object_ptr_kinds h = object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "using writes_singleton assms object_ptr_kinds_preserved"], ["proof (prove)\nusing this:\n  writes (all_args ?f) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M element_ptr shadow_root_opt_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "unfolding all_args_def"], ["proof (prove)\nusing this:\n  writes (\\<Union>arg. {?f arg}) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M element_ptr shadow_root_opt_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "by fastforce"], ["proof (state)\nthis:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h = object_ptr_kinds h'", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "unfolding shadow_root_ptr_kinds_def"], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h) =\n    the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h')", "by simp"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> put_M element_ptr shadow_root_opt_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> put_M element_ptr shadow_root_opt_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: ElementMonad.put_M_defs type_wf_defs)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma new_character_data_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "obtain new_character_data_ptr where \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>new_character_data_ptr.\n        h \\<turnstile> new_character_data\n        \\<rightarrow>\\<^sub>r new_character_data_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. (\\<And>new_character_data_ptr.\n        h \\<turnstile> new_character_data\n        \\<rightarrow>\\<^sub>r new_character_data_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson is_OK_returns_heap_I is_OK_returns_result_E)"], ["proof (state)\nthis:\n  h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>r new_character_data_ptr\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>r new_character_data_ptr", "have \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_character_data_ptr|}\""], ["proof (prove)\nusing this:\n  h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>r new_character_data_ptr\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_character_data_ptr)|}", "using new_character_data_new_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>r new_character_data_ptr\n  \\<lbrakk>?h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h ?h';\n   ?h \\<turnstile> new_character_data\n   \\<rightarrow>\\<^sub>r ?new_character_data_ptr\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h' =\n                    object_ptr_kinds ?h |\\<union>|\n                    {|cast (cast ?new_character_data_ptr)|}\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_character_data_ptr)|}", "by auto"], ["proof (state)\nthis:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast (cast new_character_data_ptr)|}\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast (cast new_character_data_ptr)|}", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast (cast new_character_data_ptr)|}\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "unfolding shadow_root_ptr_kinds_def"], ["proof (prove)\nusing this:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast (cast new_character_data_ptr)|}\n\ngoal (1 subgoal):\n 1. the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h) =\n    the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h')", "by auto"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: CharacterDataMonad.new_character_data_def type_wf_defs Let_def\n        elim!: bind_returns_heap_E split: prod.splits)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_val_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M character_data_ptr val_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "have \"object_ptr_kinds h = object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "using writes_singleton assms object_ptr_kinds_preserved"], ["proof (prove)\nusing this:\n  writes (all_args ?f) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M character_data_ptr val_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "unfolding all_args_def"], ["proof (prove)\nusing this:\n  writes (\\<Union>arg. {?f arg}) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M character_data_ptr val_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "by fastforce"], ["proof (state)\nthis:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h = object_ptr_kinds h'", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "unfolding shadow_root_ptr_kinds_def"], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h) =\n    the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h')", "by simp"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> put_M character_data_ptr val_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> put_M character_data_ptr val_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: CharacterDataMonad.put_M_defs type_wf_defs)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma new_document_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "obtain new_document_ptr where \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>new_document_ptr.\n        h \\<turnstile> new_document\n        \\<rightarrow>\\<^sub>r new_document_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. (\\<And>new_document_ptr.\n        h \\<turnstile> new_document\n        \\<rightarrow>\\<^sub>r new_document_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson is_OK_returns_heap_I is_OK_returns_result_E)"], ["proof (state)\nthis:\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr", "have \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_document_ptr|}\""], ["proof (prove)\nusing this:\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast new_document_ptr|}", "using new_document_new_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\n  \\<lbrakk>?h \\<turnstile> new_document \\<rightarrow>\\<^sub>h ?h';\n   ?h \\<turnstile> new_document\n   \\<rightarrow>\\<^sub>r ?new_document_ptr\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h' =\n                    object_ptr_kinds ?h |\\<union>|\n                    {|cast ?new_document_ptr|}\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast new_document_ptr|}", "by auto"], ["proof (state)\nthis:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast new_document_ptr|}\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast new_document_ptr|}", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast new_document_ptr|}\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "unfolding shadow_root_ptr_kinds_def"], ["proof (prove)\nusing this:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast new_document_ptr|}\n\ngoal (1 subgoal):\n 1. the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h) =\n    the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h')", "by auto"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: DocumentMonad.new_document_def type_wf_defs Let_def elim!: bind_returns_heap_E\n        split: prod.splits)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_doctype_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M document_ptr doctype_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "have \"object_ptr_kinds h = object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "using writes_singleton assms object_ptr_kinds_preserved"], ["proof (prove)\nusing this:\n  writes (all_args ?f) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M document_ptr doctype_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "unfolding all_args_def"], ["proof (prove)\nusing this:\n  writes (\\<Union>arg. {?f arg}) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M document_ptr doctype_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "by fastforce"], ["proof (state)\nthis:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h = object_ptr_kinds h'", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "unfolding shadow_root_ptr_kinds_def"], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h) =\n    the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h')", "by simp"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> put_M document_ptr doctype_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> put_M document_ptr doctype_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: DocumentMonad.put_M_defs type_wf_defs)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_document_element_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M document_ptr document_element_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "have \"object_ptr_kinds h = object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "using writes_singleton assms object_ptr_kinds_preserved"], ["proof (prove)\nusing this:\n  writes (all_args ?f) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M document_ptr document_element_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "unfolding all_args_def"], ["proof (prove)\nusing this:\n  writes (\\<Union>arg. {?f arg}) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M document_ptr document_element_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "by fastforce"], ["proof (state)\nthis:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h = object_ptr_kinds h'", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "unfolding shadow_root_ptr_kinds_def"], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h) =\n    the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h')", "by simp"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> put_M document_ptr document_element_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> put_M document_ptr document_element_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: DocumentMonad.put_M_defs type_wf_defs)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_disconnected_nodes_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M document_ptr disconnected_nodes_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "have \"object_ptr_kinds h = object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "using writes_singleton assms object_ptr_kinds_preserved"], ["proof (prove)\nusing this:\n  writes (all_args ?f) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M document_ptr disconnected_nodes_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "unfolding all_args_def"], ["proof (prove)\nusing this:\n  writes (\\<Union>arg. {?f arg}) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M document_ptr disconnected_nodes_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "by fastforce"], ["proof (state)\nthis:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h = object_ptr_kinds h'", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "unfolding shadow_root_ptr_kinds_def"], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h) =\n    the |`| cast |`| ffilter is_shadow_root_ptr_kind (object_ptr_kinds h')", "by simp"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> put_M document_ptr disconnected_nodes_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> put_M document_ptr disconnected_nodes_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: DocumentMonad.put_M_defs type_wf_defs)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_mode_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M shadow_root_ptr mode_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M shadow_root_ptr mode_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: get_M_defs is_shadow_root_kind_def type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs DocumentClass.type_wf_defs put_M_defs\n      put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def\n      dest!: get_heap_E\n      elim!: bind_returns_heap_E2\n      intro!: type_wf_put_I DocumentMonad.type_wf_put_I CharacterDataMonad.type_wf_put_I\n      ElementMonad.type_wf_put_I NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I\n      split: option.splits)"], ["", "lemma put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_child_nodes_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M shadow_root_ptr RShadowRoot.child_nodes_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M shadow_root_ptr RShadowRoot.child_nodes_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: get_M_defs is_shadow_root_kind_def type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs DocumentClass.type_wf_defs put_M_defs\n      put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def\n      dest!: get_heap_E\n      elim!: bind_returns_heap_E2\n      intro!: type_wf_put_I DocumentMonad.type_wf_put_I CharacterDataMonad.type_wf_put_I\n      ElementMonad.type_wf_put_I NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I\n      split: option.splits)"], ["", "lemma shadow_root_ptr_kinds_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  shows \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "by(simp add: shadow_root_ptr_kinds_def preserved_def object_ptr_kinds_preserved_small[OF assms])"], ["", "lemma shadow_root_ptr_kinds_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n(\\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h')\"\n  shows \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "using writes_small_big[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>reflp\n            (\\<lambda>h h'.\n                \\<forall>w\\<in>SW.\n                   ?h4 h h' \\<turnstile> w\n                   \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n                   (\\<forall>object_ptr.\n                       preserved (get_M object_ptr RObject.nothing)\n                        (?h4 h h') (?h'5 h h')));\n   transp\n    (\\<lambda>h h'.\n        \\<forall>w\\<in>SW.\n           ?h4 h h' \\<turnstile> w\n           \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n           (\\<forall>object_ptr.\n               preserved (get_M object_ptr RObject.nothing) (?h4 h h')\n                (?h'5 h h')))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>w\\<in>SW.\n                       ?h4 h h' \\<turnstile> w\n                       \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n                       (\\<forall>object_ptr.\n                           preserved (get_M object_ptr RObject.nothing)\n                            (?h4 h h') (?h'5 h h'))\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "apply(simp add: reflp_def transp_def preserved_def shadow_root_ptr_kinds_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ha h'a.\n        \\<lbrakk>\\<forall>x.\n                    (\\<exists>w\\<in>SW.\n                        ha x x \\<turnstile> w\n                        \\<rightarrow>\\<^sub>h h'a x x) \\<longrightarrow>\n                    (\\<forall>object_ptr.\n                        ha x x \\<turnstile> get_M object_ptr RObject.nothing\n                        \\<rightarrow>\\<^sub>r () =\n                        h'a x x\n                        \\<turnstile> get_M object_ptr RObject.nothing\n                        \\<rightarrow>\\<^sub>r ());\n         \\<forall>x y.\n            ((\\<exists>w\\<in>SW.\n                 ha x y \\<turnstile> w\n                 \\<rightarrow>\\<^sub>h h'a x y) \\<longrightarrow>\n             (\\<forall>object_ptr.\n                 ha x y \\<turnstile> get_M object_ptr RObject.nothing\n                 \\<rightarrow>\\<^sub>r () =\n                 h'a x y \\<turnstile> get_M object_ptr RObject.nothing\n                 \\<rightarrow>\\<^sub>r ())) \\<longrightarrow>\n            (\\<forall>z.\n                ((\\<exists>w\\<in>SW.\n                     ha y z \\<turnstile> w\n                     \\<rightarrow>\\<^sub>h h'a y z) \\<longrightarrow>\n                 (\\<forall>object_ptr.\n                     ha y z \\<turnstile> get_M object_ptr RObject.nothing\n                     \\<rightarrow>\\<^sub>r () =\n                     h'a y z \\<turnstile> get_M object_ptr RObject.nothing\n                     \\<rightarrow>\\<^sub>r ())) \\<longrightarrow>\n                (\\<exists>w\\<in>SW.\n                    ha x z \\<turnstile> w\n                    \\<rightarrow>\\<^sub>h h'a x z) \\<longrightarrow>\n                (\\<forall>object_ptr.\n                    ha x z \\<turnstile> get_M object_ptr RObject.nothing\n                    \\<rightarrow>\\<^sub>r () =\n                    h'a x z \\<turnstile> get_M object_ptr RObject.nothing\n                    \\<rightarrow>\\<^sub>r ()))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>w\\<in>SW.\n                              ha h h' \\<turnstile> w\n                              \\<rightarrow>\\<^sub>h h'a h\n               h') \\<longrightarrow>\n                          (\\<forall>object_ptr.\n                              ha h h'\n                              \\<turnstile> get_M object_ptr RObject.nothing\n                              \\<rightarrow>\\<^sub>r () =\n                              h'a h h'\n                              \\<turnstile> get_M object_ptr RObject.nothing\n                              \\<rightarrow>\\<^sub>r ())) \\<Longrightarrow>\n    (the \\<circ> cast) |`|\n    ffilter is_shadow_root_ptr_kind (object_ptr_kinds h) =\n    (the \\<circ> cast) |`|\n    ffilter is_shadow_root_ptr_kind (object_ptr_kinds h')", "by (metis assms object_ptr_kinds_preserved)"], ["", "lemma new_shadow_root_known_ptr:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"known_ptr (cast new_shadow_root_ptr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.known_ptr (cast new_shadow_root_ptr)", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. ShadowRootClass.known_ptr (cast new_shadow_root_ptr)", "apply(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def a_known_ptr_def\n      elim!: bind_returns_result_E2 split: prod.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_shadow_root_ptr new_shadow_root_ptr;\n     \\<not> DocumentClass.known_ptr (cast new_shadow_root_ptr)\\<rbrakk>\n    \\<Longrightarrow> pure\n                       (return_heap\n                         (put (shadow_root_ptr.Ref\n                                (Suc (fMax\n (shadow_root_ptr.the_ref |`| shadow_root_ptrs h))))\n                           (create_shadow_root_obj Open []) h))\n                       h", "using assms new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_is_shadow_root_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n  ?h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r ?new_shadow_root_ptr \\<Longrightarrow>\n  is_shadow_root_ptr ?new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_shadow_root_ptr new_shadow_root_ptr;\n     \\<not> DocumentClass.known_ptr (cast new_shadow_root_ptr)\\<rbrakk>\n    \\<Longrightarrow> pure\n                       (return_heap\n                         (put (shadow_root_ptr.Ref\n                                (Suc (fMax\n (shadow_root_ptr.the_ref |`| shadow_root_ptrs h))))\n                           (create_shadow_root_obj Open []) h))\n                       h", "by blast"], ["", "lemma new_shadow_root_type_wf_preserved [simp]: \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "apply(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def\n      ShadowRootClass.type_wf\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ShadowRootClass.type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a  ShadowRootClass.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n      ShadowRootClass.type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ShadowRootClass.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n      is_node_ptr_kind_none new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_not_in_heap\n      elim!: bind_returns_heap_E type_wf_put_ptr_not_in_heap_E\n      intro!: type_wf_put_I DocumentMonad.type_wf_put_I ElementMonad.type_wf_put_I\n      CharacterDataMonad.type_wf_put_I\n      NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I\n      split: if_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h' =\n             put (cast\n                   (shadow_root_ptr.Ref\n                     (Suc (fMax\n                            (shadow_root_ptr.the_ref |`|\n                             shadow_root_ptrs h)))))\n              (cast (create_shadow_root_obj Open [])) h;\n     ShadowRootClass.type_wf h\\<rbrakk>\n    \\<Longrightarrow> is_shadow_root_kind\n                       (cast (create_shadow_root_obj Open []))", "by(auto simp add: type_wf_defs DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      CharacterDataClass.type_wf_defs\n      NodeClass.type_wf_defs ObjectClass.type_wf_defs is_shadow_root_kind_def is_document_kind_def\n      split: option.splits)[1]"], ["", "locale l_new_shadow_root = l_type_wf +\n  assumes new_shadow_root_types_preserved: \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["", "lemma new_shadow_root_is_l_new_shadow_root  [instances]: \"l_new_shadow_root type_wf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_new_shadow_root ShadowRootClass.type_wf", "using l_new_shadow_root.intro new_shadow_root_type_wf_preserved"], ["proof (prove)\nusing this:\n  (\\<And>h h'.\n      h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n      \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n      ?type_wf h = ?type_wf h') \\<Longrightarrow>\n  l_new_shadow_root ?type_wf\n  ?h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>h ?h' \\<Longrightarrow>\n  ShadowRootClass.type_wf ?h = ShadowRootClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. l_new_shadow_root ShadowRootClass.type_wf", "by blast"], ["", "lemma type_wf_preserved_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  assumes \"\\<And>character_data_ptr. preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr RCharacterData.nothing) h h'\"\n  assumes \"\\<And>document_ptr. preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr RDocument.nothing) h h'\"\n  assumes \"\\<And>shadow_root_ptr. preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr RShadowRoot.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "using type_wf_preserved_small[OF assms(1) assms(2) assms(3) assms(4) assms(5)]\n    allI[OF assms(6), of id, simplified] shadow_root_ptr_kinds_small[OF assms(1)]"], ["proof (prove)\nusing this:\n  DocumentClass.type_wf h = DocumentClass.type_wf h'\n  \\<forall>x. preserved (get_M x RShadowRoot.nothing) h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "apply(auto simp add: type_wf_defs preserved_def get_M_defs shadow_root_ptr_kinds_small[OF assms(1)]\n      split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>shadow_root_ptr.\n       \\<lbrakk>\\<forall>x.\n                   ((\\<exists>y. get x h = Some y) \\<or>\n                    get x h' = None) \\<and>\n                   (get x h = None \\<or> (\\<exists>y. get x h' = Some y));\n        DocumentClass.type_wf h; DocumentClass.type_wf h';\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h').\n           \\<exists>y. get shadow_root_ptr h = Some y;\n        shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get shadow_root_ptr h' = Some y\n 2. \\<And>shadow_root_ptr.\n       \\<lbrakk>\\<forall>x.\n                   ((\\<exists>y. get x h = Some y) \\<or>\n                    get x h' = None) \\<and>\n                   (get x h = None \\<or> (\\<exists>y. get x h' = Some y));\n        DocumentClass.type_wf h; DocumentClass.type_wf h';\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h').\n           \\<exists>y. get shadow_root_ptr h' = Some y;\n        shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get shadow_root_ptr h = Some y", "apply(force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>shadow_root_ptr.\n       \\<lbrakk>\\<forall>x.\n                   ((\\<exists>y. get x h = Some y) \\<or>\n                    get x h' = None) \\<and>\n                   (get x h = None \\<or> (\\<exists>y. get x h' = Some y));\n        DocumentClass.type_wf h; DocumentClass.type_wf h';\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h').\n           \\<exists>y. get shadow_root_ptr h' = Some y;\n        shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get shadow_root_ptr h = Some y", "apply(force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma new_element_is_l_new_element [instances]:\n  \"l_new_element type_wf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_new_element ShadowRootClass.type_wf", "using l_new_element.intro new_element_type_wf_preserved"], ["proof (prove)\nusing this:\n  (\\<And>h h'.\n      h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n      ?type_wf h = ?type_wf h') \\<Longrightarrow>\n  l_new_element ?type_wf\n  ?h \\<turnstile> new_element \\<rightarrow>\\<^sub>h ?h' \\<Longrightarrow>\n  ShadowRootClass.type_wf ?h = ShadowRootClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. l_new_element ShadowRootClass.type_wf", "by blast"], ["", "lemma new_character_data_is_l_new_character_data [instances]:\n  \"l_new_character_data type_wf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_new_character_data ShadowRootClass.type_wf", "using l_new_character_data.intro new_character_data_type_wf_preserved"], ["proof (prove)\nusing this:\n  (\\<And>h h'.\n      h \\<turnstile> new_character_data\n      \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n      ?type_wf h = ?type_wf h') \\<Longrightarrow>\n  l_new_character_data ?type_wf\n  ?h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>h ?h' \\<Longrightarrow>\n  ShadowRootClass.type_wf ?h = ShadowRootClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. l_new_character_data ShadowRootClass.type_wf", "by blast"], ["", "lemma new_document_is_l_new_document [instances]:\n  \"l_new_document type_wf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_new_document ShadowRootClass.type_wf", "using l_new_document.intro new_document_type_wf_preserved"], ["proof (prove)\nusing this:\n  (\\<And>h h'.\n      h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n      ?type_wf h = ?type_wf h') \\<Longrightarrow>\n  l_new_document ?type_wf\n  ?h \\<turnstile> new_document \\<rightarrow>\\<^sub>h ?h' \\<Longrightarrow>\n  ShadowRootClass.type_wf ?h = ShadowRootClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. l_new_document ShadowRootClass.type_wf", "by blast"], ["", "lemma type_wf_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n\\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n\\<forall>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n\\<forall>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n\\<forall>character_data_ptr. preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr RCharacterData.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n\\<forall>document_ptr. preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr RDocument.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n\\<forall>shadow_root_ptr. preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr RShadowRoot.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "have \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h =\n                         ShadowRootClass.type_wf h'", "using assms type_wf_preserved_small"], ["proof (prove)\nusing this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>object_ptr.\n                       preserved (get_M object_ptr RObject.nothing) ?h ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>node_ptr.\n                       preserved (get_M node_ptr RNode.nothing) ?h ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>element_ptr.\n                       preserved (get_M element_ptr RElement.nothing) ?h ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>character_data_ptr.\n                       preserved\n                        (get_M character_data_ptr RCharacterData.nothing) ?h\n                        ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>document_ptr.\n                       preserved (get_M document_ptr RDocument.nothing) ?h\n                        ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>shadow_root_ptr.\n                       preserved (get_M shadow_root_ptr RShadowRoot.nothing)\n                        ?h ?h'\n  \\<lbrakk>\\<And>object_ptr.\n              preserved (get_M object_ptr RObject.nothing) ?h ?h';\n   \\<And>node_ptr. preserved (get_M node_ptr RNode.nothing) ?h ?h';\n   \\<And>element_ptr. preserved (get_M element_ptr RElement.nothing) ?h ?h';\n   \\<And>character_data_ptr.\n      preserved (get_M character_data_ptr RCharacterData.nothing) ?h ?h';\n   \\<And>document_ptr.\n      preserved (get_M document_ptr RDocument.nothing) ?h ?h';\n   \\<And>shadow_root_ptr.\n      preserved (get_M shadow_root_ptr RShadowRoot.nothing) ?h ?h'\\<rbrakk>\n  \\<Longrightarrow> ShadowRootClass.type_wf ?h = ShadowRootClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h =\n                         ShadowRootClass.type_wf h'", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> ShadowRootClass.type_wf ?h = ShadowRootClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms(1) assms(2)"], ["proof (chain)\npicking this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> ShadowRootClass.type_wf ?h = ShadowRootClass.type_wf ?h'", "show ?thesis"], ["proof (prove)\nusing this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> ShadowRootClass.type_wf ?h = ShadowRootClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "apply(rule writes_small_big)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> ?w1 h h' w \\<in> SW\n 2. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> ?w1 h h' w \\<rightarrow>\\<^sub>h h'\n 3. reflp\n     (\\<lambda>h h'. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h')\n 4. transp\n     (\\<lambda>h h'. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h')", "by(auto simp add: reflp_def transp_def)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma type_wf_drop: \"type_wf h \\<Longrightarrow> type_wf (Heap (fmdrop ptr (the_heap h)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h \\<Longrightarrow>\n    ShadowRootClass.type_wf (Heap (fmdrop ptr (the_heap h)))", "apply(auto simp add: type_wf_defs)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>DocumentClass.type_wf h;\n     \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h).\n        \\<exists>y. get shadow_root_ptr h = Some y\\<rbrakk>\n    \\<Longrightarrow> DocumentClass.type_wf (Heap (fmdrop ptr (the_heap h)))\n 2. \\<And>shadow_root_ptr.\n       \\<lbrakk>DocumentClass.type_wf h;\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h).\n           \\<exists>y. get shadow_root_ptr h = Some y;\n        shadow_root_ptr |\\<in>|\n        shadow_root_ptr_kinds (Heap (fmdrop ptr (the_heap h)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            get shadow_root_ptr\n                             (Heap (fmdrop ptr (the_heap h))) =\n                            Some y", "using type_wf_drop"], ["proof (prove)\nusing this:\n  DocumentClass.type_wf ?h \\<Longrightarrow>\n  DocumentClass.type_wf (Heap (fmdrop ?ptr (the_heap ?h)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>DocumentClass.type_wf h;\n     \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h).\n        \\<exists>y. get shadow_root_ptr h = Some y\\<rbrakk>\n    \\<Longrightarrow> DocumentClass.type_wf (Heap (fmdrop ptr (the_heap h)))\n 2. \\<And>shadow_root_ptr.\n       \\<lbrakk>DocumentClass.type_wf h;\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h).\n           \\<exists>y. get shadow_root_ptr h = Some y;\n        shadow_root_ptr |\\<in>|\n        shadow_root_ptr_kinds (Heap (fmdrop ptr (the_heap h)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            get shadow_root_ptr\n                             (Heap (fmdrop ptr (the_heap h))) =\n                            Some y", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>shadow_root_ptr.\n       \\<lbrakk>DocumentClass.type_wf h;\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h).\n           \\<exists>y. get shadow_root_ptr h = Some y;\n        shadow_root_ptr |\\<in>|\n        shadow_root_ptr_kinds (Heap (fmdrop ptr (the_heap h)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            get shadow_root_ptr\n                             (Heap (fmdrop ptr (the_heap h))) =\n                            Some y", "by (metis (no_types, lifting) DocumentClass.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ElementClass.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf\n      ElementMonad.type_wf_drop fmember.rep_eq fmlookup_drop get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def\n      object_ptr_kinds_code5 shadow_root_ptr_kinds_commutes)"], ["", "lemma delete_shadow_root_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\"\n  assumes \"type_wf h\"\n  shows \"type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h'", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> delete_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\n  ShadowRootClass.type_wf h\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h'", "using type_wf_drop"], ["proof (prove)\nusing this:\n  h \\<turnstile> delete_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\n  ShadowRootClass.type_wf h\n  ShadowRootClass.type_wf ?h \\<Longrightarrow>\n  ShadowRootClass.type_wf (Heap (fmdrop ?ptr (the_heap ?h)))\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h'", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def split: if_splits)"], ["", "end"]]}