{"file_name": "/home/qj213/afp-2021-10-22/thys/Shadow_DOM/tests/Shadow_DOM_Node_insertBefore.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Shadow_DOM", "problem_names": ["lemma \"test (do {\n  node \\<leftarrow> Node_insertBefore_document . createTextNode(''Foo'');\n  tmp0 \\<leftarrow> Node_insertBefore_document . createTextNode(''fail'');\n  assert_throws(HierarchyRequestError, node . insertBefore(tmp0, None))\n}) Node_insertBefore_heap\"", "lemma \"test (do {\n  tmp1 \\<leftarrow> Node_insertBefore_document . body;\n  tmp2 \\<leftarrow> Node_insertBefore_document . getElementById(''log'');\n  tmp0 \\<leftarrow> Node_insertBefore_document . body;\n  assert_throws(HierarchyRequestError, tmp0 . insertBefore(tmp1, tmp2));\n  tmp4 \\<leftarrow> Node_insertBefore_document . documentElement;\n  tmp5 \\<leftarrow> Node_insertBefore_document . getElementById(''log'');\n  tmp3 \\<leftarrow> Node_insertBefore_document . body;\n  assert_throws(HierarchyRequestError, tmp3 . insertBefore(tmp4, tmp5))\n}) Node_insertBefore_heap\"", "lemma \"test (do {\n  a \\<leftarrow> Node_insertBefore_document . createElement(''div'');\n  b \\<leftarrow> Node_insertBefore_document . createElement(''div'');\n  c \\<leftarrow> Node_insertBefore_document . createElement(''div'');\n  assert_throws(NotFoundError, a . insertBefore(b, c))\n}) Node_insertBefore_heap\"", "lemma \"test (do {\n  doc \\<leftarrow> createDocument(''title'');\n  doc2 \\<leftarrow> createDocument(''title2'');\n  tmp0 \\<leftarrow> doc . documentElement;\n  assert_throws(HierarchyRequestError, doc . insertBefore(doc2, tmp0));\n  tmp1 \\<leftarrow> doc . createTextNode(''text'');\n  tmp2 \\<leftarrow> doc . documentElement;\n  assert_throws(HierarchyRequestError, doc . insertBefore(tmp1, tmp2))\n}) Node_insertBefore_heap\"", "lemma \"test (do {\n  a \\<leftarrow> Node_insertBefore_document . createElement(''div'');\n  b \\<leftarrow> Node_insertBefore_document . createElement(''div'');\n  c \\<leftarrow> Node_insertBefore_document . createElement(''div'');\n  a . appendChild(b);\n  a . appendChild(c);\n  tmp0 \\<leftarrow> a . childNodes;\n  assert_array_equals(tmp0, [b, c]);\n  tmp1 \\<leftarrow> a . insertBefore(b, b);\n  assert_equals(tmp1, b);\n  tmp2 \\<leftarrow> a . childNodes;\n  assert_array_equals(tmp2, [b, c]);\n  tmp3 \\<leftarrow> a . insertBefore(c, c);\n  assert_equals(tmp3, c);\n  tmp4 \\<leftarrow> a . childNodes;\n  assert_array_equals(tmp4, [b, c])\n}) Node_insertBefore_heap\""], "translations": [["", "lemma \"test (do {\n  node \\<leftarrow> Node_insertBefore_document . createTextNode(''Foo'');\n  tmp0 \\<leftarrow> Node_insertBefore_document . createTextNode(''fail'');\n  assert_throws(HierarchyRequestError, node . insertBefore(tmp0, None))\n}) Node_insertBefore_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test\n     (Heap_Error_Monad.bind\n       Node_insertBefore_document . createTextNode(''Foo'')\n       (\\<lambda>node.\n           Heap_Error_Monad.bind\n            Node_insertBefore_document . createTextNode(''fail'')\n            (\\<lambda>tmp0.\n                assert_throws(HierarchyRequestError, node . insertBefore(tmp0, None)))))\n     Node_insertBefore_heap", "by eval"], ["", "text \\<open>\"Calling insertBefore with an inclusive ancestor of the context object must throw HIERARCHY\\_REQUEST\\_ERR.\"\\<close>"], ["", "lemma \"test (do {\n  tmp1 \\<leftarrow> Node_insertBefore_document . body;\n  tmp2 \\<leftarrow> Node_insertBefore_document . getElementById(''log'');\n  tmp0 \\<leftarrow> Node_insertBefore_document . body;\n  assert_throws(HierarchyRequestError, tmp0 . insertBefore(tmp1, tmp2));\n  tmp4 \\<leftarrow> Node_insertBefore_document . documentElement;\n  tmp5 \\<leftarrow> Node_insertBefore_document . getElementById(''log'');\n  tmp3 \\<leftarrow> Node_insertBefore_document . body;\n  assert_throws(HierarchyRequestError, tmp3 . insertBefore(tmp4, tmp5))\n}) Node_insertBefore_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test\n     (Heap_Error_Monad.bind Node_insertBefore_document . body\n       (\\<lambda>tmp1.\n           Heap_Error_Monad.bind\n            Node_insertBefore_document . getElementById(''log'')\n            (\\<lambda>tmp2.\n                Heap_Error_Monad.bind Node_insertBefore_document . body\n                 (\\<lambda>tmp0.\n                     Heap_Error_Monad.bind\n                      assert_throws(HierarchyRequestError, tmp0 . insertBefore(tmp1, tmp2))\n                      (\\<lambda>_.\n                          Heap_Error_Monad.bind\n                           Node_insertBefore_document . documentElement\n                           (\\<lambda>tmp4.\n                               Heap_Error_Monad.bind\n                                Node_insertBefore_document . getElementById(''log'')\n                                (\\<lambda>tmp5.\n                                    Heap_Error_Monad.bind\n                                     Node_insertBefore_document . body\n                                     (\\<lambda>tmp3.\n   assert_throws(HierarchyRequestError, tmp3 . insertBefore(tmp4, tmp5))))))))))\n     Node_insertBefore_heap", "by eval"], ["", "text \\<open>\"Calling insertBefore with a reference child whose parent is not the context node must throw a NotFoundError.\"\\<close>"], ["", "lemma \"test (do {\n  a \\<leftarrow> Node_insertBefore_document . createElement(''div'');\n  b \\<leftarrow> Node_insertBefore_document . createElement(''div'');\n  c \\<leftarrow> Node_insertBefore_document . createElement(''div'');\n  assert_throws(NotFoundError, a . insertBefore(b, c))\n}) Node_insertBefore_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test\n     (Heap_Error_Monad.bind\n       Node_insertBefore_document . createElement(''div'')\n       (\\<lambda>a.\n           Heap_Error_Monad.bind\n            Node_insertBefore_document . createElement(''div'')\n            (\\<lambda>b.\n                Heap_Error_Monad.bind\n                 Node_insertBefore_document . createElement(''div'')\n                 (\\<lambda>c.\n                     assert_throws(NotFoundError, a . insertBefore(b, c))))))\n     Node_insertBefore_heap", "by eval"], ["", "text \\<open>\"If the context node is a document, inserting a document or text node should throw a HierarchyRequestError.\"\\<close>"], ["", "lemma \"test (do {\n  doc \\<leftarrow> createDocument(''title'');\n  doc2 \\<leftarrow> createDocument(''title2'');\n  tmp0 \\<leftarrow> doc . documentElement;\n  assert_throws(HierarchyRequestError, doc . insertBefore(doc2, tmp0));\n  tmp1 \\<leftarrow> doc . createTextNode(''text'');\n  tmp2 \\<leftarrow> doc . documentElement;\n  assert_throws(HierarchyRequestError, doc . insertBefore(tmp1, tmp2))\n}) Node_insertBefore_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test\n     (Heap_Error_Monad.bind createDocument(''title'')\n       (\\<lambda>doc.\n           Heap_Error_Monad.bind createDocument(''title2'')\n            (\\<lambda>doc2.\n                Heap_Error_Monad.bind doc . documentElement\n                 (\\<lambda>tmp0.\n                     Heap_Error_Monad.bind\n                      assert_throws(HierarchyRequestError, doc . insertBefore(doc2, tmp0))\n                      (\\<lambda>_.\n                          Heap_Error_Monad.bind\n                           doc . createTextNode(''text'')\n                           (\\<lambda>tmp1.\n                               Heap_Error_Monad.bind doc . documentElement\n                                (\\<lambda>tmp2.\n                                    assert_throws(HierarchyRequestError, doc . insertBefore(tmp1, tmp2)))))))))\n     Node_insertBefore_heap", "by eval"], ["", "text \\<open>\"Inserting a node before itself should not move the node\"\\<close>"], ["", "lemma \"test (do {\n  a \\<leftarrow> Node_insertBefore_document . createElement(''div'');\n  b \\<leftarrow> Node_insertBefore_document . createElement(''div'');\n  c \\<leftarrow> Node_insertBefore_document . createElement(''div'');\n  a . appendChild(b);\n  a . appendChild(c);\n  tmp0 \\<leftarrow> a . childNodes;\n  assert_array_equals(tmp0, [b, c]);\n  tmp1 \\<leftarrow> a . insertBefore(b, b);\n  assert_equals(tmp1, b);\n  tmp2 \\<leftarrow> a . childNodes;\n  assert_array_equals(tmp2, [b, c]);\n  tmp3 \\<leftarrow> a . insertBefore(c, c);\n  assert_equals(tmp3, c);\n  tmp4 \\<leftarrow> a . childNodes;\n  assert_array_equals(tmp4, [b, c])\n}) Node_insertBefore_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test\n     (Heap_Error_Monad.bind\n       Node_insertBefore_document . createElement(''div'')\n       (\\<lambda>a.\n           Heap_Error_Monad.bind\n            Node_insertBefore_document . createElement(''div'')\n            (\\<lambda>b.\n                Heap_Error_Monad.bind\n                 Node_insertBefore_document . createElement(''div'')\n                 (\\<lambda>c.\n                     Heap_Error_Monad.bind a . appendChild(b)\n                      (\\<lambda>_.\n                          Heap_Error_Monad.bind a . appendChild(c)\n                           (\\<lambda>_.\n                               Heap_Error_Monad.bind a . childNodes\n                                (\\<lambda>tmp0.\n                                    Heap_Error_Monad.bind\n                                     assert_array_equals(tmp0, [b, c])\n                                     (\\<lambda>_.\n   Heap_Error_Monad.bind a . insertBefore(b, b)\n    (\\<lambda>tmp1.\n        Heap_Error_Monad.bind assert_array_equals(tmp1, b)\n         (\\<lambda>_.\n             Heap_Error_Monad.bind a . childNodes\n              (\\<lambda>tmp2.\n                  Heap_Error_Monad.bind assert_array_equals(tmp2, [b, c])\n                   (\\<lambda>_.\n                       Heap_Error_Monad.bind a . insertBefore(c, c)\n                        (\\<lambda>tmp3.\n                            Heap_Error_Monad.bind\n                             assert_array_equals(tmp3, c)\n                             (\\<lambda>_.\n                                 Heap_Error_Monad.bind a . childNodes\n                                  (\\<lambda>tmp4.\nassert_array_equals(tmp4, [b, c]))))))))))))))))\n     Node_insertBefore_heap", "by eval"], ["", "end"]]}