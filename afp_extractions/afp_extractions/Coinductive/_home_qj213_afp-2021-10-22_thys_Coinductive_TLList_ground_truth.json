{"file_name": "/home/qj213/afp-2021-10-22/thys/Coinductive/TLList.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Coinductive", "problem_names": ["lemma split_fst: \"R (fst p) = (\\<forall>x y. p = (x, y) \\<longrightarrow> R x)\"", "lemma split_fst_asm: \"R (fst p) \\<longleftrightarrow> (\\<not> (\\<exists>x y. p = (x, y) \\<and> \\<not> R x))\"", "lemma terminal0_terminal [simp]: \"terminal0 = terminal\"", "lemmas terminal_TNil [code, nitpick_simp] = tllist.sel(1)", "lemma terminal_TCons [simp, code, nitpick_simp]: \"terminal (TCons x xs) = terminal xs\"", "lemma \"xs = TNil x\"", "lemma \"TCons x xs = TCons x xs\"", "lemma ttl_unfold_tllist:\n  \"ttl (unfold_tllist IS_TNIL TNIL THD TTL a) = \n  (if IS_TNIL a then TNil (TNIL a) else unfold_tllist IS_TNIL TNIL THD TTL (TTL a))\"", "lemma is_TNil_ttl [simp]: \"is_TNil xs \\<Longrightarrow> is_TNil (ttl xs)\"", "lemma terminal_ttl [simp]: \"terminal (ttl xs) = terminal xs\"", "lemma unfold_tllist_eq_TNil [simp]:\n  \"unfold_tllist IS_TNIL TNIL THD TTL a = TNil b \\<longleftrightarrow> IS_TNIL a \\<and> b = TNIL a\"", "lemma TNil_eq_unfold_tllist [simp]:\n  \"TNil b = unfold_tllist IS_TNIL TNIL THD TTL a \\<longleftrightarrow> IS_TNIL a \\<and> b = TNIL a\"", "lemma tmap_is_TNil: \"is_TNil xs \\<Longrightarrow> tmap f g xs = TNil (g (terminal xs))\"", "lemma ttl_tmap [simp]: \"ttl (tmap f g xs) = tmap f g (ttl xs)\"", "lemma tmap_eq_TNil_conv:\n  \"tmap f g xs = TNil y \\<longleftrightarrow> (\\<exists>y'. xs = TNil y' \\<and> g y' = y)\"", "lemma TNil_eq_tmap_conv:\n  \"TNil y = tmap f g xs \\<longleftrightarrow> (\\<exists>y'. xs = TNil y' \\<and> g y' = y)\"", "lemma tset_ttl: \"tset (ttl xs) \\<subseteq> tset xs\"", "lemma in_tset_ttlD: \"x \\<in> tset (ttl xs) \\<Longrightarrow> x \\<in> tset xs\"", "theorem tllist_set_induct[consumes 1, case_names find step]:\n  assumes \"x \\<in> tset xs\" and \"\\<And>xs. \\<not> is_TNil xs \\<Longrightarrow> P (thd xs) xs\"\n  and \"\\<And>xs y. \\<lbrakk>\\<not> is_TNil xs; y \\<in> tset (ttl xs); P y (ttl xs)\\<rbrakk> \\<Longrightarrow> P y xs\"\n  shows \"P x xs\"", "theorem set2_tllist_induct[consumes 1, case_names find step]:\n  assumes \"x \\<in> set2_tllist xs\" and \"\\<And>xs. is_TNil xs \\<Longrightarrow> P (terminal xs) xs\"\n  and \"\\<And>xs y. \\<lbrakk>\\<not> is_TNil xs; y \\<in> set2_tllist (ttl xs); P y (ttl xs)\\<rbrakk> \\<Longrightarrow> P y xs\"\n  shows \"P x xs\"", "lemmas tllist_of_llist_LNil = tllist_of_llist_simps(1)\n  and tllist_of_llist_LCons = tllist_of_llist_simps(2)", "lemma terminal_tllist_of_llist_lnull [simp]:\n  \"lnull xs \\<Longrightarrow> terminal (tllist_of_llist b xs) = b\"", "lemma lhd_LNil: \"lhd LNil = undefined\"", "lemma thd_TNil: \"thd (TNil b) = undefined\"", "lemma thd_tllist_of_llist [simp]: \"thd (tllist_of_llist b xs) = lhd xs\"", "lemma ttl_tllist_of_llist [simp]: \"ttl (tllist_of_llist b xs) = tllist_of_llist b (ltl xs)\"", "lemma llist_of_tllist_eq_LNil:\n  \"llist_of_tllist xs = LNil \\<longleftrightarrow> is_TNil xs\"", "lemmas llist_of_tllist_TNil = llist_of_tllist_simps(1)\n  and llist_of_tllist_TCons = llist_of_tllist_simps(2)", "lemma lhd_llist_of_tllist [simp]: \"\\<not> is_TNil xs \\<Longrightarrow> lhd (llist_of_tllist xs) = thd xs\"", "lemma ltl_llist_of_tllist [simp]:\n  \"ltl (llist_of_tllist xs) = llist_of_tllist (ttl xs)\"", "lemma tllist_of_llist_cong [cong]:\n  assumes \"xs = xs'\" \"lfinite xs' \\<Longrightarrow> b = b'\"\n  shows \"tllist_of_llist b xs = tllist_of_llist b' xs'\"", "lemma llist_of_tllist_inverse [simp]: \n  \"tllist_of_llist (terminal b) (llist_of_tllist b) = b\"", "lemma tllist_of_llist_eq [simp]: \"tllist_of_llist b' xs = TNil b \\<longleftrightarrow> b = b' \\<and> xs = LNil\"", "lemma TNil_eq_tllist_of_llist [simp]: \"TNil b = tllist_of_llist b' xs \\<longleftrightarrow> b = b' \\<and> xs = LNil\"", "lemma tllist_of_llist_inject [simp]:\n  \"tllist_of_llist b xs = tllist_of_llist c ys \\<longleftrightarrow> xs = ys \\<and> (lfinite ys \\<longrightarrow> b = c)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma tllist_of_llist_inverse [simp]:\n  \"llist_of_tllist (tllist_of_llist b xs) = xs\"", "lemma Quotient_tllist:\n  \"Quotient (\\<lambda>(xs, a) (ys, b). xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n     (\\<lambda>(xs, a). tllist_of_llist a xs) (\\<lambda>ys. (llist_of_tllist ys, terminal ys)) cr_tllist\"", "lemma reflp_tllist: \"reflp (\\<lambda>(xs, a) (ys, b). xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\"", "lemma TNil_transfer [transfer_rule]:\n  \"(B ===> pcr_tllist A B) (Pair LNil) TNil\"", "lemma TCons_transfer [transfer_rule]:\n  \"(A ===> pcr_tllist A B ===> pcr_tllist A B) (apfst \\<circ> LCons) TCons\"", "lemma tmap_tllist_of_llist:\n  \"tmap f g (tllist_of_llist b xs) = tllist_of_llist (g b) (lmap f xs)\"", "lemma tmap_transfer [transfer_rule]:\n  \"((=) ===> (=) ===> pcr_tllist (=) (=) ===> pcr_tllist (=) (=)) (map_prod \\<circ> lmap) tmap\"", "lemma lset_llist_of_tllist [simp]:\n  \"lset (llist_of_tllist xs) = tset xs\" (is \"?lhs = ?rhs\")", "lemma tset_tllist_of_llist [simp]:\n  \"tset (tllist_of_llist b xs) = lset xs\"", "lemma tset_transfer [transfer_rule]:\n  \"(pcr_tllist (=) (=) ===> (=)) (lset \\<circ> fst) tset\"", "lemma is_TNil_transfer [transfer_rule]:\n  \"(pcr_tllist (=) (=) ===> (=)) (\\<lambda>(xs, b). lnull xs) is_TNil\"", "lemma thd_transfer [transfer_rule]:\n  \"(pcr_tllist (=) (=) ===> (=)) (lhd \\<circ> fst) thd\"", "lemma ttl_transfer [transfer_rule]:\n  \"(pcr_tllist A B ===> pcr_tllist A B) (apfst ltl) ttl\"", "lemma llist_of_tllist_transfer [transfer_rule]:\n  \"(pcr_tllist (=) B ===> (=)) fst llist_of_tllist\"", "lemma tllist_of_llist_transfer [transfer_rule]:\n  \"((=) ===> (=) ===> pcr_tllist (=) (=)) (\\<lambda>b xs. (xs, b)) tllist_of_llist\"", "lemma terminal_tllist_of_llist_lfinite [simp]:\n  \"lfinite xs \\<Longrightarrow> terminal (tllist_of_llist b xs) = b\"", "lemma set2_tllist_tllist_of_llist [simp]:\n  \"set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})\"", "lemma set2_tllist_transfer [transfer_rule]:\n  \"(pcr_tllist A B ===> rel_set B) (\\<lambda>(xs, b). if lfinite xs then {b} else {}) set2_tllist\"", "lemma tllist_all2_transfer [transfer_rule]:\n  \"((=) ===> (=) ===> pcr_tllist (=) (=) ===> pcr_tllist (=) (=) ===> (=))\n     (\\<lambda>P Q (xs, b) (ys, b'). llist_all2 P xs ys \\<and> (lfinite xs \\<longrightarrow> Q b b')) tllist_all2\"", "lemma tfinite_induct [consumes 1, case_names TNil TCons]:\n  assumes \"tfinite xs\"\n  and \"\\<And>y. P (TNil y)\"\n  and \"\\<And>x xs. \\<lbrakk>tfinite xs; P xs\\<rbrakk> \\<Longrightarrow> P (TCons x xs)\"\n  shows \"P xs\"", "lemma is_TNil_tfinite [simp]: \"is_TNil xs \\<Longrightarrow> tfinite xs\"", "lemma terminal_tinfinite:\n  assumes \"\\<not> tfinite xs\"\n  shows \"terminal xs = undefined\"", "lemma terminal_tllist_of_llist:\n  \"terminal (tllist_of_llist y xs) = (if lfinite xs then y else undefined)\"", "lemma terminal_transfer [transfer_rule]:\n  \"(pcr_tllist A (=) ===> (=)) (\\<lambda>(xs, b). if lfinite xs then b else undefined) terminal\"", "lemma terminal_tmap [simp]: \"tfinite xs \\<Longrightarrow> terminal (tmap f g xs) = g (terminal xs)\"", "lemma tmap_eq_TCons_conv:\n  \"tmap f g xs = TCons y ys \\<longleftrightarrow>\n  (\\<exists>z zs. xs = TCons z zs \\<and> f z = y \\<and> tmap f g zs = ys)\"", "lemma TCons_eq_tmap_conv:\n  \"TCons y ys = tmap f g xs \\<longleftrightarrow>\n  (\\<exists>z zs. xs = TCons z zs \\<and> f z = y \\<and> tmap f g zs = ys)\"", "lemma tappend_TNil [simp, code, nitpick_simp]:\n  \"tappend (TNil b) f = f b\"", "lemma tappend_TCons [simp, code, nitpick_simp]:\n  \"tappend (TCons a tr) f = TCons a (tappend tr f)\"", "lemma tappend_TNil2 [simp]:\n  \"tappend xs TNil = xs\"", "lemma tappend_assoc: \"tappend (tappend xs f) g = tappend xs (\\<lambda>b. tappend (f b) g)\"", "lemma terminal_tappend:\n  \"terminal (tappend xs f) = (if tfinite xs then terminal (f (terminal xs)) else terminal xs)\"", "lemma tfinite_tappend: \"tfinite (tappend xs f) \\<longleftrightarrow> tfinite xs \\<and> tfinite (f (terminal xs))\"", "lemma tappend_inf: \"\\<not> tfinite xs \\<Longrightarrow> tappend xs f = tcast xs\"", "lemmas tllist_monad = tappend_TNil tappend_TNil2 tappend_assoc", "lemma lappendt_LNil [simp, code, nitpick_simp]: \"lappendt LNil tr = tr\"", "lemma lappendt_LCons [simp, code, nitpick_simp]:\n  \"lappendt (LCons x xs) tr = TCons x (lappendt xs tr)\"", "lemma terminal_lappendt_lfinite [simp]:\n  \"lfinite xs \\<Longrightarrow> terminal (lappendt xs ys) = terminal ys\"", "lemma tllist_of_llist_eq_lappendt_conv:\n  \"tllist_of_llist a xs = lappendt ys zs \\<longleftrightarrow> \n  (\\<exists>xs' a'. xs = lappend ys xs' \\<and> zs = tllist_of_llist a' xs' \\<and> (lfinite ys \\<longrightarrow> a = a'))\"", "lemma tset_lappendt_lfinite [simp]:\n  \"lfinite xs \\<Longrightarrow> tset (lappendt xs ys) = lset xs \\<union> tset ys\"", "lemma tfilter_TNil [simp]:\n  \"tfilter b' P (TNil b) = TNil b\"", "lemma tfilter_TCons [simp]:\n  \"tfilter b P (TCons a tr) = (if P a then TCons a (tfilter b P tr) else tfilter b P tr)\"", "lemma is_TNil_tfilter[simp]:\n  \"is_TNil (tfilter y P xs) \\<longleftrightarrow> (\\<forall>x \\<in> tset xs. \\<not> P x)\"", "lemma tfilter_empty_conv:\n  \"tfilter y P xs = TNil y' \\<longleftrightarrow> (\\<forall>x \\<in> tset xs. \\<not> P x) \\<and> (if tfinite xs then terminal xs = y' else y = y')\"", "lemma tfilter_eq_TConsD:\n  \"tfilter a P ys = TCons x xs \\<Longrightarrow>\n   \\<exists>us vs. ys = lappendt us (TCons x vs) \\<and> lfinite us \\<and> (\\<forall>u\\<in>lset us. \\<not> P u) \\<and> P x \\<and> xs = tfilter a P vs\"", "lemma tfilter_code [code, code_unfold]:\n  \"tfilter = (\\<lambda>b. tfilter' (\\<lambda>_. b))\"", "lemma tfilter'_code [code]:\n  \"tfilter' b' P (TNil b) = TNil b\"\n  \"tfilter' b' P (TCons a tr) = (if P a then TCons a (tfilter' b' P tr) else tfilter' b' P tr)\"", "lemma tconcat_TNil [simp]: \"tconcat b (TNil b') = TNil b'\"", "lemma tconcat_TCons [simp]: \"tconcat b (TCons a tr) = lappendt a (tconcat b tr)\"", "lemma tconcat_code [code, code_unfold]: \"tconcat = (\\<lambda>b. tconcat' (\\<lambda>_. b))\"", "lemma tconcat'_code [code]:\n  \"tconcat' b (TNil b') = TNil b'\"\n  \"tconcat' b (TCons a tr) = lappendt a (tconcat' b tr)\"", "lemmas tllist_all2_TNil = tllist.rel_inject(1)", "lemmas tllist_all2_TCons = tllist.rel_inject(2)", "lemma tllist_all2_TNil1: \"tllist_all2 P Q (TNil b) ts \\<longleftrightarrow> (\\<exists>b'. ts = TNil b' \\<and> Q b b')\"", "lemma tllist_all2_TNil2: \"tllist_all2 P Q ts (TNil b') \\<longleftrightarrow> (\\<exists>b. ts = TNil b \\<and> Q b b')\"", "lemma tllist_all2_TCons1: \n  \"tllist_all2 P Q (TCons x ts) ts' \\<longleftrightarrow> (\\<exists>x' ts''. ts' = TCons x' ts'' \\<and> P x x' \\<and> tllist_all2 P Q ts ts'')\"", "lemma tllist_all2_TCons2: \n  \"tllist_all2 P Q ts' (TCons x ts) \\<longleftrightarrow> (\\<exists>x' ts''. ts' = TCons x' ts'' \\<and> P x' x \\<and> tllist_all2 P Q ts'' ts)\"", "lemma tllist_all2_coinduct [consumes 1, case_names tllist_all2, case_conclusion tllist_all2 is_TNil TNil TCons, coinduct pred: tllist_all2]:\n  assumes \"X xs ys\"\n  and \"\\<And>xs ys. X xs ys \\<Longrightarrow>\n  (is_TNil xs \\<longleftrightarrow> is_TNil ys) \\<and>\n  (is_TNil xs \\<longrightarrow> is_TNil ys \\<longrightarrow> R (terminal xs) (terminal ys)) \\<and>\n  (\\<not> is_TNil xs \\<longrightarrow> \\<not> is_TNil ys \\<longrightarrow> P (thd xs) (thd ys) \\<and> (X (ttl xs) (ttl ys) \\<or> tllist_all2 P R (ttl xs) (ttl ys)))\"\n  shows \"tllist_all2 P R xs ys\"", "lemma tllist_all2_cases[consumes 1, case_names TNil TCons, cases pred]:\n  assumes \"tllist_all2 P Q xs ys\"\n  obtains (TNil) b b' where \"xs = TNil b\" \"ys = TNil b'\" \"Q b b'\"\n  | (TCons) x xs' y ys'\n    where \"xs = TCons x xs'\" and \"ys = TCons y ys'\" \n    and \"P x y\" and \"tllist_all2 P Q xs' ys'\"", "lemma tllist_all2_tmap1:\n  \"tllist_all2 P Q (tmap f g xs) ys \\<longleftrightarrow> tllist_all2 (\\<lambda>x. P (f x)) (\\<lambda>x. Q (g x)) xs ys\"", "lemma tllist_all2_tmap2:\n  \"tllist_all2 P Q xs (tmap f g ys) \\<longleftrightarrow> tllist_all2 (\\<lambda>x y. P x (f y)) (\\<lambda>x y. Q x (g y)) xs ys\"", "lemma tllist_all2_mono:\n  \"\\<lbrakk> tllist_all2 P Q xs ys; \\<And>x y. P x y \\<Longrightarrow> P' x y; \\<And>x y. Q x y \\<Longrightarrow> Q' x y \\<rbrakk>\n  \\<Longrightarrow> tllist_all2 P' Q' xs ys\"", "lemma tllist_all2_tlengthD: \"tllist_all2 P Q xs ys \\<Longrightarrow> tlength xs = tlength ys\"", "lemma tllist_all2_tfiniteD: \"tllist_all2 P Q xs ys \\<Longrightarrow> tfinite xs = tfinite ys\"", "lemma tllist_all2_tfinite1_terminalD:\n  \"\\<lbrakk> tllist_all2 P Q xs ys; tfinite xs \\<rbrakk> \\<Longrightarrow> Q (terminal xs) (terminal ys)\"", "lemma tllist_all2_tfinite2_terminalD:\n  \"\\<lbrakk> tllist_all2 P Q xs ys; tfinite ys \\<rbrakk> \\<Longrightarrow> Q (terminal xs) (terminal ys)\"", "lemma tllist_all2D_llist_all2_llist_of_tllist:\n  \"tllist_all2 P Q xs ys \\<Longrightarrow> llist_all2 P (llist_of_tllist xs) (llist_of_tllist ys)\"", "lemma tllist_all2_is_TNilD:\n  \"tllist_all2 P Q xs ys \\<Longrightarrow> is_TNil xs \\<longleftrightarrow> is_TNil ys\"", "lemma tllist_all2_thdD:\n  \"\\<lbrakk> tllist_all2 P Q xs ys; \\<not> is_TNil xs \\<or> \\<not> is_TNil ys \\<rbrakk> \\<Longrightarrow> P (thd xs) (thd ys)\"", "lemma tllist_all2_ttlI:\n  \"\\<lbrakk> tllist_all2 P Q xs ys; \\<not> is_TNil xs \\<or> \\<not> is_TNil ys \\<rbrakk> \\<Longrightarrow> tllist_all2 P Q (ttl xs) (ttl ys)\"", "lemma tllist_all2_refl:\n  \"tllist_all2 P Q xs xs \\<longleftrightarrow> (\\<forall>x \\<in> tset xs. P x x) \\<and> (tfinite xs \\<longrightarrow> Q (terminal xs) (terminal xs))\"", "lemma tllist_all2_reflI:\n  \"\\<lbrakk> \\<And>x. x \\<in> tset xs \\<Longrightarrow> P x x; tfinite xs \\<Longrightarrow> Q (terminal xs) (terminal xs) \\<rbrakk>\n  \\<Longrightarrow> tllist_all2 P Q xs xs\"", "lemma tllist_all2_conv_all_tnth:\n  \"tllist_all2 P Q xs ys \\<longleftrightarrow> \n  tlength xs = tlength ys \\<and> \n  (\\<forall>n. enat n < tlength xs \\<longrightarrow> P (tnth xs n) (tnth ys n)) \\<and>\n  (tfinite xs \\<longrightarrow> Q (terminal xs) (terminal ys))\"", "lemma tllist_all2_tnthD:\n  \"\\<lbrakk> tllist_all2 P Q xs ys; enat n < tlength xs \\<rbrakk> \n  \\<Longrightarrow> P (tnth xs n) (tnth ys n)\"", "lemma tllist_all2_tnthD2:\n  \"\\<lbrakk> tllist_all2 P Q xs ys; enat n < tlength ys \\<rbrakk> \n  \\<Longrightarrow> P (tnth xs n) (tnth ys n)\"", "lemmas tllist_all2_eq = tllist.rel_eq", "lemma tmap_eq_tmap_conv_tllist_all2:\n  \"tmap f g xs = tmap f' g' ys \\<longleftrightarrow>\n  tllist_all2 (\\<lambda>x y. f x = f' y) (\\<lambda>x y. g x = g' y) xs ys\"", "lemma tllist_all2_trans:\n  \"\\<lbrakk> tllist_all2 P Q xs ys; tllist_all2 P Q ys zs; transp P; transp Q \\<rbrakk>\n  \\<Longrightarrow> tllist_all2 P Q xs zs\"", "lemma tllist_all2_tappendI:\n  \"\\<lbrakk> tllist_all2 P Q xs ys;\n     \\<lbrakk> tfinite xs; tfinite ys; Q (terminal xs) (terminal ys) \\<rbrakk>\n     \\<Longrightarrow> tllist_all2 P R (xs' (terminal xs)) (ys' (terminal ys)) \\<rbrakk>\n  \\<Longrightarrow> tllist_all2 P R (tappend xs xs') (tappend ys ys')\"", "lemma llist_all2_tllist_of_llistI:\n  \"tllist_all2 A B xs ys \\<Longrightarrow> llist_all2 A (llist_of_tllist xs) (llist_of_tllist ys)\"", "lemma tllist_all2_tllist_of_llist [simp]:\n  \"tllist_all2 A B (tllist_of_llist b xs) (tllist_of_llist c ys) \\<longleftrightarrow>\n  llist_all2 A xs ys \\<and> (lfinite xs \\<longrightarrow> B b c)\"", "lemma llist_of_tllist_tmap [simp]:\n  \"llist_of_tllist (tmap f g xs) = lmap f (llist_of_tllist xs)\"", "lemma llist_of_tllist_tappend:\n  \"llist_of_tllist (tappend xs f) = lappend (llist_of_tllist xs) (llist_of_tllist (f (terminal xs)))\"", "lemma llist_of_tllist_lappendt [simp]:\n  \"llist_of_tllist (lappendt xs tr) = lappend xs (llist_of_tllist tr)\"", "lemma llist_of_tllist_tfilter [simp]:\n  \"llist_of_tllist (tfilter b P tr) = lfilter P (llist_of_tllist tr)\"", "lemma llist_of_tllist_tconcat:\n  \"llist_of_tllist (tconcat b trs) = lconcat (llist_of_tllist trs)\"", "lemma llist_of_tllist_eq_lappend_conv:\n  \"llist_of_tllist xs = lappend us vs \\<longleftrightarrow> \n  (\\<exists>ys. xs = lappendt us ys \\<and> vs = llist_of_tllist ys \\<and> terminal xs = terminal ys)\"", "lemma tnth_TNil [nitpick_simp]:\n  \"tnth (TNil b) n = undefined n\"", "lemma tnth_TCons:\n  \"tnth (TCons x xs) n = (case n of 0 \\<Rightarrow> x | Suc n' \\<Rightarrow> tnth xs n')\"", "lemma tnth_code [simp, nitpick_simp, code]:\n  shows tnth_0: \"tnth (TCons x xs) 0 = x\"\n  and tnth_Suc_TCons: \"tnth (TCons x xs) (Suc n) = tnth xs n\"", "lemma lnth_llist_of_tllist [simp]:\n  \"lnth (llist_of_tllist xs) = tnth xs\"", "lemma tnth_tmap [simp]: \"enat n < tlength xs \\<Longrightarrow> tnth (tmap f g xs) n = f (tnth xs n)\"", "lemma [simp, nitpick_simp]:\n  shows tlength_TNil: \"tlength (TNil b) = 0\"\n  and tlength_TCons: \"tlength (TCons x xs) = eSuc (tlength xs)\"", "lemma llength_llist_of_tllist [simp]: \"llength (llist_of_tllist xs) = tlength xs\"", "lemma tlength_tmap [simp]: \"tlength (tmap f g xs) = tlength xs\"", "lemma gen_tlength_code [code]:\n  \"gen_tlength n (TNil b) = enat n\"\n  \"gen_tlength n (TCons x xs) = gen_tlength (n + 1) xs\"", "lemma tlength_code [code]: \"tlength = gen_tlength 0\"", "lemma tdropn_0 [simp, code, nitpick_simp]: \"tdropn 0 xs = xs\"", "lemma tdropn_TNil [simp, code]: \"tdropn n (TNil b) = (TNil b)\"", "lemma tdropn_Suc_TCons [simp, code]: \"tdropn (Suc n) (TCons x xs) = tdropn n xs\"", "lemma tdropn_Suc [nitpick_simp]: \"tdropn (Suc n) xs = (case xs of TNil b \\<Rightarrow> TNil b | TCons x xs' \\<Rightarrow> tdropn n xs')\"", "lemma lappendt_ltake_tdropn:\n  \"lappendt (ltake (enat n) (llist_of_tllist xs)) (tdropn n xs) = xs\"", "lemma llist_of_tllist_tdropn [simp]:\n  \"llist_of_tllist (tdropn n xs) = ldropn n (llist_of_tllist xs)\"", "lemma tdropn_Suc_conv_tdropn:\n  \"enat n < tlength xs \\<Longrightarrow> TCons (tnth xs n) (tdropn (Suc n) xs) = tdropn n xs\"", "lemma tlength_tdropn [simp]: \"tlength (tdropn n xs) = tlength xs - enat n\"", "lemma tnth_tdropn [simp]: \"enat (n + m) < tlength xs \\<Longrightarrow> tnth (tdropn n xs) m = tnth xs (m + n)\"", "lemma tset_induct [consumes 1, case_names find step]:\n  assumes \"x \\<in> tset xs\"\n  and \"\\<And>xs. P (TCons x xs)\"\n  and \"\\<And>x' xs. \\<lbrakk> x \\<in> tset xs; x \\<noteq> x'; P xs \\<rbrakk> \\<Longrightarrow> P (TCons x' xs)\"\n  shows \"P xs\"", "lemma tset_conv_tnth: \"tset xs = {tnth xs n|n . enat n < tlength xs}\"", "lemma in_tset_conv_tnth: \"x \\<in> tset xs \\<longleftrightarrow> (\\<exists>n. enat n < tlength xs \\<and> tnth xs n = x)\"", "lemma set1_pre_tllist_transfer [transfer_rule]:\n  \"(rel_pre_tllist A B C ===> rel_set A) set1_pre_tllist set1_pre_tllist\"", "lemma set2_pre_tllist_transfer [transfer_rule]:\n  \"(rel_pre_tllist A B C ===> rel_set B) set2_pre_tllist set2_pre_tllist\"", "lemma set3_pre_tllist_transfer [transfer_rule]:\n  \"(rel_pre_tllist A B C ===> rel_set C) set3_pre_tllist set3_pre_tllist\"", "lemma TNil_transfer2 [transfer_rule]: \"(B ===> tllist_all2 A B) TNil TNil\"", "lemma TCons_transfer2 [transfer_rule]:\n  \"(A ===> tllist_all2 A B ===> tllist_all2 A B) TCons TCons\"", "lemma case_tllist_transfer [transfer_rule]:\n  \"((B ===> C) ===> (A ===> tllist_all2 A B ===> C) ===> tllist_all2 A B ===> C)\n    case_tllist case_tllist\"", "lemma unfold_tllist_transfer [transfer_rule]:\n  \"((A ===> (=)) ===> (A ===> B) ===> (A ===> C) ===> (A ===> A) ===> A ===> tllist_all2 C B) unfold_tllist unfold_tllist\"", "lemma corec_tllist_transfer [transfer_rule]:\n  \"((A ===> (=)) ===> (A ===> B) ===> (A ===> C) ===> (A ===> (=)) ===> (A ===> tllist_all2 C B) ===> (A ===> A) ===> A ===> tllist_all2 C B) corec_tllist corec_tllist\"", "lemma ttl_transfer2 [transfer_rule]:\n  \"(tllist_all2 A B ===> tllist_all2 A B) ttl ttl\"", "lemma tset_transfer2 [transfer_rule]:\n  \"(tllist_all2 A B ===> rel_set A) tset tset\"", "lemma tmap_transfer2 [transfer_rule]:\n  \"((A ===> B) ===> (C ===> D) ===> tllist_all2 A C ===> tllist_all2 B D) tmap tmap\"", "lemma is_TNil_transfer2 [transfer_rule]:\n  \"(tllist_all2 A B ===> (=)) is_TNil is_TNil\"", "lemma tappend_transfer [transfer_rule]:\n  \"(tllist_all2 A B ===> (B ===> tllist_all2 A C) ===> tllist_all2 A C) tappend tappend\"", "lemma lappendt_transfer [transfer_rule]:\n  \"(llist_all2 A ===> tllist_all2 A B ===> tllist_all2 A B) lappendt lappendt\"", "lemma llist_of_tllist_transfer2 [transfer_rule]:\n  \"(tllist_all2 A B ===> llist_all2 A) llist_of_tllist llist_of_tllist\"", "lemma tllist_of_llist_transfer2 [transfer_rule]:\n  \"(B ===> llist_all2 A ===> tllist_all2 A B) tllist_of_llist tllist_of_llist\"", "lemma tlength_transfer [transfer_rule]:\n  \"(tllist_all2 A B ===> (=)) tlength tlength\"", "lemma tdropn_transfer [transfer_rule]:\n  \"((=) ===> tllist_all2 A B ===> tllist_all2 A B) tdropn tdropn\"", "lemma tfilter_transfer [transfer_rule]:\n  \"(B ===> (A ===> (=)) ===> tllist_all2 A B ===> tllist_all2 A B) tfilter tfilter\"", "lemma tconcat_transfer [transfer_rule]:\n  \"(B ===> tllist_all2 (llist_all2 A) B ===> tllist_all2 A B) tconcat tconcat\"", "lemma tllist_all2_rsp:\n  assumes R1: \"\\<forall>x y. R1 x y \\<longrightarrow> (\\<forall>a b. R1 a b \\<longrightarrow> S x a = T y b)\"\n  and R2: \"\\<forall>x y. R2 x y \\<longrightarrow> (\\<forall>a b. R2 a b \\<longrightarrow> S' x a = T' y b)\"\n  and xsys: \"tllist_all2 R1 R2 xs ys\"\n  and xs'ys': \"tllist_all2 R1 R2 xs' ys'\"\n  shows \"tllist_all2 S S' xs xs' = tllist_all2 T T' ys ys'\"", "lemma tllist_all2_transfer2 [transfer_rule]:\n  \"((R1 ===> R1 ===> (=)) ===> (R2 ===> R2 ===> (=)) ===>\n    tllist_all2 R1 R2 ===> tllist_all2 R1 R2 ===> (=)) tllist_all2 tllist_all2\""], "translations": [["", "lemma split_fst: \"R (fst p) = (\\<forall>x y. p = (x, y) \\<longrightarrow> R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (fst p) = (\\<forall>x y. p = (x, y) \\<longrightarrow> R x)", "by(cases p) simp"], ["", "lemma split_fst_asm: \"R (fst p) \\<longleftrightarrow> (\\<not> (\\<exists>x y. p = (x, y) \\<and> \\<not> R x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (fst p) = (\\<nexists>x y. p = (x, y) \\<and> \\<not> R x)", "by(cases p) simp"], ["", "subsection \\<open>Type definition\\<close>"], ["", "consts terminal0 :: \"'a\""], ["", "codatatype (tset: 'a, 'b) tllist =\n    TNil (terminal : 'b)\n  | TCons (thd : 'a) (ttl : \"('a, 'b) tllist\")\nfor\n  map: tmap\n  rel: tllist_all2\nwhere\n  \"thd (TNil _) = undefined\"\n| \"ttl (TNil b) = TNil b\"\n| \"terminal (TCons _ xs) = terminal0 xs\""], ["", "overloading\n  terminal0 == \"terminal0::('a, 'b) tllist \\<Rightarrow> 'b\"\nbegin"], ["", "partial_function (tailrec) terminal0 \nwhere \"terminal0 xs = (if is_TNil xs then case_tllist id undefined xs else terminal0 (ttl xs))\""], ["", "end"], ["", "lemma terminal0_terminal [simp]: \"terminal0 = terminal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal0 = terminal", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. terminal0 x = terminal x", "apply(subst terminal0.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (if is_TNil x\n        then case x of TNil x \\<Rightarrow> id x\n             | TCons x xa \\<Rightarrow> undefined x xa\n        else terminal0 (ttl x)) =\n       terminal x", "apply(case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1.\n       x = TNil x1 \\<Longrightarrow>\n       (if is_TNil x\n        then case x of TNil x \\<Rightarrow> id x\n             | TCons x xa \\<Rightarrow> undefined x xa\n        else terminal0 (ttl x)) =\n       terminal x\n 2. \\<And>x x21 x22.\n       x = TCons x21 x22 \\<Longrightarrow>\n       (if is_TNil x\n        then case x of TNil x \\<Rightarrow> id x\n             | TCons x xa \\<Rightarrow> undefined x xa\n        else terminal0 (ttl x)) =\n       terminal x", "apply(simp_all add: terminal_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas terminal_TNil [code, nitpick_simp] = tllist.sel(1)"], ["", "lemma terminal_TCons [simp, code, nitpick_simp]: \"terminal (TCons x xs) = terminal xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal (TCons x xs) = terminal xs", "by simp"], ["", "declare tllist.sel(2) [simp del]"], ["", "primcorec unfold_tllist :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'c) \\<Rightarrow> ('a \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> ('c, 'b) tllist\" where\n  \"p a \\<Longrightarrow> unfold_tllist p g1 g21 g22 a = TNil (g1 a)\" |\n  \"_ \\<Longrightarrow> unfold_tllist p g1 g21 g22 a =\n     TCons (g21 a) (unfold_tllist p g1 g21 g22 (g22 a))\""], ["", "declare\n  unfold_tllist.ctr(1) [simp]\n  tllist.corec(1) [simp]"], ["", "subsection \\<open>Code generator setup\\<close>"], ["", "text \\<open>Test quickcheck setup\\<close>"], ["", "lemma \"xs = TNil x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = TNil x", "quickcheck[random, expect=counterexample]"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = TNil x", "quickcheck[exhaustive, expect=counterexample]"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = TNil x", "oops"], ["", "lemma \"TCons x xs = TCons x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TCons x xs = TCons x xs", "quickcheck[narrowing, expect=no_counterexample]"], ["proof (prove)\ngoal (1 subgoal):\n 1. TCons x xs = TCons x xs", "oops"], ["", "text \\<open>More lemmas about generated constants\\<close>"], ["", "lemma ttl_unfold_tllist:\n  \"ttl (unfold_tllist IS_TNIL TNIL THD TTL a) = \n  (if IS_TNIL a then TNil (TNIL a) else unfold_tllist IS_TNIL TNIL THD TTL (TTL a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ttl (unfold_tllist IS_TNIL TNIL THD TTL a) =\n    (if IS_TNIL a then TNil (TNIL a)\n     else unfold_tllist IS_TNIL TNIL THD TTL (TTL a))", "by(simp)"], ["", "lemma is_TNil_ttl [simp]: \"is_TNil xs \\<Longrightarrow> is_TNil (ttl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_TNil xs \\<Longrightarrow> is_TNil (ttl xs)", "by(cases xs) simp_all"], ["", "lemma terminal_ttl [simp]: \"terminal (ttl xs) = terminal xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal (ttl xs) = terminal xs", "by(cases xs) simp_all"], ["", "lemma unfold_tllist_eq_TNil [simp]:\n  \"unfold_tllist IS_TNIL TNIL THD TTL a = TNil b \\<longleftrightarrow> IS_TNIL a \\<and> b = TNIL a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unfold_tllist IS_TNIL TNIL THD TTL a = TNil b) =\n    (IS_TNIL a \\<and> b = TNIL a)", "by(auto simp add: unfold_tllist.code)"], ["", "lemma TNil_eq_unfold_tllist [simp]:\n  \"TNil b = unfold_tllist IS_TNIL TNIL THD TTL a \\<longleftrightarrow> IS_TNIL a \\<and> b = TNIL a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (TNil b = unfold_tllist IS_TNIL TNIL THD TTL a) =\n    (IS_TNIL a \\<and> b = TNIL a)", "by(auto simp add: unfold_tllist.code)"], ["", "lemma tmap_is_TNil: \"is_TNil xs \\<Longrightarrow> tmap f g xs = TNil (g (terminal xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_TNil xs \\<Longrightarrow> tmap f g xs = TNil (g (terminal xs))", "by(clarsimp simp add: is_TNil_def)"], ["", "declare tllist.map_sel(2)[simp]"], ["", "lemma ttl_tmap [simp]: \"ttl (tmap f g xs) = tmap f g (ttl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ttl (tmap f g xs) = tmap f g (ttl xs)", "by(cases xs) simp_all"], ["", "lemma tmap_eq_TNil_conv:\n  \"tmap f g xs = TNil y \\<longleftrightarrow> (\\<exists>y'. xs = TNil y' \\<and> g y' = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tmap f g xs = TNil y) = (\\<exists>y'. xs = TNil y' \\<and> g y' = y)", "by(cases xs) simp_all"], ["", "lemma TNil_eq_tmap_conv:\n  \"TNil y = tmap f g xs \\<longleftrightarrow> (\\<exists>y'. xs = TNil y' \\<and> g y' = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (TNil y = tmap f g xs) = (\\<exists>y'. xs = TNil y' \\<and> g y' = y)", "by(cases xs) auto"], ["", "declare tllist.set_sel(1)[simp]"], ["", "lemma tset_ttl: \"tset (ttl xs) \\<subseteq> tset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tset (ttl xs) \\<subseteq> tset xs", "by(cases xs) auto"], ["", "lemma in_tset_ttlD: \"x \\<in> tset (ttl xs) \\<Longrightarrow> x \\<in> tset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> tset (ttl xs) \\<Longrightarrow> x \\<in> tset xs", "using tset_ttl[of xs]"], ["proof (prove)\nusing this:\n  tset (ttl xs) \\<subseteq> tset xs\n\ngoal (1 subgoal):\n 1. x \\<in> tset (ttl xs) \\<Longrightarrow> x \\<in> tset xs", "by auto"], ["", "theorem tllist_set_induct[consumes 1, case_names find step]:\n  assumes \"x \\<in> tset xs\" and \"\\<And>xs. \\<not> is_TNil xs \\<Longrightarrow> P (thd xs) xs\"\n  and \"\\<And>xs y. \\<lbrakk>\\<not> is_TNil xs; y \\<in> tset (ttl xs); P y (ttl xs)\\<rbrakk> \\<Longrightarrow> P y xs\"\n  shows \"P x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x xs", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> tset xs\n  \\<not> is_TNil ?xs \\<Longrightarrow> P (thd ?xs) ?xs\n  \\<lbrakk>\\<not> is_TNil ?xs; ?y \\<in> tset (ttl ?xs);\n   P ?y (ttl ?xs)\\<rbrakk>\n  \\<Longrightarrow> P ?y ?xs\n\ngoal (1 subgoal):\n 1. P x xs", "by(induct)(fastforce simp del: tllist.disc(2) iff: tllist.disc(2), auto)"], ["", "theorem set2_tllist_induct[consumes 1, case_names find step]:\n  assumes \"x \\<in> set2_tllist xs\" and \"\\<And>xs. is_TNil xs \\<Longrightarrow> P (terminal xs) xs\"\n  and \"\\<And>xs y. \\<lbrakk>\\<not> is_TNil xs; y \\<in> set2_tllist (ttl xs); P y (ttl xs)\\<rbrakk> \\<Longrightarrow> P y xs\"\n  shows \"P x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x xs", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set2_tllist xs\n  is_TNil ?xs \\<Longrightarrow> P (terminal ?xs) ?xs\n  \\<lbrakk>\\<not> is_TNil ?xs; ?y \\<in> set2_tllist (ttl ?xs);\n   P ?y (ttl ?xs)\\<rbrakk>\n  \\<Longrightarrow> P ?y ?xs\n\ngoal (1 subgoal):\n 1. P x xs", "by(induct)(fastforce simp del: tllist.disc(1) iff: tllist.disc(1), auto)"], ["", "subsection \\<open>Connection with @{typ \"'a llist\"}\\<close>"], ["", "context fixes b :: 'b begin"], ["", "primcorec tllist_of_llist :: \"'a llist \\<Rightarrow> ('a, 'b) tllist\" where\n  \"tllist_of_llist xs = (case xs of LNil \\<Rightarrow> TNil b | LCons x xs' \\<Rightarrow> TCons x (tllist_of_llist xs'))\""], ["", "end"], ["", "primcorec llist_of_tllist :: \"('a, 'b) tllist \\<Rightarrow> 'a llist\"\nwhere \"llist_of_tllist xs = (case xs of TNil _ \\<Rightarrow> LNil | TCons x xs' \\<Rightarrow> LCons x (llist_of_tllist xs'))\""], ["", "simps_of_case tllist_of_llist_simps [simp, code, nitpick_simp]: tllist_of_llist.code"], ["", "lemmas tllist_of_llist_LNil = tllist_of_llist_simps(1)\n  and tllist_of_llist_LCons = tllist_of_llist_simps(2)"], ["", "lemma terminal_tllist_of_llist_lnull [simp]:\n  \"lnull xs \\<Longrightarrow> terminal (tllist_of_llist b xs) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull xs \\<Longrightarrow> terminal (tllist_of_llist b xs) = b", "unfolding lnull_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = LNil \\<Longrightarrow> terminal (tllist_of_llist b xs) = b", "by simp"], ["", "declare tllist_of_llist.sel(1)[simp del]"], ["", "lemma lhd_LNil: \"lhd LNil = undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd LNil = undefined", "by(simp add: lhd_def)"], ["", "lemma thd_TNil: \"thd (TNil b) = undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thd (TNil b) = undefined", "by(simp add: thd_def)"], ["", "lemma thd_tllist_of_llist [simp]: \"thd (tllist_of_llist b xs) = lhd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thd (tllist_of_llist b xs) = lhd xs", "by(cases xs)(simp_all add: thd_TNil lhd_LNil)"], ["", "lemma ttl_tllist_of_llist [simp]: \"ttl (tllist_of_llist b xs) = tllist_of_llist b (ltl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ttl (tllist_of_llist b xs) = tllist_of_llist b (ltl xs)", "by(cases xs) simp_all"], ["", "lemma llist_of_tllist_eq_LNil:\n  \"llist_of_tllist xs = LNil \\<longleftrightarrow> is_TNil xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_of_tllist xs = LNil) = is_TNil xs", "using llist_of_tllist.disc_iff(1)"], ["proof (prove)\nusing this:\n  lnull (llist_of_tllist ?xs) = is_TNil ?xs\n\ngoal (1 subgoal):\n 1. (llist_of_tllist xs = LNil) = is_TNil xs", "unfolding lnull_def"], ["proof (prove)\nusing this:\n  (llist_of_tllist ?xs = LNil) = is_TNil ?xs\n\ngoal (1 subgoal):\n 1. (llist_of_tllist xs = LNil) = is_TNil xs", "."], ["", "simps_of_case llist_of_tllist_simps [simp, code, nitpick_simp]: llist_of_tllist.code"], ["", "lemmas llist_of_tllist_TNil = llist_of_tllist_simps(1)\n  and llist_of_tllist_TCons = llist_of_tllist_simps(2)"], ["", "declare llist_of_tllist.sel [simp del]"], ["", "lemma lhd_llist_of_tllist [simp]: \"\\<not> is_TNil xs \\<Longrightarrow> lhd (llist_of_tllist xs) = thd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_TNil xs \\<Longrightarrow> lhd (llist_of_tllist xs) = thd xs", "by(cases xs) simp_all"], ["", "lemma ltl_llist_of_tllist [simp]:\n  \"ltl (llist_of_tllist xs) = llist_of_tllist (ttl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (llist_of_tllist xs) = llist_of_tllist (ttl xs)", "by(cases xs) simp_all"], ["", "lemma tllist_of_llist_cong [cong]:\n  assumes \"xs = xs'\" \"lfinite xs' \\<Longrightarrow> b = b'\"\n  shows \"tllist_of_llist b xs = tllist_of_llist b' xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_of_llist b xs = tllist_of_llist b' xs'", "proof(unfold \\<open>xs = xs'\\<close>)"], ["proof (state)\ngoal (1 subgoal):\n 1. tllist_of_llist b xs' = tllist_of_llist b' xs'", "from assms"], ["proof (chain)\npicking this:\n  xs = xs'\n  lfinite xs' \\<Longrightarrow> b = b'", "have \"lfinite xs' \\<longrightarrow> b = b'\""], ["proof (prove)\nusing this:\n  xs = xs'\n  lfinite xs' \\<Longrightarrow> b = b'\n\ngoal (1 subgoal):\n 1. lfinite xs' \\<longrightarrow> b = b'", "by simp"], ["proof (state)\nthis:\n  lfinite xs' \\<longrightarrow> b = b'\n\ngoal (1 subgoal):\n 1. tllist_of_llist b xs' = tllist_of_llist b' xs'", "thus \"tllist_of_llist b xs' = tllist_of_llist b' xs'\""], ["proof (prove)\nusing this:\n  lfinite xs' \\<longrightarrow> b = b'\n\ngoal (1 subgoal):\n 1. tllist_of_llist b xs' = tllist_of_llist b' xs'", "by(coinduction arbitrary: xs') auto"], ["proof (state)\nthis:\n  tllist_of_llist b xs' = tllist_of_llist b' xs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llist_of_tllist_inverse [simp]: \n  \"tllist_of_llist (terminal b) (llist_of_tllist b) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_of_llist (terminal b) (llist_of_tllist b) = b", "by(coinduction arbitrary: b) simp_all"], ["", "lemma tllist_of_llist_eq [simp]: \"tllist_of_llist b' xs = TNil b \\<longleftrightarrow> b = b' \\<and> xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tllist_of_llist b' xs = TNil b) = (b = b' \\<and> xs = LNil)", "by(cases xs) auto"], ["", "lemma TNil_eq_tllist_of_llist [simp]: \"TNil b = tllist_of_llist b' xs \\<longleftrightarrow> b = b' \\<and> xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (TNil b = tllist_of_llist b' xs) = (b = b' \\<and> xs = LNil)", "by(cases xs) auto"], ["", "lemma tllist_of_llist_inject [simp]:\n  \"tllist_of_llist b xs = tllist_of_llist c ys \\<longleftrightarrow> xs = ys \\<and> (lfinite ys \\<longrightarrow> b = c)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (tllist_of_llist b xs = tllist_of_llist c ys) =\n    (xs = ys \\<and> (lfinite ys \\<longrightarrow> b = c))", "proof(intro iffI conjI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. tllist_of_llist b xs = tllist_of_llist c ys \\<Longrightarrow> xs = ys\n 2. \\<lbrakk>tllist_of_llist b xs = tllist_of_llist c ys;\n     lfinite ys\\<rbrakk>\n    \\<Longrightarrow> b = c\n 3. xs = ys \\<and> (lfinite ys \\<longrightarrow> b = c) \\<Longrightarrow>\n    tllist_of_llist b xs = tllist_of_llist c ys", "assume ?rhs"], ["proof (state)\nthis:\n  xs = ys \\<and> (lfinite ys \\<longrightarrow> b = c)\n\ngoal (3 subgoals):\n 1. tllist_of_llist b xs = tllist_of_llist c ys \\<Longrightarrow> xs = ys\n 2. \\<lbrakk>tllist_of_llist b xs = tllist_of_llist c ys;\n     lfinite ys\\<rbrakk>\n    \\<Longrightarrow> b = c\n 3. xs = ys \\<and> (lfinite ys \\<longrightarrow> b = c) \\<Longrightarrow>\n    tllist_of_llist b xs = tllist_of_llist c ys", "thus ?lhs"], ["proof (prove)\nusing this:\n  xs = ys \\<and> (lfinite ys \\<longrightarrow> b = c)\n\ngoal (1 subgoal):\n 1. tllist_of_llist b xs = tllist_of_llist c ys", "by(auto intro: tllist_of_llist_cong)"], ["proof (state)\nthis:\n  tllist_of_llist b xs = tllist_of_llist c ys\n\ngoal (2 subgoals):\n 1. tllist_of_llist b xs = tllist_of_llist c ys \\<Longrightarrow> xs = ys\n 2. \\<lbrakk>tllist_of_llist b xs = tllist_of_llist c ys;\n     lfinite ys\\<rbrakk>\n    \\<Longrightarrow> b = c", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. tllist_of_llist b xs = tllist_of_llist c ys \\<Longrightarrow> xs = ys\n 2. \\<lbrakk>tllist_of_llist b xs = tllist_of_llist c ys;\n     lfinite ys\\<rbrakk>\n    \\<Longrightarrow> b = c", "assume ?lhs"], ["proof (state)\nthis:\n  tllist_of_llist b xs = tllist_of_llist c ys\n\ngoal (2 subgoals):\n 1. tllist_of_llist b xs = tllist_of_llist c ys \\<Longrightarrow> xs = ys\n 2. \\<lbrakk>tllist_of_llist b xs = tllist_of_llist c ys;\n     lfinite ys\\<rbrakk>\n    \\<Longrightarrow> b = c", "thus \"xs = ys\""], ["proof (prove)\nusing this:\n  tllist_of_llist b xs = tllist_of_llist c ys\n\ngoal (1 subgoal):\n 1. xs = ys", "by(coinduction arbitrary: xs ys)(auto simp add: lnull_def neq_LNil_conv)"], ["proof (state)\nthis:\n  xs = ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tllist_of_llist b xs = tllist_of_llist c ys;\n     lfinite ys\\<rbrakk>\n    \\<Longrightarrow> b = c", "assume \"lfinite ys\""], ["proof (state)\nthis:\n  lfinite ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tllist_of_llist b xs = tllist_of_llist c ys;\n     lfinite ys\\<rbrakk>\n    \\<Longrightarrow> b = c", "thus \"b = c\""], ["proof (prove)\nusing this:\n  lfinite ys\n\ngoal (1 subgoal):\n 1. b = c", "using \\<open>?lhs\\<close>"], ["proof (prove)\nusing this:\n  lfinite ys\n  tllist_of_llist b xs = tllist_of_llist c ys\n\ngoal (1 subgoal):\n 1. b = c", "unfolding \\<open>xs = ys\\<close>"], ["proof (prove)\nusing this:\n  lfinite ys\n  tllist_of_llist b ys = tllist_of_llist c ys\n\ngoal (1 subgoal):\n 1. b = c", "by(induct) simp_all"], ["proof (state)\nthis:\n  b = c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tllist_of_llist_inverse [simp]:\n  \"llist_of_tllist (tllist_of_llist b xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_of_tllist (tllist_of_llist b xs) = xs", "by(coinduction arbitrary: xs) auto"], ["", "definition cr_tllist :: \"('a llist \\<times> 'b) \\<Rightarrow> ('a, 'b) tllist \\<Rightarrow> bool\"\n  where \"cr_tllist \\<equiv> (\\<lambda>(xs, b) ys. tllist_of_llist b xs = ys)\""], ["", "lemma Quotient_tllist:\n  \"Quotient (\\<lambda>(xs, a) (ys, b). xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n     (\\<lambda>(xs, a). tllist_of_llist a xs) (\\<lambda>ys. (llist_of_tllist ys, terminal ys)) cr_tllist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Quotient\n     (\\<lambda>(xs, a) (ys, b).\n         xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n     (\\<lambda>(xs, a). tllist_of_llist a xs)\n     (\\<lambda>ys. (llist_of_tllist ys, terminal ys)) cr_tllist", "unfolding Quotient_alt_def cr_tllist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b.\n        (case a of (xs, b) \\<Rightarrow> (=) (tllist_of_llist b xs))\n         b \\<longrightarrow>\n        (case a of (xs, a) \\<Rightarrow> tllist_of_llist a xs) = b) \\<and>\n    (\\<forall>b.\n        (case (llist_of_tllist b, terminal b) of\n         (xs, b) \\<Rightarrow> (=) (tllist_of_llist b xs))\n         b) \\<and>\n    (\\<forall>x y.\n        (case x of\n         (xs, a) \\<Rightarrow>\n           \\<lambda>(ys, b).\n              xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n         y =\n        ((case x of (xs, b) \\<Rightarrow> (=) (tllist_of_llist b xs))\n          (case x of (xs, a) \\<Rightarrow> tllist_of_llist a xs) \\<and>\n         (case y of (xs, b) \\<Rightarrow> (=) (tllist_of_llist b xs))\n          (case y of (xs, a) \\<Rightarrow> tllist_of_llist a xs) \\<and>\n         (case x of (xs, a) \\<Rightarrow> tllist_of_llist a xs) =\n         (case y of (xs, a) \\<Rightarrow> tllist_of_llist a xs)))", "by(auto intro: tllist_of_llist_cong)"], ["", "lemma reflp_tllist: \"reflp (\\<lambda>(xs, a) (ys, b). xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflp\n     (\\<lambda>(xs, a) (ys, b).\n         xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))", "by(simp add: reflp_def)"], ["", "setup_lifting Quotient_tllist reflp_tllist"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma TNil_transfer [transfer_rule]:\n  \"(B ===> pcr_tllist A B) (Pair LNil) TNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B ===> pcr_tllist A B) (Pair LNil) TNil", "by(force simp add: pcr_tllist_def cr_tllist_def)"], ["", "lemma TCons_transfer [transfer_rule]:\n  \"(A ===> pcr_tllist A B ===> pcr_tllist A B) (apfst \\<circ> LCons) TCons\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> pcr_tllist A B ===> pcr_tllist A B) (apfst \\<circ> LCons) TCons", "by(force simp add: pcr_tllist_def llist_all2_LCons1 cr_tllist_def)"], ["", "lemma tmap_tllist_of_llist:\n  \"tmap f g (tllist_of_llist b xs) = tllist_of_llist (g b) (lmap f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tmap f g (tllist_of_llist b xs) = tllist_of_llist (g b) (lmap f xs)", "by(coinduction arbitrary: xs)(auto simp add: tmap_is_TNil)"], ["", "lemma tmap_transfer [transfer_rule]:\n  \"((=) ===> (=) ===> pcr_tllist (=) (=) ===> pcr_tllist (=) (=)) (map_prod \\<circ> lmap) tmap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> pcr_tllist (=) (=) ===> pcr_tllist (=) (=))\n     (map_prod \\<circ> lmap) tmap", "by(force simp add: cr_tllist_def tllist.pcr_cr_eq tmap_tllist_of_llist)"], ["", "lemma lset_llist_of_tllist [simp]:\n  \"lset (llist_of_tllist xs) = tset xs\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (llist_of_tllist xs) = tset xs", "proof(intro set_eqI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> lset (llist_of_tllist xs) \\<Longrightarrow> x \\<in> tset xs\n 2. \\<And>x.\n       x \\<in> tset xs \\<Longrightarrow> x \\<in> lset (llist_of_tllist xs)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> lset (llist_of_tllist xs) \\<Longrightarrow> x \\<in> tset xs\n 2. \\<And>x.\n       x \\<in> tset xs \\<Longrightarrow> x \\<in> lset (llist_of_tllist xs)", "assume \"x \\<in> ?lhs\""], ["proof (state)\nthis:\n  x \\<in> lset (llist_of_tllist xs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> lset (llist_of_tllist xs) \\<Longrightarrow> x \\<in> tset xs\n 2. \\<And>x.\n       x \\<in> tset xs \\<Longrightarrow> x \\<in> lset (llist_of_tllist xs)", "thus \"x \\<in> ?rhs\""], ["proof (prove)\nusing this:\n  x \\<in> lset (llist_of_tllist xs)\n\ngoal (1 subgoal):\n 1. x \\<in> tset xs", "by(induct \"llist_of_tllist xs\" arbitrary: xs rule: llist_set_induct)(auto simp: tllist.set_sel(2))"], ["proof (state)\nthis:\n  x \\<in> tset xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tset xs \\<Longrightarrow> x \\<in> lset (llist_of_tllist xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tset xs \\<Longrightarrow> x \\<in> lset (llist_of_tllist xs)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tset xs \\<Longrightarrow> x \\<in> lset (llist_of_tllist xs)", "assume \"x \\<in> ?rhs\""], ["proof (state)\nthis:\n  x \\<in> tset xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tset xs \\<Longrightarrow> x \\<in> lset (llist_of_tllist xs)", "thus \"x \\<in> ?lhs\""], ["proof (prove)\nusing this:\n  x \\<in> tset xs\n\ngoal (1 subgoal):\n 1. x \\<in> lset (llist_of_tllist xs)", "proof(induct rule: tllist_set_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<not> is_TNil xs \\<Longrightarrow>\n       thd xs \\<in> lset (llist_of_tllist xs)\n 2. \\<And>xs y.\n       \\<lbrakk>\\<not> is_TNil xs; y \\<in> tset (ttl xs);\n        y \\<in> lset (llist_of_tllist (ttl xs))\\<rbrakk>\n       \\<Longrightarrow> y \\<in> lset (llist_of_tllist xs)", "case (find xs)"], ["proof (state)\nthis:\n  \\<not> is_TNil xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<not> is_TNil xs \\<Longrightarrow>\n       thd xs \\<in> lset (llist_of_tllist xs)\n 2. \\<And>xs y.\n       \\<lbrakk>\\<not> is_TNil xs; y \\<in> tset (ttl xs);\n        y \\<in> lset (llist_of_tllist (ttl xs))\\<rbrakk>\n       \\<Longrightarrow> y \\<in> lset (llist_of_tllist xs)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> is_TNil xs\n\ngoal (1 subgoal):\n 1. thd xs \\<in> lset (llist_of_tllist xs)", "by(cases xs) auto"], ["proof (state)\nthis:\n  thd xs \\<in> lset (llist_of_tllist xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs y.\n       \\<lbrakk>\\<not> is_TNil xs; y \\<in> tset (ttl xs);\n        y \\<in> lset (llist_of_tllist (ttl xs))\\<rbrakk>\n       \\<Longrightarrow> y \\<in> lset (llist_of_tllist xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs y.\n       \\<lbrakk>\\<not> is_TNil xs; y \\<in> tset (ttl xs);\n        y \\<in> lset (llist_of_tllist (ttl xs))\\<rbrakk>\n       \\<Longrightarrow> y \\<in> lset (llist_of_tllist xs)", "case step"], ["proof (state)\nthis:\n  \\<not> is_TNil xs_\n  y_ \\<in> tset (ttl xs_)\n  y_ \\<in> lset (llist_of_tllist (ttl xs_))\n\ngoal (1 subgoal):\n 1. \\<And>xs y.\n       \\<lbrakk>\\<not> is_TNil xs; y \\<in> tset (ttl xs);\n        y \\<in> lset (llist_of_tllist (ttl xs))\\<rbrakk>\n       \\<Longrightarrow> y \\<in> lset (llist_of_tllist xs)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> is_TNil xs_\n  y_ \\<in> tset (ttl xs_)\n  y_ \\<in> lset (llist_of_tllist (ttl xs_))\n\ngoal (1 subgoal):\n 1. y_ \\<in> lset (llist_of_tllist xs_)", "by(auto simp add: ltl_llist_of_tllist[symmetric] simp del: ltl_llist_of_tllist dest: in_lset_ltlD)"], ["proof (state)\nthis:\n  y_ \\<in> lset (llist_of_tllist xs_)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> lset (llist_of_tllist xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tset_tllist_of_llist [simp]:\n  \"tset (tllist_of_llist b xs) = lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tset (tllist_of_llist b xs) = lset xs", "by(simp add: lset_llist_of_tllist[symmetric] del: lset_llist_of_tllist)"], ["", "lemma tset_transfer [transfer_rule]:\n  \"(pcr_tllist (=) (=) ===> (=)) (lset \\<circ> fst) tset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_tllist (=) (=) ===> (=)) (lset \\<circ> fst) tset", "by(auto simp add: cr_tllist_def tllist.pcr_cr_eq)"], ["", "lemma is_TNil_transfer [transfer_rule]:\n  \"(pcr_tllist (=) (=) ===> (=)) (\\<lambda>(xs, b). lnull xs) is_TNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_tllist (=) (=) ===> (=)) (\\<lambda>(xs, b). lnull xs) is_TNil", "by(auto simp add: tllist.pcr_cr_eq cr_tllist_def)"], ["", "lemma thd_transfer [transfer_rule]:\n  \"(pcr_tllist (=) (=) ===> (=)) (lhd \\<circ> fst) thd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_tllist (=) (=) ===> (=)) (lhd \\<circ> fst) thd", "by(auto simp add: cr_tllist_def tllist.pcr_cr_eq)"], ["", "lemma ttl_transfer [transfer_rule]:\n  \"(pcr_tllist A B ===> pcr_tllist A B) (apfst ltl) ttl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_tllist A B ===> pcr_tllist A B) (apfst ltl) ttl", "by(force simp add: pcr_tllist_def cr_tllist_def intro: llist_all2_ltlI)"], ["", "lemma llist_of_tllist_transfer [transfer_rule]:\n  \"(pcr_tllist (=) B ===> (=)) fst llist_of_tllist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_tllist (=) B ===> (=)) fst llist_of_tllist", "by(auto simp add: pcr_tllist_def cr_tllist_def llist.rel_eq)"], ["", "lemma tllist_of_llist_transfer [transfer_rule]:\n  \"((=) ===> (=) ===> pcr_tllist (=) (=)) (\\<lambda>b xs. (xs, b)) tllist_of_llist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> pcr_tllist (=) (=)) (\\<lambda>b xs. (xs, b))\n     tllist_of_llist", "by(auto simp add: tllist.pcr_cr_eq cr_tllist_def)"], ["", "lemma terminal_tllist_of_llist_lfinite [simp]:\n  \"lfinite xs \\<Longrightarrow> terminal (tllist_of_llist b xs) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> terminal (tllist_of_llist b xs) = b", "by(induct rule: lfinite.induct) simp_all"], ["", "lemma set2_tllist_tllist_of_llist [simp]:\n  \"set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})", "proof(cases \"lfinite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})", "case True"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})", "thus ?thesis"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})", "by(induct) auto"], ["proof (state)\nthis:\n  set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})", "{"], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})", "assume \"x \\<in> set2_tllist (tllist_of_llist b xs)\""], ["proof (state)\nthis:\n  x \\<in> set2_tllist (tllist_of_llist b xs)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})", "hence False"], ["proof (prove)\nusing this:\n  x \\<in> set2_tllist (tllist_of_llist b xs)\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  x \\<in> set2_tllist (tllist_of_llist b xs)\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. False", "by(induct \"tllist_of_llist b xs\" arbitrary: xs rule: set2_tllist_induct) fastforce+"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> set2_tllist (tllist_of_llist b xs) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?x2 \\<in> set2_tllist (tllist_of_llist b xs) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})", "using False"], ["proof (prove)\nusing this:\n  ?x2 \\<in> set2_tllist (tllist_of_llist b xs) \\<Longrightarrow> False\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})", "by auto"], ["proof (state)\nthis:\n  set2_tllist (tllist_of_llist b xs) = (if lfinite xs then {b} else {})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set2_tllist_transfer [transfer_rule]:\n  \"(pcr_tllist A B ===> rel_set B) (\\<lambda>(xs, b). if lfinite xs then {b} else {}) set2_tllist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_tllist A B ===> rel_set B)\n     (\\<lambda>(xs, b). if lfinite xs then {b} else {}) set2_tllist", "by(auto 4 4 simp add: pcr_tllist_def cr_tllist_def dest: llist_all2_lfiniteD intro: rel_setI)"], ["", "lemma tllist_all2_transfer [transfer_rule]:\n  \"((=) ===> (=) ===> pcr_tllist (=) (=) ===> pcr_tllist (=) (=) ===> (=))\n     (\\<lambda>P Q (xs, b) (ys, b'). llist_all2 P xs ys \\<and> (lfinite xs \\<longrightarrow> Q b b')) tllist_all2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> pcr_tllist (=) (=) ===> pcr_tllist (=) (=) ===> (=))\n     (\\<lambda>P Q (xs, b) (ys, b').\n         llist_all2 P xs ys \\<and> (lfinite xs \\<longrightarrow> Q b b'))\n     tllist_all2", "unfolding tllist.pcr_cr_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> cr_tllist ===> cr_tllist ===> (=))\n     (\\<lambda>P Q (xs, b) (ys, b').\n         llist_all2 P xs ys \\<and> (lfinite xs \\<longrightarrow> Q b b'))\n     tllist_all2", "apply(rule rel_funI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>x = y; xa = ya; cr_tllist xb yb; cr_tllist xc yc\\<rbrakk>\n       \\<Longrightarrow> (case xb of\n                          (xs, b) \\<Rightarrow>\n                            \\<lambda>(ys, b').\n                               llist_all2 x xs ys \\<and>\n                               (lfinite xs \\<longrightarrow> xa b b'))\n                          xc =\n                         tllist_all2 y ya yb yc", "apply(clarsimp simp add: cr_tllist_def llist_all2_def tllist_all2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ya a b aa ba.\n       (((BNF_Def.Grp {x. lset x \\<subseteq> {(x, ya). y x ya}}\n           (lmap fst))\\<inverse>\\<inverse> OO\n         BNF_Def.Grp {x. lset x \\<subseteq> {(x, ya). y x ya}} (lmap snd))\n         a aa \\<and>\n        (lfinite a \\<longrightarrow> ya b ba)) =\n       ((BNF_Def.Grp\n          {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n              set2_tllist x \\<subseteq> {(x, y). ya x y}}\n          (tmap fst fst))\\<inverse>\\<inverse> OO\n        BNF_Def.Grp\n         {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n             set2_tllist x \\<subseteq> {(x, y). ya x y}}\n         (tmap snd snd))\n        (tllist_of_llist b a) (tllist_of_llist ba aa)", "apply(safe elim!: GrpE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>lset bb \\<subseteq> {(x, ya). y x ya};\n        lset bb \\<subseteq> {(x, ya). y x ya};\n        \\<not> lfinite (lmap fst bb)\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp\n                            {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n                                set2_tllist x \\<subseteq> {(x, y). ya x y}}\n                            (tmap fst fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n                               set2_tllist x \\<subseteq> {(x, y). ya x y}}\n                           (tmap snd snd))\n                          (tllist_of_llist b (lmap fst bb))\n                          (tllist_of_llist ba (lmap snd bb))\n 2. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>lset bb \\<subseteq> {(x, ya). y x ya};\n        lset bb \\<subseteq> {(x, ya). y x ya}; ya b ba\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp\n                            {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n                                set2_tllist x \\<subseteq> {(x, y). ya x y}}\n                            (tmap fst fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n                               set2_tllist x \\<subseteq> {(x, y). ya x y}}\n                           (tmap snd snd))\n                          (tllist_of_llist b (lmap fst bb))\n                          (tllist_of_llist ba (lmap snd bb))\n 3. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y};\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp\n                            {x. lset x \\<subseteq> {(x, ya). y x ya}}\n                            (lmap fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. lset x \\<subseteq> {(x, ya). y x ya}}\n                           (lmap snd))\n                          a aa\n 4. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y};\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}; lfinite a\\<rbrakk>\n       \\<Longrightarrow> ya b ba", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y ya b ba bb.\n       \\<lbrakk>lset bb \\<subseteq> {(x, ya). y x ya};\n        \\<not> lfinite bb\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp\n                            {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n                                set2_tllist x \\<subseteq> {(x, y). ya x y}}\n                            (tmap fst fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n                               set2_tllist x \\<subseteq> {(x, y). ya x y}}\n                           (tmap snd snd))\n                          (tllist_of_llist b (lmap fst bb))\n                          (tllist_of_llist ba (lmap snd bb))\n 2. \\<And>y ya b ba bb.\n       \\<lbrakk>lset bb \\<subseteq> {(x, ya). y x ya}; ya b ba\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp\n                            {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n                                set2_tllist x \\<subseteq> {(x, y). ya x y}}\n                            (tmap fst fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n                               set2_tllist x \\<subseteq> {(x, y). ya x y}}\n                           (tmap snd snd))\n                          (tllist_of_llist b (lmap fst bb))\n                          (tllist_of_llist ba (lmap snd bb))\n 3. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp\n                            {x. lset x \\<subseteq> {(x, ya). y x ya}}\n                            (lmap fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. lset x \\<subseteq> {(x, ya). y x ya}}\n                           (lmap snd))\n                          a aa\n 4. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}; lfinite a\\<rbrakk>\n       \\<Longrightarrow> ya b ba", "apply(rule_tac b=\"tllist_of_llist (b, ba) bb\" in relcomppI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>y ya b ba bb.\n       \\<lbrakk>lset bb \\<subseteq> {(x, ya). y x ya};\n        \\<not> lfinite bb\\<rbrakk>\n       \\<Longrightarrow> (BNF_Def.Grp\n                           {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n                               set2_tllist x \\<subseteq> {(x, y). ya x y}}\n                           (tmap fst fst))\\<inverse>\\<inverse>\n                          (tllist_of_llist b (lmap fst bb))\n                          (tllist_of_llist (b, ba) bb)\n 2. \\<And>y ya b ba bb.\n       \\<lbrakk>lset bb \\<subseteq> {(x, ya). y x ya};\n        \\<not> lfinite bb\\<rbrakk>\n       \\<Longrightarrow> BNF_Def.Grp\n                          {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n                              set2_tllist x \\<subseteq> {(x, y). ya x y}}\n                          (tmap snd snd) (tllist_of_llist (b, ba) bb)\n                          (tllist_of_llist ba (lmap snd bb))\n 3. \\<And>y ya b ba bb.\n       \\<lbrakk>lset bb \\<subseteq> {(x, ya). y x ya}; ya b ba\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp\n                            {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n                                set2_tllist x \\<subseteq> {(x, y). ya x y}}\n                            (tmap fst fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n                               set2_tllist x \\<subseteq> {(x, y). ya x y}}\n                           (tmap snd snd))\n                          (tllist_of_llist b (lmap fst bb))\n                          (tllist_of_llist ba (lmap snd bb))\n 4. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp\n                            {x. lset x \\<subseteq> {(x, ya). y x ya}}\n                            (lmap fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. lset x \\<subseteq> {(x, ya). y x ya}}\n                           (lmap snd))\n                          a aa\n 5. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}; lfinite a\\<rbrakk>\n       \\<Longrightarrow> ya b ba", "apply(auto intro!: GrpI simp add: tmap_tllist_of_llist)[2]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y ya b ba bb.\n       \\<lbrakk>lset bb \\<subseteq> {(x, ya). y x ya}; ya b ba\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp\n                            {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n                                set2_tllist x \\<subseteq> {(x, y). ya x y}}\n                            (tmap fst fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n                               set2_tllist x \\<subseteq> {(x, y). ya x y}}\n                           (tmap snd snd))\n                          (tllist_of_llist b (lmap fst bb))\n                          (tllist_of_llist ba (lmap snd bb))\n 2. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp\n                            {x. lset x \\<subseteq> {(x, ya). y x ya}}\n                            (lmap fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. lset x \\<subseteq> {(x, ya). y x ya}}\n                           (lmap snd))\n                          a aa\n 3. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}; lfinite a\\<rbrakk>\n       \\<Longrightarrow> ya b ba", "apply(rule_tac b=\"tllist_of_llist (b, ba) bb\" in relcomppI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y ya b ba bb.\n       \\<lbrakk>lset bb \\<subseteq> {(x, ya). y x ya}; ya b ba\\<rbrakk>\n       \\<Longrightarrow> (BNF_Def.Grp\n                           {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n                               set2_tllist x \\<subseteq> {(x, y). ya x y}}\n                           (tmap fst fst))\\<inverse>\\<inverse>\n                          (tllist_of_llist b (lmap fst bb))\n                          (tllist_of_llist (b, ba) bb)\n 2. \\<And>y ya b ba bb.\n       \\<lbrakk>lset bb \\<subseteq> {(x, ya). y x ya}; ya b ba\\<rbrakk>\n       \\<Longrightarrow> BNF_Def.Grp\n                          {x. tset x \\<subseteq> {(x, ya). y x ya} \\<and>\n                              set2_tllist x \\<subseteq> {(x, y). ya x y}}\n                          (tmap snd snd) (tllist_of_llist (b, ba) bb)\n                          (tllist_of_llist ba (lmap snd bb))\n 3. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp\n                            {x. lset x \\<subseteq> {(x, ya). y x ya}}\n                            (lmap fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. lset x \\<subseteq> {(x, ya). y x ya}}\n                           (lmap snd))\n                          a aa\n 4. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}; lfinite a\\<rbrakk>\n       \\<Longrightarrow> ya b ba", "apply(auto simp add: tmap_tllist_of_llist intro!: GrpI split: if_split_asm)[2]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp\n                            {x. lset x \\<subseteq> {(x, ya). y x ya}}\n                            (lmap fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. lset x \\<subseteq> {(x, ya). y x ya}}\n                           (lmap snd))\n                          a aa\n 2. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}; lfinite a\\<rbrakk>\n       \\<Longrightarrow> ya b ba", "apply(rule_tac b=\"llist_of_tllist bb\" in relcomppI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}\\<rbrakk>\n       \\<Longrightarrow> (BNF_Def.Grp\n                           {x. lset x \\<subseteq> {(x, ya). y x ya}}\n                           (lmap fst))\\<inverse>\\<inverse>\n                          a (llist_of_tllist bb)\n 2. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}\\<rbrakk>\n       \\<Longrightarrow> BNF_Def.Grp\n                          {x. lset x \\<subseteq> {(x, ya). y x ya}}\n                          (lmap snd) (llist_of_tllist bb) aa\n 3. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}; lfinite a\\<rbrakk>\n       \\<Longrightarrow> ya b ba", "apply(auto intro!: GrpI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}\\<rbrakk>\n       \\<Longrightarrow> lmap fst (llist_of_tllist bb) = a\n 2. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}\\<rbrakk>\n       \\<Longrightarrow> lmap snd (llist_of_tllist bb) = aa\n 3. \\<And>y ya a b aa ba bb.\n       \\<lbrakk>tmap snd snd bb = tllist_of_llist ba aa;\n        tmap fst fst bb = tllist_of_llist b a;\n        tset bb \\<subseteq> {(x, ya). y x ya};\n        set2_tllist bb \\<subseteq> {(x, y). ya x y}; lfinite a\\<rbrakk>\n       \\<Longrightarrow> ya b ba", "apply(transfer, auto intro: GrpI split: if_split_asm)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Library function definitions\\<close>"], ["", "text \\<open>\n  We lift the constants from @{typ \"'a llist\"} to @{typ \"('a, 'b) tllist\"} using the lifting package.\n  This way, many results are transferred easily.\n\\<close>"], ["", "lift_definition tappend :: \"('a, 'b) tllist \\<Rightarrow> ('b \\<Rightarrow> ('a, 'c) tllist) \\<Rightarrow> ('a, 'c) tllist\"\nis \"\\<lambda>(xs, b) f. apfst (lappend xs) (f b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2 fun1 fun2.\n       \\<lbrakk>(case prod1 of\n                 (xs, a) \\<Rightarrow>\n                   \\<lambda>(ys, b).\n                      xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n                 prod2;\n        \\<And>x.\n           (case fun1 x of\n            (xs, a) \\<Rightarrow>\n              \\<lambda>(ys, b).\n                 xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n            (fun2 x)\\<rbrakk>\n       \\<Longrightarrow> (case (case prod1 of\n                                (xs, b) \\<Rightarrow>\n                                  \\<lambda>f. apfst (lappend xs) (f b))\n                                fun1 of\n                          (xs, a) \\<Rightarrow>\n                            \\<lambda>(ys, b).\n                               xs = ys \\<and>\n                               (lfinite ys \\<longrightarrow> a = b))\n                          ((case prod2 of\n                            (xs, b) \\<Rightarrow>\n                              \\<lambda>f. apfst (lappend xs) (f b))\n                            fun2)", "by(auto simp add: split_def lappend_inf)"], ["", "lift_definition lappendt :: \"'a llist \\<Rightarrow> ('a, 'b) tllist \\<Rightarrow> ('a, 'b) tllist\"\nis \"apfst \\<circ> lappend\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>llist prod1 prod2.\n       (case prod1 of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        prod2 \\<Longrightarrow>\n       (case (apfst \\<circ> lappend) llist prod1 of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        ((apfst \\<circ> lappend) llist prod2)", "by(simp add: split_def)"], ["", "lift_definition tfilter :: \"'b \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> ('a, 'b) tllist \\<Rightarrow> ('a, 'b) tllist\"\nis \"\\<lambda>b P (xs, b'). (lfilter P xs, if lfinite xs then b' else b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b fun prod1 prod2.\n       (case prod1 of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        prod2 \\<Longrightarrow>\n       (case case prod1 of\n             (xs, b') \\<Rightarrow>\n               (lfilter fun xs, if lfinite xs then b' else b) of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        (case prod2 of\n         (xs, b') \\<Rightarrow>\n           (lfilter fun xs, if lfinite xs then b' else b))", "by(simp add: split_beta)"], ["", "lift_definition tconcat :: \"'b \\<Rightarrow> ('a llist, 'b) tllist \\<Rightarrow> ('a, 'b) tllist\"\nis \"\\<lambda>b (xss, b'). (lconcat xss, if lfinite xss then b' else b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b prod1 prod2.\n       (case prod1 of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        prod2 \\<Longrightarrow>\n       (case case prod1 of\n             (xss, b') \\<Rightarrow>\n               (lconcat xss, if lfinite xss then b' else b) of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        (case prod2 of\n         (xss, b') \\<Rightarrow>\n           (lconcat xss, if lfinite xss then b' else b))", "by(simp add: split_beta)"], ["", "lift_definition tnth :: \"('a, 'b) tllist \\<Rightarrow> nat \\<Rightarrow> 'a\"\nis \"lnth \\<circ> fst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2.\n       (case prod1 of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        prod2 \\<Longrightarrow>\n       (lnth \\<circ> fst) prod1 = (lnth \\<circ> fst) prod2", "by(auto)"], ["", "lift_definition tlength :: \"('a, 'b) tllist \\<Rightarrow> enat\"\nis \"llength \\<circ> fst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2.\n       (case prod1 of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        prod2 \\<Longrightarrow>\n       (llength \\<circ> fst) prod1 = (llength \\<circ> fst) prod2", "by auto"], ["", "lift_definition tdropn :: \"nat \\<Rightarrow> ('a, 'b) tllist \\<Rightarrow> ('a, 'b) tllist\"\nis \"apfst \\<circ> ldropn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat prod1 prod2.\n       (case prod1 of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        prod2 \\<Longrightarrow>\n       (case (apfst \\<circ> ldropn) nat prod1 of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        ((apfst \\<circ> ldropn) nat prod2)", "by auto"], ["", "abbreviation tfinite :: \"('a, 'b) tllist \\<Rightarrow> bool\"\nwhere \"tfinite xs \\<equiv> lfinite (llist_of_tllist xs)\""], ["", "subsection \\<open>@{term \"tfinite\"}\\<close>"], ["", "lemma tfinite_induct [consumes 1, case_names TNil TCons]:\n  assumes \"tfinite xs\"\n  and \"\\<And>y. P (TNil y)\"\n  and \"\\<And>x xs. \\<lbrakk>tfinite xs; P xs\\<rbrakk> \\<Longrightarrow> P (TCons x xs)\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "using assms"], ["proof (prove)\nusing this:\n  tfinite xs\n  P (TNil ?y)\n  \\<lbrakk>tfinite ?xs; P ?xs\\<rbrakk> \\<Longrightarrow> P (TCons ?x ?xs)\n\ngoal (1 subgoal):\n 1. P xs", "by transfer (clarsimp, erule lfinite.induct)"], ["", "lemma is_TNil_tfinite [simp]: \"is_TNil xs \\<Longrightarrow> tfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_TNil xs \\<Longrightarrow> tfinite xs", "by transfer clarsimp"], ["", "subsection \\<open>The terminal element @{term \"terminal\"}\\<close>"], ["", "lemma terminal_tinfinite:\n  assumes \"\\<not> tfinite xs\"\n  shows \"terminal xs = undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal xs = undefined", "unfolding terminal0_terminal[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal0 xs = undefined", "using assms"], ["proof (prove)\nusing this:\n  \\<not> tfinite xs\n\ngoal (1 subgoal):\n 1. terminal0 xs = undefined", "apply(rule contrapos_np)"], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal0 xs \\<noteq> undefined \\<Longrightarrow> tfinite xs", "by(induct xs rule: terminal0.raw_induct[rotated 1, OF refl, consumes 1])(auto split: tllist.split_asm)"], ["", "lemma terminal_tllist_of_llist:\n  \"terminal (tllist_of_llist y xs) = (if lfinite xs then y else undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal (tllist_of_llist y xs) = (if lfinite xs then y else undefined)", "by(simp add: terminal_tinfinite)"], ["", "lemma terminal_transfer [transfer_rule]:\n  \"(pcr_tllist A (=) ===> (=)) (\\<lambda>(xs, b). if lfinite xs then b else undefined) terminal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_tllist A (=) ===> (=))\n     (\\<lambda>(xs, b). if lfinite xs then b else undefined) terminal", "by(force simp add: cr_tllist_def pcr_tllist_def terminal_tllist_of_llist dest: llist_all2_lfiniteD)"], ["", "lemma terminal_tmap [simp]: \"tfinite xs \\<Longrightarrow> terminal (tmap f g xs) = g (terminal xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tfinite xs \\<Longrightarrow> terminal (tmap f g xs) = g (terminal xs)", "by(induct rule: tfinite_induct) simp_all"], ["", "subsection \\<open>@{term \"tmap\"}\\<close>"], ["", "lemma tmap_eq_TCons_conv:\n  \"tmap f g xs = TCons y ys \\<longleftrightarrow>\n  (\\<exists>z zs. xs = TCons z zs \\<and> f z = y \\<and> tmap f g zs = ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tmap f g xs = TCons y ys) =\n    (\\<exists>z zs. xs = TCons z zs \\<and> f z = y \\<and> tmap f g zs = ys)", "by(cases xs) simp_all"], ["", "lemma TCons_eq_tmap_conv:\n  \"TCons y ys = tmap f g xs \\<longleftrightarrow>\n  (\\<exists>z zs. xs = TCons z zs \\<and> f z = y \\<and> tmap f g zs = ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (TCons y ys = tmap f g xs) =\n    (\\<exists>z zs. xs = TCons z zs \\<and> f z = y \\<and> tmap f g zs = ys)", "by(cases xs) auto"], ["", "subsection \\<open>Appending two terminated lazy lists @{term \"tappend\" }\\<close>"], ["", "lemma tappend_TNil [simp, code, nitpick_simp]:\n  \"tappend (TNil b) f = f b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tappend (TNil b) f = f b", "by transfer auto"], ["", "lemma tappend_TCons [simp, code, nitpick_simp]:\n  \"tappend (TCons a tr) f = TCons a (tappend tr f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tappend (TCons a tr) f = TCons a (tappend tr f)", "by transfer(auto simp add: apfst_def map_prod_def split: prod.splits)"], ["", "lemma tappend_TNil2 [simp]:\n  \"tappend xs TNil = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tappend xs TNil = xs", "by transfer auto"], ["", "lemma tappend_assoc: \"tappend (tappend xs f) g = tappend xs (\\<lambda>b. tappend (f b) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tappend (tappend xs f) g = tappend xs (\\<lambda>b. tappend (f b) g)", "by transfer(auto simp add: split_beta lappend_assoc)"], ["", "lemma terminal_tappend:\n  \"terminal (tappend xs f) = (if tfinite xs then terminal (f (terminal xs)) else terminal xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal (tappend xs f) =\n    (if tfinite xs then terminal (f (terminal xs)) else terminal xs)", "by transfer(auto simp add: split_beta)"], ["", "lemma tfinite_tappend: \"tfinite (tappend xs f) \\<longleftrightarrow> tfinite xs \\<and> tfinite (f (terminal xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tfinite (tappend xs f) = (tfinite xs \\<and> tfinite (f (terminal xs)))", "by transfer auto"], ["", "lift_definition tcast :: \"('a, 'b) tllist \\<Rightarrow> ('a, 'c) tllist\"\nis \"\\<lambda>(xs, a). (xs, undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2.\n       (case prod1 of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        prod2 \\<Longrightarrow>\n       (case case prod1 of (xs, a) \\<Rightarrow> (xs, undefined) of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        (case prod2 of (xs, a) \\<Rightarrow> (xs, undefined))", "by clarsimp"], ["", "lemma tappend_inf: \"\\<not> tfinite xs \\<Longrightarrow> tappend xs f = tcast xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> tfinite xs \\<Longrightarrow> tappend xs f = tcast xs", "by(transfer)(auto simp add: apfst_def map_prod_def split_beta lappend_inf)"], ["", "text \\<open>@{term tappend} is the monadic bind on @{typ \"('a, 'b) tllist\"}\\<close>"], ["", "lemmas tllist_monad = tappend_TNil tappend_TNil2 tappend_assoc"], ["", "subsection \\<open>Appending a terminated lazy list to a lazy list @{term \"lappendt\"}\\<close>"], ["", "lemma lappendt_LNil [simp, code, nitpick_simp]: \"lappendt LNil tr = tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappendt LNil tr = tr", "by transfer auto"], ["", "lemma lappendt_LCons [simp, code, nitpick_simp]:\n  \"lappendt (LCons x xs) tr = TCons x (lappendt xs tr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappendt (LCons x xs) tr = TCons x (lappendt xs tr)", "by transfer auto"], ["", "lemma terminal_lappendt_lfinite [simp]:\n  \"lfinite xs \\<Longrightarrow> terminal (lappendt xs ys) = terminal ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> terminal (lappendt xs ys) = terminal ys", "by transfer auto"], ["", "lemma tllist_of_llist_eq_lappendt_conv:\n  \"tllist_of_llist a xs = lappendt ys zs \\<longleftrightarrow> \n  (\\<exists>xs' a'. xs = lappend ys xs' \\<and> zs = tllist_of_llist a' xs' \\<and> (lfinite ys \\<longrightarrow> a = a'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tllist_of_llist a xs = lappendt ys zs) =\n    (\\<exists>xs' a'.\n        xs = lappend ys xs' \\<and>\n        zs = tllist_of_llist a' xs' \\<and>\n        (lfinite ys \\<longrightarrow> a = a'))", "by transfer auto"], ["", "lemma tset_lappendt_lfinite [simp]:\n  \"lfinite xs \\<Longrightarrow> tset (lappendt xs ys) = lset xs \\<union> tset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    tset (lappendt xs ys) = lset xs \\<union> tset ys", "by transfer auto"], ["", "subsection \\<open>Filtering terminated lazy lists @{term tfilter}\\<close>"], ["", "lemma tfilter_TNil [simp]:\n  \"tfilter b' P (TNil b) = TNil b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tfilter b' P (TNil b) = TNil b", "by transfer auto"], ["", "lemma tfilter_TCons [simp]:\n  \"tfilter b P (TCons a tr) = (if P a then TCons a (tfilter b P tr) else tfilter b P tr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tfilter b P (TCons a tr) =\n    (if P a then TCons a (tfilter b P tr) else tfilter b P tr)", "by transfer auto"], ["", "lemma is_TNil_tfilter[simp]:\n  \"is_TNil (tfilter y P xs) \\<longleftrightarrow> (\\<forall>x \\<in> tset xs. \\<not> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_TNil (tfilter y P xs) = (\\<forall>x\\<in>tset xs. \\<not> P x)", "by transfer auto"], ["", "lemma tfilter_empty_conv:\n  \"tfilter y P xs = TNil y' \\<longleftrightarrow> (\\<forall>x \\<in> tset xs. \\<not> P x) \\<and> (if tfinite xs then terminal xs = y' else y = y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tfilter y P xs = TNil y') =\n    ((\\<forall>x\\<in>tset xs. \\<not> P x) \\<and>\n     (if tfinite xs then terminal xs = y' else y = y'))", "by transfer(clarsimp simp add: lfilter_eq_LNil)"], ["", "lemma tfilter_eq_TConsD:\n  \"tfilter a P ys = TCons x xs \\<Longrightarrow>\n   \\<exists>us vs. ys = lappendt us (TCons x vs) \\<and> lfinite us \\<and> (\\<forall>u\\<in>lset us. \\<not> P u) \\<and> P x \\<and> xs = tfilter a P vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tfilter a P ys = TCons x xs \\<Longrightarrow>\n    \\<exists>us vs.\n       ys = lappendt us (TCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = tfilter a P vs", "by transfer(fastforce dest: lfilter_eq_LConsD[OF sym])"], ["", "text \\<open>Use a version of @{term \"tfilter\"} for code generation that does not evaluate the first argument\\<close>"], ["", "definition tfilter' :: \"(unit \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> ('a, 'b) tllist \\<Rightarrow> ('a, 'b) tllist\"\nwhere [simp, code del]: \"tfilter' b = tfilter (b ())\""], ["", "lemma tfilter_code [code, code_unfold]:\n  \"tfilter = (\\<lambda>b. tfilter' (\\<lambda>_. b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tfilter = (\\<lambda>b. tfilter' (\\<lambda>_. b))", "by simp"], ["", "lemma tfilter'_code [code]:\n  \"tfilter' b' P (TNil b) = TNil b\"\n  \"tfilter' b' P (TCons a tr) = (if P a then TCons a (tfilter' b' P tr) else tfilter' b' P tr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tfilter' b' P (TNil b) = TNil b &&&\n    tfilter' b' P (TCons a tr) =\n    (if P a then TCons a (tfilter' b' P tr) else tfilter' b' P tr)", "by simp_all"], ["", "end"], ["", "hide_const (open) tfilter'"], ["", "subsection \\<open>Concatenating a terminated lazy list of lazy lists @{term tconcat}\\<close>"], ["", "lemma tconcat_TNil [simp]: \"tconcat b (TNil b') = TNil b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tconcat b (TNil b') = TNil b'", "by transfer auto"], ["", "lemma tconcat_TCons [simp]: \"tconcat b (TCons a tr) = lappendt a (tconcat b tr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tconcat b (TCons a tr) = lappendt a (tconcat b tr)", "by transfer auto"], ["", "text \\<open>Use a version of @{term \"tconcat\"} for code generation that does not evaluate the first argument\\<close>"], ["", "definition tconcat' :: \"(unit \\<Rightarrow> 'b) \\<Rightarrow> ('a llist, 'b) tllist \\<Rightarrow> ('a, 'b) tllist\"\nwhere [simp, code del]: \"tconcat' b = tconcat (b ())\""], ["", "lemma tconcat_code [code, code_unfold]: \"tconcat = (\\<lambda>b. tconcat' (\\<lambda>_. b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tconcat = (\\<lambda>b. tconcat' (\\<lambda>_. b))", "by simp"], ["", "lemma tconcat'_code [code]:\n  \"tconcat' b (TNil b') = TNil b'\"\n  \"tconcat' b (TCons a tr) = lappendt a (tconcat' b tr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tconcat' b (TNil b') = TNil b' &&&\n    tconcat' b (TCons a tr) = lappendt a (tconcat' b tr)", "by simp_all"], ["", "hide_const (open) tconcat'"], ["", "subsection \\<open>@{term tllist_all2}\\<close>"], ["", "lemmas tllist_all2_TNil = tllist.rel_inject(1)"], ["", "lemmas tllist_all2_TCons = tllist.rel_inject(2)"], ["", "lemma tllist_all2_TNil1: \"tllist_all2 P Q (TNil b) ts \\<longleftrightarrow> (\\<exists>b'. ts = TNil b' \\<and> Q b b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 P Q (TNil b) ts = (\\<exists>b'. ts = TNil b' \\<and> Q b b')", "by transfer auto"], ["", "lemma tllist_all2_TNil2: \"tllist_all2 P Q ts (TNil b') \\<longleftrightarrow> (\\<exists>b. ts = TNil b \\<and> Q b b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 P Q ts (TNil b') = (\\<exists>b. ts = TNil b \\<and> Q b b')", "by transfer auto"], ["", "lemma tllist_all2_TCons1: \n  \"tllist_all2 P Q (TCons x ts) ts' \\<longleftrightarrow> (\\<exists>x' ts''. ts' = TCons x' ts'' \\<and> P x x' \\<and> tllist_all2 P Q ts ts'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 P Q (TCons x ts) ts' =\n    (\\<exists>x' ts''.\n        ts' = TCons x' ts'' \\<and> P x x' \\<and> tllist_all2 P Q ts ts'')", "by transfer(fastforce simp add: llist_all2_LCons1 dest: llist_all2_lfiniteD)"], ["", "lemma tllist_all2_TCons2: \n  \"tllist_all2 P Q ts' (TCons x ts) \\<longleftrightarrow> (\\<exists>x' ts''. ts' = TCons x' ts'' \\<and> P x' x \\<and> tllist_all2 P Q ts'' ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 P Q ts' (TCons x ts) =\n    (\\<exists>x' ts''.\n        ts' = TCons x' ts'' \\<and> P x' x \\<and> tllist_all2 P Q ts'' ts)", "by transfer(fastforce simp add: llist_all2_LCons2 dest: llist_all2_lfiniteD)"], ["", "lemma tllist_all2_coinduct [consumes 1, case_names tllist_all2, case_conclusion tllist_all2 is_TNil TNil TCons, coinduct pred: tllist_all2]:\n  assumes \"X xs ys\"\n  and \"\\<And>xs ys. X xs ys \\<Longrightarrow>\n  (is_TNil xs \\<longleftrightarrow> is_TNil ys) \\<and>\n  (is_TNil xs \\<longrightarrow> is_TNil ys \\<longrightarrow> R (terminal xs) (terminal ys)) \\<and>\n  (\\<not> is_TNil xs \\<longrightarrow> \\<not> is_TNil ys \\<longrightarrow> P (thd xs) (thd ys) \\<and> (X (ttl xs) (ttl ys) \\<or> tllist_all2 P R (ttl xs) (ttl ys)))\"\n  shows \"tllist_all2 P R xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 P R xs ys", "using assms"], ["proof (prove)\nusing this:\n  X xs ys\n  X ?xs ?ys \\<Longrightarrow>\n  is_TNil ?xs = is_TNil ?ys \\<and>\n  (is_TNil ?xs \\<longrightarrow>\n   is_TNil ?ys \\<longrightarrow> R (terminal ?xs) (terminal ?ys)) \\<and>\n  (\\<not> is_TNil ?xs \\<longrightarrow>\n   \\<not> is_TNil ?ys \\<longrightarrow>\n   P (thd ?xs) (thd ?ys) \\<and>\n   (X (ttl ?xs) (ttl ?ys) \\<or> tllist_all2 P R (ttl ?xs) (ttl ?ys)))\n\ngoal (1 subgoal):\n 1. tllist_all2 P R xs ys", "apply(transfer fixing: P R)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X xs ys.\n       \\<lbrakk>Domainp\n                 (rel_fun (pcr_tllist (=) (=))\n                   (rel_fun (pcr_tllist (=) (=)) (=)))\n                 X;\n        X xs ys;\n        \\<And>xs ys.\n           X xs ys \\<Longrightarrow>\n           (case xs of (xs, b) \\<Rightarrow> lnull xs) =\n           (case ys of (xs, b) \\<Rightarrow> lnull xs) \\<and>\n           ((case xs of (xs, b) \\<Rightarrow> lnull xs) \\<longrightarrow>\n            (case ys of (xs, b) \\<Rightarrow> lnull xs) \\<longrightarrow>\n            R (case xs of\n               (xs, b) \\<Rightarrow> if lfinite xs then b else undefined)\n             (case ys of\n              (xs, b) \\<Rightarrow>\n                if lfinite xs then b else undefined)) \\<and>\n           (\\<not> (case xs of\n                    (xs, b) \\<Rightarrow> lnull xs) \\<longrightarrow>\n            \\<not> (case ys of\n                    (xs, b) \\<Rightarrow> lnull xs) \\<longrightarrow>\n            P ((lhd \\<circ> fst) xs) ((lhd \\<circ> fst) ys) \\<and>\n            (X (apfst ltl xs) (apfst ltl ys) \\<or>\n             (case apfst ltl xs of\n              (xs, b) \\<Rightarrow>\n                \\<lambda>(ys, b').\n                   llist_all2 P xs ys \\<and>\n                   (lfinite xs \\<longrightarrow> R b b'))\n              (apfst ltl ys)))\\<rbrakk>\n       \\<Longrightarrow> (case xs of\n                          (xs, b) \\<Rightarrow>\n                            \\<lambda>(ys, b').\n                               llist_all2 P xs ys \\<and>\n                               (lfinite xs \\<longrightarrow> R b b'))\n                          ys", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X a b aa ba bb.\n       \\<lbrakk>X (a, b) (aa, ba);\n        \\<And>a b aa ba.\n           X (a, b) (aa, ba) \\<Longrightarrow>\n           lnull a = lnull aa \\<and>\n           (lnull a \\<longrightarrow>\n            lnull aa \\<longrightarrow> R b ba) \\<and>\n           (\\<not> lnull a \\<longrightarrow>\n            \\<not> lnull aa \\<longrightarrow>\n            P (lhd a) (lhd aa) \\<and>\n            (X (ltl a, b) (ltl aa, ba) \\<or>\n             llist_all2 P (ltl a) (ltl aa) \\<and>\n             (lfinite a \\<longrightarrow> R b ba)));\n        rel_fun (pcr_tllist (=) (=)) (rel_fun (pcr_tllist (=) (=)) (=)) X\n         bb\\<rbrakk>\n       \\<Longrightarrow> llist_all2 P a aa \\<and>\n                         (lfinite a \\<longrightarrow> R b ba)", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X a b aa ba bb.\n       \\<lbrakk>X (a, b) (aa, ba);\n        \\<And>a b aa ba.\n           X (a, b) (aa, ba) \\<Longrightarrow>\n           lnull a = lnull aa \\<and>\n           (lnull a \\<longrightarrow>\n            lnull aa \\<longrightarrow> R b ba) \\<and>\n           (\\<not> lnull a \\<longrightarrow>\n            \\<not> lnull aa \\<longrightarrow>\n            P (lhd a) (lhd aa) \\<and>\n            (X (ltl a, b) (ltl aa, ba) \\<or>\n             llist_all2 P (ltl a) (ltl aa) \\<and>\n             (lfinite a \\<longrightarrow> R b ba)));\n        rel_fun (pcr_tllist (=) (=)) (rel_fun (pcr_tllist (=) (=)) (=)) X\n         bb\\<rbrakk>\n       \\<Longrightarrow> llist_all2 P a aa\n 2. \\<And>X a b aa ba bb.\n       \\<lbrakk>X (a, b) (aa, ba);\n        \\<And>a b aa ba.\n           X (a, b) (aa, ba) \\<Longrightarrow>\n           lnull a = lnull aa \\<and>\n           (lnull a \\<longrightarrow>\n            lnull aa \\<longrightarrow> R b ba) \\<and>\n           (\\<not> lnull a \\<longrightarrow>\n            \\<not> lnull aa \\<longrightarrow>\n            P (lhd a) (lhd aa) \\<and>\n            (X (ltl a, b) (ltl aa, ba) \\<or>\n             llist_all2 P (ltl a) (ltl aa) \\<and>\n             (lfinite a \\<longrightarrow> R b ba)));\n        rel_fun (pcr_tllist (=) (=)) (rel_fun (pcr_tllist (=) (=)) (=)) X\n         bb\\<rbrakk>\n       \\<Longrightarrow> lfinite a \\<longrightarrow> R b ba", "apply(erule llist_all2_coinduct, blast, blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X a b aa ba bb.\n       \\<lbrakk>X (a, b) (aa, ba);\n        \\<And>a b aa ba.\n           X (a, b) (aa, ba) \\<Longrightarrow>\n           lnull a = lnull aa \\<and>\n           (lnull a \\<longrightarrow>\n            lnull aa \\<longrightarrow> R b ba) \\<and>\n           (\\<not> lnull a \\<longrightarrow>\n            \\<not> lnull aa \\<longrightarrow>\n            P (lhd a) (lhd aa) \\<and>\n            (X (ltl a, b) (ltl aa, ba) \\<or>\n             llist_all2 P (ltl a) (ltl aa) \\<and>\n             (lfinite a \\<longrightarrow> R b ba)));\n        rel_fun (pcr_tllist (=) (=)) (rel_fun (pcr_tllist (=) (=)) (=)) X\n         bb\\<rbrakk>\n       \\<Longrightarrow> lfinite a \\<longrightarrow> R b ba", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X a b aa ba bb.\n       \\<lbrakk>X (a, b) (aa, ba);\n        \\<And>a b aa ba.\n           X (a, b) (aa, ba) \\<Longrightarrow>\n           lnull a = lnull aa \\<and>\n           (lnull a \\<longrightarrow>\n            lnull aa \\<longrightarrow> R b ba) \\<and>\n           (\\<not> lnull a \\<longrightarrow>\n            \\<not> lnull aa \\<longrightarrow>\n            P (lhd a) (lhd aa) \\<and>\n            (X (ltl a, b) (ltl aa, ba) \\<or>\n             llist_all2 P (ltl a) (ltl aa) \\<and>\n             (lfinite a \\<longrightarrow> R b ba)));\n        rel_fun (pcr_tllist (=) (=)) (rel_fun (pcr_tllist (=) (=)) (=)) X\n         bb;\n        lfinite a\\<rbrakk>\n       \\<Longrightarrow> R b ba", "subgoal premises prems for X xs b ys c"], ["proof (prove)\ngoal (1 subgoal):\n 1. R b c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R b c", "from \\<open>lfinite xs\\<close> \\<open>X (xs, b) (ys, c)\\<close>"], ["proof (chain)\npicking this:\n  lfinite xs\n  X (xs, b) (ys, c)", "show \"R b c\""], ["proof (prove)\nusing this:\n  lfinite xs\n  X (xs, b) (ys, c)\n\ngoal (1 subgoal):\n 1. R b c", "by(induct arbitrary: ys rule: lfinite_induct)(auto dest: prems(2))"], ["proof (state)\nthis:\n  R b c\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tllist_all2_cases[consumes 1, case_names TNil TCons, cases pred]:\n  assumes \"tllist_all2 P Q xs ys\"\n  obtains (TNil) b b' where \"xs = TNil b\" \"ys = TNil b'\" \"Q b b'\"\n  | (TCons) x xs' y ys'\n    where \"xs = TCons x xs'\" and \"ys = TCons y ys'\" \n    and \"P x y\" and \"tllist_all2 P Q xs' ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>b b'.\n                \\<lbrakk>xs = TNil b; ys = TNil b'; Q b b'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>x xs' y ys'.\n        \\<lbrakk>xs = TCons x xs'; ys = TCons y ys'; P x y;\n         tllist_all2 P Q xs' ys'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  tllist_all2 P Q xs ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>b b'.\n                \\<lbrakk>xs = TNil b; ys = TNil b'; Q b b'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>x xs' y ys'.\n        \\<lbrakk>xs = TCons x xs'; ys = TCons y ys'; P x y;\n         tllist_all2 P Q xs' ys'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(cases xs)(fastforce simp add: tllist_all2_TCons1 tllist_all2_TNil1)+"], ["", "lemma tllist_all2_tmap1:\n  \"tllist_all2 P Q (tmap f g xs) ys \\<longleftrightarrow> tllist_all2 (\\<lambda>x. P (f x)) (\\<lambda>x. Q (g x)) xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 P Q (tmap f g xs) ys =\n    tllist_all2 (\\<lambda>x. P (f x)) (\\<lambda>x. Q (g x)) xs ys", "by(transfer)(auto simp add: llist_all2_lmap1)"], ["", "lemma tllist_all2_tmap2:\n  \"tllist_all2 P Q xs (tmap f g ys) \\<longleftrightarrow> tllist_all2 (\\<lambda>x y. P x (f y)) (\\<lambda>x y. Q x (g y)) xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 P Q xs (tmap f g ys) =\n    tllist_all2 (\\<lambda>x y. P x (f y)) (\\<lambda>x y. Q x (g y)) xs ys", "by(transfer)(auto simp add: llist_all2_lmap2)"], ["", "lemma tllist_all2_mono:\n  \"\\<lbrakk> tllist_all2 P Q xs ys; \\<And>x y. P x y \\<Longrightarrow> P' x y; \\<And>x y. Q x y \\<Longrightarrow> Q' x y \\<rbrakk>\n  \\<Longrightarrow> tllist_all2 P' Q' xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tllist_all2 P Q xs ys;\n     \\<And>x y. P x y \\<Longrightarrow> P' x y;\n     \\<And>x y. Q x y \\<Longrightarrow> Q' x y\\<rbrakk>\n    \\<Longrightarrow> tllist_all2 P' Q' xs ys", "by transfer(auto elim!: llist_all2_mono)"], ["", "lemma tllist_all2_tlengthD: \"tllist_all2 P Q xs ys \\<Longrightarrow> tlength xs = tlength ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 P Q xs ys \\<Longrightarrow> tlength xs = tlength ys", "by(transfer)(auto dest: llist_all2_llengthD)"], ["", "lemma tllist_all2_tfiniteD: \"tllist_all2 P Q xs ys \\<Longrightarrow> tfinite xs = tfinite ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 P Q xs ys \\<Longrightarrow> tfinite xs = tfinite ys", "by(transfer)(auto dest: llist_all2_lfiniteD)"], ["", "lemma tllist_all2_tfinite1_terminalD:\n  \"\\<lbrakk> tllist_all2 P Q xs ys; tfinite xs \\<rbrakk> \\<Longrightarrow> Q (terminal xs) (terminal ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tllist_all2 P Q xs ys; tfinite xs\\<rbrakk>\n    \\<Longrightarrow> Q (terminal xs) (terminal ys)", "by(frule tllist_all2_tfiniteD)(transfer, auto)"], ["", "lemma tllist_all2_tfinite2_terminalD:\n  \"\\<lbrakk> tllist_all2 P Q xs ys; tfinite ys \\<rbrakk> \\<Longrightarrow> Q (terminal xs) (terminal ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tllist_all2 P Q xs ys; tfinite ys\\<rbrakk>\n    \\<Longrightarrow> Q (terminal xs) (terminal ys)", "by(metis tllist_all2_tfinite1_terminalD tllist_all2_tfiniteD)"], ["", "lemma tllist_all2D_llist_all2_llist_of_tllist:\n  \"tllist_all2 P Q xs ys \\<Longrightarrow> llist_all2 P (llist_of_tllist xs) (llist_of_tllist ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 P Q xs ys \\<Longrightarrow>\n    llist_all2 P (llist_of_tllist xs) (llist_of_tllist ys)", "by(transfer) auto"], ["", "lemma tllist_all2_is_TNilD:\n  \"tllist_all2 P Q xs ys \\<Longrightarrow> is_TNil xs \\<longleftrightarrow> is_TNil ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 P Q xs ys \\<Longrightarrow> is_TNil xs = is_TNil ys", "by(cases xs)(auto simp add: tllist_all2_TNil1 tllist_all2_TCons1)"], ["", "lemma tllist_all2_thdD:\n  \"\\<lbrakk> tllist_all2 P Q xs ys; \\<not> is_TNil xs \\<or> \\<not> is_TNil ys \\<rbrakk> \\<Longrightarrow> P (thd xs) (thd ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tllist_all2 P Q xs ys;\n     \\<not> is_TNil xs \\<or> \\<not> is_TNil ys\\<rbrakk>\n    \\<Longrightarrow> P (thd xs) (thd ys)", "by(cases xs)(auto simp add: tllist_all2_TNil1 tllist_all2_TCons1)"], ["", "lemma tllist_all2_ttlI:\n  \"\\<lbrakk> tllist_all2 P Q xs ys; \\<not> is_TNil xs \\<or> \\<not> is_TNil ys \\<rbrakk> \\<Longrightarrow> tllist_all2 P Q (ttl xs) (ttl ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tllist_all2 P Q xs ys;\n     \\<not> is_TNil xs \\<or> \\<not> is_TNil ys\\<rbrakk>\n    \\<Longrightarrow> tllist_all2 P Q (ttl xs) (ttl ys)", "by(cases xs)(auto simp add: tllist_all2_TNil1 tllist_all2_TCons1)"], ["", "lemma tllist_all2_refl:\n  \"tllist_all2 P Q xs xs \\<longleftrightarrow> (\\<forall>x \\<in> tset xs. P x x) \\<and> (tfinite xs \\<longrightarrow> Q (terminal xs) (terminal xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 P Q xs xs =\n    ((\\<forall>x\\<in>tset xs. P x x) \\<and>\n     (tfinite xs \\<longrightarrow> Q (terminal xs) (terminal xs)))", "by transfer(auto)"], ["", "lemma tllist_all2_reflI:\n  \"\\<lbrakk> \\<And>x. x \\<in> tset xs \\<Longrightarrow> P x x; tfinite xs \\<Longrightarrow> Q (terminal xs) (terminal xs) \\<rbrakk>\n  \\<Longrightarrow> tllist_all2 P Q xs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x \\<in> tset xs \\<Longrightarrow> P x x;\n     tfinite xs \\<Longrightarrow> Q (terminal xs) (terminal xs)\\<rbrakk>\n    \\<Longrightarrow> tllist_all2 P Q xs xs", "by(simp add: tllist_all2_refl)"], ["", "lemma tllist_all2_conv_all_tnth:\n  \"tllist_all2 P Q xs ys \\<longleftrightarrow> \n  tlength xs = tlength ys \\<and> \n  (\\<forall>n. enat n < tlength xs \\<longrightarrow> P (tnth xs n) (tnth ys n)) \\<and>\n  (tfinite xs \\<longrightarrow> Q (terminal xs) (terminal ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 P Q xs ys =\n    (tlength xs = tlength ys \\<and>\n     (\\<forall>n.\n         enat n < tlength xs \\<longrightarrow>\n         P (tnth xs n) (tnth ys n)) \\<and>\n     (tfinite xs \\<longrightarrow> Q (terminal xs) (terminal ys)))", "by transfer(auto 4 4 simp add: llist_all2_conv_all_lnth split: if_split_asm dest: lfinite_llength_enat not_lfinite_llength)"], ["", "lemma tllist_all2_tnthD:\n  \"\\<lbrakk> tllist_all2 P Q xs ys; enat n < tlength xs \\<rbrakk> \n  \\<Longrightarrow> P (tnth xs n) (tnth ys n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tllist_all2 P Q xs ys; enat n < tlength xs\\<rbrakk>\n    \\<Longrightarrow> P (tnth xs n) (tnth ys n)", "by(simp add: tllist_all2_conv_all_tnth)"], ["", "lemma tllist_all2_tnthD2:\n  \"\\<lbrakk> tllist_all2 P Q xs ys; enat n < tlength ys \\<rbrakk> \n  \\<Longrightarrow> P (tnth xs n) (tnth ys n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tllist_all2 P Q xs ys; enat n < tlength ys\\<rbrakk>\n    \\<Longrightarrow> P (tnth xs n) (tnth ys n)", "by(simp add: tllist_all2_conv_all_tnth)"], ["", "lemmas tllist_all2_eq = tllist.rel_eq"], ["", "lemma tmap_eq_tmap_conv_tllist_all2:\n  \"tmap f g xs = tmap f' g' ys \\<longleftrightarrow>\n  tllist_all2 (\\<lambda>x y. f x = f' y) (\\<lambda>x y. g x = g' y) xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tmap f g xs = tmap f' g' ys) =\n    tllist_all2 (\\<lambda>x y. f x = f' y) (\\<lambda>x y. g x = g' y) xs ys", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g xs f' g' ys.\n       (case (map_prod \\<circ> lmap) f g xs of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        ((map_prod \\<circ> lmap) f' g' ys) =\n       (case xs of\n        (xs, b) \\<Rightarrow>\n          \\<lambda>(ys, b').\n             llist_all2 (\\<lambda>x y. f x = f' y) xs ys \\<and>\n             (lfinite xs \\<longrightarrow> g b = g' b'))\n        ys", "apply(clarsimp simp add: lmap_eq_lmap_conv_llist_all2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g a b f' g' aa ba.\n       (llist_all2 (\\<lambda>x y. f x = f' y) a aa \\<and>\n        (lfinite aa \\<longrightarrow> g b = g' ba)) =\n       (llist_all2 (\\<lambda>x y. f x = f' y) a aa \\<and>\n        (lfinite a \\<longrightarrow> g b = g' ba))", "apply(auto dest: llist_all2_lfiniteD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tllist_all2_trans:\n  \"\\<lbrakk> tllist_all2 P Q xs ys; tllist_all2 P Q ys zs; transp P; transp Q \\<rbrakk>\n  \\<Longrightarrow> tllist_all2 P Q xs zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tllist_all2 P Q xs ys; tllist_all2 P Q ys zs; transp P;\n     transp Q\\<rbrakk>\n    \\<Longrightarrow> tllist_all2 P Q xs zs", "by transfer(auto elim: llist_all2_trans dest: llist_all2_lfiniteD transpD)"], ["", "lemma tllist_all2_tappendI:\n  \"\\<lbrakk> tllist_all2 P Q xs ys;\n     \\<lbrakk> tfinite xs; tfinite ys; Q (terminal xs) (terminal ys) \\<rbrakk>\n     \\<Longrightarrow> tllist_all2 P R (xs' (terminal xs)) (ys' (terminal ys)) \\<rbrakk>\n  \\<Longrightarrow> tllist_all2 P R (tappend xs xs') (tappend ys ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tllist_all2 P Q xs ys;\n     \\<lbrakk>tfinite xs; tfinite ys; Q (terminal xs) (terminal ys)\\<rbrakk>\n     \\<Longrightarrow> tllist_all2 P R (xs' (terminal xs))\n                        (ys' (terminal ys))\\<rbrakk>\n    \\<Longrightarrow> tllist_all2 P R (tappend xs xs') (tappend ys ys')", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P Q xs ys R xs' ys'.\n       \\<lbrakk>(case xs of\n                 (xs, b) \\<Rightarrow>\n                   \\<lambda>(ys, b').\n                      llist_all2 P xs ys \\<and>\n                      (lfinite xs \\<longrightarrow> Q b b'))\n                 ys;\n        \\<lbrakk>lfinite (fst xs); lfinite (fst ys);\n         Q (case xs of\n            (xs, b) \\<Rightarrow> if lfinite xs then b else undefined)\n          (case ys of\n           (xs, b) \\<Rightarrow>\n             if lfinite xs then b else undefined)\\<rbrakk>\n        \\<Longrightarrow> (case xs' (case xs of\n                                     (xs, b) \\<Rightarrow>\n if lfinite xs then b else undefined) of\n                           (xs, b) \\<Rightarrow>\n                             \\<lambda>(ys, b').\n                                llist_all2 P xs ys \\<and>\n                                (lfinite xs \\<longrightarrow> R b b'))\n                           (ys' (case ys of\n                                 (xs, b) \\<Rightarrow>\n                                   if lfinite xs then b\n                                   else undefined))\\<rbrakk>\n       \\<Longrightarrow> (case (case xs of\n                                (xs, b) \\<Rightarrow>\n                                  \\<lambda>f. apfst (lappend xs) (f b))\n                                xs' of\n                          (xs, b) \\<Rightarrow>\n                            \\<lambda>(ys, b').\n                               llist_all2 P xs ys \\<and>\n                               (lfinite xs \\<longrightarrow> R b b'))\n                          ((case ys of\n                            (xs, b) \\<Rightarrow>\n                              \\<lambda>f. apfst (lappend xs) (f b))\n                            ys')", "apply(auto 4 3 simp add: apfst_def map_prod_def lappend_inf split: prod.split_asm dest: llist_all2_lfiniteD intro: llist_all2_lappendI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P xs' ys' x1 x2 x1a x2a bb b' x1b x1c.\n       \\<lbrakk>llist_all2 P x1 x1a; \\<not> lfinite x1; xs' x2 = (x1b, bb);\n        ys' x2a = (x1c, b')\\<rbrakk>\n       \\<Longrightarrow> llist_all2 P x1 (lappend x1a x1c)", "apply(frule llist_all2_lfiniteD, simp add: lappend_inf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma llist_all2_tllist_of_llistI:\n  \"tllist_all2 A B xs ys \\<Longrightarrow> llist_all2 A (llist_of_tllist xs) (llist_of_tllist ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 A B xs ys \\<Longrightarrow>\n    llist_all2 A (llist_of_tllist xs) (llist_of_tllist ys)", "by(coinduction arbitrary: xs ys)(auto dest: tllist_all2_is_TNilD tllist_all2_thdD intro: tllist_all2_ttlI)"], ["", "lemma tllist_all2_tllist_of_llist [simp]:\n  \"tllist_all2 A B (tllist_of_llist b xs) (tllist_of_llist c ys) \\<longleftrightarrow>\n  llist_all2 A xs ys \\<and> (lfinite xs \\<longrightarrow> B b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 A B (tllist_of_llist b xs) (tllist_of_llist c ys) =\n    (llist_all2 A xs ys \\<and> (lfinite xs \\<longrightarrow> B b c))", "by transfer auto"], ["", "subsection \\<open>From a terminated lazy list to a lazy list @{term llist_of_tllist}\\<close>"], ["", "lemma llist_of_tllist_tmap [simp]:\n  \"llist_of_tllist (tmap f g xs) = lmap f (llist_of_tllist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_of_tllist (tmap f g xs) = lmap f (llist_of_tllist xs)", "by transfer auto"], ["", "lemma llist_of_tllist_tappend:\n  \"llist_of_tllist (tappend xs f) = lappend (llist_of_tllist xs) (llist_of_tllist (f (terminal xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_of_tllist (tappend xs f) =\n    lappend (llist_of_tllist xs) (llist_of_tllist (f (terminal xs)))", "by(transfer)(auto simp add: lappend_inf)"], ["", "lemma llist_of_tllist_lappendt [simp]:\n  \"llist_of_tllist (lappendt xs tr) = lappend xs (llist_of_tllist tr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_of_tllist (lappendt xs tr) = lappend xs (llist_of_tllist tr)", "by transfer auto"], ["", "lemma llist_of_tllist_tfilter [simp]:\n  \"llist_of_tllist (tfilter b P tr) = lfilter P (llist_of_tllist tr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_of_tllist (tfilter b P tr) = lfilter P (llist_of_tllist tr)", "by transfer auto"], ["", "lemma llist_of_tllist_tconcat:\n  \"llist_of_tllist (tconcat b trs) = lconcat (llist_of_tllist trs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_of_tllist (tconcat b trs) = lconcat (llist_of_tllist trs)", "by transfer auto"], ["", "lemma llist_of_tllist_eq_lappend_conv:\n  \"llist_of_tllist xs = lappend us vs \\<longleftrightarrow> \n  (\\<exists>ys. xs = lappendt us ys \\<and> vs = llist_of_tllist ys \\<and> terminal xs = terminal ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_of_tllist xs = lappend us vs) =\n    (\\<exists>ys.\n        xs = lappendt us ys \\<and>\n        vs = llist_of_tllist ys \\<and> terminal xs = terminal ys)", "by transfer auto"], ["", "subsection \\<open>The nth element of a terminated lazy list @{term \"tnth\"}\\<close>"], ["", "lemma tnth_TNil [nitpick_simp]:\n  \"tnth (TNil b) n = undefined n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tnth (TNil b) n = undefined n", "by(transfer)(simp add: lnth_LNil)"], ["", "lemma tnth_TCons:\n  \"tnth (TCons x xs) n = (case n of 0 \\<Rightarrow> x | Suc n' \\<Rightarrow> tnth xs n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tnth (TCons x xs) n =\n    (case n of 0 \\<Rightarrow> x | Suc n' \\<Rightarrow> tnth xs n')", "by(transfer)(auto simp add: lnth_LCons split: nat.split)"], ["", "lemma tnth_code [simp, nitpick_simp, code]:\n  shows tnth_0: \"tnth (TCons x xs) 0 = x\"\n  and tnth_Suc_TCons: \"tnth (TCons x xs) (Suc n) = tnth xs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tnth (TCons x xs) 0 = x &&& tnth (TCons x xs) (Suc n) = tnth xs n", "by(simp_all add: tnth_TCons)"], ["", "lemma lnth_llist_of_tllist [simp]:\n  \"lnth (llist_of_tllist xs) = tnth xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (llist_of_tllist xs) = tnth xs", "by(transfer)(auto)"], ["", "lemma tnth_tmap [simp]: \"enat n < tlength xs \\<Longrightarrow> tnth (tmap f g xs) n = f (tnth xs n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat n < tlength xs \\<Longrightarrow>\n    tnth (tmap f g xs) n = f (tnth xs n)", "by transfer simp"], ["", "subsection \\<open>The length of a terminated lazy list @{term \"tlength\"}\\<close>"], ["", "lemma [simp, nitpick_simp]:\n  shows tlength_TNil: \"tlength (TNil b) = 0\"\n  and tlength_TCons: \"tlength (TCons x xs) = eSuc (tlength xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tlength (TNil b) = 0 &&& tlength (TCons x xs) = eSuc (tlength xs)", "apply(transfer, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tlength (TCons x xs) = eSuc (tlength xs)", "apply(transfer, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma llength_llist_of_tllist [simp]: \"llength (llist_of_tllist xs) = tlength xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (llist_of_tllist xs) = tlength xs", "by transfer auto"], ["", "lemma tlength_tmap [simp]: \"tlength (tmap f g xs) = tlength xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tlength (tmap f g xs) = tlength xs", "by transfer simp"], ["", "definition gen_tlength :: \"nat \\<Rightarrow> ('a, 'b) tllist \\<Rightarrow> enat\"\nwhere \"gen_tlength n xs = enat n + tlength xs\""], ["", "lemma gen_tlength_code [code]:\n  \"gen_tlength n (TNil b) = enat n\"\n  \"gen_tlength n (TCons x xs) = gen_tlength (n + 1) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_tlength n (TNil b) = enat n &&&\n    gen_tlength n (TCons x xs) = gen_tlength (n + 1) xs", "by(simp_all add: gen_tlength_def iadd_Suc eSuc_enat[symmetric] iadd_Suc_right)"], ["", "lemma tlength_code [code]: \"tlength = gen_tlength 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tlength = gen_tlength 0", "by(simp add: gen_tlength_def fun_eq_iff zero_enat_def)"], ["", "subsection \\<open>@{term \"tdropn\"}\\<close>"], ["", "lemma tdropn_0 [simp, code, nitpick_simp]: \"tdropn 0 xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdropn 0 xs = xs", "by transfer auto"], ["", "lemma tdropn_TNil [simp, code]: \"tdropn n (TNil b) = (TNil b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdropn n (TNil b) = TNil b", "by transfer(auto)"], ["", "lemma tdropn_Suc_TCons [simp, code]: \"tdropn (Suc n) (TCons x xs) = tdropn n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdropn (Suc n) (TCons x xs) = tdropn n xs", "by transfer(auto)"], ["", "lemma tdropn_Suc [nitpick_simp]: \"tdropn (Suc n) xs = (case xs of TNil b \\<Rightarrow> TNil b | TCons x xs' \\<Rightarrow> tdropn n xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdropn (Suc n) xs =\n    (case xs of TNil b \\<Rightarrow> TNil b\n     | TCons x xs' \\<Rightarrow> tdropn n xs')", "by(cases xs) simp_all"], ["", "lemma lappendt_ltake_tdropn:\n  \"lappendt (ltake (enat n) (llist_of_tllist xs)) (tdropn n xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappendt (ltake (enat n) (llist_of_tllist xs)) (tdropn n xs) = xs", "by transfer (auto)"], ["", "lemma llist_of_tllist_tdropn [simp]:\n  \"llist_of_tllist (tdropn n xs) = ldropn n (llist_of_tllist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_of_tllist (tdropn n xs) = ldropn n (llist_of_tllist xs)", "by transfer auto"], ["", "lemma tdropn_Suc_conv_tdropn:\n  \"enat n < tlength xs \\<Longrightarrow> TCons (tnth xs n) (tdropn (Suc n) xs) = tdropn n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat n < tlength xs \\<Longrightarrow>\n    TCons (tnth xs n) (tdropn (Suc n) xs) = tdropn n xs", "by transfer(auto simp add: ldropn_Suc_conv_ldropn)"], ["", "lemma tlength_tdropn [simp]: \"tlength (tdropn n xs) = tlength xs - enat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tlength (tdropn n xs) = tlength xs - enat n", "by transfer auto"], ["", "lemma tnth_tdropn [simp]: \"enat (n + m) < tlength xs \\<Longrightarrow> tnth (tdropn n xs) m = tnth xs (m + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (n + m) < tlength xs \\<Longrightarrow>\n    tnth (tdropn n xs) m = tnth xs (m + n)", "by transfer auto"], ["", "subsection \\<open>@{term \"tset\"}\\<close>"], ["", "lemma tset_induct [consumes 1, case_names find step]:\n  assumes \"x \\<in> tset xs\"\n  and \"\\<And>xs. P (TCons x xs)\"\n  and \"\\<And>x' xs. \\<lbrakk> x \\<in> tset xs; x \\<noteq> x'; P xs \\<rbrakk> \\<Longrightarrow> P (TCons x' xs)\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> tset xs\n  P (TCons x ?xs)\n  \\<lbrakk>x \\<in> tset ?xs; x \\<noteq> ?x'; P ?xs\\<rbrakk>\n  \\<Longrightarrow> P (TCons ?x' ?xs)\n\ngoal (1 subgoal):\n 1. P xs", "by transfer(clarsimp, erule lset_induct)"], ["", "lemma tset_conv_tnth: \"tset xs = {tnth xs n|n . enat n < tlength xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tset xs = {tnth xs n |n. enat n < tlength xs}", "by transfer(simp add: lset_conv_lnth)"], ["", "lemma in_tset_conv_tnth: \"x \\<in> tset xs \\<longleftrightarrow> (\\<exists>n. enat n < tlength xs \\<and> tnth xs n = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> tset xs) =\n    (\\<exists>n. enat n < tlength xs \\<and> tnth xs n = x)", "using tset_conv_tnth[of xs]"], ["proof (prove)\nusing this:\n  tset xs = {tnth xs n |n. enat n < tlength xs}\n\ngoal (1 subgoal):\n 1. (x \\<in> tset xs) =\n    (\\<exists>n. enat n < tlength xs \\<and> tnth xs n = x)", "by auto"], ["", "subsection \\<open>Setup for Lifting/Transfer\\<close>"], ["", "subsubsection \\<open>Relator and predicator properties\\<close>"], ["", "abbreviation \"tllist_all == pred_tllist\""], ["", "subsubsection \\<open>Transfer rules for the Transfer package\\<close>"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma set1_pre_tllist_transfer [transfer_rule]:\n  \"(rel_pre_tllist A B C ===> rel_set A) set1_pre_tllist set1_pre_tllist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_pre_tllist A B C ===> rel_set A) set1_pre_tllist set1_pre_tllist", "by(auto simp add: rel_pre_tllist_def vimage2p_def rel_fun_def set1_pre_tllist_def rel_set_def collect_def sum_set_defs prod_set_defs elim: rel_sum.cases split: sum.split_asm)"], ["", "lemma set2_pre_tllist_transfer [transfer_rule]:\n  \"(rel_pre_tllist A B C ===> rel_set B) set2_pre_tllist set2_pre_tllist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_pre_tllist A B C ===> rel_set B) set2_pre_tllist set2_pre_tllist", "by(auto simp add: rel_pre_tllist_def vimage2p_def rel_fun_def set2_pre_tllist_def rel_set_def collect_def sum_set_defs prod_set_defs elim: rel_sum.cases split: sum.split_asm)"], ["", "lemma set3_pre_tllist_transfer [transfer_rule]:\n  \"(rel_pre_tllist A B C ===> rel_set C) set3_pre_tllist set3_pre_tllist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_pre_tllist A B C ===> rel_set C) set3_pre_tllist set3_pre_tllist", "by(auto simp add: rel_pre_tllist_def vimage2p_def rel_fun_def set3_pre_tllist_def rel_set_def collect_def sum_set_defs prod_set_defs elim: rel_sum.cases split: sum.split_asm)"], ["", "lemma TNil_transfer2 [transfer_rule]: \"(B ===> tllist_all2 A B) TNil TNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B ===> tllist_all2 A B) TNil TNil", "by auto"], ["", "declare TNil_transfer [transfer_rule]"], ["", "lemma TCons_transfer2 [transfer_rule]:\n  \"(A ===> tllist_all2 A B ===> tllist_all2 A B) TCons TCons\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> tllist_all2 A B ===> tllist_all2 A B) TCons TCons", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       A x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           tllist_all2 A B xa ya \\<longrightarrow>\n           tllist_all2 A B (TCons x xa) (TCons y ya))", "by simp"], ["", "declare TCons_transfer [transfer_rule]"], ["", "lemma case_tllist_transfer [transfer_rule]:\n  \"((B ===> C) ===> (A ===> tllist_all2 A B ===> C) ===> tllist_all2 A B ===> C)\n    case_tllist case_tllist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((B ===> C) ===>\n     (A ===> tllist_all2 A B ===> C) ===> tllist_all2 A B ===> C)\n     case_tllist case_tllist", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<forall>xa ya.\n           B xa ya \\<longrightarrow> C (x xa) (y ya)) \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<forall>x y.\n               A x y \\<longrightarrow>\n               (\\<forall>xaa yaa.\n                   tllist_all2 A B xaa yaa \\<longrightarrow>\n                   C (xa x xaa) (ya y yaa))) \\<longrightarrow>\n           (\\<forall>xaa yaa.\n               tllist_all2 A B xaa yaa \\<longrightarrow>\n               C (case xaa of TNil xa \\<Rightarrow> x xa\n                  | TCons x xb \\<Rightarrow> xa x xb)\n                (case yaa of TNil x \\<Rightarrow> y x\n                 | TCons x xa \\<Rightarrow> ya x xa)))", "by (simp add: tllist_all2_TNil1 tllist_all2_TNil2 split: tllist.split)"], ["", "lemma unfold_tllist_transfer [transfer_rule]:\n  \"((A ===> (=)) ===> (A ===> B) ===> (A ===> C) ===> (A ===> A) ===> A ===> tllist_all2 C B) unfold_tllist unfold_tllist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===>\n     (A ===> B) ===> (A ===> C) ===> (A ===> A) ===> A ===> tllist_all2 C B)\n     unfold_tllist unfold_tllist", "proof(rule rel_funI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd.\n       \\<lbrakk>(A ===> (=)) x y; (A ===> B) xa ya; (A ===> C) xb yb;\n        (A ===> A) xc yc; A xd yd\\<rbrakk>\n       \\<Longrightarrow> tllist_all2 C B (unfold_tllist x xa xb xc xd)\n                          (unfold_tllist y ya yb yc yd)", "fix IS_TNIL1 :: \"'a \\<Rightarrow> bool\" and IS_TNIL2\n    TERMINAL1 TERMINAL2 THD1 THD2 TTL1 TTL2 x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd.\n       \\<lbrakk>(A ===> (=)) x y; (A ===> B) xa ya; (A ===> C) xb yb;\n        (A ===> A) xc yc; A xd yd\\<rbrakk>\n       \\<Longrightarrow> tllist_all2 C B (unfold_tllist x xa xb xc xd)\n                          (unfold_tllist y ya yb yc yd)", "assume rel: \"(A ===> (=)) IS_TNIL1 IS_TNIL2\" \"(A ===> B) TERMINAL1 TERMINAL2\"\n    \"(A ===> C) THD1 THD2\" \"(A ===> A) TTL1 TTL2\"\n    and \"A x y\""], ["proof (state)\nthis:\n  (A ===> (=)) IS_TNIL1 IS_TNIL2\n  (A ===> B) TERMINAL1 TERMINAL2\n  (A ===> C) THD1 THD2\n  (A ===> A) TTL1 TTL2\n  A x y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd.\n       \\<lbrakk>(A ===> (=)) x y; (A ===> B) xa ya; (A ===> C) xb yb;\n        (A ===> A) xc yc; A xd yd\\<rbrakk>\n       \\<Longrightarrow> tllist_all2 C B (unfold_tllist x xa xb xc xd)\n                          (unfold_tllist y ya yb yc yd)", "show \"tllist_all2 C B (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 x) (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 C B (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 x)\n     (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 y)", "using \\<open>A x y\\<close>"], ["proof (prove)\nusing this:\n  A x y\n\ngoal (1 subgoal):\n 1. tllist_all2 C B (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 x)\n     (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 y)", "apply(coinduction arbitrary: x y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       A x y \\<Longrightarrow>\n       is_TNil (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 x) =\n       is_TNil (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 y) \\<and>\n       (is_TNil\n         (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 x) \\<longrightarrow>\n        is_TNil\n         (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 y) \\<longrightarrow>\n        B (terminal (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 x))\n         (terminal (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 y))) \\<and>\n       (\\<not> is_TNil\n                (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1\n                  x) \\<longrightarrow>\n        \\<not> is_TNil\n                (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2\n                  y) \\<longrightarrow>\n        C (thd (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 x))\n         (thd (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 y)) \\<and>\n        ((\\<exists>xa ya.\n             ttl (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 x) =\n             unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 xa \\<and>\n             ttl (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 y) =\n             unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 ya \\<and>\n             A xa ya) \\<or>\n         tllist_all2 C B\n          (ttl (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 x))\n          (ttl (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 y))))", "using rel"], ["proof (prove)\nusing this:\n  (A ===> (=)) IS_TNIL1 IS_TNIL2\n  (A ===> B) TERMINAL1 TERMINAL2\n  (A ===> C) THD1 THD2\n  (A ===> A) TTL1 TTL2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       A x y \\<Longrightarrow>\n       is_TNil (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 x) =\n       is_TNil (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 y) \\<and>\n       (is_TNil\n         (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 x) \\<longrightarrow>\n        is_TNil\n         (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 y) \\<longrightarrow>\n        B (terminal (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 x))\n         (terminal (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 y))) \\<and>\n       (\\<not> is_TNil\n                (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1\n                  x) \\<longrightarrow>\n        \\<not> is_TNil\n                (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2\n                  y) \\<longrightarrow>\n        C (thd (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 x))\n         (thd (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 y)) \\<and>\n        ((\\<exists>xa ya.\n             ttl (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 x) =\n             unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 xa \\<and>\n             ttl (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 y) =\n             unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 ya \\<and>\n             A xa ya) \\<or>\n         tllist_all2 C B\n          (ttl (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 x))\n          (ttl (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 y))))", "by(auto 4 4 elim: rel_funE)"], ["proof (state)\nthis:\n  tllist_all2 C B (unfold_tllist IS_TNIL1 TERMINAL1 THD1 TTL1 x)\n   (unfold_tllist IS_TNIL2 TERMINAL2 THD2 TTL2 y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma corec_tllist_transfer [transfer_rule]:\n  \"((A ===> (=)) ===> (A ===> B) ===> (A ===> C) ===> (A ===> (=)) ===> (A ===> tllist_all2 C B) ===> (A ===> A) ===> A ===> tllist_all2 C B) corec_tllist corec_tllist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===>\n     (A ===> B) ===>\n     (A ===> C) ===>\n     (A ===> (=)) ===>\n     (A ===> tllist_all2 C B) ===> (A ===> A) ===> A ===> tllist_all2 C B)\n     corec_tllist corec_tllist", "proof(rule rel_funI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd xe ye xf yf.\n       \\<lbrakk>(A ===> (=)) x y; (A ===> B) xa ya; (A ===> C) xb yb;\n        (A ===> (=)) xc yc; (A ===> tllist_all2 C B) xd yd;\n        (A ===> A) xe ye; A xf yf\\<rbrakk>\n       \\<Longrightarrow> tllist_all2 C B (corec_tllist x xa xb xc xd xe xf)\n                          (corec_tllist y ya yb yc yd ye yf)", "fix IS_TNIL1 MORE1 :: \"'a \\<Rightarrow> bool\" and IS_TNIL2\n    TERMINAL1 TERMINAL2 THD1 THD2 MORE2 STOP1 STOP2 TTL1 TTL2 x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd xe ye xf yf.\n       \\<lbrakk>(A ===> (=)) x y; (A ===> B) xa ya; (A ===> C) xb yb;\n        (A ===> (=)) xc yc; (A ===> tllist_all2 C B) xd yd;\n        (A ===> A) xe ye; A xf yf\\<rbrakk>\n       \\<Longrightarrow> tllist_all2 C B (corec_tllist x xa xb xc xd xe xf)\n                          (corec_tllist y ya yb yc yd ye yf)", "assume rel: \"(A ===> (=)) IS_TNIL1 IS_TNIL2\" \"(A ===> B) TERMINAL1 TERMINAL2\"\n    \"(A ===> C) THD1 THD2\" \"(A ===> (=)) MORE1 MORE2\"\n    \"(A ===> tllist_all2 C B) STOP1 STOP2\" \"(A ===> A) TTL1 TTL2\"\n    and \"A x y\""], ["proof (state)\nthis:\n  (A ===> (=)) IS_TNIL1 IS_TNIL2\n  (A ===> B) TERMINAL1 TERMINAL2\n  (A ===> C) THD1 THD2\n  (A ===> (=)) MORE1 MORE2\n  (A ===> tllist_all2 C B) STOP1 STOP2\n  (A ===> A) TTL1 TTL2\n  A x y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd xe ye xf yf.\n       \\<lbrakk>(A ===> (=)) x y; (A ===> B) xa ya; (A ===> C) xb yb;\n        (A ===> (=)) xc yc; (A ===> tllist_all2 C B) xd yd;\n        (A ===> A) xe ye; A xf yf\\<rbrakk>\n       \\<Longrightarrow> tllist_all2 C B (corec_tllist x xa xb xc xd xe xf)\n                          (corec_tllist y ya yb yc yd ye yf)", "show \"tllist_all2 C B (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1 x) (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 C B\n     (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1 x)\n     (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2 y)", "using \\<open>A x y\\<close>"], ["proof (prove)\nusing this:\n  A x y\n\ngoal (1 subgoal):\n 1. tllist_all2 C B\n     (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1 x)\n     (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2 y)", "apply(coinduction arbitrary: x y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       A x y \\<Longrightarrow>\n       is_TNil (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1 x) =\n       is_TNil\n        (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2 y) \\<and>\n       (is_TNil\n         (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1\n           x) \\<longrightarrow>\n        is_TNil\n         (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2\n           y) \\<longrightarrow>\n        B (terminal\n            (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1 x))\n         (terminal\n           (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2\n             y))) \\<and>\n       (\\<not> is_TNil\n                (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1\n                  x) \\<longrightarrow>\n        \\<not> is_TNil\n                (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2\n                  y) \\<longrightarrow>\n        C (thd (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1 x))\n         (thd (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2\n                y)) \\<and>\n        ((\\<exists>xa ya.\n             ttl (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1 x) =\n             corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1 xa \\<and>\n             ttl (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2 y) =\n             corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2 ya \\<and>\n             A xa ya) \\<or>\n         tllist_all2 C B\n          (ttl (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1 x))\n          (ttl (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2 y))))", "using rel"], ["proof (prove)\nusing this:\n  (A ===> (=)) IS_TNIL1 IS_TNIL2\n  (A ===> B) TERMINAL1 TERMINAL2\n  (A ===> C) THD1 THD2\n  (A ===> (=)) MORE1 MORE2\n  (A ===> tllist_all2 C B) STOP1 STOP2\n  (A ===> A) TTL1 TTL2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       A x y \\<Longrightarrow>\n       is_TNil (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1 x) =\n       is_TNil\n        (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2 y) \\<and>\n       (is_TNil\n         (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1\n           x) \\<longrightarrow>\n        is_TNil\n         (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2\n           y) \\<longrightarrow>\n        B (terminal\n            (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1 x))\n         (terminal\n           (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2\n             y))) \\<and>\n       (\\<not> is_TNil\n                (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1\n                  x) \\<longrightarrow>\n        \\<not> is_TNil\n                (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2\n                  y) \\<longrightarrow>\n        C (thd (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1 x))\n         (thd (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2\n                y)) \\<and>\n        ((\\<exists>xa ya.\n             ttl (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1 x) =\n             corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1 xa \\<and>\n             ttl (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2 y) =\n             corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2 ya \\<and>\n             A xa ya) \\<or>\n         tllist_all2 C B\n          (ttl (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1 x))\n          (ttl (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2 y))))", "by(auto 4 4 elim: rel_funE)"], ["proof (state)\nthis:\n  tllist_all2 C B (corec_tllist IS_TNIL1 TERMINAL1 THD1 MORE1 STOP1 TTL1 x)\n   (corec_tllist IS_TNIL2 TERMINAL2 THD2 MORE2 STOP2 TTL2 y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ttl_transfer2 [transfer_rule]:\n  \"(tllist_all2 A B ===> tllist_all2 A B) ttl ttl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tllist_all2 A B ===> tllist_all2 A B) ttl ttl", "unfolding ttl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (tllist_all2 A B ===> tllist_all2 A B)\n     (\\<lambda>tllist.\n         case tllist of TNil x \\<Rightarrow> TNil x\n         | TCons x21 x22 \\<Rightarrow> x22)\n     (\\<lambda>tllist.\n         case tllist of TNil x \\<Rightarrow> TNil x\n         | TCons x21 x22 \\<Rightarrow> x22)", "by transfer_prover"], ["", "declare ttl_transfer [transfer_rule]"], ["", "lemma tset_transfer2 [transfer_rule]:\n  \"(tllist_all2 A B ===> rel_set A) tset tset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tllist_all2 A B ===> rel_set A) tset tset", "by (intro rel_funI rel_setI) (auto simp only: in_tset_conv_tnth tllist_all2_conv_all_tnth Bex_def)"], ["", "lemma tmap_transfer2 [transfer_rule]:\n  \"((A ===> B) ===> (C ===> D) ===> tllist_all2 A C ===> tllist_all2 B D) tmap tmap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B) ===> (C ===> D) ===> tllist_all2 A C ===> tllist_all2 B D)\n     tmap tmap", "by(auto simp add: rel_fun_def tllist_all2_tmap1 tllist_all2_tmap2 elim: tllist_all2_mono)"], ["", "declare tmap_transfer [transfer_rule]"], ["", "lemma is_TNil_transfer2 [transfer_rule]:\n  \"(tllist_all2 A B ===> (=)) is_TNil is_TNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tllist_all2 A B ===> (=)) is_TNil is_TNil", "by(auto dest: tllist_all2_is_TNilD)"], ["", "declare is_TNil_transfer [transfer_rule]"], ["", "lemma tappend_transfer [transfer_rule]:\n  \"(tllist_all2 A B ===> (B ===> tllist_all2 A C) ===> tllist_all2 A C) tappend tappend\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tllist_all2 A B ===> (B ===> tllist_all2 A C) ===> tllist_all2 A C)\n     tappend tappend", "by(auto intro: tllist_all2_tappendI elim: rel_funE)"], ["", "declare tappend.transfer [transfer_rule]"], ["", "lemma lappendt_transfer [transfer_rule]:\n  \"(llist_all2 A ===> tllist_all2 A B ===> tllist_all2 A B) lappendt lappendt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_all2 A ===> tllist_all2 A B ===> tllist_all2 A B) lappendt\n     lappendt", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       llist_all2 A x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           tllist_all2 A B xa ya \\<longrightarrow>\n           tllist_all2 A B (lappendt x xa) (lappendt y ya))", "by transfer(auto intro: llist_all2_lappendI)"], ["", "declare lappendt.transfer [transfer_rule]"], ["", "lemma llist_of_tllist_transfer2 [transfer_rule]:\n  \"(tllist_all2 A B ===> llist_all2 A) llist_of_tllist llist_of_tllist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tllist_all2 A B ===> llist_all2 A) llist_of_tllist llist_of_tllist", "by(auto intro: llist_all2_tllist_of_llistI)"], ["", "declare llist_of_tllist_transfer [transfer_rule]"], ["", "lemma tllist_of_llist_transfer2 [transfer_rule]:\n  \"(B ===> llist_all2 A ===> tllist_all2 A B) tllist_of_llist tllist_of_llist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B ===> llist_all2 A ===> tllist_all2 A B) tllist_of_llist\n     tllist_of_llist", "by(auto intro!: rel_funI)"], ["", "declare tllist_of_llist_transfer [transfer_rule]"], ["", "lemma tlength_transfer [transfer_rule]:\n  \"(tllist_all2 A B ===> (=)) tlength tlength\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tllist_all2 A B ===> (=)) tlength tlength", "by(auto dest: tllist_all2_tlengthD)"], ["", "declare tlength.transfer [transfer_rule]"], ["", "lemma tdropn_transfer [transfer_rule]:\n  \"((=) ===> tllist_all2 A B ===> tllist_all2 A B) tdropn tdropn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> tllist_all2 A B ===> tllist_all2 A B) tdropn tdropn", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = y \\<longrightarrow>\n       (\\<forall>xa ya.\n           tllist_all2 A B xa ya \\<longrightarrow>\n           tllist_all2 A B (tdropn x xa) (tdropn y ya))", "by transfer(auto intro: llist_all2_ldropnI)"], ["", "declare tdropn.transfer [transfer_rule]"], ["", "lemma tfilter_transfer [transfer_rule]:\n  \"(B ===> (A ===> (=)) ===> tllist_all2 A B ===> tllist_all2 A B) tfilter tfilter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B ===> (A ===> (=)) ===> tllist_all2 A B ===> tllist_all2 A B) tfilter\n     tfilter", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       B x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<forall>x y.\n               A x y \\<longrightarrow> xa x = ya y) \\<longrightarrow>\n           (\\<forall>xb yb.\n               tllist_all2 A B xb yb \\<longrightarrow>\n               tllist_all2 A B (tfilter x xa xb) (tfilter y ya yb)))", "by transfer(auto intro: llist_all2_lfilterI dest: llist_all2_lfiniteD)"], ["", "declare tfilter.transfer [transfer_rule]"], ["", "lemma tconcat_transfer [transfer_rule]:\n  \"(B ===> tllist_all2 (llist_all2 A) B ===> tllist_all2 A B) tconcat tconcat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B ===> tllist_all2 (llist_all2 A) B ===> tllist_all2 A B) tconcat\n     tconcat", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       B x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           tllist_all2 (llist_all2 A) B xa ya \\<longrightarrow>\n           tllist_all2 A B (tconcat x xa) (tconcat y ya))", "by transfer(auto intro: llist_all2_lconcatI dest: llist_all2_lfiniteD)"], ["", "declare tconcat.transfer [transfer_rule]"], ["", "lemma tllist_all2_rsp:\n  assumes R1: \"\\<forall>x y. R1 x y \\<longrightarrow> (\\<forall>a b. R1 a b \\<longrightarrow> S x a = T y b)\"\n  and R2: \"\\<forall>x y. R2 x y \\<longrightarrow> (\\<forall>a b. R2 a b \\<longrightarrow> S' x a = T' y b)\"\n  and xsys: \"tllist_all2 R1 R2 xs ys\"\n  and xs'ys': \"tllist_all2 R1 R2 xs' ys'\"\n  shows \"tllist_all2 S S' xs xs' = tllist_all2 T T' ys ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 S S' xs xs' = tllist_all2 T T' ys ys'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. tllist_all2 S S' xs xs' \\<Longrightarrow> tllist_all2 T T' ys ys'\n 2. tllist_all2 T T' ys ys' \\<Longrightarrow> tllist_all2 S S' xs xs'", "assume \"tllist_all2 S S' xs xs'\""], ["proof (state)\nthis:\n  tllist_all2 S S' xs xs'\n\ngoal (2 subgoals):\n 1. tllist_all2 S S' xs xs' \\<Longrightarrow> tllist_all2 T T' ys ys'\n 2. tllist_all2 T T' ys ys' \\<Longrightarrow> tllist_all2 S S' xs xs'", "with xsys xs'ys'"], ["proof (chain)\npicking this:\n  tllist_all2 R1 R2 xs ys\n  tllist_all2 R1 R2 xs' ys'\n  tllist_all2 S S' xs xs'", "show \"tllist_all2 T T' ys ys'\""], ["proof (prove)\nusing this:\n  tllist_all2 R1 R2 xs ys\n  tllist_all2 R1 R2 xs' ys'\n  tllist_all2 S S' xs xs'\n\ngoal (1 subgoal):\n 1. tllist_all2 T T' ys ys'", "proof(coinduction arbitrary: ys ys' xs xs')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ysa ys' xsa xs'.\n       \\<lbrakk>tllist_all2 R1 R2 xsa ysa; tllist_all2 R1 R2 xs' ys';\n        tllist_all2 S S' xsa xs'\\<rbrakk>\n       \\<Longrightarrow> is_TNil ysa = is_TNil ys' \\<and>\n                         (is_TNil ysa \\<longrightarrow>\n                          is_TNil ys' \\<longrightarrow>\n                          T' (terminal ysa) (terminal ys')) \\<and>\n                         (\\<not> is_TNil ysa \\<longrightarrow>\n                          \\<not> is_TNil ys' \\<longrightarrow>\n                          T (thd ysa) (thd ys') \\<and>\n                          ((\\<exists>ys ys'a xs xs'.\n                               ttl ysa = ys \\<and>\n                               ttl ys' = ys'a \\<and>\n                               tllist_all2 R1 R2 xs ys \\<and>\n                               tllist_all2 R1 R2 xs' ys'a \\<and>\n                               tllist_all2 S S' xs xs') \\<or>\n                           tllist_all2 T T' (ttl ysa) (ttl ys')))", "case (tllist_all2 ys ys' xs xs')"], ["proof (state)\nthis:\n  tllist_all2 R1 R2 xs ys\n  tllist_all2 R1 R2 xs' ys'\n  tllist_all2 S S' xs xs'\n\ngoal (1 subgoal):\n 1. \\<And>ysa ys' xsa xs'.\n       \\<lbrakk>tllist_all2 R1 R2 xsa ysa; tllist_all2 R1 R2 xs' ys';\n        tllist_all2 S S' xsa xs'\\<rbrakk>\n       \\<Longrightarrow> is_TNil ysa = is_TNil ys' \\<and>\n                         (is_TNil ysa \\<longrightarrow>\n                          is_TNil ys' \\<longrightarrow>\n                          T' (terminal ysa) (terminal ys')) \\<and>\n                         (\\<not> is_TNil ysa \\<longrightarrow>\n                          \\<not> is_TNil ys' \\<longrightarrow>\n                          T (thd ysa) (thd ys') \\<and>\n                          ((\\<exists>ys ys'a xs xs'.\n                               ttl ysa = ys \\<and>\n                               ttl ys' = ys'a \\<and>\n                               tllist_all2 R1 R2 xs ys \\<and>\n                               tllist_all2 R1 R2 xs' ys'a \\<and>\n                               tllist_all2 S S' xs xs') \\<or>\n                           tllist_all2 T T' (ttl ysa) (ttl ys')))", "thus ?case"], ["proof (prove)\nusing this:\n  tllist_all2 R1 R2 xs ys\n  tllist_all2 R1 R2 xs' ys'\n  tllist_all2 S S' xs xs'\n\ngoal (1 subgoal):\n 1. is_TNil ys = is_TNil ys' \\<and>\n    (is_TNil ys \\<longrightarrow>\n     is_TNil ys' \\<longrightarrow> T' (terminal ys) (terminal ys')) \\<and>\n    (\\<not> is_TNil ys \\<longrightarrow>\n     \\<not> is_TNil ys' \\<longrightarrow>\n     T (thd ys) (thd ys') \\<and>\n     ((\\<exists>ys ys' xs xs'.\n          ttl ys = ys \\<and>\n          ttl ys' = ys' \\<and>\n          tllist_all2 R1 R2 xs ys \\<and>\n          tllist_all2 R1 R2 xs' ys' \\<and> tllist_all2 S S' xs xs') \\<or>\n      tllist_all2 T T' (ttl ys) (ttl ys')))", "by cases (auto 4 4 simp add: tllist_all2_TCons1 tllist_all2_TCons2 tllist_all2_TNil1 tllist_all2_TNil2 dest: R1[rule_format] R2[rule_format])"], ["proof (state)\nthis:\n  is_TNil ys = is_TNil ys' \\<and>\n  (is_TNil ys \\<longrightarrow>\n   is_TNil ys' \\<longrightarrow> T' (terminal ys) (terminal ys')) \\<and>\n  (\\<not> is_TNil ys \\<longrightarrow>\n   \\<not> is_TNil ys' \\<longrightarrow>\n   T (thd ys) (thd ys') \\<and>\n   ((\\<exists>ys ys' xs xs'.\n        ttl ys = ys \\<and>\n        ttl ys' = ys' \\<and>\n        tllist_all2 R1 R2 xs ys \\<and>\n        tllist_all2 R1 R2 xs' ys' \\<and> tllist_all2 S S' xs xs') \\<or>\n    tllist_all2 T T' (ttl ys) (ttl ys')))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tllist_all2 T T' ys ys'\n\ngoal (1 subgoal):\n 1. tllist_all2 T T' ys ys' \\<Longrightarrow> tllist_all2 S S' xs xs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tllist_all2 T T' ys ys' \\<Longrightarrow> tllist_all2 S S' xs xs'", "assume \"tllist_all2 T T' ys ys'\""], ["proof (state)\nthis:\n  tllist_all2 T T' ys ys'\n\ngoal (1 subgoal):\n 1. tllist_all2 T T' ys ys' \\<Longrightarrow> tllist_all2 S S' xs xs'", "with xsys xs'ys'"], ["proof (chain)\npicking this:\n  tllist_all2 R1 R2 xs ys\n  tllist_all2 R1 R2 xs' ys'\n  tllist_all2 T T' ys ys'", "show \"tllist_all2 S S' xs xs'\""], ["proof (prove)\nusing this:\n  tllist_all2 R1 R2 xs ys\n  tllist_all2 R1 R2 xs' ys'\n  tllist_all2 T T' ys ys'\n\ngoal (1 subgoal):\n 1. tllist_all2 S S' xs xs'", "proof(coinduction arbitrary: xs xs' ys ys')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa xs' ysa ys'.\n       \\<lbrakk>tllist_all2 R1 R2 xsa ysa; tllist_all2 R1 R2 xs' ys';\n        tllist_all2 T T' ysa ys'\\<rbrakk>\n       \\<Longrightarrow> is_TNil xsa = is_TNil xs' \\<and>\n                         (is_TNil xsa \\<longrightarrow>\n                          is_TNil xs' \\<longrightarrow>\n                          S' (terminal xsa) (terminal xs')) \\<and>\n                         (\\<not> is_TNil xsa \\<longrightarrow>\n                          \\<not> is_TNil xs' \\<longrightarrow>\n                          S (thd xsa) (thd xs') \\<and>\n                          ((\\<exists>xs xs'a ys ys'.\n                               ttl xsa = xs \\<and>\n                               ttl xs' = xs'a \\<and>\n                               tllist_all2 R1 R2 xs ys \\<and>\n                               tllist_all2 R1 R2 xs'a ys' \\<and>\n                               tllist_all2 T T' ys ys') \\<or>\n                           tllist_all2 S S' (ttl xsa) (ttl xs')))", "case (tllist_all2 xs xs' ys ys')"], ["proof (state)\nthis:\n  tllist_all2 R1 R2 xs ys\n  tllist_all2 R1 R2 xs' ys'\n  tllist_all2 T T' ys ys'\n\ngoal (1 subgoal):\n 1. \\<And>xsa xs' ysa ys'.\n       \\<lbrakk>tllist_all2 R1 R2 xsa ysa; tllist_all2 R1 R2 xs' ys';\n        tllist_all2 T T' ysa ys'\\<rbrakk>\n       \\<Longrightarrow> is_TNil xsa = is_TNil xs' \\<and>\n                         (is_TNil xsa \\<longrightarrow>\n                          is_TNil xs' \\<longrightarrow>\n                          S' (terminal xsa) (terminal xs')) \\<and>\n                         (\\<not> is_TNil xsa \\<longrightarrow>\n                          \\<not> is_TNil xs' \\<longrightarrow>\n                          S (thd xsa) (thd xs') \\<and>\n                          ((\\<exists>xs xs'a ys ys'.\n                               ttl xsa = xs \\<and>\n                               ttl xs' = xs'a \\<and>\n                               tllist_all2 R1 R2 xs ys \\<and>\n                               tllist_all2 R1 R2 xs'a ys' \\<and>\n                               tllist_all2 T T' ys ys') \\<or>\n                           tllist_all2 S S' (ttl xsa) (ttl xs')))", "thus ?case"], ["proof (prove)\nusing this:\n  tllist_all2 R1 R2 xs ys\n  tllist_all2 R1 R2 xs' ys'\n  tllist_all2 T T' ys ys'\n\ngoal (1 subgoal):\n 1. is_TNil xs = is_TNil xs' \\<and>\n    (is_TNil xs \\<longrightarrow>\n     is_TNil xs' \\<longrightarrow> S' (terminal xs) (terminal xs')) \\<and>\n    (\\<not> is_TNil xs \\<longrightarrow>\n     \\<not> is_TNil xs' \\<longrightarrow>\n     S (thd xs) (thd xs') \\<and>\n     ((\\<exists>xs xs' ys ys'.\n          ttl xs = xs \\<and>\n          ttl xs' = xs' \\<and>\n          tllist_all2 R1 R2 xs ys \\<and>\n          tllist_all2 R1 R2 xs' ys' \\<and> tllist_all2 T T' ys ys') \\<or>\n      tllist_all2 S S' (ttl xs) (ttl xs')))", "by cases(auto 4 4 simp add: tllist_all2_TCons1 tllist_all2_TCons2 tllist_all2_TNil1 tllist_all2_TNil2 dest: R1[rule_format] R2[rule_format])"], ["proof (state)\nthis:\n  is_TNil xs = is_TNil xs' \\<and>\n  (is_TNil xs \\<longrightarrow>\n   is_TNil xs' \\<longrightarrow> S' (terminal xs) (terminal xs')) \\<and>\n  (\\<not> is_TNil xs \\<longrightarrow>\n   \\<not> is_TNil xs' \\<longrightarrow>\n   S (thd xs) (thd xs') \\<and>\n   ((\\<exists>xs xs' ys ys'.\n        ttl xs = xs \\<and>\n        ttl xs' = xs' \\<and>\n        tllist_all2 R1 R2 xs ys \\<and>\n        tllist_all2 R1 R2 xs' ys' \\<and> tllist_all2 T T' ys ys') \\<or>\n    tllist_all2 S S' (ttl xs) (ttl xs')))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tllist_all2 S S' xs xs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tllist_all2_transfer2 [transfer_rule]:\n  \"((R1 ===> R1 ===> (=)) ===> (R2 ===> R2 ===> (=)) ===>\n    tllist_all2 R1 R2 ===> tllist_all2 R1 R2 ===> (=)) tllist_all2 tllist_all2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((R1 ===> R1 ===> (=)) ===>\n     (R2 ===> R2 ===> (=)) ===>\n     tllist_all2 R1 R2 ===> tllist_all2 R1 R2 ===> (=))\n     tllist_all2 tllist_all2", "by (simp add: tllist_all2_rsp rel_fun_def)"], ["", "declare tllist_all2_transfer [transfer_rule]"], ["", "end"], ["", "text \\<open>\n  Delete lifting rules for @{typ \"('a, 'b) tllist\"} \n  because the parametricity rules take precedence over\n  most of the transfer rules. They can be restored by \n  including the bundle \\<open>tllist.lifting\\<close>.\n\\<close>"], ["", "lifting_update tllist.lifting"], ["", "lifting_forget tllist.lifting"], ["", "end"]]}