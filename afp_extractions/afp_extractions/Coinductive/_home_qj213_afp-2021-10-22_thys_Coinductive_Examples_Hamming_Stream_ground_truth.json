{"file_name": "/home/qj213/afp-2021-10-22/thys/Coinductive/Examples/Hamming_Stream.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Coinductive", "problem_names": ["lemma infinity_inf_enat [simp]:\n  fixes n :: enat\n  shows \"\\<infinity> \\<sqinter> n = n\" \"n \\<sqinter> \\<infinity> = n\"", "lemma eSuc_inf_eSuc [simp]: \"eSuc n \\<sqinter> eSuc m = eSuc (n \\<sqinter> m)\"", "lemma if_pull2: \"(if b then f x x' else f y y') = f (if b then x else y) (if b then x' else y')\"", "lemma lnull_lmerge [simp]: \"lnull (lmerge xs ys) \\<longleftrightarrow> (lnull xs \\<or> lnull ys)\"", "lemma lmerge_eq_LNil_iff: \"lmerge xs ys = LNil \\<longleftrightarrow> (xs = LNil \\<or> ys = LNil)\"", "lemma lhd_lmerge: \"\\<lbrakk> \\<not> lnull xs; \\<not> lnull ys \\<rbrakk> \\<Longrightarrow> lhd (lmerge xs ys) = (if lhd xs < lhd ys then lhd xs else lhd ys)\"", "lemma ltl_lmerge:\n  \"\\<lbrakk> \\<not> lnull xs; \\<not> lnull ys \\<rbrakk> \\<Longrightarrow> \n  ltl (lmerge xs ys) = \n  (if lhd xs < lhd ys then lmerge (ltl xs) ys \n   else if lhd ys < lhd xs then lmerge xs (ltl ys) \n   else lmerge (ltl xs) (ltl ys))\"", "lemma lmerge_simps:\n  \"lmerge (LCons x xs) (LCons y ys) =\n  (if x < y then LCons x (lmerge xs (LCons y ys))\n   else if y < x then LCons y (lmerge (LCons x xs) ys)\n   else LCons y (lmerge xs ys))\"", "lemma lmerge_LNil [simp]:\n  \"lmerge LNil ys = LNil\"\n  \"lmerge xs LNil = LNil\"", "lemma lprefix_lmergeI:\n  \"\\<lbrakk> lprefix xs xs'; lprefix ys ys' \\<rbrakk>\n  \\<Longrightarrow> lprefix (lmerge xs ys) (lmerge xs' ys')\"", "lemma [partial_function_mono]:\n  assumes F: \"mono_llist F\" and G: \"mono_llist G\"\n  shows \"mono_llist (\\<lambda>f. lmerge (F f) (G f))\"", "lemma in_lset_lmergeD: \"x \\<in> lset (lmerge xs ys) \\<Longrightarrow> x \\<in> lset xs \\<or> x \\<in> lset ys\"", "lemma lset_lmerge: \"lset (lmerge xs ys) \\<subseteq> lset xs \\<union> lset ys\"", "lemma lfinite_lmergeD: \"lfinite (lmerge xs ys) \\<Longrightarrow> lfinite xs \\<or> lfinite ys\"", "lemma fixes F\n  defines \"F \\<equiv> \\<lambda>lmerge (xs, ys). case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> case ys of LNil \\<Rightarrow> LNil | LCons y ys' \\<Rightarrow> (if x < y then LCons x (curry lmerge xs' ys) else if y < x then LCons y (curry lmerge xs ys') else LCons y (curry lmerge xs' ys'))\"\n  shows lmerge_conv_fixp: \"lmerge \\<equiv> curry (ccpo.fixp (fun_lub lSup) (fun_ord lprefix) F)\" (is \"?lhs \\<equiv> ?rhs\")\n  and lmerge_mono: \"mono_llist (\\<lambda>lmerge. F lmerge xs)\" (is \"?mono xs\")", "lemma monotone_lmerge: \"monotone (rel_prod lprefix lprefix) lprefix (case_prod lmerge)\"", "lemma mono2mono_lmerge1 [THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_lmerge1: \"monotone lprefix lprefix (\\<lambda>xs. lmerge xs ys)\"", "lemma mono2mono_lmerge2 [THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_lmerge2: \"monotone lprefix lprefix (\\<lambda>ys. lmerge xs ys)\"", "lemma mcont_lmerge: \"mcont (prod_lub lSup lSup) (rel_prod lprefix lprefix) lSup lprefix (case_prod lmerge)\"", "lemma mcont2mcont_lmerge1 [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_lmerge1: \"mcont lSup lprefix lSup lprefix (\\<lambda>xs. lmerge xs ys)\"", "lemma mcont2mcont_lmerge2 [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_lmerge2: \"mcont lSup lprefix lSup lprefix (\\<lambda>ys. lmerge xs ys)\"", "lemma lfinite_lmergeI [simp]: \"\\<lbrakk> lfinite xs; lfinite ys \\<rbrakk> \\<Longrightarrow> lfinite (lmerge xs ys)\"", "lemma linfinite_lmerge [simp]: \"\\<lbrakk> \\<not> lfinite xs; \\<not> lfinite ys \\<rbrakk> \\<Longrightarrow> \\<not> lfinite (lmerge xs ys)\"", "lemma llength_lmerge_above: \"llength xs \\<sqinter> llength ys \\<le> llength (lmerge xs ys)\"", "lemma in_lset_lmergeI1:\n  \"\\<lbrakk> x \\<in> lset xs; lsorted xs; \\<not> lfinite ys; \\<exists>y\\<in>lset ys. x \\<le> y \\<rbrakk>\n  \\<Longrightarrow> x \\<in> lset (lmerge xs ys)\"", "lemma in_lset_lmergeI2:\n  \"\\<lbrakk> x \\<in> lset ys; lsorted ys; \\<not> lfinite xs; \\<exists>y\\<in>lset xs. x \\<le> y \\<rbrakk>\n  \\<Longrightarrow> x \\<in> lset (lmerge xs ys)\"", "lemma lsorted_lmerge: \"\\<lbrakk> lsorted xs; lsorted ys \\<rbrakk> \\<Longrightarrow> lsorted (lmerge xs ys)\"", "lemma ldistinct_lmerge: \n  \"\\<lbrakk> lsorted xs; lsorted ys; ldistinct xs; ldistinct ys \\<rbrakk>\n  \\<Longrightarrow> ldistinct (lmerge xs ys)\"", "lemma lnull_hamming [simp]: \"\\<not> lnull hamming\"", "lemma hamming_eq_LNil_iff [simp]: \"hamming = LNil \\<longleftrightarrow> False\"", "lemma lhd_hamming [simp]: \"lhd hamming = 1\"", "lemma ltl_hamming [simp]:\n  \"ltl hamming = lmerge (lmap ((*) 2) hamming) (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming))\"", "lemma hamming_unfold:\n  \"hamming = LCons 1 (lmerge (lmap ((*) 2) hamming) (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming)))\"", "lemma smooth_0 [simp]: \"\\<not> smooth 0\"", "lemma smooth_Suc0 [simp]: \"smooth (Suc 0)\"", "lemma smooth_gt0: \"smooth n \\<Longrightarrow> n > 0\"", "lemma smooth_ge_Suc0: \"smooth n \\<Longrightarrow> n \\<ge> Suc 0\"", "lemma prime_nat_dvdD: \"prime p \\<Longrightarrow> (n :: nat) dvd p \\<Longrightarrow> n = 1 \\<or> n = p\"", "lemma smooth_times [simp]: \"smooth (x * y) \\<longleftrightarrow> smooth x \\<and> smooth y\"", "lemma smooth2 [simp]: \"smooth 2\"", "lemma smooth3 [simp]: \"smooth 3\"", "lemma smooth5 [simp]: \"smooth 5\"", "lemma hamming_in_smooth: \"lset hamming \\<subseteq> {n. smooth n}\"", "lemma lfinite_hamming [simp]: \"\\<not> lfinite hamming\"", "lemma lsorted_hamming [simp]: \"lsorted hamming\"\n  and ldistinct_hamming [simp]: \"ldistinct hamming\"", "lemma smooth_hamming:\n  assumes \"smooth n\"\n  shows \"n \\<in> lset hamming\"", "lemma hamming_THE:\n  \"(THE xs. lsorted xs \\<and> ldistinct xs \\<and> lset xs = {n. smooth n}) = hamming\""], "translations": [["", "lemma infinity_inf_enat [simp]:\n  fixes n :: enat\n  shows \"\\<infinity> \\<sqinter> n = n\" \"n \\<sqinter> \\<infinity> = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> \\<sqinter> n = n &&& n \\<sqinter> \\<infinity> = n", "by(simp_all add: inf_enat_def)"], ["", "lemma eSuc_inf_eSuc [simp]: \"eSuc n \\<sqinter> eSuc m = eSuc (n \\<sqinter> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSuc n \\<sqinter> eSuc m = eSuc (n \\<sqinter> m)", "by(simp add: inf_enat_def)"], ["", "lemma if_pull2: \"(if b then f x x' else f y y') = f (if b then x else y) (if b then x' else y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b then f x x' else f y y') =\n    f (if b then x else y) (if b then x' else y')", "by simp"], ["", "context ord begin"], ["", "primcorec lmerge :: \"'a llist \\<Rightarrow> 'a llist \\<Rightarrow> 'a llist\"\nwhere \n  \"lmerge xs ys =\n   (case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow>\n    case ys of LNil \\<Rightarrow> LNil | LCons y ys' \\<Rightarrow>\n    if lhd xs < lhd ys then LCons x (lmerge xs' ys)\n    else LCons y (if lhd ys < lhd xs then lmerge xs ys' else lmerge xs' ys'))\""], ["", "lemma lnull_lmerge [simp]: \"lnull (lmerge xs ys) \\<longleftrightarrow> (lnull xs \\<or> lnull ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (lmerge xs ys) = (lnull xs \\<or> lnull ys)", "by(simp add: lmerge_def)"], ["", "lemma lmerge_eq_LNil_iff: \"lmerge xs ys = LNil \\<longleftrightarrow> (xs = LNil \\<or> ys = LNil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lmerge xs ys = LNil) = (xs = LNil \\<or> ys = LNil)", "using lnull_lmerge"], ["proof (prove)\nusing this:\n  lnull (lmerge ?xs ?ys) = (lnull ?xs \\<or> lnull ?ys)\n\ngoal (1 subgoal):\n 1. (lmerge xs ys = LNil) = (xs = LNil \\<or> ys = LNil)", "unfolding lnull_def"], ["proof (prove)\nusing this:\n  (lmerge ?xs ?ys = LNil) = (?xs = LNil \\<or> ?ys = LNil)\n\ngoal (1 subgoal):\n 1. (lmerge xs ys = LNil) = (xs = LNil \\<or> ys = LNil)", "."], ["", "lemma lhd_lmerge: \"\\<lbrakk> \\<not> lnull xs; \\<not> lnull ys \\<rbrakk> \\<Longrightarrow> lhd (lmerge xs ys) = (if lhd xs < lhd ys then lhd xs else lhd ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lnull xs; \\<not> lnull ys\\<rbrakk>\n    \\<Longrightarrow> lhd (lmerge xs ys) =\n                      (if lhd xs < lhd ys then lhd xs else lhd ys)", "by(auto split: llist.split)"], ["", "lemma ltl_lmerge:\n  \"\\<lbrakk> \\<not> lnull xs; \\<not> lnull ys \\<rbrakk> \\<Longrightarrow> \n  ltl (lmerge xs ys) = \n  (if lhd xs < lhd ys then lmerge (ltl xs) ys \n   else if lhd ys < lhd xs then lmerge xs (ltl ys) \n   else lmerge (ltl xs) (ltl ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lnull xs; \\<not> lnull ys\\<rbrakk>\n    \\<Longrightarrow> ltl (lmerge xs ys) =\n                      (if lhd xs < lhd ys then lmerge (ltl xs) ys\n                       else if lhd ys < lhd xs then lmerge xs (ltl ys)\n                            else lmerge (ltl xs) (ltl ys))", "by(auto split: llist.split)"], ["", "declare lmerge.sel [simp del]"], ["", "lemma lmerge_simps:\n  \"lmerge (LCons x xs) (LCons y ys) =\n  (if x < y then LCons x (lmerge xs (LCons y ys))\n   else if y < x then LCons y (lmerge (LCons x xs) ys)\n   else LCons y (lmerge xs ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmerge (LCons x xs) (LCons y ys) =\n    (if x < y then LCons x (lmerge xs (LCons y ys))\n     else if y < x then LCons y (lmerge (LCons x xs) ys)\n          else LCons y (lmerge xs ys))", "by(rule llist.expand)(simp_all add: lhd_lmerge ltl_lmerge)"], ["", "lemma lmerge_LNil [simp]:\n  \"lmerge LNil ys = LNil\"\n  \"lmerge xs LNil = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmerge LNil ys = LNil &&& lmerge xs LNil = LNil", "by simp_all"], ["", "lemma lprefix_lmergeI:\n  \"\\<lbrakk> lprefix xs xs'; lprefix ys ys' \\<rbrakk>\n  \\<Longrightarrow> lprefix (lmerge xs ys) (lmerge xs' ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lprefix xs xs'; lprefix ys ys'\\<rbrakk>\n    \\<Longrightarrow> lprefix (lmerge xs ys) (lmerge xs' ys')", "by(coinduction arbitrary: xs xs' ys ys')(fastforce simp add: lhd_lmerge ltl_lmerge dest: lprefix_lhdD lprefix_lnullD simp add: not_lnull_conv split: if_split_asm)"], ["", "lemma [partial_function_mono]:\n  assumes F: \"mono_llist F\" and G: \"mono_llist G\"\n  shows \"mono_llist (\\<lambda>f. lmerge (F f) (G f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_llist (\\<lambda>f. lmerge (F f) (G f))", "by(blast intro: monotoneI lprefix_lmergeI monotoneD[OF F] monotoneD[OF G])"], ["", "lemma in_lset_lmergeD: \"x \\<in> lset (lmerge xs ys) \\<Longrightarrow> x \\<in> lset xs \\<or> x \\<in> lset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> lset (lmerge xs ys) \\<Longrightarrow>\n    x \\<in> lset xs \\<or> x \\<in> lset ys", "by(induct zs\\<equiv>\"lmerge xs ys\" arbitrary: xs ys rule: llist_set_induct)(auto simp add: lhd_lmerge ltl_lmerge split: if_split_asm dest: in_lset_ltlD)"], ["", "lemma lset_lmerge: \"lset (lmerge xs ys) \\<subseteq> lset xs \\<union> lset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lmerge xs ys) \\<subseteq> lset xs \\<union> lset ys", "by(auto dest: in_lset_lmergeD)"], ["", "lemma lfinite_lmergeD: \"lfinite (lmerge xs ys) \\<Longrightarrow> lfinite xs \\<or> lfinite ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (lmerge xs ys) \\<Longrightarrow> lfinite xs \\<or> lfinite ys", "by(induct zs\\<equiv>\"lmerge xs ys\" arbitrary: xs ys rule: lfinite_induct)(fastforce simp add: ltl_lmerge if_pull2 split: if_split_asm)+"], ["", "lemma fixes F\n  defines \"F \\<equiv> \\<lambda>lmerge (xs, ys). case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> case ys of LNil \\<Rightarrow> LNil | LCons y ys' \\<Rightarrow> (if x < y then LCons x (curry lmerge xs' ys) else if y < x then LCons y (curry lmerge xs ys') else LCons y (curry lmerge xs' ys'))\"\n  shows lmerge_conv_fixp: \"lmerge \\<equiv> curry (ccpo.fixp (fun_lub lSup) (fun_ord lprefix) F)\" (is \"?lhs \\<equiv> ?rhs\")\n  and lmerge_mono: \"mono_llist (\\<lambda>lmerge. F lmerge xs)\" (is \"?mono xs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lmerge \\<equiv> curry (llist.fixp_fun F)) &&&\n    mono_llist (\\<lambda>lmerge. F lmerge xs)", "proof(intro eq_reflection ext)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. lmerge x xa = curry (llist.fixp_fun F) x xa\n 2. mono_llist (\\<lambda>lmerge. F lmerge xs)", "show mono: \"\\<And>xs. ?mono xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. mono_llist (\\<lambda>lmerge. F lmerge xs)", "unfolding F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       mono_llist\n        (\\<lambda>lmerge.\n            case xs of\n            (xs, ys) \\<Rightarrow>\n              case xs of LNil \\<Rightarrow> LNil\n              | LCons x xs' \\<Rightarrow>\n                  case ys of LNil \\<Rightarrow> LNil\n                  | LCons y ys' \\<Rightarrow>\n                      if x < y then LCons x (curry lmerge xs' ys)\n                      else if y < x then LCons y (curry lmerge xs ys')\n                           else LCons y (curry lmerge xs' ys'))", "by(tactic \\<open>Partial_Function.mono_tac @{context} 1\\<close>)"], ["proof (state)\nthis:\n  mono_llist (\\<lambda>lmerge. F lmerge ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xa. lmerge x xa = curry (llist.fixp_fun F) x xa", "fix xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. lmerge x xa = curry (llist.fixp_fun F) x xa", "show \"lmerge xs ys = ?rhs xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmerge xs ys = curry (llist.fixp_fun F) xs ys", "proof(coinduction arbitrary: xs ys)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       lnull (lmerge xs ys) = lnull (curry (llist.fixp_fun F) xs ys) \\<and>\n       (\\<not> lnull (lmerge xs ys) \\<longrightarrow>\n        \\<not> lnull (curry (llist.fixp_fun F) xs ys) \\<longrightarrow>\n        lhd (lmerge xs ys) = lhd (curry (llist.fixp_fun F) xs ys) \\<and>\n        (\\<exists>xsa ysa.\n            ltl (lmerge xs ys) = lmerge xsa ysa \\<and>\n            ltl (curry (llist.fixp_fun F) xs ys) =\n            curry (llist.fixp_fun F) xsa ysa))", "case Eq_llist"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       lnull (lmerge xs ys) = lnull (curry (llist.fixp_fun F) xs ys) \\<and>\n       (\\<not> lnull (lmerge xs ys) \\<longrightarrow>\n        \\<not> lnull (curry (llist.fixp_fun F) xs ys) \\<longrightarrow>\n        lhd (lmerge xs ys) = lhd (curry (llist.fixp_fun F) xs ys) \\<and>\n        (\\<exists>xsa ysa.\n            ltl (lmerge xs ys) = lmerge xsa ysa \\<and>\n            ltl (curry (llist.fixp_fun F) xs ys) =\n            curry (llist.fixp_fun F) xsa ysa))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (lmerge xs ys) = lnull (curry (llist.fixp_fun F) xs ys) \\<and>\n    (\\<not> lnull (lmerge xs ys) \\<longrightarrow>\n     \\<not> lnull (curry (llist.fixp_fun F) xs ys) \\<longrightarrow>\n     lhd (lmerge xs ys) = lhd (curry (llist.fixp_fun F) xs ys) \\<and>\n     (\\<exists>xs ys.\n         ltl (lmerge xs ys) = lmerge xs ys \\<and>\n         ltl (curry (llist.fixp_fun F) xs ys) =\n         curry (llist.fixp_fun F) xs ys))", "by(subst (1 3 4) llist.mono_body_fixp[OF mono])(auto simp add: F_def lmerge_simps split: llist.split)"], ["proof (state)\nthis:\n  lnull (lmerge xs ys) = lnull (curry (llist.fixp_fun F) xs ys) \\<and>\n  (\\<not> lnull (lmerge xs ys) \\<longrightarrow>\n   \\<not> lnull (curry (llist.fixp_fun F) xs ys) \\<longrightarrow>\n   lhd (lmerge xs ys) = lhd (curry (llist.fixp_fun F) xs ys) \\<and>\n   (\\<exists>xs ys.\n       ltl (lmerge xs ys) = lmerge xs ys \\<and>\n       ltl (curry (llist.fixp_fun F) xs ys) =\n       curry (llist.fixp_fun F) xs ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lmerge xs ys = curry (llist.fixp_fun F) xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monotone_lmerge: \"monotone (rel_prod lprefix lprefix) lprefix (case_prod lmerge)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (rel_prod lprefix lprefix) lprefix\n     (\\<lambda>(x, y). lmerge x y)", "apply(rule llist.fixp_preserves_mono2[OF lmerge_mono lmerge_conv_fixp])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       monotone (rel_prod lprefix lprefix) lprefix\n        (\\<lambda>(x, y). f x y) \\<Longrightarrow>\n       monotone (rel_prod lprefix lprefix) lprefix\n        (\\<lambda>(b, a).\n            case b of LNil \\<Rightarrow> LNil\n            | LCons x xs' \\<Rightarrow>\n                case a of LNil \\<Rightarrow> LNil\n                | LCons y ys' \\<Rightarrow>\n                    if x < y then LCons x (f xs' a)\n                    else if y < x then LCons y (f b ys')\n                         else LCons y (f xs' ys'))", "apply(erule conjE|rule allI conjI cont_intro|simp|erule allE, erule llist.mono2mono)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mono2mono_lmerge1 [THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_lmerge1: \"monotone lprefix lprefix (\\<lambda>xs. lmerge xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone lprefix lprefix (\\<lambda>xs. lmerge xs ys)", "by(simp add: monotone_lmerge[simplified])"], ["", "lemma mono2mono_lmerge2 [THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_lmerge2: \"monotone lprefix lprefix (\\<lambda>ys. lmerge xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone lprefix lprefix (lmerge xs)", "by(simp add: monotone_lmerge[simplified])"], ["", "lemma mcont_lmerge: \"mcont (prod_lub lSup lSup) (rel_prod lprefix lprefix) lSup lprefix (case_prod lmerge)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont (prod_lub lSup lSup) (rel_prod lprefix lprefix) lSup lprefix\n     (\\<lambda>(x, y). lmerge x y)", "apply(rule llist.fixp_preserves_mcont2[OF lmerge_mono lmerge_conv_fixp])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       mcont (prod_lub lSup lSup) (rel_prod lprefix lprefix) lSup lprefix\n        (\\<lambda>(x, y). f x y) \\<Longrightarrow>\n       mcont (prod_lub lSup lSup) (rel_prod lprefix lprefix) lSup lprefix\n        (\\<lambda>(b, a).\n            case b of LNil \\<Rightarrow> LNil\n            | LCons x xs' \\<Rightarrow>\n                case a of LNil \\<Rightarrow> LNil\n                | LCons y ys' \\<Rightarrow>\n                    if x < y then LCons x (f xs' a)\n                    else if y < x then LCons y (f b ys')\n                         else LCons y (f xs' ys'))", "apply(erule conjE|rule allI conjI cont_intro|simp|erule allE, erule llist.mcont2mcont)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mcont2mcont_lmerge1 [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_lmerge1: \"mcont lSup lprefix lSup lprefix (\\<lambda>xs. lmerge xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup lprefix lSup lprefix (\\<lambda>xs. lmerge xs ys)", "by(simp add: mcont_lmerge[simplified])"], ["", "lemma mcont2mcont_lmerge2 [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_lmerge2: \"mcont lSup lprefix lSup lprefix (\\<lambda>ys. lmerge xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup lprefix lSup lprefix (lmerge xs)", "by(simp add: mcont_lmerge[simplified])"], ["", "lemma lfinite_lmergeI [simp]: \"\\<lbrakk> lfinite xs; lfinite ys \\<rbrakk> \\<Longrightarrow> lfinite (lmerge xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lfinite xs; lfinite ys\\<rbrakk>\n    \\<Longrightarrow> lfinite (lmerge xs ys)", "proof(induction arbitrary: ys rule: lfinite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>lnull xs; lfinite ys\\<rbrakk>\n       \\<Longrightarrow> lfinite (lmerge xs ys)\n 2. \\<And>xs ys.\n       \\<lbrakk>lfinite xs; \\<not> lnull xs;\n        \\<And>ys. lfinite ys \\<Longrightarrow> lfinite (lmerge (ltl xs) ys);\n        lfinite ys\\<rbrakk>\n       \\<Longrightarrow> lfinite (lmerge xs ys)", "case (LCons xs)"], ["proof (state)\nthis:\n  lfinite xs\n  \\<not> lnull xs\n  lfinite ?ys \\<Longrightarrow> lfinite (lmerge (ltl xs) ?ys)\n  lfinite ys\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>lnull xs; lfinite ys\\<rbrakk>\n       \\<Longrightarrow> lfinite (lmerge xs ys)\n 2. \\<And>xs ys.\n       \\<lbrakk>lfinite xs; \\<not> lnull xs;\n        \\<And>ys. lfinite ys \\<Longrightarrow> lfinite (lmerge (ltl xs) ys);\n        lfinite ys\\<rbrakk>\n       \\<Longrightarrow> lfinite (lmerge xs ys)", "from LCons.prems LCons.hyps LCons.IH"], ["proof (chain)\npicking this:\n  lfinite ys\n  lfinite xs\n  \\<not> lnull xs\n  lfinite ?ys \\<Longrightarrow> lfinite (lmerge (ltl xs) ?ys)", "show ?case"], ["proof (prove)\nusing this:\n  lfinite ys\n  lfinite xs\n  \\<not> lnull xs\n  lfinite ?ys \\<Longrightarrow> lfinite (lmerge (ltl xs) ?ys)\n\ngoal (1 subgoal):\n 1. lfinite (lmerge xs ys)", "by induct(clarsimp simp add: not_lnull_conv lmerge_simps)+"], ["proof (state)\nthis:\n  lfinite (lmerge xs ys)\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>lnull xs; lfinite ys\\<rbrakk>\n       \\<Longrightarrow> lfinite (lmerge xs ys)", "qed simp"], ["", "lemma linfinite_lmerge [simp]: \"\\<lbrakk> \\<not> lfinite xs; \\<not> lfinite ys \\<rbrakk> \\<Longrightarrow> \\<not> lfinite (lmerge xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lfinite xs; \\<not> lfinite ys\\<rbrakk>\n    \\<Longrightarrow> \\<not> lfinite (lmerge xs ys)", "by(auto dest: lfinite_lmergeD)"], ["", "lemma llength_lmerge_above: \"llength xs \\<sqinter> llength ys \\<le> llength (lmerge xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs \\<sqinter> llength ys \\<le> llength (lmerge xs ys)", "proof(induction xs arbitrary: ys)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible lSup lprefix\n     (\\<lambda>a.\n         \\<forall>x.\n            llength a \\<sqinter> llength x \\<le> llength (lmerge a x))\n 2. \\<And>ys.\n       llength LNil \\<sqinter> llength ys \\<le> llength (lmerge LNil ys)\n 3. \\<And>x xs ys.\n       \\<lbrakk>lfinite xs;\n        \\<And>ys.\n           llength xs \\<sqinter> llength ys\n           \\<le> llength (lmerge xs ys)\\<rbrakk>\n       \\<Longrightarrow> llength (LCons x xs) \\<sqinter> llength ys\n                         \\<le> llength (lmerge (LCons x xs) ys)", "case (LCons x xs)"], ["proof (state)\nthis:\n  lfinite xs\n  llength xs \\<sqinter> llength ?ys \\<le> llength (lmerge xs ?ys)\n\ngoal (3 subgoals):\n 1. ccpo.admissible lSup lprefix\n     (\\<lambda>a.\n         \\<forall>x.\n            llength a \\<sqinter> llength x \\<le> llength (lmerge a x))\n 2. \\<And>ys.\n       llength LNil \\<sqinter> llength ys \\<le> llength (lmerge LNil ys)\n 3. \\<And>x xs ys.\n       \\<lbrakk>lfinite xs;\n        \\<And>ys.\n           llength xs \\<sqinter> llength ys\n           \\<le> llength (lmerge xs ys)\\<rbrakk>\n       \\<Longrightarrow> llength (LCons x xs) \\<sqinter> llength ys\n                         \\<le> llength (lmerge (LCons x xs) ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (LCons x xs) \\<sqinter> llength ys\n    \\<le> llength (lmerge (LCons x xs) ys)", "proof(induct ys)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible lSup lprefix\n     (\\<lambda>a.\n         llength (LCons x xs) \\<sqinter> llength a\n         \\<le> llength (lmerge (LCons x xs) a))\n 2. llength (LCons x xs) \\<sqinter> llength LNil\n    \\<le> llength (lmerge (LCons x xs) LNil)\n 3. \\<And>xa ys.\n       \\<lbrakk>lfinite ys;\n        llength (LCons x xs) \\<sqinter> llength ys\n        \\<le> llength (lmerge (LCons x xs) ys)\\<rbrakk>\n       \\<Longrightarrow> llength (LCons x xs) \\<sqinter>\n                         llength (LCons xa ys)\n                         \\<le> llength (lmerge (LCons x xs) (LCons xa ys))", "case LCons"], ["proof (state)\nthis:\n  lfinite ys_\n  llength (LCons x xs) \\<sqinter> llength ys_\n  \\<le> llength (lmerge (LCons x xs) ys_)\n\ngoal (3 subgoals):\n 1. ccpo.admissible lSup lprefix\n     (\\<lambda>a.\n         llength (LCons x xs) \\<sqinter> llength a\n         \\<le> llength (lmerge (LCons x xs) a))\n 2. llength (LCons x xs) \\<sqinter> llength LNil\n    \\<le> llength (lmerge (LCons x xs) LNil)\n 3. \\<And>xa ys.\n       \\<lbrakk>lfinite ys;\n        llength (LCons x xs) \\<sqinter> llength ys\n        \\<le> llength (lmerge (LCons x xs) ys)\\<rbrakk>\n       \\<Longrightarrow> llength (LCons x xs) \\<sqinter>\n                         llength (LCons xa ys)\n                         \\<le> llength (lmerge (LCons x xs) (LCons xa ys))", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite ys_\n  llength (LCons x xs) \\<sqinter> llength ys_\n  \\<le> llength (lmerge (LCons x xs) ys_)\n\ngoal (1 subgoal):\n 1. llength (LCons x xs) \\<sqinter> llength (LCons x_ ys_)\n    \\<le> llength (lmerge (LCons x xs) (LCons x_ ys_))", "using LCons.IH"], ["proof (prove)\nusing this:\n  lfinite ys_\n  llength (LCons x xs) \\<sqinter> llength ys_\n  \\<le> llength (lmerge (LCons x xs) ys_)\n  llength xs \\<sqinter> llength ?ys \\<le> llength (lmerge xs ?ys)\n\ngoal (1 subgoal):\n 1. llength (LCons x xs) \\<sqinter> llength (LCons x_ ys_)\n    \\<le> llength (lmerge (LCons x xs) (LCons x_ ys_))", "by(fastforce simp add: bot_enat_def[symmetric] lmerge_simps le_infI1 le_infI2 intro: order_trans[rotated])"], ["proof (state)\nthis:\n  llength (LCons x xs) \\<sqinter> llength (LCons x_ ys_)\n  \\<le> llength (lmerge (LCons x xs) (LCons x_ ys_))\n\ngoal (2 subgoals):\n 1. ccpo.admissible lSup lprefix\n     (\\<lambda>a.\n         llength (LCons x xs) \\<sqinter> llength a\n         \\<le> llength (lmerge (LCons x xs) a))\n 2. llength (LCons x xs) \\<sqinter> llength LNil\n    \\<le> llength (lmerge (LCons x xs) LNil)", "qed(simp_all add: bot_enat_def[symmetric])"], ["proof (state)\nthis:\n  llength (LCons x xs) \\<sqinter> llength ys\n  \\<le> llength (lmerge (LCons x xs) ys)\n\ngoal (2 subgoals):\n 1. ccpo.admissible lSup lprefix\n     (\\<lambda>a.\n         \\<forall>x.\n            llength a \\<sqinter> llength x \\<le> llength (lmerge a x))\n 2. \\<And>ys.\n       llength LNil \\<sqinter> llength ys \\<le> llength (lmerge LNil ys)", "qed(simp_all add: bot_enat_def[symmetric])"], ["", "end"], ["", "context linorder begin"], ["", "lemma in_lset_lmergeI1:\n  \"\\<lbrakk> x \\<in> lset xs; lsorted xs; \\<not> lfinite ys; \\<exists>y\\<in>lset ys. x \\<le> y \\<rbrakk>\n  \\<Longrightarrow> x \\<in> lset (lmerge xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> lset xs; lsorted xs; \\<not> lfinite ys;\n     \\<exists>y\\<in>lset ys. x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> lset (lmerge xs ys)", "proof(induction arbitrary: ys rule: lset_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>lsorted (LCons x xs); \\<not> lfinite ys;\n        Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge (LCons x xs) ys)\n 2. \\<And>x' xs ys.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>ys.\n           \\<lbrakk>lsorted xs; \\<not> lfinite ys;\n            Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xs ys);\n        lsorted (LCons x' xs); \\<not> lfinite ys;\n        Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge (LCons x' xs) ys)", "case (find xs)"], ["proof (state)\nthis:\n  lsorted (LCons x xs)\n  \\<not> lfinite ys\n  \\<exists>a\\<in>lset ys. x \\<le> a\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>lsorted (LCons x xs); \\<not> lfinite ys;\n        Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge (LCons x xs) ys)\n 2. \\<And>x' xs ys.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>ys.\n           \\<lbrakk>lsorted xs; \\<not> lfinite ys;\n            Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xs ys);\n        lsorted (LCons x' xs); \\<not> lfinite ys;\n        Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge (LCons x' xs) ys)", "then"], ["proof (chain)\npicking this:\n  lsorted (LCons x xs)\n  \\<not> lfinite ys\n  \\<exists>a\\<in>lset ys. x \\<le> a", "obtain y where \"y \\<in> lset ys\" \"x \\<le> y\""], ["proof (prove)\nusing this:\n  lsorted (LCons x xs)\n  \\<not> lfinite ys\n  \\<exists>a\\<in>lset ys. x \\<le> a\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> lset ys; x \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> lset ys\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>lsorted (LCons x xs); \\<not> lfinite ys;\n        Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge (LCons x xs) ys)\n 2. \\<And>x' xs ys.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>ys.\n           \\<lbrakk>lsorted xs; \\<not> lfinite ys;\n            Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xs ys);\n        lsorted (LCons x' xs); \\<not> lfinite ys;\n        Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge (LCons x' xs) ys)", "thus ?case"], ["proof (prove)\nusing this:\n  y \\<in> lset ys\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<in> lset (lmerge (LCons x xs) ys)", "by induct(auto simp add: lmerge_simps not_less)"], ["proof (state)\nthis:\n  x \\<in> lset (lmerge (LCons x xs) ys)\n\ngoal (1 subgoal):\n 1. \\<And>x' xs ys.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>ys.\n           \\<lbrakk>lsorted xs; \\<not> lfinite ys;\n            Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xs ys);\n        lsorted (LCons x' xs); \\<not> lfinite ys;\n        Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge (LCons x' xs) ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x' xs ys.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>ys.\n           \\<lbrakk>lsorted xs; \\<not> lfinite ys;\n            Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xs ys);\n        lsorted (LCons x' xs); \\<not> lfinite ys;\n        Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge (LCons x' xs) ys)", "case (step x' xs)"], ["proof (state)\nthis:\n  x \\<in> lset xs\n  x \\<noteq> x'\n  \\<lbrakk>lsorted xs; \\<not> lfinite ?ys;\n   \\<exists>a\\<in>lset ?ys. x \\<le> a\\<rbrakk>\n  \\<Longrightarrow> x \\<in> lset (lmerge xs ?ys)\n  lsorted (LCons x' xs)\n  \\<not> lfinite ys\n  \\<exists>a\\<in>lset ys. x \\<le> a\n\ngoal (1 subgoal):\n 1. \\<And>x' xs ys.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>ys.\n           \\<lbrakk>lsorted xs; \\<not> lfinite ys;\n            Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xs ys);\n        lsorted (LCons x' xs); \\<not> lfinite ys;\n        Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge (LCons x' xs) ys)", "then"], ["proof (chain)\npicking this:\n  x \\<in> lset xs\n  x \\<noteq> x'\n  \\<lbrakk>lsorted xs; \\<not> lfinite ?ys;\n   \\<exists>a\\<in>lset ?ys. x \\<le> a\\<rbrakk>\n  \\<Longrightarrow> x \\<in> lset (lmerge xs ?ys)\n  lsorted (LCons x' xs)\n  \\<not> lfinite ys\n  \\<exists>a\\<in>lset ys. x \\<le> a", "obtain y where \"y \\<in> lset ys\" \"x \\<le> y\""], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n  x \\<noteq> x'\n  \\<lbrakk>lsorted xs; \\<not> lfinite ?ys;\n   \\<exists>a\\<in>lset ?ys. x \\<le> a\\<rbrakk>\n  \\<Longrightarrow> x \\<in> lset (lmerge xs ?ys)\n  lsorted (LCons x' xs)\n  \\<not> lfinite ys\n  \\<exists>a\\<in>lset ys. x \\<le> a\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> lset ys; x \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> lset ys\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x' xs ys.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>ys.\n           \\<lbrakk>lsorted xs; \\<not> lfinite ys;\n            Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xs ys);\n        lsorted (LCons x' xs); \\<not> lfinite ys;\n        Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge (LCons x' xs) ys)", "moreover"], ["proof (state)\nthis:\n  y \\<in> lset ys\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x' xs ys.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>ys.\n           \\<lbrakk>lsorted xs; \\<not> lfinite ys;\n            Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xs ys);\n        lsorted (LCons x' xs); \\<not> lfinite ys;\n        Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge (LCons x' xs) ys)", "from \\<open>lsorted (LCons x' xs)\\<close> \\<open>x \\<in> lset xs\\<close> \\<open>x \\<noteq> x'\\<close>"], ["proof (chain)\npicking this:\n  lsorted (LCons x' xs)\n  x \\<in> lset xs\n  x \\<noteq> x'", "have \"x' < x\" \"lsorted xs\""], ["proof (prove)\nusing this:\n  lsorted (LCons x' xs)\n  x \\<in> lset xs\n  x \\<noteq> x'\n\ngoal (1 subgoal):\n 1. x' < x &&& lsorted xs", "by(auto simp add: lsorted_LCons)"], ["proof (state)\nthis:\n  x' < x\n  lsorted xs\n\ngoal (1 subgoal):\n 1. \\<And>x' xs ys.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>ys.\n           \\<lbrakk>lsorted xs; \\<not> lfinite ys;\n            Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xs ys);\n        lsorted (LCons x' xs); \\<not> lfinite ys;\n        Bex (lset ys) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge (LCons x' xs) ys)", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> lset ys\n  x \\<le> y\n  x' < x\n  lsorted xs", "show ?case"], ["proof (prove)\nusing this:\n  y \\<in> lset ys\n  x \\<le> y\n  x' < x\n  lsorted xs\n\ngoal (1 subgoal):\n 1. x \\<in> lset (lmerge (LCons x' xs) ys)", "using \\<open>\\<not> lfinite ys\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> lset ys\n  x \\<le> y\n  x' < x\n  lsorted xs\n  \\<not> lfinite ys\n\ngoal (1 subgoal):\n 1. x \\<in> lset (lmerge (LCons x' xs) ys)", "by induct(auto 4 3 simp add: lmerge_simps \\<open>x \\<noteq> x'\\<close> not_less intro: step.IH dest: in_lset_lmergeD)"], ["proof (state)\nthis:\n  x \\<in> lset (lmerge (LCons x' xs) ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_lset_lmergeI2:\n  \"\\<lbrakk> x \\<in> lset ys; lsorted ys; \\<not> lfinite xs; \\<exists>y\\<in>lset xs. x \\<le> y \\<rbrakk>\n  \\<Longrightarrow> x \\<in> lset (lmerge xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> lset ys; lsorted ys; \\<not> lfinite xs;\n     \\<exists>y\\<in>lset xs. x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> lset (lmerge xs ys)", "proof(induction arbitrary: xs rule: lset_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs xsa.\n       \\<lbrakk>lsorted (LCons x xs); \\<not> lfinite xsa;\n        Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge xsa (LCons x xs))\n 2. \\<And>x' xs xsa.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>xsa.\n           \\<lbrakk>lsorted xs; \\<not> lfinite xsa;\n            Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xsa xs);\n        lsorted (LCons x' xs); \\<not> lfinite xsa;\n        Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge xsa (LCons x' xs))", "case (find ys)"], ["proof (state)\nthis:\n  lsorted (LCons x ys)\n  \\<not> lfinite xs\n  \\<exists>a\\<in>lset xs. x \\<le> a\n\ngoal (2 subgoals):\n 1. \\<And>xs xsa.\n       \\<lbrakk>lsorted (LCons x xs); \\<not> lfinite xsa;\n        Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge xsa (LCons x xs))\n 2. \\<And>x' xs xsa.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>xsa.\n           \\<lbrakk>lsorted xs; \\<not> lfinite xsa;\n            Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xsa xs);\n        lsorted (LCons x' xs); \\<not> lfinite xsa;\n        Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge xsa (LCons x' xs))", "then"], ["proof (chain)\npicking this:\n  lsorted (LCons x ys)\n  \\<not> lfinite xs\n  \\<exists>a\\<in>lset xs. x \\<le> a", "obtain y where \"y \\<in> lset xs\" \"x \\<le> y\""], ["proof (prove)\nusing this:\n  lsorted (LCons x ys)\n  \\<not> lfinite xs\n  \\<exists>a\\<in>lset xs. x \\<le> a\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> lset xs; x \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> lset xs\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. \\<And>xs xsa.\n       \\<lbrakk>lsorted (LCons x xs); \\<not> lfinite xsa;\n        Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge xsa (LCons x xs))\n 2. \\<And>x' xs xsa.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>xsa.\n           \\<lbrakk>lsorted xs; \\<not> lfinite xsa;\n            Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xsa xs);\n        lsorted (LCons x' xs); \\<not> lfinite xsa;\n        Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge xsa (LCons x' xs))", "thus ?case"], ["proof (prove)\nusing this:\n  y \\<in> lset xs\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<in> lset (lmerge xs (LCons x ys))", "by induct(auto simp add: lmerge_simps not_less)"], ["proof (state)\nthis:\n  x \\<in> lset (lmerge xs (LCons x ys))\n\ngoal (1 subgoal):\n 1. \\<And>x' xs xsa.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>xsa.\n           \\<lbrakk>lsorted xs; \\<not> lfinite xsa;\n            Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xsa xs);\n        lsorted (LCons x' xs); \\<not> lfinite xsa;\n        Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge xsa (LCons x' xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x' xs xsa.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>xsa.\n           \\<lbrakk>lsorted xs; \\<not> lfinite xsa;\n            Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xsa xs);\n        lsorted (LCons x' xs); \\<not> lfinite xsa;\n        Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge xsa (LCons x' xs))", "case (step x' ys)"], ["proof (state)\nthis:\n  x \\<in> lset ys\n  x \\<noteq> x'\n  \\<lbrakk>lsorted ys; \\<not> lfinite ?xs;\n   \\<exists>a\\<in>lset ?xs. x \\<le> a\\<rbrakk>\n  \\<Longrightarrow> x \\<in> lset (lmerge ?xs ys)\n  lsorted (LCons x' ys)\n  \\<not> lfinite xs\n  \\<exists>a\\<in>lset xs. x \\<le> a\n\ngoal (1 subgoal):\n 1. \\<And>x' xs xsa.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>xsa.\n           \\<lbrakk>lsorted xs; \\<not> lfinite xsa;\n            Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xsa xs);\n        lsorted (LCons x' xs); \\<not> lfinite xsa;\n        Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge xsa (LCons x' xs))", "then"], ["proof (chain)\npicking this:\n  x \\<in> lset ys\n  x \\<noteq> x'\n  \\<lbrakk>lsorted ys; \\<not> lfinite ?xs;\n   \\<exists>a\\<in>lset ?xs. x \\<le> a\\<rbrakk>\n  \\<Longrightarrow> x \\<in> lset (lmerge ?xs ys)\n  lsorted (LCons x' ys)\n  \\<not> lfinite xs\n  \\<exists>a\\<in>lset xs. x \\<le> a", "obtain y where \"y \\<in> lset xs\" \"x \\<le> y\""], ["proof (prove)\nusing this:\n  x \\<in> lset ys\n  x \\<noteq> x'\n  \\<lbrakk>lsorted ys; \\<not> lfinite ?xs;\n   \\<exists>a\\<in>lset ?xs. x \\<le> a\\<rbrakk>\n  \\<Longrightarrow> x \\<in> lset (lmerge ?xs ys)\n  lsorted (LCons x' ys)\n  \\<not> lfinite xs\n  \\<exists>a\\<in>lset xs. x \\<le> a\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> lset xs; x \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> lset xs\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x' xs xsa.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>xsa.\n           \\<lbrakk>lsorted xs; \\<not> lfinite xsa;\n            Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xsa xs);\n        lsorted (LCons x' xs); \\<not> lfinite xsa;\n        Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge xsa (LCons x' xs))", "moreover"], ["proof (state)\nthis:\n  y \\<in> lset xs\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x' xs xsa.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>xsa.\n           \\<lbrakk>lsorted xs; \\<not> lfinite xsa;\n            Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xsa xs);\n        lsorted (LCons x' xs); \\<not> lfinite xsa;\n        Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge xsa (LCons x' xs))", "from \\<open>lsorted (LCons x' ys)\\<close> \\<open>x \\<in> lset ys\\<close> \\<open>x \\<noteq> x'\\<close>"], ["proof (chain)\npicking this:\n  lsorted (LCons x' ys)\n  x \\<in> lset ys\n  x \\<noteq> x'", "have \"x' < x\" \"lsorted ys\""], ["proof (prove)\nusing this:\n  lsorted (LCons x' ys)\n  x \\<in> lset ys\n  x \\<noteq> x'\n\ngoal (1 subgoal):\n 1. x' < x &&& lsorted ys", "by(auto simp add: lsorted_LCons)"], ["proof (state)\nthis:\n  x' < x\n  lsorted ys\n\ngoal (1 subgoal):\n 1. \\<And>x' xs xsa.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>xsa.\n           \\<lbrakk>lsorted xs; \\<not> lfinite xsa;\n            Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> lset (lmerge xsa xs);\n        lsorted (LCons x' xs); \\<not> lfinite xsa;\n        Bex (lset xsa) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset (lmerge xsa (LCons x' xs))", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> lset xs\n  x \\<le> y\n  x' < x\n  lsorted ys", "show ?case"], ["proof (prove)\nusing this:\n  y \\<in> lset xs\n  x \\<le> y\n  x' < x\n  lsorted ys\n\ngoal (1 subgoal):\n 1. x \\<in> lset (lmerge xs (LCons x' ys))", "using \\<open>\\<not> lfinite xs\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> lset xs\n  x \\<le> y\n  x' < x\n  lsorted ys\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. x \\<in> lset (lmerge xs (LCons x' ys))", "by induct(auto 4 3 simp add: lmerge_simps \\<open>x \\<noteq> x'\\<close> not_less intro: step.IH dest: in_lset_lmergeD)"], ["proof (state)\nthis:\n  x \\<in> lset (lmerge xs (LCons x' ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lsorted_lmerge: \"\\<lbrakk> lsorted xs; lsorted ys \\<rbrakk> \\<Longrightarrow> lsorted (lmerge xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lsorted xs; lsorted ys\\<rbrakk>\n    \\<Longrightarrow> lsorted (lmerge xs ys)", "proof(coinduction arbitrary: xs ys)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>lsorted xsa; lsorted ys;\n        \\<not> lnull (lmerge xsa ys)\\<rbrakk>\n       \\<Longrightarrow> Ball (lset (ltl (lmerge xsa ys)))\n                          ((\\<le>) (lhd (lmerge xsa ys))) \\<and>\n                         ((\\<exists>xs ysa.\n                              ltl (lmerge xsa ys) = lmerge xs ysa \\<and>\n                              lsorted xs \\<and> lsorted ysa) \\<or>\n                          lsorted (ltl (lmerge xsa ys)))", "case (lsorted xs ys)"], ["proof (state)\nthis:\n  lsorted xs\n  lsorted ys\n  \\<not> lnull (lmerge xs ys)\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>lsorted xsa; lsorted ys;\n        \\<not> lnull (lmerge xsa ys)\\<rbrakk>\n       \\<Longrightarrow> Ball (lset (ltl (lmerge xsa ys)))\n                          ((\\<le>) (lhd (lmerge xsa ys))) \\<and>\n                         ((\\<exists>xs ysa.\n                              ltl (lmerge xsa ys) = lmerge xs ysa \\<and>\n                              lsorted xs \\<and> lsorted ysa) \\<or>\n                          lsorted (ltl (lmerge xsa ys)))", "have ?lhd"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (lset (ltl (lmerge xs ys))) ((\\<le>) (lhd (lmerge xs ys)))", "using lsorted"], ["proof (prove)\nusing this:\n  lsorted xs\n  lsorted ys\n  \\<not> lnull (lmerge xs ys)\n\ngoal (1 subgoal):\n 1. Ball (lset (ltl (lmerge xs ys))) ((\\<le>) (lhd (lmerge xs ys)))", "by(auto 4 3 simp add: not_lnull_conv lsorted_LCons lhd_lmerge ltl_lmerge dest!: in_lset_lmergeD)"], ["proof (state)\nthis:\n  Ball (lset (ltl (lmerge xs ys))) ((\\<le>) (lhd (lmerge xs ys)))\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>lsorted xsa; lsorted ys;\n        \\<not> lnull (lmerge xsa ys)\\<rbrakk>\n       \\<Longrightarrow> Ball (lset (ltl (lmerge xsa ys)))\n                          ((\\<le>) (lhd (lmerge xsa ys))) \\<and>\n                         ((\\<exists>xs ysa.\n                              ltl (lmerge xsa ys) = lmerge xs ysa \\<and>\n                              lsorted xs \\<and> lsorted ysa) \\<or>\n                          lsorted (ltl (lmerge xsa ys)))", "moreover"], ["proof (state)\nthis:\n  Ball (lset (ltl (lmerge xs ys))) ((\\<le>) (lhd (lmerge xs ys)))\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>lsorted xsa; lsorted ys;\n        \\<not> lnull (lmerge xsa ys)\\<rbrakk>\n       \\<Longrightarrow> Ball (lset (ltl (lmerge xsa ys)))\n                          ((\\<le>) (lhd (lmerge xsa ys))) \\<and>\n                         ((\\<exists>xs ysa.\n                              ltl (lmerge xsa ys) = lmerge xs ysa \\<and>\n                              lsorted xs \\<and> lsorted ysa) \\<or>\n                          lsorted (ltl (lmerge xsa ys)))", "have ?ltl"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs ys.\n        ltl (lmerge xs ys) = lmerge xs ys \\<and>\n        lsorted xs \\<and> lsorted ys) \\<or>\n    lsorted (ltl (lmerge xs ys))", "using lsorted"], ["proof (prove)\nusing this:\n  lsorted xs\n  lsorted ys\n  \\<not> lnull (lmerge xs ys)\n\ngoal (1 subgoal):\n 1. (\\<exists>xs ys.\n        ltl (lmerge xs ys) = lmerge xs ys \\<and>\n        lsorted xs \\<and> lsorted ys) \\<or>\n    lsorted (ltl (lmerge xs ys))", "by(auto simp add: ltl_lmerge intro: lsorted_ltlI)"], ["proof (state)\nthis:\n  (\\<exists>xs ys.\n      ltl (lmerge xs ys) = lmerge xs ys \\<and>\n      lsorted xs \\<and> lsorted ys) \\<or>\n  lsorted (ltl (lmerge xs ys))\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>lsorted xsa; lsorted ys;\n        \\<not> lnull (lmerge xsa ys)\\<rbrakk>\n       \\<Longrightarrow> Ball (lset (ltl (lmerge xsa ys)))\n                          ((\\<le>) (lhd (lmerge xsa ys))) \\<and>\n                         ((\\<exists>xs ysa.\n                              ltl (lmerge xsa ys) = lmerge xs ysa \\<and>\n                              lsorted xs \\<and> lsorted ysa) \\<or>\n                          lsorted (ltl (lmerge xsa ys)))", "ultimately"], ["proof (chain)\npicking this:\n  Ball (lset (ltl (lmerge xs ys))) ((\\<le>) (lhd (lmerge xs ys)))\n  (\\<exists>xs ys.\n      ltl (lmerge xs ys) = lmerge xs ys \\<and>\n      lsorted xs \\<and> lsorted ys) \\<or>\n  lsorted (ltl (lmerge xs ys))", "show ?case"], ["proof (prove)\nusing this:\n  Ball (lset (ltl (lmerge xs ys))) ((\\<le>) (lhd (lmerge xs ys)))\n  (\\<exists>xs ys.\n      ltl (lmerge xs ys) = lmerge xs ys \\<and>\n      lsorted xs \\<and> lsorted ys) \\<or>\n  lsorted (ltl (lmerge xs ys))\n\ngoal (1 subgoal):\n 1. Ball (lset (ltl (lmerge xs ys))) ((\\<le>) (lhd (lmerge xs ys))) \\<and>\n    ((\\<exists>xs ys.\n         ltl (lmerge xs ys) = lmerge xs ys \\<and>\n         lsorted xs \\<and> lsorted ys) \\<or>\n     lsorted (ltl (lmerge xs ys)))", ".."], ["proof (state)\nthis:\n  Ball (lset (ltl (lmerge xs ys))) ((\\<le>) (lhd (lmerge xs ys))) \\<and>\n  ((\\<exists>xs ys.\n       ltl (lmerge xs ys) = lmerge xs ys \\<and>\n       lsorted xs \\<and> lsorted ys) \\<or>\n   lsorted (ltl (lmerge xs ys)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldistinct_lmerge: \n  \"\\<lbrakk> lsorted xs; lsorted ys; ldistinct xs; ldistinct ys \\<rbrakk>\n  \\<Longrightarrow> ldistinct (lmerge xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lsorted xs; lsorted ys; ldistinct xs; ldistinct ys\\<rbrakk>\n    \\<Longrightarrow> ldistinct (lmerge xs ys)", "by(coinduction arbitrary: xs ys)(auto 4 3 simp add: lhd_lmerge ltl_lmerge not_lnull_conv lsorted_LCons not_less dest!: in_lset_lmergeD dest: antisym)"], ["", "end"], ["", "partial_function (llist) hamming' :: \"unit \\<Rightarrow> nat llist\"\nwhere\n  \"hamming' _ = \n   LCons 1 (lmerge (lmap ((*) 2) (hamming' ())) (lmerge (lmap ((*) 3) (hamming' ())) (lmap ((*) 5) (hamming' ()))))\""], ["", "definition hamming :: \"nat llist\"\nwhere \"hamming = hamming' ()\""], ["", "lemma lnull_hamming [simp]: \"\\<not> lnull hamming\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull hamming", "unfolding hamming_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull (hamming' ())", "by(subst hamming'.simps) simp"], ["", "lemma hamming_eq_LNil_iff [simp]: \"hamming = LNil \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hamming = LNil) = False", "using lnull_hamming"], ["proof (prove)\nusing this:\n  \\<not> lnull hamming\n\ngoal (1 subgoal):\n 1. (hamming = LNil) = False", "unfolding lnull_def"], ["proof (prove)\nusing this:\n  hamming \\<noteq> LNil\n\ngoal (1 subgoal):\n 1. (hamming = LNil) = False", "by simp"], ["", "lemma lhd_hamming [simp]: \"lhd hamming = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd hamming = 1", "unfolding hamming_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd (hamming' ()) = 1", "by(subst hamming'.simps) simp"], ["", "lemma ltl_hamming [simp]:\n  \"ltl hamming = lmerge (lmap ((*) 2) hamming) (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl hamming =\n    lmerge (lmap ((*) 2) hamming)\n     (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming))", "unfolding hamming_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (hamming' ()) =\n    lmerge (lmap ((*) 2) (hamming' ()))\n     (lmerge (lmap ((*) 3) (hamming' ())) (lmap ((*) 5) (hamming' ())))", "by(subst hamming'.simps) simp"], ["", "lemma hamming_unfold:\n  \"hamming = LCons 1 (lmerge (lmap ((*) 2) hamming) (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hamming =\n    LCons 1\n     (lmerge (lmap ((*) 2) hamming)\n       (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming)))", "by(rule llist.expand) simp_all"], ["", "definition smooth :: \"nat \\<Rightarrow> bool\"\nwhere \"smooth n \\<longleftrightarrow> (\\<forall>p. prime p \\<longrightarrow> p dvd n \\<longrightarrow> p \\<le> 5)\""], ["", "lemma smooth_0 [simp]: \"\\<not> smooth 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> smooth 0", "by(auto simp add: smooth_def intro: exI[where x=7])"], ["", "lemma smooth_Suc0 [simp]: \"smooth (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth (Suc 0)", "by(auto simp add: smooth_def)"], ["", "lemma smooth_gt0: \"smooth n \\<Longrightarrow> n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth n \\<Longrightarrow> 0 < n", "by(cases n) simp_all"], ["", "lemma smooth_ge_Suc0: \"smooth n \\<Longrightarrow> n \\<ge> Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth n \\<Longrightarrow> Suc 0 \\<le> n", "by(cases n) simp_all"], ["", "lemma prime_nat_dvdD: \"prime p \\<Longrightarrow> (n :: nat) dvd p \\<Longrightarrow> n = 1 \\<or> n = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; n dvd p\\<rbrakk> \\<Longrightarrow> n = 1 \\<or> n = p", "unfolding prime_nat_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < p \\<and>\n             (\\<forall>m. m dvd p \\<longrightarrow> m = 1 \\<or> m = p);\n     n dvd p\\<rbrakk>\n    \\<Longrightarrow> n = 1 \\<or> n = p", "by simp"], ["", "lemma smooth_times [simp]: \"smooth (x * y) \\<longleftrightarrow> smooth x \\<and> smooth y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth (x * y) = (smooth x \\<and> smooth y)", "by(auto simp add: smooth_def prime_dvd_mult_iff)"], ["", "lemma smooth2 [simp]: \"smooth 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth 2", "by(auto simp add: smooth_def dest: prime_nat_dvdD[of 2, simplified])"], ["", "lemma smooth3 [simp]: \"smooth 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth 3", "by(auto simp add: smooth_def dest: prime_nat_dvdD[of 3, simplified])"], ["", "lemma smooth5 [simp]: \"smooth 5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth 5", "by(auto simp add: smooth_def dest: prime_nat_dvdD[of 5, simplified])"], ["", "lemma hamming_in_smooth: \"lset hamming \\<subseteq> {n. smooth n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset hamming \\<subseteq> {n. smooth n}", "unfolding hamming_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (hamming' ()) \\<subseteq> {n. smooth n}", "by(induct rule: hamming'.fixp_induct)(auto 6 6 dest: in_lset_lmergeD)"], ["", "lemma lfinite_hamming [simp]: \"\\<not> lfinite hamming\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite hamming", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite hamming \\<Longrightarrow> False", "assume \"lfinite hamming\""], ["proof (state)\nthis:\n  lfinite hamming\n\ngoal (1 subgoal):\n 1. lfinite hamming \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  lfinite hamming", "obtain n where n: \"llength hamming = enat n\""], ["proof (prove)\nusing this:\n  lfinite hamming\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        llength hamming = enat n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lfinite_conv_llength_enat"], ["proof (prove)\nusing this:\n  \\<exists>n. llength hamming = enat n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        llength hamming = enat n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  llength hamming = enat n\n\ngoal (1 subgoal):\n 1. lfinite hamming \\<Longrightarrow> False", "have \"llength (lmap ((*) 3) hamming) \\<sqinter> llength (lmap ((*) 5) hamming) \\<le> llength (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lmap ((*) 3) hamming) \\<sqinter> llength (lmap ((*) 5) hamming)\n    \\<le> llength (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming))", "by(rule llength_lmerge_above)"], ["proof (state)\nthis:\n  llength (lmap ((*) 3) hamming) \\<sqinter> llength (lmap ((*) 5) hamming)\n  \\<le> llength (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming))\n\ngoal (1 subgoal):\n 1. lfinite hamming \\<Longrightarrow> False", "hence \"llength hamming \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  llength (lmap ((*) 3) hamming) \\<sqinter> llength (lmap ((*) 5) hamming)\n  \\<le> llength (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming))\n\ngoal (1 subgoal):\n 1. llength hamming\n    \\<le> llength (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming))", "by simp"], ["proof (state)\nthis:\n  llength hamming\n  \\<le> llength (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming))\n\ngoal (1 subgoal):\n 1. lfinite hamming \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  llength hamming\n  \\<le> llength (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming))\n\ngoal (1 subgoal):\n 1. lfinite hamming \\<Longrightarrow> False", "have \"llength (lmap ((*) 2) hamming) \\<sqinter> \\<dots> \\<le>\n    llength (lmerge (lmap ((*) 2) hamming) (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lmap ((*) 2) hamming) \\<sqinter>\n    llength (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming))\n    \\<le> llength\n           (lmerge (lmap ((*) 2) hamming)\n             (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming)))", "by(rule llength_lmerge_above)"], ["proof (state)\nthis:\n  llength (lmap ((*) 2) hamming) \\<sqinter>\n  llength (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming))\n  \\<le> llength\n         (lmerge (lmap ((*) 2) hamming)\n           (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming)))\n\ngoal (1 subgoal):\n 1. lfinite hamming \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  llength hamming\n  \\<le> llength (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming))\n  llength (lmap ((*) 2) hamming) \\<sqinter>\n  llength (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming))\n  \\<le> llength\n         (lmerge (lmap ((*) 2) hamming)\n           (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming)))", "have \"llength hamming \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  llength hamming\n  \\<le> llength (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming))\n  llength (lmap ((*) 2) hamming) \\<sqinter>\n  llength (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming))\n  \\<le> llength\n         (lmerge (lmap ((*) 2) hamming)\n           (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming)))\n\ngoal (1 subgoal):\n 1. llength hamming\n    \\<le> llength\n           (lmerge (lmap ((*) 2) hamming)\n             (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming)))", "by(simp add: inf.absorb1)"], ["proof (state)\nthis:\n  llength hamming\n  \\<le> llength\n         (lmerge (lmap ((*) 2) hamming)\n           (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming)))\n\ngoal (1 subgoal):\n 1. lfinite hamming \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  llength hamming\n  \\<le> llength\n         (lmerge (lmap ((*) 2) hamming)\n           (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming)))\n\ngoal (1 subgoal):\n 1. lfinite hamming \\<Longrightarrow> False", "from n"], ["proof (chain)\npicking this:\n  llength hamming = enat n", "have \"\\<dots> < enat n\""], ["proof (prove)\nusing this:\n  llength hamming = enat n\n\ngoal (1 subgoal):\n 1. llength\n     (lmerge (lmap ((*) 2) hamming)\n       (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming)))\n    < enat n", "by(subst (asm) hamming_unfold)(cases n, auto simp add: zero_enat_def[symmetric] eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  llength\n   (lmerge (lmap ((*) 2) hamming)\n     (lmerge (lmap ((*) 3) hamming) (lmap ((*) 5) hamming)))\n  < enat n\n\ngoal (1 subgoal):\n 1. lfinite hamming \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  llength hamming < enat n", "show False"], ["proof (prove)\nusing this:\n  llength hamming < enat n\n\ngoal (1 subgoal):\n 1. False", "unfolding n"], ["proof (prove)\nusing this:\n  enat n < enat n\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lsorted_hamming [simp]: \"lsorted hamming\"\n  and ldistinct_hamming [simp]: \"ldistinct hamming\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted hamming &&& ldistinct hamming", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. lsorted hamming\n 2. ldistinct hamming", "have \"lsorted hamming \\<and> ldistinct hamming \\<and> lset hamming \\<subseteq> {1..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted hamming \\<and>\n    ldistinct hamming \\<and> lset hamming \\<subseteq> {1..}", "unfolding hamming_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted (hamming' ()) \\<and>\n    ldistinct (hamming' ()) \\<and> lset (hamming' ()) \\<subseteq> {1..}", "by(induct rule: hamming'.fixp_induct)(auto 6 6 simp add: lsorted_LCons dest: in_lset_lmergeD intro: smooth_ge_Suc0 lsorted_lmerge lsorted_lmap monotoneI ldistinct_lmerge inj_onI)"], ["proof (state)\nthis:\n  lsorted hamming \\<and>\n  ldistinct hamming \\<and> lset hamming \\<subseteq> {1..}\n\ngoal (2 subgoals):\n 1. lsorted hamming\n 2. ldistinct hamming", "thus \"lsorted hamming\" \"ldistinct hamming\""], ["proof (prove)\nusing this:\n  lsorted hamming \\<and>\n  ldistinct hamming \\<and> lset hamming \\<subseteq> {1..}\n\ngoal (1 subgoal):\n 1. lsorted hamming &&& ldistinct hamming", "by simp_all"], ["proof (state)\nthis:\n  lsorted hamming\n  ldistinct hamming\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smooth_hamming:\n  assumes \"smooth n\"\n  shows \"n \\<in> lset hamming\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> lset hamming", "using assms"], ["proof (prove)\nusing this:\n  smooth n\n\ngoal (1 subgoal):\n 1. n \\<in> lset hamming", "proof(induction n rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; smooth y\\<rbrakk>\n                   \\<Longrightarrow> y \\<in> lset hamming;\n        smooth x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset hamming", "have [simp]:\n    \"monotone (\\<le>) (\\<le>) ((*) 2 :: nat \\<Rightarrow> nat)\" \n    \"monotone (\\<le>) (\\<le>) ((*) 3 :: nat \\<Rightarrow> nat)\" \n    \"monotone (\\<le>) (\\<le>) ((*) 5 :: nat \\<Rightarrow> nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) ((*) 2) &&&\n    monotone (\\<le>) (\\<le>) ((*) 3) &&& monotone (\\<le>) (\\<le>) ((*) 5)", "by(simp_all add: monotone_def)"], ["proof (state)\nthis:\n  monotone (\\<le>) (\\<le>) ((*) 2)\n  monotone (\\<le>) (\\<le>) ((*) 3)\n  monotone (\\<le>) (\\<le>) ((*) 5)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; smooth y\\<rbrakk>\n                   \\<Longrightarrow> y \\<in> lset hamming;\n        smooth x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset hamming", "case (less n)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < n; smooth ?y\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> lset hamming\n  smooth n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; smooth y\\<rbrakk>\n                   \\<Longrightarrow> y \\<in> lset hamming;\n        smooth x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset hamming", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> lset hamming", "proof(cases \"n > 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 < n \\<Longrightarrow> n \\<in> lset hamming\n 2. \\<not> 1 < n \\<Longrightarrow> n \\<in> lset hamming", "case False"], ["proof (state)\nthis:\n  \\<not> 1 < n\n\ngoal (2 subgoals):\n 1. 1 < n \\<Longrightarrow> n \\<in> lset hamming\n 2. \\<not> 1 < n \\<Longrightarrow> n \\<in> lset hamming", "moreover"], ["proof (state)\nthis:\n  \\<not> 1 < n\n\ngoal (2 subgoals):\n 1. 1 < n \\<Longrightarrow> n \\<in> lset hamming\n 2. \\<not> 1 < n \\<Longrightarrow> n \\<in> lset hamming", "from \\<open>smooth n\\<close>"], ["proof (chain)\npicking this:\n  smooth n", "have \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  smooth n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by(rule contrapos_pn) simp"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 1 < n \\<Longrightarrow> n \\<in> lset hamming\n 2. \\<not> 1 < n \\<Longrightarrow> n \\<in> lset hamming", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> 1 < n\n  n \\<noteq> 0", "have \"n = 1\""], ["proof (prove)\nusing this:\n  \\<not> 1 < n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n = 1", "by(simp)"], ["proof (state)\nthis:\n  n = 1\n\ngoal (2 subgoals):\n 1. 1 < n \\<Longrightarrow> n \\<in> lset hamming\n 2. \\<not> 1 < n \\<Longrightarrow> n \\<in> lset hamming", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 1\n\ngoal (1 subgoal):\n 1. n \\<in> lset hamming", "by(subst hamming_unfold) simp"], ["proof (state)\nthis:\n  n \\<in> lset hamming\n\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> n \\<in> lset hamming", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> n \\<in> lset hamming", "case True"], ["proof (state)\nthis:\n  1 < n\n\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> n \\<in> lset hamming", "hence \"\\<exists>p. prime p \\<and> p dvd n\""], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<exists>p. prime p \\<and> p dvd n", "by(metis less_numeral_extra(4) prime_factor_nat)"], ["proof (state)\nthis:\n  \\<exists>p. prime p \\<and> p dvd n\n\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> n \\<in> lset hamming", "with \\<open>smooth n\\<close>"], ["proof (chain)\npicking this:\n  smooth n\n  \\<exists>p. prime p \\<and> p dvd n", "obtain p where \"prime p\" \"p dvd n\" \"p \\<le> 5\""], ["proof (prove)\nusing this:\n  smooth n\n  \\<exists>p. prime p \\<and> p dvd n\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd n; p \\<le> 5\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: smooth_def)"], ["proof (state)\nthis:\n  prime p\n  p dvd n\n  p \\<le> 5\n\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> n \\<in> lset hamming", "from \\<open>p dvd n\\<close>"], ["proof (chain)\npicking this:\n  p dvd n", "obtain n' where n: \"n = p * n'\""], ["proof (prove)\nusing this:\n  p dvd n\n\ngoal (1 subgoal):\n 1. (\\<And>n'. n = p * n' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by(auto simp add: dvd_def)"], ["proof (state)\nthis:\n  n = p * n'\n\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> n \\<in> lset hamming", "with \\<open>smooth n\\<close> \\<open>prime p\\<close>"], ["proof (chain)\npicking this:\n  smooth n\n  prime p\n  n = p * n'", "have \"smooth n'\""], ["proof (prove)\nusing this:\n  smooth n\n  prime p\n  n = p * n'\n\ngoal (1 subgoal):\n 1. smooth n'", "by(simp add: smooth_def)"], ["proof (state)\nthis:\n  smooth n'\n\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> n \\<in> lset hamming", "with \\<open>prime p\\<close> n"], ["proof (chain)\npicking this:\n  prime p\n  n = p * n'\n  smooth n'", "have \"n' < n\""], ["proof (prove)\nusing this:\n  prime p\n  n = p * n'\n  smooth n'\n\ngoal (1 subgoal):\n 1. n' < n", "by(simp add: smooth_gt0 prime_gt_Suc_0_nat)"], ["proof (state)\nthis:\n  n' < n\n\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> n \\<in> lset hamming", "hence n': \"n' \\<in> lset hamming\""], ["proof (prove)\nusing this:\n  n' < n\n\ngoal (1 subgoal):\n 1. n' \\<in> lset hamming", "using \\<open>smooth n'\\<close>"], ["proof (prove)\nusing this:\n  n' < n\n  smooth n'\n\ngoal (1 subgoal):\n 1. n' \\<in> lset hamming", "by(rule less.IH)"], ["proof (state)\nthis:\n  n' \\<in> lset hamming\n\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> n \\<in> lset hamming", "from \\<open>p \\<le> 5\\<close>"], ["proof (chain)\npicking this:\n  p \\<le> 5", "have \"p = 0 \\<or> p = 1 \\<or> p = 2 \\<or> p = 3 \\<or> p = 4 \\<or> p = 5\""], ["proof (prove)\nusing this:\n  p \\<le> 5\n\ngoal (1 subgoal):\n 1. p = 0 \\<or> p = 1 \\<or> p = 2 \\<or> p = 3 \\<or> p = 4 \\<or> p = 5", "by presburger"], ["proof (state)\nthis:\n  p = 0 \\<or> p = 1 \\<or> p = 2 \\<or> p = 3 \\<or> p = 4 \\<or> p = 5\n\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> n \\<in> lset hamming", "with \\<open>prime p\\<close>"], ["proof (chain)\npicking this:\n  prime p\n  p = 0 \\<or> p = 1 \\<or> p = 2 \\<or> p = 3 \\<or> p = 4 \\<or> p = 5", "have \"p = 2 \\<or> p = 3 \\<or> p = 5\""], ["proof (prove)\nusing this:\n  prime p\n  p = 0 \\<or> p = 1 \\<or> p = 2 \\<or> p = 3 \\<or> p = 4 \\<or> p = 5\n\ngoal (1 subgoal):\n 1. p = 2 \\<or> p = 3 \\<or> p = 5", "by auto"], ["proof (state)\nthis:\n  p = 2 \\<or> p = 3 \\<or> p = 5\n\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> n \\<in> lset hamming", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 2 \\<or> p = 3 \\<or> p = 5\n\ngoal (1 subgoal):\n 1. n \\<in> lset hamming", "proof(elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. p = 2 \\<Longrightarrow> n \\<in> lset hamming\n 2. p = 3 \\<Longrightarrow> n \\<in> lset hamming\n 3. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "assume \"p = 2\""], ["proof (state)\nthis:\n  p = 2\n\ngoal (3 subgoals):\n 1. p = 2 \\<Longrightarrow> n \\<in> lset hamming\n 2. p = 3 \\<Longrightarrow> n \\<in> lset hamming\n 3. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "with n n'"], ["proof (chain)\npicking this:\n  n = p * n'\n  n' \\<in> lset hamming\n  p = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  n = p * n'\n  n' \\<in> lset hamming\n  p = 2\n\ngoal (1 subgoal):\n 1. n \\<in> lset hamming", "by(subst hamming_unfold)(simp_all add: in_lset_lmergeI1 not_less lsorted_lmap bexI[where x=\"n'\"] bexI[where x=\"3*n'\"])"], ["proof (state)\nthis:\n  n \\<in> lset hamming\n\ngoal (2 subgoals):\n 1. p = 3 \\<Longrightarrow> n \\<in> lset hamming\n 2. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 3 \\<Longrightarrow> n \\<in> lset hamming\n 2. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "assume \"p = 3\""], ["proof (state)\nthis:\n  p = 3\n\ngoal (2 subgoals):\n 1. p = 3 \\<Longrightarrow> n \\<in> lset hamming\n 2. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "moreover"], ["proof (state)\nthis:\n  p = 3\n\ngoal (2 subgoals):\n 1. p = 3 \\<Longrightarrow> n \\<in> lset hamming\n 2. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "with n \\<open>smooth n'\\<close>"], ["proof (chain)\npicking this:\n  n = p * n'\n  smooth n'\n  p = 3", "have \"2 * n' < n\""], ["proof (prove)\nusing this:\n  n = p * n'\n  smooth n'\n  p = 3\n\ngoal (1 subgoal):\n 1. 2 * n' < n", "by(simp add: smooth_gt0)"], ["proof (state)\nthis:\n  2 * n' < n\n\ngoal (2 subgoals):\n 1. p = 3 \\<Longrightarrow> n \\<in> lset hamming\n 2. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "hence \"2 * n' \\<in> lset hamming\""], ["proof (prove)\nusing this:\n  2 * n' < n\n\ngoal (1 subgoal):\n 1. 2 * n' \\<in> lset hamming", "by(rule less.IH)(simp add: \\<open>smooth n'\\<close>)"], ["proof (state)\nthis:\n  2 * n' \\<in> lset hamming\n\ngoal (2 subgoals):\n 1. p = 3 \\<Longrightarrow> n \\<in> lset hamming\n 2. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "ultimately"], ["proof (chain)\npicking this:\n  p = 3\n  2 * n' \\<in> lset hamming", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 3\n  2 * n' \\<in> lset hamming\n\ngoal (1 subgoal):\n 1. n \\<in> lset hamming", "using n n'"], ["proof (prove)\nusing this:\n  p = 3\n  2 * n' \\<in> lset hamming\n  n = p * n'\n  n' \\<in> lset hamming\n\ngoal (1 subgoal):\n 1. n \\<in> lset hamming", "by(subst hamming_unfold)(auto 4 4 simp add: not_less lsorted_lmap lsorted_lmerge intro: in_lset_lmergeI1 in_lset_lmergeI2 bexI[where x=\"4*n'\"] bexI[where x=\"5*n'\"])"], ["proof (state)\nthis:\n  n \\<in> lset hamming\n\ngoal (1 subgoal):\n 1. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "assume \"p = 5\""], ["proof (state)\nthis:\n  p = 5\n\ngoal (1 subgoal):\n 1. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "moreover"], ["proof (state)\nthis:\n  p = 5\n\ngoal (1 subgoal):\n 1. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "with n \\<open>smooth n'\\<close>"], ["proof (chain)\npicking this:\n  n = p * n'\n  smooth n'\n  p = 5", "have \"2 * (2 * n') < n\""], ["proof (prove)\nusing this:\n  n = p * n'\n  smooth n'\n  p = 5\n\ngoal (1 subgoal):\n 1. 2 * (2 * n') < n", "by(simp add: smooth_gt0)"], ["proof (state)\nthis:\n  2 * (2 * n') < n\n\ngoal (1 subgoal):\n 1. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "hence \"2 * (2 * n') \\<in> lset hamming\""], ["proof (prove)\nusing this:\n  2 * (2 * n') < n\n\ngoal (1 subgoal):\n 1. 2 * (2 * n') \\<in> lset hamming", "by(rule less.IH)(simp only: smooth_times smooth2 \\<open>smooth n'\\<close> simp_thms)"], ["proof (state)\nthis:\n  2 * (2 * n') \\<in> lset hamming\n\ngoal (1 subgoal):\n 1. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "moreover"], ["proof (state)\nthis:\n  2 * (2 * n') \\<in> lset hamming\n\ngoal (1 subgoal):\n 1. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "from \\<open>p = 5\\<close> n \\<open>smooth n'\\<close>"], ["proof (chain)\npicking this:\n  p = 5\n  n = p * n'\n  smooth n'", "have \"3 * n' < n\""], ["proof (prove)\nusing this:\n  p = 5\n  n = p * n'\n  smooth n'\n\ngoal (1 subgoal):\n 1. 3 * n' < n", "by(simp add: smooth_gt0)"], ["proof (state)\nthis:\n  3 * n' < n\n\ngoal (1 subgoal):\n 1. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "hence \"3 * n' \\<in> lset hamming\""], ["proof (prove)\nusing this:\n  3 * n' < n\n\ngoal (1 subgoal):\n 1. 3 * n' \\<in> lset hamming", "by(rule less.IH)(simp add: \\<open>smooth n'\\<close>)"], ["proof (state)\nthis:\n  3 * n' \\<in> lset hamming\n\ngoal (1 subgoal):\n 1. p = 5 \\<Longrightarrow> n \\<in> lset hamming", "ultimately"], ["proof (chain)\npicking this:\n  p = 5\n  2 * (2 * n') \\<in> lset hamming\n  3 * n' \\<in> lset hamming", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 5\n  2 * (2 * n') \\<in> lset hamming\n  3 * n' \\<in> lset hamming\n\ngoal (1 subgoal):\n 1. n \\<in> lset hamming", "using n n'"], ["proof (prove)\nusing this:\n  p = 5\n  2 * (2 * n') \\<in> lset hamming\n  3 * n' \\<in> lset hamming\n  n = p * n'\n  n' \\<in> lset hamming\n\ngoal (1 subgoal):\n 1. n \\<in> lset hamming", "by(subst hamming_unfold)(auto 4 4 simp add: lsorted_lmap lsorted_lmerge intro: in_lset_lmergeI2 bexI[where x=\"9*n'\"] bexI[where x=\"8 * n'\"])"], ["proof (state)\nthis:\n  n \\<in> lset hamming\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> lset hamming\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> lset hamming\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary hamming_smooth: \"lset hamming = {n. smooth n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset hamming = {n. smooth n}", "using hamming_in_smooth"], ["proof (prove)\nusing this:\n  lset hamming \\<subseteq> {n. smooth n}\n\ngoal (1 subgoal):\n 1. lset hamming = {n. smooth n}", "by(blast intro: smooth_hamming)"], ["", "lemma hamming_THE:\n  \"(THE xs. lsorted xs \\<and> ldistinct xs \\<and> lset xs = {n. smooth n}) = hamming\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE xs.\n        lsorted xs \\<and> ldistinct xs \\<and> lset xs = {n. smooth n}) =\n    hamming", "by(rule the_equality)(simp_all add: hamming_smooth lsorted_ldistinct_lset_unique)"], ["", "end"]]}