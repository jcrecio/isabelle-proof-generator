{"file_name": "/home/qj213/afp-2021-10-22/thys/Coinductive/Coinductive_Stream.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Coinductive", "problem_names": ["lemma eq_onpI: \"P x \\<Longrightarrow> eq_onp P x x\"", "lemma eq_SConsD: \"xs = SCons y ys \\<Longrightarrow> shd xs = y \\<and> stl xs = ys\"", "lemma smap_eq_SCons_conv:\n  \"smap f xs = y ## ys \\<longleftrightarrow>\n  (\\<exists>x xs'. xs = x ## xs' \\<and> y = f x \\<and> ys = smap f xs')\"", "lemma smap_unfold_stream:\n  \"smap f (unfold_stream SHD STL b) = unfold_stream (f \\<circ> SHD) STL b\"", "lemma smap_corec_stream:\n  \"smap f (corec_stream SHD endORmore STL_end STL_more b) =\n   corec_stream (f \\<circ> SHD) endORmore (smap f \\<circ> STL_end) STL_more b\"", "lemma unfold_stream_ltl_unroll:\n  \"unfold_stream SHD STL (STL b) = unfold_stream (SHD \\<circ> STL) STL b\"", "lemma unfold_stream_eq_SCons [simp]:\n  \"unfold_stream SHD STL b = x ## xs \\<longleftrightarrow>\n  x = SHD b \\<and> xs = unfold_stream SHD STL (STL b)\"", "lemma unfold_stream_id [simp]: \"unfold_stream shd stl xs = xs\"", "lemma sset_neq_empty [simp]: \"sset xs \\<noteq> {}\"", "lemma sset_stl: \"sset (stl xs) \\<subseteq> sset xs\"", "lemmas stream_set_induct = sset_induct", "lemma szip_iterates:\n  \"szip (siterate f a) (siterate g b) = siterate (map_prod f g) (a, b)\"", "lemma szip_smap1: \"szip (smap f xs) ys = smap (apfst f) (szip xs ys)\"", "lemma szip_smap2: \"szip xs (smap g ys) = smap (apsnd g) (szip xs ys)\"", "lemma szip_smap [simp]: \"szip (smap f xs) (smap g ys) = smap (map_prod f g) (szip xs ys)\"", "lemma smap_fst_szip [simp]: \"smap fst (szip xs ys) = xs\"", "lemma smap_snd_szip [simp]: \"smap snd (szip xs ys) = ys\"", "lemma snth_shift: \"snth (shift xs ys) n = (if n < length xs then xs ! n else snth ys (n - length xs))\"", "lemma szip_shift:\n  \"length xs = length us\n  \\<Longrightarrow> szip (xs @- ys) (us @- zs) = zip xs us @- szip ys zs\"", "lemma lnull_llist_of_stream [simp]: \"\\<not> lnull (llist_of_stream xs)\"", "lemma ltl_llist_of_stream [simp]: \"ltl (llist_of_stream xs) = llist_of_stream (stl xs)\"", "lemma stl_stream_of_llist [simp]: \"stl (stream_of_llist xs) = stream_of_llist (ltl xs)\"", "lemma shd_stream_of_llist [simp]: \"shd (stream_of_llist xs) = lhd xs\"", "lemma lhd_llist_of_stream [simp]: \"lhd (llist_of_stream xs) = shd xs\"", "lemma stream_of_llist_llist_of_stream [simp]:\n  \"stream_of_llist (llist_of_stream xs) = xs\"", "lemma llist_of_stream_stream_of_llist [simp]:\n  \"\\<not> lfinite xs \\<Longrightarrow> llist_of_stream (stream_of_llist xs) = xs\"", "lemma lfinite_llist_of_stream [simp]: \"\\<not> lfinite (llist_of_stream xs)\"", "lemma stream_from_llist: \"type_definition llist_of_stream stream_of_llist {xs. \\<not> lfinite xs}\"", "lemma cr_streamI: \"\\<not> lfinite xs \\<Longrightarrow> cr_stream xs (stream_of_llist xs)\"", "lemma llist_of_stream_unfold_stream [simp]:\n  \"llist_of_stream (unfold_stream SHD STL x) = unfold_llist (\\<lambda>_. False) SHD STL x\"", "lemma llist_of_stream_corec_stream [simp]:\n  \"llist_of_stream (corec_stream SHD endORmore STL_more STL_end x) =\n   corec_llist (\\<lambda>_. False) SHD endORmore (llist_of_stream \\<circ> STL_more) STL_end x\"", "lemma LCons_llist_of_stream [simp]: \"LCons x (llist_of_stream xs) = llist_of_stream (x ## xs)\"", "lemma lmap_llist_of_stream [simp]:\n  \"lmap f (llist_of_stream xs) = llist_of_stream (smap f xs)\"", "lemma lset_llist_of_stream [simp]: \"lset (llist_of_stream xs) = sset xs\" (is \"?lhs = ?rhs\")", "lemma lnth_list_of_stream [simp]:\n  \"lnth (llist_of_stream xs) = snth xs\"", "lemma llist_of_stream_siterates [simp]: \"llist_of_stream (siterate f x) = iterates f x\"", "lemma lappend_llist_of_stream_conv_shift [simp]:\n  \"lappend (llist_of xs) (llist_of_stream ys) = llist_of_stream (xs @- ys)\"", "lemma lzip_llist_of_stream [simp]:\n  \"lzip (llist_of_stream xs) (llist_of_stream ys) = llist_of_stream (szip xs ys)\"", "lemma lmap_infinite_transfer [transfer_rule]:\n  \"((=) ===> eq_onp (\\<lambda>xs. \\<not> lfinite xs) ===> eq_onp (\\<lambda>xs. \\<not> lfinite xs)) lmap lmap\"", "lemma lset_infinite_transfer [transfer_rule]:\n  \"(eq_onp (\\<lambda>xs. \\<not> lfinite xs) ===> (=)) lset lset\"", "lemma unfold_stream_transfer [transfer_rule]:\n  \"((=) ===> (=) ===> (=) ===> pcr_stream (=)) (unfold_llist (\\<lambda>_. False)) unfold_stream\"", "lemma corec_stream_transfer [transfer_rule]:\n  \"((=) ===> (=) ===> ((=) ===> pcr_stream (=)) ===> (=) ===> (=) ===> pcr_stream (=))\n   (corec_llist (\\<lambda>_. False)) corec_stream\"", "lemma shd_transfer [transfer_rule]: \"(pcr_stream A ===> A) lhd shd\"", "lemma stl_transfer [transfer_rule]: \"(pcr_stream A ===> pcr_stream A) ltl stl\"", "lemma llist_of_stream_transfer [transfer_rule]: \"(pcr_stream (=) ===> (=)) id llist_of_stream\"", "lemma stream_of_llist_transfer [transfer_rule]:\n  \"(eq_onp (\\<lambda>xs. \\<not> lfinite xs) ===> pcr_stream (=)) (\\<lambda>xs. xs) stream_of_llist\"", "lemma SCons_transfer [transfer_rule]:\n  \"(A ===> pcr_stream A ===> pcr_stream A) LCons (##)\"", "lemma sset_transfer [transfer_rule]: \"(pcr_stream A ===> rel_set A) lset sset\"", "lemma smap_transfer [transfer_rule]:\n  \"((A ===> B) ===> pcr_stream A ===> pcr_stream B) lmap smap\"", "lemma snth_transfer [transfer_rule]: \"(pcr_stream (=) ===> (=)) lnth snth\"", "lemma siterate_transfer [transfer_rule]:\n  \"((=) ===> (=) ===> pcr_stream (=)) iterates siterate\"", "lemma smap_stream_of_llist [simp]:\n  shows \"smap f (stream_of_llist xs) = stream_of_llist (lmap f xs)\"", "lemma sset_stream_of_llist [simp]:\n  assumes \"\\<not> lfinite xs\"\n  shows \"sset (stream_of_llist xs) = lset xs\"", "lemma llist_all2_llist_of_stream [simp]:\n  \"llist_all2 P (llist_of_stream xs) (llist_of_stream ys) = stream_all2 P xs ys\"", "lemma stream_all2_transfer [transfer_rule]:\n  \"((=) ===> pcr_stream (=) ===> pcr_stream (=) ===> (=)) llist_all2 stream_all2\"", "lemma stream_all2_coinduct:\n  assumes \"X xs ys\"\n  and \"\\<And>xs ys. X xs ys \\<Longrightarrow> P (shd xs) (shd ys) \\<and> (X (stl xs) (stl ys) \\<or> stream_all2 P (stl xs) (stl ys))\"\n  shows \"stream_all2 P xs ys\"", "lemma shift_transfer [transfer_rule]:\n  \"((=) ===> pcr_stream (=) ===> pcr_stream (=)) (lappend \\<circ> llist_of) shift\"", "lemma szip_transfer [transfer_rule]:\n  \"(pcr_stream (=) ===> pcr_stream (=) ===> pcr_stream (=)) lzip szip\"", "lemma of_seq_rec [code]: \"of_seq f = f 0 ## of_seq (f \\<circ> Suc)\"", "lemma snth_of_seq [simp]: \"snth (of_seq f) = f\"", "lemma snth_SCons: \"snth (x ## xs) n = (case n of 0 \\<Rightarrow> x | Suc n' \\<Rightarrow> snth xs n')\"", "lemma snth_SCons_simps [simp]:\n  shows snth_SCons_0: \"(x ## xs) !! 0 = x\"\n  and snth_SCons_Suc: \"(x ## xs) !! Suc n = xs !! n\"", "lemma of_seq_snth [simp]: \"of_seq (snth xs) = xs\"", "lemma shd_of_seq [simp]: \"shd (of_seq f) = f 0\"", "lemma stl_of_seq [simp]: \"stl (of_seq f) = of_seq (\\<lambda>n. f (Suc n))\"", "lemma sset_of_seq [simp]: \"sset (of_seq f) = range f\"", "lemma smap_of_seq [simp]: \"smap f (of_seq g) = of_seq (f \\<circ> g)\"", "lemmas siterate [nitpick_simp] = siterate.code", "lemma smap_iterates: \"smap f (siterate f x) = siterate f (f x)\"", "lemma siterate_smap: \"siterate f x = x ## (smap f (siterate f x))\"", "lemma siterate_conv_of_seq: \"siterate f a = of_seq (\\<lambda>n. (f ^^ n) a)\"", "lemma sconst_conv_of_seq: \"sconst a = of_seq (\\<lambda>_. a)\"", "lemma szip_sconst1 [simp]: \"szip (sconst a) xs = smap (Pair a) xs\"", "lemma szip_sconst2 [simp]: \"szip xs (sconst b) = smap (\\<lambda>x. (x, b)) xs\"", "lemma scount_simps:\n  \"P \\<omega> \\<Longrightarrow> scount P \\<omega> = eSuc (scount P (stl \\<omega>))\"\n  \"\\<not> P \\<omega> \\<Longrightarrow> scount P \\<omega> = scount P (stl \\<omega>)\"", "lemma scount_eq_0I: \"alw (not P) \\<omega> \\<Longrightarrow> scount P \\<omega> = 0\"", "lemma scount_eq_0D: \"scount P \\<omega> = 0 \\<Longrightarrow> alw (not P) \\<omega>\"", "lemma scount_eq_0_iff: \"scount P \\<omega> = 0 \\<longleftrightarrow> alw (not P) \\<omega>\"", "lemma\n  assumes \"ev (alw (not P)) \\<omega>\"\n  shows scount_eq_card: \"scount P \\<omega> = enat (card {i. P (sdrop i \\<omega>)})\"\n    and ev_alw_not_HLD_finite: \"finite {i. P (sdrop i \\<omega>)}\"", "lemma scount_finite: \"ev (alw (not P)) \\<omega> \\<Longrightarrow> scount P \\<omega> < \\<infinity>\"", "lemma scount_infinite:\n  \"alw (ev P) \\<omega> \\<Longrightarrow> scount P \\<omega> = \\<infinity>\"", "lemma scount_infinite_iff: \"scount P \\<omega> = \\<infinity> \\<longleftrightarrow> alw (ev P) \\<omega>\"", "lemma scount_eq:\n  \"scount P \\<omega> = (if alw (ev P) \\<omega> then \\<infinity> else enat (card {i. P (sdrop i \\<omega>)}))\"", "lemma sfirst_eq_0: \"sfirst P \\<omega> = 0 \\<longleftrightarrow> P \\<omega>\"", "lemma sfirst_0[simp]: \"P \\<omega> \\<Longrightarrow> sfirst P \\<omega> = 0\"", "lemma sfirst_eSuc[simp]: \"\\<not> P \\<omega> \\<Longrightarrow> sfirst P \\<omega> = eSuc (sfirst P (stl \\<omega>))\"", "lemma less_sfirstD:\n  fixes n :: nat\n  assumes \"enat n < sfirst P \\<omega>\" shows \"\\<not> P (sdrop n \\<omega>)\"", "lemma sfirst_finite: \"sfirst P \\<omega> < \\<infinity> \\<longleftrightarrow> ev P \\<omega>\"", "lemma sfirst_Stream: \"sfirst P (s ## x) = (if P (s ## x) then 0 else eSuc (sfirst P x))\"", "lemma less_sfirst_iff: \"(not P until (alw P)) \\<omega> \\<Longrightarrow> enat n < sfirst P \\<omega> \\<longleftrightarrow> \\<not> P (sdrop n \\<omega>)\"", "lemma sfirst_eq_Inf: \"sfirst P \\<omega> = Inf {enat i | i. P (sdrop i \\<omega>)}\"", "lemma sfirst_eq_enat_iff: \"sfirst P \\<omega> = enat n \\<longleftrightarrow> ev_at P n \\<omega>\"", "lemma stakeWhile_SCons [simp]:\n  \"stakeWhile P (x ## xs) = (if P x then LCons x (stakeWhile P xs) else LNil)\"", "lemma lnull_stakeWhile [simp]: \"lnull (stakeWhile P xs) \\<longleftrightarrow> \\<not> P (shd xs)\"", "lemma lhd_stakeWhile [simp]: \"P (shd xs) \\<Longrightarrow> lhd (stakeWhile P xs) = shd xs\"", "lemma ltl_stakeWhile [simp]:\n  \"ltl (stakeWhile P xs) = (if P (shd xs) then stakeWhile P (stl xs) else LNil)\"", "lemma stakeWhile_K_False [simp]: \"stakeWhile (\\<lambda>_. False) xs = LNil\"", "lemma stakeWhile_K_True [simp]: \"stakeWhile (\\<lambda>_. True) xs = llist_of_stream xs\"", "lemma stakeWhile_smap: \"stakeWhile P (smap f xs) = lmap f (stakeWhile (P \\<circ> f) xs)\"", "lemma lfinite_stakeWhile [simp]: \"lfinite (stakeWhile P xs) \\<longleftrightarrow> (\\<exists>x\\<in>sset xs. \\<not> P x)\""], "translations": [["", "lemma eq_onpI: \"P x \\<Longrightarrow> eq_onp P x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x \\<Longrightarrow> eq_onp P x x", "by(simp add: eq_onp_def)"], ["", "primcorec unfold_stream :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'b stream\" where\n  \"unfold_stream g1 g2 a = g1 a ## unfold_stream g1 g2 (g2 a)\""], ["", "text \\<open>\n  The following setup should be done by the BNF package.\n\\<close>"], ["", "text \\<open>congruence rule\\<close>"], ["", "declare stream.map_cong [cong]"], ["", "text \\<open>lemmas about generated constants\\<close>"], ["", "lemma eq_SConsD: \"xs = SCons y ys \\<Longrightarrow> shd xs = y \\<and> stl xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = y ## ys \\<Longrightarrow> shd xs = y \\<and> stl xs = ys", "by auto"], ["", "declare stream.map_ident[simp]"], ["", "lemma smap_eq_SCons_conv:\n  \"smap f xs = y ## ys \\<longleftrightarrow>\n  (\\<exists>x xs'. xs = x ## xs' \\<and> y = f x \\<and> ys = smap f xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (smap f xs = y ## ys) =\n    (\\<exists>x xs'. xs = x ## xs' \\<and> y = f x \\<and> ys = smap f xs')", "by(cases xs)(auto)"], ["", "lemma smap_unfold_stream:\n  \"smap f (unfold_stream SHD STL b) = unfold_stream (f \\<circ> SHD) STL b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap f (unfold_stream SHD STL b) = unfold_stream (f \\<circ> SHD) STL b", "by(coinduction arbitrary: b) auto"], ["", "lemma smap_corec_stream:\n  \"smap f (corec_stream SHD endORmore STL_end STL_more b) =\n   corec_stream (f \\<circ> SHD) endORmore (smap f \\<circ> STL_end) STL_more b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap f (corec_stream SHD endORmore STL_end STL_more b) =\n    corec_stream (f \\<circ> SHD) endORmore (smap f \\<circ> STL_end) STL_more\n     b", "by(coinduction arbitrary: b rule: stream.coinduct_strong) auto"], ["", "lemma unfold_stream_ltl_unroll:\n  \"unfold_stream SHD STL (STL b) = unfold_stream (SHD \\<circ> STL) STL b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold_stream SHD STL (STL b) = unfold_stream (SHD \\<circ> STL) STL b", "by(coinduction arbitrary: b) auto"], ["", "lemma unfold_stream_eq_SCons [simp]:\n  \"unfold_stream SHD STL b = x ## xs \\<longleftrightarrow>\n  x = SHD b \\<and> xs = unfold_stream SHD STL (STL b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unfold_stream SHD STL b = x ## xs) =\n    (x = SHD b \\<and> xs = unfold_stream SHD STL (STL b))", "by(subst unfold_stream.ctr) auto"], ["", "lemma unfold_stream_id [simp]: \"unfold_stream shd stl xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold_stream shd stl xs = xs", "by(coinduction arbitrary: xs) simp_all"], ["", "lemma sset_neq_empty [simp]: \"sset xs \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset xs \\<noteq> {}", "by(cases xs) simp_all"], ["", "declare stream.set_sel(1)[simp]"], ["", "lemma sset_stl: \"sset (stl xs) \\<subseteq> sset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (stl xs) \\<subseteq> sset xs", "by(cases xs) auto"], ["", "text \\<open>induction rules\\<close>"], ["", "lemmas stream_set_induct = sset_induct"], ["", "subsection \\<open>Lemmas about operations from @{theory \"HOL-Library.Stream\"}\\<close>"], ["", "lemma szip_iterates:\n  \"szip (siterate f a) (siterate g b) = siterate (map_prod f g) (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. szip (siterate f a) (siterate g b) = siterate (map_prod f g) (a, b)", "by(coinduction arbitrary: a b) auto"], ["", "lemma szip_smap1: \"szip (smap f xs) ys = smap (apfst f) (szip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. szip (smap f xs) ys = smap (apfst f) (szip xs ys)", "by(coinduction arbitrary: xs ys) auto"], ["", "lemma szip_smap2: \"szip xs (smap g ys) = smap (apsnd g) (szip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. szip xs (smap g ys) = smap (apsnd g) (szip xs ys)", "by(coinduction arbitrary: xs ys) auto"], ["", "lemma szip_smap [simp]: \"szip (smap f xs) (smap g ys) = smap (map_prod f g) (szip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. szip (smap f xs) (smap g ys) = smap (map_prod f g) (szip xs ys)", "by(coinduction arbitrary: xs ys) auto"], ["", "lemma smap_fst_szip [simp]: \"smap fst (szip xs ys) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap fst (szip xs ys) = xs", "by(coinduction arbitrary: xs ys) auto"], ["", "lemma smap_snd_szip [simp]: \"smap snd (szip xs ys) = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap snd (szip xs ys) = ys", "by(coinduction arbitrary: xs ys) auto"], ["", "lemma snth_shift: \"snth (shift xs ys) n = (if n < length xs then xs ! n else snth ys (n - length xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @- ys) !! n =\n    (if n < length xs then xs ! n else ys !! (n - length xs))", "by simp"], ["", "declare szip_unfold [simp, nitpick_simp]"], ["", "lemma szip_shift:\n  \"length xs = length us\n  \\<Longrightarrow> szip (xs @- ys) (us @- zs) = zip xs us @- szip ys zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length us \\<Longrightarrow>\n    szip (xs @- ys) (us @- zs) = zip xs us @- szip ys zs", "by(induct xs arbitrary: us)(auto simp add: Suc_length_conv)"], ["", "subsection \\<open>Link @{typ \"'a stream\"} to @{typ \"'a llist\"}\\<close>"], ["", "definition llist_of_stream :: \"'a stream \\<Rightarrow> 'a llist\"\nwhere \"llist_of_stream = unfold_llist (\\<lambda>_. False) shd stl\""], ["", "definition stream_of_llist :: \"'a llist \\<Rightarrow> 'a stream\"\nwhere \"stream_of_llist = unfold_stream lhd ltl\""], ["", "lemma lnull_llist_of_stream [simp]: \"\\<not> lnull (llist_of_stream xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull (llist_of_stream xs)", "by(simp add: llist_of_stream_def)"], ["", "lemma ltl_llist_of_stream [simp]: \"ltl (llist_of_stream xs) = llist_of_stream (stl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (llist_of_stream xs) = llist_of_stream (stl xs)", "by(simp add: llist_of_stream_def)"], ["", "lemma stl_stream_of_llist [simp]: \"stl (stream_of_llist xs) = stream_of_llist (ltl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stl (stream_of_llist xs) = stream_of_llist (ltl xs)", "by(simp add: stream_of_llist_def)"], ["", "lemma shd_stream_of_llist [simp]: \"shd (stream_of_llist xs) = lhd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shd (stream_of_llist xs) = lhd xs", "by(simp add: stream_of_llist_def)"], ["", "lemma lhd_llist_of_stream [simp]: \"lhd (llist_of_stream xs) = shd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd (llist_of_stream xs) = shd xs", "by(simp add: llist_of_stream_def)"], ["", "lemma stream_of_llist_llist_of_stream [simp]:\n  \"stream_of_llist (llist_of_stream xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_of_llist (llist_of_stream xs) = xs", "by(coinduction arbitrary: xs) simp_all"], ["", "lemma llist_of_stream_stream_of_llist [simp]:\n  \"\\<not> lfinite xs \\<Longrightarrow> llist_of_stream (stream_of_llist xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llist_of_stream (stream_of_llist xs) = xs", "by(coinduction arbitrary: xs) auto"], ["", "lemma lfinite_llist_of_stream [simp]: \"\\<not> lfinite (llist_of_stream xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite (llist_of_stream xs)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite (llist_of_stream xs) \\<Longrightarrow> False", "assume \"lfinite (llist_of_stream xs)\""], ["proof (state)\nthis:\n  lfinite (llist_of_stream xs)\n\ngoal (1 subgoal):\n 1. lfinite (llist_of_stream xs) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  lfinite (llist_of_stream xs)\n\ngoal (1 subgoal):\n 1. False", "by(induct \"llist_of_stream xs\" arbitrary: xs rule: lfinite_induct) auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stream_from_llist: \"type_definition llist_of_stream stream_of_llist {xs. \\<not> lfinite xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition llist_of_stream stream_of_llist {xs. \\<not> lfinite xs}", "by(unfold_locales) simp_all"], ["", "interpretation stream: type_definition llist_of_stream stream_of_llist \"{xs. \\<not> lfinite xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition llist_of_stream stream_of_llist {xs. \\<not> lfinite xs}", "by(fact stream_from_llist)"], ["", "declare stream.exhaust[cases type: stream]"], ["", "locale stream_from_llist_setup\nbegin"], ["", "setup_lifting stream_from_llist"], ["", "end"], ["", "context\nbegin"], ["", "interpretation stream_from_llist_setup"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma cr_streamI: \"\\<not> lfinite xs \\<Longrightarrow> cr_stream xs (stream_of_llist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> cr_stream xs (stream_of_llist xs)", "by(simp add: cr_stream_def Abs_stream_inverse)"], ["", "lemma llist_of_stream_unfold_stream [simp]:\n  \"llist_of_stream (unfold_stream SHD STL x) = unfold_llist (\\<lambda>_. False) SHD STL x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_of_stream (unfold_stream SHD STL x) =\n    unfold_llist (\\<lambda>_. False) SHD STL x", "by(coinduction arbitrary: x) auto"], ["", "lemma llist_of_stream_corec_stream [simp]:\n  \"llist_of_stream (corec_stream SHD endORmore STL_more STL_end x) =\n   corec_llist (\\<lambda>_. False) SHD endORmore (llist_of_stream \\<circ> STL_more) STL_end x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_of_stream (corec_stream SHD endORmore STL_more STL_end x) =\n    corec_llist (\\<lambda>_. False) SHD endORmore\n     (llist_of_stream \\<circ> STL_more) STL_end x", "by(coinduction arbitrary: x rule: llist.coinduct_strong) auto"], ["", "lemma LCons_llist_of_stream [simp]: \"LCons x (llist_of_stream xs) = llist_of_stream (x ## xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LCons x (llist_of_stream xs) = llist_of_stream (x ## xs)", "by(rule sym)(simp add: llist_of_stream_def)"], ["", "lemma lmap_llist_of_stream [simp]:\n  \"lmap f (llist_of_stream xs) = llist_of_stream (smap f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (llist_of_stream xs) = llist_of_stream (smap f xs)", "by(coinduction arbitrary: xs) auto"], ["", "lemma lset_llist_of_stream [simp]: \"lset (llist_of_stream xs) = sset xs\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (llist_of_stream xs) = sset xs", "proof(intro set_eqI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> lset (llist_of_stream xs) \\<Longrightarrow> x \\<in> sset xs\n 2. \\<And>x.\n       x \\<in> sset xs \\<Longrightarrow> x \\<in> lset (llist_of_stream xs)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> lset (llist_of_stream xs) \\<Longrightarrow> x \\<in> sset xs\n 2. \\<And>x.\n       x \\<in> sset xs \\<Longrightarrow> x \\<in> lset (llist_of_stream xs)", "assume \"x \\<in> ?lhs\""], ["proof (state)\nthis:\n  x \\<in> lset (llist_of_stream xs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> lset (llist_of_stream xs) \\<Longrightarrow> x \\<in> sset xs\n 2. \\<And>x.\n       x \\<in> sset xs \\<Longrightarrow> x \\<in> lset (llist_of_stream xs)", "thus \"x \\<in> ?rhs\""], ["proof (prove)\nusing this:\n  x \\<in> lset (llist_of_stream xs)\n\ngoal (1 subgoal):\n 1. x \\<in> sset xs", "by(induct \"llist_of_stream xs\" arbitrary: xs rule: llist_set_induct)\n      (auto dest: stream.set_sel(2))"], ["proof (state)\nthis:\n  x \\<in> sset xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sset xs \\<Longrightarrow> x \\<in> lset (llist_of_stream xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sset xs \\<Longrightarrow> x \\<in> lset (llist_of_stream xs)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sset xs \\<Longrightarrow> x \\<in> lset (llist_of_stream xs)", "assume \"x \\<in> ?rhs\""], ["proof (state)\nthis:\n  x \\<in> sset xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sset xs \\<Longrightarrow> x \\<in> lset (llist_of_stream xs)", "thus \"x \\<in> ?lhs\""], ["proof (prove)\nusing this:\n  x \\<in> sset xs\n\ngoal (1 subgoal):\n 1. x \\<in> lset (llist_of_stream xs)", "proof(induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. shd s \\<in> lset (llist_of_stream s)\n 2. \\<And>s y.\n       \\<lbrakk>y \\<in> sset (stl s);\n        y \\<in> lset (llist_of_stream (stl s))\\<rbrakk>\n       \\<Longrightarrow> y \\<in> lset (llist_of_stream s)", "case (shd xs)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s. shd s \\<in> lset (llist_of_stream s)\n 2. \\<And>s y.\n       \\<lbrakk>y \\<in> sset (stl s);\n        y \\<in> lset (llist_of_stream (stl s))\\<rbrakk>\n       \\<Longrightarrow> y \\<in> lset (llist_of_stream s)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. shd xs \\<in> lset (llist_of_stream xs)", "using llist.set_sel(1)[of \"llist_of_stream xs\"]"], ["proof (prove)\nusing this:\n  \\<not> lnull (llist_of_stream xs) \\<Longrightarrow>\n  lhd (llist_of_stream xs) \\<in> lset (llist_of_stream xs)\n\ngoal (1 subgoal):\n 1. shd xs \\<in> lset (llist_of_stream xs)", "by simp"], ["proof (state)\nthis:\n  shd xs \\<in> lset (llist_of_stream xs)\n\ngoal (1 subgoal):\n 1. \\<And>s y.\n       \\<lbrakk>y \\<in> sset (stl s);\n        y \\<in> lset (llist_of_stream (stl s))\\<rbrakk>\n       \\<Longrightarrow> y \\<in> lset (llist_of_stream s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s y.\n       \\<lbrakk>y \\<in> sset (stl s);\n        y \\<in> lset (llist_of_stream (stl s))\\<rbrakk>\n       \\<Longrightarrow> y \\<in> lset (llist_of_stream s)", "case stl"], ["proof (state)\nthis:\n  y_ \\<in> sset (stl s_)\n  y_ \\<in> lset (llist_of_stream (stl s_))\n\ngoal (1 subgoal):\n 1. \\<And>s y.\n       \\<lbrakk>y \\<in> sset (stl s);\n        y \\<in> lset (llist_of_stream (stl s))\\<rbrakk>\n       \\<Longrightarrow> y \\<in> lset (llist_of_stream s)", "thus ?case"], ["proof (prove)\nusing this:\n  y_ \\<in> sset (stl s_)\n  y_ \\<in> lset (llist_of_stream (stl s_))\n\ngoal (1 subgoal):\n 1. y_ \\<in> lset (llist_of_stream s_)", "by(auto simp add: ltl_llist_of_stream[symmetric] simp del: ltl_llist_of_stream dest: in_lset_ltlD)"], ["proof (state)\nthis:\n  y_ \\<in> lset (llist_of_stream s_)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> lset (llist_of_stream xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lnth_list_of_stream [simp]:\n  \"lnth (llist_of_stream xs) = snth xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (llist_of_stream xs) = (!!) xs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lnth (llist_of_stream xs) x = xs !! x", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lnth (llist_of_stream xs) x = xs !! x", "show \"lnth (llist_of_stream xs) n = snth xs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (llist_of_stream xs) n = xs !! n", "by(induction n arbitrary: xs)(simp_all add: lnth_0_conv_lhd lnth_ltl[symmetric])"], ["proof (state)\nthis:\n  lnth (llist_of_stream xs) n = xs !! n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llist_of_stream_siterates [simp]: \"llist_of_stream (siterate f x) = iterates f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_of_stream (siterate f x) = iterates f x", "by(coinduction arbitrary: x) auto"], ["", "lemma lappend_llist_of_stream_conv_shift [simp]:\n  \"lappend (llist_of xs) (llist_of_stream ys) = llist_of_stream (xs @- ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend (llist_of xs) (llist_of_stream ys) = llist_of_stream (xs @- ys)", "by(induct xs) simp_all"], ["", "lemma lzip_llist_of_stream [simp]:\n  \"lzip (llist_of_stream xs) (llist_of_stream ys) = llist_of_stream (szip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip (llist_of_stream xs) (llist_of_stream ys) =\n    llist_of_stream (szip xs ys)", "by(coinduction arbitrary: xs ys) auto"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma lmap_infinite_transfer [transfer_rule]:\n  \"((=) ===> eq_onp (\\<lambda>xs. \\<not> lfinite xs) ===> eq_onp (\\<lambda>xs. \\<not> lfinite xs)) lmap lmap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     eq_onp (\\<lambda>xs. \\<not> lfinite xs) ===>\n     eq_onp (\\<lambda>xs. \\<not> lfinite xs))\n     lmap lmap", "by(simp add: rel_fun_def eq_onp_def)"], ["", "lemma lset_infinite_transfer [transfer_rule]:\n  \"(eq_onp (\\<lambda>xs. \\<not> lfinite xs) ===> (=)) lset lset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq_onp (\\<lambda>xs. \\<not> lfinite xs) ===> (=)) lset lset", "by(simp add: rel_fun_def eq_onp_def)"], ["", "lemma unfold_stream_transfer [transfer_rule]:\n  \"((=) ===> (=) ===> (=) ===> pcr_stream (=)) (unfold_llist (\\<lambda>_. False)) unfold_stream\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> (=) ===> pcr_stream (=))\n     (unfold_llist (\\<lambda>_. False)) unfold_stream", "by(auto simp add: stream.pcr_cr_eq cr_stream_def intro!: rel_funI)"], ["", "lemma corec_stream_transfer [transfer_rule]:\n  \"((=) ===> (=) ===> ((=) ===> pcr_stream (=)) ===> (=) ===> (=) ===> pcr_stream (=))\n   (corec_llist (\\<lambda>_. False)) corec_stream\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     (=) ===>\n     ((=) ===> pcr_stream (=)) ===> (=) ===> (=) ===> pcr_stream (=))\n     (corec_llist (\\<lambda>_. False)) corec_stream", "apply(auto intro!: rel_funI simp add: cr_stream_def stream.pcr_cr_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ya xb yb yc yd.\n       ((=) ===> (\\<lambda>x y. x = llist_of_stream y)) xb\n        yb \\<Longrightarrow>\n       corec_llist (\\<lambda>_. False) y ya xb yc yd =\n       corec_llist (\\<lambda>_. False) y ya (llist_of_stream \\<circ> yb) yc\n        yd", "apply(rule fun_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ya xb yb yc yd.\n       ((=) ===> (\\<lambda>x y. x = llist_of_stream y)) xb\n        yb \\<Longrightarrow>\n       (\\<lambda>a. corec_llist (\\<lambda>_. False) y ya xb yc yd) =\n       (\\<lambda>a. a)", "back"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ya xb yb yc yd.\n       ((=) ===> (\\<lambda>x y. x = llist_of_stream y)) xb\n        yb \\<Longrightarrow>\n       corec_llist (\\<lambda>_. False) y ya xb yc =\n       corec_llist (\\<lambda>_. False) y ya (llist_of_stream \\<circ> yb) yc", "apply(rule_tac x=yc in fun_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ya xb yb yc yd.\n       ((=) ===> (\\<lambda>x y. x = llist_of_stream y)) xb\n        yb \\<Longrightarrow>\n       corec_llist (\\<lambda>_. False) y ya xb =\n       corec_llist (\\<lambda>_. False) y ya (llist_of_stream \\<circ> yb)", "apply(rule_tac x=xb in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ya xb yb yc yd.\n       ((=) ===> (\\<lambda>x y. x = llist_of_stream y)) xb\n        yb \\<Longrightarrow>\n       xb = llist_of_stream \\<circ> yb", "apply(auto elim: rel_funE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shd_transfer [transfer_rule]: \"(pcr_stream A ===> A) lhd shd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_stream A ===> A) lhd shd", "by(auto simp add: pcr_stream_def cr_stream_def intro!: rel_funI relcomppI)(frule llist_all2_lhdD, auto dest: llist_all2_lnullD)"], ["", "lemma stl_transfer [transfer_rule]: \"(pcr_stream A ===> pcr_stream A) ltl stl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_stream A ===> pcr_stream A) ltl stl", "by(auto simp add: pcr_stream_def cr_stream_def intro!: rel_funI relcomppI dest: llist_all2_ltlI)"], ["", "lemma llist_of_stream_transfer [transfer_rule]: \"(pcr_stream (=) ===> (=)) id llist_of_stream\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_stream (=) ===> (=)) id llist_of_stream", "by(simp add: rel_fun_def stream.pcr_cr_eq cr_stream_def)"], ["", "lemma stream_of_llist_transfer [transfer_rule]:\n  \"(eq_onp (\\<lambda>xs. \\<not> lfinite xs) ===> pcr_stream (=)) (\\<lambda>xs. xs) stream_of_llist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq_onp (\\<lambda>xs. \\<not> lfinite xs) ===> pcr_stream (=))\n     (\\<lambda>xs. xs) stream_of_llist", "by(simp add: eq_onp_def rel_fun_def stream.pcr_cr_eq cr_stream_def)"], ["", "lemma SCons_transfer [transfer_rule]:\n  \"(A ===> pcr_stream A ===> pcr_stream A) LCons (##)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> pcr_stream A ===> pcr_stream A) LCons (##)", "by(auto simp add: cr_stream_def pcr_stream_def intro!: rel_funI relcomppI intro: llist_all2_expand)"], ["", "lemma sset_transfer [transfer_rule]: \"(pcr_stream A ===> rel_set A) lset sset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_stream A ===> rel_set A) lset sset", "by(auto 4 3 simp add: pcr_stream_def cr_stream_def intro!: rel_funI relcomppI rel_setI dest: llist_all2_lsetD1 llist_all2_lsetD2)"], ["", "lemma smap_transfer [transfer_rule]:\n  \"((A ===> B) ===> pcr_stream A ===> pcr_stream B) lmap smap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B) ===> pcr_stream A ===> pcr_stream B) lmap smap", "by(auto simp add: cr_stream_def pcr_stream_def intro!: rel_funI relcomppI dest: lmap_transfer[THEN rel_funD] elim: rel_funD)"], ["", "lemma snth_transfer [transfer_rule]: \"(pcr_stream (=) ===> (=)) lnth snth\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_stream (=) ===> (=)) lnth (!!)", "by(rule rel_funI)(clarsimp simp add: stream.pcr_cr_eq cr_stream_def fun_eq_iff)"], ["", "lemma siterate_transfer [transfer_rule]:\n  \"((=) ===> (=) ===> pcr_stream (=)) iterates siterate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> pcr_stream (=)) iterates siterate", "by(rule rel_funI)+(clarsimp simp add: stream.pcr_cr_eq cr_stream_def)"], ["", "context\n  fixes xs\n  assumes inf: \"\\<not> lfinite xs\"\n  notes [transfer_rule] = eq_onpI[where P=\"\\<lambda>xs. \\<not> lfinite xs\", OF inf]\nbegin"], ["", "lemma smap_stream_of_llist [simp]:\n  shows \"smap f (stream_of_llist xs) = stream_of_llist (lmap f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap f (stream_of_llist xs) = stream_of_llist (lmap f xs)", "by transfer simp"], ["", "lemma sset_stream_of_llist [simp]:\n  assumes \"\\<not> lfinite xs\"\n  shows \"sset (stream_of_llist xs) = lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (stream_of_llist xs) = lset xs", "by transfer simp"], ["", "end"], ["", "lemma llist_all2_llist_of_stream [simp]:\n  \"llist_all2 P (llist_of_stream xs) (llist_of_stream ys) = stream_all2 P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P (llist_of_stream xs) (llist_of_stream ys) =\n    stream_all2 P xs ys", "apply(cases xs ys rule: stream.Abs_cases[case_product stream.Abs_cases])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y__ ya__.\n       \\<lbrakk>xs = stream_of_llist y__; y__ \\<in> {xs. \\<not> lfinite xs};\n        ys = stream_of_llist ya__;\n        ya__ \\<in> {xs. \\<not> lfinite xs}\\<rbrakk>\n       \\<Longrightarrow> llist_all2 P (llist_of_stream xs)\n                          (llist_of_stream ys) =\n                         stream_all2 P xs ys", "apply(simp add: llist_all2_def stream_all2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y__ ya__.\n       \\<lbrakk>xs = stream_of_llist y__; \\<not> lfinite y__;\n        ys = stream_of_llist ya__; \\<not> lfinite ya__\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp\n                            {x. lset x \\<subseteq> {(x, y). P x y}}\n                            (lmap fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. lset x \\<subseteq> {(x, y). P x y}}\n                           (lmap snd))\n                          y__ ya__ =\n                         ((BNF_Def.Grp\n                            {x. sset x \\<subseteq> {(x, y). P x y}}\n                            (smap fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. sset x \\<subseteq> {(x, y). P x y}}\n                           (smap snd))\n                          (stream_of_llist y__) (stream_of_llist ya__)", "apply(safe elim!: GrpE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>_ _ b.\n       \\<lbrakk>xs = stream_of_llist (lmap fst b);\n        \\<not> lfinite (lmap fst b); ys = stream_of_llist (lmap snd b);\n        \\<not> lfinite (lmap snd b); lset b \\<subseteq> {(x, y). P x y};\n        lset b \\<subseteq> {(x, y). P x y}\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp\n                            {x. sset x \\<subseteq> {(x, y). P x y}}\n                            (smap fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. sset x \\<subseteq> {(x, y). P x y}}\n                           (smap snd))\n                          (stream_of_llist (lmap fst b))\n                          (stream_of_llist (lmap snd b))\n 2. \\<And>y__ ya__ b.\n       \\<lbrakk>xs = stream_of_llist y__; \\<not> lfinite y__;\n        ys = stream_of_llist ya__; \\<not> lfinite ya__;\n        smap snd b = stream_of_llist ya__; smap fst b = stream_of_llist y__;\n        sset b \\<subseteq> {(x, y). P x y};\n        sset b \\<subseteq> {(x, y). P x y}\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp\n                            {x. lset x \\<subseteq> {(x, y). P x y}}\n                            (lmap fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. lset x \\<subseteq> {(x, y). P x y}}\n                           (lmap snd))\n                          y__ ya__", "apply(rule_tac b=\"stream_of_llist b\" in relcomppI; auto intro!: GrpI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y__ ya__ b.\n       \\<lbrakk>xs = stream_of_llist y__; \\<not> lfinite y__;\n        ys = stream_of_llist ya__; \\<not> lfinite ya__;\n        smap snd b = stream_of_llist ya__; smap fst b = stream_of_llist y__;\n        sset b \\<subseteq> {(x, y). P x y};\n        sset b \\<subseteq> {(x, y). P x y}\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp\n                            {x. lset x \\<subseteq> {(x, y). P x y}}\n                            (lmap fst))\\<inverse>\\<inverse> OO\n                          BNF_Def.Grp\n                           {x. lset x \\<subseteq> {(x, y). P x y}}\n                           (lmap snd))\n                          y__ ya__", "apply(rule_tac b=\"llist_of_stream b\" in relcomppI; auto intro!: GrpI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma stream_all2_transfer [transfer_rule]:\n  \"((=) ===> pcr_stream (=) ===> pcr_stream (=) ===> (=)) llist_all2 stream_all2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> pcr_stream (=) ===> pcr_stream (=) ===> (=)) llist_all2\n     stream_all2", "by(simp add: rel_fun_def stream.pcr_cr_eq cr_stream_def)"], ["", "lemma stream_all2_coinduct:\n  assumes \"X xs ys\"\n  and \"\\<And>xs ys. X xs ys \\<Longrightarrow> P (shd xs) (shd ys) \\<and> (X (stl xs) (stl ys) \\<or> stream_all2 P (stl xs) (stl ys))\"\n  shows \"stream_all2 P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 P xs ys", "using assms"], ["proof (prove)\nusing this:\n  X xs ys\n  X ?xs ?ys \\<Longrightarrow>\n  P (shd ?xs) (shd ?ys) \\<and>\n  (X (stl ?xs) (stl ?ys) \\<or> stream_all2 P (stl ?xs) (stl ?ys))\n\ngoal (1 subgoal):\n 1. stream_all2 P xs ys", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X xs ys P.\n       \\<lbrakk>\\<not> lfinite xs; \\<not> lfinite ys; X xs ys;\n        \\<And>xs ys.\n           \\<lbrakk>\\<not> lfinite xs; \\<not> lfinite ys; X xs ys\\<rbrakk>\n           \\<Longrightarrow> P (lhd xs) (lhd ys) \\<and>\n                             (X (ltl xs) (ltl ys) \\<or>\n                              llist_all2 P (ltl xs) (ltl ys))\\<rbrakk>\n       \\<Longrightarrow> llist_all2 P xs ys", "apply(rule_tac X=\"\\<lambda>xs ys. \\<not> lfinite xs \\<and> \\<not> lfinite ys \\<and> X xs ys\" in llist_all2_coinduct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>X xs ys P.\n       \\<lbrakk>\\<not> lfinite xs; \\<not> lfinite ys; X xs ys;\n        \\<And>xs ys.\n           \\<lbrakk>\\<not> lfinite xs; \\<not> lfinite ys; X xs ys\\<rbrakk>\n           \\<Longrightarrow> P (lhd xs) (lhd ys) \\<and>\n                             (X (ltl xs) (ltl ys) \\<or>\n                              llist_all2 P (ltl xs) (ltl ys))\\<rbrakk>\n       \\<Longrightarrow> \\<not> lfinite xs \\<and>\n                         \\<not> lfinite ys \\<and> X xs ys\n 2. \\<And>X xs ys P xsa ysa.\n       \\<lbrakk>\\<not> lfinite xs; \\<not> lfinite ys; X xs ys;\n        \\<And>xs ys.\n           \\<lbrakk>\\<not> lfinite xs; \\<not> lfinite ys; X xs ys\\<rbrakk>\n           \\<Longrightarrow> P (lhd xs) (lhd ys) \\<and>\n                             (X (ltl xs) (ltl ys) \\<or>\n                              llist_all2 P (ltl xs) (ltl ys));\n        \\<not> lfinite xsa \\<and>\n        \\<not> lfinite ysa \\<and> X xsa ysa\\<rbrakk>\n       \\<Longrightarrow> lnull xsa = lnull ysa\n 3. \\<And>X xs ys P xsa ysa.\n       \\<lbrakk>\\<not> lfinite xs; \\<not> lfinite ys; X xs ys;\n        \\<And>xs ys.\n           \\<lbrakk>\\<not> lfinite xs; \\<not> lfinite ys; X xs ys\\<rbrakk>\n           \\<Longrightarrow> P (lhd xs) (lhd ys) \\<and>\n                             (X (ltl xs) (ltl ys) \\<or>\n                              llist_all2 P (ltl xs) (ltl ys));\n        \\<not> lfinite xsa \\<and> \\<not> lfinite ysa \\<and> X xsa ysa;\n        \\<not> lnull xsa; \\<not> lnull ysa\\<rbrakk>\n       \\<Longrightarrow> P (lhd xsa) (lhd ysa) \\<and>\n                         (\\<not> lfinite (ltl xsa) \\<and>\n                          \\<not> lfinite (ltl ysa) \\<and>\n                          X (ltl xsa) (ltl ysa) \\<or>\n                          llist_all2 P (ltl xsa) (ltl ysa))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shift_transfer [transfer_rule]:\n  \"((=) ===> pcr_stream (=) ===> pcr_stream (=)) (lappend \\<circ> llist_of) shift\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> pcr_stream (=) ===> pcr_stream (=)) (lappend \\<circ> llist_of)\n     (@-)", "by(clarsimp simp add: rel_fun_def stream.pcr_cr_eq cr_stream_def)"], ["", "lemma szip_transfer [transfer_rule]:\n  \"(pcr_stream (=) ===> pcr_stream (=) ===> pcr_stream (=)) lzip szip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_stream (=) ===> pcr_stream (=) ===> pcr_stream (=)) lzip szip", "by(simp add: stream.pcr_cr_eq cr_stream_def rel_fun_def)"], ["", "subsection \\<open>Link @{typ \"'a stream\"} with @{typ \"nat \\<Rightarrow> 'a\"}\\<close>"], ["", "lift_definition of_seq :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> 'a stream\" is \"inf_llist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. \\<not> lfinite (inf_llist fun)", "by simp"], ["", "lemma of_seq_rec [code]: \"of_seq f = f 0 ## of_seq (f \\<circ> Suc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_seq f = f 0 ## of_seq (f \\<circ> Suc)", "by transfer (subst inf_llist_rec, simp add: o_def)"], ["", "lemma snth_of_seq [simp]: \"snth (of_seq f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (!!) (of_seq f) = f", "by transfer (simp add: fun_eq_iff)"], ["", "lemma snth_SCons: \"snth (x ## xs) n = (case n of 0 \\<Rightarrow> x | Suc n' \\<Rightarrow> snth xs n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ## xs) !! n =\n    (case n of 0 \\<Rightarrow> x | Suc n' \\<Rightarrow> xs !! n')", "by(simp split: nat.split)"], ["", "lemma snth_SCons_simps [simp]:\n  shows snth_SCons_0: \"(x ## xs) !! 0 = x\"\n  and snth_SCons_Suc: \"(x ## xs) !! Suc n = xs !! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ## xs) !! 0 = x &&& (x ## xs) !! Suc n = xs !! n", "by(simp_all add: snth_SCons)"], ["", "lemma of_seq_snth [simp]: \"of_seq (snth xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_seq ((!!) xs) = xs", "by transfer simp"], ["", "lemma shd_of_seq [simp]: \"shd (of_seq f) = f 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shd (of_seq f) = f 0", "by transfer simp"], ["", "lemma stl_of_seq [simp]: \"stl (of_seq f) = of_seq (\\<lambda>n. f (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stl (of_seq f) = of_seq (\\<lambda>n. f (Suc n))", "by transfer simp"], ["", "lemma sset_of_seq [simp]: \"sset (of_seq f) = range f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (of_seq f) = range f", "by transfer simp"], ["", "lemma smap_of_seq [simp]: \"smap f (of_seq g) = of_seq (f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap f (of_seq g) = of_seq (f \\<circ> g)", "by transfer simp"], ["", "end"], ["", "subsection\\<open>Function iteration @{const siterate}  and @{term sconst}\\<close>"], ["", "lemmas siterate [nitpick_simp] = siterate.code"], ["", "lemma smap_iterates: \"smap f (siterate f x) = siterate f (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap f (siterate f x) = siterate f (f x)", "by transfer (rule lmap_iterates)"], ["", "lemma siterate_smap: \"siterate f x = x ## (smap f (siterate f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. siterate f x = x ## smap f (siterate f x)", "by transfer (rule iterates_lmap)"], ["", "lemma siterate_conv_of_seq: \"siterate f a = of_seq (\\<lambda>n. (f ^^ n) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. siterate f a = of_seq (\\<lambda>n. (f ^^ n) a)", "by transfer (rule iterates_conv_inf_llist)"], ["", "lemma sconst_conv_of_seq: \"sconst a = of_seq (\\<lambda>_. a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sconst a = of_seq (\\<lambda>_. a)", "by(simp add: siterate_conv_of_seq)"], ["", "lemma szip_sconst1 [simp]: \"szip (sconst a) xs = smap (Pair a) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. szip (sconst a) xs = smap (Pair a) xs", "by(coinduction arbitrary: xs) auto"], ["", "lemma szip_sconst2 [simp]: \"szip xs (sconst b) = smap (\\<lambda>x. (x, b)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. szip xs (sconst b) = smap (\\<lambda>x. (x, b)) xs", "by(coinduction arbitrary: xs) auto"], ["", "end"], ["", "subsection \\<open> Counting elements \\<close>"], ["", "partial_function (lfp) scount :: \"('s stream \\<Rightarrow> bool) \\<Rightarrow> 's stream \\<Rightarrow> enat\" where\n  \"scount P \\<omega> = (if P \\<omega> then eSuc (scount P (stl \\<omega>)) else scount P (stl \\<omega>))\""], ["", "lemma scount_simps:\n  \"P \\<omega> \\<Longrightarrow> scount P \\<omega> = eSuc (scount P (stl \\<omega>))\"\n  \"\\<not> P \\<omega> \\<Longrightarrow> scount P \\<omega> = scount P (stl \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<omega> \\<Longrightarrow>\n     scount P \\<omega> = eSuc (scount P (stl \\<omega>))) &&&\n    (\\<not> P \\<omega> \\<Longrightarrow>\n     scount P \\<omega> = scount P (stl \\<omega>))", "using scount.simps[of P \\<omega>]"], ["proof (prove)\nusing this:\n  scount P \\<omega> =\n  (if P \\<omega> then eSuc (scount P (stl \\<omega>))\n   else scount P (stl \\<omega>))\n\ngoal (1 subgoal):\n 1. (P \\<omega> \\<Longrightarrow>\n     scount P \\<omega> = eSuc (scount P (stl \\<omega>))) &&&\n    (\\<not> P \\<omega> \\<Longrightarrow>\n     scount P \\<omega> = scount P (stl \\<omega>))", "by auto"], ["", "lemma scount_eq_0I: \"alw (not P) \\<omega> \\<Longrightarrow> scount P \\<omega> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>xs. \\<not> P xs) \\<omega> \\<Longrightarrow>\n    scount P \\<omega> = 0", "by (induct arbitrary: \\<omega> rule: scount.fixp_induct)\n     (auto simp: bot_enat_def intro!: admissible_all admissible_imp admissible_eq_mcontI mcont_const)"], ["", "lemma scount_eq_0D: \"scount P \\<omega> = 0 \\<Longrightarrow> alw (not P) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scount P \\<omega> = 0 \\<Longrightarrow>\n    alw (\\<lambda>xs. \\<not> P xs) \\<omega>", "proof (induction rule: alw.coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       scount P x = 0 \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          \\<not> P xs \\<and>\n          (scount P (stl xs) = 0 \\<or>\n           alw (\\<lambda>xs. \\<not> P xs) (stl xs))", "case (alw \\<omega>)"], ["proof (state)\nthis:\n  scount P \\<omega> = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       scount P x = 0 \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          \\<not> P xs \\<and>\n          (scount P (stl xs) = 0 \\<or>\n           alw (\\<lambda>xs. \\<not> P xs) (stl xs))", "with scount.simps[of P \\<omega>]"], ["proof (chain)\npicking this:\n  scount P \\<omega> =\n  (if P \\<omega> then eSuc (scount P (stl \\<omega>))\n   else scount P (stl \\<omega>))\n  scount P \\<omega> = 0", "show ?case"], ["proof (prove)\nusing this:\n  scount P \\<omega> =\n  (if P \\<omega> then eSuc (scount P (stl \\<omega>))\n   else scount P (stl \\<omega>))\n  scount P \\<omega> = 0\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       \\<omega> = xs \\<and>\n       \\<not> P xs \\<and>\n       (scount P (stl xs) = 0 \\<or> alw (\\<lambda>xs. \\<not> P xs) (stl xs))", "by (simp split: if_split_asm)"], ["proof (state)\nthis:\n  \\<exists>xs.\n     \\<omega> = xs \\<and>\n     \\<not> P xs \\<and>\n     (scount P (stl xs) = 0 \\<or> alw (\\<lambda>xs. \\<not> P xs) (stl xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scount_eq_0_iff: \"scount P \\<omega> = 0 \\<longleftrightarrow> alw (not P) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (scount P \\<omega> = 0) = alw (\\<lambda>xs. \\<not> P xs) \\<omega>", "by (metis scount_eq_0D scount_eq_0I)"], ["", "lemma\n  assumes \"ev (alw (not P)) \\<omega>\"\n  shows scount_eq_card: \"scount P \\<omega> = enat (card {i. P (sdrop i \\<omega>)})\"\n    and ev_alw_not_HLD_finite: \"finite {i. P (sdrop i \\<omega>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scount P \\<omega> = enat (card {i. P (sdrop i \\<omega>)}) &&&\n    finite {i. P (sdrop i \\<omega>)}", "using assms"], ["proof (prove)\nusing this:\n  ev (alw (\\<lambda>xs. \\<not> P xs)) \\<omega>\n\ngoal (1 subgoal):\n 1. scount P \\<omega> = enat (card {i. P (sdrop i \\<omega>)}) &&&\n    finite {i. P (sdrop i \\<omega>)}", "proof (induction \\<omega>)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       scount P xs = enat (card {i. P (sdrop i xs)})\n 2. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}\n 3. \\<And>xs.\n       \\<lbrakk>ev (alw (\\<lambda>xs. \\<not> P xs)) (stl xs);\n        scount P (stl xs) = enat (card {i. P (sdrop i (stl xs))});\n        finite {i. P (sdrop i (stl xs))}\\<rbrakk>\n       \\<Longrightarrow> scount P xs = enat (card {i. P (sdrop i xs)})\n 4. \\<And>xs.\n       \\<lbrakk>ev (alw (\\<lambda>xs. \\<not> P xs)) (stl xs);\n        scount P (stl xs) = enat (card {i. P (sdrop i (stl xs))});\n        finite {i. P (sdrop i (stl xs))}\\<rbrakk>\n       \\<Longrightarrow> finite {i. P (sdrop i xs)}", "case (step \\<omega>)"], ["proof (state)\nthis:\n  ev (alw (\\<lambda>xs. \\<not> P xs)) (stl \\<omega>)\n  scount P (stl \\<omega>) = enat (card {i. P (sdrop i (stl \\<omega>))})\n  finite {i. P (sdrop i (stl \\<omega>))}\n\ngoal (4 subgoals):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       scount P xs = enat (card {i. P (sdrop i xs)})\n 2. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}\n 3. \\<And>xs.\n       \\<lbrakk>ev (alw (\\<lambda>xs. \\<not> P xs)) (stl xs);\n        scount P (stl xs) = enat (card {i. P (sdrop i (stl xs))});\n        finite {i. P (sdrop i (stl xs))}\\<rbrakk>\n       \\<Longrightarrow> scount P xs = enat (card {i. P (sdrop i xs)})\n 4. \\<And>xs.\n       \\<lbrakk>ev (alw (\\<lambda>xs. \\<not> P xs)) (stl xs);\n        scount P (stl xs) = enat (card {i. P (sdrop i (stl xs))});\n        finite {i. P (sdrop i (stl xs))}\\<rbrakk>\n       \\<Longrightarrow> finite {i. P (sdrop i xs)}", "have eq: \"{i. P (sdrop i \\<omega>)} = (if P \\<omega> then {0} else {}) \\<union> (Suc ` {i. P (sdrop i (stl \\<omega>))})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. P (sdrop i \\<omega>)} =\n    (if P \\<omega> then {0} else {}) \\<union>\n    Suc ` {i. P (sdrop i (stl \\<omega>))}", "apply (intro set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> {i. P (sdrop i \\<omega>)}) =\n       (x \\<in> (if P \\<omega> then {0} else {}) \\<union>\n                Suc ` {i. P (sdrop i (stl \\<omega>))})", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x = 0 \\<Longrightarrow>\n       (x \\<in> {i. P (sdrop i \\<omega>)}) =\n       (x \\<in> (if P \\<omega> then {0} else {}) \\<union>\n                Suc ` {i. P (sdrop i (stl \\<omega>))})\n 2. \\<And>x nat.\n       x = Suc nat \\<Longrightarrow>\n       (x \\<in> {i. P (sdrop i \\<omega>)}) =\n       (x \\<in> (if P \\<omega> then {0} else {}) \\<union>\n                Suc ` {i. P (sdrop i (stl \\<omega>))})", "apply (auto simp: image_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {i. P (sdrop i \\<omega>)} =\n  (if P \\<omega> then {0} else {}) \\<union>\n  Suc ` {i. P (sdrop i (stl \\<omega>))}\n\ngoal (4 subgoals):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       scount P xs = enat (card {i. P (sdrop i xs)})\n 2. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}\n 3. \\<And>xs.\n       \\<lbrakk>ev (alw (\\<lambda>xs. \\<not> P xs)) (stl xs);\n        scount P (stl xs) = enat (card {i. P (sdrop i (stl xs))});\n        finite {i. P (sdrop i (stl xs))}\\<rbrakk>\n       \\<Longrightarrow> scount P xs = enat (card {i. P (sdrop i xs)})\n 4. \\<And>xs.\n       \\<lbrakk>ev (alw (\\<lambda>xs. \\<not> P xs)) (stl xs);\n        scount P (stl xs) = enat (card {i. P (sdrop i (stl xs))});\n        finite {i. P (sdrop i (stl xs))}\\<rbrakk>\n       \\<Longrightarrow> finite {i. P (sdrop i xs)}", "{"], ["proof (state)\nthis:\n  {i. P (sdrop i \\<omega>)} =\n  (if P \\<omega> then {0} else {}) \\<union>\n  Suc ` {i. P (sdrop i (stl \\<omega>))}\n\ngoal (4 subgoals):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       scount P xs = enat (card {i. P (sdrop i xs)})\n 2. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}\n 3. \\<And>xs.\n       \\<lbrakk>ev (alw (\\<lambda>xs. \\<not> P xs)) (stl xs);\n        scount P (stl xs) = enat (card {i. P (sdrop i (stl xs))});\n        finite {i. P (sdrop i (stl xs))}\\<rbrakk>\n       \\<Longrightarrow> scount P xs = enat (card {i. P (sdrop i xs)})\n 4. \\<And>xs.\n       \\<lbrakk>ev (alw (\\<lambda>xs. \\<not> P xs)) (stl xs);\n        scount P (stl xs) = enat (card {i. P (sdrop i (stl xs))});\n        finite {i. P (sdrop i (stl xs))}\\<rbrakk>\n       \\<Longrightarrow> finite {i. P (sdrop i xs)}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       scount P xs = enat (card {i. P (sdrop i xs)})\n 2. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}\n 3. \\<And>xs.\n       \\<lbrakk>ev (alw (\\<lambda>xs. \\<not> P xs)) (stl xs);\n        scount P (stl xs) = enat (card {i. P (sdrop i (stl xs))});\n        finite {i. P (sdrop i (stl xs))}\\<rbrakk>\n       \\<Longrightarrow> scount P xs = enat (card {i. P (sdrop i xs)})\n 4. \\<And>xs.\n       \\<lbrakk>ev (alw (\\<lambda>xs. \\<not> P xs)) (stl xs);\n        scount P (stl xs) = enat (card {i. P (sdrop i (stl xs))});\n        finite {i. P (sdrop i (stl xs))}\\<rbrakk>\n       \\<Longrightarrow> finite {i. P (sdrop i xs)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. scount P \\<omega> = enat (card {i. P (sdrop i \\<omega>)})", "using step"], ["proof (prove)\nusing this:\n  ev (alw (\\<lambda>xs. \\<not> P xs)) (stl \\<omega>)\n  scount P (stl \\<omega>) = enat (card {i. P (sdrop i (stl \\<omega>))})\n  finite {i. P (sdrop i (stl \\<omega>))}\n\ngoal (1 subgoal):\n 1. scount P \\<omega> = enat (card {i. P (sdrop i \\<omega>)})", "unfolding eq"], ["proof (prove)\nusing this:\n  ev (alw (\\<lambda>xs. \\<not> P xs)) (stl \\<omega>)\n  scount P (stl \\<omega>) = enat (card {i. P (sdrop i (stl \\<omega>))})\n  finite {i. P (sdrop i (stl \\<omega>))}\n\ngoal (1 subgoal):\n 1. scount P \\<omega> =\n    enat\n     (card\n       ((if P \\<omega> then {0} else {}) \\<union>\n        Suc ` {i. P (sdrop i (stl \\<omega>))}))", "by (auto simp: scount_simps card_image zero_notin_Suc_image eSuc_enat)"], ["proof (state)\nthis:\n  scount P \\<omega> = enat (card {i. P (sdrop i \\<omega>)})\n\ngoal (3 subgoals):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       scount P xs = enat (card {i. P (sdrop i xs)})\n 2. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}\n 3. \\<And>xs.\n       \\<lbrakk>ev (alw (\\<lambda>xs. \\<not> P xs)) (stl xs);\n        scount P (stl xs) = enat (card {i. P (sdrop i (stl xs))});\n        finite {i. P (sdrop i (stl xs))}\\<rbrakk>\n       \\<Longrightarrow> finite {i. P (sdrop i xs)}", "}"], ["proof (state)\nthis:\n  scount P \\<omega> = enat (card {i. P (sdrop i \\<omega>)})\n\ngoal (3 subgoals):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       scount P xs = enat (card {i. P (sdrop i xs)})\n 2. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}\n 3. \\<And>xs.\n       \\<lbrakk>ev (alw (\\<lambda>xs. \\<not> P xs)) (stl xs);\n        scount P (stl xs) = enat (card {i. P (sdrop i (stl xs))});\n        finite {i. P (sdrop i (stl xs))}\\<rbrakk>\n       \\<Longrightarrow> finite {i. P (sdrop i xs)}", "{"], ["proof (state)\nthis:\n  scount P \\<omega> = enat (card {i. P (sdrop i \\<omega>)})\n\ngoal (3 subgoals):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       scount P xs = enat (card {i. P (sdrop i xs)})\n 2. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}\n 3. \\<And>xs.\n       \\<lbrakk>ev (alw (\\<lambda>xs. \\<not> P xs)) (stl xs);\n        scount P (stl xs) = enat (card {i. P (sdrop i (stl xs))});\n        finite {i. P (sdrop i (stl xs))}\\<rbrakk>\n       \\<Longrightarrow> finite {i. P (sdrop i xs)}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       scount P xs = enat (card {i. P (sdrop i xs)})\n 2. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}\n 3. \\<And>xs.\n       \\<lbrakk>ev (alw (\\<lambda>xs. \\<not> P xs)) (stl xs);\n        scount P (stl xs) = enat (card {i. P (sdrop i (stl xs))});\n        finite {i. P (sdrop i (stl xs))}\\<rbrakk>\n       \\<Longrightarrow> finite {i. P (sdrop i xs)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i. P (sdrop i \\<omega>)}", "using step"], ["proof (prove)\nusing this:\n  ev (alw (\\<lambda>xs. \\<not> P xs)) (stl \\<omega>)\n  scount P (stl \\<omega>) = enat (card {i. P (sdrop i (stl \\<omega>))})\n  finite {i. P (sdrop i (stl \\<omega>))}\n\ngoal (1 subgoal):\n 1. finite {i. P (sdrop i \\<omega>)}", "unfolding eq"], ["proof (prove)\nusing this:\n  ev (alw (\\<lambda>xs. \\<not> P xs)) (stl \\<omega>)\n  scount P (stl \\<omega>) = enat (card {i. P (sdrop i (stl \\<omega>))})\n  finite {i. P (sdrop i (stl \\<omega>))}\n\ngoal (1 subgoal):\n 1. finite\n     ((if P \\<omega> then {0} else {}) \\<union>\n      Suc ` {i. P (sdrop i (stl \\<omega>))})", "by auto"], ["proof (state)\nthis:\n  finite {i. P (sdrop i \\<omega>)}\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       scount P xs = enat (card {i. P (sdrop i xs)})\n 2. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}", "}"], ["proof (state)\nthis:\n  finite {i. P (sdrop i \\<omega>)}\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       scount P xs = enat (card {i. P (sdrop i xs)})\n 2. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       scount P xs = enat (card {i. P (sdrop i xs)})\n 2. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}", "case (base \\<omega>)"], ["proof (state)\nthis:\n  alw (\\<lambda>xs. \\<not> P xs) \\<omega>\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       scount P xs = enat (card {i. P (sdrop i xs)})\n 2. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}", "then"], ["proof (chain)\npicking this:\n  alw (\\<lambda>xs. \\<not> P xs) \\<omega>", "have [simp]: \"{i. P (sdrop i \\<omega>)} = {}\""], ["proof (prove)\nusing this:\n  alw (\\<lambda>xs. \\<not> P xs) \\<omega>\n\ngoal (1 subgoal):\n 1. {i. P (sdrop i \\<omega>)} = {}", "by (simp add: not_HLD alw_iff_sdrop)"], ["proof (state)\nthis:\n  {i. P (sdrop i \\<omega>)} = {}\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       scount P xs = enat (card {i. P (sdrop i xs)})\n 2. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}", "{"], ["proof (state)\nthis:\n  {i. P (sdrop i \\<omega>)} = {}\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       scount P xs = enat (card {i. P (sdrop i xs)})\n 2. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       scount P xs = enat (card {i. P (sdrop i xs)})\n 2. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. scount P \\<omega> = enat (card {i. P (sdrop i \\<omega>)})", "using base"], ["proof (prove)\nusing this:\n  alw (\\<lambda>xs. \\<not> P xs) \\<omega>\n\ngoal (1 subgoal):\n 1. scount P \\<omega> = enat (card {i. P (sdrop i \\<omega>)})", "by (simp add: scount_eq_0I enat_0)"], ["proof (state)\nthis:\n  scount P \\<omega> = enat (card {i. P (sdrop i \\<omega>)})\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}", "}"], ["proof (state)\nthis:\n  scount P \\<omega> = enat (card {i. P (sdrop i \\<omega>)})\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}", "{"], ["proof (state)\nthis:\n  scount P \\<omega> = enat (card {i. P (sdrop i \\<omega>)})\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       alw (\\<lambda>xs. \\<not> P xs) xs \\<Longrightarrow>\n       finite {i. P (sdrop i xs)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i. P (sdrop i \\<omega>)}", "by simp"], ["proof (state)\nthis:\n  finite {i. P (sdrop i \\<omega>)}\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  finite {i. P (sdrop i \\<omega>)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scount_finite: \"ev (alw (not P)) \\<omega> \\<Longrightarrow> scount P \\<omega> < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (alw (\\<lambda>xs. \\<not> P xs)) \\<omega> \\<Longrightarrow>\n    scount P \\<omega> < \\<infinity>", "using scount_eq_card[of P \\<omega>]"], ["proof (prove)\nusing this:\n  ev (alw (\\<lambda>xs. \\<not> P xs)) \\<omega> \\<Longrightarrow>\n  scount P \\<omega> = enat (card {i. P (sdrop i \\<omega>)})\n\ngoal (1 subgoal):\n 1. ev (alw (\\<lambda>xs. \\<not> P xs)) \\<omega> \\<Longrightarrow>\n    scount P \\<omega> < \\<infinity>", "by auto"], ["", "lemma scount_infinite:\n  \"alw (ev P) \\<omega> \\<Longrightarrow> scount P \\<omega> = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (ev P) \\<omega> \\<Longrightarrow> scount P \\<omega> = \\<infinity>", "proof (coinduction arbitrary: \\<omega> rule: enat_coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       alw (ev P) \\<omega> \\<Longrightarrow>\n       (scount P \\<omega> = 0) = (\\<infinity> = 0) \\<and>\n       (scount P \\<omega> \\<noteq> 0 \\<longrightarrow>\n        \\<infinity> \\<noteq> 0 \\<longrightarrow>\n        (\\<exists>\\<omega>'.\n            epred (scount P \\<omega>) = scount P \\<omega>' \\<and>\n            epred \\<infinity> = \\<infinity> \\<and>\n            alw (ev P) \\<omega>') \\<or>\n        epred (scount P \\<omega>) = epred \\<infinity>)", "case (Eq_enat \\<omega>)"], ["proof (state)\nthis:\n  alw (ev P) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       alw (ev P) \\<omega> \\<Longrightarrow>\n       (scount P \\<omega> = 0) = (\\<infinity> = 0) \\<and>\n       (scount P \\<omega> \\<noteq> 0 \\<longrightarrow>\n        \\<infinity> \\<noteq> 0 \\<longrightarrow>\n        (\\<exists>\\<omega>'.\n            epred (scount P \\<omega>) = scount P \\<omega>' \\<and>\n            epred \\<infinity> = \\<infinity> \\<and>\n            alw (ev P) \\<omega>') \\<or>\n        epred (scount P \\<omega>) = epred \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  alw (ev P) \\<omega>", "have \"ev P \\<omega>\" \"alw (ev P) \\<omega>\""], ["proof (prove)\nusing this:\n  alw (ev P) \\<omega>\n\ngoal (1 subgoal):\n 1. ev P \\<omega> &&& alw (ev P) \\<omega>", "by auto"], ["proof (state)\nthis:\n  ev P \\<omega>\n  alw (ev P) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       alw (ev P) \\<omega> \\<Longrightarrow>\n       (scount P \\<omega> = 0) = (\\<infinity> = 0) \\<and>\n       (scount P \\<omega> \\<noteq> 0 \\<longrightarrow>\n        \\<infinity> \\<noteq> 0 \\<longrightarrow>\n        (\\<exists>\\<omega>'.\n            epred (scount P \\<omega>) = scount P \\<omega>' \\<and>\n            epred \\<infinity> = \\<infinity> \\<and>\n            alw (ev P) \\<omega>') \\<or>\n        epred (scount P \\<omega>) = epred \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  ev P \\<omega>\n  alw (ev P) \\<omega>", "show ?case"], ["proof (prove)\nusing this:\n  ev P \\<omega>\n  alw (ev P) \\<omega>\n\ngoal (1 subgoal):\n 1. (scount P \\<omega> = 0) = (\\<infinity> = 0) \\<and>\n    (scount P \\<omega> \\<noteq> 0 \\<longrightarrow>\n     \\<infinity> \\<noteq> 0 \\<longrightarrow>\n     (\\<exists>\\<omega>.\n         epred (scount P \\<omega>) = scount P \\<omega> \\<and>\n         epred \\<infinity> = \\<infinity> \\<and> alw (ev P) \\<omega>) \\<or>\n     epred (scount P \\<omega>) = epred \\<infinity>)", "by (induction rule: ev_induct_strong) (auto simp add: scount_simps)"], ["proof (state)\nthis:\n  (scount P \\<omega> = 0) = (\\<infinity> = 0) \\<and>\n  (scount P \\<omega> \\<noteq> 0 \\<longrightarrow>\n   \\<infinity> \\<noteq> 0 \\<longrightarrow>\n   (\\<exists>\\<omega>.\n       epred (scount P \\<omega>) = scount P \\<omega> \\<and>\n       epred \\<infinity> = \\<infinity> \\<and> alw (ev P) \\<omega>) \\<or>\n   epred (scount P \\<omega>) = epred \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scount_infinite_iff: \"scount P \\<omega> = \\<infinity> \\<longleftrightarrow> alw (ev P) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (scount P \\<omega> = \\<infinity>) = alw (ev P) \\<omega>", "by (metis enat_ord_simps(4) not_alw_not scount_finite scount_infinite)"], ["", "lemma scount_eq:\n  \"scount P \\<omega> = (if alw (ev P) \\<omega> then \\<infinity> else enat (card {i. P (sdrop i \\<omega>)}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scount P \\<omega> =\n    (if alw (ev P) \\<omega> then \\<infinity>\n     else enat (card {i. P (sdrop i \\<omega>)}))", "by (auto simp: scount_infinite_iff scount_eq_card not_alw_iff not_ev_iff)"], ["", "subsection \\<open> First index of an element \\<close>"], ["", "partial_function (gfp) sfirst :: \"('s stream \\<Rightarrow> bool) \\<Rightarrow> 's stream \\<Rightarrow> enat\" where\n  \"sfirst P \\<omega> = (if P \\<omega> then 0 else eSuc (sfirst P (stl \\<omega>)))\""], ["", "lemma sfirst_eq_0: \"sfirst P \\<omega> = 0 \\<longleftrightarrow> P \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sfirst P \\<omega> = 0) = P \\<omega>", "by (subst sfirst.simps) auto"], ["", "lemma sfirst_0[simp]: \"P \\<omega> \\<Longrightarrow> sfirst P \\<omega> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<omega> \\<Longrightarrow> sfirst P \\<omega> = 0", "by (subst sfirst.simps) auto"], ["", "lemma sfirst_eSuc[simp]: \"\\<not> P \\<omega> \\<Longrightarrow> sfirst P \\<omega> = eSuc (sfirst P (stl \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P \\<omega> \\<Longrightarrow>\n    sfirst P \\<omega> = eSuc (sfirst P (stl \\<omega>))", "by (subst sfirst.simps) auto"], ["", "lemma less_sfirstD:\n  fixes n :: nat\n  assumes \"enat n < sfirst P \\<omega>\" shows \"\\<not> P (sdrop n \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P (sdrop n \\<omega>)", "using assms"], ["proof (prove)\nusing this:\n  enat n < sfirst P \\<omega>\n\ngoal (1 subgoal):\n 1. \\<not> P (sdrop n \\<omega>)", "proof (induction n arbitrary: \\<omega>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       enat 0 < sfirst P \\<omega> \\<Longrightarrow>\n       \\<not> P (sdrop 0 \\<omega>)\n 2. \\<And>n \\<omega>.\n       \\<lbrakk>\\<And>\\<omega>.\n                   enat n < sfirst P \\<omega> \\<Longrightarrow>\n                   \\<not> P (sdrop n \\<omega>);\n        enat (Suc n) < sfirst P \\<omega>\\<rbrakk>\n       \\<Longrightarrow> \\<not> P (sdrop (Suc n) \\<omega>)", "case (Suc n)"], ["proof (state)\nthis:\n  enat n < sfirst P ?\\<omega> \\<Longrightarrow> \\<not> P (sdrop n ?\\<omega>)\n  enat (Suc n) < sfirst P \\<omega>\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       enat 0 < sfirst P \\<omega> \\<Longrightarrow>\n       \\<not> P (sdrop 0 \\<omega>)\n 2. \\<And>n \\<omega>.\n       \\<lbrakk>\\<And>\\<omega>.\n                   enat n < sfirst P \\<omega> \\<Longrightarrow>\n                   \\<not> P (sdrop n \\<omega>);\n        enat (Suc n) < sfirst P \\<omega>\\<rbrakk>\n       \\<Longrightarrow> \\<not> P (sdrop (Suc n) \\<omega>)", "then"], ["proof (chain)\npicking this:\n  enat n < sfirst P ?\\<omega> \\<Longrightarrow> \\<not> P (sdrop n ?\\<omega>)\n  enat (Suc n) < sfirst P \\<omega>", "show ?case"], ["proof (prove)\nusing this:\n  enat n < sfirst P ?\\<omega> \\<Longrightarrow> \\<not> P (sdrop n ?\\<omega>)\n  enat (Suc n) < sfirst P \\<omega>\n\ngoal (1 subgoal):\n 1. \\<not> P (sdrop (Suc n) \\<omega>)", "by (auto simp: sfirst.simps[of _ \\<omega>] eSuc_enat[symmetric] split: if_split_asm)"], ["proof (state)\nthis:\n  \\<not> P (sdrop (Suc n) \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       enat 0 < sfirst P \\<omega> \\<Longrightarrow>\n       \\<not> P (sdrop 0 \\<omega>)", "qed (simp add: enat_0 sfirst_eq_0)"], ["", "lemma sfirst_finite: \"sfirst P \\<omega> < \\<infinity> \\<longleftrightarrow> ev P \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sfirst P \\<omega> < \\<infinity>) = ev P \\<omega>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. sfirst P \\<omega> < \\<infinity> \\<Longrightarrow> ev P \\<omega>\n 2. ev P \\<omega> \\<Longrightarrow> sfirst P \\<omega> < \\<infinity>", "assume \"sfirst P \\<omega> < \\<infinity>\""], ["proof (state)\nthis:\n  sfirst P \\<omega> < \\<infinity>\n\ngoal (2 subgoals):\n 1. sfirst P \\<omega> < \\<infinity> \\<Longrightarrow> ev P \\<omega>\n 2. ev P \\<omega> \\<Longrightarrow> sfirst P \\<omega> < \\<infinity>", "then"], ["proof (chain)\npicking this:\n  sfirst P \\<omega> < \\<infinity>", "obtain n where \"sfirst P \\<omega> = enat n\""], ["proof (prove)\nusing this:\n  sfirst P \\<omega> < \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        sfirst P \\<omega> = enat n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  sfirst P \\<omega> = enat n\n\ngoal (2 subgoals):\n 1. sfirst P \\<omega> < \\<infinity> \\<Longrightarrow> ev P \\<omega>\n 2. ev P \\<omega> \\<Longrightarrow> sfirst P \\<omega> < \\<infinity>", "then"], ["proof (chain)\npicking this:\n  sfirst P \\<omega> = enat n", "show \"ev P \\<omega>\""], ["proof (prove)\nusing this:\n  sfirst P \\<omega> = enat n\n\ngoal (1 subgoal):\n 1. ev P \\<omega>", "proof (induction n arbitrary: \\<omega>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       sfirst P \\<omega> = enat 0 \\<Longrightarrow> ev P \\<omega>\n 2. \\<And>n \\<omega>.\n       \\<lbrakk>\\<And>\\<omega>.\n                   sfirst P \\<omega> = enat n \\<Longrightarrow>\n                   ev P \\<omega>;\n        sfirst P \\<omega> = enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> ev P \\<omega>", "case (Suc n)"], ["proof (state)\nthis:\n  sfirst P ?\\<omega> = enat n \\<Longrightarrow> ev P ?\\<omega>\n  sfirst P \\<omega> = enat (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       sfirst P \\<omega> = enat 0 \\<Longrightarrow> ev P \\<omega>\n 2. \\<And>n \\<omega>.\n       \\<lbrakk>\\<And>\\<omega>.\n                   sfirst P \\<omega> = enat n \\<Longrightarrow>\n                   ev P \\<omega>;\n        sfirst P \\<omega> = enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> ev P \\<omega>", "then"], ["proof (chain)\npicking this:\n  sfirst P ?\\<omega> = enat n \\<Longrightarrow> ev P ?\\<omega>\n  sfirst P \\<omega> = enat (Suc n)", "show ?case"], ["proof (prove)\nusing this:\n  sfirst P ?\\<omega> = enat n \\<Longrightarrow> ev P ?\\<omega>\n  sfirst P \\<omega> = enat (Suc n)\n\ngoal (1 subgoal):\n 1. ev P \\<omega>", "by (auto simp add: eSuc_enat[symmetric] sfirst.simps[of P \\<omega>] split: if_split_asm)"], ["proof (state)\nthis:\n  ev P \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       sfirst P \\<omega> = enat 0 \\<Longrightarrow> ev P \\<omega>", "qed (auto simp add: enat_0 sfirst_eq_0)"], ["proof (state)\nthis:\n  ev P \\<omega>\n\ngoal (1 subgoal):\n 1. ev P \\<omega> \\<Longrightarrow> sfirst P \\<omega> < \\<infinity>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ev P \\<omega> \\<Longrightarrow> sfirst P \\<omega> < \\<infinity>", "assume \"ev P \\<omega>\""], ["proof (state)\nthis:\n  ev P \\<omega>\n\ngoal (1 subgoal):\n 1. ev P \\<omega> \\<Longrightarrow> sfirst P \\<omega> < \\<infinity>", "then"], ["proof (chain)\npicking this:\n  ev P \\<omega>", "show \"sfirst P \\<omega> < \\<infinity>\""], ["proof (prove)\nusing this:\n  ev P \\<omega>\n\ngoal (1 subgoal):\n 1. sfirst P \\<omega> < \\<infinity>", "by (induction rule: ev_induct_strong) (auto simp: eSuc_enat)"], ["proof (state)\nthis:\n  sfirst P \\<omega> < \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sfirst_Stream: \"sfirst P (s ## x) = (if P (s ## x) then 0 else eSuc (sfirst P x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfirst P (s ## x) = (if P (s ## x) then 0 else eSuc (sfirst P x))", "by (subst sfirst.simps) (simp add: HLD_iff)"], ["", "lemma less_sfirst_iff: \"(not P until (alw P)) \\<omega> \\<Longrightarrow> enat n < sfirst P \\<omega> \\<longleftrightarrow> \\<not> P (sdrop n \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega> \\<Longrightarrow>\n    (enat n < sfirst P \\<omega>) = (\\<not> P (sdrop n \\<omega>))", "proof (induction n arbitrary: \\<omega>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega> \\<Longrightarrow>\n       (enat 0 < sfirst P \\<omega>) = (\\<not> P (sdrop 0 \\<omega>))\n 2. \\<And>n \\<omega>.\n       \\<lbrakk>\\<And>\\<omega>.\n                   ((\\<lambda>xs. \\<not> P xs) until alw P)\n                    \\<omega> \\<Longrightarrow>\n                   (enat n < sfirst P \\<omega>) =\n                   (\\<not> P (sdrop n \\<omega>));\n        ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (enat (Suc n) < sfirst P \\<omega>) =\n                         (\\<not> P (sdrop (Suc n) \\<omega>))", "case 0"], ["proof (state)\nthis:\n  ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega>\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega> \\<Longrightarrow>\n       (enat 0 < sfirst P \\<omega>) = (\\<not> P (sdrop 0 \\<omega>))\n 2. \\<And>n \\<omega>.\n       \\<lbrakk>\\<And>\\<omega>.\n                   ((\\<lambda>xs. \\<not> P xs) until alw P)\n                    \\<omega> \\<Longrightarrow>\n                   (enat n < sfirst P \\<omega>) =\n                   (\\<not> P (sdrop n \\<omega>));\n        ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (enat (Suc n) < sfirst P \\<omega>) =\n                         (\\<not> P (sdrop (Suc n) \\<omega>))", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega>", "show ?case"], ["proof (prove)\nusing this:\n  ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega>\n\ngoal (1 subgoal):\n 1. (enat 0 < sfirst P \\<omega>) = (\\<not> P (sdrop 0 \\<omega>))", "by (simp add: enat_0 sfirst_eq_0 HLD_iff)"], ["proof (state)\nthis:\n  (enat 0 < sfirst P \\<omega>) = (\\<not> P (sdrop 0 \\<omega>))\n\ngoal (1 subgoal):\n 1. \\<And>n \\<omega>.\n       \\<lbrakk>\\<And>\\<omega>.\n                   ((\\<lambda>xs. \\<not> P xs) until alw P)\n                    \\<omega> \\<Longrightarrow>\n                   (enat n < sfirst P \\<omega>) =\n                   (\\<not> P (sdrop n \\<omega>));\n        ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (enat (Suc n) < sfirst P \\<omega>) =\n                         (\\<not> P (sdrop (Suc n) \\<omega>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n \\<omega>.\n       \\<lbrakk>\\<And>\\<omega>.\n                   ((\\<lambda>xs. \\<not> P xs) until alw P)\n                    \\<omega> \\<Longrightarrow>\n                   (enat n < sfirst P \\<omega>) =\n                   (\\<not> P (sdrop n \\<omega>));\n        ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (enat (Suc n) < sfirst P \\<omega>) =\n                         (\\<not> P (sdrop (Suc n) \\<omega>))", "case (Suc n)"], ["proof (state)\nthis:\n  ((\\<lambda>xs. \\<not> P xs) until alw P) ?\\<omega> \\<Longrightarrow>\n  (enat n < sfirst P ?\\<omega>) = (\\<not> P (sdrop n ?\\<omega>))\n  ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>n \\<omega>.\n       \\<lbrakk>\\<And>\\<omega>.\n                   ((\\<lambda>xs. \\<not> P xs) until alw P)\n                    \\<omega> \\<Longrightarrow>\n                   (enat n < sfirst P \\<omega>) =\n                   (\\<not> P (sdrop n \\<omega>));\n        ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (enat (Suc n) < sfirst P \\<omega>) =\n                         (\\<not> P (sdrop (Suc n) \\<omega>))", "from Suc.prems"], ["proof (chain)\npicking this:\n  ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega>", "have **: \"P \\<omega> \\<Longrightarrow> P (stl \\<omega>)\""], ["proof (prove)\nusing this:\n  ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega>\n\ngoal (1 subgoal):\n 1. P \\<omega> \\<Longrightarrow> P (stl \\<omega>)", "by (auto elim: UNTIL.cases)"], ["proof (state)\nthis:\n  P \\<omega> \\<Longrightarrow> P (stl \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>n \\<omega>.\n       \\<lbrakk>\\<And>\\<omega>.\n                   ((\\<lambda>xs. \\<not> P xs) until alw P)\n                    \\<omega> \\<Longrightarrow>\n                   (enat n < sfirst P \\<omega>) =\n                   (\\<not> P (sdrop n \\<omega>));\n        ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (enat (Suc n) < sfirst P \\<omega>) =\n                         (\\<not> P (sdrop (Suc n) \\<omega>))", "have *: \"\\<not> P (sdrop n (stl \\<omega>)) \\<longleftrightarrow> enat n < sfirst P (stl \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> P (sdrop n (stl \\<omega>))) = (enat n < sfirst P (stl \\<omega>))", "using Suc.prems"], ["proof (prove)\nusing this:\n  ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega>\n\ngoal (1 subgoal):\n 1. (\\<not> P (sdrop n (stl \\<omega>))) = (enat n < sfirst P (stl \\<omega>))", "by (intro Suc.IH[symmetric]) (auto intro: UNTIL.intros elim: UNTIL.cases)"], ["proof (state)\nthis:\n  (\\<not> P (sdrop n (stl \\<omega>))) = (enat n < sfirst P (stl \\<omega>))\n\ngoal (1 subgoal):\n 1. \\<And>n \\<omega>.\n       \\<lbrakk>\\<And>\\<omega>.\n                   ((\\<lambda>xs. \\<not> P xs) until alw P)\n                    \\<omega> \\<Longrightarrow>\n                   (enat n < sfirst P \\<omega>) =\n                   (\\<not> P (sdrop n \\<omega>));\n        ((\\<lambda>xs. \\<not> P xs) until alw P) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (enat (Suc n) < sfirst P \\<omega>) =\n                         (\\<not> P (sdrop (Suc n) \\<omega>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (enat (Suc n) < sfirst P \\<omega>) = (\\<not> P (sdrop (Suc n) \\<omega>))", "unfolding sdrop.simps *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (enat (Suc n) < sfirst P \\<omega>) = (enat n < sfirst P (stl \\<omega>))", "by (cases \"P \\<omega>\") (simp_all add: ** eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  (enat (Suc n) < sfirst P \\<omega>) = (\\<not> P (sdrop (Suc n) \\<omega>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sfirst_eq_Inf: \"sfirst P \\<omega> = Inf {enat i | i. P (sdrop i \\<omega>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfirst P \\<omega> = \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)}", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. sfirst P \\<omega> \\<le> \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)}\n 2. \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)} \\<le> sfirst P \\<omega>", "show \"sfirst P \\<omega> \\<le> \\<Sqinter>{enat i |i. P (sdrop i \\<omega>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfirst P \\<omega> \\<le> \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)}", "proof (safe intro!: Inf_greatest)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       P (sdrop i \\<omega>) \\<Longrightarrow> sfirst P \\<omega> \\<le> enat i", "fix \\<omega> i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       P (sdrop i \\<omega>) \\<Longrightarrow> sfirst P \\<omega> \\<le> enat i", "assume \"P (sdrop i \\<omega>)\""], ["proof (state)\nthis:\n  P (sdrop i \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       P (sdrop i \\<omega>) \\<Longrightarrow> sfirst P \\<omega> \\<le> enat i", "then"], ["proof (chain)\npicking this:\n  P (sdrop i \\<omega>)", "show \"sfirst P \\<omega> \\<le> enat i\""], ["proof (prove)\nusing this:\n  P (sdrop i \\<omega>)\n\ngoal (1 subgoal):\n 1. sfirst P \\<omega> \\<le> enat i", "proof (induction i arbitrary: \\<omega>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       P (sdrop 0 \\<omega>) \\<Longrightarrow> sfirst P \\<omega> \\<le> enat 0\n 2. \\<And>i \\<omega>.\n       \\<lbrakk>\\<And>\\<omega>.\n                   P (sdrop i \\<omega>) \\<Longrightarrow>\n                   sfirst P \\<omega> \\<le> enat i;\n        P (sdrop (Suc i) \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> sfirst P \\<omega> \\<le> enat (Suc i)", "case (Suc i)"], ["proof (state)\nthis:\n  P (sdrop i ?\\<omega>) \\<Longrightarrow> sfirst P ?\\<omega> \\<le> enat i\n  P (sdrop (Suc i) \\<omega>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       P (sdrop 0 \\<omega>) \\<Longrightarrow> sfirst P \\<omega> \\<le> enat 0\n 2. \\<And>i \\<omega>.\n       \\<lbrakk>\\<And>\\<omega>.\n                   P (sdrop i \\<omega>) \\<Longrightarrow>\n                   sfirst P \\<omega> \\<le> enat i;\n        P (sdrop (Suc i) \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> sfirst P \\<omega> \\<le> enat (Suc i)", "then"], ["proof (chain)\npicking this:\n  P (sdrop i ?\\<omega>) \\<Longrightarrow> sfirst P ?\\<omega> \\<le> enat i\n  P (sdrop (Suc i) \\<omega>)", "show ?case"], ["proof (prove)\nusing this:\n  P (sdrop i ?\\<omega>) \\<Longrightarrow> sfirst P ?\\<omega> \\<le> enat i\n  P (sdrop (Suc i) \\<omega>)\n\ngoal (1 subgoal):\n 1. sfirst P \\<omega> \\<le> enat (Suc i)", "by (auto simp add: sfirst.simps[of P \\<omega>] eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  sfirst P \\<omega> \\<le> enat (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       P (sdrop 0 \\<omega>) \\<Longrightarrow> sfirst P \\<omega> \\<le> enat 0", "qed auto"], ["proof (state)\nthis:\n  sfirst P \\<omega> \\<le> enat i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sfirst P \\<omega> \\<le> \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)}\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)} \\<le> sfirst P \\<omega>", "show \"\\<Sqinter>{enat i |i. P (sdrop i \\<omega>)} \\<le> sfirst P \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)} \\<le> sfirst P \\<omega>", "proof (induction arbitrary: \\<omega> rule: sfirst.fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. gfp.admissible\n     (\\<lambda>Pa.\n         \\<forall>x.\n            \\<Sqinter> {enat i |i. P (sdrop i x)} \\<le> curry Pa P x)\n 2. \\<And>\\<omega>.\n       \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)} \\<le> \\<Sqinter> {}\n 3. \\<And>f \\<omega>.\n       (\\<And>\\<omega>.\n           \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)}\n           \\<le> f P \\<omega>) \\<Longrightarrow>\n       \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)}\n       \\<le> (if P \\<omega> then 0 else eSuc (f P (stl \\<omega>)))", "case (3 f)"], ["proof (state)\nthis:\n  \\<Sqinter> {enat i |i. P (sdrop i ?\\<omega>)} \\<le> f P ?\\<omega>\n\ngoal (3 subgoals):\n 1. gfp.admissible\n     (\\<lambda>Pa.\n         \\<forall>x.\n            \\<Sqinter> {enat i |i. P (sdrop i x)} \\<le> curry Pa P x)\n 2. \\<And>\\<omega>.\n       \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)} \\<le> \\<Sqinter> {}\n 3. \\<And>f \\<omega>.\n       (\\<And>\\<omega>.\n           \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)}\n           \\<le> f P \\<omega>) \\<Longrightarrow>\n       \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)}\n       \\<le> (if P \\<omega> then 0 else eSuc (f P (stl \\<omega>)))", "have \"{enat i |i. P (sdrop i \\<omega>)} = (if P \\<omega> then {0} else {}) \\<union> eSuc ` {enat i |i. P (sdrop i (stl \\<omega>))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {enat i |i. P (sdrop i \\<omega>)} =\n    (if P \\<omega> then {0} else {}) \\<union>\n    eSuc ` {enat i |i. P (sdrop i (stl \\<omega>))}", "apply (intro set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> {enat i |i. P (sdrop i \\<omega>)}) =\n       (x \\<in> (if P \\<omega> then {0} else {}) \\<union>\n                eSuc ` {enat i |i. P (sdrop i (stl \\<omega>))})", "apply (case_tac x rule: enat_coexhaust)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x = 0 \\<Longrightarrow>\n       (x \\<in> {enat i |i. P (sdrop i \\<omega>)}) =\n       (x \\<in> (if P \\<omega> then {0} else {}) \\<union>\n                eSuc ` {enat i |i. P (sdrop i (stl \\<omega>))})\n 2. \\<And>x n'.\n       x = eSuc n' \\<Longrightarrow>\n       (x \\<in> {enat i |i. P (sdrop i \\<omega>)}) =\n       (x \\<in> (if P \\<omega> then {0} else {}) \\<union>\n                eSuc ` {enat i |i. P (sdrop i (stl \\<omega>))})", "apply (auto simp add: enat_0_iff image_iff eSuc_enat_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {enat i |i. P (sdrop i \\<omega>)} =\n  (if P \\<omega> then {0} else {}) \\<union>\n  eSuc ` {enat i |i. P (sdrop i (stl \\<omega>))}\n\ngoal (3 subgoals):\n 1. gfp.admissible\n     (\\<lambda>Pa.\n         \\<forall>x.\n            \\<Sqinter> {enat i |i. P (sdrop i x)} \\<le> curry Pa P x)\n 2. \\<And>\\<omega>.\n       \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)} \\<le> \\<Sqinter> {}\n 3. \\<And>f \\<omega>.\n       (\\<And>\\<omega>.\n           \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)}\n           \\<le> f P \\<omega>) \\<Longrightarrow>\n       \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)}\n       \\<le> (if P \\<omega> then 0 else eSuc (f P (stl \\<omega>)))", "with 3[of \"stl \\<omega>\"]"], ["proof (chain)\npicking this:\n  \\<Sqinter> {enat i |i. P (sdrop i (stl \\<omega>))}\n  \\<le> f P (stl \\<omega>)\n  {enat i |i. P (sdrop i \\<omega>)} =\n  (if P \\<omega> then {0} else {}) \\<union>\n  eSuc ` {enat i |i. P (sdrop i (stl \\<omega>))}", "show ?case"], ["proof (prove)\nusing this:\n  \\<Sqinter> {enat i |i. P (sdrop i (stl \\<omega>))}\n  \\<le> f P (stl \\<omega>)\n  {enat i |i. P (sdrop i \\<omega>)} =\n  (if P \\<omega> then {0} else {}) \\<union>\n  eSuc ` {enat i |i. P (sdrop i (stl \\<omega>))}\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)}\n    \\<le> (if P \\<omega> then 0 else eSuc (f P (stl \\<omega>)))", "by (auto simp: inf.absorb1 eSuc_Inf[symmetric])"], ["proof (state)\nthis:\n  \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)}\n  \\<le> (if P \\<omega> then 0 else eSuc (f P (stl \\<omega>)))\n\ngoal (2 subgoals):\n 1. gfp.admissible\n     (\\<lambda>Pa.\n         \\<forall>x.\n            \\<Sqinter> {enat i |i. P (sdrop i x)} \\<le> curry Pa P x)\n 2. \\<And>\\<omega>.\n       \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)} \\<le> \\<Sqinter> {}", "qed simp_all"], ["proof (state)\nthis:\n  \\<Sqinter> {enat i |i. P (sdrop i \\<omega>)} \\<le> sfirst P \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sfirst_eq_enat_iff: \"sfirst P \\<omega> = enat n \\<longleftrightarrow> ev_at P n \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sfirst P \\<omega> = enat n) = ev_at P n \\<omega>", "by (induction n arbitrary: \\<omega>)\n     (simp_all add: eSuc_enat[symmetric] sfirst.simps enat_0)"], ["", "subsection \\<open>\\<open>stakeWhile\\<close>\\<close>"], ["", "definition stakeWhile :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a stream \\<Rightarrow> 'a llist\"\nwhere \"stakeWhile P xs = ltakeWhile P (llist_of_stream xs)\""], ["", "lemma stakeWhile_SCons [simp]:\n  \"stakeWhile P (x ## xs) = (if P x then LCons x (stakeWhile P xs) else LNil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stakeWhile P (x ## xs) =\n    (if P x then LCons x (stakeWhile P xs) else LNil)", "by(simp add: stakeWhile_def LCons_llist_of_stream[symmetric] del: LCons_llist_of_stream)"], ["", "lemma lnull_stakeWhile [simp]: \"lnull (stakeWhile P xs) \\<longleftrightarrow> \\<not> P (shd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (stakeWhile P xs) = (\\<not> P (shd xs))", "by(simp add: stakeWhile_def)"], ["", "lemma lhd_stakeWhile [simp]: \"P (shd xs) \\<Longrightarrow> lhd (stakeWhile P xs) = shd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (shd xs) \\<Longrightarrow> lhd (stakeWhile P xs) = shd xs", "by(simp add: stakeWhile_def)"], ["", "lemma ltl_stakeWhile [simp]:\n  \"ltl (stakeWhile P xs) = (if P (shd xs) then stakeWhile P (stl xs) else LNil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (stakeWhile P xs) =\n    (if P (shd xs) then stakeWhile P (stl xs) else LNil)", "by(simp add: stakeWhile_def)"], ["", "lemma stakeWhile_K_False [simp]: \"stakeWhile (\\<lambda>_. False) xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stakeWhile (\\<lambda>_. False) xs = LNil", "by(simp add: stakeWhile_def)"], ["", "lemma stakeWhile_K_True [simp]: \"stakeWhile (\\<lambda>_. True) xs = llist_of_stream xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stakeWhile (\\<lambda>_. True) xs = llist_of_stream xs", "by(simp add: stakeWhile_def)"], ["", "lemma stakeWhile_smap: \"stakeWhile P (smap f xs) = lmap f (stakeWhile (P \\<circ> f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stakeWhile P (smap f xs) = lmap f (stakeWhile (P \\<circ> f) xs)", "by(simp add: stakeWhile_def ltakeWhile_lmap[symmetric] del: o_apply)"], ["", "lemma lfinite_stakeWhile [simp]: \"lfinite (stakeWhile P xs) \\<longleftrightarrow> (\\<exists>x\\<in>sset xs. \\<not> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (stakeWhile P xs) = (\\<exists>x\\<in>sset xs. \\<not> P x)", "by(simp add: stakeWhile_def lfinite_ltakeWhile)"], ["", "end"]]}