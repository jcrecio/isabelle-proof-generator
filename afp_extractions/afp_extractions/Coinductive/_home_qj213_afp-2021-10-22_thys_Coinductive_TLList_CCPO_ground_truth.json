{"file_name": "/home/qj213/afp-2021-10-22/thys/Coinductive/TLList_CCPO.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Coinductive", "problem_names": ["lemma Set_is_empty_parametric [transfer_rule]:\n  includes lifting_syntax\n  shows \"(rel_set A ===> (=)) Set.is_empty Set.is_empty\"", "lemma monotone_comp: \"\\<lbrakk> monotone orda ordb g; monotone ordb ordc f \\<rbrakk> \\<Longrightarrow> monotone orda ordc (f \\<circ> g)\"", "lemma cont_comp: \"\\<lbrakk> mcont luba orda lubb ordb g; cont lubb ordb lubc ordc f \\<rbrakk> \\<Longrightarrow> cont luba orda lubc ordc (f \\<circ> g)\"", "lemma mcont_comp: \"\\<lbrakk> mcont luba orda lubb ordb g; mcont lubb ordb lubc ordc f \\<rbrakk> \\<Longrightarrow> mcont luba orda lubc ordc (f \\<circ> g)\"", "lemma monotone_parametric [transfer_rule]:\n  assumes [transfer_rule]: \"bi_total A\"\n  shows \"((A ===> A ===> (=)) ===> (B ===> B ===> (=)) ===> (A ===> B) ===> (=)) monotone monotone\"", "lemma cont_parametric [transfer_rule]:\n  assumes [transfer_rule]: \"bi_total A\" \"bi_unique B\"\n  shows \"((rel_set A ===> A) ===> (A ===> A ===> (=)) ===> (rel_set B ===> B) ===> (B ===> B ===> (=)) ===> (A ===> B) ===> (=)) cont cont\"", "lemma mcont_parametric [transfer_rule]:\n  assumes [transfer_rule]: \"bi_total A\" \"bi_unique B\"\n  shows \"((rel_set A ===> A) ===> (A ===> A ===> (=)) ===> (rel_set B ===> B) ===> (B ===> B ===> (=)) ===> (A ===> B) ===> (=)) mcont mcont\"", "lemma (in ccpo) Sup_Un_less:\n  assumes chain: \"Complete_Partial_Order.chain (\\<le>) (A \\<union> B)\"\n  and AB: \"\\<forall>x\\<in>A. \\<exists>y\\<in>B. x \\<le> y\"\n  shows \"Sup (A \\<union> B) = Sup B\"", "lemma tllist_ord_simps [simp, code]: (* FIXME: does not work with transfer *)\n  shows tllist_ord_TNil_TNil: \"tllist_ord (TNil b1) (TNil b2) \\<longleftrightarrow> flat_ord b b1 b2\"\n  and tllist_ord_TNil_TCons: \"tllist_ord (TNil b1) (TCons y ys) \\<longleftrightarrow> b1 = b\"\n  and tllist_ord_TCons_TNil: \"tllist_ord (TCons x xs) (TNil b2) \\<longleftrightarrow> False\"\n  and tllist_ord_TCons_TCons: \"tllist_ord (TCons x xs) (TCons y ys) \\<longleftrightarrow> x = y \\<and> tllist_ord xs ys\"", "lemma tllist_ord_refl [simp]: \"tllist_ord xs xs\"", "lemma tllist_ord_antisym: \"\\<lbrakk> tllist_ord xs ys; tllist_ord ys xs \\<rbrakk> \\<Longrightarrow> xs = ys\"", "lemma tllist_ord_trans [trans]: \"\\<lbrakk> tllist_ord xs ys; tllist_ord ys zs \\<rbrakk> \\<Longrightarrow> tllist_ord xs zs\"", "lemma chain_tllist_llist_of_tllist:\n  assumes \"Complete_Partial_Order.chain tllist_ord A\"\n  shows \"Complete_Partial_Order.chain lprefix (llist_of_tllist ` A)\"", "lemma chain_tllist_terminal:\n  assumes \"Complete_Partial_Order.chain tllist_ord A\"\n  shows \"Complete_Partial_Order.chain (flat_ord b) {terminal xs|xs. xs \\<in> A \\<and> tfinite xs}\"", "lemma flat_ord_chain_finite:\n  assumes \"Complete_Partial_Order.chain (flat_ord b) A\"\n  shows \"finite A\"", "lemma tSup_empty [simp]: \"tSup {} = TNil b\"", "lemma is_TNil_tSup [simp]: \"is_TNil (tSup A) \\<longleftrightarrow> (\\<forall>x\\<in>A. is_TNil x)\"", "lemma chain_tllist_ord_tSup:\n  assumes chain: \"Complete_Partial_Order.chain tllist_ord A\"\n  and A: \"xs \\<in> A\"\n  shows \"tllist_ord xs (tSup A)\"", "lemma chain_tSup_tllist_ord:\n  assumes chain: \"Complete_Partial_Order.chain tllist_ord A\"\n  and lub: \"\\<And>xs'. xs' \\<in> A \\<Longrightarrow> tllist_ord xs' xs\"\n  shows \"tllist_ord (tSup A) xs\"", "lemma tllist_ord_ccpo [simp, cont_intro]:\n  \"class.ccpo tSup tllist_ord (mk_less tllist_ord)\"", "lemma tllist_ord_partial_function_definitions: \"partial_function_definitions tllist_ord tSup\"", "lemma admissible_mcont_is_TNil [THEN admissible_subst, cont_intro, simp]:\n  shows admissible_is_TNil: \"ccpo.admissible tSup tllist_ord is_TNil\"", "lemma terminal_tSup:\n  \"\\<forall>xs\\<in>Y. is_TNil xs \\<Longrightarrow> terminal (tSup Y) = flat_lub b (terminal ` Y)\"", "lemma thd_tSup:\n  \"\\<exists>xs \\<in> Y. \\<not> is_TNil xs\n  \\<Longrightarrow> thd (tSup Y) = (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\"", "lemma ex_TCons_raw_parametric:\n  includes lifting_syntax\n  shows \"(rel_set (rel_prod (llist_all2 A) B) ===> (=)) (\\<lambda>Y. \\<exists>(xs, b) \\<in> Y. \\<not> lnull xs) (\\<lambda>Y. \\<exists>(xs, b) \\<in> Y. \\<not> lnull xs)\"", "lemma ex_TCons_iff: \"ex_TCons Y \\<longleftrightarrow> (\\<exists>xs \\<in> Y. \\<not> is_TNil xs)\"", "lemma retain_TCons_raw_parametric:\n  includes lifting_syntax\n  shows \"(rel_set (rel_prod (llist_all2 A) B) ===> rel_set (rel_prod (llist_all2 A) B))\n    (\\<lambda>A. A \\<inter> {(xs, b). \\<not> lnull xs}) (\\<lambda>A. A \\<inter> {(xs, b). \\<not> lnull xs})\"", "lemma retain_TCons_conv: \"retain_TCons A = A \\<inter> {xs. \\<not> is_TNil xs}\"", "lemma ttl_tSup:\n  \"\\<lbrakk> Complete_Partial_Order.chain tllist_ord Y; \\<exists>xs \\<in> Y. \\<not> is_TNil xs \\<rbrakk>\n  \\<Longrightarrow> ttl (tSup Y) = tSup (ttl ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\"", "lemma tSup_TCons: \"A \\<noteq> {} \\<Longrightarrow> tSup (TCons x ` A) = TCons x (tSup A)\"", "lemma tllist_ord_terminalD:\n  \"\\<lbrakk> tllist_ord xs ys; is_TNil ys \\<rbrakk> \\<Longrightarrow> flat_ord b (terminal xs) (terminal ys)\"", "lemma tllist_ord_bot [simp]: \"tllist_ord (TNil b) xs\"", "lemma tllist_ord_ttlI:\n  \"tllist_ord xs ys \\<Longrightarrow> tllist_ord (ttl xs) (ttl ys)\"", "lemma not_is_TNil_conv: \"\\<not> is_TNil xs \\<longleftrightarrow> (\\<exists>x xs'. xs = TCons x xs')\"", "lemma mono_tllist_ord_case:\n  fixes bot\n  assumes mono: \"\\<And>x. monotone tllist_ord ord (\\<lambda>xs. f x xs (TCons x xs))\"\n  and ord: \"class.preorder ord (mk_less ord)\"\n  and bot: \"\\<And>x. ord (bot b) x\"\n  shows \"monotone tllist_ord ord (\\<lambda>xs. case xs of TNil b \\<Rightarrow> bot b | TCons x xs' \\<Rightarrow> f x xs' xs)\"", "lemma mcont_lprefix_case_aux:\n  fixes f bot ord\n  defines \"g \\<equiv> \\<lambda>xs. f (thd xs) (ttl xs) (TCons (thd xs) (ttl xs))\"\n  assumes mcont: \"\\<And>x. mcont tSup tllist_ord lub ord (\\<lambda>xs. f x xs (TCons x xs))\"\n  and ccpo: \"class.ccpo lub ord (mk_less ord)\"\n  and bot: \"\\<And>x. ord (bot b) x\"\n  and cont_bot: \"cont (flat_lub b) (flat_ord b) lub ord bot\"\n  shows \"mcont tSup tllist_ord lub ord (\\<lambda>xs. case xs of TNil b \\<Rightarrow> bot b | TCons x xs' \\<Rightarrow> f x xs' xs)\"\n  (is \"mcont _ _ _ _ ?f\")", "lemma cont_TNil [simp, cont_intro]: \"cont (flat_lub b) (flat_ord b) tSup tllist_ord TNil\"", "lemma monotone_TCons: \"monotone tllist_ord tllist_ord (TCons x)\"", "lemmas mono2mono_TCons[cont_intro] = monotone_TCons[THEN tllist.mono2mono]", "lemma mcont_TCons: \"mcont tSup tllist_ord tSup tllist_ord (TCons x)\"", "lemmas mcont2mcont_TCons[cont_intro] = mcont_TCons[THEN tllist.mcont2mcont]", "lemmas [transfer_rule del] = tllist_ord.transfer tSup.transfer", "lemmas [transfer_rule] = tllist_ord.transfer tSup.transfer", "lemma mono2mono_tset[THEN lfp.mono2mono, cont_intro]:\n  shows smonotone_tset: \"monotone tllist_ord (\\<subseteq>) tset\"", "lemma mcont2mcont_tset [THEN lfp.mcont2mcont, cont_intro]:\n  shows mcont_tset: \"mcont tSup tllist_ord Union (\\<subseteq>) tset\"", "lemma rel_fun_lift:\n  \"(\\<And>x. A (f x) (g x)) \\<Longrightarrow> ((=) ===> A) f g\"", "lemma tllist_ord_transfer [transfer_rule]:\n  \"((=) ===> pcr_tllist (=) (=) ===> pcr_tllist (=) (=) ===> (=))\n     (\\<lambda>b (xs1, b1) (xs2, b2). if lfinite xs1 then b1 = b \\<and> lprefix xs1 xs2 \\<or> xs1 = xs2 \\<and> flat_ord b b1 b2 else xs1 = xs2)\n     tllist_ord\"", "lemma tSup_transfer [transfer_rule]:\n  \"((=) ===> rel_set (pcr_tllist (=) (=)) ===> pcr_tllist (=) (=))\n     (\\<lambda>b A. (lSup (fst ` A), flat_lub b (snd ` (A \\<inter> {(xs, _). lfinite xs}))))\n     tSup\"", "lemma tllist_case_mono [partial_function_mono, cont_intro]: \n  assumes tnil: \"\\<And>b. monotone orda ordb (\\<lambda>f. tnil f b)\"\n  and tcons: \"\\<And>x xs. monotone orda ordb (\\<lambda>f. tcons f x xs)\"\n  shows \"monotone orda ordb (\\<lambda>f. case_tllist (tnil f) (tcons f) xs)\"", "lemma LCons_mono [partial_function_mono, cont_intro]:\n  \"mono_tllist A \\<Longrightarrow> mono_tllist (\\<lambda>f. TCons x (A f))\"", "lemma mono_tllist_lappendt2 [partial_function_mono]:\n  \"tllist_pf.mono_tllist b A \\<Longrightarrow> tllist_pf.mono_tllist b (\\<lambda>f. lappendt xs (A f))\"", "lemma mono_tllist_tappend2 [partial_function_mono]:\n  assumes \"\\<And>y. tllist_pf.mono_tllist b (C y)\"\n  shows \"tllist_pf.mono_tllist b (\\<lambda>f. tappend xs (\\<lambda>y. C y f))\""], "translations": [["", "lemma Set_is_empty_parametric [transfer_rule]:\n  includes lifting_syntax\n  shows \"(rel_set A ===> (=)) Set.is_empty Set.is_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (=)) Set.is_empty Set.is_empty", "by(auto simp add: rel_fun_def Set.is_empty_def dest: rel_setD1 rel_setD2)"], ["", "lemma monotone_comp: \"\\<lbrakk> monotone orda ordb g; monotone ordb ordc f \\<rbrakk> \\<Longrightarrow> monotone orda ordc (f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monotone orda ordb g; monotone ordb ordc f\\<rbrakk>\n    \\<Longrightarrow> monotone orda ordc (f \\<circ> g)", "by(rule monotoneI)(simp add: monotoneD)"], ["", "lemma cont_comp: \"\\<lbrakk> mcont luba orda lubb ordb g; cont lubb ordb lubc ordc f \\<rbrakk> \\<Longrightarrow> cont luba orda lubc ordc (f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mcont luba orda lubb ordb g;\n     cont lubb ordb lubc ordc f\\<rbrakk>\n    \\<Longrightarrow> cont luba orda lubc ordc (f \\<circ> g)", "apply(rule contI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>mcont luba orda lubb ordb g; cont lubb ordb lubc ordc f;\n        Complete_Partial_Order.chain orda Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (f \\<circ> g) (luba Y) = lubc ((f \\<circ> g) ` Y)", "apply(frule (2) mcont_contD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>mcont luba orda lubb ordb g; cont lubb ordb lubc ordc f;\n        Complete_Partial_Order.chain orda Y; Y \\<noteq> {};\n        g (luba Y) = lubb (g ` Y)\\<rbrakk>\n       \\<Longrightarrow> (f \\<circ> g) (luba Y) = lubc ((f \\<circ> g) ` Y)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>mcont luba orda lubb ordb g; cont lubb ordb lubc ordc f;\n        Complete_Partial_Order.chain orda Y; Y \\<noteq> {};\n        g (luba Y) = lubb (g ` Y)\\<rbrakk>\n       \\<Longrightarrow> f (lubb (g ` Y)) = lubc ((\\<lambda>x. f (g x)) ` Y)", "apply(drule (1) contD[OF _ chain_imageI])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Y x y.\n       \\<lbrakk>mcont luba orda lubb ordb g;\n        Complete_Partial_Order.chain orda Y; Y \\<noteq> {};\n        g (luba Y) = lubb (g ` Y); x \\<in> Y; y \\<in> Y; orda x y\\<rbrakk>\n       \\<Longrightarrow> ordb (?fa6 Y x) (?fa6 Y y)\n 2. \\<And>Y.\n       \\<lbrakk>mcont luba orda lubb ordb g;\n        Complete_Partial_Order.chain orda Y; Y \\<noteq> {};\n        g (luba Y) = lubb (g ` Y)\\<rbrakk>\n       \\<Longrightarrow> ?fa6 Y ` Y \\<noteq> {}\n 3. \\<And>Y.\n       \\<lbrakk>mcont luba orda lubb ordb g;\n        Complete_Partial_Order.chain orda Y; Y \\<noteq> {};\n        g (luba Y) = lubb (g ` Y);\n        f (lubb (?fa6 Y ` Y)) = lubc (f ` ?fa6 Y ` Y)\\<rbrakk>\n       \\<Longrightarrow> f (lubb (g ` Y)) = lubc ((\\<lambda>x. f (g x)) ` Y)", "apply(erule (1) mcont_monoD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>mcont luba orda lubb ordb g;\n        Complete_Partial_Order.chain orda Y; Y \\<noteq> {};\n        g (luba Y) = lubb (g ` Y)\\<rbrakk>\n       \\<Longrightarrow> g ` Y \\<noteq> {}\n 2. \\<And>Y.\n       \\<lbrakk>mcont luba orda lubb ordb g;\n        Complete_Partial_Order.chain orda Y; Y \\<noteq> {};\n        g (luba Y) = lubb (g ` Y);\n        f (lubb (g ` Y)) = lubc (f ` g ` Y)\\<rbrakk>\n       \\<Longrightarrow> f (lubb (g ` Y)) = lubc ((\\<lambda>x. f (g x)) ` Y)", "apply(simp_all add: image_image o_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mcont_comp: \"\\<lbrakk> mcont luba orda lubb ordb g; mcont lubb ordb lubc ordc f \\<rbrakk> \\<Longrightarrow> mcont luba orda lubc ordc (f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mcont luba orda lubb ordb g;\n     mcont lubb ordb lubc ordc f\\<rbrakk>\n    \\<Longrightarrow> mcont luba orda lubc ordc (f \\<circ> g)", "by(auto simp add: mcont_def intro: cont_comp monotone_comp)"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma monotone_parametric [transfer_rule]:\n  assumes [transfer_rule]: \"bi_total A\"\n  shows \"((A ===> A ===> (=)) ===> (B ===> B ===> (=)) ===> (A ===> B) ===> (=)) monotone monotone\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> (=)) ===> (B ===> B ===> (=)) ===> (A ===> B) ===> (=))\n     monotone monotone", "unfolding monotone_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> (=)) ===> (B ===> B ===> (=)) ===> (A ===> B) ===> (=))\n     (\\<lambda>orda ordb f.\n         \\<forall>x y. orda x y \\<longrightarrow> ordb (f x) (f y))\n     (\\<lambda>orda ordb f.\n         \\<forall>x y. orda x y \\<longrightarrow> ordb (f x) (f y))", "by transfer_prover"], ["", "lemma cont_parametric [transfer_rule]:\n  assumes [transfer_rule]: \"bi_total A\" \"bi_unique B\"\n  shows \"((rel_set A ===> A) ===> (A ===> A ===> (=)) ===> (rel_set B ===> B) ===> (B ===> B ===> (=)) ===> (A ===> B) ===> (=)) cont cont\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_set A ===> A) ===>\n     (A ===> A ===> (=)) ===>\n     (rel_set B ===> B) ===> (B ===> B ===> (=)) ===> (A ===> B) ===> (=))\n     cont cont", "unfolding cont_def[abs_def] Set.is_empty_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_set A ===> A) ===>\n     (A ===> A ===> (=)) ===>\n     (rel_set B ===> B) ===> (B ===> B ===> (=)) ===> (A ===> B) ===> (=))\n     (\\<lambda>luba orda lubb ordb f.\n         \\<forall>Y.\n            Complete_Partial_Order.chain orda Y \\<longrightarrow>\n            \\<not> Set.is_empty Y \\<longrightarrow>\n            f (luba Y) = lubb (f ` Y))\n     (\\<lambda>luba orda lubb ordb f.\n         \\<forall>Y.\n            Complete_Partial_Order.chain orda Y \\<longrightarrow>\n            \\<not> Set.is_empty Y \\<longrightarrow>\n            f (luba Y) = lubb (f ` Y))", "by transfer_prover"], ["", "lemma mcont_parametric [transfer_rule]:\n  assumes [transfer_rule]: \"bi_total A\" \"bi_unique B\"\n  shows \"((rel_set A ===> A) ===> (A ===> A ===> (=)) ===> (rel_set B ===> B) ===> (B ===> B ===> (=)) ===> (A ===> B) ===> (=)) mcont mcont\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_set A ===> A) ===>\n     (A ===> A ===> (=)) ===>\n     (rel_set B ===> B) ===> (B ===> B ===> (=)) ===> (A ===> B) ===> (=))\n     mcont mcont", "unfolding mcont_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_set A ===> A) ===>\n     (A ===> A ===> (=)) ===>\n     (rel_set B ===> B) ===> (B ===> B ===> (=)) ===> (A ===> B) ===> (=))\n     (\\<lambda>luba orda lubb ordb f.\n         monotone orda ordb f \\<and> cont luba orda lubb ordb f)\n     (\\<lambda>luba orda lubb ordb f.\n         monotone orda ordb f \\<and> cont luba orda lubb ordb f)", "by transfer_prover"], ["", "end"], ["", "lemma (in ccpo) Sup_Un_less:\n  assumes chain: \"Complete_Partial_Order.chain (\\<le>) (A \\<union> B)\"\n  and AB: \"\\<forall>x\\<in>A. \\<exists>y\\<in>B. x \\<le> y\"\n  shows \"Sup (A \\<union> B) = Sup B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (A \\<union> B) = \\<Squnion> B", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Squnion> (A \\<union> B) \\<le> \\<Squnion> B\n 2. \\<Squnion> B \\<le> \\<Squnion> (A \\<union> B)", "from chain"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (\\<le>) (A \\<union> B)", "have chain': \"Complete_Partial_Order.chain (\\<le>) B\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) (A \\<union> B)\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) B", "by(blast intro: chain_subset)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) B\n\ngoal (2 subgoals):\n 1. \\<Squnion> (A \\<union> B) \\<le> \\<Squnion> B\n 2. \\<Squnion> B \\<le> \\<Squnion> (A \\<union> B)", "show \"Sup (A \\<union> B) \\<le> Sup B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (A \\<union> B) \\<le> \\<Squnion> B", "using chain"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) (A \\<union> B)\n\ngoal (1 subgoal):\n 1. \\<Squnion> (A \\<union> B) \\<le> \\<Squnion> B", "proof(rule ccpo_Sup_least)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<union> B \\<Longrightarrow> x \\<le> \\<Squnion> B", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<union> B \\<Longrightarrow> x \\<le> \\<Squnion> B", "assume \"x \\<in> A \\<union> B\""], ["proof (state)\nthis:\n  x \\<in> A \\<union> B\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<union> B \\<Longrightarrow> x \\<le> \\<Squnion> B", "thus \"x \\<le> Sup B\""], ["proof (prove)\nusing this:\n  x \\<in> A \\<union> B\n\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> B", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow> x \\<le> \\<Squnion> B\n 2. x \\<in> B \\<Longrightarrow> x \\<le> \\<Squnion> B", "assume \"x \\<in> A\""], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow> x \\<le> \\<Squnion> B\n 2. x \\<in> B \\<Longrightarrow> x \\<le> \\<Squnion> B", "then"], ["proof (chain)\npicking this:\n  x \\<in> A", "obtain y where \"x \\<le> y\" \"y \\<in> B\""], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>x \\<le> y; y \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using AB"], ["proof (prove)\nusing this:\n  x \\<in> A\n  \\<forall>x\\<in>A. \\<exists>y\\<in>B. x \\<le> y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>x \\<le> y; y \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<in> B\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow> x \\<le> \\<Squnion> B\n 2. x \\<in> B \\<Longrightarrow> x \\<le> \\<Squnion> B", "note \\<open>x \\<le> y\\<close>"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow> x \\<le> \\<Squnion> B\n 2. x \\<in> B \\<Longrightarrow> x \\<le> \\<Squnion> B", "also"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow> x \\<le> \\<Squnion> B\n 2. x \\<in> B \\<Longrightarrow> x \\<le> \\<Squnion> B", "from chain' \\<open>y \\<in> B\\<close>"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (\\<le>) B\n  y \\<in> B", "have \"y \\<le> Sup B\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) B\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. y \\<le> \\<Squnion> B", "by(rule ccpo_Sup_upper)"], ["proof (state)\nthis:\n  y \\<le> \\<Squnion> B\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow> x \\<le> \\<Squnion> B\n 2. x \\<in> B \\<Longrightarrow> x \\<le> \\<Squnion> B", "finally"], ["proof (chain)\npicking this:\n  x \\<le> \\<Squnion> B", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> \\<Squnion> B\n\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> B", "."], ["proof (state)\nthis:\n  x \\<le> \\<Squnion> B\n\ngoal (1 subgoal):\n 1. x \\<in> B \\<Longrightarrow> x \\<le> \\<Squnion> B", "qed(rule ccpo_Sup_upper[OF chain'])"], ["proof (state)\nthis:\n  x \\<le> \\<Squnion> B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Squnion> (A \\<union> B) \\<le> \\<Squnion> B\n\ngoal (1 subgoal):\n 1. \\<Squnion> B \\<le> \\<Squnion> (A \\<union> B)", "show \"Sup B \\<le> Sup (A \\<union> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> B \\<le> \\<Squnion> (A \\<union> B)", "using chain chain'"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) (A \\<union> B)\n  Complete_Partial_Order.chain (\\<le>) B\n\ngoal (1 subgoal):\n 1. \\<Squnion> B \\<le> \\<Squnion> (A \\<union> B)", "by(blast intro: ccpo_Sup_least ccpo_Sup_upper)"], ["proof (state)\nthis:\n  \\<Squnion> B \\<le> \\<Squnion> (A \\<union> B)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The ccpo structure\\<close>"], ["", "context includes tllist.lifting fixes b :: 'b begin"], ["", "lift_definition tllist_ord :: \"('a, 'b) tllist \\<Rightarrow> ('a, 'b) tllist \\<Rightarrow> bool\"\nis \"\\<lambda>(xs1, b1) (xs2, b2). if lfinite xs1 then b1 = b \\<and> lprefix xs1 xs2 \\<or> xs1 = xs2 \\<and> flat_ord b b1 b2 else xs1 = xs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2 prod3 prod4.\n       \\<lbrakk>(case prod1 of\n                 (xs, a) \\<Rightarrow>\n                   \\<lambda>(ys, b).\n                      xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n                 prod2;\n        (case prod3 of\n         (xs, a) \\<Rightarrow>\n           \\<lambda>(ys, b).\n              xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n         prod4\\<rbrakk>\n       \\<Longrightarrow> (case prod1 of\n                          (xs1, b1) \\<Rightarrow>\n                            \\<lambda>(xs2, b2).\n                               if lfinite xs1\n                               then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                                    xs1 = xs2 \\<and> flat_ord b b1 b2\n                               else xs1 = xs2)\n                          prod3 =\n                         (case prod2 of\n                          (xs1, b1) \\<Rightarrow>\n                            \\<lambda>(xs2, b2).\n                               if lfinite xs1\n                               then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                                    xs1 = xs2 \\<and> flat_ord b b1 b2\n                               else xs1 = xs2)\n                          prod4", "by auto"], ["", "lift_definition tSup :: \"('a, 'b) tllist set \\<Rightarrow> ('a, 'b) tllist\"\nis \"\\<lambda>A. (lSup (fst ` A), flat_lub b (snd ` (A \\<inter> {(xs, _). lfinite xs})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       rel_set\n        (\\<lambda>(xs, a) (ys, b).\n            xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        set1 set2 \\<Longrightarrow>\n       (case (lSup (fst ` set1),\n              flat_lub b (snd ` (set1 \\<inter> {(xs, uu_). lfinite xs}))) of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        (lSup (fst ` set2),\n         flat_lub b (snd ` (set2 \\<inter> {(xs, uu_). lfinite xs})))", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       rel_set\n        (\\<lambda>(xs, a) (ys, b).\n            xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        set1 set2 \\<Longrightarrow>\n       (case (lSup (fst ` set1),\n              flat_lub b (snd ` (set1 \\<inter> {(xs, uu_). lfinite xs}))) of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        (lSup (fst ` set2),\n         flat_lub b (snd ` (set2 \\<inter> {(xs, uu_). lfinite xs})))", "case (1 A1 A2)"], ["proof (state)\nthis:\n  rel_set\n   (\\<lambda>(xs, a) (ys, b).\n       xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n   A1 A2\n\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       rel_set\n        (\\<lambda>(xs, a) (ys, b).\n            xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        set1 set2 \\<Longrightarrow>\n       (case (lSup (fst ` set1),\n              flat_lub b (snd ` (set1 \\<inter> {(xs, uu_). lfinite xs}))) of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        (lSup (fst ` set2),\n         flat_lub b (snd ` (set2 \\<inter> {(xs, uu_). lfinite xs})))", "hence \"fst ` A1 = fst ` A2\" \"snd ` (A1 \\<inter> {(xs, _). lfinite xs}) = snd ` (A2 \\<inter> {(xs, _). lfinite xs})\""], ["proof (prove)\nusing this:\n  rel_set\n   (\\<lambda>(xs, a) (ys, b).\n       xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n   A1 A2\n\ngoal (1 subgoal):\n 1. fst ` A1 = fst ` A2 &&&\n    snd ` (A1 \\<inter> {(xs, uu_). lfinite xs}) =\n    snd ` (A2 \\<inter> {(xs, uu_). lfinite xs})", "by(auto 4 3 simp add: rel_set_def intro: rev_image_eqI)"], ["proof (state)\nthis:\n  fst ` A1 = fst ` A2\n  snd ` (A1 \\<inter> {(xs, uu_). lfinite xs}) =\n  snd ` (A2 \\<inter> {(xs, uu_). lfinite xs})\n\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       rel_set\n        (\\<lambda>(xs, a) (ys, b).\n            xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        set1 set2 \\<Longrightarrow>\n       (case (lSup (fst ` set1),\n              flat_lub b (snd ` (set1 \\<inter> {(xs, uu_). lfinite xs}))) of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        (lSup (fst ` set2),\n         flat_lub b (snd ` (set2 \\<inter> {(xs, uu_). lfinite xs})))", "thus ?case"], ["proof (prove)\nusing this:\n  fst ` A1 = fst ` A2\n  snd ` (A1 \\<inter> {(xs, uu_). lfinite xs}) =\n  snd ` (A2 \\<inter> {(xs, uu_). lfinite xs})\n\ngoal (1 subgoal):\n 1. (case (lSup (fst ` A1),\n           flat_lub b (snd ` (A1 \\<inter> {(xs, uu_). lfinite xs}))) of\n     (xs, a) \\<Rightarrow>\n       \\<lambda>(ys, b).\n          xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n     (lSup (fst ` A2),\n      flat_lub b (snd ` (A2 \\<inter> {(xs, uu_). lfinite xs})))", "by simp"], ["proof (state)\nthis:\n  (case (lSup (fst ` A1),\n         flat_lub b (snd ` (A1 \\<inter> {(xs, uu_). lfinite xs}))) of\n   (xs, a) \\<Rightarrow>\n     \\<lambda>(ys, b). xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n   (lSup (fst ` A2),\n    flat_lub b (snd ` (A2 \\<inter> {(xs, uu_). lfinite xs})))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tllist_ord_simps [simp, code]: (* FIXME: does not work with transfer *)\n  shows tllist_ord_TNil_TNil: \"tllist_ord (TNil b1) (TNil b2) \\<longleftrightarrow> flat_ord b b1 b2\"\n  and tllist_ord_TNil_TCons: \"tllist_ord (TNil b1) (TCons y ys) \\<longleftrightarrow> b1 = b\"\n  and tllist_ord_TCons_TNil: \"tllist_ord (TCons x xs) (TNil b2) \\<longleftrightarrow> False\"\n  and tllist_ord_TCons_TCons: \"tllist_ord (TCons x xs) (TCons y ys) \\<longleftrightarrow> x = y \\<and> tllist_ord xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.tllist_ord (TNil b1) (TNil b2) = flat_ord b b1 b2 &&&\n     local.tllist_ord (TNil b1) (TCons y ys) = (b1 = b)) &&&\n    local.tllist_ord (TCons x xs) (TNil b2) = False &&&\n    local.tllist_ord (TCons x xs) (TCons y ys) =\n    (x = y \\<and> local.tllist_ord xs ys)", "by(auto simp add: tllist_ord.rep_eq flat_ord_def)"], ["", "lemma tllist_ord_refl [simp]: \"tllist_ord xs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tllist_ord xs xs", "by transfer(auto simp add: flat_ord_def)"], ["", "lemma tllist_ord_antisym: \"\\<lbrakk> tllist_ord xs ys; tllist_ord ys xs \\<rbrakk> \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.tllist_ord xs ys; local.tllist_ord ys xs\\<rbrakk>\n    \\<Longrightarrow> xs = ys", "by transfer(auto simp add: flat_ord_def split: if_split_asm intro: lprefix_antisym)"], ["", "lemma tllist_ord_trans [trans]: \"\\<lbrakk> tllist_ord xs ys; tllist_ord ys zs \\<rbrakk> \\<Longrightarrow> tllist_ord xs zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.tllist_ord xs ys; local.tllist_ord ys zs\\<rbrakk>\n    \\<Longrightarrow> local.tllist_ord xs zs", "by transfer(auto simp add: flat_ord_def split: if_split_asm intro: lprefix_trans)"], ["", "lemma chain_tllist_llist_of_tllist:\n  assumes \"Complete_Partial_Order.chain tllist_ord A\"\n  shows \"Complete_Partial_Order.chain lprefix (llist_of_tllist ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain lprefix (llist_of_tllist ` A)", "by(rule chainI)(auto 4 3 simp add: tllist_ord.rep_eq split: if_split_asm dest: chainD[OF assms])"], ["", "lemma chain_tllist_terminal:\n  assumes \"Complete_Partial_Order.chain tllist_ord A\"\n  shows \"Complete_Partial_Order.chain (flat_ord b) {terminal xs|xs. xs \\<in> A \\<and> tfinite xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (flat_ord b)\n     {terminal xs |xs. xs \\<in> A \\<and> tfinite xs}", "by(rule chainI)(auto simp add: tllist_ord.rep_eq flat_ord_def dest: chainD[OF assms])"], ["", "lemma flat_ord_chain_finite:\n  assumes \"Complete_Partial_Order.chain (flat_ord b) A\"\n  shows \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite A", "from assms"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (flat_ord b) A", "have \"\\<exists>z. \\<forall>x\\<in>A. x = b \\<or> x = z\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (flat_ord b) A\n\ngoal (1 subgoal):\n 1. \\<exists>z. \\<forall>x\\<in>A. x = b \\<or> x = z", "by(clarsimp simp add: chain_def flat_ord_def) metis"], ["proof (state)\nthis:\n  \\<exists>z. \\<forall>x\\<in>A. x = b \\<or> x = z\n\ngoal (1 subgoal):\n 1. finite A", "then"], ["proof (chain)\npicking this:\n  \\<exists>z. \\<forall>x\\<in>A. x = b \\<or> x = z", "obtain z where \"\\<And>x. x \\<in> A \\<Longrightarrow> x = b \\<or> x = z\""], ["proof (prove)\nusing this:\n  \\<exists>z. \\<forall>x\\<in>A. x = b \\<or> x = z\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        (\\<And>x.\n            x \\<in> A \\<Longrightarrow> x = b \\<or> x = z) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ?x2 \\<in> A \\<Longrightarrow> ?x2 = b \\<or> ?x2 = z\n\ngoal (1 subgoal):\n 1. finite A", "hence \"A \\<subseteq> {b, z}\""], ["proof (prove)\nusing this:\n  ?x2 \\<in> A \\<Longrightarrow> ?x2 = b \\<or> ?x2 = z\n\ngoal (1 subgoal):\n 1. A \\<subseteq> {b, z}", "by auto"], ["proof (state)\nthis:\n  A \\<subseteq> {b, z}\n\ngoal (1 subgoal):\n 1. finite A", "thus ?thesis"], ["proof (prove)\nusing this:\n  A \\<subseteq> {b, z}\n\ngoal (1 subgoal):\n 1. finite A", "by(rule finite_subset) simp"], ["proof (state)\nthis:\n  finite A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tSup_empty [simp]: \"tSup {} = TNil b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tSup {} = TNil b", "by(transfer)(simp add: flat_lub_def)"], ["", "lemma is_TNil_tSup [simp]: \"is_TNil (tSup A) \\<longleftrightarrow> (\\<forall>x\\<in>A. is_TNil x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_TNil (local.tSup A) = (\\<forall>x\\<in>A. is_TNil x)", "by transfer(simp add: split_beta)"], ["", "lemma chain_tllist_ord_tSup:\n  assumes chain: \"Complete_Partial_Order.chain tllist_ord A\"\n  and A: \"xs \\<in> A\"\n  shows \"tllist_ord xs (tSup A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tllist_ord xs (local.tSup A)", "proof(cases \"tfinite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. tfinite xs \\<Longrightarrow> local.tllist_ord xs (local.tSup A)\n 2. \\<not> tfinite xs \\<Longrightarrow> local.tllist_ord xs (local.tSup A)", "case True"], ["proof (state)\nthis:\n  tfinite xs\n\ngoal (2 subgoals):\n 1. tfinite xs \\<Longrightarrow> local.tllist_ord xs (local.tSup A)\n 2. \\<not> tfinite xs \\<Longrightarrow> local.tllist_ord xs (local.tSup A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tllist_ord xs (local.tSup A)", "proof(cases \"llist_of_tllist xs = llist_of_tllist (tSup A)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. llist_of_tllist xs = llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)\n 2. llist_of_tllist xs \\<noteq>\n    llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)", "case True"], ["proof (state)\nthis:\n  llist_of_tllist xs = llist_of_tllist (local.tSup A)\n\ngoal (2 subgoals):\n 1. llist_of_tllist xs = llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)\n 2. llist_of_tllist xs \\<noteq>\n    llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)", "with \\<open>tfinite xs\\<close>"], ["proof (chain)\npicking this:\n  tfinite xs\n  llist_of_tllist xs = llist_of_tllist (local.tSup A)", "have \"lfinite (lSup (llist_of_tllist ` A))\""], ["proof (prove)\nusing this:\n  tfinite xs\n  llist_of_tllist xs = llist_of_tllist (local.tSup A)\n\ngoal (1 subgoal):\n 1. lfinite (lSup (llist_of_tllist ` A))", "by(simp add: tSup_def image_image)"], ["proof (state)\nthis:\n  lfinite (lSup (llist_of_tllist ` A))\n\ngoal (2 subgoals):\n 1. llist_of_tllist xs = llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)\n 2. llist_of_tllist xs \\<noteq>\n    llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)", "hence \"terminal (tSup A) = flat_lub b {terminal xs|xs. xs \\<in> A \\<and> tfinite xs}\" (is \"_ = flat_lub _ ?A\")"], ["proof (prove)\nusing this:\n  lfinite (lSup (llist_of_tllist ` A))\n\ngoal (1 subgoal):\n 1. terminal (local.tSup A) =\n    flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs}", "by(simp add: tSup_def terminal_tllist_of_llist image_image)(auto intro: rev_image_eqI intro!: arg_cong[where f=\"flat_lub b\"])"], ["proof (state)\nthis:\n  terminal (local.tSup A) =\n  flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs}\n\ngoal (2 subgoals):\n 1. llist_of_tllist xs = llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)\n 2. llist_of_tllist xs \\<noteq>\n    llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)", "moreover"], ["proof (state)\nthis:\n  terminal (local.tSup A) =\n  flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs}\n\ngoal (2 subgoals):\n 1. llist_of_tllist xs = llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)\n 2. llist_of_tllist xs \\<noteq>\n    llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)", "have \"flat_ord b (terminal xs) (flat_lub b ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_ord b (terminal xs)\n     (flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs})", "by(rule ccpo.ccpo_Sup_upper[OF Partial_Function.ccpo[OF flat_interpretation]])(blast intro: chain_tllist_terminal[OF chain] A \\<open>tfinite xs\\<close>)+"], ["proof (state)\nthis:\n  flat_ord b (terminal xs)\n   (flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs})\n\ngoal (2 subgoals):\n 1. llist_of_tllist xs = llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)\n 2. llist_of_tllist xs \\<noteq>\n    llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)", "ultimately"], ["proof (chain)\npicking this:\n  terminal (local.tSup A) =\n  flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs}\n  flat_ord b (terminal xs)\n   (flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs})", "show ?thesis"], ["proof (prove)\nusing this:\n  terminal (local.tSup A) =\n  flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs}\n  flat_ord b (terminal xs)\n   (flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs})\n\ngoal (1 subgoal):\n 1. local.tllist_ord xs (local.tSup A)", "using True"], ["proof (prove)\nusing this:\n  terminal (local.tSup A) =\n  flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs}\n  flat_ord b (terminal xs)\n   (flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs})\n  llist_of_tllist xs = llist_of_tllist (local.tSup A)\n\ngoal (1 subgoal):\n 1. local.tllist_ord xs (local.tSup A)", "by(simp add: tllist_ord.rep_eq)"], ["proof (state)\nthis:\n  local.tllist_ord xs (local.tSup A)\n\ngoal (1 subgoal):\n 1. llist_of_tllist xs \\<noteq>\n    llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. llist_of_tllist xs \\<noteq>\n    llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)", "case False"], ["proof (state)\nthis:\n  llist_of_tllist xs \\<noteq> llist_of_tllist (local.tSup A)\n\ngoal (1 subgoal):\n 1. llist_of_tllist xs \\<noteq>\n    llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)", "hence \"\\<exists>ys\\<in>A. \\<not> tllist_ord ys xs\""], ["proof (prove)\nusing this:\n  llist_of_tllist xs \\<noteq> llist_of_tllist (local.tSup A)\n\ngoal (1 subgoal):\n 1. \\<exists>ys\\<in>A. \\<not> local.tllist_ord ys xs", "by(rule contrapos_np)(auto intro!: lprefix_antisym chain_lSup_lprefix chain_lprefix_lSup simp add: tSup_def image_image A chain_tllist_llist_of_tllist[OF chain] tllist_ord.rep_eq split: if_split_asm)"], ["proof (state)\nthis:\n  \\<exists>ys\\<in>A. \\<not> local.tllist_ord ys xs\n\ngoal (1 subgoal):\n 1. llist_of_tllist xs \\<noteq>\n    llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)", "then"], ["proof (chain)\npicking this:\n  \\<exists>ys\\<in>A. \\<not> local.tllist_ord ys xs", "obtain ys where \"ys \\<in> A\" \"\\<not> tllist_ord ys xs\""], ["proof (prove)\nusing this:\n  \\<exists>ys\\<in>A. \\<not> local.tllist_ord ys xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>ys \\<in> A; \\<not> local.tllist_ord ys xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ys \\<in> A\n  \\<not> local.tllist_ord ys xs\n\ngoal (1 subgoal):\n 1. llist_of_tllist xs \\<noteq>\n    llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)", "with A"], ["proof (chain)\npicking this:\n  xs \\<in> A\n  ys \\<in> A\n  \\<not> local.tllist_ord ys xs", "have \"tllist_ord xs ys\" \"xs \\<noteq> ys\""], ["proof (prove)\nusing this:\n  xs \\<in> A\n  ys \\<in> A\n  \\<not> local.tllist_ord ys xs\n\ngoal (1 subgoal):\n 1. local.tllist_ord xs ys &&& xs \\<noteq> ys", "by(auto dest: chainD[OF chain])"], ["proof (state)\nthis:\n  local.tllist_ord xs ys\n  xs \\<noteq> ys\n\ngoal (1 subgoal):\n 1. llist_of_tllist xs \\<noteq>\n    llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)", "with True"], ["proof (chain)\npicking this:\n  tfinite xs\n  local.tllist_ord xs ys\n  xs \\<noteq> ys", "have \"terminal xs = b\""], ["proof (prove)\nusing this:\n  tfinite xs\n  local.tllist_ord xs ys\n  xs \\<noteq> ys\n\ngoal (1 subgoal):\n 1. terminal xs = b", "by transfer(auto simp add: flat_ord_def)"], ["proof (state)\nthis:\n  terminal xs = b\n\ngoal (1 subgoal):\n 1. llist_of_tllist xs \\<noteq>\n    llist_of_tllist (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord xs (local.tSup A)", "with True False"], ["proof (chain)\npicking this:\n  tfinite xs\n  llist_of_tllist xs \\<noteq> llist_of_tllist (local.tSup A)\n  terminal xs = b", "show ?thesis"], ["proof (prove)\nusing this:\n  tfinite xs\n  llist_of_tllist xs \\<noteq> llist_of_tllist (local.tSup A)\n  terminal xs = b\n\ngoal (1 subgoal):\n 1. local.tllist_ord xs (local.tSup A)", "by(simp add: tllist_ord.rep_eq tSup_def image_image chain_lprefix_lSup chain_tllist_llist_of_tllist chain A)"], ["proof (state)\nthis:\n  local.tllist_ord xs (local.tSup A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.tllist_ord xs (local.tSup A)\n\ngoal (1 subgoal):\n 1. \\<not> tfinite xs \\<Longrightarrow> local.tllist_ord xs (local.tSup A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tfinite xs \\<Longrightarrow> local.tllist_ord xs (local.tSup A)", "case False"], ["proof (state)\nthis:\n  \\<not> tfinite xs\n\ngoal (1 subgoal):\n 1. \\<not> tfinite xs \\<Longrightarrow> local.tllist_ord xs (local.tSup A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> tfinite xs\n\ngoal (1 subgoal):\n 1. local.tllist_ord xs (local.tSup A)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> tfinite xs\n  Complete_Partial_Order.chain local.tllist_ord A\n  xs \\<in> A\n\ngoal (1 subgoal):\n 1. local.tllist_ord xs (local.tSup A)", "by(simp add: tllist_ord.rep_eq tSup_def image_image chain_lprefix_lSup chain_tllist_llist_of_tllist not_lfinite_lprefix_conv_eq[THEN iffD1] terminal_tllist_of_llist split: if_split_asm)"], ["proof (state)\nthis:\n  local.tllist_ord xs (local.tSup A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_tSup_tllist_ord:\n  assumes chain: \"Complete_Partial_Order.chain tllist_ord A\"\n  and lub: \"\\<And>xs'. xs' \\<in> A \\<Longrightarrow> tllist_ord xs' xs\"\n  shows \"tllist_ord (tSup A) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tllist_ord (local.tSup A) xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.tllist_ord (local.tSup A) xs", "have \"\\<And>xs'. xs' \\<in> llist_of_tllist ` A \\<Longrightarrow> lprefix xs' (llist_of_tllist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs'.\n       xs' \\<in> llist_of_tllist ` A \\<Longrightarrow>\n       lprefix xs' (llist_of_tllist xs)", "by(auto dest!: lub simp add: tllist_ord.rep_eq split: if_split_asm)"], ["proof (state)\nthis:\n  ?xs'2 \\<in> llist_of_tllist ` A \\<Longrightarrow>\n  lprefix ?xs'2 (llist_of_tllist xs)\n\ngoal (1 subgoal):\n 1. local.tllist_ord (local.tSup A) xs", "with chain_tllist_llist_of_tllist[OF chain]"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain lprefix (llist_of_tllist ` A)\n  ?xs'2 \\<in> llist_of_tllist ` A \\<Longrightarrow>\n  lprefix ?xs'2 (llist_of_tllist xs)", "have prefix: \"lprefix (lSup (llist_of_tllist ` A)) (llist_of_tllist xs)\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain lprefix (llist_of_tllist ` A)\n  ?xs'2 \\<in> llist_of_tllist ` A \\<Longrightarrow>\n  lprefix ?xs'2 (llist_of_tllist xs)\n\ngoal (1 subgoal):\n 1. lprefix (lSup (llist_of_tllist ` A)) (llist_of_tllist xs)", "by(rule chain_lSup_lprefix)"], ["proof (state)\nthis:\n  lprefix (lSup (llist_of_tllist ` A)) (llist_of_tllist xs)\n\ngoal (1 subgoal):\n 1. local.tllist_ord (local.tSup A) xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tllist_ord (local.tSup A) xs", "proof(cases \"tfinite (tSup A)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. tfinite (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs\n 2. \\<not> tfinite (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "case False"], ["proof (state)\nthis:\n  \\<not> tfinite (local.tSup A)\n\ngoal (2 subgoals):\n 1. tfinite (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs\n 2. \\<not> tfinite (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> tfinite (local.tSup A)\n\ngoal (1 subgoal):\n 1. local.tllist_ord (local.tSup A) xs", "using prefix"], ["proof (prove)\nusing this:\n  \\<not> tfinite (local.tSup A)\n  lprefix (lSup (llist_of_tllist ` A)) (llist_of_tllist xs)\n\ngoal (1 subgoal):\n 1. local.tllist_ord (local.tSup A) xs", "by(simp add: tllist_ord.rep_eq tSup_def image_image not_lfinite_lprefix_conv_eq[THEN iffD1])"], ["proof (state)\nthis:\n  local.tllist_ord (local.tSup A) xs\n\ngoal (1 subgoal):\n 1. tfinite (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tfinite (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "case True"], ["proof (state)\nthis:\n  tfinite (local.tSup A)\n\ngoal (1 subgoal):\n 1. tfinite (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "from True"], ["proof (chain)\npicking this:\n  tfinite (local.tSup A)", "have fin: \"lfinite (lSup (llist_of_tllist ` A))\""], ["proof (prove)\nusing this:\n  tfinite (local.tSup A)\n\ngoal (1 subgoal):\n 1. lfinite (lSup (llist_of_tllist ` A))", "by(simp add: tSup_def image_image)"], ["proof (state)\nthis:\n  lfinite (lSup (llist_of_tllist ` A))\n\ngoal (1 subgoal):\n 1. tfinite (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "have eq: \"terminal (tSup A) = flat_lub b {terminal xs|xs. xs \\<in> A \\<and> tfinite xs}\" (is \"_ = flat_lub _ ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal (local.tSup A) =\n    flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs}", "by(simp add: tSup_def terminal_tllist_of_llist image_image fin)(auto intro: rev_image_eqI intro!: arg_cong[where f=\"flat_lub b\"])"], ["proof (state)\nthis:\n  terminal (local.tSup A) =\n  flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs}\n\ngoal (1 subgoal):\n 1. tfinite (local.tSup A) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tllist_ord (local.tSup A) xs", "proof(cases \"lprefix (llist_of_tllist xs) (lSup (llist_of_tllist ` A))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lprefix (llist_of_tllist xs)\n     (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs\n 2. \\<not> lprefix (llist_of_tllist xs)\n            (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "case True"], ["proof (state)\nthis:\n  lprefix (llist_of_tllist xs) (lSup (llist_of_tllist ` A))\n\ngoal (2 subgoals):\n 1. lprefix (llist_of_tllist xs)\n     (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs\n 2. \\<not> lprefix (llist_of_tllist xs)\n            (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "with prefix"], ["proof (chain)\npicking this:\n  lprefix (lSup (llist_of_tllist ` A)) (llist_of_tllist xs)\n  lprefix (llist_of_tllist xs) (lSup (llist_of_tllist ` A))", "have \"lSup (llist_of_tllist ` A) = llist_of_tllist xs\""], ["proof (prove)\nusing this:\n  lprefix (lSup (llist_of_tllist ` A)) (llist_of_tllist xs)\n  lprefix (llist_of_tllist xs) (lSup (llist_of_tllist ` A))\n\ngoal (1 subgoal):\n 1. lSup (llist_of_tllist ` A) = llist_of_tllist xs", "by(rule lprefix_antisym)"], ["proof (state)\nthis:\n  lSup (llist_of_tllist ` A) = llist_of_tllist xs\n\ngoal (2 subgoals):\n 1. lprefix (llist_of_tllist xs)\n     (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs\n 2. \\<not> lprefix (llist_of_tllist xs)\n            (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "moreover"], ["proof (state)\nthis:\n  lSup (llist_of_tllist ` A) = llist_of_tllist xs\n\ngoal (2 subgoals):\n 1. lprefix (llist_of_tllist xs)\n     (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs\n 2. \\<not> lprefix (llist_of_tllist xs)\n            (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "have \"flat_ord b (flat_lub b ?A) (terminal xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_ord b (flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs})\n     (terminal xs)", "by(rule ccpo.ccpo_Sup_least[OF Partial_Function.ccpo[OF flat_interpretation]])(auto intro: chain_tllist_terminal[OF chain] dest: lub simp add: tllist_ord.rep_eq flat_ord_def)"], ["proof (state)\nthis:\n  flat_ord b (flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs})\n   (terminal xs)\n\ngoal (2 subgoals):\n 1. lprefix (llist_of_tllist xs)\n     (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs\n 2. \\<not> lprefix (llist_of_tllist xs)\n            (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "ultimately"], ["proof (chain)\npicking this:\n  lSup (llist_of_tllist ` A) = llist_of_tllist xs\n  flat_ord b (flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs})\n   (terminal xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  lSup (llist_of_tllist ` A) = llist_of_tllist xs\n  flat_ord b (flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs})\n   (terminal xs)\n\ngoal (1 subgoal):\n 1. local.tllist_ord (local.tSup A) xs", "using eq"], ["proof (prove)\nusing this:\n  lSup (llist_of_tllist ` A) = llist_of_tllist xs\n  flat_ord b (flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs})\n   (terminal xs)\n  terminal (local.tSup A) =\n  flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs}\n\ngoal (1 subgoal):\n 1. local.tllist_ord (local.tSup A) xs", "by(simp add: tllist_ord.rep_eq tSup_def image_image)"], ["proof (state)\nthis:\n  local.tllist_ord (local.tSup A) xs\n\ngoal (1 subgoal):\n 1. \\<not> lprefix (llist_of_tllist xs)\n            (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lprefix (llist_of_tllist xs)\n            (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "case False"], ["proof (state)\nthis:\n  \\<not> lprefix (llist_of_tllist xs) (lSup (llist_of_tllist ` A))\n\ngoal (1 subgoal):\n 1. \\<not> lprefix (llist_of_tllist xs)\n            (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "{"], ["proof (state)\nthis:\n  \\<not> lprefix (llist_of_tllist xs) (lSup (llist_of_tllist ` A))\n\ngoal (1 subgoal):\n 1. \\<not> lprefix (llist_of_tllist xs)\n            (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "fix xs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lprefix (llist_of_tllist xs)\n            (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "assume \"xs' \\<in> A\""], ["proof (state)\nthis:\n  xs' \\<in> A\n\ngoal (1 subgoal):\n 1. \\<not> lprefix (llist_of_tllist xs)\n            (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "with False"], ["proof (chain)\npicking this:\n  \\<not> lprefix (llist_of_tllist xs) (lSup (llist_of_tllist ` A))\n  xs' \\<in> A", "have \"\\<not> lprefix (llist_of_tllist xs) (llist_of_tllist xs')\""], ["proof (prove)\nusing this:\n  \\<not> lprefix (llist_of_tllist xs) (lSup (llist_of_tllist ` A))\n  xs' \\<in> A\n\ngoal (1 subgoal):\n 1. \\<not> lprefix (llist_of_tllist xs) (llist_of_tllist xs')", "by-(erule contrapos_nn, auto 4 4 intro: lprefix_trans chain_lprefix_lSup chain_tllist_llist_of_tllist chain)"], ["proof (state)\nthis:\n  \\<not> lprefix (llist_of_tllist xs) (llist_of_tllist xs')\n\ngoal (1 subgoal):\n 1. \\<not> lprefix (llist_of_tllist xs)\n            (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "with lub[OF \\<open>xs' \\<in> A\\<close>]"], ["proof (chain)\npicking this:\n  local.tllist_ord xs' xs\n  \\<not> lprefix (llist_of_tllist xs) (llist_of_tllist xs')", "have \"terminal xs' = b\""], ["proof (prove)\nusing this:\n  local.tllist_ord xs' xs\n  \\<not> lprefix (llist_of_tllist xs) (llist_of_tllist xs')\n\ngoal (1 subgoal):\n 1. terminal xs' = b", "by(auto simp add: tllist_ord.rep_eq split: if_split_asm)"], ["proof (state)\nthis:\n  terminal xs' = b\n\ngoal (1 subgoal):\n 1. \\<not> lprefix (llist_of_tllist xs)\n            (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "}"], ["proof (state)\nthis:\n  ?xs'4 \\<in> A \\<Longrightarrow> terminal ?xs'4 = b\n\ngoal (1 subgoal):\n 1. \\<not> lprefix (llist_of_tllist xs)\n            (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "with chain_tllist_terminal[OF chain]"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (flat_ord b)\n   {terminal xs |xs. xs \\<in> A \\<and> tfinite xs}\n  ?xs'4 \\<in> A \\<Longrightarrow> terminal ?xs'4 = b", "have \"flat_ord b (flat_lub b ?A) b\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (flat_ord b)\n   {terminal xs |xs. xs \\<in> A \\<and> tfinite xs}\n  ?xs'4 \\<in> A \\<Longrightarrow> terminal ?xs'4 = b\n\ngoal (1 subgoal):\n 1. flat_ord b (flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs})\n     b", "by -(rule ccpo.ccpo_Sup_least[OF Partial_Function.ccpo[OF flat_interpretation]], auto simp add: flat_ord_def)"], ["proof (state)\nthis:\n  flat_ord b (flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs}) b\n\ngoal (1 subgoal):\n 1. \\<not> lprefix (llist_of_tllist xs)\n            (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "hence \"flat_lub b ?A = b\""], ["proof (prove)\nusing this:\n  flat_ord b (flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs}) b\n\ngoal (1 subgoal):\n 1. flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs} = b", "by(simp add: flat_ord_def)"], ["proof (state)\nthis:\n  flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs} = b\n\ngoal (1 subgoal):\n 1. \\<not> lprefix (llist_of_tllist xs)\n            (lSup (llist_of_tllist ` A)) \\<Longrightarrow>\n    local.tllist_ord (local.tSup A) xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs} = b\n\ngoal (1 subgoal):\n 1. local.tllist_ord (local.tSup A) xs", "using True eq prefix"], ["proof (prove)\nusing this:\n  flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs} = b\n  tfinite (local.tSup A)\n  terminal (local.tSup A) =\n  flat_lub b {terminal xs |xs. xs \\<in> A \\<and> tfinite xs}\n  lprefix (lSup (llist_of_tllist ` A)) (llist_of_tllist xs)\n\ngoal (1 subgoal):\n 1. local.tllist_ord (local.tSup A) xs", "by(simp add: tSup_def terminal_tllist_of_llist tllist_ord.rep_eq image_image)"], ["proof (state)\nthis:\n  local.tllist_ord (local.tSup A) xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.tllist_ord (local.tSup A) xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.tllist_ord (local.tSup A) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tllist_ord_ccpo [simp, cont_intro]:\n  \"class.ccpo tSup tllist_ord (mk_less tllist_ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo local.tSup local.tllist_ord (mk_less local.tllist_ord)", "by unfold_locales(auto simp add: mk_less_def intro: tllist_ord_antisym tllist_ord_trans chain_tllist_ord_tSup chain_tSup_tllist_ord)"], ["", "lemma tllist_ord_partial_function_definitions: \"partial_function_definitions tllist_ord tSup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_function_definitions local.tllist_ord local.tSup", "by unfold_locales(auto simp add: mk_less_def intro: tllist_ord_antisym tllist_ord_trans chain_tllist_ord_tSup chain_tSup_tllist_ord)"], ["", "interpretation tllist: partial_function_definitions \"tllist_ord\" \"tSup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_function_definitions local.tllist_ord local.tSup", "by(rule tllist_ord_partial_function_definitions)"], ["", "lemma admissible_mcont_is_TNil [THEN admissible_subst, cont_intro, simp]:\n  shows admissible_is_TNil: \"ccpo.admissible tSup tllist_ord is_TNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible local.tSup local.tllist_ord is_TNil", "by(rule ccpo.admissibleI)(simp)"], ["", "lemma terminal_tSup:\n  \"\\<forall>xs\\<in>Y. is_TNil xs \\<Longrightarrow> terminal (tSup Y) = flat_lub b (terminal ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>Y. is_TNil xs \\<Longrightarrow>\n    terminal (local.tSup Y) = flat_lub b (terminal ` Y)", "including tllist.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>Y. is_TNil xs \\<Longrightarrow>\n    terminal (local.tSup Y) = flat_lub b (terminal ` Y)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<forall>(xs, b)\\<in>Y. lnull xs \\<Longrightarrow>\n       (case (lSup (fst ` Y),\n              flat_lub b (snd ` (Y \\<inter> {(xs, uu_). lfinite xs}))) of\n        (xs, b) \\<Rightarrow> if lfinite xs then b else undefined) =\n       flat_lub b\n        ((\\<lambda>(xs, b). if lfinite xs then b else undefined) ` Y)", "apply (auto simp add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<forall>x\\<in>Y. lnull (fst x) \\<Longrightarrow>\n       flat_lub b (snd ` (Y \\<inter> {p. lfinite (fst p)})) =\n       flat_lub b (snd ` Y)", "apply (rule arg_cong [where f = \"flat_lub b\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<forall>x\\<in>Y. lnull (fst x) \\<Longrightarrow>\n       snd ` (Y \\<inter> {p. lfinite (fst p)}) = snd ` Y", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma thd_tSup:\n  \"\\<exists>xs \\<in> Y. \\<not> is_TNil xs\n  \\<Longrightarrow> thd (tSup Y) = (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs\\<in>Y. \\<not> is_TNil xs \\<Longrightarrow>\n    thd (local.tSup Y) =\n    (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs}))", "apply(simp add: tSup_def image_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs\\<in>Y. \\<not> is_TNil xs \\<Longrightarrow>\n    (THE x.\n        x \\<in> lhd `\n                (llist_of_tllist ` Y \\<inter> {xs. \\<not> lnull xs})) =\n    (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs}))", "apply(rule arg_cong[where f=The])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs\\<in>Y. \\<not> is_TNil xs \\<Longrightarrow>\n    (\\<lambda>x.\n        x \\<in> lhd `\n                (llist_of_tllist ` Y \\<inter> {xs. \\<not> lnull xs})) =\n    (\\<lambda>x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs}))", "apply(auto intro: rev_image_eqI intro!: ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ex_TCons_raw_parametric:\n  includes lifting_syntax\n  shows \"(rel_set (rel_prod (llist_all2 A) B) ===> (=)) (\\<lambda>Y. \\<exists>(xs, b) \\<in> Y. \\<not> lnull xs) (\\<lambda>Y. \\<exists>(xs, b) \\<in> Y. \\<not> lnull xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (rel_prod (llist_all2 A) B) ===> (=))\n     (\\<lambda>Y. \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs)\n     (\\<lambda>Y. \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs)", "by(auto 4 4 simp add: rel_fun_def dest: rel_setD1 rel_setD2 llist_all2_lnullD intro: rev_bexI)"], ["", "lift_definition ex_TCons :: \"('a, 'b) tllist set \\<Rightarrow> bool\"\nis \"\\<lambda>Y. \\<exists>(xs, b) \\<in> Y. \\<not> lnull xs\" parametric ex_TCons_raw_parametric"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       rel_set\n        (\\<lambda>(xs, a) (ys, b).\n            xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        set1 set2 \\<Longrightarrow>\n       (\\<exists>(xs, b)\\<in>set1. \\<not> lnull xs) =\n       (\\<exists>(xs, b)\\<in>set2. \\<not> lnull xs)", "by (blast dest: rel_setD1 rel_setD2)+"], ["", "lemma ex_TCons_iff: \"ex_TCons Y \\<longleftrightarrow> (\\<exists>xs \\<in> Y. \\<not> is_TNil xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ex_TCons Y = (\\<exists>xs\\<in>Y. \\<not> is_TNil xs)", "by transfer auto"], ["", "lemma retain_TCons_raw_parametric:\n  includes lifting_syntax\n  shows \"(rel_set (rel_prod (llist_all2 A) B) ===> rel_set (rel_prod (llist_all2 A) B))\n    (\\<lambda>A. A \\<inter> {(xs, b). \\<not> lnull xs}) (\\<lambda>A. A \\<inter> {(xs, b). \\<not> lnull xs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (rel_prod (llist_all2 A) B) ===>\n     rel_set (rel_prod (llist_all2 A) B))\n     (\\<lambda>A. A \\<inter> {(xs, b). \\<not> lnull xs})\n     (\\<lambda>A. A \\<inter> {(xs, b). \\<not> lnull xs})", "by(rule rel_funI rel_setI)+(auto 4 4 dest: llist_all2_lnullD rel_setD2 rel_setD1 intro: rev_bexI)"], ["", "lift_definition retain_TCons :: \"('a, 'b) tllist set \\<Rightarrow> ('a, 'b) tllist set\"\nis \"\\<lambda>A. A \\<inter> {(xs, b). \\<not> lnull xs}\" parametric retain_TCons_raw_parametric"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       rel_set\n        (\\<lambda>(xs, a) (ys, b).\n            xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        set1 set2 \\<Longrightarrow>\n       rel_set\n        (\\<lambda>(xs, a) (ys, b).\n            xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        (set1 \\<inter> {(xs, b). \\<not> lnull xs})\n        (set2 \\<inter> {(xs, b). \\<not> lnull xs})", "by(rule rel_setI)(fastforce dest: rel_setD1 rel_setD2)+"], ["", "lemma retain_TCons_conv: \"retain_TCons A = A \\<inter> {xs. \\<not> is_TNil xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.retain_TCons A = A \\<inter> {xs. \\<not> is_TNil xs}", "by(auto simp add: retain_TCons_def intro: rev_image_eqI)"], ["", "lemma ttl_tSup:\n  \"\\<lbrakk> Complete_Partial_Order.chain tllist_ord Y; \\<exists>xs \\<in> Y. \\<not> is_TNil xs \\<rbrakk>\n  \\<Longrightarrow> ttl (tSup Y) = tSup (ttl ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Complete_Partial_Order.chain local.tllist_ord Y;\n     \\<exists>xs\\<in>Y. \\<not> is_TNil xs\\<rbrakk>\n    \\<Longrightarrow> ttl (local.tSup Y) =\n                      local.tSup\n                       (ttl ` (Y \\<inter> {xs. \\<not> is_TNil xs}))", "unfolding ex_TCons_iff[symmetric] retain_TCons_conv[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Complete_Partial_Order.chain local.tllist_ord Y;\n     local.ex_TCons Y\\<rbrakk>\n    \\<Longrightarrow> ttl (local.tSup Y) =\n                      local.tSup (ttl ` local.retain_TCons Y)", "proof (transfer, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (\\<lambda>(xs1, b1) (xs2, b2).\n                     if lfinite xs1\n                     then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                          xs1 = xs2 \\<and> flat_ord b b1 b2\n                     else xs1 = xs2)\n                 Y;\n        \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> (case apfst ltl\n                                (lSup (fst ` Y),\n                                 flat_lub b\n                                  (snd `\n                                   (Y \\<inter> {(xs, uu_). lfinite xs}))) of\n                          (xs, a) \\<Rightarrow>\n                            \\<lambda>(ys, b).\n                               xs = ys \\<and>\n                               (lfinite ys \\<longrightarrow> a = b))\n                          (lSup\n                            (fst `\n                             apfst ltl `\n                             (Y \\<inter> {(xs, b). \\<not> lnull xs})),\n                           flat_lub b\n                            (snd `\n                             (apfst ltl `\n                              (Y \\<inter>\n                               {(xs, b). \\<not> lnull xs}) \\<inter>\n                              {(xs, uu_). lfinite xs})))", "case prems: (1 Y)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain\n   (\\<lambda>(xs1, b1) (xs2, b2).\n       if lfinite xs1\n       then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n            xs1 = xs2 \\<and> flat_ord b b1 b2\n       else xs1 = xs2)\n   Y\n  \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (\\<lambda>(xs1, b1) (xs2, b2).\n                     if lfinite xs1\n                     then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                          xs1 = xs2 \\<and> flat_ord b b1 b2\n                     else xs1 = xs2)\n                 Y;\n        \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> (case apfst ltl\n                                (lSup (fst ` Y),\n                                 flat_lub b\n                                  (snd `\n                                   (Y \\<inter> {(xs, uu_). lfinite xs}))) of\n                          (xs, a) \\<Rightarrow>\n                            \\<lambda>(ys, b).\n                               xs = ys \\<and>\n                               (lfinite ys \\<longrightarrow> a = b))\n                          (lSup\n                            (fst `\n                             apfst ltl `\n                             (Y \\<inter> {(xs, b). \\<not> lnull xs})),\n                           flat_lub b\n                            (snd `\n                             (apfst ltl `\n                              (Y \\<inter>\n                               {(xs, b). \\<not> lnull xs}) \\<inter>\n                              {(xs, uu_). lfinite xs})))", "then"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain\n   (\\<lambda>(xs1, b1) (xs2, b2).\n       if lfinite xs1\n       then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n            xs1 = xs2 \\<and> flat_ord b b1 b2\n       else xs1 = xs2)\n   Y\n  \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs", "obtain xs b' where xsb: \"(xs, b') \\<in> Y\" \"\\<not> lnull xs\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain\n   (\\<lambda>(xs1, b1) (xs2, b2).\n       if lfinite xs1\n       then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n            xs1 = xs2 \\<and> flat_ord b b1 b2\n       else xs1 = xs2)\n   Y\n  \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs b'.\n        \\<lbrakk>(xs, b') \\<in> Y; \\<not> lnull xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (xs, b') \\<in> Y\n  \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (\\<lambda>(xs1, b1) (xs2, b2).\n                     if lfinite xs1\n                     then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                          xs1 = xs2 \\<and> flat_ord b b1 b2\n                     else xs1 = xs2)\n                 Y;\n        \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> (case apfst ltl\n                                (lSup (fst ` Y),\n                                 flat_lub b\n                                  (snd `\n                                   (Y \\<inter> {(xs, uu_). lfinite xs}))) of\n                          (xs, a) \\<Rightarrow>\n                            \\<lambda>(ys, b).\n                               xs = ys \\<and>\n                               (lfinite ys \\<longrightarrow> a = b))\n                          (lSup\n                            (fst `\n                             apfst ltl `\n                             (Y \\<inter> {(xs, b). \\<not> lnull xs})),\n                           flat_lub b\n                            (snd `\n                             (apfst ltl `\n                              (Y \\<inter>\n                               {(xs, b). \\<not> lnull xs}) \\<inter>\n                              {(xs, uu_). lfinite xs})))", "note chain = prems(1)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain\n   (\\<lambda>(xs1, b1) (xs2, b2).\n       if lfinite xs1\n       then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n            xs1 = xs2 \\<and> flat_ord b b1 b2\n       else xs1 = xs2)\n   Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (\\<lambda>(xs1, b1) (xs2, b2).\n                     if lfinite xs1\n                     then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                          xs1 = xs2 \\<and> flat_ord b b1 b2\n                     else xs1 = xs2)\n                 Y;\n        \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> (case apfst ltl\n                                (lSup (fst ` Y),\n                                 flat_lub b\n                                  (snd `\n                                   (Y \\<inter> {(xs, uu_). lfinite xs}))) of\n                          (xs, a) \\<Rightarrow>\n                            \\<lambda>(ys, b).\n                               xs = ys \\<and>\n                               (lfinite ys \\<longrightarrow> a = b))\n                          (lSup\n                            (fst `\n                             apfst ltl `\n                             (Y \\<inter> {(xs, b). \\<not> lnull xs})),\n                           flat_lub b\n                            (snd `\n                             (apfst ltl `\n                              (Y \\<inter>\n                               {(xs, b). \\<not> lnull xs}) \\<inter>\n                              {(xs, uu_). lfinite xs})))", "have \"flat_lub b (snd ` (Y \\<inter> {(xs, _). lfinite xs})) = flat_lub b (insert b (snd ` (Y \\<inter> {(xs, _). lfinite xs})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_lub b (snd ` (Y \\<inter> {(xs, uu_). lfinite xs})) =\n    flat_lub b (insert b (snd ` (Y \\<inter> {(xs, uu_). lfinite xs})))", "by(auto simp add: flat_lub_def)"], ["proof (state)\nthis:\n  flat_lub b (snd ` (Y \\<inter> {(xs, uu_). lfinite xs})) =\n  flat_lub b (insert b (snd ` (Y \\<inter> {(xs, uu_). lfinite xs})))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (\\<lambda>(xs1, b1) (xs2, b2).\n                     if lfinite xs1\n                     then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                          xs1 = xs2 \\<and> flat_ord b b1 b2\n                     else xs1 = xs2)\n                 Y;\n        \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> (case apfst ltl\n                                (lSup (fst ` Y),\n                                 flat_lub b\n                                  (snd `\n                                   (Y \\<inter> {(xs, uu_). lfinite xs}))) of\n                          (xs, a) \\<Rightarrow>\n                            \\<lambda>(ys, b).\n                               xs = ys \\<and>\n                               (lfinite ys \\<longrightarrow> a = b))\n                          (lSup\n                            (fst `\n                             apfst ltl `\n                             (Y \\<inter> {(xs, b). \\<not> lnull xs})),\n                           flat_lub b\n                            (snd `\n                             (apfst ltl `\n                              (Y \\<inter>\n                               {(xs, b). \\<not> lnull xs}) \\<inter>\n                              {(xs, uu_). lfinite xs})))", "also"], ["proof (state)\nthis:\n  flat_lub b (snd ` (Y \\<inter> {(xs, uu_). lfinite xs})) =\n  flat_lub b (insert b (snd ` (Y \\<inter> {(xs, uu_). lfinite xs})))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (\\<lambda>(xs1, b1) (xs2, b2).\n                     if lfinite xs1\n                     then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                          xs1 = xs2 \\<and> flat_ord b b1 b2\n                     else xs1 = xs2)\n                 Y;\n        \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> (case apfst ltl\n                                (lSup (fst ` Y),\n                                 flat_lub b\n                                  (snd `\n                                   (Y \\<inter> {(xs, uu_). lfinite xs}))) of\n                          (xs, a) \\<Rightarrow>\n                            \\<lambda>(ys, b).\n                               xs = ys \\<and>\n                               (lfinite ys \\<longrightarrow> a = b))\n                          (lSup\n                            (fst `\n                             apfst ltl `\n                             (Y \\<inter> {(xs, b). \\<not> lnull xs})),\n                           flat_lub b\n                            (snd `\n                             (apfst ltl `\n                              (Y \\<inter>\n                               {(xs, b). \\<not> lnull xs}) \\<inter>\n                              {(xs, uu_). lfinite xs})))", "have \"insert b (snd ` (Y \\<inter> {(xs, _). lfinite xs})) = insert b (snd ` (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter> {(xs, _). lfinite xs}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert b (snd ` (Y \\<inter> {(xs, uu_). lfinite xs})) =\n    insert b\n     (snd `\n      (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter>\n       {(xs, uu_). lfinite xs}))", "apply(auto intro: rev_image_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba.\n       \\<lbrakk>ba \\<notin> snd `\n                            (apfst ltl `\n                             (Y \\<inter>\n                              {(xs, b). \\<not> lnull xs}) \\<inter>\n                             {(xs, uu_). lfinite xs});\n        (a, ba) \\<in> Y; lfinite a\\<rbrakk>\n       \\<Longrightarrow> ba = b", "apply(erule contrapos_np)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba.\n       \\<lbrakk>(a, ba) \\<in> Y; lfinite a; ba \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> ba \\<in> snd `\n                                  (apfst ltl `\n                                   (Y \\<inter>\n                                    {(xs, b). \\<not> lnull xs}) \\<inter>\n                                   {(xs, uu_). lfinite xs})", "apply(frule chainD[OF chain \\<open>(xs, b') \\<in> Y\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba.\n       \\<lbrakk>(a, ba) \\<in> Y; lfinite a; ba \\<noteq> b;\n        (case (xs, b') of\n         (xs1, b1) \\<Rightarrow>\n           \\<lambda>(xs2, b2).\n              if lfinite xs1\n              then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                   xs1 = xs2 \\<and> flat_ord b b1 b2\n              else xs1 = xs2)\n         (a, ba) \\<or>\n        (case (a, ba) of\n         (xs1, b1) \\<Rightarrow>\n           \\<lambda>(xs2, b2).\n              if lfinite xs1\n              then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                   xs1 = xs2 \\<and> flat_ord b b1 b2\n              else xs1 = xs2)\n         (xs, b')\\<rbrakk>\n       \\<Longrightarrow> ba \\<in> snd `\n                                  (apfst ltl `\n                                   (Y \\<inter>\n                                    {(xs, b). \\<not> lnull xs}) \\<inter>\n                                   {(xs, uu_). lfinite xs})", "using \\<open>\\<not> lnull xs\\<close> xsb"], ["proof (prove)\nusing this:\n  \\<not> lnull xs\n  (xs, b') \\<in> Y\n  \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. \\<And>a ba.\n       \\<lbrakk>(a, ba) \\<in> Y; lfinite a; ba \\<noteq> b;\n        (case (xs, b') of\n         (xs1, b1) \\<Rightarrow>\n           \\<lambda>(xs2, b2).\n              if lfinite xs1\n              then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                   xs1 = xs2 \\<and> flat_ord b b1 b2\n              else xs1 = xs2)\n         (a, ba) \\<or>\n        (case (a, ba) of\n         (xs1, b1) \\<Rightarrow>\n           \\<lambda>(xs2, b2).\n              if lfinite xs1\n              then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                   xs1 = xs2 \\<and> flat_ord b b1 b2\n              else xs1 = xs2)\n         (xs, b')\\<rbrakk>\n       \\<Longrightarrow> ba \\<in> snd `\n                                  (apfst ltl `\n                                   (Y \\<inter>\n                                    {(xs, b). \\<not> lnull xs}) \\<inter>\n                                   {(xs, uu_). lfinite xs})", "by(fastforce split: if_split_asm simp add: lprefix_lnull intro!: rev_image_eqI)"], ["proof (state)\nthis:\n  insert b (snd ` (Y \\<inter> {(xs, uu_). lfinite xs})) =\n  insert b\n   (snd `\n    (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter>\n     {(xs, uu_). lfinite xs}))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (\\<lambda>(xs1, b1) (xs2, b2).\n                     if lfinite xs1\n                     then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                          xs1 = xs2 \\<and> flat_ord b b1 b2\n                     else xs1 = xs2)\n                 Y;\n        \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> (case apfst ltl\n                                (lSup (fst ` Y),\n                                 flat_lub b\n                                  (snd `\n                                   (Y \\<inter> {(xs, uu_). lfinite xs}))) of\n                          (xs, a) \\<Rightarrow>\n                            \\<lambda>(ys, b).\n                               xs = ys \\<and>\n                               (lfinite ys \\<longrightarrow> a = b))\n                          (lSup\n                            (fst `\n                             apfst ltl `\n                             (Y \\<inter> {(xs, b). \\<not> lnull xs})),\n                           flat_lub b\n                            (snd `\n                             (apfst ltl `\n                              (Y \\<inter>\n                               {(xs, b). \\<not> lnull xs}) \\<inter>\n                              {(xs, uu_). lfinite xs})))", "also"], ["proof (state)\nthis:\n  insert b (snd ` (Y \\<inter> {(xs, uu_). lfinite xs})) =\n  insert b\n   (snd `\n    (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter>\n     {(xs, uu_). lfinite xs}))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (\\<lambda>(xs1, b1) (xs2, b2).\n                     if lfinite xs1\n                     then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                          xs1 = xs2 \\<and> flat_ord b b1 b2\n                     else xs1 = xs2)\n                 Y;\n        \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> (case apfst ltl\n                                (lSup (fst ` Y),\n                                 flat_lub b\n                                  (snd `\n                                   (Y \\<inter> {(xs, uu_). lfinite xs}))) of\n                          (xs, a) \\<Rightarrow>\n                            \\<lambda>(ys, b).\n                               xs = ys \\<and>\n                               (lfinite ys \\<longrightarrow> a = b))\n                          (lSup\n                            (fst `\n                             apfst ltl `\n                             (Y \\<inter> {(xs, b). \\<not> lnull xs})),\n                           flat_lub b\n                            (snd `\n                             (apfst ltl `\n                              (Y \\<inter>\n                               {(xs, b). \\<not> lnull xs}) \\<inter>\n                              {(xs, uu_). lfinite xs})))", "have \"flat_lub b \\<dots> = flat_lub b (snd ` (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter> {(xs, _). lfinite xs}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_lub b\n     (insert b\n       (snd `\n        (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter>\n         {(xs, uu_). lfinite xs}))) =\n    flat_lub b\n     (snd `\n      (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter>\n       {(xs, uu_). lfinite xs}))", "by(auto simp add: flat_lub_def)"], ["proof (state)\nthis:\n  flat_lub b\n   (insert b\n     (snd `\n      (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter>\n       {(xs, uu_). lfinite xs}))) =\n  flat_lub b\n   (snd `\n    (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter>\n     {(xs, uu_). lfinite xs}))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (\\<lambda>(xs1, b1) (xs2, b2).\n                     if lfinite xs1\n                     then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                          xs1 = xs2 \\<and> flat_ord b b1 b2\n                     else xs1 = xs2)\n                 Y;\n        \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> (case apfst ltl\n                                (lSup (fst ` Y),\n                                 flat_lub b\n                                  (snd `\n                                   (Y \\<inter> {(xs, uu_). lfinite xs}))) of\n                          (xs, a) \\<Rightarrow>\n                            \\<lambda>(ys, b).\n                               xs = ys \\<and>\n                               (lfinite ys \\<longrightarrow> a = b))\n                          (lSup\n                            (fst `\n                             apfst ltl `\n                             (Y \\<inter> {(xs, b). \\<not> lnull xs})),\n                           flat_lub b\n                            (snd `\n                             (apfst ltl `\n                              (Y \\<inter>\n                               {(xs, b). \\<not> lnull xs}) \\<inter>\n                              {(xs, uu_). lfinite xs})))", "also"], ["proof (state)\nthis:\n  flat_lub b\n   (insert b\n     (snd `\n      (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter>\n       {(xs, uu_). lfinite xs}))) =\n  flat_lub b\n   (snd `\n    (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter>\n     {(xs, uu_). lfinite xs}))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (\\<lambda>(xs1, b1) (xs2, b2).\n                     if lfinite xs1\n                     then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                          xs1 = xs2 \\<and> flat_ord b b1 b2\n                     else xs1 = xs2)\n                 Y;\n        \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> (case apfst ltl\n                                (lSup (fst ` Y),\n                                 flat_lub b\n                                  (snd `\n                                   (Y \\<inter> {(xs, uu_). lfinite xs}))) of\n                          (xs, a) \\<Rightarrow>\n                            \\<lambda>(ys, b).\n                               xs = ys \\<and>\n                               (lfinite ys \\<longrightarrow> a = b))\n                          (lSup\n                            (fst `\n                             apfst ltl `\n                             (Y \\<inter> {(xs, b). \\<not> lnull xs})),\n                           flat_lub b\n                            (snd `\n                             (apfst ltl `\n                              (Y \\<inter>\n                               {(xs, b). \\<not> lnull xs}) \\<inter>\n                              {(xs, uu_). lfinite xs})))", "have \"ltl ` (fst ` Y \\<inter> {xs. \\<not> lnull xs}) = fst ` apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl ` (fst ` Y \\<inter> {xs. \\<not> lnull xs}) =\n    fst ` apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs})", "by(auto simp add: image_image)"], ["proof (state)\nthis:\n  ltl ` (fst ` Y \\<inter> {xs. \\<not> lnull xs}) =\n  fst ` apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs})\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (\\<lambda>(xs1, b1) (xs2, b2).\n                     if lfinite xs1\n                     then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                          xs1 = xs2 \\<and> flat_ord b b1 b2\n                     else xs1 = xs2)\n                 Y;\n        \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> (case apfst ltl\n                                (lSup (fst ` Y),\n                                 flat_lub b\n                                  (snd `\n                                   (Y \\<inter> {(xs, uu_). lfinite xs}))) of\n                          (xs, a) \\<Rightarrow>\n                            \\<lambda>(ys, b).\n                               xs = ys \\<and>\n                               (lfinite ys \\<longrightarrow> a = b))\n                          (lSup\n                            (fst `\n                             apfst ltl `\n                             (Y \\<inter> {(xs, b). \\<not> lnull xs})),\n                           flat_lub b\n                            (snd `\n                             (apfst ltl `\n                              (Y \\<inter>\n                               {(xs, b). \\<not> lnull xs}) \\<inter>\n                              {(xs, uu_). lfinite xs})))", "ultimately"], ["proof (chain)\npicking this:\n  flat_lub b\n   (snd ` (Y \\<inter> {a. case a of (xs, uu_) \\<Rightarrow> lfinite xs})) =\n  flat_lub b\n   (snd `\n    (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter>\n     {(xs, uu_). lfinite xs}))\n  ltl ` (fst ` Y \\<inter> {xs. \\<not> lnull xs}) =\n  fst ` apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs})", "show ?case"], ["proof (prove)\nusing this:\n  flat_lub b\n   (snd ` (Y \\<inter> {a. case a of (xs, uu_) \\<Rightarrow> lfinite xs})) =\n  flat_lub b\n   (snd `\n    (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter>\n     {(xs, uu_). lfinite xs}))\n  ltl ` (fst ` Y \\<inter> {xs. \\<not> lnull xs}) =\n  fst ` apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs})\n\ngoal (1 subgoal):\n 1. (case apfst ltl\n           (lSup (fst ` Y),\n            flat_lub b (snd ` (Y \\<inter> {(xs, uu_). lfinite xs}))) of\n     (xs, a) \\<Rightarrow>\n       \\<lambda>(ys, b).\n          xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n     (lSup (fst ` apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs})),\n      flat_lub b\n       (snd `\n        (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter>\n         {(xs, uu_). lfinite xs})))", "using prems"], ["proof (prove)\nusing this:\n  flat_lub b\n   (snd ` (Y \\<inter> {a. case a of (xs, uu_) \\<Rightarrow> lfinite xs})) =\n  flat_lub b\n   (snd `\n    (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter>\n     {(xs, uu_). lfinite xs}))\n  ltl ` (fst ` Y \\<inter> {xs. \\<not> lnull xs}) =\n  fst ` apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs})\n  Complete_Partial_Order.chain\n   (\\<lambda>(xs1, b1) (xs2, b2).\n       if lfinite xs1\n       then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n            xs1 = xs2 \\<and> flat_ord b b1 b2\n       else xs1 = xs2)\n   Y\n  \\<exists>(xs, b)\\<in>Y. \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. (case apfst ltl\n           (lSup (fst ` Y),\n            flat_lub b (snd ` (Y \\<inter> {(xs, uu_). lfinite xs}))) of\n     (xs, a) \\<Rightarrow>\n       \\<lambda>(ys, b).\n          xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n     (lSup (fst ` apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs})),\n      flat_lub b\n       (snd `\n        (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter>\n         {(xs, uu_). lfinite xs})))", "by clarsimp"], ["proof (state)\nthis:\n  (case apfst ltl\n         (lSup (fst ` Y),\n          flat_lub b (snd ` (Y \\<inter> {(xs, uu_). lfinite xs}))) of\n   (xs, a) \\<Rightarrow>\n     \\<lambda>(ys, b). xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n   (lSup (fst ` apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs})),\n    flat_lub b\n     (snd `\n      (apfst ltl ` (Y \\<inter> {(xs, b). \\<not> lnull xs}) \\<inter>\n       {(xs, uu_). lfinite xs})))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tSup_TCons: \"A \\<noteq> {} \\<Longrightarrow> tSup (TCons x ` A) = TCons x (tSup A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    local.tSup (TCons x ` A) = TCons x (local.tSup A)", "unfolding Set.is_empty_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty A \\<Longrightarrow>\n    local.tSup (TCons x ` A) = TCons x (local.tSup A)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x.\n       \\<not> Set.is_empty A \\<Longrightarrow>\n       (case (lSup (fst ` (apfst \\<circ> LCons) x ` A),\n              flat_lub b\n               (snd `\n                ((apfst \\<circ> LCons) x ` A \\<inter>\n                 {(xs, uu_). lfinite xs}))) of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        ((apfst \\<circ> LCons) x\n          (lSup (fst ` A),\n           flat_lub b (snd ` (A \\<inter> {(xs, uu_). lfinite xs}))))", "unfolding Set.is_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x.\n       A \\<noteq> {} \\<Longrightarrow>\n       (case (lSup (fst ` (apfst \\<circ> LCons) x ` A),\n              flat_lub b\n               (snd `\n                ((apfst \\<circ> LCons) x ` A \\<inter>\n                 {(xs, uu_). lfinite xs}))) of\n        (xs, a) \\<Rightarrow>\n          \\<lambda>(ys, b).\n             xs = ys \\<and> (lfinite ys \\<longrightarrow> a = b))\n        ((apfst \\<circ> LCons) x\n          (lSup (fst ` A),\n           flat_lub b (snd ` (A \\<inter> {(xs, uu_). lfinite xs}))))", "apply(clarsimp simp add: image_image lSup_LCons[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x.\n       \\<lbrakk>A \\<noteq> {};\n        lfinite (lSup ((\\<lambda>xa. LCons x (fst xa)) ` A))\\<rbrakk>\n       \\<Longrightarrow> flat_lub b\n                          (snd `\n                           (apfst (LCons x) ` A \\<inter>\n                            {(xs, uu_). lfinite xs})) =\n                         flat_lub b\n                          (snd ` (A \\<inter> {(xs, uu_). lfinite xs}))", "apply(rule arg_cong[where f=\"flat_lub b\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x.\n       \\<lbrakk>A \\<noteq> {};\n        lfinite (lSup ((\\<lambda>xa. LCons x (fst xa)) ` A))\\<rbrakk>\n       \\<Longrightarrow> snd `\n                         (apfst (LCons x) ` A \\<inter>\n                          {(xs, uu_). lfinite xs}) =\n                         snd ` (A \\<inter> {(xs, uu_). lfinite xs})", "apply(auto 4 3 intro: rev_image_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tllist_ord_terminalD:\n  \"\\<lbrakk> tllist_ord xs ys; is_TNil ys \\<rbrakk> \\<Longrightarrow> flat_ord b (terminal xs) (terminal ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.tllist_ord xs ys; is_TNil ys\\<rbrakk>\n    \\<Longrightarrow> flat_ord b (terminal xs) (terminal ys)", "by(cases xs)(auto simp add: is_TNil_def)"], ["", "lemma tllist_ord_bot [simp]: \"tllist_ord (TNil b) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tllist_ord (TNil b) xs", "by(cases xs)(simp_all add: flat_ord_def)"], ["", "lemma tllist_ord_ttlI:\n  \"tllist_ord xs ys \\<Longrightarrow> tllist_ord (ttl xs) (ttl ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tllist_ord xs ys \\<Longrightarrow>\n    local.tllist_ord (ttl xs) (ttl ys)", "by(cases xs ys rule: tllist.exhaust[case_product tllist.exhaust])(simp_all)"], ["", "lemma not_is_TNil_conv: \"\\<not> is_TNil xs \\<longleftrightarrow> (\\<exists>x xs'. xs = TCons x xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> is_TNil xs) = (\\<exists>x xs'. xs = TCons x xs')", "by(cases xs) simp_all"], ["", "subsection \\<open>Continuity of predefined constants\\<close>"], ["", "lemma mono_tllist_ord_case:\n  fixes bot\n  assumes mono: \"\\<And>x. monotone tllist_ord ord (\\<lambda>xs. f x xs (TCons x xs))\"\n  and ord: \"class.preorder ord (mk_less ord)\"\n  and bot: \"\\<And>x. ord (bot b) x\"\n  shows \"monotone tllist_ord ord (\\<lambda>xs. case xs of TNil b \\<Rightarrow> bot b | TCons x xs' \\<Rightarrow> f x xs' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone local.tllist_ord ord\n     (\\<lambda>xs.\n         case xs of TNil b \\<Rightarrow> bot b\n         | TCons x xs' \\<Rightarrow> f x xs' xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monotone local.tllist_ord ord\n     (\\<lambda>xs.\n         case xs of TNil b \\<Rightarrow> bot b\n         | TCons x xs' \\<Rightarrow> f x xs' xs)", "interpret preorder ord \"mk_less ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.preorder ord (mk_less ord)", "by (fact ord)"], ["proof (state)\ngoal (1 subgoal):\n 1. monotone local.tllist_ord ord\n     (\\<lambda>xs.\n         case xs of TNil b \\<Rightarrow> bot b\n         | TCons x xs' \\<Rightarrow> f x xs' xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone local.tllist_ord ord\n     (\\<lambda>xs.\n         case xs of TNil b \\<Rightarrow> bot b\n         | TCons x xs' \\<Rightarrow> f x xs' xs)", "by(rule monotoneI)(auto split: tllist.split dest: monotoneD[OF mono] simp add: flat_ord_def bot)"], ["proof (state)\nthis:\n  monotone local.tllist_ord ord\n   (\\<lambda>xs.\n       case xs of TNil b \\<Rightarrow> bot b\n       | TCons x xs' \\<Rightarrow> f x xs' xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mcont_lprefix_case_aux:\n  fixes f bot ord\n  defines \"g \\<equiv> \\<lambda>xs. f (thd xs) (ttl xs) (TCons (thd xs) (ttl xs))\"\n  assumes mcont: \"\\<And>x. mcont tSup tllist_ord lub ord (\\<lambda>xs. f x xs (TCons x xs))\"\n  and ccpo: \"class.ccpo lub ord (mk_less ord)\"\n  and bot: \"\\<And>x. ord (bot b) x\"\n  and cont_bot: \"cont (flat_lub b) (flat_ord b) lub ord bot\"\n  shows \"mcont tSup tllist_ord lub ord (\\<lambda>xs. case xs of TNil b \\<Rightarrow> bot b | TCons x xs' \\<Rightarrow> f x xs' xs)\"\n  (is \"mcont _ _ _ _ ?f\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont local.tSup local.tllist_ord lub ord\n     (\\<lambda>xs.\n         case xs of TNil b \\<Rightarrow> bot b\n         | TCons x xs' \\<Rightarrow> f x xs' xs)", "proof(rule mcontI)"], ["proof (state)\ngoal (2 subgoals):\n 1. monotone local.tllist_ord ord\n     (\\<lambda>xs.\n         case xs of TNil b \\<Rightarrow> bot b\n         | TCons x xs' \\<Rightarrow> f x xs' xs)\n 2. cont local.tSup local.tllist_ord lub ord\n     (\\<lambda>xs.\n         case xs of TNil b \\<Rightarrow> bot b\n         | TCons x xs' \\<Rightarrow> f x xs' xs)", "interpret b: ccpo lub ord \"mk_less ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo lub ord (mk_less ord)", "by(rule ccpo)"], ["proof (state)\ngoal (2 subgoals):\n 1. monotone local.tllist_ord ord\n     (\\<lambda>xs.\n         case xs of TNil b \\<Rightarrow> bot b\n         | TCons x xs' \\<Rightarrow> f x xs' xs)\n 2. cont local.tSup local.tllist_ord lub ord\n     (\\<lambda>xs.\n         case xs of TNil b \\<Rightarrow> bot b\n         | TCons x xs' \\<Rightarrow> f x xs' xs)", "show \"cont tSup tllist_ord lub ord ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont local.tSup local.tllist_ord lub ord\n     (\\<lambda>xs.\n         case xs of TNil b \\<Rightarrow> bot b\n         | TCons x xs' \\<Rightarrow> f x xs' xs)", "proof(rule contI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain local.tllist_ord Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (case local.tSup Y of TNil b \\<Rightarrow> bot b\n                          | TCons x xs' \\<Rightarrow>\n                              f x xs' (local.tSup Y)) =\n                         lub ((\\<lambda>xs.\n                                  case xs of TNil b \\<Rightarrow> bot b\n                                  | TCons x xs' \\<Rightarrow> f x xs' xs) `\n                              Y)", "fix Y :: \"('a, 'b) tllist set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain local.tllist_ord Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (case local.tSup Y of TNil b \\<Rightarrow> bot b\n                          | TCons x xs' \\<Rightarrow>\n                              f x xs' (local.tSup Y)) =\n                         lub ((\\<lambda>xs.\n                                  case xs of TNil b \\<Rightarrow> bot b\n                                  | TCons x xs' \\<Rightarrow> f x xs' xs) `\n                              Y)", "assume chain: \"Complete_Partial_Order.chain tllist_ord Y\"\n      and Y: \"Y \\<noteq> {}\""], ["proof (state)\nthis:\n  Complete_Partial_Order.chain local.tllist_ord Y\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain local.tllist_ord Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (case local.tSup Y of TNil b \\<Rightarrow> bot b\n                          | TCons x xs' \\<Rightarrow>\n                              f x xs' (local.tSup Y)) =\n                         lub ((\\<lambda>xs.\n                                  case xs of TNil b \\<Rightarrow> bot b\n                                  | TCons x xs' \\<Rightarrow> f x xs' xs) `\n                              Y)", "from chain"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain local.tllist_ord Y", "have chain': \"Complete_Partial_Order.chain ord (?f ` Y)\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain local.tllist_ord Y\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain ord\n     ((\\<lambda>xs.\n          case xs of TNil b \\<Rightarrow> bot b\n          | TCons x xs' \\<Rightarrow> f x xs' xs) `\n      Y)", "by(rule chain_imageI)(auto split: tllist.split simp add: flat_ord_def intro!: bot mcont_monoD[OF mcont])"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain ord\n   ((\\<lambda>xs.\n        case xs of TNil b \\<Rightarrow> bot b\n        | TCons x xs' \\<Rightarrow> f x xs' xs) `\n    Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain local.tllist_ord Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (case local.tSup Y of TNil b \\<Rightarrow> bot b\n                          | TCons x xs' \\<Rightarrow>\n                              f x xs' (local.tSup Y)) =\n                         lub ((\\<lambda>xs.\n                                  case xs of TNil b \\<Rightarrow> bot b\n                                  | TCons x xs' \\<Rightarrow> f x xs' xs) `\n                              Y)", "show \"?f (tSup Y) = lub (?f ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "proof(cases \"is_TNil (tSup Y)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)\n 2. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "case True"], ["proof (state)\nthis:\n  is_TNil (local.tSup Y)\n\ngoal (2 subgoals):\n 1. is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)\n 2. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "hence \"?f ` Y = bot ` terminal ` Y\""], ["proof (prove)\nusing this:\n  is_TNil (local.tSup Y)\n\ngoal (1 subgoal):\n 1. (\\<lambda>xs.\n        case xs of TNil b \\<Rightarrow> bot b\n        | TCons x xs' \\<Rightarrow> f x xs' xs) `\n    Y =\n    bot ` terminal ` Y", "by(auto 4 3 split: tllist.split intro: rev_image_eqI intro!: imageI)"], ["proof (state)\nthis:\n  (\\<lambda>xs.\n      case xs of TNil b \\<Rightarrow> bot b\n      | TCons x xs' \\<Rightarrow> f x xs' xs) `\n  Y =\n  bot ` terminal ` Y\n\ngoal (2 subgoals):\n 1. is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)\n 2. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>xs.\n      case xs of TNil b \\<Rightarrow> bot b\n      | TCons x xs' \\<Rightarrow> f x xs' xs) `\n  Y =\n  bot ` terminal ` Y\n\ngoal (2 subgoals):\n 1. is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)\n 2. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "from True"], ["proof (chain)\npicking this:\n  is_TNil (local.tSup Y)", "have \"tSup Y = TNil (flat_lub b (terminal ` Y))\""], ["proof (prove)\nusing this:\n  is_TNil (local.tSup Y)\n\ngoal (1 subgoal):\n 1. local.tSup Y = TNil (flat_lub b (terminal ` Y))", "by -(rule tllist.expand, simp_all add: terminal_tSup)"], ["proof (state)\nthis:\n  local.tSup Y = TNil (flat_lub b (terminal ` Y))\n\ngoal (2 subgoals):\n 1. is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)\n 2. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "moreover"], ["proof (state)\nthis:\n  local.tSup Y = TNil (flat_lub b (terminal ` Y))\n\ngoal (2 subgoals):\n 1. is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)\n 2. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "have \"Complete_Partial_Order.chain (flat_ord b) (terminal ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (flat_ord b) (terminal ` Y)", "using chain True"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain local.tllist_ord Y\n  is_TNil (local.tSup Y)\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (flat_ord b) (terminal ` Y)", "by(auto intro: chain_imageI tllist_ord_terminalD)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (flat_ord b) (terminal ` Y)\n\ngoal (2 subgoals):\n 1. is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)\n 2. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>xs.\n      case xs of TNil b \\<Rightarrow> bot b\n      | TCons x xs' \\<Rightarrow> f x xs' xs) `\n  Y =\n  bot ` terminal ` Y\n  local.tSup Y = TNil (flat_lub b (terminal ` Y))\n  Complete_Partial_Order.chain (flat_ord b) (terminal ` Y)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>xs.\n      case xs of TNil b \\<Rightarrow> bot b\n      | TCons x xs' \\<Rightarrow> f x xs' xs) `\n  Y =\n  bot ` terminal ` Y\n  local.tSup Y = TNil (flat_lub b (terminal ` Y))\n  Complete_Partial_Order.chain (flat_ord b) (terminal ` Y)\n\ngoal (1 subgoal):\n 1. (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "using Y"], ["proof (prove)\nusing this:\n  (\\<lambda>xs.\n      case xs of TNil b \\<Rightarrow> bot b\n      | TCons x xs' \\<Rightarrow> f x xs' xs) `\n  Y =\n  bot ` terminal ` Y\n  local.tSup Y = TNil (flat_lub b (terminal ` Y))\n  Complete_Partial_Order.chain (flat_ord b) (terminal ` Y)\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "by (simp add: contD [OF cont_bot] cong del: b.SUP_cong_simp)"], ["proof (state)\nthis:\n  (case local.tSup Y of TNil b \\<Rightarrow> bot b\n   | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n  lub ((\\<lambda>xs.\n           case xs of TNil b \\<Rightarrow> bot b\n           | TCons x xs' \\<Rightarrow> f x xs' xs) `\n       Y)\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "case False"], ["proof (state)\nthis:\n  \\<not> is_TNil (local.tSup Y)\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "hence eq: \"tSup Y = TCons (thd (tSup Y)) (ttl (tSup Y))\""], ["proof (prove)\nusing this:\n  \\<not> is_TNil (local.tSup Y)\n\ngoal (1 subgoal):\n 1. local.tSup Y = TCons (thd (local.tSup Y)) (ttl (local.tSup Y))", "by simp"], ["proof (state)\nthis:\n  local.tSup Y = TCons (thd (local.tSup Y)) (ttl (local.tSup Y))\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "have eq': \n        \"?f ` Y =\n         (\\<lambda>x. bot (terminal x)) ` (Y \\<inter> {xs. is_TNil xs}) \\<union>\n         (\\<lambda>xs. f (thd xs) (ttl xs) xs) ` (Y \\<inter> {xs. \\<not> is_TNil xs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xs.\n        case xs of TNil b \\<Rightarrow> bot b\n        | TCons x xs' \\<Rightarrow> f x xs' xs) `\n    Y =\n    (\\<lambda>x. bot (terminal x)) ` (Y \\<inter> {xs. is_TNil xs}) \\<union>\n    (\\<lambda>xs. f (thd xs) (ttl xs) xs) `\n    (Y \\<inter> {xs. \\<not> is_TNil xs})", "by(auto 4 3 split: tllist.splits intro: rev_image_eqI)"], ["proof (state)\nthis:\n  (\\<lambda>xs.\n      case xs of TNil b \\<Rightarrow> bot b\n      | TCons x xs' \\<Rightarrow> f x xs' xs) `\n  Y =\n  (\\<lambda>x. bot (terminal x)) ` (Y \\<inter> {xs. is_TNil xs}) \\<union>\n  (\\<lambda>xs. f (thd xs) (ttl xs) xs) `\n  (Y \\<inter> {xs. \\<not> is_TNil xs})\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "from False"], ["proof (chain)\npicking this:\n  \\<not> is_TNil (local.tSup Y)", "obtain xs where xs: \"xs \\<in> Y\" \"\\<not> is_TNil xs\""], ["proof (prove)\nusing this:\n  \\<not> is_TNil (local.tSup Y)\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>xs \\<in> Y; \\<not> is_TNil xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs \\<in> Y\n  \\<not> is_TNil xs\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "{"], ["proof (state)\nthis:\n  xs \\<in> Y\n  \\<not> is_TNil xs\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "fix ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "assume \"ys \\<in> Y\" \"is_TNil ys\""], ["proof (state)\nthis:\n  ys \\<in> Y\n  is_TNil ys\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "hence \"terminal ys = b\""], ["proof (prove)\nusing this:\n  ys \\<in> Y\n  is_TNil ys\n\ngoal (1 subgoal):\n 1. terminal ys = b", "using xs"], ["proof (prove)\nusing this:\n  ys \\<in> Y\n  is_TNil ys\n  xs \\<in> Y\n  \\<not> is_TNil xs\n\ngoal (1 subgoal):\n 1. terminal ys = b", "by(cases xs ys rule: tllist.exhaust[case_product tllist.exhaust])(auto dest: chainD[OF chain])"], ["proof (state)\nthis:\n  terminal ys = b\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ys6 \\<in> Y; is_TNil ?ys6\\<rbrakk>\n  \\<Longrightarrow> terminal ?ys6 = b\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?ys6 \\<in> Y; is_TNil ?ys6\\<rbrakk>\n  \\<Longrightarrow> terminal ?ys6 = b", "have lub: \"lub (?f ` Y) = lub ((\\<lambda>xs. f (thd xs) (ttl xs) xs) ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?ys6 \\<in> Y; is_TNil ?ys6\\<rbrakk>\n  \\<Longrightarrow> terminal ?ys6 = b\n\ngoal (1 subgoal):\n 1. lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y) =\n    lub ((\\<lambda>xs. f (thd xs) (ttl xs) xs) `\n         (Y \\<inter> {xs. \\<not> is_TNil xs}))", "using xs chain'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ys6 \\<in> Y; is_TNil ?ys6\\<rbrakk>\n  \\<Longrightarrow> terminal ?ys6 = b\n  xs \\<in> Y\n  \\<not> is_TNil xs\n  Complete_Partial_Order.chain ord\n   ((\\<lambda>xs.\n        case xs of TNil b \\<Rightarrow> bot b\n        | TCons x xs' \\<Rightarrow> f x xs' xs) `\n    Y)\n\ngoal (1 subgoal):\n 1. lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y) =\n    lub ((\\<lambda>xs. f (thd xs) (ttl xs) xs) `\n         (Y \\<inter> {xs. \\<not> is_TNil xs}))", "unfolding eq'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ys6 \\<in> Y; is_TNil ?ys6\\<rbrakk>\n  \\<Longrightarrow> terminal ?ys6 = b\n  xs \\<in> Y\n  \\<not> is_TNil xs\n  Complete_Partial_Order.chain ord\n   ((\\<lambda>x. bot (terminal x)) ` (Y \\<inter> Collect is_TNil) \\<union>\n    (\\<lambda>xs. f (thd xs) (ttl xs) xs) `\n    (Y \\<inter> {xs. \\<not> is_TNil xs}))\n\ngoal (1 subgoal):\n 1. lub ((\\<lambda>x. bot (terminal x)) `\n         (Y \\<inter> Collect is_TNil) \\<union>\n         (\\<lambda>xs. f (thd xs) (ttl xs) xs) `\n         (Y \\<inter> {xs. \\<not> is_TNil xs})) =\n    lub ((\\<lambda>xs. f (thd xs) (ttl xs) xs) `\n         (Y \\<inter> {xs. \\<not> is_TNil xs}))", "by -(erule ccpo.Sup_Un_less[OF ccpo], auto simp add: intro!: bot)"], ["proof (state)\nthis:\n  lub ((\\<lambda>xs.\n           case xs of TNil b \\<Rightarrow> bot b\n           | TCons x xs' \\<Rightarrow> f x xs' xs) `\n       Y) =\n  lub ((\\<lambda>xs. f (thd xs) (ttl xs) xs) `\n       (Y \\<inter> {xs. \\<not> is_TNil xs}))\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "{"], ["proof (state)\nthis:\n  lub ((\\<lambda>xs.\n           case xs of TNil b \\<Rightarrow> bot b\n           | TCons x xs' \\<Rightarrow> f x xs' xs) `\n       Y) =\n  lub ((\\<lambda>xs. f (thd xs) (ttl xs) xs) `\n       (Y \\<inter> {xs. \\<not> is_TNil xs}))\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "assume xs:  \"xs \\<in> Y \\<inter> {xs. \\<not> is_TNil xs}\""], ["proof (state)\nthis:\n  xs \\<in> Y \\<inter> {xs. \\<not> is_TNil xs}\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "hence \"(THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs})) = thd xs\""], ["proof (prove)\nusing this:\n  xs \\<in> Y \\<inter> {xs. \\<not> is_TNil xs}\n\ngoal (1 subgoal):\n 1. (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs})) = thd xs", "by(auto dest: chainD[OF chain] simp add: not_is_TNil_conv intro!: the_equality)"], ["proof (state)\nthis:\n  (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs})) = thd xs\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "hence \"f (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs})) (ttl xs) (TCons (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs})) (ttl xs)) = f (thd xs) (ttl xs) xs\""], ["proof (prove)\nusing this:\n  (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs})) = thd xs\n\ngoal (1 subgoal):\n 1. f (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs})) (ttl xs)\n     (TCons (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\n       (ttl xs)) =\n    f (thd xs) (ttl xs) xs", "using xs"], ["proof (prove)\nusing this:\n  (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs})) = thd xs\n  xs \\<in> Y \\<inter> {xs. \\<not> is_TNil xs}\n\ngoal (1 subgoal):\n 1. f (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs})) (ttl xs)\n     (TCons (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\n       (ttl xs)) =\n    f (thd xs) (ttl xs) xs", "by simp"], ["proof (state)\nthis:\n  f (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs})) (ttl xs)\n   (TCons (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\n     (ttl xs)) =\n  f (thd xs) (ttl xs) xs\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "}"], ["proof (state)\nthis:\n  ?xsa6 \\<in> Y \\<inter> {xs. \\<not> is_TNil xs} \\<Longrightarrow>\n  f (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs})) (ttl ?xsa6)\n   (TCons (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\n     (ttl ?xsa6)) =\n  f (thd ?xsa6) (ttl ?xsa6) ?xsa6\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "moreover"], ["proof (state)\nthis:\n  ?xsa6 \\<in> Y \\<inter> {xs. \\<not> is_TNil xs} \\<Longrightarrow>\n  f (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs})) (ttl ?xsa6)\n   (TCons (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\n     (ttl ?xsa6)) =\n  f (thd ?xsa6) (ttl ?xsa6) ?xsa6\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "have \"Complete_Partial_Order.chain tllist_ord (ttl ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain local.tllist_ord\n     (ttl ` (Y \\<inter> {xs. \\<not> is_TNil xs}))", "using chain"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain local.tllist_ord Y\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain local.tllist_ord\n     (ttl ` (Y \\<inter> {xs. \\<not> is_TNil xs}))", "by(rule chain_imageI[OF chain_subset])(auto simp add: tllist_ord_ttlI)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain local.tllist_ord\n   (ttl ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "moreover"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain local.tllist_ord\n   (ttl ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "from False"], ["proof (chain)\npicking this:\n  \\<not> is_TNil (local.tSup Y)", "have \"Y \\<inter> {xs. \\<not> is_TNil xs} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> is_TNil (local.tSup Y)\n\ngoal (1 subgoal):\n 1. Y \\<inter> {xs. \\<not> is_TNil xs} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Y \\<inter> {xs. \\<not> is_TNil xs} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> is_TNil (local.tSup Y) \\<Longrightarrow>\n    (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "ultimately"], ["proof (chain)\npicking this:\n  ?xsa6 \\<in> Y \\<inter> {xs. \\<not> is_TNil xs} \\<Longrightarrow>\n  f (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs})) (ttl ?xsa6)\n   (TCons (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\n     (ttl ?xsa6)) =\n  f (thd ?xsa6) (ttl ?xsa6) ?xsa6\n  Complete_Partial_Order.chain local.tllist_ord\n   (ttl ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\n  Y \\<inter> {xs. \\<not> is_TNil xs} \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?xsa6 \\<in> Y \\<inter> {xs. \\<not> is_TNil xs} \\<Longrightarrow>\n  f (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs})) (ttl ?xsa6)\n   (TCons (THE x. x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\n     (ttl ?xsa6)) =\n  f (thd ?xsa6) (ttl ?xsa6) ?xsa6\n  Complete_Partial_Order.chain local.tllist_ord\n   (ttl ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\n  Y \\<inter> {xs. \\<not> is_TNil xs} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (case local.tSup Y of TNil b \\<Rightarrow> bot b\n     | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n    lub ((\\<lambda>xs.\n             case xs of TNil b \\<Rightarrow> bot b\n             | TCons x xs' \\<Rightarrow> f x xs' xs) `\n         Y)", "apply(subst (1 2) eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xsa.\n                xsa\n                \\<in> Y \\<inter> {xs. \\<not> is_TNil xs} \\<Longrightarrow>\n                f (THE x.\n                      x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\n                 (ttl xsa)\n                 (TCons\n                   (THE x.\n                       x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\n                   (ttl xsa)) =\n                f (thd xsa) (ttl xsa) xsa;\n     Complete_Partial_Order.chain local.tllist_ord\n      (ttl ` (Y \\<inter> {xs. \\<not> is_TNil xs}));\n     Y \\<inter> {xs. \\<not> is_TNil xs} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (case TCons (thd (local.tSup Y))\n                             (ttl (local.tSup Y)) of\n                       TNil x \\<Rightarrow> bot x\n                       | TCons x xs' \\<Rightarrow>\n                           f x xs'\n                            (TCons (thd (local.tSup Y))\n                              (ttl (local.tSup Y)))) =\n                      lub ((\\<lambda>xs.\n                               case xs of TNil x \\<Rightarrow> bot x\n                               | TCons x xs' \\<Rightarrow> f x xs' xs) `\n                           Y)", "using False"], ["proof (prove)\nusing this:\n  \\<not> is_TNil (local.tSup Y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xsa.\n                xsa\n                \\<in> Y \\<inter> {xs. \\<not> is_TNil xs} \\<Longrightarrow>\n                f (THE x.\n                      x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\n                 (ttl xsa)\n                 (TCons\n                   (THE x.\n                       x \\<in> thd ` (Y \\<inter> {xs. \\<not> is_TNil xs}))\n                   (ttl xsa)) =\n                f (thd xsa) (ttl xsa) xsa;\n     Complete_Partial_Order.chain local.tllist_ord\n      (ttl ` (Y \\<inter> {xs. \\<not> is_TNil xs}));\n     Y \\<inter> {xs. \\<not> is_TNil xs} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (case TCons (thd (local.tSup Y))\n                             (ttl (local.tSup Y)) of\n                       TNil x \\<Rightarrow> bot x\n                       | TCons x xs' \\<Rightarrow>\n                           f x xs'\n                            (TCons (thd (local.tSup Y))\n                              (ttl (local.tSup Y)))) =\n                      lub ((\\<lambda>xs.\n                               case xs of TNil x \\<Rightarrow> bot x\n                               | TCons x xs' \\<Rightarrow> f x xs' xs) `\n                           Y)", "apply(simp add: thd_tSup ttl_tSup[OF chain] mcont_contD[OF mcont] image_image lub)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (case local.tSup Y of TNil b \\<Rightarrow> bot b\n   | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n  lub ((\\<lambda>xs.\n           case xs of TNil b \\<Rightarrow> bot b\n           | TCons x xs' \\<Rightarrow> f x xs' xs) `\n       Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (case local.tSup Y of TNil b \\<Rightarrow> bot b\n   | TCons x xs' \\<Rightarrow> f x xs' (local.tSup Y)) =\n  lub ((\\<lambda>xs.\n           case xs of TNil b \\<Rightarrow> bot b\n           | TCons x xs' \\<Rightarrow> f x xs' xs) `\n       Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cont local.tSup local.tllist_ord lub ord\n   (\\<lambda>xs.\n       case xs of TNil b \\<Rightarrow> bot b\n       | TCons x xs' \\<Rightarrow> f x xs' xs)\n\ngoal (1 subgoal):\n 1. monotone local.tllist_ord ord\n     (\\<lambda>xs.\n         case xs of TNil b \\<Rightarrow> bot b\n         | TCons x xs' \\<Rightarrow> f x xs' xs)", "from mcont_mono[OF mcont] _ bot"], ["proof (chain)\npicking this:\n  monotone local.tllist_ord ord (\\<lambda>xs. f ?x5 xs (TCons ?x5 xs))\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ord (bot b) ?x4", "show \"monotone tllist_ord ord ?f\""], ["proof (prove)\nusing this:\n  monotone local.tllist_ord ord (\\<lambda>xs. f ?x5 xs (TCons ?x5 xs))\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ord (bot b) ?x4\n\ngoal (1 subgoal):\n 1. monotone local.tllist_ord ord\n     (\\<lambda>xs.\n         case xs of TNil b \\<Rightarrow> bot b\n         | TCons x xs' \\<Rightarrow> f x xs' xs)", "by(rule mono_tllist_ord_case)(unfold_locales)"], ["proof (state)\nthis:\n  monotone local.tllist_ord ord\n   (\\<lambda>xs.\n       case xs of TNil b \\<Rightarrow> bot b\n       | TCons x xs' \\<Rightarrow> f x xs' xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cont_TNil [simp, cont_intro]: \"cont (flat_lub b) (flat_ord b) tSup tllist_ord TNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (flat_lub b) (flat_ord b) local.tSup local.tllist_ord TNil", "apply(rule contI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (flat_ord b) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> TNil (flat_lub b Y) = local.tSup (TNil ` Y)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (flat_ord b) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (case (LNil, flat_lub b Y) of\n                          (xs, a) \\<Rightarrow>\n                            \\<lambda>(ys, b).\n                               xs = ys \\<and>\n                               (lfinite ys \\<longrightarrow> a = b))\n                          (lSup (fst ` Pair LNil ` Y),\n                           flat_lub b\n                            (snd `\n                             (Pair LNil ` Y \\<inter>\n                              {(xs, uu_). lfinite xs})))", "apply(simp add: image_image image_constant_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (flat_ord b) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> flat_lub b Y =\n                         flat_lub b\n                          (snd `\n                           (Pair LNil ` Y \\<inter> {(xs, uu_). lfinite xs}))", "apply(rule arg_cong[where f=\"flat_lub b\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (flat_ord b) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Y =\n                         snd `\n                         (Pair LNil ` Y \\<inter> {(xs, uu_). lfinite xs})", "apply(auto intro: rev_image_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma monotone_TCons: \"monotone tllist_ord tllist_ord (TCons x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone local.tllist_ord local.tllist_ord (TCons x)", "by(rule monotoneI) simp"], ["", "lemmas mono2mono_TCons[cont_intro] = monotone_TCons[THEN tllist.mono2mono]"], ["", "lemma mcont_TCons: \"mcont tSup tllist_ord tSup tllist_ord (TCons x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont local.tSup local.tllist_ord local.tSup local.tllist_ord (TCons x)", "apply(rule mcontI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. monotone local.tllist_ord local.tllist_ord (TCons x)\n 2. cont local.tSup local.tllist_ord local.tSup local.tllist_ord (TCons x)", "apply(rule monotone_TCons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont local.tSup local.tllist_ord local.tSup local.tllist_ord (TCons x)", "apply(rule contI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain local.tllist_ord Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> TCons x (local.tSup Y) = local.tSup (TCons x ` Y)", "apply(simp add: tSup_TCons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas mcont2mcont_TCons[cont_intro] = mcont_TCons[THEN tllist.mcont2mcont]"], ["", "lemmas [transfer_rule del] = tllist_ord.transfer tSup.transfer"], ["", "lifting_update tllist.lifting"], ["", "lifting_forget tllist.lifting"], ["", "lemmas [transfer_rule] = tllist_ord.transfer tSup.transfer"], ["", "lemma mono2mono_tset[THEN lfp.mono2mono, cont_intro]:\n  shows smonotone_tset: \"monotone tllist_ord (\\<subseteq>) tset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone local.tllist_ord (\\<subseteq>) tset", "including tllist.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone local.tllist_ord (\\<subseteq>) tset", "by transfer(rule monotone_comp[OF _ monotone_lset], auto intro: monotoneI)"], ["", "lemma mcont2mcont_tset [THEN lfp.mcont2mcont, cont_intro]:\n  shows mcont_tset: \"mcont tSup tllist_ord Union (\\<subseteq>) tset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont local.tSup local.tllist_ord \\<Union> (\\<subseteq>) tset", "including tllist.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont local.tSup local.tllist_ord \\<Union> (\\<subseteq>) tset", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont\n     (\\<lambda>A.\n         (lSup (fst ` A),\n          flat_lub b (snd ` (A \\<inter> {(xs, uu_). lfinite xs}))))\n     (\\<lambda>(xs1, b1) (xs2, b2).\n         if lfinite xs1\n         then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n              xs1 = xs2 \\<and> flat_ord b b1 b2\n         else xs1 = xs2)\n     \\<Union> (\\<subseteq>) (lset \\<circ> fst)", "apply(rule mcont_comp[OF _ mcont_lset])"], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont\n     (\\<lambda>A.\n         (lSup (fst ` A),\n          flat_lub b (snd ` (A \\<inter> {(xs, uu_). lfinite xs}))))\n     (\\<lambda>(xs1, b1) (xs2, b2).\n         if lfinite xs1\n         then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n              xs1 = xs2 \\<and> flat_ord b b1 b2\n         else xs1 = xs2)\n     lSup lprefix fst", "unfolding mcont_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone\n     (\\<lambda>(xs1, b1) (xs2, b2).\n         if lfinite xs1\n         then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n              xs1 = xs2 \\<and> flat_ord b b1 b2\n         else xs1 = xs2)\n     lprefix fst \\<and>\n    cont\n     (\\<lambda>A.\n         (lSup (fst ` A),\n          flat_lub b (snd ` (A \\<inter> {(xs, uu_). lfinite xs}))))\n     (\\<lambda>(xs1, b1) (xs2, b2).\n         if lfinite xs1\n         then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n              xs1 = xs2 \\<and> flat_ord b b1 b2\n         else xs1 = xs2)\n     lSup lprefix fst", "by(auto intro: monotoneI contI )"], ["", "end"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma rel_fun_lift:\n  \"(\\<And>x. A (f x) (g x)) \\<Longrightarrow> ((=) ===> A) f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. A (f x) (g x)) \\<Longrightarrow> ((=) ===> A) f g", "by(simp add: rel_fun_def)"], ["", "lemma tllist_ord_transfer [transfer_rule]:\n  \"((=) ===> pcr_tllist (=) (=) ===> pcr_tllist (=) (=) ===> (=))\n     (\\<lambda>b (xs1, b1) (xs2, b2). if lfinite xs1 then b1 = b \\<and> lprefix xs1 xs2 \\<or> xs1 = xs2 \\<and> flat_ord b b1 b2 else xs1 = xs2)\n     tllist_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> pcr_tllist (=) (=) ===> pcr_tllist (=) (=) ===> (=))\n     (\\<lambda>b (xs1, b1) (xs2, b2).\n         if lfinite xs1\n         then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n              xs1 = xs2 \\<and> flat_ord b b1 b2\n         else xs1 = xs2)\n     tllist_ord", "by(rule rel_fun_lift)(rule tllist_ord.transfer)"], ["", "lemma tSup_transfer [transfer_rule]:\n  \"((=) ===> rel_set (pcr_tllist (=) (=)) ===> pcr_tllist (=) (=))\n     (\\<lambda>b A. (lSup (fst ` A), flat_lub b (snd ` (A \\<inter> {(xs, _). lfinite xs}))))\n     tSup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> rel_set (pcr_tllist (=) (=)) ===> pcr_tllist (=) (=))\n     (\\<lambda>b A.\n         (lSup (fst ` A),\n          flat_lub b (snd ` (A \\<inter> {(xs, uu_). lfinite xs}))))\n     tSup", "by(rule rel_fun_lift)(rule tSup.transfer)"], ["", "end"], ["", "lifting_update tllist.lifting"], ["", "lifting_forget tllist.lifting"], ["", "interpretation tllist: partial_function_definitions \"tllist_ord b\" \"tSup b\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_function_definitions (tllist_ord b) (tSup b)", "by(rule tllist_ord_partial_function_definitions)"], ["", "lemma tllist_case_mono [partial_function_mono, cont_intro]: \n  assumes tnil: \"\\<And>b. monotone orda ordb (\\<lambda>f. tnil f b)\"\n  and tcons: \"\\<And>x xs. monotone orda ordb (\\<lambda>f. tcons f x xs)\"\n  shows \"monotone orda ordb (\\<lambda>f. case_tllist (tnil f) (tcons f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone orda ordb\n     (\\<lambda>f.\n         case xs of TNil x \\<Rightarrow> tnil f x\n         | TCons x xa \\<Rightarrow> tcons f x xa)", "by(rule monotoneI)(auto split: tllist.split dest: monotoneD[OF tnil] monotoneD[OF tcons])"], ["", "subsection \\<open>Definition of recursive functions\\<close>"], ["", "locale tllist_pf = fixes b :: 'b\nbegin"], ["", "declaration \\<open>Partial_Function.init \"tllist\" @{term \"tllist.fixp_fun b\"}\n  @{term \"tllist.mono_body b\"} @{thm tllist.fixp_rule_uc[where b=b]} @{thm tllist.fixp_induct_uc[where b=b]} NONE\\<close>"], ["", "abbreviation mono_tllist where \"mono_tllist \\<equiv> monotone (fun_ord (tllist_ord b)) (tllist_ord b)\""], ["", "lemma LCons_mono [partial_function_mono, cont_intro]:\n  \"mono_tllist A \\<Longrightarrow> mono_tllist (\\<lambda>f. TCons x (A f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_tllist A \\<Longrightarrow> mono_tllist (\\<lambda>f. TCons x (A f))", "by(rule monotoneI)(auto dest: monotoneD)"], ["", "end"], ["", "lemma mono_tllist_lappendt2 [partial_function_mono]:\n  \"tllist_pf.mono_tllist b A \\<Longrightarrow> tllist_pf.mono_tllist b (\\<lambda>f. lappendt xs (A f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (tllist.le_fun b) (tllist_ord b) A \\<Longrightarrow>\n    monotone (tllist.le_fun b) (tllist_ord b)\n     (\\<lambda>f. lappendt xs (A f))", "apply(rule monotoneI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>monotone (tllist.le_fun b) (tllist_ord b) A;\n        tllist.le_fun b x y\\<rbrakk>\n       \\<Longrightarrow> tllist_ord b (lappendt xs (A x))\n                          (lappendt xs (A y))", "apply(drule (1) monotoneD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>tllist.le_fun b x y; tllist_ord b (A x) (A y)\\<rbrakk>\n       \\<Longrightarrow> tllist_ord b (lappendt xs (A x))\n                          (lappendt xs (A y))", "apply(simp add: tllist_ord.rep_eq split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>tllist.le_fun b x y; tfinite (A x);\n        terminal (A x) = b \\<and>\n        lprefix (llist_of_tllist (A x)) (llist_of_tllist (A y)) \\<or>\n        llist_of_tllist (A x) = llist_of_tllist (A y) \\<and>\n        flat_ord b (terminal (A x)) (terminal (A y))\\<rbrakk>\n       \\<Longrightarrow> (lfinite xs \\<longrightarrow>\n                          terminal (A x) = b \\<and>\n                          lprefix (llist_of_tllist (A x))\n                           (llist_of_tllist (A y)) \\<or>\n                          lappend xs (llist_of_tllist (A x)) =\n                          lappend xs (llist_of_tllist (A y)) \\<and>\n                          flat_ord b (terminal (A x))\n                           (terminal (A y))) \\<and>\n                         (\\<not> lfinite xs \\<longrightarrow>\n                          lappend xs (llist_of_tllist (A x)) =\n                          lappend xs (llist_of_tllist (A y)))", "apply(auto simp add: lappend_inf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mono_tllist_tappend2 [partial_function_mono]:\n  assumes \"\\<And>y. tllist_pf.mono_tllist b (C y)\"\n  shows \"tllist_pf.mono_tllist b (\\<lambda>f. tappend xs (\\<lambda>y. C y f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (tllist.le_fun b) (tllist_ord b)\n     (\\<lambda>f. tappend xs (\\<lambda>y. C y f))", "apply(cases \"tfinite xs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. tfinite xs \\<Longrightarrow>\n    monotone (tllist.le_fun b) (tllist_ord b)\n     (\\<lambda>f. tappend xs (\\<lambda>y. C y f))\n 2. \\<not> tfinite xs \\<Longrightarrow>\n    monotone (tllist.le_fun b) (tllist_ord b)\n     (\\<lambda>f. tappend xs (\\<lambda>y. C y f))", "apply(rule monotoneI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>tfinite xs; tllist.le_fun b x y\\<rbrakk>\n       \\<Longrightarrow> tllist_ord b (tappend xs (\\<lambda>y. C y x))\n                          (tappend xs (\\<lambda>ya. C ya y))\n 2. \\<not> tfinite xs \\<Longrightarrow>\n    monotone (tllist.le_fun b) (tllist_ord b)\n     (\\<lambda>f. tappend xs (\\<lambda>y. C y f))", "apply(drule monotoneD[OF assms[where y=\"terminal xs\"]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>tfinite xs;\n        tllist_ord b (C (terminal xs) x) (C (terminal xs) y)\\<rbrakk>\n       \\<Longrightarrow> tllist_ord b (tappend xs (\\<lambda>y. C y x))\n                          (tappend xs (\\<lambda>ya. C ya y))\n 2. \\<not> tfinite xs \\<Longrightarrow>\n    monotone (tllist.le_fun b) (tllist_ord b)\n     (\\<lambda>f. tappend xs (\\<lambda>y. C y f))", "including tllist.lifting"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>tfinite xs;\n        tllist_ord b (C (terminal xs) x) (C (terminal xs) y)\\<rbrakk>\n       \\<Longrightarrow> tllist_ord b (tappend xs (\\<lambda>y. C y x))\n                          (tappend xs (\\<lambda>ya. C ya y))\n 2. \\<not> tfinite xs \\<Longrightarrow>\n    monotone (tllist.le_fun b) (tllist_ord b)\n     (\\<lambda>f. tappend xs (\\<lambda>y. C y f))", "apply transfer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xs b C.\n       \\<lbrakk>lfinite (fst xs);\n        (case C (case xs of\n                 (xs, b) \\<Rightarrow> if lfinite xs then b else undefined)\n               x of\n         (xs1, b1) \\<Rightarrow>\n           \\<lambda>(xs2, b2).\n              if lfinite xs1\n              then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                   xs1 = xs2 \\<and> flat_ord b b1 b2\n              else xs1 = xs2)\n         (C (case xs of\n             (xs, b) \\<Rightarrow> if lfinite xs then b else undefined)\n           y)\\<rbrakk>\n       \\<Longrightarrow> (case (case xs of\n                                (xs, b) \\<Rightarrow>\n                                  \\<lambda>f. apfst (lappend xs) (f b))\n                                (\\<lambda>y. C y x) of\n                          (xs1, b1) \\<Rightarrow>\n                            \\<lambda>(xs2, b2).\n                               if lfinite xs1\n                               then b1 = b \\<and> lprefix xs1 xs2 \\<or>\n                                    xs1 = xs2 \\<and> flat_ord b b1 b2\n                               else xs1 = xs2)\n                          ((case xs of\n                            (xs, b) \\<Rightarrow>\n                              \\<lambda>f. apfst (lappend xs) (f b))\n                            (\\<lambda>ya. C ya y))\n 2. \\<not> tfinite xs \\<Longrightarrow>\n    monotone (tllist.le_fun b) (tllist_ord b)\n     (\\<lambda>f. tappend xs (\\<lambda>y. C y f))", "apply(fastforce split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> tfinite xs \\<Longrightarrow>\n    monotone (tllist.le_fun b) (tllist_ord b)\n     (\\<lambda>f. tappend xs (\\<lambda>y. C y f))", "apply(simp add: tappend_inf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}