{"file_name": "/home/qj213/afp-2021-10-22/thys/Coinductive/Coinductive_Nat.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Coinductive", "problem_names": ["lemma inj_enat [simp]: \"inj_on enat A\"", "lemma Sup_range_enat [simp]: \"Sup (range enat) = \\<infinity>\"", "lemmas eSuc_plus = iadd_Suc", "lemmas plus_enat_eq_0_conv = iadd_is_0", "lemma enat_add_sub_same:\n  fixes a b :: enat shows \"a \\<noteq> \\<infinity> \\<Longrightarrow> a + b - a = b\"", "lemma enat_the_enat: \"n \\<noteq> \\<infinity> \\<Longrightarrow> enat (the_enat n) = n\"", "lemma enat_min_eq_0_iff:\n  fixes a b :: enat\n  shows \"min a b = 0 \\<longleftrightarrow> a = 0 \\<or> b = 0\"", "lemma enat_le_plus_same: \"x \\<le> (x :: enat) + y\" \"x \\<le> y + x\"", "lemma the_enat_0 [simp]: \"the_enat 0 = 0\"", "lemma the_enat_eSuc: \"n \\<noteq> \\<infinity> \\<Longrightarrow> the_enat (eSuc n) = Suc (the_enat n)\"", "lemma enat_set_eq_UNIV [simp]: \"enat_set = UNIV\"", "lemma enat_coexhaust:\n  obtains (0) \"n = 0\"\n     | (eSuc) n' where \"n = eSuc n'\"", "lemma enat_cocase_0 [simp]: \"co.case_enat z s 0 = z\"", "lemma enat_cocase_eSuc [simp]: \"co.case_enat z s (eSuc n) = s n\"", "lemma neq_zero_conv_eSuc: \"n \\<noteq> 0 \\<longleftrightarrow> (\\<exists>n'. n = eSuc n')\"", "lemma enat_cocase_cert:\n  assumes \"CASE \\<equiv> co.case_enat c d\"\n  shows \"(CASE 0 \\<equiv> c) &&& (CASE (eSuc n) \\<equiv> d n)\"", "lemma enat_cosplit_asm:\n  \"P (co.case_enat c d n) = (\\<not> (n = 0 \\<and> \\<not> P c \\<or> (\\<exists>m. n = eSuc m \\<and> \\<not> P (d m))))\"", "lemma enat_cosplit:\n  \"P (co.case_enat c d n) = ((n = 0 \\<longrightarrow> P c) \\<and> (\\<forall>m. n = eSuc m \\<longrightarrow> P (d m)))\"", "lemma epred_0 [simp]: \"epred 0 = 0\"", "lemma epred_eSuc [simp]: \"epred (eSuc n) = n\"", "lemma epred_conv_minus: \"epred n = n - 1\"", "lemma case_enat_numeral [simp]: \"case_enat f i (numeral v) = (let n = numeral v in f n)\"", "lemma case_enat_0 [simp]: \"case_enat f i 0 = f 0\"", "lemma [simp]:\n  shows max_eSuc_eSuc: \"max (eSuc n) (eSuc m) = eSuc (max n m)\"\n  and min_eSuc_eSuc: \"min (eSuc n) (eSuc m) = eSuc (min n m)\"", "lemma numeral_eq_eSuc: \"numeral k = eSuc (epred_numeral k)\"", "lemma epred_numeral_simps [simp]:\n  \"epred_numeral num.One = 0\"\n  \"epred_numeral (num.Bit0 k) = numeral (Num.BitM k)\"\n  \"epred_numeral (num.Bit1 k) = numeral (num.Bit0 k)\"", "lemma [simp]:\n  shows eq_numeral_eSuc: \"numeral k = eSuc n \\<longleftrightarrow> epred_numeral k = n\"\n  and Suc_eq_numeral: \"eSuc n = numeral k \\<longleftrightarrow> n = epred_numeral k\"\n  and less_numeral_Suc: \"numeral k < eSuc n \\<longleftrightarrow> epred_numeral k < n\"\n  and less_eSuc_numeral: \"eSuc n < numeral k \\<longleftrightarrow> n < epred_numeral k\"\n  and le_numeral_eSuc: \"numeral k \\<le> eSuc n \\<longleftrightarrow> epred_numeral k \\<le> n\"\n  and le_eSuc_numeral: \"eSuc n \\<le> numeral k \\<longleftrightarrow> n \\<le> epred_numeral k\"\n  and diff_eSuc_numeral: \"eSuc n - numeral k = n - epred_numeral k\"\n  and diff_numeral_eSuc: \"numeral k - eSuc n = epred_numeral k - n\"\n  and max_eSuc_numeral: \"max (eSuc n) (numeral k) = eSuc (max n (epred_numeral k))\"\n  and max_numeral_eSuc: \"max (numeral k) (eSuc n) = eSuc (max (epred_numeral k) n)\"\n  and min_eSuc_numeral: \"min (eSuc n) (numeral k) = eSuc (min n (epred_numeral k))\"\n  and min_numeral_eSuc: \"min (numeral k) (eSuc n) = eSuc (min (epred_numeral k) n)\"", "lemma enat_cocase_numeral [simp]:\n  \"co.case_enat a f (numeral v) = (let pv = epred_numeral v in f pv)\"", "lemma enat_cocase_add_eq_if [simp]:\n  \"co.case_enat a f ((numeral v) + n) = (let pv = epred_numeral v in f (pv + n))\"", "lemma [simp]:\n  shows epred_1: \"epred 1 = 0\"\n  and epred_numeral: \"epred (numeral i) = epred_numeral i\"\n  and epred_Infty: \"epred \\<infinity> = \\<infinity>\"\n  and epred_enat: \"epred (enat m) = enat (m - 1)\"", "lemmas epred_simps = epred_0 epred_1 epred_numeral epred_eSuc epred_Infty epred_enat", "lemma epred_iadd1: \"a \\<noteq> 0 \\<Longrightarrow> epred (a + b) = epred a + b\"", "lemma epred_min [simp]: \"epred (min a b) = min (epred a) (epred b)\"", "lemma epred_le_epredI: \"n \\<le> m \\<Longrightarrow> epred n \\<le> epred m\"", "lemma epred_minus_epred [simp]:\n  \"m \\<noteq> 0 \\<Longrightarrow> epred n - epred m = n - m\"", "lemma eSuc_epred: \"n \\<noteq> 0 \\<Longrightarrow> eSuc (epred n) = n\"", "lemma epred_inject: \"\\<lbrakk> x \\<noteq> 0; y \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> epred x = epred y \\<longleftrightarrow> x = y\"", "lemma monotone_fun_eSuc[partial_function_mono]:\n    \"monotone (fun_ord (\\<lambda>y x. x \\<le> y)) (\\<lambda>y x. x \\<le> y) (\\<lambda>f. eSuc (f x))\"", "lemma enat_unfold_stop [simp]: \"stop a \\<Longrightarrow> enat_unfold stop next a = 0\"", "lemma enat_unfold_next: \"\\<not> stop a \\<Longrightarrow> enat_unfold stop next a = eSuc (enat_unfold stop next (next a))\"", "lemma enat_unfold_eq_0 [simp]:\n  \"enat_unfold stop next a = 0 \\<longleftrightarrow> stop a\"", "lemma epred_enat_unfold [simp]:\n  \"epred (enat_unfold stop next a) = (if stop a then 0 else enat_unfold stop next (next a))\"", "lemma epred_max: \"epred (max x y) = max (epred x) (epred y)\"", "lemma epred_Max:\n  assumes \"finite A\" \"A \\<noteq> {}\"\n  shows \"epred (Max A) = Max (epred ` A)\"", "lemma finite_imageD2: \"\\<lbrakk> finite (f ` A); inj_on f (A - B); finite B \\<rbrakk> \\<Longrightarrow> finite A\"", "lemma epred_Sup: \"epred (Sup A) = Sup (epred ` A)\"", "lemma ile_into_Le_enat:\n  \"m \\<le> n \\<Longrightarrow> (m, n) \\<in> Le_enat\"", "lemma Le_enat_imp_ile_enat_k:\n  \"(m, n) \\<in> Le_enat \\<Longrightarrow> n < enat l \\<Longrightarrow> m < enat l\"", "lemma enat_less_imp_le:\n  assumes k: \"!!k. n < enat k \\<Longrightarrow> m < enat k\"\n  shows \"m \\<le> n\"", "lemma Le_enat_imp_ile:\n  \"(m, n) \\<in> Le_enat \\<Longrightarrow> m \\<le> n\"", "lemma Le_enat_eq_ile:\n  \"(m, n) \\<in> Le_enat \\<longleftrightarrow> m \\<le> n\"", "lemma enat_leI [consumes 1, case_names Leenat, case_conclusion Leenat zero eSuc]:\n  assumes major: \"(m, n) \\<in> X\"\n  and step:\n    \"\\<And>m n. (m, n) \\<in> X \n     \\<Longrightarrow> m = 0 \\<or> (\\<exists>m' n' k. m = eSuc m' \\<and> n = n' + enat k \\<and> k \\<noteq> 0 \\<and>\n                           ((m', n') \\<in> X \\<or> m' \\<le> n'))\"\n  shows \"m \\<le> n\"", "lemma enat_le_coinduct[consumes 1, case_names le, case_conclusion le 0 eSuc]:\n  assumes P: \"P m n\"\n  and step:\n    \"\\<And>m n. P m n \n     \\<Longrightarrow> (n = 0 \\<longrightarrow> m = 0) \\<and>\n         (m \\<noteq> 0 \\<longrightarrow> n \\<noteq> 0 \\<longrightarrow> (\\<exists>k n'. P (epred m) n' \\<and> epred n = n' + k) \\<or> epred m \\<le> epred n)\"\n  shows \"m \\<le> n\"", "lemma enat_equalityI [consumes 1, case_names Eq_enat,\n                                  case_conclusion Eq_enat zero eSuc]:\n  assumes major: \"(m, n) \\<in> X\"\n  and step:\n    \"\\<And>m n. (m, n) \\<in> X\n     \\<Longrightarrow> m = 0 \\<and> n = 0 \\<or> (\\<exists>m' n'. m = eSuc m' \\<and> n = eSuc n' \\<and> ((m', n') \\<in> X \\<or> m' = n'))\"\n  shows \"m = n\"", "lemma enat_coinduct [consumes 1, case_names Eq_enat, case_conclusion Eq_enat zero eSuc]:\n  assumes major: \"P m n\"\n  and step: \"\\<And>m n. P m n \n    \\<Longrightarrow> (m = 0 \\<longleftrightarrow> n = 0) \\<and>\n       (m \\<noteq> 0 \\<longrightarrow> n \\<noteq> 0 \\<longrightarrow> P (epred m) (epred n) \\<or> epred m = epred n)\"\n  shows \"m = n\"", "lemma enat_coinduct2 [consumes 1, case_names zero eSuc]:\n  \"\\<lbrakk> P m n; \\<And>m n. P m n \\<Longrightarrow> m = 0 \\<longleftrightarrow> n = 0; \n     \\<And>m n. \\<lbrakk> P m n; m \\<noteq> 0; n \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> P (epred m) (epred n) \\<or> epred m = epred n \\<rbrakk>\n  \\<Longrightarrow> m = n\"", "lemma enat_unfold_unique:\n  assumes h: \"!!x. h x = (if stop x then 0 else eSuc (h (next x)))\"\n  shows \"h x = enat_unfold stop next x\"", "lemma enat_diff_cancel_left: \"\\<lbrakk> m \\<le> x; m \\<le> y \\<rbrakk> \\<Longrightarrow> x - m = y - m \\<longleftrightarrow> x = (y :: enat)\"", "lemma finite_lessThan_enatI: \n  assumes \"m \\<noteq> \\<infinity>\"\n  shows \"finite {..<m :: enat}\"", "lemma infinite_lessThan_infty: \"\\<not> finite {..<\\<infinity> :: enat}\"", "lemma finite_lessThan_enat_iff:\n  \"finite {..<m :: enat} \\<longleftrightarrow> m \\<noteq> \\<infinity>\"", "lemma enat_minus_mono1: \"x \\<le> y \\<Longrightarrow> x - m \\<le> y - (m :: enat)\"", "lemma max_enat_minus1: \"max n m - k = max (n - k) (m - k :: enat)\"", "lemma Max_enat_minus1:\n  assumes \"finite A\" \"A \\<noteq> {}\"\n  shows \"Max A - m = Max ((\\<lambda>n :: enat. n - m) ` A)\"", "lemma Sup_enat_minus1: \n  assumes \"m \\<noteq> \\<infinity>\"\n  shows \"\\<Squnion>A - m = \\<Squnion>((\\<lambda>n :: enat. n - m) ` A)\"", "lemma Sup_image_eadd1:\n  assumes \"Y \\<noteq> {}\"\n  shows \"Sup ((\\<lambda>y :: enat. y+x) ` Y) = Sup Y + x\"", "lemma Sup_image_eadd2:\n  \"Y \\<noteq> {} \\<Longrightarrow> Sup ((\\<lambda>y :: enat. x + y) ` Y) = x + Sup Y\"", "lemma mono2mono_eSuc [THEN lfp.mono2mono, cont_intro, simp]:\n  shows monotone_eSuc: \"monotone (\\<le>) (\\<le>) eSuc\"", "lemma mcont2mcont_eSuc [THEN lfp.mcont2mcont, cont_intro, simp]:\n  shows mcont_eSuc: \"mcont Sup (\\<le>) Sup (\\<le>) eSuc\"", "lemma mono2mono_epred [THEN lfp.mono2mono, cont_intro, simp]:\n  shows monotone_epred: \"monotone (\\<le>) (\\<le>) epred\"", "lemma mcont2mcont_epred [THEN lfp.mcont2mcont, cont_intro, simp]:\n  shows mcont_epred: \"mcont Sup (\\<le>) Sup (\\<le>) epred\"", "lemma enat_cocase_mono [partial_function_mono, cont_intro]: \n  \"\\<lbrakk> monotone orda ordb zero; \\<And>n. monotone orda ordb (\\<lambda>f. esuc f n) \\<rbrakk>\n  \\<Longrightarrow> monotone orda ordb (\\<lambda>f. co.case_enat (zero f) (esuc f) x)\"", "lemma enat_cocase_mcont [cont_intro, simp]:\n  \"\\<lbrakk> mcont luba orda lubb ordb zero; \\<And>n. mcont luba orda lubb ordb (\\<lambda>f. esuc f n) \\<rbrakk>\n  \\<Longrightarrow> mcont luba orda lubb ordb (\\<lambda>f. co.case_enat (zero f) (esuc f) x)\"", "lemma eSuc_mono [partial_function_mono]:\n  \"monotone (fun_ord (\\<le>)) (\\<le>) f \\<Longrightarrow> monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>x. eSuc (f x))\"", "lemma mono2mono_enat_minus1 [THEN lfp.mono2mono, cont_intro, simp]:\n  shows monotone_enat_minus1: \"monotone (\\<le>) (\\<le>) (\\<lambda>n. n - m :: enat)\"", "lemma mcont2mcont_enat_minus [THEN lfp.mcont2mcont, cont_intro, simp]:\n  shows mcont_enat_minus: \"m \\<noteq> \\<infinity> \\<Longrightarrow> mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>n. n - m :: enat)\"", "lemma monotone_eadd1: \"monotone (\\<le>) (\\<le>) (\\<lambda>x. x + y :: enat)\"", "lemma monotone_eadd2: \"monotone (\\<le>) (\\<le>) (\\<lambda>y. x + y :: enat)\"", "lemma mono2mono_eadd[THEN lfp.mono2mono2, cont_intro, simp]:\n  shows monotone_eadd: \"monotone (rel_prod (\\<le>) (\\<le>)) (\\<le>) (\\<lambda>(x, y). x + y :: enat)\"", "lemma mcont_eadd2: \"mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>y. x + y :: enat)\"", "lemma mcont_eadd1: \"mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>x. x + y :: enat)\"", "lemma mcont2mcont_eadd [cont_intro, simp]:\n  \"\\<lbrakk> mcont lub ord Sup (\\<le>) (\\<lambda>x. f x);\n    mcont lub ord Sup (\\<le>) (\\<lambda>x. g x) \\<rbrakk>\n  \\<Longrightarrow> mcont lub ord Sup (\\<le>) (\\<lambda>x. f x + g x :: enat)\"", "lemma eadd_partial_function_mono [partial_function_mono]:\n  \"\\<lbrakk> monotone (fun_ord (\\<le>)) (\\<le>) f; monotone (fun_ord (\\<le>)) (\\<le>) g \\<rbrakk>\n  \\<Longrightarrow> monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>x. f x + g x :: enat)\"", "lemma monotone_max_enat1: \"monotone (\\<le>) (\\<le>) (\\<lambda>x. max x y :: enat)\"", "lemma monotone_max_enat2: \"monotone (\\<le>) (\\<le>) (\\<lambda>y. max x y :: enat)\"", "lemma mono2mono_max_enat[THEN lfp.mono2mono2, cont_intro, simp]:\n  shows monotone_max_enat: \"monotone (rel_prod (\\<le>) (\\<le>)) (\\<le>) (\\<lambda>(x, y). max x y :: enat)\"", "lemma max_Sup_enat2:\n  assumes \"Y \\<noteq> {}\"\n  shows \"max x (Sup Y) = Sup ((\\<lambda>y :: enat. max x y) ` Y)\"", "lemma max_Sup_enat1:\n  \"Y \\<noteq> {} \\<Longrightarrow> max (Sup Y) x = Sup ((\\<lambda>y :: enat. max y x) ` Y)\"", "lemma mcont_max_enat1: \"mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>x. max x y :: enat)\"", "lemma mcont_max_enat2: \"mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>y. max x y :: enat)\"", "lemma mcont2mcont_max_enat [cont_intro, simp]:\n  \"\\<lbrakk> mcont lub ord Sup (\\<le>) (\\<lambda>x. f x);\n    mcont lub ord Sup (\\<le>) (\\<lambda>x. g x) \\<rbrakk>\n  \\<Longrightarrow> mcont lub ord Sup (\\<le>) (\\<lambda>x. max (f x) (g x) :: enat)\"", "lemma max_enat_partial_function_mono [partial_function_mono]:\n  \"\\<lbrakk> monotone (fun_ord (\\<le>)) (\\<le>) f; monotone (fun_ord (\\<le>)) (\\<le>) g \\<rbrakk>\n  \\<Longrightarrow> monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>x. max (f x) (g x) :: enat)\"", "lemma chain_epredI:\n  \"Complete_Partial_Order.chain (\\<le>) Y\n  \\<Longrightarrow> Complete_Partial_Order.chain (\\<le>) (epred ` (Y \\<inter> {x. x \\<noteq> 0}))\"", "lemma monotone_enat_le_case:\n  fixes bot\n  assumes mono: \"monotone (\\<le>) ord (\\<lambda>x. f x (eSuc x))\"\n  and ord: \"\\<And>x. ord bot (f x (eSuc x))\"\n  and bot: \"ord bot bot\"\n  shows \"monotone (\\<le>) ord (\\<lambda>x. case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)\"", "lemma mcont_enat_le_case:\n  fixes bot\n  assumes ccpo: \"class.ccpo lub ord (mk_less ord)\"\n  and mcont: \"mcont Sup (\\<le>) lub ord (\\<lambda>x. f x (eSuc x))\"\n  and ord: \"\\<And>x. ord bot (f x (eSuc x))\"\n  shows \"mcont Sup (\\<le>) lub ord (\\<lambda>x. case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)\"", "lemma enat_add_mono [simp]:\n  \"enat x + y < enat x + z \\<longleftrightarrow> y < z\"", "lemma enat_add1_eq [simp]: \"enat x + y = enat x + z \\<longleftrightarrow> y = z\"", "lemma enat_add2_eq [simp]: \"y + enat x = z + enat x \\<longleftrightarrow> y = z\"", "lemma enat_less_enat_plusI: \"x < y \\<Longrightarrow> enat x < enat y + z\"", "lemma enat_less_enat_plusI2:\n  \"enat y < z \\<Longrightarrow> enat (x + y) < enat x + z\"", "lemma min_enat1_conv_enat: \"\\<And>a b. min (enat a) b = enat (case b of enat b' \\<Rightarrow> min a b' | \\<infinity> \\<Rightarrow> a)\"\n  and min_enat2_conv_enat: \"\\<And>a b. min a (enat b) = enat (case a of enat a' \\<Rightarrow> min a' b | \\<infinity> \\<Rightarrow> b)\"", "lemma eSuc_le_iff: \"eSuc x \\<le> y \\<longleftrightarrow> (\\<exists>y'. y = eSuc y' \\<and> x \\<le> y')\"", "lemma eSuc_eq_infinity_iff: \"eSuc n = \\<infinity> \\<longleftrightarrow> n = \\<infinity>\"", "lemma infinity_eq_eSuc_iff: \"\\<infinity> = eSuc n \\<longleftrightarrow> n = \\<infinity>\"", "lemma enat_cocase_inf: \"(case \\<infinity> of 0 \\<Rightarrow> a | eSuc b \\<Rightarrow> f b) = f \\<infinity>\"", "lemma eSuc_Inf: \"eSuc (Inf A) = Inf (eSuc ` A)\""], "translations": [["", "lemma inj_enat [simp]: \"inj_on enat A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on enat A", "by(simp add: inj_on_def)"], ["", "lemma Sup_range_enat [simp]: \"Sup (range enat) = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> range enat = \\<infinity>", "by(auto dest: finite_imageD simp add: Sup_enat_def)"], ["", "lemmas eSuc_plus = iadd_Suc"], ["", "lemmas plus_enat_eq_0_conv = iadd_is_0"], ["", "lemma enat_add_sub_same:\n  fixes a b :: enat shows \"a \\<noteq> \\<infinity> \\<Longrightarrow> a + b - a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> \\<infinity> \\<Longrightarrow> a + b - a = b", "by(cases b) auto"], ["", "lemma enat_the_enat: \"n \\<noteq> \\<infinity> \\<Longrightarrow> enat (the_enat n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> \\<infinity> \\<Longrightarrow> enat (the_enat n) = n", "by auto"], ["", "lemma enat_min_eq_0_iff:\n  fixes a b :: enat\n  shows \"min a b = 0 \\<longleftrightarrow> a = 0 \\<or> b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min a b = 0) = (a = 0 \\<or> b = 0)", "by(auto simp add: min_def)"], ["", "lemma enat_le_plus_same: \"x \\<le> (x :: enat) + y\" \"x \\<le> y + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x + y &&& x \\<le> y + x", "by(auto simp add: less_eq_enat_def plus_enat_def split: enat.split)"], ["", "lemma the_enat_0 [simp]: \"the_enat 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_enat 0 = 0", "by(simp add: zero_enat_def)"], ["", "lemma the_enat_eSuc: \"n \\<noteq> \\<infinity> \\<Longrightarrow> the_enat (eSuc n) = Suc (the_enat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> \\<infinity> \\<Longrightarrow>\n    the_enat (eSuc n) = Suc (the_enat n)", "by(cases n)(simp_all add: eSuc_enat)"], ["", "coinductive_set enat_set :: \"enat set\"\nwhere \"0 \\<in> enat_set\"\n  | \"n \\<in> enat_set \\<Longrightarrow> (eSuc n) \\<in> enat_set\""], ["", "lemma enat_set_eq_UNIV [simp]: \"enat_set = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat_set = UNIV", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. enat_set \\<subseteq> UNIV\n 2. UNIV \\<subseteq> enat_set", "show \"enat_set \\<subseteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat_set \\<subseteq> UNIV", "by blast"], ["proof (state)\nthis:\n  enat_set \\<subseteq> UNIV\n\ngoal (1 subgoal):\n 1. UNIV \\<subseteq> enat_set", "show \"UNIV \\<subseteq> enat_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<subseteq> enat_set", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> x \\<in> enat_set", "fix x :: enat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> x \\<in> enat_set", "assume \"x \\<in> UNIV\""], ["proof (state)\nthis:\n  x \\<in> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> x \\<in> enat_set", "thus \"x \\<in> enat_set\""], ["proof (prove)\nusing this:\n  x \\<in> UNIV\n\ngoal (1 subgoal):\n 1. x \\<in> enat_set", "proof coinduct"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       x = 0 \\<or>\n       (\\<exists>n. x = eSuc n \\<and> (n \\<in> UNIV \\<or> n \\<in> enat_set))", "case (enat_set x)"], ["proof (state)\nthis:\n  x \\<in> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       x = 0 \\<or>\n       (\\<exists>n. x = eSuc n \\<and> (n \\<in> UNIV \\<or> n \\<in> enat_set))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = 0 \\<or>\n    (\\<exists>n. x = eSuc n \\<and> (n \\<in> UNIV \\<or> n \\<in> enat_set))", "proof(cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    x = 0 \\<or>\n    (\\<exists>n. x = eSuc n \\<and> (n \\<in> UNIV \\<or> n \\<in> enat_set))\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    x = 0 \\<or>\n    (\\<exists>n. x = eSuc n \\<and> (n \\<in> UNIV \\<or> n \\<in> enat_set))", "case True"], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    x = 0 \\<or>\n    (\\<exists>n. x = eSuc n \\<and> (n \\<in> UNIV \\<or> n \\<in> enat_set))\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    x = 0 \\<or>\n    (\\<exists>n. x = eSuc n \\<and> (n \\<in> UNIV \\<or> n \\<in> enat_set))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. x = 0 \\<or>\n    (\\<exists>n. x = eSuc n \\<and> (n \\<in> UNIV \\<or> n \\<in> enat_set))", "by simp"], ["proof (state)\nthis:\n  x = 0 \\<or>\n  (\\<exists>n. x = eSuc n \\<and> (n \\<in> UNIV \\<or> n \\<in> enat_set))\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x = 0 \\<or>\n    (\\<exists>n. x = eSuc n \\<and> (n \\<in> UNIV \\<or> n \\<in> enat_set))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x = 0 \\<or>\n    (\\<exists>n. x = eSuc n \\<and> (n \\<in> UNIV \\<or> n \\<in> enat_set))", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x = 0 \\<or>\n    (\\<exists>n. x = eSuc n \\<and> (n \\<in> UNIV \\<or> n \\<in> enat_set))", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> 0", "obtain n where \"x = eSuc n\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>n. x = eSuc n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by(cases x)(fastforce simp add: eSuc_def zero_enat_def gr0_conv_Suc\n                               split: enat.splits)+"], ["proof (state)\nthis:\n  x = eSuc n\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x = 0 \\<or>\n    (\\<exists>n. x = eSuc n \\<and> (n \\<in> UNIV \\<or> n \\<in> enat_set))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = eSuc n\n\ngoal (1 subgoal):\n 1. x = 0 \\<or>\n    (\\<exists>n. x = eSuc n \\<and> (n \\<in> UNIV \\<or> n \\<in> enat_set))", "by auto"], ["proof (state)\nthis:\n  x = 0 \\<or>\n  (\\<exists>n. x = eSuc n \\<and> (n \\<in> UNIV \\<or> n \\<in> enat_set))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = 0 \\<or>\n  (\\<exists>n. x = eSuc n \\<and> (n \\<in> UNIV \\<or> n \\<in> enat_set))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> enat_set\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UNIV \\<subseteq> enat_set\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Case operator\\<close>"], ["", "lemma enat_coexhaust:\n  obtains (0) \"n = 0\"\n     | (eSuc) n' where \"n = eSuc n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = 0 \\<Longrightarrow> thesis;\n     \\<And>n'. n = eSuc n' \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = 0 \\<Longrightarrow> thesis;\n     \\<And>n'. n = eSuc n' \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"n \\<in> enat_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> enat_set", "by auto"], ["proof (state)\nthis:\n  n \\<in> enat_set\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n = 0 \\<Longrightarrow> thesis;\n     \\<And>n'. n = eSuc n' \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  n \\<in> enat_set\n\ngoal (1 subgoal):\n 1. thesis", "by cases (erule that)+"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "locale co begin"], ["", "free_constructors (plugins del: code) case_enat for\n    \"0::enat\"\n  | eSuc epred\nwhere\n  \"epred 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P y.\n        \\<lbrakk>y = 0 \\<Longrightarrow> P;\n         \\<And>x2. y = eSuc x2 \\<Longrightarrow> P\\<rbrakk>\n        \\<Longrightarrow> P) &&&\n    (\\<And>x2 y2. (eSuc x2 = eSuc y2) = (x2 = y2)) &&&\n    (\\<And>x2. 0 \\<noteq> eSuc x2)", "apply (erule enat_coexhaust, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2 y2. (eSuc x2 = eSuc y2) = (x2 = y2)\n 2. \\<And>x2. 0 \\<noteq> eSuc x2", "apply (rule eSuc_inject)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2. 0 \\<noteq> eSuc x2", "by (rule zero_ne_eSuc)"], ["", "end"], ["", "lemma enat_cocase_0 [simp]: \"co.case_enat z s 0 = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case 0 of 0 \\<Rightarrow> z | eSuc x \\<Rightarrow> s x) = z", "by (rule co.enat.case(1))"], ["", "lemma enat_cocase_eSuc [simp]: \"co.case_enat z s (eSuc n) = s n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case eSuc n of 0 \\<Rightarrow> z | eSuc x \\<Rightarrow> s x) = s n", "by (rule co.enat.case(2))"], ["", "lemma neq_zero_conv_eSuc: \"n \\<noteq> 0 \\<longleftrightarrow> (\\<exists>n'. n = eSuc n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n \\<noteq> 0) = (\\<exists>n'. n = eSuc n')", "by(cases n rule: enat_coexhaust) simp_all"], ["", "lemma enat_cocase_cert:\n  assumes \"CASE \\<equiv> co.case_enat c d\"\n  shows \"(CASE 0 \\<equiv> c) &&& (CASE (eSuc n) \\<equiv> d n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (CASE 0 \\<equiv> c) &&& CASE (eSuc n) \\<equiv> d n", "using assms"], ["proof (prove)\nusing this:\n  CASE \\<equiv> co.case_enat c d\n\ngoal (1 subgoal):\n 1. (CASE 0 \\<equiv> c) &&& CASE (eSuc n) \\<equiv> d n", "by simp_all"], ["", "lemma enat_cosplit_asm:\n  \"P (co.case_enat c d n) = (\\<not> (n = 0 \\<and> \\<not> P c \\<or> (\\<exists>m. n = eSuc m \\<and> \\<not> P (d m))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (case n of 0 \\<Rightarrow> c | eSuc x \\<Rightarrow> d x) =\n    (\\<not> (n = 0 \\<and> \\<not> P c \\<or>\n             (\\<exists>m. n = eSuc m \\<and> \\<not> P (d m))))", "by (rule co.enat.split_asm)"], ["", "lemma enat_cosplit:\n  \"P (co.case_enat c d n) = ((n = 0 \\<longrightarrow> P c) \\<and> (\\<forall>m. n = eSuc m \\<longrightarrow> P (d m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (case n of 0 \\<Rightarrow> c | eSuc x \\<Rightarrow> d x) =\n    ((n = 0 \\<longrightarrow> P c) \\<and>\n     (\\<forall>m. n = eSuc m \\<longrightarrow> P (d m)))", "by (rule co.enat.split)"], ["", "abbreviation epred :: \"enat => enat\" where \"epred \\<equiv> co.epred\""], ["", "lemma epred_0 [simp]: \"epred 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epred 0 = 0", "by(rule co.enat.sel(1))"], ["", "lemma epred_eSuc [simp]: \"epred (eSuc n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epred (eSuc n) = n", "by(rule co.enat.sel(2))"], ["", "declare co.enat.collapse[simp]"], ["", "lemma epred_conv_minus: \"epred n = n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epred n = n - 1", "by(cases n rule: co.enat.exhaust)(simp_all)"], ["", "subsection \\<open>Corecursion for @{typ enat}\\<close>"], ["", "lemma case_enat_numeral [simp]: \"case_enat f i (numeral v) = (let n = numeral v in f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case numeral v of enat x \\<Rightarrow> f x\n     | \\<infinity> \\<Rightarrow> i) =\n    Let (numeral v) f", "by(simp add: numeral_eq_enat)"], ["", "lemma case_enat_0 [simp]: \"case_enat f i 0 = f 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case 0 of enat x \\<Rightarrow> f x | \\<infinity> \\<Rightarrow> i) = f 0", "by(simp add: zero_enat_def)"], ["", "lemma [simp]:\n  shows max_eSuc_eSuc: \"max (eSuc n) (eSuc m) = eSuc (max n m)\"\n  and min_eSuc_eSuc: \"min (eSuc n) (eSuc m) = eSuc (min n m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (eSuc n) (eSuc m) = eSuc (max n m) &&&\n    min (eSuc n) (eSuc m) = eSuc (min n m)", "by(simp_all add: eSuc_def split: enat.split)"], ["", "definition epred_numeral :: \"num \\<Rightarrow> enat\"\nwhere [code del]: \"epred_numeral = enat \\<circ> pred_numeral\""], ["", "lemma numeral_eq_eSuc: \"numeral k = eSuc (epred_numeral k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral k = eSuc (epred_numeral k)", "by(simp add: numeral_eq_Suc eSuc_def epred_numeral_def numeral_eq_enat)"], ["", "lemma epred_numeral_simps [simp]:\n  \"epred_numeral num.One = 0\"\n  \"epred_numeral (num.Bit0 k) = numeral (Num.BitM k)\"\n  \"epred_numeral (num.Bit1 k) = numeral (num.Bit0 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epred_numeral num.One = 0 &&&\n    epred_numeral (num.Bit0 k) = numeral (Num.BitM k) &&&\n    epred_numeral (num.Bit1 k) = numeral (num.Bit0 k)", "by(simp_all add: epred_numeral_def enat_numeral zero_enat_def)"], ["", "lemma [simp]:\n  shows eq_numeral_eSuc: \"numeral k = eSuc n \\<longleftrightarrow> epred_numeral k = n\"\n  and Suc_eq_numeral: \"eSuc n = numeral k \\<longleftrightarrow> n = epred_numeral k\"\n  and less_numeral_Suc: \"numeral k < eSuc n \\<longleftrightarrow> epred_numeral k < n\"\n  and less_eSuc_numeral: \"eSuc n < numeral k \\<longleftrightarrow> n < epred_numeral k\"\n  and le_numeral_eSuc: \"numeral k \\<le> eSuc n \\<longleftrightarrow> epred_numeral k \\<le> n\"\n  and le_eSuc_numeral: \"eSuc n \\<le> numeral k \\<longleftrightarrow> n \\<le> epred_numeral k\"\n  and diff_eSuc_numeral: \"eSuc n - numeral k = n - epred_numeral k\"\n  and diff_numeral_eSuc: \"numeral k - eSuc n = epred_numeral k - n\"\n  and max_eSuc_numeral: \"max (eSuc n) (numeral k) = eSuc (max n (epred_numeral k))\"\n  and max_numeral_eSuc: \"max (numeral k) (eSuc n) = eSuc (max (epred_numeral k) n)\"\n  and min_eSuc_numeral: \"min (eSuc n) (numeral k) = eSuc (min n (epred_numeral k))\"\n  and min_numeral_eSuc: \"min (numeral k) (eSuc n) = eSuc (min (epred_numeral k) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((numeral k = eSuc n) = (epred_numeral k = n) &&&\n      (eSuc n = numeral k) = (n = epred_numeral k) &&&\n      (numeral k < eSuc n) = (epred_numeral k < n)) &&&\n     (eSuc n < numeral k) = (n < epred_numeral k) &&&\n     (numeral k \\<le> eSuc n) = (epred_numeral k \\<le> n) &&&\n     (eSuc n \\<le> numeral k) = (n \\<le> epred_numeral k)) &&&\n    (eSuc n - numeral k = n - epred_numeral k &&&\n     numeral k - eSuc n = epred_numeral k - n &&&\n     max (eSuc n) (numeral k) = eSuc (max n (epred_numeral k))) &&&\n    max (numeral k) (eSuc n) = eSuc (max (epred_numeral k) n) &&&\n    min (eSuc n) (numeral k) = eSuc (min n (epred_numeral k)) &&&\n    min (numeral k) (eSuc n) = eSuc (min (epred_numeral k) n)", "by(simp_all add: numeral_eq_eSuc)"], ["", "lemma enat_cocase_numeral [simp]:\n  \"co.case_enat a f (numeral v) = (let pv = epred_numeral v in f pv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case numeral v of 0 \\<Rightarrow> a | eSuc x \\<Rightarrow> f x) =\n    Let (epred_numeral v) f", "by(simp add: numeral_eq_eSuc)"], ["", "lemma enat_cocase_add_eq_if [simp]:\n  \"co.case_enat a f ((numeral v) + n) = (let pv = epred_numeral v in f (pv + n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case numeral v + n of 0 \\<Rightarrow> a | eSuc x \\<Rightarrow> f x) =\n    (let pv = epred_numeral v in f (pv + n))", "by(simp add: numeral_eq_eSuc iadd_Suc)"], ["", "lemma [simp]:\n  shows epred_1: \"epred 1 = 0\"\n  and epred_numeral: \"epred (numeral i) = epred_numeral i\"\n  and epred_Infty: \"epred \\<infinity> = \\<infinity>\"\n  and epred_enat: \"epred (enat m) = enat (m - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (epred 1 = 0 &&& epred (numeral i) = epred_numeral i) &&&\n    epred \\<infinity> = \\<infinity> &&& epred (enat m) = enat (m - 1)", "by(simp_all add: epred_conv_minus one_enat_def zero_enat_def eSuc_def epred_numeral_def numeral_eq_enat split: enat.split)"], ["", "lemmas epred_simps = epred_0 epred_1 epred_numeral epred_eSuc epred_Infty epred_enat"], ["", "lemma epred_iadd1: \"a \\<noteq> 0 \\<Longrightarrow> epred (a + b) = epred a + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> epred (a + b) = epred a + b", "apply(cases a b rule: enat.exhaust[case_product enat.exhaust])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>nat__ nata__.\n       \\<lbrakk>a \\<noteq> 0; a = enat nat__; b = enat nata__\\<rbrakk>\n       \\<Longrightarrow> epred (a + b) = epred a + b\n 2. \\<And>nat__.\n       \\<lbrakk>a \\<noteq> 0; a = enat nat__; b = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> epred (a + b) = epred a + b\n 3. \\<And>nat__.\n       \\<lbrakk>a \\<noteq> 0; a = \\<infinity>; b = enat nat__\\<rbrakk>\n       \\<Longrightarrow> epred (a + b) = epred a + b\n 4. \\<lbrakk>a \\<noteq> 0; a = \\<infinity>; b = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> epred (a + b) = epred a + b", "apply(simp_all add: epred_conv_minus eSuc_def one_enat_def zero_enat_def split: enat.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma epred_min [simp]: \"epred (min a b) = min (epred a) (epred b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epred (min a b) = min (epred a) (epred b)", "by(cases a b rule: enat_coexhaust[case_product enat_coexhaust]) simp_all"], ["", "lemma epred_le_epredI: \"n \\<le> m \\<Longrightarrow> epred n \\<le> epred m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow> epred n \\<le> epred m", "by(cases m n rule: enat_coexhaust[case_product enat_coexhaust]) simp_all"], ["", "lemma epred_minus_epred [simp]:\n  \"m \\<noteq> 0 \\<Longrightarrow> epred n - epred m = n - m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> epred n - epred m = n - m", "by(cases n m rule: enat_coexhaust[case_product enat_coexhaust])(simp_all add: epred_conv_minus)"], ["", "lemma eSuc_epred: \"n \\<noteq> 0 \\<Longrightarrow> eSuc (epred n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> eSuc (epred n) = n", "by(cases n rule: enat_coexhaust) simp_all"], ["", "lemma epred_inject: \"\\<lbrakk> x \\<noteq> 0; y \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> epred x = epred y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> 0; y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (epred x = epred y) = (x = y)", "by(cases x y rule: enat.exhaust[case_product enat.exhaust])(auto simp add: zero_enat_def)"], ["", "lemma monotone_fun_eSuc[partial_function_mono]:\n    \"monotone (fun_ord (\\<lambda>y x. x \\<le> y)) (\\<lambda>y x. x \\<le> y) (\\<lambda>f. eSuc (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp.mono_body (\\<lambda>f. eSuc (f x))", "by (auto simp: monotone_def fun_ord_def)"], ["", "partial_function (gfp) enat_unfold :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> enat\" where\n  enat_unfold [code, nitpick_simp]:\n  \"enat_unfold stop next a = (if stop a then 0 else eSuc (enat_unfold stop next (next a)))\""], ["", "lemma enat_unfold_stop [simp]: \"stop a \\<Longrightarrow> enat_unfold stop next a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stop a \\<Longrightarrow> enat_unfold stop next a = 0", "by(simp add: enat_unfold)"], ["", "lemma enat_unfold_next: \"\\<not> stop a \\<Longrightarrow> enat_unfold stop next a = eSuc (enat_unfold stop next (next a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> stop a \\<Longrightarrow>\n    enat_unfold stop next a = eSuc (enat_unfold stop next (next a))", "by(simp add: enat_unfold)"], ["", "lemma enat_unfold_eq_0 [simp]:\n  \"enat_unfold stop next a = 0 \\<longleftrightarrow> stop a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (enat_unfold stop next a = 0) = stop a", "by(simp add: enat_unfold)"], ["", "lemma epred_enat_unfold [simp]:\n  \"epred (enat_unfold stop next a) = (if stop a then 0 else enat_unfold stop next (next a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epred (enat_unfold stop next a) =\n    (if stop a then 0 else enat_unfold stop next (next a))", "by(simp add: enat_unfold_next)"], ["", "lemma epred_max: \"epred (max x y) = max (epred x) (epred y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epred (max x y) = max (epred x) (epred y)", "by(cases x y rule: enat.exhaust[case_product enat.exhaust]) simp_all"], ["", "lemma epred_Max:\n  assumes \"finite A\" \"A \\<noteq> {}\"\n  shows \"epred (Max A) = Max (epred ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epred (Max A) = Max (epred ` A)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. epred (Max A) = Max (epred ` A)", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow> epred (Max {}) = Max (epred ` {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> epred (Max F) = Max (epred ` F);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> epred (Max (insert x F)) = Max (epred ` insert x F)", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  A \\<noteq> {} \\<Longrightarrow> epred (Max A) = Max (epred ` A)\n  insert x A \\<noteq> {}\n\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow> epred (Max {}) = Max (epred ` {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> epred (Max F) = Max (epred ` F);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> epred (Max (insert x F)) = Max (epred ` insert x F)", "thus ?case"], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  A \\<noteq> {} \\<Longrightarrow> epred (Max A) = Max (epred ` A)\n  insert x A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. epred (Max (insert x A)) = Max (epred ` insert x A)", "by(cases \"A = {}\")(simp_all add: epred_max)"], ["proof (state)\nthis:\n  epred (Max (insert x A)) = Max (epred ` insert x A)\n\ngoal (1 subgoal):\n 1. {} \\<noteq> {} \\<Longrightarrow> epred (Max {}) = Max (epred ` {})", "qed simp"], ["", "lemma finite_imageD2: \"\\<lbrakk> finite (f ` A); inj_on f (A - B); finite B \\<rbrakk> \\<Longrightarrow> finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (f ` A); inj_on f (A - B); finite B\\<rbrakk>\n    \\<Longrightarrow> finite A", "by (metis Diff_subset finite_Diff2 image_mono inj_on_finite)"], ["", "lemma epred_Sup: \"epred (Sup A) = Sup (epred ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epred (\\<Squnion> A) = \\<Squnion> (epred ` A)", "by(auto 4 4 simp add: bot_enat_def Sup_enat_def epred_Max inj_on_def neq_zero_conv_eSuc dest: finite_imageD2[where B=\"{0}\"])"], ["", "subsection \\<open>Less as greatest fixpoint\\<close>"], ["", "coinductive_set Le_enat :: \"(enat \\<times> enat) set\"\nwhere\n  Le_enat_zero: \"(0, n) \\<in> Le_enat\"\n| Le_enat_add: \"\\<lbrakk> (m, n) \\<in> Le_enat; k \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> (eSuc m, n + k) \\<in> Le_enat\""], ["", "lemma ile_into_Le_enat:\n  \"m \\<le> n \\<Longrightarrow> (m, n) \\<in> Le_enat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> (m, n) \\<in> Le_enat", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> (m, n) \\<in> Le_enat", "assume \"m \\<le> n\""], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> (m, n) \\<in> Le_enat", "hence \"(m, n) \\<in> {(m, n)|m n. m \\<le> n}\""], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. (m, n) \\<in> {(m, n) |m n. m \\<le> n}", "by simp"], ["proof (state)\nthis:\n  (m, n) \\<in> {(m, n) |m n. m \\<le> n}\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> (m, n) \\<in> Le_enat", "thus ?thesis"], ["proof (prove)\nusing this:\n  (m, n) \\<in> {(m, n) |m n. m \\<le> n}\n\ngoal (1 subgoal):\n 1. (m, n) \\<in> Le_enat", "proof coinduct"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       (x1, x2) \\<in> {(m, n) |m n. m \\<le> n} \\<Longrightarrow>\n       (\\<exists>n. x1 = 0 \\<and> x2 = n) \\<or>\n       (\\<exists>m n k.\n           x1 = eSuc m \\<and>\n           x2 = n + k \\<and>\n           ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n            (m, n) \\<in> Le_enat) \\<and>\n           k \\<noteq> 0)", "case (Le_enat m n)"], ["proof (state)\nthis:\n  (m, n) \\<in> {(m, n) |m n. m \\<le> n}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       (x1, x2) \\<in> {(m, n) |m n. m \\<le> n} \\<Longrightarrow>\n       (\\<exists>n. x1 = 0 \\<and> x2 = n) \\<or>\n       (\\<exists>m n k.\n           x1 = eSuc m \\<and>\n           x2 = n + k \\<and>\n           ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n            (m, n) \\<in> Le_enat) \\<and>\n           k \\<noteq> 0)", "hence \"m \\<le> n\""], ["proof (prove)\nusing this:\n  (m, n) \\<in> {(m, n) |m n. m \\<le> n}\n\ngoal (1 subgoal):\n 1. m \\<le> n", "by simp"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       (x1, x2) \\<in> {(m, n) |m n. m \\<le> n} \\<Longrightarrow>\n       (\\<exists>n. x1 = 0 \\<and> x2 = n) \\<or>\n       (\\<exists>m n k.\n           x1 = eSuc m \\<and>\n           x2 = n + k \\<and>\n           ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n            (m, n) \\<in> Le_enat) \\<and>\n           k \\<noteq> 0)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n    (\\<exists>m n k.\n        m = eSuc m \\<and>\n        n = n + k \\<and>\n        ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n         (m, n) \\<in> Le_enat) \\<and>\n        k \\<noteq> 0)", "proof(cases \"m = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n    (\\<exists>m n k.\n        m = eSuc m \\<and>\n        n = n + k \\<and>\n        ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n         (m, n) \\<in> Le_enat) \\<and>\n        k \\<noteq> 0)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n    (\\<exists>m n k.\n        m = eSuc m \\<and>\n        n = n + k \\<and>\n        ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n         (m, n) \\<in> Le_enat) \\<and>\n        k \\<noteq> 0)", "case True"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n    (\\<exists>m n k.\n        m = eSuc m \\<and>\n        n = n + k \\<and>\n        ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n         (m, n) \\<in> Le_enat) \\<and>\n        k \\<noteq> 0)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n    (\\<exists>m n k.\n        m = eSuc m \\<and>\n        n = n + k \\<and>\n        ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n         (m, n) \\<in> Le_enat) \\<and>\n        k \\<noteq> 0)", "hence ?Le_enat_zero"], ["proof (prove)\nusing this:\n  m = 0\n\ngoal (1 subgoal):\n 1. \\<exists>n. m = 0 \\<and> n = n", "by simp"], ["proof (state)\nthis:\n  \\<exists>n. m = 0 \\<and> n = n\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n    (\\<exists>m n k.\n        m = eSuc m \\<and>\n        n = n + k \\<and>\n        ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n         (m, n) \\<in> Le_enat) \\<and>\n        k \\<noteq> 0)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n    (\\<exists>m n k.\n        m = eSuc m \\<and>\n        n = n + k \\<and>\n        ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n         (m, n) \\<in> Le_enat) \\<and>\n        k \\<noteq> 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>n. m = 0 \\<and> n = n\n\ngoal (1 subgoal):\n 1. (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n    (\\<exists>m n k.\n        m = eSuc m \\<and>\n        n = n + k \\<and>\n        ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n         (m, n) \\<in> Le_enat) \\<and>\n        k \\<noteq> 0)", ".."], ["proof (state)\nthis:\n  (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n  (\\<exists>m n k.\n      m = eSuc m \\<and>\n      n = n + k \\<and>\n      ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n       (m, n) \\<in> Le_enat) \\<and>\n      k \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n    (\\<exists>m n k.\n        m = eSuc m \\<and>\n        n = n + k \\<and>\n        ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n         (m, n) \\<in> Le_enat) \\<and>\n        k \\<noteq> 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n    (\\<exists>m n k.\n        m = eSuc m \\<and>\n        n = n + k \\<and>\n        ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n         (m, n) \\<in> Le_enat) \\<and>\n        k \\<noteq> 0)", "case False"], ["proof (state)\nthis:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n    (\\<exists>m n k.\n        m = eSuc m \\<and>\n        n = n + k \\<and>\n        ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n         (m, n) \\<in> Le_enat) \\<and>\n        k \\<noteq> 0)", "with \\<open>m \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  m \\<le> n\n  m \\<noteq> 0", "obtain m' n' where \"m = eSuc m'\" \"n = n' + 1\" \"m' \\<le> n'\""], ["proof (prove)\nusing this:\n  m \\<le> n\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>m' n'.\n        \\<lbrakk>m = eSuc m'; n = n' + 1; m' \\<le> n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases m rule: enat_coexhaust, simp)\n          (cases n rule: enat_coexhaust, auto simp add: eSuc_plus_1[symmetric])"], ["proof (state)\nthis:\n  m = eSuc m'\n  n = n' + 1\n  m' \\<le> n'\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n    (\\<exists>m n k.\n        m = eSuc m \\<and>\n        n = n + k \\<and>\n        ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n         (m, n) \\<in> Le_enat) \\<and>\n        k \\<noteq> 0)", "hence ?Le_enat_add"], ["proof (prove)\nusing this:\n  m = eSuc m'\n  n = n' + 1\n  m' \\<le> n'\n\ngoal (1 subgoal):\n 1. \\<exists>m n k.\n       m = eSuc m \\<and>\n       n = n + k \\<and>\n       ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n        (m, n) \\<in> Le_enat) \\<and>\n       k \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>m n k.\n     m = eSuc m \\<and>\n     n = n + k \\<and>\n     ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n      (m, n) \\<in> Le_enat) \\<and>\n     k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n    (\\<exists>m n k.\n        m = eSuc m \\<and>\n        n = n + k \\<and>\n        ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n         (m, n) \\<in> Le_enat) \\<and>\n        k \\<noteq> 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>m n k.\n     m = eSuc m \\<and>\n     n = n + k \\<and>\n     ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n      (m, n) \\<in> Le_enat) \\<and>\n     k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n    (\\<exists>m n k.\n        m = eSuc m \\<and>\n        n = n + k \\<and>\n        ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n         (m, n) \\<in> Le_enat) \\<and>\n        k \\<noteq> 0)", ".."], ["proof (state)\nthis:\n  (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n  (\\<exists>m n k.\n      m = eSuc m \\<and>\n      n = n + k \\<and>\n      ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n       (m, n) \\<in> Le_enat) \\<and>\n      k \\<noteq> 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>n. m = 0 \\<and> n = n) \\<or>\n  (\\<exists>m n k.\n      m = eSuc m \\<and>\n      n = n + k \\<and>\n      ((m, n) \\<in> {(m, n) |m n. m \\<le> n} \\<or>\n       (m, n) \\<in> Le_enat) \\<and>\n      k \\<noteq> 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (m, n) \\<in> Le_enat\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Le_enat_imp_ile_enat_k:\n  \"(m, n) \\<in> Le_enat \\<Longrightarrow> n < enat l \\<Longrightarrow> m < enat l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(m, n) \\<in> Le_enat; n < enat l\\<rbrakk>\n    \\<Longrightarrow> m < enat l", "proof(induct l arbitrary: m n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>(m, n) \\<in> Le_enat; n < enat 0\\<rbrakk>\n       \\<Longrightarrow> m < enat 0\n 2. \\<And>l m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>(m, n) \\<in> Le_enat; n < enat l\\<rbrakk>\n                   \\<Longrightarrow> m < enat l;\n        (m, n) \\<in> Le_enat; n < enat (Suc l)\\<rbrakk>\n       \\<Longrightarrow> m < enat (Suc l)", "case 0"], ["proof (state)\nthis:\n  (m, n) \\<in> Le_enat\n  n < enat 0\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>(m, n) \\<in> Le_enat; n < enat 0\\<rbrakk>\n       \\<Longrightarrow> m < enat 0\n 2. \\<And>l m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>(m, n) \\<in> Le_enat; n < enat l\\<rbrakk>\n                   \\<Longrightarrow> m < enat l;\n        (m, n) \\<in> Le_enat; n < enat (Suc l)\\<rbrakk>\n       \\<Longrightarrow> m < enat (Suc l)", "thus ?case"], ["proof (prove)\nusing this:\n  (m, n) \\<in> Le_enat\n  n < enat 0\n\ngoal (1 subgoal):\n 1. m < enat 0", "by(simp add: zero_enat_def[symmetric])"], ["proof (state)\nthis:\n  m < enat 0\n\ngoal (1 subgoal):\n 1. \\<And>l m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>(m, n) \\<in> Le_enat; n < enat l\\<rbrakk>\n                   \\<Longrightarrow> m < enat l;\n        (m, n) \\<in> Le_enat; n < enat (Suc l)\\<rbrakk>\n       \\<Longrightarrow> m < enat (Suc l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>(m, n) \\<in> Le_enat; n < enat l\\<rbrakk>\n                   \\<Longrightarrow> m < enat l;\n        (m, n) \\<in> Le_enat; n < enat (Suc l)\\<rbrakk>\n       \\<Longrightarrow> m < enat (Suc l)", "case (Suc l)"], ["proof (state)\nthis:\n  \\<lbrakk>(?m, ?n) \\<in> Le_enat; ?n < enat l\\<rbrakk>\n  \\<Longrightarrow> ?m < enat l\n  (m, n) \\<in> Le_enat\n  n < enat (Suc l)\n\ngoal (1 subgoal):\n 1. \\<And>l m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>(m, n) \\<in> Le_enat; n < enat l\\<rbrakk>\n                   \\<Longrightarrow> m < enat l;\n        (m, n) \\<in> Le_enat; n < enat (Suc l)\\<rbrakk>\n       \\<Longrightarrow> m < enat (Suc l)", "from \\<open>(m, n) \\<in> Le_enat\\<close>"], ["proof (chain)\npicking this:\n  (m, n) \\<in> Le_enat", "show ?case"], ["proof (prove)\nusing this:\n  (m, n) \\<in> Le_enat\n\ngoal (1 subgoal):\n 1. m < enat (Suc l)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> m < enat (Suc l)\n 2. \\<And>m n k.\n       \\<lbrakk>m = eSuc m; n = n + k; (m, n) \\<in> Le_enat;\n        k \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> m < enat (Suc l)", "case Le_enat_zero"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> m < enat (Suc l)\n 2. \\<And>m n k.\n       \\<lbrakk>m = eSuc m; n = n + k; (m, n) \\<in> Le_enat;\n        k \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> m < enat (Suc l)", "with \\<open>n < enat (Suc l)\\<close>"], ["proof (chain)\npicking this:\n  n < enat (Suc l)\n  m = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n < enat (Suc l)\n  m = 0\n\ngoal (1 subgoal):\n 1. m < enat (Suc l)", "by auto"], ["proof (state)\nthis:\n  m < enat (Suc l)\n\ngoal (1 subgoal):\n 1. \\<And>m n k.\n       \\<lbrakk>m = eSuc m; n = n + k; (m, n) \\<in> Le_enat;\n        k \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> m < enat (Suc l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n k.\n       \\<lbrakk>m = eSuc m; n = n + k; (m, n) \\<in> Le_enat;\n        k \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> m < enat (Suc l)", "case (Le_enat_add M N K)"], ["proof (state)\nthis:\n  m = eSuc M\n  n = N + K\n  (M, N) \\<in> Le_enat\n  K \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>m n k.\n       \\<lbrakk>m = eSuc m; n = n + k; (m, n) \\<in> Le_enat;\n        k \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> m < enat (Suc l)", "from \\<open>n = N + K\\<close> \\<open>n < enat (Suc l)\\<close> \\<open>K \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  n = N + K\n  n < enat (Suc l)\n  K \\<noteq> 0", "have \"N < enat l\""], ["proof (prove)\nusing this:\n  n = N + K\n  n < enat (Suc l)\n  K \\<noteq> 0\n\ngoal (1 subgoal):\n 1. N < enat l", "by(cases N)(cases K, auto simp add: zero_enat_def)"], ["proof (state)\nthis:\n  N < enat l\n\ngoal (1 subgoal):\n 1. \\<And>m n k.\n       \\<lbrakk>m = eSuc m; n = n + k; (m, n) \\<in> Le_enat;\n        k \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> m < enat (Suc l)", "with \\<open>(M, N) \\<in> Le_enat\\<close>"], ["proof (chain)\npicking this:\n  (M, N) \\<in> Le_enat\n  N < enat l", "have \"M < enat l\""], ["proof (prove)\nusing this:\n  (M, N) \\<in> Le_enat\n  N < enat l\n\ngoal (1 subgoal):\n 1. M < enat l", "by(rule Suc)"], ["proof (state)\nthis:\n  M < enat l\n\ngoal (1 subgoal):\n 1. \\<And>m n k.\n       \\<lbrakk>m = eSuc m; n = n + k; (m, n) \\<in> Le_enat;\n        k \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> m < enat (Suc l)", "with \\<open>m = eSuc M\\<close>"], ["proof (chain)\npicking this:\n  m = eSuc M\n  M < enat l", "show ?thesis"], ["proof (prove)\nusing this:\n  m = eSuc M\n  M < enat l\n\ngoal (1 subgoal):\n 1. m < enat (Suc l)", "by(simp add: eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  m < enat (Suc l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m < enat (Suc l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enat_less_imp_le:\n  assumes k: \"!!k. n < enat k \\<Longrightarrow> m < enat k\"\n  shows \"m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n", "proof(cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nat. n = enat nat \\<Longrightarrow> m \\<le> n\n 2. n = \\<infinity> \\<Longrightarrow> m \\<le> n", "case (enat n')"], ["proof (state)\nthis:\n  n = enat n'\n\ngoal (2 subgoals):\n 1. \\<And>nat. n = enat nat \\<Longrightarrow> m \\<le> n\n 2. n = \\<infinity> \\<Longrightarrow> m \\<le> n", "with k[of \"Suc n'\"]"], ["proof (chain)\npicking this:\n  n < enat (Suc n') \\<Longrightarrow> m < enat (Suc n')\n  n = enat n'", "show ?thesis"], ["proof (prove)\nusing this:\n  n < enat (Suc n') \\<Longrightarrow> m < enat (Suc n')\n  n = enat n'\n\ngoal (1 subgoal):\n 1. m \\<le> n", "by(cases m) simp_all"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. n = \\<infinity> \\<Longrightarrow> m \\<le> n", "qed simp"], ["", "lemma Le_enat_imp_ile:\n  \"(m, n) \\<in> Le_enat \\<Longrightarrow> m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m, n) \\<in> Le_enat \\<Longrightarrow> m \\<le> n", "by(rule enat_less_imp_le)(erule Le_enat_imp_ile_enat_k)"], ["", "lemma Le_enat_eq_ile:\n  \"(m, n) \\<in> Le_enat \\<longleftrightarrow> m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((m, n) \\<in> Le_enat) = (m \\<le> n)", "by(blast intro: Le_enat_imp_ile ile_into_Le_enat)"], ["", "lemma enat_leI [consumes 1, case_names Leenat, case_conclusion Leenat zero eSuc]:\n  assumes major: \"(m, n) \\<in> X\"\n  and step:\n    \"\\<And>m n. (m, n) \\<in> X \n     \\<Longrightarrow> m = 0 \\<or> (\\<exists>m' n' k. m = eSuc m' \\<and> n = n' + enat k \\<and> k \\<noteq> 0 \\<and>\n                           ((m', n') \\<in> X \\<or> m' \\<le> n'))\"\n  shows \"m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n", "apply(rule Le_enat.coinduct[unfolded Le_enat_eq_ile, where X=\"\\<lambda>x y. (x, y) \\<in> X\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (m, n) \\<in> X\n 2. \\<And>x1 x2.\n       (x1, x2) \\<in> X \\<Longrightarrow>\n       (\\<exists>n. x1 = 0 \\<and> x2 = n) \\<or>\n       (\\<exists>m n k.\n           x1 = eSuc m \\<and>\n           x2 = n + k \\<and>\n           ((m, n) \\<in> X \\<or> m \\<le> n) \\<and> k \\<noteq> 0)", "apply(fastforce simp add: zero_enat_def dest: step intro: major)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma enat_le_coinduct[consumes 1, case_names le, case_conclusion le 0 eSuc]:\n  assumes P: \"P m n\"\n  and step:\n    \"\\<And>m n. P m n \n     \\<Longrightarrow> (n = 0 \\<longrightarrow> m = 0) \\<and>\n         (m \\<noteq> 0 \\<longrightarrow> n \\<noteq> 0 \\<longrightarrow> (\\<exists>k n'. P (epred m) n' \\<and> epred n = n' + k) \\<or> epred m \\<le> epred n)\"\n  shows \"m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<le> n", "from P"], ["proof (chain)\npicking this:\n  P m n", "have \"(m, n) \\<in> {(m, n). P m n}\""], ["proof (prove)\nusing this:\n  P m n\n\ngoal (1 subgoal):\n 1. (m, n) \\<in> {(m, n). P m n}", "by simp"], ["proof (state)\nthis:\n  (m, n) \\<in> {(m, n). P m n}\n\ngoal (1 subgoal):\n 1. m \\<le> n", "thus ?thesis"], ["proof (prove)\nusing this:\n  (m, n) \\<in> {(m, n). P m n}\n\ngoal (1 subgoal):\n 1. m \\<le> n", "proof(coinduct rule: enat_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (m, n) \\<in> {(m, n). P m n} \\<Longrightarrow>\n       m = 0 \\<or>\n       (\\<exists>m' n' k.\n           m = eSuc m' \\<and>\n           n = n' + enat k \\<and>\n           k \\<noteq> 0 \\<and>\n           ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "case (Leenat m n)"], ["proof (state)\nthis:\n  (m, n) \\<in> {(m, n). P m n}\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (m, n) \\<in> {(m, n). P m n} \\<Longrightarrow>\n       m = 0 \\<or>\n       (\\<exists>m' n' k.\n           m = eSuc m' \\<and>\n           n = n' + enat k \\<and>\n           k \\<noteq> 0 \\<and>\n           ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "hence \"P m n\""], ["proof (prove)\nusing this:\n  (m, n) \\<in> {(m, n). P m n}\n\ngoal (1 subgoal):\n 1. P m n", "by simp"], ["proof (state)\nthis:\n  P m n\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (m, n) \\<in> {(m, n). P m n} \\<Longrightarrow>\n       m = 0 \\<or>\n       (\\<exists>m' n' k.\n           m = eSuc m' \\<and>\n           n = n' + enat k \\<and>\n           k \\<noteq> 0 \\<and>\n           ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "proof(cases m rule: enat_coexhaust)"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))\n 2. \\<And>n'.\n       m = eSuc n' \\<Longrightarrow>\n       m = 0 \\<or>\n       (\\<exists>m' n' k.\n           m = eSuc m' \\<and>\n           n = n' + enat k \\<and>\n           k \\<noteq> 0 \\<and>\n           ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "case 0"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))\n 2. \\<And>n'.\n       m = eSuc n' \\<Longrightarrow>\n       m = 0 \\<or>\n       (\\<exists>m' n' k.\n           m = eSuc m' \\<and>\n           n = n' + enat k \\<and>\n           k \\<noteq> 0 \\<and>\n           ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  m = 0\n\ngoal (1 subgoal):\n 1. m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "by simp"], ["proof (state)\nthis:\n  m = 0 \\<or>\n  (\\<exists>m' n' k.\n      m = eSuc m' \\<and>\n      n = n' + enat k \\<and>\n      k \\<noteq> 0 \\<and>\n      ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))\n\ngoal (1 subgoal):\n 1. \\<And>n'.\n       m = eSuc n' \\<Longrightarrow>\n       m = 0 \\<or>\n       (\\<exists>m' n' k.\n           m = eSuc m' \\<and>\n           n = n' + enat k \\<and>\n           k \\<noteq> 0 \\<and>\n           ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'.\n       m = eSuc n' \\<Longrightarrow>\n       m = 0 \\<or>\n       (\\<exists>m' n' k.\n           m = eSuc m' \\<and>\n           n = n' + enat k \\<and>\n           k \\<noteq> 0 \\<and>\n           ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "case (eSuc m')"], ["proof (state)\nthis:\n  m = eSuc m'\n\ngoal (1 subgoal):\n 1. \\<And>n'.\n       m = eSuc n' \\<Longrightarrow>\n       m = 0 \\<or>\n       (\\<exists>m' n' k.\n           m = eSuc m' \\<and>\n           n = n' + enat k \\<and>\n           k \\<noteq> 0 \\<and>\n           ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "with step[OF \\<open>P m n\\<close>]"], ["proof (chain)\npicking this:\n  (n = 0 \\<longrightarrow> m = 0) \\<and>\n  (m \\<noteq> 0 \\<longrightarrow>\n   n \\<noteq> 0 \\<longrightarrow>\n   (\\<exists>k n'. P (epred m) n' \\<and> epred n = n' + k) \\<or>\n   epred m \\<le> epred n)\n  m = eSuc m'", "have \"n \\<noteq> 0\" and disj: \"(\\<exists>k n'. P m' n' \\<and> epred n = n' + k) \\<or> m' \\<le> epred n\""], ["proof (prove)\nusing this:\n  (n = 0 \\<longrightarrow> m = 0) \\<and>\n  (m \\<noteq> 0 \\<longrightarrow>\n   n \\<noteq> 0 \\<longrightarrow>\n   (\\<exists>k n'. P (epred m) n' \\<and> epred n = n' + k) \\<or>\n   epred m \\<le> epred n)\n  m = eSuc m'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 &&&\n    (\\<exists>k n'. P m' n' \\<and> epred n = n' + k) \\<or> m' \\<le> epred n", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> 0\n  (\\<exists>k n'. P m' n' \\<and> epred n = n' + k) \\<or> m' \\<le> epred n\n\ngoal (1 subgoal):\n 1. \\<And>n'.\n       m = eSuc n' \\<Longrightarrow>\n       m = 0 \\<or>\n       (\\<exists>m' n' k.\n           m = eSuc m' \\<and>\n           n = n' + enat k \\<and>\n           k \\<noteq> 0 \\<and>\n           ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "from \\<open>n \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "obtain n' where n': \"n = eSuc n'\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>n'. n = eSuc n' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n rule: enat_coexhaust) auto"], ["proof (state)\nthis:\n  n = eSuc n'\n\ngoal (1 subgoal):\n 1. \\<And>n'.\n       m = eSuc n' \\<Longrightarrow>\n       m = 0 \\<or>\n       (\\<exists>m' n' k.\n           m = eSuc m' \\<and>\n           n = n' + enat k \\<and>\n           k \\<noteq> 0 \\<and>\n           ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "from disj"], ["proof (chain)\npicking this:\n  (\\<exists>k n'. P m' n' \\<and> epred n = n' + k) \\<or> m' \\<le> epred n", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>k n'. P m' n' \\<and> epred n = n' + k) \\<or> m' \\<le> epred n\n\ngoal (1 subgoal):\n 1. m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>k n'. P m' n' \\<and> epred n = n' + k \\<Longrightarrow>\n    m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))\n 2. m' \\<le> epred n \\<Longrightarrow>\n    m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "assume \"m' \\<le> epred n\""], ["proof (state)\nthis:\n  m' \\<le> epred n\n\ngoal (2 subgoals):\n 1. \\<exists>k n'. P m' n' \\<and> epred n = n' + k \\<Longrightarrow>\n    m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))\n 2. m' \\<le> epred n \\<Longrightarrow>\n    m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "with eSuc n'"], ["proof (chain)\npicking this:\n  m = eSuc m'\n  n = eSuc n'\n  m' \\<le> epred n", "show ?thesis"], ["proof (prove)\nusing this:\n  m = eSuc m'\n  n = eSuc n'\n  m' \\<le> epred n\n\ngoal (1 subgoal):\n 1. m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "by(auto 4 3 intro: exI[where x=\"Suc 0\"] simp add: eSuc_enat[symmetric] iadd_Suc_right zero_enat_def[symmetric])"], ["proof (state)\nthis:\n  m = 0 \\<or>\n  (\\<exists>m' n' k.\n      m = eSuc m' \\<and>\n      n = n' + enat k \\<and>\n      k \\<noteq> 0 \\<and>\n      ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))\n\ngoal (1 subgoal):\n 1. \\<exists>k n'. P m' n' \\<and> epred n = n' + k \\<Longrightarrow>\n    m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k n'. P m' n' \\<and> epred n = n' + k \\<Longrightarrow>\n    m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "assume \"\\<exists>k n'. P m' n' \\<and> epred n = n' + k\""], ["proof (state)\nthis:\n  \\<exists>k n'. P m' n' \\<and> epred n = n' + k\n\ngoal (1 subgoal):\n 1. \\<exists>k n'. P m' n' \\<and> epred n = n' + k \\<Longrightarrow>\n    m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "then"], ["proof (chain)\npicking this:\n  \\<exists>k n'. P m' n' \\<and> epred n = n' + k", "obtain k n'' where n'': \"epred n = n'' + k\" and k: \"P m' n''\""], ["proof (prove)\nusing this:\n  \\<exists>k n'. P m' n' \\<and> epred n = n' + k\n\ngoal (1 subgoal):\n 1. (\\<And>n'' k.\n        \\<lbrakk>epred n = n'' + k; P m' n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  epred n = n'' + k\n  P m' n''\n\ngoal (1 subgoal):\n 1. \\<exists>k n'. P m' n' \\<and> epred n = n' + k \\<Longrightarrow>\n    m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "using eSuc k n' n''"], ["proof (prove)\nusing this:\n  m = eSuc m'\n  P m' n''\n  n = eSuc n'\n  epred n = n'' + k\n\ngoal (1 subgoal):\n 1. m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))", "by(cases k)(auto 4 3 simp add: iadd_Suc_right[symmetric] eSuc_enat intro: exI[where x=\\<infinity>])"], ["proof (state)\nthis:\n  m = 0 \\<or>\n  (\\<exists>m' n' k.\n      m = eSuc m' \\<and>\n      n = n' + enat k \\<and>\n      k \\<noteq> 0 \\<and>\n      ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m = 0 \\<or>\n  (\\<exists>m' n' k.\n      m = eSuc m' \\<and>\n      n = n' + enat k \\<and>\n      k \\<noteq> 0 \\<and>\n      ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m = 0 \\<or>\n  (\\<exists>m' n' k.\n      m = eSuc m' \\<and>\n      n = n' + enat k \\<and>\n      k \\<noteq> 0 \\<and>\n      ((m', n') \\<in> {(m, n). P m n} \\<or> m' \\<le> n'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Equality as greatest fixpoint\\<close>"], ["", "lemma enat_equalityI [consumes 1, case_names Eq_enat,\n                                  case_conclusion Eq_enat zero eSuc]:\n  assumes major: \"(m, n) \\<in> X\"\n  and step:\n    \"\\<And>m n. (m, n) \\<in> X\n     \\<Longrightarrow> m = 0 \\<and> n = 0 \\<or> (\\<exists>m' n'. m = eSuc m' \\<and> n = eSuc n' \\<and> ((m', n') \\<in> X \\<or> m' = n'))\"\n  shows \"m = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = n", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. m \\<le> n\n 2. n \\<le> m", "from major"], ["proof (chain)\npicking this:\n  (m, n) \\<in> X", "show \"m \\<le> n\""], ["proof (prove)\nusing this:\n  (m, n) \\<in> X\n\ngoal (1 subgoal):\n 1. m \\<le> n", "by(coinduct rule: enat_leI)\n      (drule step, auto simp add: eSuc_plus_1 enat_1[symmetric])"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. n \\<le> m", "from major"], ["proof (chain)\npicking this:\n  (m, n) \\<in> X", "have \"(n, m) \\<in> {(n, m). (m, n) \\<in> X}\""], ["proof (prove)\nusing this:\n  (m, n) \\<in> X\n\ngoal (1 subgoal):\n 1. (n, m) \\<in> {(n, m). (m, n) \\<in> X}", "by simp"], ["proof (state)\nthis:\n  (n, m) \\<in> {(n, m). (m, n) \\<in> X}\n\ngoal (1 subgoal):\n 1. n \\<le> m", "thus \"n \\<le> m\""], ["proof (prove)\nusing this:\n  (n, m) \\<in> {(n, m). (m, n) \\<in> X}\n\ngoal (1 subgoal):\n 1. n \\<le> m", "proof(coinduct rule: enat_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (m, n) \\<in> {(n, m). (m, n) \\<in> X} \\<Longrightarrow>\n       m = 0 \\<or>\n       (\\<exists>m' n' k.\n           m = eSuc m' \\<and>\n           n = n' + enat k \\<and>\n           k \\<noteq> 0 \\<and>\n           ((m', n') \\<in> {(n, m). (m, n) \\<in> X} \\<or> m' \\<le> n'))", "case (Leenat n m)"], ["proof (state)\nthis:\n  (n, m) \\<in> {(n, m). (m, n) \\<in> X}\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (m, n) \\<in> {(n, m). (m, n) \\<in> X} \\<Longrightarrow>\n       m = 0 \\<or>\n       (\\<exists>m' n' k.\n           m = eSuc m' \\<and>\n           n = n' + enat k \\<and>\n           k \\<noteq> 0 \\<and>\n           ((m', n') \\<in> {(n, m). (m, n) \\<in> X} \\<or> m' \\<le> n'))", "hence \"(m, n) \\<in> X\""], ["proof (prove)\nusing this:\n  (n, m) \\<in> {(n, m). (m, n) \\<in> X}\n\ngoal (1 subgoal):\n 1. (m, n) \\<in> X", "by simp"], ["proof (state)\nthis:\n  (m, n) \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (m, n) \\<in> {(n, m). (m, n) \\<in> X} \\<Longrightarrow>\n       m = 0 \\<or>\n       (\\<exists>m' n' k.\n           m = eSuc m' \\<and>\n           n = n' + enat k \\<and>\n           k \\<noteq> 0 \\<and>\n           ((m', n') \\<in> {(n, m). (m, n) \\<in> X} \\<or> m' \\<le> n'))", "from step[OF this]"], ["proof (chain)\npicking this:\n  m = 0 \\<and> n = 0 \\<or>\n  (\\<exists>m' n'.\n      m = eSuc m' \\<and>\n      n = eSuc n' \\<and> ((m', n') \\<in> X \\<or> m' = n'))", "show ?case"], ["proof (prove)\nusing this:\n  m = 0 \\<and> n = 0 \\<or>\n  (\\<exists>m' n'.\n      m = eSuc m' \\<and>\n      n = eSuc n' \\<and> ((m', n') \\<in> X \\<or> m' = n'))\n\ngoal (1 subgoal):\n 1. n = 0 \\<or>\n    (\\<exists>m' n' k.\n        n = eSuc m' \\<and>\n        m = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n') \\<in> {(n, m). (m, n) \\<in> X} \\<or> m' \\<le> n'))", "by(auto simp add: eSuc_plus_1 enat_1[symmetric])"], ["proof (state)\nthis:\n  n = 0 \\<or>\n  (\\<exists>m' n' k.\n      n = eSuc m' \\<and>\n      m = n' + enat k \\<and>\n      k \\<noteq> 0 \\<and>\n      ((m', n') \\<in> {(n, m). (m, n) \\<in> X} \\<or> m' \\<le> n'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<le> m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enat_coinduct [consumes 1, case_names Eq_enat, case_conclusion Eq_enat zero eSuc]:\n  assumes major: \"P m n\"\n  and step: \"\\<And>m n. P m n \n    \\<Longrightarrow> (m = 0 \\<longleftrightarrow> n = 0) \\<and>\n       (m \\<noteq> 0 \\<longrightarrow> n \\<noteq> 0 \\<longrightarrow> P (epred m) (epred n) \\<or> epred m = epred n)\"\n  shows \"m = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m = n", "from major"], ["proof (chain)\npicking this:\n  P m n", "have \"(m, n) \\<in> {(m, n). P m n}\""], ["proof (prove)\nusing this:\n  P m n\n\ngoal (1 subgoal):\n 1. (m, n) \\<in> {(m, n). P m n}", "by simp"], ["proof (state)\nthis:\n  (m, n) \\<in> {(m, n). P m n}\n\ngoal (1 subgoal):\n 1. m = n", "thus ?thesis"], ["proof (prove)\nusing this:\n  (m, n) \\<in> {(m, n). P m n}\n\ngoal (1 subgoal):\n 1. m = n", "proof(coinduct rule: enat_equalityI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (m, n) \\<in> {(m, n). P m n} \\<Longrightarrow>\n       m = 0 \\<and> n = 0 \\<or>\n       (\\<exists>m' n'.\n           m = eSuc m' \\<and>\n           n = eSuc n' \\<and>\n           ((m', n') \\<in> {(m, n). P m n} \\<or> m' = n'))", "case (Eq_enat m n)"], ["proof (state)\nthis:\n  (m, n) \\<in> {(m, n). P m n}\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (m, n) \\<in> {(m, n). P m n} \\<Longrightarrow>\n       m = 0 \\<and> n = 0 \\<or>\n       (\\<exists>m' n'.\n           m = eSuc m' \\<and>\n           n = eSuc n' \\<and>\n           ((m', n') \\<in> {(m, n). P m n} \\<or> m' = n'))", "hence \"P m n\""], ["proof (prove)\nusing this:\n  (m, n) \\<in> {(m, n). P m n}\n\ngoal (1 subgoal):\n 1. P m n", "by simp"], ["proof (state)\nthis:\n  P m n\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (m, n) \\<in> {(m, n). P m n} \\<Longrightarrow>\n       m = 0 \\<and> n = 0 \\<or>\n       (\\<exists>m' n'.\n           m = eSuc m' \\<and>\n           n = eSuc n' \\<and>\n           ((m', n') \\<in> {(m, n). P m n} \\<or> m' = n'))", "from step[OF this]"], ["proof (chain)\npicking this:\n  (m = 0) = (n = 0) \\<and>\n  (m \\<noteq> 0 \\<longrightarrow>\n   n \\<noteq> 0 \\<longrightarrow>\n   P (epred m) (epred n) \\<or> epred m = epred n)", "show ?case"], ["proof (prove)\nusing this:\n  (m = 0) = (n = 0) \\<and>\n  (m \\<noteq> 0 \\<longrightarrow>\n   n \\<noteq> 0 \\<longrightarrow>\n   P (epred m) (epred n) \\<or> epred m = epred n)\n\ngoal (1 subgoal):\n 1. m = 0 \\<and> n = 0 \\<or>\n    (\\<exists>m' n'.\n        m = eSuc m' \\<and>\n        n = eSuc n' \\<and> ((m', n') \\<in> {(m, n). P m n} \\<or> m' = n'))", "by(cases m n rule: enat_coexhaust[case_product enat_coexhaust]) auto"], ["proof (state)\nthis:\n  m = 0 \\<and> n = 0 \\<or>\n  (\\<exists>m' n'.\n      m = eSuc m' \\<and>\n      n = eSuc n' \\<and> ((m', n') \\<in> {(m, n). P m n} \\<or> m' = n'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enat_coinduct2 [consumes 1, case_names zero eSuc]:\n  \"\\<lbrakk> P m n; \\<And>m n. P m n \\<Longrightarrow> m = 0 \\<longleftrightarrow> n = 0; \n     \\<And>m n. \\<lbrakk> P m n; m \\<noteq> 0; n \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> P (epred m) (epred n) \\<or> epred m = epred n \\<rbrakk>\n  \\<Longrightarrow> m = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P m n; \\<And>m n. P m n \\<Longrightarrow> (m = 0) = (n = 0);\n     \\<And>m n.\n        \\<lbrakk>P m n; m \\<noteq> 0; n \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> P (epred m) (epred n) \\<or>\n                          epred m = epred n\\<rbrakk>\n    \\<Longrightarrow> m = n", "by(erule enat_coinduct) blast"], ["", "subsection \\<open>Uniqueness of corecursion\\<close>"], ["", "lemma enat_unfold_unique:\n  assumes h: \"!!x. h x = (if stop x then 0 else eSuc (h (next x)))\"\n  shows \"h x = enat_unfold stop next x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h x = enat_unfold stop next x", "by(coinduction arbitrary: x rule: enat_coinduct)(subst (1 3) h, auto)"], ["", "subsection \\<open>Setup for partial\\_function\\<close>"], ["", "lemma enat_diff_cancel_left: \"\\<lbrakk> m \\<le> x; m \\<le> y \\<rbrakk> \\<Longrightarrow> x - m = y - m \\<longleftrightarrow> x = (y :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> x; m \\<le> y\\<rbrakk>\n    \\<Longrightarrow> (x - m = y - m) = (x = y)", "by(cases x y m rule: enat.exhaust[case_product enat.exhaust[case_product enat.exhaust]])(simp_all, arith)"], ["", "lemma finite_lessThan_enatI: \n  assumes \"m \\<noteq> \\<infinity>\"\n  shows \"finite {..<m :: enat}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {..<m}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {..<m}", "from assms"], ["proof (chain)\npicking this:\n  m \\<noteq> \\<infinity>", "obtain m' where m: \"m = enat m'\""], ["proof (prove)\nusing this:\n  m \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>m'. m = enat m' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  m = enat m'\n\ngoal (1 subgoal):\n 1. finite {..<m}", "have \"{..<enat m'} \\<subseteq> enat ` {..<m'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<enat m'} \\<subseteq> enat ` {..<m'}", "by(rule subsetI)(case_tac x, auto)"], ["proof (state)\nthis:\n  {..<enat m'} \\<subseteq> enat ` {..<m'}\n\ngoal (1 subgoal):\n 1. finite {..<m}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {..<enat m'} \\<subseteq> enat ` {..<m'}\n\ngoal (1 subgoal):\n 1. finite {..<m}", "unfolding m"], ["proof (prove)\nusing this:\n  {..<enat m'} \\<subseteq> enat ` {..<m'}\n\ngoal (1 subgoal):\n 1. finite {..<enat m'}", "by(rule finite_subset) simp"], ["proof (state)\nthis:\n  finite {..<m}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_lessThan_infty: \"\\<not> finite {..<\\<infinity> :: enat}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {..<\\<infinity>}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {..<\\<infinity>} \\<Longrightarrow> False", "have \"range enat \\<subseteq> {..<\\<infinity>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range enat \\<subseteq> {..<\\<infinity>}", "by auto"], ["proof (state)\nthis:\n  range enat \\<subseteq> {..<\\<infinity>}\n\ngoal (1 subgoal):\n 1. finite {..<\\<infinity>} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  range enat \\<subseteq> {..<\\<infinity>}\n\ngoal (1 subgoal):\n 1. finite {..<\\<infinity>} \\<Longrightarrow> False", "assume \"finite {..<\\<infinity> :: enat}\""], ["proof (state)\nthis:\n  finite {..<\\<infinity>}\n\ngoal (1 subgoal):\n 1. finite {..<\\<infinity>} \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  range enat \\<subseteq> {..<\\<infinity>}\n  finite {..<\\<infinity>}", "have \"finite (range enat)\""], ["proof (prove)\nusing this:\n  range enat \\<subseteq> {..<\\<infinity>}\n  finite {..<\\<infinity>}\n\ngoal (1 subgoal):\n 1. finite (range enat)", "by(rule finite_subset)"], ["proof (state)\nthis:\n  finite (range enat)\n\ngoal (1 subgoal):\n 1. finite {..<\\<infinity>} \\<Longrightarrow> False", "hence \"finite (UNIV :: nat set)\""], ["proof (prove)\nusing this:\n  finite (range enat)\n\ngoal (1 subgoal):\n 1. finite UNIV", "by(rule finite_imageD)(simp add: inj_on_def)"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite {..<\\<infinity>} \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_lessThan_enat_iff:\n  \"finite {..<m :: enat} \\<longleftrightarrow> m \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {..<m} = (m \\<noteq> \\<infinity>)", "by(cases m)(auto intro: finite_lessThan_enatI simp add: infinite_lessThan_infty)"], ["", "lemma enat_minus_mono1: \"x \\<le> y \\<Longrightarrow> x - m \\<le> y - (m :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x - m \\<le> y - m", "by(cases m x y rule: enat.exhaust[case_product enat.exhaust[case_product enat.exhaust]]) simp_all"], ["", "lemma max_enat_minus1: \"max n m - k = max (n - k) (m - k :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max n m - k = max (n - k) (m - k)", "by(cases n m k rule: enat.exhaust[case_product enat.exhaust[case_product enat.exhaust]]) simp_all"], ["", "lemma Max_enat_minus1:\n  assumes \"finite A\" \"A \\<noteq> {}\"\n  shows \"Max A - m = Max ((\\<lambda>n :: enat. n - m) ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max A - m = (MAX n\\<in>A. n - m)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max A - m = (MAX n\\<in>A. n - m)", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow> Max {} - m = (MAX n\\<in>{}. n - m)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Max F - m = (MAX n\\<in>F. n - m);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Max (insert x F) - m =\n                         (MAX n\\<in>insert x F. n - m)", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  A \\<noteq> {} \\<Longrightarrow> Max A - m = (MAX n\\<in>A. n - m)\n  insert x A \\<noteq> {}\n\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow> Max {} - m = (MAX n\\<in>{}. n - m)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Max F - m = (MAX n\\<in>F. n - m);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Max (insert x F) - m =\n                         (MAX n\\<in>insert x F. n - m)", "thus ?case"], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  A \\<noteq> {} \\<Longrightarrow> Max A - m = (MAX n\\<in>A. n - m)\n  insert x A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max (insert x A) - m = (MAX n\\<in>insert x A. n - m)", "by(cases \"A = {}\")(simp_all add: max_enat_minus1)"], ["proof (state)\nthis:\n  Max (insert x A) - m = (MAX n\\<in>insert x A. n - m)\n\ngoal (1 subgoal):\n 1. {} \\<noteq> {} \\<Longrightarrow> Max {} - m = (MAX n\\<in>{}. n - m)", "qed simp"], ["", "lemma Sup_enat_minus1: \n  assumes \"m \\<noteq> \\<infinity>\"\n  shows \"\\<Squnion>A - m = \\<Squnion>((\\<lambda>n :: enat. n - m) ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> A - m = (\\<Squnion>n\\<in>A. n - m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Squnion> A - m = (\\<Squnion>n\\<in>A. n - m)", "from assms"], ["proof (chain)\npicking this:\n  m \\<noteq> \\<infinity>", "obtain m' where \"m = enat m'\""], ["proof (prove)\nusing this:\n  m \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>m'. m = enat m' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  m = enat m'\n\ngoal (1 subgoal):\n 1. \\<Squnion> A - m = (\\<Squnion>n\\<in>A. n - m)", "thus ?thesis"], ["proof (prove)\nusing this:\n  m = enat m'\n\ngoal (1 subgoal):\n 1. \\<Squnion> A - m = (\\<Squnion>n\\<in>A. n - m)", "by(auto simp add: Sup_enat_def Max_enat_minus1 finite_lessThan_enat_iff enat_diff_cancel_left inj_on_def dest!: finite_imageD2[where B=\"{..<enat m'}\"])"], ["proof (state)\nthis:\n  \\<Squnion> A - m = (\\<Squnion>n\\<in>A. n - m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Sup_image_eadd1:\n  assumes \"Y \\<noteq> {}\"\n  shows \"Sup ((\\<lambda>y :: enat. y+x) ` Y) = Sup Y + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "proof(cases \"finite Y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite Y \\<Longrightarrow> (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x\n 2. infinite Y \\<Longrightarrow>\n    (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "case True"], ["proof (state)\nthis:\n  finite Y\n\ngoal (2 subgoals):\n 1. finite Y \\<Longrightarrow> (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x\n 2. infinite Y \\<Longrightarrow>\n    (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite Y\n\ngoal (1 subgoal):\n 1. (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "by(simp add: Sup_enat_def Max_add_commute assms)"], ["proof (state)\nthis:\n  (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x\n\ngoal (1 subgoal):\n 1. infinite Y \\<Longrightarrow>\n    (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite Y \\<Longrightarrow>\n    (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "case False"], ["proof (state)\nthis:\n  infinite Y\n\ngoal (1 subgoal):\n 1. infinite Y \\<Longrightarrow>\n    (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite Y\n\ngoal (1 subgoal):\n 1. (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "proof(cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>infinite Y; x = enat nat\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x\n 2. \\<lbrakk>infinite Y; x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "case (enat x')"], ["proof (state)\nthis:\n  x = enat x'\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>infinite Y; x = enat nat\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x\n 2. \\<lbrakk>infinite Y; x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "hence \"\\<not> finite ((\\<lambda>y. y+x) ` Y)\""], ["proof (prove)\nusing this:\n  x = enat x'\n\ngoal (1 subgoal):\n 1. infinite ((\\<lambda>y. y + x) ` Y)", "using False"], ["proof (prove)\nusing this:\n  x = enat x'\n  infinite Y\n\ngoal (1 subgoal):\n 1. infinite ((\\<lambda>y. y + x) ` Y)", "by(auto dest!: finite_imageD intro: inj_onI)"], ["proof (state)\nthis:\n  infinite ((\\<lambda>y. y + x) ` Y)\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>infinite Y; x = enat nat\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x\n 2. \\<lbrakk>infinite Y; x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "with False"], ["proof (chain)\npicking this:\n  infinite Y\n  infinite ((\\<lambda>y. y + x) ` Y)", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite Y\n  infinite ((\\<lambda>y. y + x) ` Y)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "by(simp add: Sup_enat_def assms)"], ["proof (state)\nthis:\n  (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>infinite Y; x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>infinite Y; x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "case infinity"], ["proof (state)\nthis:\n  x = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>infinite Y; x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "hence \"(+) x ` Y = {\\<infinity>}\""], ["proof (prove)\nusing this:\n  x = \\<infinity>\n\ngoal (1 subgoal):\n 1. (+) x ` Y = {\\<infinity>}", "using assms"], ["proof (prove)\nusing this:\n  x = \\<infinity>\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (+) x ` Y = {\\<infinity>}", "by auto"], ["proof (state)\nthis:\n  (+) x ` Y = {\\<infinity>}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>infinite Y; x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "thus ?thesis"], ["proof (prove)\nusing this:\n  (+) x ` Y = {\\<infinity>}\n\ngoal (1 subgoal):\n 1. (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "using infinity"], ["proof (prove)\nusing this:\n  (+) x ` Y = {\\<infinity>}\n  x = \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x", "by(simp add: image_constant_conv assms)"], ["proof (state)\nthis:\n  (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Squnion>y\\<in>Y. y + x) = \\<Squnion> Y + x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Sup_image_eadd2:\n  \"Y \\<noteq> {} \\<Longrightarrow> Sup ((\\<lambda>y :: enat. x + y) ` Y) = x + Sup Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    \\<Squnion> ((+) x ` Y) = x + \\<Squnion> Y", "by(simp add: Sup_image_eadd1 add.commute)"], ["", "lemma mono2mono_eSuc [THEN lfp.mono2mono, cont_intro, simp]:\n  shows monotone_eSuc: \"monotone (\\<le>) (\\<le>) eSuc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) eSuc", "by(rule monotoneI) simp"], ["", "lemma mcont2mcont_eSuc [THEN lfp.mcont2mcont, cont_intro, simp]:\n  shows mcont_eSuc: \"mcont Sup (\\<le>) Sup (\\<le>) eSuc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) Sup (\\<le>) eSuc", "by(intro mcontI contI)(simp_all add: monotone_eSuc eSuc_Sup)"], ["", "lemma mono2mono_epred [THEN lfp.mono2mono, cont_intro, simp]:\n  shows monotone_epred: \"monotone (\\<le>) (\\<le>) epred\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) epred", "by(rule monotoneI)(simp add: epred_le_epredI)"], ["", "lemma mcont2mcont_epred [THEN lfp.mcont2mcont, cont_intro, simp]:\n  shows mcont_epred: \"mcont Sup (\\<le>) Sup (\\<le>) epred\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) Sup (\\<le>) epred", "by(simp add: mcont_def monotone_epred cont_def epred_Sup)"], ["", "lemma enat_cocase_mono [partial_function_mono, cont_intro]: \n  \"\\<lbrakk> monotone orda ordb zero; \\<And>n. monotone orda ordb (\\<lambda>f. esuc f n) \\<rbrakk>\n  \\<Longrightarrow> monotone orda ordb (\\<lambda>f. co.case_enat (zero f) (esuc f) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monotone orda ordb zero;\n     \\<And>n. monotone orda ordb (\\<lambda>f. esuc f n)\\<rbrakk>\n    \\<Longrightarrow> monotone orda ordb\n                       (\\<lambda>f.\n                           case x of 0 \\<Rightarrow> zero f\n                           | eSuc x \\<Rightarrow> esuc f x)", "by(cases x rule: co.enat.exhaust) simp_all"], ["", "lemma enat_cocase_mcont [cont_intro, simp]:\n  \"\\<lbrakk> mcont luba orda lubb ordb zero; \\<And>n. mcont luba orda lubb ordb (\\<lambda>f. esuc f n) \\<rbrakk>\n  \\<Longrightarrow> mcont luba orda lubb ordb (\\<lambda>f. co.case_enat (zero f) (esuc f) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mcont luba orda lubb ordb zero;\n     \\<And>n. mcont luba orda lubb ordb (\\<lambda>f. esuc f n)\\<rbrakk>\n    \\<Longrightarrow> mcont luba orda lubb ordb\n                       (\\<lambda>f.\n                           case x of 0 \\<Rightarrow> zero f\n                           | eSuc x \\<Rightarrow> esuc f x)", "by(cases x rule: co.enat.exhaust) simp_all"], ["", "lemma eSuc_mono [partial_function_mono]:\n  \"monotone (fun_ord (\\<le>)) (\\<le>) f \\<Longrightarrow> monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>x. eSuc (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (fun_ord (\\<le>)) (\\<le>) f \\<Longrightarrow>\n    monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>x. eSuc (f x))", "by(rule mono2mono_eSuc)"], ["", "lemma mono2mono_enat_minus1 [THEN lfp.mono2mono, cont_intro, simp]:\n  shows monotone_enat_minus1: \"monotone (\\<le>) (\\<le>) (\\<lambda>n. n - m :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) (\\<lambda>n. n - m)", "by(rule monotoneI)(rule enat_minus_mono1)"], ["", "lemma mcont2mcont_enat_minus [THEN lfp.mcont2mcont, cont_intro, simp]:\n  shows mcont_enat_minus: \"m \\<noteq> \\<infinity> \\<Longrightarrow> mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>n. n - m :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> \\<infinity> \\<Longrightarrow>\n    mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>n. n - m)", "by(rule mcontI)(simp_all add: monotone_enat_minus1 contI Sup_enat_minus1)"], ["", "lemma monotone_eadd1: \"monotone (\\<le>) (\\<le>) (\\<lambda>x. x + y :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) (\\<lambda>x. x + y)", "by(auto intro!: monotoneI)"], ["", "lemma monotone_eadd2: \"monotone (\\<le>) (\\<le>) (\\<lambda>y. x + y :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) ((+) x)", "by(auto intro!: monotoneI)"], ["", "lemma mono2mono_eadd[THEN lfp.mono2mono2, cont_intro, simp]:\n  shows monotone_eadd: \"monotone (rel_prod (\\<le>) (\\<le>)) (\\<le>) (\\<lambda>(x, y). x + y :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (rel_prod (\\<le>) (\\<le>)) (\\<le>) (\\<lambda>(x, y). x + y)", "by(simp add: monotone_eadd1 monotone_eadd2)"], ["", "lemma mcont_eadd2: \"mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>y. x + y :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) Sup (\\<le>) ((+) x)", "by(auto intro: mcontI monotone_eadd2 contI Sup_image_eadd2[symmetric])"], ["", "lemma mcont_eadd1: \"mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>x. x + y :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>x. x + y)", "by(auto intro: mcontI monotone_eadd1 contI Sup_image_eadd1[symmetric])"], ["", "lemma mcont2mcont_eadd [cont_intro, simp]:\n  \"\\<lbrakk> mcont lub ord Sup (\\<le>) (\\<lambda>x. f x);\n    mcont lub ord Sup (\\<le>) (\\<lambda>x. g x) \\<rbrakk>\n  \\<Longrightarrow> mcont lub ord Sup (\\<le>) (\\<lambda>x. f x + g x :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mcont lub ord Sup (\\<le>) f;\n     mcont lub ord Sup (\\<le>) g\\<rbrakk>\n    \\<Longrightarrow> mcont lub ord Sup (\\<le>) (\\<lambda>x. f x + g x)", "by(best intro: ccpo.mcont2mcont'[OF complete_lattice_ccpo] mcont_eadd1 mcont_eadd2 ccpo.mcont_const[OF complete_lattice_ccpo])"], ["", "lemma eadd_partial_function_mono [partial_function_mono]:\n  \"\\<lbrakk> monotone (fun_ord (\\<le>)) (\\<le>) f; monotone (fun_ord (\\<le>)) (\\<le>) g \\<rbrakk>\n  \\<Longrightarrow> monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>x. f x + g x :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monotone (fun_ord (\\<le>)) (\\<le>) f;\n     monotone (fun_ord (\\<le>)) (\\<le>) g\\<rbrakk>\n    \\<Longrightarrow> monotone (fun_ord (\\<le>)) (\\<le>)\n                       (\\<lambda>x. f x + g x)", "by(rule mono2mono_eadd)"], ["", "lemma monotone_max_enat1: \"monotone (\\<le>) (\\<le>) (\\<lambda>x. max x y :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) (\\<lambda>x. max x y)", "by(auto intro!: monotoneI simp add: max_def)"], ["", "lemma monotone_max_enat2: \"monotone (\\<le>) (\\<le>) (\\<lambda>y. max x y :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) (max x)", "by(auto intro!: monotoneI simp add: max_def)"], ["", "lemma mono2mono_max_enat[THEN lfp.mono2mono2, cont_intro, simp]:\n  shows monotone_max_enat: \"monotone (rel_prod (\\<le>) (\\<le>)) (\\<le>) (\\<lambda>(x, y). max x y :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (rel_prod (\\<le>) (\\<le>)) (\\<le>) (\\<lambda>(x, y). max x y)", "by(simp add: monotone_max_enat1 monotone_max_enat2)"], ["", "lemma max_Sup_enat2:\n  assumes \"Y \\<noteq> {}\"\n  shows \"max x (Sup Y) = Sup ((\\<lambda>y :: enat. max x y) ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "proof(cases \"finite Y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite Y \\<Longrightarrow> max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)\n 2. infinite Y \\<Longrightarrow>\n    max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "case True"], ["proof (state)\nthis:\n  finite Y\n\ngoal (2 subgoals):\n 1. finite Y \\<Longrightarrow> max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)\n 2. infinite Y \\<Longrightarrow>\n    max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "hence \"max x (Max Y) = Max (max x ` Y)\""], ["proof (prove)\nusing this:\n  finite Y\n\ngoal (1 subgoal):\n 1. max x (Max Y) = Max (max x ` Y)", "using assms"], ["proof (prove)\nusing this:\n  finite Y\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. max x (Max Y) = Max (max x ` Y)", "proof(induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow> max x (Max {}) = Max (max x ` {})\n 2. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> max x (Max F) = Max (max x ` F);\n        insert xa F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> max x (Max (insert xa F)) =\n                         Max (max x ` insert xa F)", "case (insert y Y)"], ["proof (state)\nthis:\n  finite Y\n  y \\<notin> Y\n  Y \\<noteq> {} \\<Longrightarrow> max x (Max Y) = Max (max x ` Y)\n  insert y Y \\<noteq> {}\n\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow> max x (Max {}) = Max (max x ` {})\n 2. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> max x (Max F) = Max (max x ` F);\n        insert xa F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> max x (Max (insert xa F)) =\n                         Max (max x ` insert xa F)", "thus ?case"], ["proof (prove)\nusing this:\n  finite Y\n  y \\<notin> Y\n  Y \\<noteq> {} \\<Longrightarrow> max x (Max Y) = Max (max x ` Y)\n  insert y Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. max x (Max (insert y Y)) = Max (max x ` insert y Y)", "by(cases \"Y = {}\")(simp_all, metis max.assoc max.left_commute max.left_idem)"], ["proof (state)\nthis:\n  max x (Max (insert y Y)) = Max (max x ` insert y Y)\n\ngoal (1 subgoal):\n 1. {} \\<noteq> {} \\<Longrightarrow> max x (Max {}) = Max (max x ` {})", "qed simp"], ["proof (state)\nthis:\n  max x (Max Y) = Max (max x ` Y)\n\ngoal (2 subgoals):\n 1. finite Y \\<Longrightarrow> max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)\n 2. infinite Y \\<Longrightarrow>\n    max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  max x (Max Y) = Max (max x ` Y)\n\ngoal (1 subgoal):\n 1. max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "using True"], ["proof (prove)\nusing this:\n  max x (Max Y) = Max (max x ` Y)\n  finite Y\n\ngoal (1 subgoal):\n 1. max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "by(simp add: Sup_enat_def assms)"], ["proof (state)\nthis:\n  max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)\n\ngoal (1 subgoal):\n 1. infinite Y \\<Longrightarrow>\n    max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite Y \\<Longrightarrow>\n    max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "case False"], ["proof (state)\nthis:\n  infinite Y\n\ngoal (1 subgoal):\n 1. infinite Y \\<Longrightarrow>\n    max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "proof(cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)\n 2. x = \\<infinity> \\<Longrightarrow>\n    max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "case infinity"], ["proof (state)\nthis:\n  x = \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)\n 2. x = \\<infinity> \\<Longrightarrow>\n    max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "hence \"max x ` Y = {\\<infinity>}\""], ["proof (prove)\nusing this:\n  x = \\<infinity>\n\ngoal (1 subgoal):\n 1. max x ` Y = {\\<infinity>}", "using assms"], ["proof (prove)\nusing this:\n  x = \\<infinity>\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. max x ` Y = {\\<infinity>}", "by auto"], ["proof (state)\nthis:\n  max x ` Y = {\\<infinity>}\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)\n 2. x = \\<infinity> \\<Longrightarrow>\n    max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  max x ` Y = {\\<infinity>}\n\ngoal (1 subgoal):\n 1. max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "using False"], ["proof (prove)\nusing this:\n  max x ` Y = {\\<infinity>}\n  infinite Y\n\ngoal (1 subgoal):\n 1. max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "by(simp add: Sup_enat_def assms)"], ["proof (state)\nthis:\n  max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "case (enat x')"], ["proof (state)\nthis:\n  x = enat x'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "{"], ["proof (state)\nthis:\n  x = enat x'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "assume \"finite (max x ` Y)\""], ["proof (state)\nthis:\n  finite (max x ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "hence \"finite (max x ` {y \\<in> Y. y > x})\""], ["proof (prove)\nusing this:\n  finite (max x ` Y)\n\ngoal (1 subgoal):\n 1. finite (max x ` {y \\<in> Y. x < y})", "by(rule finite_subset[rotated]) auto"], ["proof (state)\nthis:\n  finite (max x ` {y \\<in> Y. x < y})\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "hence \"finite {y \\<in> Y. y > x}\""], ["proof (prove)\nusing this:\n  finite (max x ` {y \\<in> Y. x < y})\n\ngoal (1 subgoal):\n 1. finite {y \\<in> Y. x < y}", "by(rule finite_imageD)(auto intro!: inj_onI simp add: max_def split: if_split_asm)"], ["proof (state)\nthis:\n  finite {y \\<in> Y. x < y}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "moreover"], ["proof (state)\nthis:\n  finite {y \\<in> Y. x < y}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "have \"finite {y \\<in> Y. y \\<le> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {y \\<in> Y. y \\<le> x}", "by(rule finite_enat_bounded)(auto simp add: enat)"], ["proof (state)\nthis:\n  finite {y \\<in> Y. y \\<le> x}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "ultimately"], ["proof (chain)\npicking this:\n  finite {y \\<in> Y. x < y}\n  finite {y \\<in> Y. y \\<le> x}", "have \"finite ({y \\<in> Y. y > x} \\<union> {y \\<in> Y. y \\<le> x})\""], ["proof (prove)\nusing this:\n  finite {y \\<in> Y. x < y}\n  finite {y \\<in> Y. y \\<le> x}\n\ngoal (1 subgoal):\n 1. finite ({y \\<in> Y. x < y} \\<union> {y \\<in> Y. y \\<le> x})", "by simp"], ["proof (state)\nthis:\n  finite ({y \\<in> Y. x < y} \\<union> {y \\<in> Y. y \\<le> x})\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "also"], ["proof (state)\nthis:\n  finite ({y \\<in> Y. x < y} \\<union> {y \\<in> Y. y \\<le> x})\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "have \"{y \\<in> Y. y > x} \\<union> {y \\<in> Y. y \\<le> x} = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y \\<in> Y. x < y} \\<union> {y \\<in> Y. y \\<le> x} = Y", "by auto"], ["proof (state)\nthis:\n  {y \\<in> Y. x < y} \\<union> {y \\<in> Y. y \\<le> x} = Y\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "finally"], ["proof (chain)\npicking this:\n  finite Y", "have \"finite Y\""], ["proof (prove)\nusing this:\n  finite Y\n\ngoal (1 subgoal):\n 1. finite Y", "."], ["proof (state)\nthis:\n  finite Y\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "}"], ["proof (state)\nthis:\n  finite (max x ` Y) \\<Longrightarrow> finite Y\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x = enat nat \\<Longrightarrow>\n       max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite (max x ` Y) \\<Longrightarrow> finite Y\n\ngoal (1 subgoal):\n 1. max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "using False"], ["proof (prove)\nusing this:\n  finite (max x ` Y) \\<Longrightarrow> finite Y\n  infinite Y\n\ngoal (1 subgoal):\n 1. max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)", "by(auto simp add: Sup_enat_def assms)"], ["proof (state)\nthis:\n  max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  max x (\\<Squnion> Y) = \\<Squnion> (max x ` Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_Sup_enat1:\n  \"Y \\<noteq> {} \\<Longrightarrow> max (Sup Y) x = Sup ((\\<lambda>y :: enat. max y x) ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    max (\\<Squnion> Y) x = (\\<Squnion>y\\<in>Y. max y x)", "by(subst (1 2) max.commute)(rule max_Sup_enat2)"], ["", "lemma mcont_max_enat1: \"mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>x. max x y :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>x. max x y)", "by(auto intro!: mcontI contI max_Sup_enat1 simp add: monotone_max_enat1)"], ["", "lemma mcont_max_enat2: \"mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>y. max x y :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) Sup (\\<le>) (max x)", "by(auto intro!: mcontI contI max_Sup_enat2 simp add: monotone_max_enat2)"], ["", "lemma mcont2mcont_max_enat [cont_intro, simp]:\n  \"\\<lbrakk> mcont lub ord Sup (\\<le>) (\\<lambda>x. f x);\n    mcont lub ord Sup (\\<le>) (\\<lambda>x. g x) \\<rbrakk>\n  \\<Longrightarrow> mcont lub ord Sup (\\<le>) (\\<lambda>x. max (f x) (g x) :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mcont lub ord Sup (\\<le>) f;\n     mcont lub ord Sup (\\<le>) g\\<rbrakk>\n    \\<Longrightarrow> mcont lub ord Sup (\\<le>)\n                       (\\<lambda>x. max (f x) (g x))", "by(best intro: ccpo.mcont2mcont'[OF complete_lattice_ccpo] mcont_max_enat1 mcont_max_enat2 ccpo.mcont_const[OF complete_lattice_ccpo])"], ["", "lemma max_enat_partial_function_mono [partial_function_mono]:\n  \"\\<lbrakk> monotone (fun_ord (\\<le>)) (\\<le>) f; monotone (fun_ord (\\<le>)) (\\<le>) g \\<rbrakk>\n  \\<Longrightarrow> monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>x. max (f x) (g x) :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monotone (fun_ord (\\<le>)) (\\<le>) f;\n     monotone (fun_ord (\\<le>)) (\\<le>) g\\<rbrakk>\n    \\<Longrightarrow> monotone (fun_ord (\\<le>)) (\\<le>)\n                       (\\<lambda>x. max (f x) (g x))", "by(rule mono2mono_max_enat)"], ["", "lemma chain_epredI:\n  \"Complete_Partial_Order.chain (\\<le>) Y\n  \\<Longrightarrow> Complete_Partial_Order.chain (\\<le>) (epred ` (Y \\<inter> {x. x \\<noteq> 0}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) Y \\<Longrightarrow>\n    Complete_Partial_Order.chain (\\<le>)\n     (epred ` (Y \\<inter> {x. x \\<noteq> 0}))", "by(auto intro: chainI dest: chainD)"], ["", "lemma monotone_enat_le_case:\n  fixes bot\n  assumes mono: \"monotone (\\<le>) ord (\\<lambda>x. f x (eSuc x))\"\n  and ord: \"\\<And>x. ord bot (f x (eSuc x))\"\n  and bot: \"ord bot bot\"\n  shows \"monotone (\\<le>) ord (\\<lambda>x. case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) ord\n     (\\<lambda>x.\n         case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monotone (\\<le>) ord\n     (\\<lambda>x.\n         case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)", "have \"monotone (\\<le>) ord (\\<lambda>x. if x \\<le> 0 then bot else f (epred x) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) ord\n     (\\<lambda>x. if x \\<le> 0 then bot else f (epred x) x)", "proof(rule monotone_if_bot)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> ord (f (epred x) x) (f (epred y) y)\n 2. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)\n 3. ord bot bot", "fix x y :: enat"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> ord (f (epred x) x) (f (epred y) y)\n 2. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)\n 3. ord bot bot", "assume \"x \\<le> y\" \"\\<not> x \\<le> 0\""], ["proof (state)\nthis:\n  x \\<le> y\n  \\<not> x \\<le> 0\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> ord (f (epred x) x) (f (epred y) y)\n 2. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)\n 3. ord bot bot", "thus \"ord (f (epred x) x) (f (epred y) y)\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  \\<not> x \\<le> 0\n\ngoal (1 subgoal):\n 1. ord (f (epred x) x) (f (epred y) y)", "by(cases x y rule: co.enat.exhaust[case_product co.enat.exhaust])(auto intro: monotoneD[OF mono])"], ["proof (state)\nthis:\n  ord (f (epred x) x) (f (epred y) y)\n\ngoal (2 subgoals):\n 1. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)\n 2. ord bot bot", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)\n 2. ord bot bot", "fix x :: enat"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)\n 2. ord bot bot", "assume \"\\<not> x \\<le> 0\""], ["proof (state)\nthis:\n  \\<not> x \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)\n 2. ord bot bot", "thus \"ord bot (f (epred x) x)\""], ["proof (prove)\nusing this:\n  \\<not> x \\<le> 0\n\ngoal (1 subgoal):\n 1. ord bot (f (epred x) x)", "by(cases x rule: co.enat.exhaust)(auto intro: ord)"], ["proof (state)\nthis:\n  ord bot (f (epred x) x)\n\ngoal (1 subgoal):\n 1. ord bot bot", "qed(rule bot)"], ["proof (state)\nthis:\n  monotone (\\<le>) ord\n   (\\<lambda>x. if x \\<le> 0 then bot else f (epred x) x)\n\ngoal (1 subgoal):\n 1. monotone (\\<le>) ord\n     (\\<lambda>x.\n         case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)", "also"], ["proof (state)\nthis:\n  monotone (\\<le>) ord\n   (\\<lambda>x. if x \\<le> 0 then bot else f (epred x) x)\n\ngoal (1 subgoal):\n 1. monotone (\\<le>) ord\n     (\\<lambda>x.\n         case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)", "have \"(\\<lambda>x. if x \\<le> 0 then bot else f (epred x) x) = (\\<lambda>x. case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<le> 0 then bot else f (epred x) x) =\n    (\\<lambda>x.\n        case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)", "by(auto simp add: fun_eq_iff split: co.enat.split)"], ["proof (state)\nthis:\n  (\\<lambda>x. if x \\<le> 0 then bot else f (epred x) x) =\n  (\\<lambda>x. case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)\n\ngoal (1 subgoal):\n 1. monotone (\\<le>) ord\n     (\\<lambda>x.\n         case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)", "finally"], ["proof (chain)\npicking this:\n  monotone (\\<le>) ord\n   (\\<lambda>x.\n       case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)", "show ?thesis"], ["proof (prove)\nusing this:\n  monotone (\\<le>) ord\n   (\\<lambda>x.\n       case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)\n\ngoal (1 subgoal):\n 1. monotone (\\<le>) ord\n     (\\<lambda>x.\n         case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)", "."], ["proof (state)\nthis:\n  monotone (\\<le>) ord\n   (\\<lambda>x.\n       case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mcont_enat_le_case:\n  fixes bot\n  assumes ccpo: \"class.ccpo lub ord (mk_less ord)\"\n  and mcont: \"mcont Sup (\\<le>) lub ord (\\<lambda>x. f x (eSuc x))\"\n  and ord: \"\\<And>x. ord bot (f x (eSuc x))\"\n  shows \"mcont Sup (\\<le>) lub ord (\\<lambda>x. case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) lub ord\n     (\\<lambda>x.\n         case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) lub ord\n     (\\<lambda>x.\n         case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)", "from ccpo"], ["proof (chain)\npicking this:\n  class.ccpo lub ord (mk_less ord)", "have \"mcont Sup (\\<le>) lub ord (\\<lambda>x. if x \\<le> 0 then bot else f (epred x) x)\""], ["proof (prove)\nusing this:\n  class.ccpo lub ord (mk_less ord)\n\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) lub ord\n     (\\<lambda>x. if x \\<le> 0 then bot else f (epred x) x)", "proof(rule mcont_if_bot)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> ord (f (epred x) x) (f (epred y) y)\n 2. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) Y; Y \\<noteq> {};\n        \\<And>x. x \\<in> Y \\<Longrightarrow> \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> f (epred (\\<Squnion> Y)) (\\<Squnion> Y) =\n                         lub ((\\<lambda>x. f (epred x) x) ` Y)\n 3. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "fix x y :: enat"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> ord (f (epred x) x) (f (epred y) y)\n 2. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) Y; Y \\<noteq> {};\n        \\<And>x. x \\<in> Y \\<Longrightarrow> \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> f (epred (\\<Squnion> Y)) (\\<Squnion> Y) =\n                         lub ((\\<lambda>x. f (epred x) x) ` Y)\n 3. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "assume \"x \\<le> y\" \"\\<not> x \\<le> 0\""], ["proof (state)\nthis:\n  x \\<le> y\n  \\<not> x \\<le> 0\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> ord (f (epred x) x) (f (epred y) y)\n 2. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) Y; Y \\<noteq> {};\n        \\<And>x. x \\<in> Y \\<Longrightarrow> \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> f (epred (\\<Squnion> Y)) (\\<Squnion> Y) =\n                         lub ((\\<lambda>x. f (epred x) x) ` Y)\n 3. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "thus \"ord (f (epred x) x) (f (epred y) y)\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  \\<not> x \\<le> 0\n\ngoal (1 subgoal):\n 1. ord (f (epred x) x) (f (epred y) y)", "by(cases x y rule: co.enat.exhaust[case_product co.enat.exhaust])(auto intro: mcont_monoD[OF mcont])"], ["proof (state)\nthis:\n  ord (f (epred x) x) (f (epred y) y)\n\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) Y; Y \\<noteq> {};\n        \\<And>x. x \\<in> Y \\<Longrightarrow> \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> f (epred (\\<Squnion> Y)) (\\<Squnion> Y) =\n                         lub ((\\<lambda>x. f (epred x) x) ` Y)\n 2. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) Y; Y \\<noteq> {};\n        \\<And>x. x \\<in> Y \\<Longrightarrow> \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> f (epred (\\<Squnion> Y)) (\\<Squnion> Y) =\n                         lub ((\\<lambda>x. f (epred x) x) ` Y)\n 2. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "fix Y :: \"enat set\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) Y; Y \\<noteq> {};\n        \\<And>x. x \\<in> Y \\<Longrightarrow> \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> f (epred (\\<Squnion> Y)) (\\<Squnion> Y) =\n                         lub ((\\<lambda>x. f (epred x) x) ` Y)\n 2. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "assume chain: \"Complete_Partial_Order.chain (\\<le>) Y\"\n      and Y: \"Y \\<noteq> {}\" \"\\<And>x. x \\<in> Y \\<Longrightarrow> \\<not> x \\<le> 0\""], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) Y\n  Y \\<noteq> {}\n  ?x \\<in> Y \\<Longrightarrow> \\<not> ?x \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) Y; Y \\<noteq> {};\n        \\<And>x. x \\<in> Y \\<Longrightarrow> \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> f (epred (\\<Squnion> Y)) (\\<Squnion> Y) =\n                         lub ((\\<lambda>x. f (epred x) x) ` Y)\n 2. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "from Y"], ["proof (chain)\npicking this:\n  Y \\<noteq> {}\n  ?x \\<in> Y \\<Longrightarrow> \\<not> ?x \\<le> 0", "have Y': \"Y \\<inter> {x. x \\<noteq> 0} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  Y \\<noteq> {}\n  ?x \\<in> Y \\<Longrightarrow> \\<not> ?x \\<le> 0\n\ngoal (1 subgoal):\n 1. Y \\<inter> {x. x \\<noteq> 0} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Y \\<inter> {x. x \\<noteq> 0} \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) Y; Y \\<noteq> {};\n        \\<And>x. x \\<in> Y \\<Longrightarrow> \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> f (epred (\\<Squnion> Y)) (\\<Squnion> Y) =\n                         lub ((\\<lambda>x. f (epred x) x) ` Y)\n 2. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "from Y(2)"], ["proof (chain)\npicking this:\n  ?x \\<in> Y \\<Longrightarrow> \\<not> ?x \\<le> 0", "have eq: \"Y = eSuc ` (epred ` (Y \\<inter> {x. x \\<noteq> 0}))\""], ["proof (prove)\nusing this:\n  ?x \\<in> Y \\<Longrightarrow> \\<not> ?x \\<le> 0\n\ngoal (1 subgoal):\n 1. Y = eSuc ` epred ` (Y \\<inter> {x. x \\<noteq> 0})", "by(fastforce intro: rev_image_eqI)"], ["proof (state)\nthis:\n  Y = eSuc ` epred ` (Y \\<inter> {x. x \\<noteq> 0})\n\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) Y; Y \\<noteq> {};\n        \\<And>x. x \\<in> Y \\<Longrightarrow> \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> f (epred (\\<Squnion> Y)) (\\<Squnion> Y) =\n                         lub ((\\<lambda>x. f (epred x) x) ` Y)\n 2. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "let ?Y = \"epred ` (Y \\<inter> {x. x \\<noteq> 0})\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) Y; Y \\<noteq> {};\n        \\<And>x. x \\<in> Y \\<Longrightarrow> \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> f (epred (\\<Squnion> Y)) (\\<Squnion> Y) =\n                         lub ((\\<lambda>x. f (epred x) x) ` Y)\n 2. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "from chain_epredI [OF chain] Y'"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (\\<le>)\n   (epred ` (Y \\<inter> {x. x \\<noteq> 0}))\n  Y \\<inter> {x. x \\<noteq> 0} \\<noteq> {}", "have \"f (\\<Squnion>?Y) (eSuc (\\<Squnion>?Y)) = lub ((\\<lambda>x. f x (eSuc x)) ` ?Y)\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>)\n   (epred ` (Y \\<inter> {x. x \\<noteq> 0}))\n  Y \\<inter> {x. x \\<noteq> 0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. f (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))\n     (eSuc (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))) =\n    lub ((\\<lambda>x. f x (eSuc x)) `\n         epred ` (Y \\<inter> {x. x \\<noteq> 0}))", "using mcont [THEN mcont_contD]"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>)\n   (epred ` (Y \\<inter> {x. x \\<noteq> 0}))\n  Y \\<inter> {x. x \\<noteq> 0} \\<noteq> {}\n  \\<lbrakk>Complete_Partial_Order.chain (\\<le>) ?Y; ?Y \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> f (\\<Squnion> ?Y) (eSuc (\\<Squnion> ?Y)) =\n                    lub ((\\<lambda>x. f x (eSuc x)) ` ?Y)\n\ngoal (1 subgoal):\n 1. f (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))\n     (eSuc (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))) =\n    lub ((\\<lambda>x. f x (eSuc x)) `\n         epred ` (Y \\<inter> {x. x \\<noteq> 0}))", "by blast"], ["proof (state)\nthis:\n  f (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))\n   (eSuc (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))) =\n  lub ((\\<lambda>x. f x (eSuc x)) ` epred ` (Y \\<inter> {x. x \\<noteq> 0}))\n\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) Y; Y \\<noteq> {};\n        \\<And>x. x \\<in> Y \\<Longrightarrow> \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> f (epred (\\<Squnion> Y)) (\\<Squnion> Y) =\n                         lub ((\\<lambda>x. f (epred x) x) ` Y)\n 2. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "moreover"], ["proof (state)\nthis:\n  f (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))\n   (eSuc (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))) =\n  lub ((\\<lambda>x. f x (eSuc x)) ` epred ` (Y \\<inter> {x. x \\<noteq> 0}))\n\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) Y; Y \\<noteq> {};\n        \\<And>x. x \\<in> Y \\<Longrightarrow> \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> f (epred (\\<Squnion> Y)) (\\<Squnion> Y) =\n                         lub ((\\<lambda>x. f (epred x) x) ` Y)\n 2. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "from chain_epredI [OF chain] Y'"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (\\<le>)\n   (epred ` (Y \\<inter> {x. x \\<noteq> 0}))\n  Y \\<inter> {x. x \\<noteq> 0} \\<noteq> {}", "have \"\\<Squnion>(eSuc ` ?Y) = eSuc (\\<Squnion>?Y)\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>)\n   (epred ` (Y \\<inter> {x. x \\<noteq> 0}))\n  Y \\<inter> {x. x \\<noteq> 0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<Squnion> (eSuc ` epred ` (Y \\<inter> {x. x \\<noteq> 0})) =\n    eSuc (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))", "using mcont_eSuc [THEN mcont_contD, symmetric]"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>)\n   (epred ` (Y \\<inter> {x. x \\<noteq> 0}))\n  Y \\<inter> {x. x \\<noteq> 0} \\<noteq> {}\n  \\<lbrakk>Complete_Partial_Order.chain (\\<le>) ?Y; ?Y \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<Squnion> (eSuc ` ?Y) = eSuc (\\<Squnion> ?Y)\n\ngoal (1 subgoal):\n 1. \\<Squnion> (eSuc ` epred ` (Y \\<inter> {x. x \\<noteq> 0})) =\n    eSuc (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))", "by blast"], ["proof (state)\nthis:\n  \\<Squnion> (eSuc ` epred ` (Y \\<inter> {x. x \\<noteq> 0})) =\n  eSuc (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))\n\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) Y; Y \\<noteq> {};\n        \\<And>x. x \\<in> Y \\<Longrightarrow> \\<not> x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> f (epred (\\<Squnion> Y)) (\\<Squnion> Y) =\n                         lub ((\\<lambda>x. f (epred x) x) ` Y)\n 2. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "ultimately"], ["proof (chain)\npicking this:\n  f (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))\n   (eSuc (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))) =\n  lub ((\\<lambda>x. f x (eSuc x)) ` epred ` (Y \\<inter> {x. x \\<noteq> 0}))\n  \\<Squnion> (eSuc ` epred ` (Y \\<inter> {x. x \\<noteq> 0})) =\n  eSuc (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))", "show \"f (epred (Sup Y)) (Sup Y) = lub ((\\<lambda>x. f (epred x) x) ` Y)\""], ["proof (prove)\nusing this:\n  f (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))\n   (eSuc (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))) =\n  lub ((\\<lambda>x. f x (eSuc x)) ` epred ` (Y \\<inter> {x. x \\<noteq> 0}))\n  \\<Squnion> (eSuc ` epred ` (Y \\<inter> {x. x \\<noteq> 0})) =\n  eSuc (\\<Squnion> (epred ` (Y \\<inter> {x. x \\<noteq> 0})))\n\ngoal (1 subgoal):\n 1. f (epred (\\<Squnion> Y)) (\\<Squnion> Y) =\n    lub ((\\<lambda>x. f (epred x) x) ` Y)", "by (subst (1 2 3) eq) (simp add: image_image)"], ["proof (state)\nthis:\n  f (epred (\\<Squnion> Y)) (\\<Squnion> Y) =\n  lub ((\\<lambda>x. f (epred x) x) ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "fix x :: enat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "assume \"\\<not> x \\<le> 0\""], ["proof (state)\nthis:\n  \\<not> x \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<not> x \\<le> 0 \\<Longrightarrow> ord bot (f (epred x) x)", "thus \"ord bot (f (epred x) x)\""], ["proof (prove)\nusing this:\n  \\<not> x \\<le> 0\n\ngoal (1 subgoal):\n 1. ord bot (f (epred x) x)", "by(cases x rule: co.enat.exhaust)(auto intro: ord)"], ["proof (state)\nthis:\n  ord bot (f (epred x) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mcont Sup (\\<le>) lub ord\n   (\\<lambda>x. if x \\<le> 0 then bot else f (epred x) x)\n\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) lub ord\n     (\\<lambda>x.\n         case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)", "also"], ["proof (state)\nthis:\n  mcont Sup (\\<le>) lub ord\n   (\\<lambda>x. if x \\<le> 0 then bot else f (epred x) x)\n\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) lub ord\n     (\\<lambda>x.\n         case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)", "have \"(\\<lambda>x. if x \\<le> 0 then bot else f (epred x) x) = (\\<lambda>x. case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<le> 0 then bot else f (epred x) x) =\n    (\\<lambda>x.\n        case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)", "by(auto simp add: fun_eq_iff split: co.enat.split)"], ["proof (state)\nthis:\n  (\\<lambda>x. if x \\<le> 0 then bot else f (epred x) x) =\n  (\\<lambda>x. case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)\n\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) lub ord\n     (\\<lambda>x.\n         case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)", "finally"], ["proof (chain)\npicking this:\n  mcont Sup (\\<le>) lub ord\n   (\\<lambda>x.\n       case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)", "show ?thesis"], ["proof (prove)\nusing this:\n  mcont Sup (\\<le>) lub ord\n   (\\<lambda>x.\n       case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)\n\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) lub ord\n     (\\<lambda>x.\n         case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)", "."], ["proof (state)\nthis:\n  mcont Sup (\\<le>) lub ord\n   (\\<lambda>x.\n       case x of 0 \\<Rightarrow> bot | eSuc x' \\<Rightarrow> f x' x)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Misc.\\<close>"], ["", "lemma enat_add_mono [simp]:\n  \"enat x + y < enat x + z \\<longleftrightarrow> y < z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (enat x + y < enat x + z) = (y < z)", "by(cases y)(case_tac [!] z, simp_all)"], ["", "lemma enat_add1_eq [simp]: \"enat x + y = enat x + z \\<longleftrightarrow> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (enat x + y = enat x + z) = (y = z)", "by (metis enat_add_mono add.commute neq_iff)"], ["", "lemma enat_add2_eq [simp]: \"y + enat x = z + enat x \\<longleftrightarrow> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y + enat x = z + enat x) = (y = z)", "by (metis enat_add1_eq add.commute)"], ["", "lemma enat_less_enat_plusI: \"x < y \\<Longrightarrow> enat x < enat y + z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y \\<Longrightarrow> enat x < enat y + z", "by(cases z) simp_all"], ["", "lemma enat_less_enat_plusI2:\n  \"enat y < z \\<Longrightarrow> enat (x + y) < enat x + z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat y < z \\<Longrightarrow> enat (x + y) < enat x + z", "by (metis enat_add_mono plus_enat_simps(1))"], ["", "lemma min_enat1_conv_enat: \"\\<And>a b. min (enat a) b = enat (case b of enat b' \\<Rightarrow> min a b' | \\<infinity> \\<Rightarrow> a)\"\n  and min_enat2_conv_enat: \"\\<And>a b. min a (enat b) = enat (case a of enat a' \\<Rightarrow> min a' b | \\<infinity> \\<Rightarrow> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        min (enat a) b =\n        enat\n         (case b of enat b' \\<Rightarrow> min a b'\n          | \\<infinity> \\<Rightarrow> a)) &&&\n    (\\<And>a b.\n        min a (enat b) =\n        enat\n         (case a of enat a' \\<Rightarrow> min a' b\n          | \\<infinity> \\<Rightarrow> b))", "by(simp_all split: enat.split)"], ["", "lemma eSuc_le_iff: \"eSuc x \\<le> y \\<longleftrightarrow> (\\<exists>y'. y = eSuc y' \\<and> x \\<le> y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eSuc x \\<le> y) = (\\<exists>y'. y = eSuc y' \\<and> x \\<le> y')", "by(cases y rule: co.enat.exhaust) simp_all"], ["", "lemma eSuc_eq_infinity_iff: \"eSuc n = \\<infinity> \\<longleftrightarrow> n = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eSuc n = \\<infinity>) = (n = \\<infinity>)", "by(cases n)(simp_all add: zero_enat_def eSuc_enat)"], ["", "lemma infinity_eq_eSuc_iff: \"\\<infinity> = eSuc n \\<longleftrightarrow> n = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<infinity> = eSuc n) = (n = \\<infinity>)", "by(cases n)(simp_all add: zero_enat_def eSuc_enat)"], ["", "lemma enat_cocase_inf: \"(case \\<infinity> of 0 \\<Rightarrow> a | eSuc b \\<Rightarrow> f b) = f \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case \\<infinity> of 0 \\<Rightarrow> a | eSuc b \\<Rightarrow> f b) =\n    f \\<infinity>", "by(auto split: co.enat.split simp add: infinity_eq_eSuc_iff)"], ["", "lemma eSuc_Inf: \"eSuc (Inf A) = Inf (eSuc ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSuc (\\<Sqinter> A) = \\<Sqinter> (eSuc ` A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eSuc (\\<Sqinter> A) = \\<Sqinter> (eSuc ` A)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. eSuc (\\<Sqinter> A) = \\<Sqinter> (eSuc ` A)", "assume \"A \\<noteq> {}\""], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. eSuc (\\<Sqinter> A) = \\<Sqinter> (eSuc ` A)", "then"], ["proof (chain)\npicking this:\n  A \\<noteq> {}", "obtain a where \"a \\<in> A\""], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. eSuc (\\<Sqinter> A) = \\<Sqinter> (eSuc ` A)", "then"], ["proof (chain)\npicking this:\n  a \\<in> A", "have \"eSuc (LEAST a. a \\<in> A) = (LEAST a. a \\<in> eSuc ` A)\""], ["proof (prove)\nusing this:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. eSuc (LEAST a. a \\<in> A) = (LEAST a. a \\<in> eSuc ` A)", "proof (rule LeastI2_wellorder)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> A;\n        \\<forall>b. b \\<in> A \\<longrightarrow> a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> eSuc a = (LEAST a. a \\<in> eSuc ` A)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> A;\n        \\<forall>b. b \\<in> A \\<longrightarrow> a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> eSuc a = (LEAST a. a \\<in> eSuc ` A)", "assume \"a \\<in> A\" and b: \"\\<forall>b. b \\<in> A \\<longrightarrow> a \\<le> b\""], ["proof (state)\nthis:\n  a \\<in> A\n  \\<forall>b. b \\<in> A \\<longrightarrow> a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> A;\n        \\<forall>b. b \\<in> A \\<longrightarrow> a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> eSuc a = (LEAST a. a \\<in> eSuc ` A)", "then"], ["proof (chain)\npicking this:\n  a \\<in> A\n  \\<forall>b. b \\<in> A \\<longrightarrow> a \\<le> b", "have a: \"eSuc a \\<in> eSuc ` A\""], ["proof (prove)\nusing this:\n  a \\<in> A\n  \\<forall>b. b \\<in> A \\<longrightarrow> a \\<le> b\n\ngoal (1 subgoal):\n 1. eSuc a \\<in> eSuc ` A", "by auto"], ["proof (state)\nthis:\n  eSuc a \\<in> eSuc ` A\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> A;\n        \\<forall>b. b \\<in> A \\<longrightarrow> a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> eSuc a = (LEAST a. a \\<in> eSuc ` A)", "then"], ["proof (chain)\npicking this:\n  eSuc a \\<in> eSuc ` A", "show \"eSuc a = (LEAST a. a \\<in> eSuc ` A)\""], ["proof (prove)\nusing this:\n  eSuc a \\<in> eSuc ` A\n\ngoal (1 subgoal):\n 1. eSuc a = (LEAST a. a \\<in> eSuc ` A)", "by (rule LeastI2_wellorder) (metis (full_types) b a antisym eSuc_le_iff imageE)"], ["proof (state)\nthis:\n  eSuc a = (LEAST a. a \\<in> eSuc ` A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eSuc (LEAST a. a \\<in> A) = (LEAST a. a \\<in> eSuc ` A)\n\ngoal (1 subgoal):\n 1. eSuc (\\<Sqinter> A) = \\<Sqinter> (eSuc ` A)", "}"], ["proof (state)\nthis:\n  A \\<noteq> {} \\<Longrightarrow>\n  eSuc (LEAST a. a \\<in> A) = (LEAST a. a \\<in> eSuc ` A)\n\ngoal (1 subgoal):\n 1. eSuc (\\<Sqinter> A) = \\<Sqinter> (eSuc ` A)", "then"], ["proof (chain)\npicking this:\n  A \\<noteq> {} \\<Longrightarrow>\n  eSuc (LEAST a. a \\<in> A) = (LEAST a. a \\<in> eSuc ` A)", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<noteq> {} \\<Longrightarrow>\n  eSuc (LEAST a. a \\<in> A) = (LEAST a. a \\<in> eSuc ` A)\n\ngoal (1 subgoal):\n 1. eSuc (\\<Sqinter> A) = \\<Sqinter> (eSuc ` A)", "by (simp add: Inf_enat_def)"], ["proof (state)\nthis:\n  eSuc (\\<Sqinter> A) = \\<Sqinter> (eSuc ` A)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}