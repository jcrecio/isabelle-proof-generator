{"file_name": "/home/qj213/afp-2021-10-22/thys/Coinductive/Examples/LMirror.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Coinductive", "problem_names": ["lemma lnull_lmirror_aux [simp]:\n  \"lnull (lmirror_aux acc xs) = (lnull xs \\<and> lnull acc)\"", "lemma ltl_lmirror_aux:\n  \"ltl (lmirror_aux acc xs) = (if lnull xs then ltl acc else lmirror_aux (LCons (lhd xs) acc) (ltl xs))\"", "lemma lhd_lmirror_aux:\n  \"lhd (lmirror_aux acc xs) = (if lnull xs then lhd acc else lhd xs)\"", "lemma lfinite_lmirror_aux [simp]:\n  \"lfinite (lmirror_aux acc xs) \\<longleftrightarrow> lfinite xs \\<and> lfinite acc\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma lmirror_aux_inf:\n  \"\\<not> lfinite xs \\<Longrightarrow> lmirror_aux acc xs = xs\"", "lemma lmirror_aux_acc:\n  \"lmirror_aux (lappend ys zs) xs = lappend (lmirror_aux ys xs) zs\"", "lemma lmirror_aux_LCons:\n  \"lmirror_aux acc (LCons x xs) = LCons x (lappend (lmirror_aux LNil xs) (LCons x acc))\"", "lemma llength_lmirror_aux: \"llength (lmirror_aux acc xs) = 2 * llength xs + llength acc\"", "lemma lnull_lmirror [simp]: \"lnull (lmirror xs) = lnull xs\"", "lemma lmirror_LNil [simp]: \"lmirror LNil = LNil\"", "lemma lmirror_LCons [simp]: \"lmirror (LCons x xs) = LCons x (lappend (lmirror xs) (LCons x LNil))\"", "lemma ltl_lmirror [simp]:\n  \"\\<not> lnull xs \\<Longrightarrow> ltl (lmirror xs) = lappend (lmirror (ltl xs)) (LCons (lhd xs) LNil)\"", "lemma lmap_lmirror_aux: \"lmap f (lmirror_aux acc xs) = lmirror_aux (lmap f acc) (lmap f xs)\"", "lemma lmap_lmirror: \"lmap f (lmirror xs) = lmirror (lmap f xs)\"", "lemma lset_lmirror_aux: \"lset (lmirror_aux acc xs) = lset (lappend xs acc)\"", "lemma lset_lmirror [simp]: \"lset (lmirror xs) = lset xs\"", "lemma llength_lmirror [simp]: \"llength (lmirror xs) = 2 * llength xs\"", "lemma lmirror_llist_of [simp]: \"lmirror (llist_of xs) = llist_of (xs @ rev xs)\"", "lemma list_of_lmirror [simp]: \"lfinite xs \\<Longrightarrow> list_of (lmirror xs) = list_of xs @ rev (list_of xs)\"", "lemma llist_all2_lmirror_aux:\n  \"\\<lbrakk> llist_all2 P acc acc'; llist_all2 P xs xs' \\<rbrakk>\n  \\<Longrightarrow> llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs')\"", "lemma enat_mult_cancel1 [simp]:\n  \"k * m = k * n \\<longleftrightarrow> m = n \\<or> k = 0 \\<or> k = (\\<infinity> :: enat) \\<and> n \\<noteq> 0 \\<and> m \\<noteq> 0\"", "lemma llist_all2_lmirror_auxD:\n  \"\\<lbrakk> llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs'); llist_all2 P acc acc'; lfinite acc \\<rbrakk>\n  \\<Longrightarrow> llist_all2 P xs xs'\"", "lemma llist_all2_lmirrorI:\n  \"llist_all2 P xs ys \\<Longrightarrow> llist_all2 P (lmirror xs) (lmirror ys)\"", "lemma llist_all2_lmirrorD:\n  \"llist_all2 P (lmirror xs) (lmirror ys) \\<Longrightarrow> llist_all2 P xs ys\"", "lemma llist_all2_lmirror [simp]:\n  \"llist_all2 P (lmirror xs) (lmirror ys) \\<longleftrightarrow> llist_all2 P xs ys\"", "lemma lmirror_parametric [transfer_rule]:\n  includes lifting_syntax\n  shows \"(llist_all2 A ===> llist_all2 A) lmirror lmirror\""], "translations": [["", "lemma lnull_lmirror_aux [simp]:\n  \"lnull (lmirror_aux acc xs) = (lnull xs \\<and> lnull acc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (lmirror_aux acc xs) = (lnull xs \\<and> lnull acc)", "by(fact lmirror_aux.simps)"], ["", "lemma ltl_lmirror_aux:\n  \"ltl (lmirror_aux acc xs) = (if lnull xs then ltl acc else lmirror_aux (LCons (lhd xs) acc) (ltl xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (lmirror_aux acc xs) =\n    (if lnull xs then ltl acc\n     else lmirror_aux (LCons (lhd xs) acc) (ltl xs))", "by(cases acc)(simp_all split: llist.split)"], ["", "lemma lhd_lmirror_aux:\n  \"lhd (lmirror_aux acc xs) = (if lnull xs then lhd acc else lhd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd (lmirror_aux acc xs) = (if lnull xs then lhd acc else lhd xs)", "by(cases acc)(simp_all split: llist.split)"], ["", "declare lmirror_aux.sel[simp del]"], ["", "lemma lfinite_lmirror_aux [simp]:\n  \"lfinite (lmirror_aux acc xs) \\<longleftrightarrow> lfinite xs \\<and> lfinite acc\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (lmirror_aux acc xs) = (lfinite xs \\<and> lfinite acc)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite (lmirror_aux acc xs) \\<Longrightarrow>\n    lfinite xs \\<and> lfinite acc\n 2. lfinite xs \\<and> lfinite acc \\<Longrightarrow>\n    lfinite (lmirror_aux acc xs)", "assume ?lhs"], ["proof (state)\nthis:\n  lfinite (lmirror_aux acc xs)\n\ngoal (2 subgoals):\n 1. lfinite (lmirror_aux acc xs) \\<Longrightarrow>\n    lfinite xs \\<and> lfinite acc\n 2. lfinite xs \\<and> lfinite acc \\<Longrightarrow>\n    lfinite (lmirror_aux acc xs)", "thus ?rhs"], ["proof (prove)\nusing this:\n  lfinite (lmirror_aux acc xs)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<and> lfinite acc", "proof(induct zs\\<equiv>\"lmirror_aux acc xs\" arbitrary: acc xs rule: lfinite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>acc xs.\n       lnull (lmirror_aux acc xs) \\<Longrightarrow>\n       lfinite xs \\<and> lfinite acc\n 2. \\<And>acc xs.\n       \\<lbrakk>lfinite (lmirror_aux acc xs);\n        \\<not> lnull (lmirror_aux acc xs);\n        \\<And>acca xsa.\n           ltl (lmirror_aux acc xs) = lmirror_aux acca xsa \\<Longrightarrow>\n           lfinite xsa \\<and> lfinite acca\\<rbrakk>\n       \\<Longrightarrow> lfinite xs \\<and> lfinite acc", "case LCons"], ["proof (state)\nthis:\n  lfinite (lmirror_aux acc xs)\n  \\<not> lnull (lmirror_aux acc xs)\n  ltl (lmirror_aux acc xs) = lmirror_aux ?acc ?xs \\<Longrightarrow>\n  lfinite ?xs \\<and> lfinite ?acc\n\ngoal (2 subgoals):\n 1. \\<And>acc xs.\n       lnull (lmirror_aux acc xs) \\<Longrightarrow>\n       lfinite xs \\<and> lfinite acc\n 2. \\<And>acc xs.\n       \\<lbrakk>lfinite (lmirror_aux acc xs);\n        \\<not> lnull (lmirror_aux acc xs);\n        \\<And>acca xsa.\n           ltl (lmirror_aux acc xs) = lmirror_aux acca xsa \\<Longrightarrow>\n           lfinite xsa \\<and> lfinite acca\\<rbrakk>\n       \\<Longrightarrow> lfinite xs \\<and> lfinite acc", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite (lmirror_aux acc xs)\n  \\<not> lnull (lmirror_aux acc xs)\n  ltl (lmirror_aux acc xs) = lmirror_aux ?acc ?xs \\<Longrightarrow>\n  lfinite ?xs \\<and> lfinite ?acc\n\ngoal (1 subgoal):\n 1. lfinite xs \\<and> lfinite acc", "proof(cases \"lnull xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>lfinite (lmirror_aux acc xs);\n     \\<not> lnull (lmirror_aux acc xs);\n     \\<And>acc xs.\n        ltl (lmirror_aux acc xs) = lmirror_aux acc xs \\<Longrightarrow>\n        lfinite xs \\<and> lfinite acc;\n     lnull xs\\<rbrakk>\n    \\<Longrightarrow> lfinite xs \\<and> lfinite acc\n 2. \\<lbrakk>lfinite (lmirror_aux acc xs);\n     \\<not> lnull (lmirror_aux acc xs);\n     \\<And>acc xs.\n        ltl (lmirror_aux acc xs) = lmirror_aux acc xs \\<Longrightarrow>\n        lfinite xs \\<and> lfinite acc;\n     \\<not> lnull xs\\<rbrakk>\n    \\<Longrightarrow> lfinite xs \\<and> lfinite acc", "case True"], ["proof (state)\nthis:\n  lnull xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lfinite (lmirror_aux acc xs);\n     \\<not> lnull (lmirror_aux acc xs);\n     \\<And>acc xs.\n        ltl (lmirror_aux acc xs) = lmirror_aux acc xs \\<Longrightarrow>\n        lfinite xs \\<and> lfinite acc;\n     lnull xs\\<rbrakk>\n    \\<Longrightarrow> lfinite xs \\<and> lfinite acc\n 2. \\<lbrakk>lfinite (lmirror_aux acc xs);\n     \\<not> lnull (lmirror_aux acc xs);\n     \\<And>acc xs.\n        ltl (lmirror_aux acc xs) = lmirror_aux acc xs \\<Longrightarrow>\n        lfinite xs \\<and> lfinite acc;\n     \\<not> lnull xs\\<rbrakk>\n    \\<Longrightarrow> lfinite xs \\<and> lfinite acc", "with LCons.hyps(3)[of \"ltl acc\" LNil]"], ["proof (chain)\npicking this:\n  ltl (lmirror_aux acc xs) = lmirror_aux (ltl acc) LNil \\<Longrightarrow>\n  lfinite LNil \\<and> lfinite (ltl acc)\n  lnull xs", "show ?thesis"], ["proof (prove)\nusing this:\n  ltl (lmirror_aux acc xs) = lmirror_aux (ltl acc) LNil \\<Longrightarrow>\n  lfinite LNil \\<and> lfinite (ltl acc)\n  lnull xs\n\ngoal (1 subgoal):\n 1. lfinite xs \\<and> lfinite acc", "by(simp add: ltl_lmirror_aux)"], ["proof (state)\nthis:\n  lfinite xs \\<and> lfinite acc\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lfinite (lmirror_aux acc xs);\n     \\<not> lnull (lmirror_aux acc xs);\n     \\<And>acc xs.\n        ltl (lmirror_aux acc xs) = lmirror_aux acc xs \\<Longrightarrow>\n        lfinite xs \\<and> lfinite acc;\n     \\<not> lnull xs\\<rbrakk>\n    \\<Longrightarrow> lfinite xs \\<and> lfinite acc", "qed(fastforce simp add: ltl_lmirror_aux)"], ["proof (state)\nthis:\n  lfinite xs \\<and> lfinite acc\n\ngoal (1 subgoal):\n 1. \\<And>acc xs.\n       lnull (lmirror_aux acc xs) \\<Longrightarrow>\n       lfinite xs \\<and> lfinite acc", "qed simp"], ["proof (state)\nthis:\n  lfinite xs \\<and> lfinite acc\n\ngoal (1 subgoal):\n 1. lfinite xs \\<and> lfinite acc \\<Longrightarrow>\n    lfinite (lmirror_aux acc xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite xs \\<and> lfinite acc \\<Longrightarrow>\n    lfinite (lmirror_aux acc xs)", "assume ?rhs"], ["proof (state)\nthis:\n  lfinite xs \\<and> lfinite acc\n\ngoal (1 subgoal):\n 1. lfinite xs \\<and> lfinite acc \\<Longrightarrow>\n    lfinite (lmirror_aux acc xs)", "hence \"lfinite xs\" \"lfinite acc\""], ["proof (prove)\nusing this:\n  lfinite xs \\<and> lfinite acc\n\ngoal (1 subgoal):\n 1. lfinite xs &&& lfinite acc", "by simp_all"], ["proof (state)\nthis:\n  lfinite xs\n  lfinite acc\n\ngoal (1 subgoal):\n 1. lfinite xs \\<and> lfinite acc \\<Longrightarrow>\n    lfinite (lmirror_aux acc xs)", "thus ?lhs"], ["proof (prove)\nusing this:\n  lfinite xs\n  lfinite acc\n\ngoal (1 subgoal):\n 1. lfinite (lmirror_aux acc xs)", "by(induction arbitrary: acc) simp_all"], ["proof (state)\nthis:\n  lfinite (lmirror_aux acc xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lmirror_aux_inf:\n  \"\\<not> lfinite xs \\<Longrightarrow> lmirror_aux acc xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> lmirror_aux acc xs = xs", "by(coinduction arbitrary: acc xs)(auto simp add: lhd_lmirror_aux ltl_lmirror_aux)"], ["", "lemma lmirror_aux_acc:\n  \"lmirror_aux (lappend ys zs) xs = lappend (lmirror_aux ys xs) zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmirror_aux (lappend ys zs) xs = lappend (lmirror_aux ys xs) zs", "proof(cases \"lfinite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    lmirror_aux (lappend ys zs) xs = lappend (lmirror_aux ys xs) zs\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    lmirror_aux (lappend ys zs) xs = lappend (lmirror_aux ys xs) zs", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    lmirror_aux (lappend ys zs) xs = lappend (lmirror_aux ys xs) zs\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    lmirror_aux (lappend ys zs) xs = lappend (lmirror_aux ys xs) zs", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. lmirror_aux (lappend ys zs) xs = lappend (lmirror_aux ys xs) zs", "by(simp add: lmirror_aux_inf lappend_inf)"], ["proof (state)\nthis:\n  lmirror_aux (lappend ys zs) xs = lappend (lmirror_aux ys xs) zs\n\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    lmirror_aux (lappend ys zs) xs = lappend (lmirror_aux ys xs) zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    lmirror_aux (lappend ys zs) xs = lappend (lmirror_aux ys xs) zs", "case True"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    lmirror_aux (lappend ys zs) xs = lappend (lmirror_aux ys xs) zs", "thus ?thesis"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lmirror_aux (lappend ys zs) xs = lappend (lmirror_aux ys xs) zs", "by(induction arbitrary: ys)(simp_all add: lappend_code(2)[symmetric] del: lappend_code(2))"], ["proof (state)\nthis:\n  lmirror_aux (lappend ys zs) xs = lappend (lmirror_aux ys xs) zs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lmirror_aux_LCons:\n  \"lmirror_aux acc (LCons x xs) = LCons x (lappend (lmirror_aux LNil xs) (LCons x acc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmirror_aux acc (LCons x xs) =\n    LCons x (lappend (lmirror_aux LNil xs) (LCons x acc))", "by (metis lappend_code(1) lmirror_aux_acc lmirror_aux_simps(2))"], ["", "lemma llength_lmirror_aux: \"llength (lmirror_aux acc xs) = 2 * llength xs + llength acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lmirror_aux acc xs) = 2 * llength xs + llength acc", "apply(coinduction arbitrary: acc xs rule: enat_coinduct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>acc xs.\n       (llength (lmirror_aux acc xs) = 0) =\n       (2 * llength xs + llength acc = 0) \\<and>\n       (llength (lmirror_aux acc xs) \\<noteq> 0 \\<longrightarrow>\n        2 * llength xs + llength acc \\<noteq> 0 \\<longrightarrow>\n        (\\<exists>acca xsa.\n            epred (llength (lmirror_aux acc xs)) =\n            llength (lmirror_aux acca xsa) \\<and>\n            epred (2 * llength xs + llength acc) =\n            2 * llength xsa + llength acca) \\<or>\n        epred (llength (lmirror_aux acc xs)) =\n        epred (2 * llength xs + llength acc))", "apply(auto simp add: iadd_is_0 epred_iadd1 mult_2 epred_llength ltl_lmirror_aux iadd_Suc_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>acc xs.\n       \\<lbrakk>\\<not> lnull xs;\n        llength (lmirror_aux (LCons (lhd xs) acc) (ltl xs)) \\<noteq>\n        llength (ltl xs) + llength xs + llength acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acca xsa.\n                            llength\n                             (lmirror_aux (LCons (lhd xs) acc) (ltl xs)) =\n                            llength (lmirror_aux acca xsa) \\<and>\n                            llength (ltl xs) + llength xs + llength acc =\n                            llength xsa + llength xsa + llength acca", "apply(rule exI conjI refl)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>acc xs.\n       \\<lbrakk>\\<not> lnull xs;\n        llength (lmirror_aux (LCons (lhd xs) acc) (ltl xs)) \\<noteq>\n        llength (ltl xs) + llength xs + llength acc\\<rbrakk>\n       \\<Longrightarrow> llength (ltl xs) + llength xs + llength acc =\n                         llength (ltl xs) + llength (ltl xs) +\n                         llength (LCons (lhd xs) acc)", "apply(simp add: iadd_Suc_right llength_ltl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>acc xs.\n       \\<lbrakk>\\<not> lnull xs;\n        llength (lmirror_aux (LCons (lhd xs) acc) (ltl xs)) \\<noteq>\n        epred (llength xs) + llength xs + llength acc\\<rbrakk>\n       \\<Longrightarrow> epred (llength xs) + llength xs + llength acc =\n                         eSuc\n                          (epred (llength xs) + epred (llength xs) +\n                           llength acc)", "by (metis (hide_lams, no_types) add.commute epred_llength iadd_Suc_right lhd_LCons_ltl llength_LCons)"], ["", "lemma lnull_lmirror [simp]: \"lnull (lmirror xs) = lnull xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (lmirror xs) = lnull xs", "by(simp add: lmirror_def)"], ["", "lemma lmirror_LNil [simp]: \"lmirror LNil = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmirror LNil = LNil", "by(simp add: lmirror_def)"], ["", "lemma lmirror_LCons [simp]: \"lmirror (LCons x xs) = LCons x (lappend (lmirror xs) (LCons x LNil))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmirror (LCons x xs) = LCons x (lappend (lmirror xs) (LCons x LNil))", "by(simp only: lmirror_aux_LCons lmirror_def)"], ["", "lemma ltl_lmirror [simp]:\n  \"\\<not> lnull xs \\<Longrightarrow> ltl (lmirror xs) = lappend (lmirror (ltl xs)) (LCons (lhd xs) LNil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull xs \\<Longrightarrow>\n    ltl (lmirror xs) = lappend (lmirror (ltl xs)) (LCons (lhd xs) LNil)", "by(clarsimp simp add: not_lnull_conv)"], ["", "lemma lmap_lmirror_aux: \"lmap f (lmirror_aux acc xs) = lmirror_aux (lmap f acc) (lmap f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (lmirror_aux acc xs) = lmirror_aux (lmap f acc) (lmap f xs)", "by(coinduction arbitrary: acc xs rule: llist.coinduct_strong)(auto 4 3 simp add: lhd_lmirror_aux ltl_lmirror_aux)"], ["", "lemma lmap_lmirror: \"lmap f (lmirror xs) = lmirror (lmap f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (lmirror xs) = lmirror (lmap f xs)", "by(simp add: lmirror_def lmap_lmirror_aux)"], ["", "lemma lset_lmirror_aux: \"lset (lmirror_aux acc xs) = lset (lappend xs acc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lmirror_aux acc xs) = lset (lappend xs acc)", "proof(cases \"lfinite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    lset (lmirror_aux acc xs) = lset (lappend xs acc)\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    lset (lmirror_aux acc xs) = lset (lappend xs acc)", "case True"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    lset (lmirror_aux acc xs) = lset (lappend xs acc)\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    lset (lmirror_aux acc xs) = lset (lappend xs acc)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lset (lmirror_aux acc xs) = lset (lappend xs acc)", "by(induction arbitrary: acc) simp_all"], ["proof (state)\nthis:\n  lset (lmirror_aux acc xs) = lset (lappend xs acc)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    lset (lmirror_aux acc xs) = lset (lappend xs acc)", "qed(simp add: lmirror_aux_inf lappend_inf)"], ["", "lemma lset_lmirror [simp]: \"lset (lmirror xs) = lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lmirror xs) = lset xs", "by(simp add: lmirror_def lset_lmirror_aux)"], ["", "lemma llength_lmirror [simp]: \"llength (lmirror xs) = 2 * llength xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lmirror xs) = 2 * llength xs", "by(simp add: lmirror_def llength_lmirror_aux)"], ["", "lemma lmirror_llist_of [simp]: \"lmirror (llist_of xs) = llist_of (xs @ rev xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmirror (llist_of xs) = llist_of (xs @ rev xs)", "by(induct xs)(simp_all add: lappend_llist_of_LCons)"], ["", "lemma list_of_lmirror [simp]: \"lfinite xs \\<Longrightarrow> list_of (lmirror xs) = list_of xs @ rev (list_of xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    list_of (lmirror xs) = list_of xs @ rev (list_of xs)", "by (metis list_of_llist_of llist_of_list_of lmirror_llist_of)"], ["", "lemma llist_all2_lmirror_aux:\n  \"\\<lbrakk> llist_all2 P acc acc'; llist_all2 P xs xs' \\<rbrakk>\n  \\<Longrightarrow> llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>llist_all2 P acc acc'; llist_all2 P xs xs'\\<rbrakk>\n    \\<Longrightarrow> llist_all2 P (lmirror_aux acc xs)\n                       (lmirror_aux acc' xs')", "by(coinduction arbitrary: acc acc' xs xs')(auto simp add: lhd_lmirror_aux ltl_lmirror_aux elim: llist_all2_lhdD intro!: llist_all2_ltlI exI dest: llist_all2_lnullD)"], ["", "lemma enat_mult_cancel1 [simp]:\n  \"k * m = k * n \\<longleftrightarrow> m = n \\<or> k = 0 \\<or> k = (\\<infinity> :: enat) \\<and> n \\<noteq> 0 \\<and> m \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k * m = k * n) =\n    (m = n \\<or>\n     k = 0 \\<or> k = \\<infinity> \\<and> n \\<noteq> 0 \\<and> m \\<noteq> 0)", "by(cases k m n rule: enat.exhaust[case_product enat.exhaust[case_product enat.exhaust]])(simp_all add: zero_enat_def)"], ["", "lemma llist_all2_lmirror_auxD:\n  \"\\<lbrakk> llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs'); llist_all2 P acc acc'; lfinite acc \\<rbrakk>\n  \\<Longrightarrow> llist_all2 P xs xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs');\n     llist_all2 P acc acc'; lfinite acc\\<rbrakk>\n    \\<Longrightarrow> llist_all2 P xs xs'", "proof(coinduction arbitrary: xs xs' acc acc')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xsa xs' acc acc'.\n       \\<lbrakk>llist_all2 P (lmirror_aux acc xsa) (lmirror_aux acc' xs');\n        llist_all2 P acc acc'; lfinite acc\\<rbrakk>\n       \\<Longrightarrow> lnull xsa = lnull xs'\n 2. \\<And>xsa xs' acc acc'.\n       \\<lbrakk>llist_all2 P (lmirror_aux acc xsa) (lmirror_aux acc' xs');\n        llist_all2 P acc acc'; lfinite acc; \\<not> lnull xsa;\n        \\<not> lnull xs'\\<rbrakk>\n       \\<Longrightarrow> P (lhd xsa) (lhd xs') \\<and>\n                         ((\\<exists>xs xs'a acc acc'.\n                              ltl xsa = xs \\<and>\n                              ltl xs' = xs'a \\<and>\n                              llist_all2 P (lmirror_aux acc xs)\n                               (lmirror_aux acc' xs'a) \\<and>\n                              llist_all2 P acc acc' \\<and>\n                              lfinite acc) \\<or>\n                          llist_all2 P (ltl xsa) (ltl xs'))", "case (LNil xs xs' acc acc')"], ["proof (state)\nthis:\n  llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs')\n  llist_all2 P acc acc'\n  lfinite acc\n\ngoal (2 subgoals):\n 1. \\<And>xsa xs' acc acc'.\n       \\<lbrakk>llist_all2 P (lmirror_aux acc xsa) (lmirror_aux acc' xs');\n        llist_all2 P acc acc'; lfinite acc\\<rbrakk>\n       \\<Longrightarrow> lnull xsa = lnull xs'\n 2. \\<And>xsa xs' acc acc'.\n       \\<lbrakk>llist_all2 P (lmirror_aux acc xsa) (lmirror_aux acc' xs');\n        llist_all2 P acc acc'; lfinite acc; \\<not> lnull xsa;\n        \\<not> lnull xs'\\<rbrakk>\n       \\<Longrightarrow> P (lhd xsa) (lhd xs') \\<and>\n                         ((\\<exists>xs xs'a acc acc'.\n                              ltl xsa = xs \\<and>\n                              ltl xs' = xs'a \\<and>\n                              llist_all2 P (lmirror_aux acc xs)\n                               (lmirror_aux acc' xs'a) \\<and>\n                              llist_all2 P acc acc' \\<and>\n                              lfinite acc) \\<or>\n                          llist_all2 P (ltl xsa) (ltl xs'))", "from \\<open>llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs')\\<close>"], ["proof (chain)\npicking this:\n  llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs')", "have \"llength (lmirror_aux acc xs) = llength (lmirror_aux acc' xs')\""], ["proof (prove)\nusing this:\n  llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs')\n\ngoal (1 subgoal):\n 1. llength (lmirror_aux acc xs) = llength (lmirror_aux acc' xs')", "by(rule llist_all2_llengthD)"], ["proof (state)\nthis:\n  llength (lmirror_aux acc xs) = llength (lmirror_aux acc' xs')\n\ngoal (2 subgoals):\n 1. \\<And>xsa xs' acc acc'.\n       \\<lbrakk>llist_all2 P (lmirror_aux acc xsa) (lmirror_aux acc' xs');\n        llist_all2 P acc acc'; lfinite acc\\<rbrakk>\n       \\<Longrightarrow> lnull xsa = lnull xs'\n 2. \\<And>xsa xs' acc acc'.\n       \\<lbrakk>llist_all2 P (lmirror_aux acc xsa) (lmirror_aux acc' xs');\n        llist_all2 P acc acc'; lfinite acc; \\<not> lnull xsa;\n        \\<not> lnull xs'\\<rbrakk>\n       \\<Longrightarrow> P (lhd xsa) (lhd xs') \\<and>\n                         ((\\<exists>xs xs'a acc acc'.\n                              ltl xsa = xs \\<and>\n                              ltl xs' = xs'a \\<and>\n                              llist_all2 P (lmirror_aux acc xs)\n                               (lmirror_aux acc' xs'a) \\<and>\n                              llist_all2 P acc acc' \\<and>\n                              lfinite acc) \\<or>\n                          llist_all2 P (ltl xsa) (ltl xs'))", "moreover"], ["proof (state)\nthis:\n  llength (lmirror_aux acc xs) = llength (lmirror_aux acc' xs')\n\ngoal (2 subgoals):\n 1. \\<And>xsa xs' acc acc'.\n       \\<lbrakk>llist_all2 P (lmirror_aux acc xsa) (lmirror_aux acc' xs');\n        llist_all2 P acc acc'; lfinite acc\\<rbrakk>\n       \\<Longrightarrow> lnull xsa = lnull xs'\n 2. \\<And>xsa xs' acc acc'.\n       \\<lbrakk>llist_all2 P (lmirror_aux acc xsa) (lmirror_aux acc' xs');\n        llist_all2 P acc acc'; lfinite acc; \\<not> lnull xsa;\n        \\<not> lnull xs'\\<rbrakk>\n       \\<Longrightarrow> P (lhd xsa) (lhd xs') \\<and>\n                         ((\\<exists>xs xs'a acc acc'.\n                              ltl xsa = xs \\<and>\n                              ltl xs' = xs'a \\<and>\n                              llist_all2 P (lmirror_aux acc xs)\n                               (lmirror_aux acc' xs'a) \\<and>\n                              llist_all2 P acc acc' \\<and>\n                              lfinite acc) \\<or>\n                          llist_all2 P (ltl xsa) (ltl xs'))", "from \\<open>llist_all2 P acc acc'\\<close>"], ["proof (chain)\npicking this:\n  llist_all2 P acc acc'", "have \"llength acc = llength acc'\""], ["proof (prove)\nusing this:\n  llist_all2 P acc acc'\n\ngoal (1 subgoal):\n 1. llength acc = llength acc'", "by(rule llist_all2_llengthD)"], ["proof (state)\nthis:\n  llength acc = llength acc'\n\ngoal (2 subgoals):\n 1. \\<And>xsa xs' acc acc'.\n       \\<lbrakk>llist_all2 P (lmirror_aux acc xsa) (lmirror_aux acc' xs');\n        llist_all2 P acc acc'; lfinite acc\\<rbrakk>\n       \\<Longrightarrow> lnull xsa = lnull xs'\n 2. \\<And>xsa xs' acc acc'.\n       \\<lbrakk>llist_all2 P (lmirror_aux acc xsa) (lmirror_aux acc' xs');\n        llist_all2 P acc acc'; lfinite acc; \\<not> lnull xsa;\n        \\<not> lnull xs'\\<rbrakk>\n       \\<Longrightarrow> P (lhd xsa) (lhd xs') \\<and>\n                         ((\\<exists>xs xs'a acc acc'.\n                              ltl xsa = xs \\<and>\n                              ltl xs' = xs'a \\<and>\n                              llist_all2 P (lmirror_aux acc xs)\n                               (lmirror_aux acc' xs'a) \\<and>\n                              llist_all2 P acc acc' \\<and>\n                              lfinite acc) \\<or>\n                          llist_all2 P (ltl xsa) (ltl xs'))", "ultimately"], ["proof (chain)\npicking this:\n  llength (lmirror_aux acc xs) = llength (lmirror_aux acc' xs')\n  llength acc = llength acc'", "have \"llength xs = llength xs'\""], ["proof (prove)\nusing this:\n  llength (lmirror_aux acc xs) = llength (lmirror_aux acc' xs')\n  llength acc = llength acc'\n\ngoal (1 subgoal):\n 1. llength xs = llength xs'", "using \\<open>lfinite acc\\<close>"], ["proof (prove)\nusing this:\n  llength (lmirror_aux acc xs) = llength (lmirror_aux acc' xs')\n  llength acc = llength acc'\n  lfinite acc\n\ngoal (1 subgoal):\n 1. llength xs = llength xs'", "by(auto simp add: llength_lmirror_aux dest: lfinite_llength_enat)"], ["proof (state)\nthis:\n  llength xs = llength xs'\n\ngoal (2 subgoals):\n 1. \\<And>xsa xs' acc acc'.\n       \\<lbrakk>llist_all2 P (lmirror_aux acc xsa) (lmirror_aux acc' xs');\n        llist_all2 P acc acc'; lfinite acc\\<rbrakk>\n       \\<Longrightarrow> lnull xsa = lnull xs'\n 2. \\<And>xsa xs' acc acc'.\n       \\<lbrakk>llist_all2 P (lmirror_aux acc xsa) (lmirror_aux acc' xs');\n        llist_all2 P acc acc'; lfinite acc; \\<not> lnull xsa;\n        \\<not> lnull xs'\\<rbrakk>\n       \\<Longrightarrow> P (lhd xsa) (lhd xs') \\<and>\n                         ((\\<exists>xs xs'a acc acc'.\n                              ltl xsa = xs \\<and>\n                              ltl xs' = xs'a \\<and>\n                              llist_all2 P (lmirror_aux acc xs)\n                               (lmirror_aux acc' xs'a) \\<and>\n                              llist_all2 P acc acc' \\<and>\n                              lfinite acc) \\<or>\n                          llist_all2 P (ltl xsa) (ltl xs'))", "thus ?case"], ["proof (prove)\nusing this:\n  llength xs = llength xs'\n\ngoal (1 subgoal):\n 1. lnull xs = lnull xs'", "by auto"], ["proof (state)\nthis:\n  lnull xs = lnull xs'\n\ngoal (1 subgoal):\n 1. \\<And>xsa xs' acc acc'.\n       \\<lbrakk>llist_all2 P (lmirror_aux acc xsa) (lmirror_aux acc' xs');\n        llist_all2 P acc acc'; lfinite acc; \\<not> lnull xsa;\n        \\<not> lnull xs'\\<rbrakk>\n       \\<Longrightarrow> P (lhd xsa) (lhd xs') \\<and>\n                         ((\\<exists>xs xs'a acc acc'.\n                              ltl xsa = xs \\<and>\n                              ltl xs' = xs'a \\<and>\n                              llist_all2 P (lmirror_aux acc xs)\n                               (lmirror_aux acc' xs'a) \\<and>\n                              llist_all2 P acc acc' \\<and>\n                              lfinite acc) \\<or>\n                          llist_all2 P (ltl xsa) (ltl xs'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa xs' acc acc'.\n       \\<lbrakk>llist_all2 P (lmirror_aux acc xsa) (lmirror_aux acc' xs');\n        llist_all2 P acc acc'; lfinite acc; \\<not> lnull xsa;\n        \\<not> lnull xs'\\<rbrakk>\n       \\<Longrightarrow> P (lhd xsa) (lhd xs') \\<and>\n                         ((\\<exists>xs xs'a acc acc'.\n                              ltl xsa = xs \\<and>\n                              ltl xs' = xs'a \\<and>\n                              llist_all2 P (lmirror_aux acc xs)\n                               (lmirror_aux acc' xs'a) \\<and>\n                              llist_all2 P acc acc' \\<and>\n                              lfinite acc) \\<or>\n                          llist_all2 P (ltl xsa) (ltl xs'))", "case (LCons xs xs' acc acc')"], ["proof (state)\nthis:\n  llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs')\n  llist_all2 P acc acc'\n  lfinite acc\n  \\<not> lnull xs\n  \\<not> lnull xs'\n\ngoal (1 subgoal):\n 1. \\<And>xsa xs' acc acc'.\n       \\<lbrakk>llist_all2 P (lmirror_aux acc xsa) (lmirror_aux acc' xs');\n        llist_all2 P acc acc'; lfinite acc; \\<not> lnull xsa;\n        \\<not> lnull xs'\\<rbrakk>\n       \\<Longrightarrow> P (lhd xsa) (lhd xs') \\<and>\n                         ((\\<exists>xs xs'a acc acc'.\n                              ltl xsa = xs \\<and>\n                              ltl xs' = xs'a \\<and>\n                              llist_all2 P (lmirror_aux acc xs)\n                               (lmirror_aux acc' xs'a) \\<and>\n                              llist_all2 P acc acc' \\<and>\n                              lfinite acc) \\<or>\n                          llist_all2 P (ltl xsa) (ltl xs'))", "from \\<open>llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs')\\<close> \\<open>\\<not> lnull xs\\<close> \\<open>\\<not> lnull xs'\\<close>"], ["proof (chain)\npicking this:\n  llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs')\n  \\<not> lnull xs\n  \\<not> lnull xs'", "have ?lhd"], ["proof (prove)\nusing this:\n  llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs')\n  \\<not> lnull xs\n  \\<not> lnull xs'\n\ngoal (1 subgoal):\n 1. P (lhd xs) (lhd xs')", "by(auto dest: llist_all2_lhdD simp add: lhd_lmirror_aux)"], ["proof (state)\nthis:\n  P (lhd xs) (lhd xs')\n\ngoal (1 subgoal):\n 1. \\<And>xsa xs' acc acc'.\n       \\<lbrakk>llist_all2 P (lmirror_aux acc xsa) (lmirror_aux acc' xs');\n        llist_all2 P acc acc'; lfinite acc; \\<not> lnull xsa;\n        \\<not> lnull xs'\\<rbrakk>\n       \\<Longrightarrow> P (lhd xsa) (lhd xs') \\<and>\n                         ((\\<exists>xs xs'a acc acc'.\n                              ltl xsa = xs \\<and>\n                              ltl xs' = xs'a \\<and>\n                              llist_all2 P (lmirror_aux acc xs)\n                               (lmirror_aux acc' xs'a) \\<and>\n                              llist_all2 P acc acc' \\<and>\n                              lfinite acc) \\<or>\n                          llist_all2 P (ltl xsa) (ltl xs'))", "thus ?case"], ["proof (prove)\nusing this:\n  P (lhd xs) (lhd xs')\n\ngoal (1 subgoal):\n 1. P (lhd xs) (lhd xs') \\<and>\n    ((\\<exists>xs xs' acc acc'.\n         ltl xs = xs \\<and>\n         ltl xs' = xs' \\<and>\n         llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs') \\<and>\n         llist_all2 P acc acc' \\<and> lfinite acc) \\<or>\n     llist_all2 P (ltl xs) (ltl xs'))", "using LCons \\<open>llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs')\\<close>[THEN llist_all2_ltlI]"], ["proof (prove)\nusing this:\n  P (lhd xs) (lhd xs')\n  llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs')\n  llist_all2 P acc acc'\n  lfinite acc\n  \\<not> lnull xs\n  \\<not> lnull xs'\n  llist_all2 P (ltl (lmirror_aux acc xs)) (ltl (lmirror_aux acc' xs'))\n\ngoal (1 subgoal):\n 1. P (lhd xs) (lhd xs') \\<and>\n    ((\\<exists>xs xs' acc acc'.\n         ltl xs = xs \\<and>\n         ltl xs' = xs' \\<and>\n         llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs') \\<and>\n         llist_all2 P acc acc' \\<and> lfinite acc) \\<or>\n     llist_all2 P (ltl xs) (ltl xs'))", "by(auto 4 3 simp add: ltl_lmirror_aux)"], ["proof (state)\nthis:\n  P (lhd xs) (lhd xs') \\<and>\n  ((\\<exists>xs xs' acc acc'.\n       ltl xs = xs \\<and>\n       ltl xs' = xs' \\<and>\n       llist_all2 P (lmirror_aux acc xs) (lmirror_aux acc' xs') \\<and>\n       llist_all2 P acc acc' \\<and> lfinite acc) \\<or>\n   llist_all2 P (ltl xs) (ltl xs'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llist_all2_lmirrorI:\n  \"llist_all2 P xs ys \\<Longrightarrow> llist_all2 P (lmirror xs) (lmirror ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs ys \\<Longrightarrow>\n    llist_all2 P (lmirror xs) (lmirror ys)", "by(simp add: lmirror_def llist_all2_lmirror_aux)"], ["", "lemma llist_all2_lmirrorD:\n  \"llist_all2 P (lmirror xs) (lmirror ys) \\<Longrightarrow> llist_all2 P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P (lmirror xs) (lmirror ys) \\<Longrightarrow>\n    llist_all2 P xs ys", "unfolding lmirror_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P (lmirror_aux LNil xs)\n     (lmirror_aux LNil ys) \\<Longrightarrow>\n    llist_all2 P xs ys", "by(erule llist_all2_lmirror_auxD) simp_all"], ["", "lemma llist_all2_lmirror [simp]:\n  \"llist_all2 P (lmirror xs) (lmirror ys) \\<longleftrightarrow> llist_all2 P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P (lmirror xs) (lmirror ys) = llist_all2 P xs ys", "by(blast intro: llist_all2_lmirrorI llist_all2_lmirrorD)"], ["", "lemma lmirror_parametric [transfer_rule]:\n  includes lifting_syntax\n  shows \"(llist_all2 A ===> llist_all2 A) lmirror lmirror\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_all2 A ===> llist_all2 A) lmirror lmirror", "by(rule rel_funI)(rule llist_all2_lmirrorI)"], ["", "end"]]}