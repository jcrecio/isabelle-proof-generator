{"file_name": "/home/qj213/afp-2021-10-22/thys/Coinductive/Examples/LList_CCPO_Topology.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Coinductive", "problem_names": ["lemma closed_Collect_eq_isCont:\n  fixes f g :: \"'a :: t2_space \\<Rightarrow> 'b::t2_space\"\n  assumes f: \"\\<And>x. isCont f x\" and g: \"\\<And>x. isCont g x\"\n  shows \"closed {x. f x = g x}\"", "lemma tendsto_mcont_llist: \"mcont lSup lprefix lSup lprefix f \\<Longrightarrow> f \\<midarrow>l\\<rightarrow> f l\"", "lemma tendsto_ltl[THEN tendsto_compose, tendsto_intros]: \"ltl \\<midarrow>l\\<rightarrow> ltl l\"", "lemma tendsto_lappend2[THEN tendsto_compose, tendsto_intros]: \"lappend l \\<midarrow>l'\\<rightarrow> lappend l l'\"", "lemma tendsto_LCons[THEN tendsto_compose, tendsto_intros]: \"LCons x \\<midarrow>l\\<rightarrow> LCons x l\"", "lemma tendsto_lmap[THEN tendsto_compose, tendsto_intros]: \"lmap f \\<midarrow>l\\<rightarrow> lmap f l\"", "lemma tendsto_llength[THEN tendsto_compose, tendsto_intros]: \"llength \\<midarrow>l\\<rightarrow> llength l\"", "lemma tendsto_lset[THEN tendsto_compose, tendsto_intros]: \"lset \\<midarrow>l\\<rightarrow> lset l\"", "lemma open_lhd: \"open {l. \\<not> lnull l \\<and> lhd l = x}\"", "lemma open_LCons': assumes A: \"open A\" shows \"open (LCons x ` A)\"", "lemma open_Ici: \"lfinite xs \\<Longrightarrow> open {xs ..}\"", "lemma open_lfinite[simp]: \"lfinite x \\<Longrightarrow> open {x}\"", "lemma open_singleton_iff_lfinite: \"open {x} \\<longleftrightarrow> lfinite x\"", "lemma closure_eq_lfinite:\n  assumes closed_Q: \"closed {xs. Q xs}\"\n  assumes downwards_Q: \"\\<And>xs ys. Q xs \\<Longrightarrow> lprefix ys xs \\<Longrightarrow> Q ys\"\n  shows \"{xs. Q xs} = closure {xs. lfinite xs \\<and> Q xs}\"", "lemma closure_lfinite: \"closure {xs. lfinite xs} = UNIV\"", "lemma closed_ldistinct: \"closed {xs. ldistinct xs}\"", "lemma ldistinct_closure: \"{xs. ldistinct xs} = closure {xs. lfinite xs \\<and> ldistinct xs}\"", "lemma closed_ldistinct': \"(\\<And>x. isCont f x) \\<Longrightarrow> closed {xs. ldistinct (f xs)}\"", "lemma closed_lsorted: \"closed {xs. lsorted xs}\"", "lemma lsorted_closure: \"{xs. lsorted xs} = closure {xs. lfinite xs \\<and> lsorted xs}\"", "lemma closed_lsorted': \"(\\<And>x. isCont f x) \\<Longrightarrow> closed {xs. lsorted (f xs)}\"", "lemma closed_in_lset: \"closed {l. x \\<in> lset l}\"", "lemma closed_llist_all2:\n  \"closed {(x, y). llist_all2 R x y}\"", "lemma closed_list_all2:\n  fixes f g :: \"'b::t2_space \\<Rightarrow> 'a llist\"\n  assumes f: \"\\<And>x. isCont f x\" and g: \"\\<And>x. isCont g x\"\n  shows \"closed {x. llist_all2 R (f x) (g x)}\"", "lemma at_botI_lfinite[simp]: \"lfinite l \\<Longrightarrow> at l = bot\"", "lemma at_eq_lfinite: \"at l = (if lfinite l then bot else at' l)\"", "lemma eventually_lfinite: \"eventually lfinite (at' x)\"", "lemma eventually_nhds_llist:\n  \"eventually P (nhds l) \\<longleftrightarrow> (\\<exists>xs\\<le>l. lfinite xs \\<and> (\\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys))\"", "lemma nhds_lfinite: \"lfinite l \\<Longrightarrow> nhds l = principal {l}\"", "lemma eventually_at'_llist:\n  \"eventually P (at' l) \\<longleftrightarrow> (\\<exists>xs\\<le>l. lfinite xs \\<and> (\\<forall>ys\\<ge>xs. lfinite ys \\<longrightarrow> ys \\<le> l \\<longrightarrow> P ys))\"", "lemma eventually_at'_llistI: \"(\\<And>xs. lfinite xs \\<Longrightarrow> xs \\<le> l \\<Longrightarrow> P xs) \\<Longrightarrow> eventually P (at' l)\"", "lemma Lim_at'_lfinite: \"lfinite xs \\<Longrightarrow> Lim (at' xs) f = f xs\"", "lemma filterlim_at'_list:\n  \"(f \\<longlongrightarrow> y) (at' (x::'a llist)) \\<Longrightarrow> f \\<midarrow>x\\<rightarrow> y\"", "lemma tendsto_mcont_llist': \"mcont lSup lprefix lSup lprefix f \\<Longrightarrow> (f \\<longlongrightarrow> f x) (at' (x :: 'a llist))\"", "lemma tendsto_closed:\n  assumes eq: \"closed {x. P x}\"\n  assumes ev: \"\\<And>ys. lfinite ys \\<Longrightarrow> ys \\<le> x \\<Longrightarrow> P ys\"\n  shows \"P x\"", "lemma tendsto_Sup_at':\n  fixes f :: \"'a llist \\<Rightarrow> 'b::ccpo_topology\"\n  assumes f: \"\\<And>x y. x \\<le> y \\<Longrightarrow> lfinite x \\<Longrightarrow> lfinite y \\<Longrightarrow> f x \\<le> f y\"\n  shows \"(f \\<longlongrightarrow> (Sup (f`{xs. lfinite xs \\<and> xs \\<le> l}))) (at' l)\"", "lemma tendsto_Lim_at':\n  fixes f :: \"'a llist \\<Rightarrow> 'b::ccpo_topology\"\n  assumes f: \"\\<And>l. f l = Lim (at' l) f'\"\n  assumes mono: \"\\<And>x y. x \\<le> y \\<Longrightarrow> lfinite x \\<Longrightarrow> lfinite y \\<Longrightarrow> f' x \\<le> f' y\"\n  shows \"(f \\<longlongrightarrow> f l) (at' l)\"", "lemma isCont_LCons[THEN isCont_o2[rotated]]: \"isCont (LCons x) l\"", "lemma isCont_lmap[THEN isCont_o2[rotated]]: \"isCont (lmap f) l\"", "lemma isCont_lappend[THEN isCont_o2[rotated]]: \"isCont (lappend xs) ys\"", "lemma isCont_lset[THEN isCont_o2[rotated]]: \"isCont lset xs\"", "lemma tendsto_lfilter: \"(lfilter' P \\<longlongrightarrow> lfilter' P xs) (at' xs)\"", "lemma isCont_lfilter[THEN isCont_o2[rotated]]: \"isCont (lfilter' P) l\"", "lemma lfilter'_lfinite[simp]: \"lfinite xs \\<Longrightarrow> lfilter' P xs = llist_of (filter P (list_of xs))\"", "lemma lfilter'_LNil: \"lfilter' P LNil = LNil\"", "lemma lfilter'_LCons [simp]: \"lfilter' P (LCons a xs) = (if P a then LCons a (lfilter' P xs) else lfilter' P xs)\"", "lemma ldistinct_lfilter': \"ldistinct l \\<Longrightarrow> ldistinct (lfilter' P l)\"", "lemma lfilter'_lmap: \"lfilter' P (lmap f xs) = lmap f (lfilter' (P \\<circ> f) xs)\"", "lemma lfilter'_lfilter': \"lfilter' P (lfilter' Q xs) = lfilter' (\\<lambda>x. Q x \\<and> P x) xs\"", "lemma lfilter'_LNil_I[simp]: \"(\\<forall>x \\<in> lset xs. \\<not> P x) \\<Longrightarrow> lfilter' P xs = LNil\"", "lemma lset_lfilter': \"lset (lfilter' P xs) = lset xs \\<inter> {x. P x}\"", "lemma lfilter'_eq_LNil_iff: \"lfilter' P xs = LNil \\<longleftrightarrow> (\\<forall>x\\<in>lset xs. \\<not> P x)\"", "lemma lfilter'_eq_lfilter: \"lfilter' P xs = lfilter P xs\"", "lemma tendsto_lconcat': \"(lconcat' \\<longlongrightarrow> lconcat' xss) (at' xss)\"", "lemma isCont_lconcat'[THEN isCont_o2[rotated]]: \"isCont lconcat' l\"", "lemma lconcat'_lfinite[simp]: \"lfinite xs \\<Longrightarrow> lconcat' xs = foldr lappend (list_of xs) LNil\"", "lemma lconcat'_LNil: \"lconcat' LNil = LNil\"", "lemma lconcat'_LCons [simp]: \"lconcat' (LCons l xs) = lappend l (lconcat' xs)\"", "lemma lmap_lconcat: \"lmap f (lconcat' xss) = lconcat' (lmap (lmap f) (xss::'a llist llist))\"", "lemmas tendsto_Sup[THEN tendsto_compose, tendsto_intros] =\n  mcont_SUP[OF mcont_id' mcont_const, THEN tendsto_mcont]", "lemma\n  assumes fin: \"\\<forall>xs\\<in>lset xss. lfinite xs\"\n  shows \"lset (lconcat' xss) = (\\<Union>xs\\<in>lset xss. lset xs)\" (is \"?lhs = ?rhs\")", "lemma tendsto_ldropWhile':\n  \"(ldropWhile' P \\<longlongrightarrow> ldropWhile' P xs) (at' xs)\"", "lemma isCont_ldropWhile'[THEN isCont_o2[rotated]]: \"isCont (ldropWhile' P) l\"", "lemma ldropWhile'_lfinite[simp]: \"lfinite xs \\<Longrightarrow> ldropWhile' P xs = llist_of (dropWhile P (list_of xs))\"", "lemma ldropWhile'_LNil: \"ldropWhile' P LNil = LNil\"", "lemma ldropWhile'_LCons [simp]: \"ldropWhile' P (LCons l xs) = (if P l then ldropWhile' P xs else LCons l xs)\"", "lemma \"ldropWhile' P (lmap f xs) = lmap f (ldropWhile' (P \\<circ> f) xs)\"", "lemma ldropWhile'_LNil_I[simp]: \"\\<forall>x \\<in> lset xs. P x \\<Longrightarrow> ldropWhile' P xs = LNil\"", "lemma lnull_ldropWhile': \"lnull (ldropWhile' P xs) \\<longleftrightarrow> (\\<forall>x \\<in> lset xs. P x)\" (is \"?lhs \\<longleftrightarrow> _\")", "lemma lhd_lfilter': \"lhd (lfilter' P xs) = lhd (ldropWhile' (Not \\<circ> P) xs)\"", "lemma mono_edrop: \"edrop n xs \\<le> edrop n (xs @ ys)\"", "lemma edrop_mono: \"xs \\<le> ys \\<Longrightarrow> edrop n xs \\<le> edrop n ys\"", "lemma ldrop'_lfinite[simp]: \"lfinite xs \\<Longrightarrow> ldrop' n xs = llist_of (edrop n (list_of xs))\"", "lemma tendsto_ldrop': \"(ldrop' n \\<longlongrightarrow> ldrop' n l) (at' l)\"", "lemma isCont_ldrop'[THEN isCont_o2[rotated]]: \"isCont (ldrop' n) l\"", "lemma \"ldrop' n LNil = LNil\"", "lemma \"ldrop' n (LCons x xs) = (case n of 0 \\<Rightarrow> LCons x xs | eSuc n \\<Rightarrow> ldrop' n xs)\"", "lemma set_upD: \"x \\<in> set (up y xs) \\<Longrightarrow> x \\<in> set xs \\<and> y < x\"", "lemma prefix_up: \"prefix (up a xs) (up a (xs @  ys))\"", "lemma mono_up: \"xs \\<le> ys \\<Longrightarrow> up a xs \\<le> up a ys\"", "lemma sorted_up: \"sorted (up a xs)\"", "lemma tendsto_lup: \"(lup a \\<longlongrightarrow> lup a xs) (at' xs)\"", "lemma isCont_lup[THEN isCont_o2[rotated]]: \"isCont (lup a) l\"", "lemma lup_lfinite[simp]: \"lfinite xs \\<Longrightarrow> lup a xs = llist_of (up a (list_of xs))\"", "lemma lup_LNil: \"lup a LNil = LNil\"", "lemma lup_LCons [simp]: \"lup a (LCons x xs) = (if a < x then LCons x (lup x xs) else lup a xs)\"", "lemma lset_lup: \"lset (lup x xs) \\<subseteq> lset xs \\<inter> {y. x < y}\"", "lemma lsorted_lup: \"lsorted (lup (a::'a::linorder) l)\"", "lemma monotone_lup': \"monotone (rel_prod (=) lprefix) lprefix (\\<lambda>(a, xs). lup' a xs)\"", "lemma mono2mono_lup'2[THEN llist.mono2mono, simp, cont_intro]:\n  shows monotone_lup'2: \"monotone lprefix lprefix (lup' a)\"", "lemma mcont_lup': \"mcont (prod_lub the_Sup lSup) (rel_prod (=) lprefix) lSup lprefix (\\<lambda>(a, xs). lup' a xs)\"", "lemma mcont2mcont_lup'2[THEN llist.mcont2mcont, simp, cont_intro]:\n  shows mcont_lup'2: \"mcont lSup lprefix lSup lprefix (lup' a)\"", "lemma lset_lup'_subset:\n  fixes x :: \"_ :: preorder\"\n  shows \"lset (lup' x xs) \\<subseteq> lset xs \\<inter> {y. x < y}\"", "lemma in_lset_lup'D:\n  fixes x :: \"_ :: preorder\"\n  assumes \"y \\<in> lset (lup' x xs)\"\n  shows \"y \\<in> lset xs \\<and> x < y\"", "lemma lsorted_lup':\n  fixes x :: \"_ :: preorder\"\n  shows \"lsorted (lup' x xs)\"", "lemma ldistinct_lup':\n  fixes x :: \"_ :: preorder\"\n  shows \"ldistinct (lup' x xs)\"", "lemma lmap_iterate: \"lmap f (iterate x) = iterate (f x)\"", "lemma prefix_ext:\n  \"prefix (extup a xs) (extup a (xs @  ys))\"\n  \"prefix (extdown a xs) (extdown a (xs @  ys))\"", "lemma mono_ext: assumes \"xs \\<le> ys\" shows \"extup a xs \\<le> extup a ys\" \"extdown a xs \\<le> extdown a ys\"", "lemma set_ext: \"set (extup a xs) \\<subseteq> {a} \\<union> set xs\" \"set (extdown a xs) \\<subseteq> {a} \\<union> set xs\"", "lemma tendsto_lextup[tendsto_intros]: \"(lextup i \\<longlongrightarrow> lextup i xs) (at' xs)\"", "lemma tendsto_lextdown[tendsto_intros]: \"(lextdown i \\<longlongrightarrow> lextdown i xs) (at' xs)\"", "lemma isCont_lextup[THEN isCont_o2[rotated]]: \"isCont (lextup a) l\"", "lemma isCont_lextdown[THEN isCont_o2[rotated]]: \"isCont (lextdown a) l\"", "lemma lextup_lfinite[simp]: \"lfinite xs \\<Longrightarrow> lextup i xs = llist_of (extup i (list_of xs))\"", "lemma lextdown_lfinite[simp]: \"lfinite xs \\<Longrightarrow> lextdown i xs = llist_of (extdown i (list_of xs))\"", "lemma \"lextup i LNil = LNil\" \"lextdown i LNil = LNil\"", "lemma \"lextup i (LCons x xs) = (if i \\<le> x then lextup x xs else LCons i (lextdown x xs))\"", "lemma \"lextdown i (LCons x xs) = (if x \\<le> i then lextdown x xs else LCons i (lextup x xs))\"", "lemma \"lset (lextup a xs) \\<subseteq> {a} \\<union> lset xs\"", "lemma \"lset (lextdown a xs) \\<subseteq> {a} \\<union> lset xs\"", "lemma distinct_ext:\n  assumes \"distinct xs\" \"a \\<notin> set xs\"\n  shows \"distinct (extup a xs)\" \"distinct (extdown a xs)\"", "lemma \"ldistinct xs \\<Longrightarrow> a \\<notin> lset xs \\<Longrightarrow> ldistinct (lextup a xs)\"", "lemma esum_list_lfinite[simp]: \"lfinite xs \\<Longrightarrow> esum_list xs = sum_list (list_of xs)\"", "lemma esum_list_LNil: \"esum_list LNil = 0\"", "lemma esum_list_tendsto_SUP:\n  \"((sum_list\\<circ>list_of) \\<longlongrightarrow> (SUP ys \\<in> {ys. lfinite ys \\<and> ys \\<le> xs}. esum_list ys)) (at' xs)\"\n    (is \"(_ \\<longlongrightarrow> ?y) _\")", "lemma tendsto_esum_list: \"(esum_list \\<longlongrightarrow> esum_list xs) (at' xs)\"", "lemma isCont_esum_list: \"isCont esum_list xs\"", "lemma esum_list_nonneg:\n  \"(\\<And>x. x \\<in> lset xs \\<Longrightarrow> 0 \\<le> x) \\<Longrightarrow> 0 \\<le> esum_list xs\"", "lemma esum_list_LCons:\n  assumes x: \"0 \\<le> x\" \"\\<And>x. x \\<in> lset xs \\<Longrightarrow> 0 \\<le> x\" shows \"esum_list (LCons x xs) = x + esum_list xs\"", "lemma esum_list_lfilter':\n  assumes nn: \"\\<And>x. x \\<in> lset xs \\<Longrightarrow> 0 \\<le> x\" shows \"esum_list (lfilter' (\\<lambda>x. x \\<noteq> 0) xs) = esum_list xs\"", "lemma length_f[simp]: \"length (f xs) = length xs\"", "lemma f_mono': \"\\<exists>ys'. f (xs @ ys) = f xs @ ys'\"", "lemma f_mono: \"xs \\<le> ys \\<Longrightarrow> f xs \\<le> f ys\"", "lemma f'_lfinite[simp]: \"lfinite xs \\<Longrightarrow> f' xs = llist_of (f (list_of xs))\"", "lemma tendsto_f': \"(f' \\<longlongrightarrow> f' l) (at' l)\"", "lemma isCont_f'[THEN isCont_o2[rotated]]: \"isCont f' l\"", "lemma \"f' LNil = LNil\"", "lemma \"f' (LCons x xs) = LCons (x * 2) (f' (f' xs))\""], "translations": [["", "lemma closed_Collect_eq_isCont:\n  fixes f g :: \"'a :: t2_space \\<Rightarrow> 'b::t2_space\"\n  assumes f: \"\\<And>x. isCont f x\" and g: \"\\<And>x. isCont g x\"\n  shows \"closed {x. f x = g x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {x. f x = g x}", "by (intro closed_Collect_eq continuous_at_imp_continuous_on ballI assms)"], ["", "instantiation llist :: (type) ccpo_topology\nbegin"], ["", "definition open_llist :: \"'a llist set \\<Rightarrow> bool\" where\n  \"open_llist A \\<longleftrightarrow> (\\<forall>C. chain C \\<longrightarrow> C \\<noteq> {} \\<longrightarrow> Sup C \\<in> A \\<longrightarrow> C \\<inter> A \\<noteq> {})\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a llist, ccpo_topology_class)", "by intro_classes (simp add: open_llist_def)"], ["", "end"], ["", "subsection \\<open>Continuity and closedness of predefined constants\\<close>"], ["", "lemma tendsto_mcont_llist: \"mcont lSup lprefix lSup lprefix f \\<Longrightarrow> f \\<midarrow>l\\<rightarrow> f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup lprefix lSup lprefix f \\<Longrightarrow>\n    f \\<midarrow>l\\<rightarrow> f l", "by (auto simp add: Sup_llist_def[abs_def] intro!: tendsto_mcont)"], ["", "lemma tendsto_ltl[THEN tendsto_compose, tendsto_intros]: \"ltl \\<midarrow>l\\<rightarrow> ltl l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl \\<midarrow>l\\<rightarrow> ltl l", "by (intro tendsto_mcont_llist mcont_ltl)"], ["", "lemma tendsto_lappend2[THEN tendsto_compose, tendsto_intros]: \"lappend l \\<midarrow>l'\\<rightarrow> lappend l l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend l \\<midarrow>l'\\<rightarrow> lappend l l'", "by (intro tendsto_mcont_llist mcont_lappend2)"], ["", "lemma tendsto_LCons[THEN tendsto_compose, tendsto_intros]: \"LCons x \\<midarrow>l\\<rightarrow> LCons x l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LCons x \\<midarrow>l\\<rightarrow> LCons x l", "by (intro tendsto_mcont_llist mcont_LCons)"], ["", "lemma tendsto_lmap[THEN tendsto_compose, tendsto_intros]: \"lmap f \\<midarrow>l\\<rightarrow> lmap f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f \\<midarrow>l\\<rightarrow> lmap f l", "by (intro tendsto_mcont_llist mcont_lmap)"], ["", "lemma tendsto_llength[THEN tendsto_compose, tendsto_intros]: \"llength \\<midarrow>l\\<rightarrow> llength l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength \\<midarrow>l\\<rightarrow> llength l", "by (intro tendsto_mcont) (simp add: Sup_llist_def[abs_def])"], ["", "lemma tendsto_lset[THEN tendsto_compose, tendsto_intros]: \"lset \\<midarrow>l\\<rightarrow> lset l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset \\<midarrow>l\\<rightarrow> lset l", "by(rule tendsto_mcont)(simp add: Sup_llist_def[abs_def])"], ["", "lemma open_lhd: \"open {l. \\<not> lnull l \\<and> lhd l = x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open {l. \\<not> lnull l \\<and> lhd l = x}", "unfolding open_ccpo set_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       chain C \\<longrightarrow>\n       \\<not> (\\<forall>x. (x \\<in> C) = (x \\<in> {})) \\<longrightarrow>\n       \\<Squnion> C\n       \\<in> {l. \\<not> lnull l \\<and> lhd l = x} \\<longrightarrow>\n       \\<not> (\\<forall>xa.\n                  (xa \\<in> C \\<inter>\n                            {l. \\<not> lnull l \\<and> lhd l = x}) =\n                  (xa \\<in> {}))", "proof (simp add: imp_conjL Sup_llist_def del: lhd_lSup, intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>Complete_Partial_Order.chain lprefix C; C \\<noteq> {};\n        \\<exists>x\\<in>C. \\<not> lnull x; lhd (lSup C) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> C \\<and>\n                            \\<not> lnull xa \\<and> lhd xa = x", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>Complete_Partial_Order.chain lprefix C; C \\<noteq> {};\n        \\<exists>x\\<in>C. \\<not> lnull x; lhd (lSup C) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> C \\<and>\n                            \\<not> lnull xa \\<and> lhd xa = x", "assume \"Complete_Partial_Order.chain lprefix C\" \"lhd (lSup C) = x\""], ["proof (state)\nthis:\n  Complete_Partial_Order.chain lprefix C\n  lhd (lSup C) = x\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>Complete_Partial_Order.chain lprefix C; C \\<noteq> {};\n        \\<exists>x\\<in>C. \\<not> lnull x; lhd (lSup C) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> C \\<and>\n                            \\<not> lnull xa \\<and> lhd xa = x", "moreover"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain lprefix C\n  lhd (lSup C) = x\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>Complete_Partial_Order.chain lprefix C; C \\<noteq> {};\n        \\<exists>x\\<in>C. \\<not> lnull x; lhd (lSup C) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> C \\<and>\n                            \\<not> lnull xa \\<and> lhd xa = x", "assume \"\\<exists>c\\<in>C. \\<not> lnull c\""], ["proof (state)\nthis:\n  \\<exists>c\\<in>C. \\<not> lnull c\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>Complete_Partial_Order.chain lprefix C; C \\<noteq> {};\n        \\<exists>x\\<in>C. \\<not> lnull x; lhd (lSup C) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> C \\<and>\n                            \\<not> lnull xa \\<and> lhd xa = x", "then"], ["proof (chain)\npicking this:\n  \\<exists>c\\<in>C. \\<not> lnull c", "obtain c where \"c \\<in> C\" \"\\<not> lnull c\""], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>C. \\<not> lnull c\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> C; \\<not> lnull c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<in> C\n  \\<not> lnull c\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>Complete_Partial_Order.chain lprefix C; C \\<noteq> {};\n        \\<exists>x\\<in>C. \\<not> lnull x; lhd (lSup C) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> C \\<and>\n                            \\<not> lnull xa \\<and> lhd xa = x", "ultimately"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain lprefix C\n  lhd (lSup C) = x\n  c \\<in> C\n  \\<not> lnull c", "show \"\\<exists>c. c \\<in> C \\<and> \\<not> lnull c \\<and> lhd c = x\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain lprefix C\n  lhd (lSup C) = x\n  c \\<in> C\n  \\<not> lnull c\n\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<in> C \\<and> \\<not> lnull c \\<and> lhd c = x", "by (force simp: lhd_lSup_eq)"], ["proof (state)\nthis:\n  \\<exists>c. c \\<in> C \\<and> \\<not> lnull c \\<and> lhd c = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma open_LCons': assumes A: \"open A\" shows \"open (LCons x ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (LCons x ` A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. open (LCons x ` A)", "have \"open (ltl -` A \\<inter> {l. \\<not> lnull l \\<and> lhd l = x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (ltl -` A \\<inter> {l. \\<not> lnull l \\<and> lhd l = x})", "by (intro open_Int open_vimageI open_lhd A tendsto_intros)"], ["proof (state)\nthis:\n  open (ltl -` A \\<inter> {l. \\<not> lnull l \\<and> lhd l = x})\n\ngoal (1 subgoal):\n 1. open (LCons x ` A)", "also"], ["proof (state)\nthis:\n  open (ltl -` A \\<inter> {l. \\<not> lnull l \\<and> lhd l = x})\n\ngoal (1 subgoal):\n 1. open (LCons x ` A)", "have \"(ltl -` A \\<inter> {l. \\<not> lnull l \\<and> lhd l = x}) = LCons x ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl -` A \\<inter> {l. \\<not> lnull l \\<and> lhd l = x} = LCons x ` A", "by force"], ["proof (state)\nthis:\n  ltl -` A \\<inter> {l. \\<not> lnull l \\<and> lhd l = x} = LCons x ` A\n\ngoal (1 subgoal):\n 1. open (LCons x ` A)", "finally"], ["proof (chain)\npicking this:\n  open (LCons x ` A)", "show ?thesis"], ["proof (prove)\nusing this:\n  open (LCons x ` A)\n\ngoal (1 subgoal):\n 1. open (LCons x ` A)", "."], ["proof (state)\nthis:\n  open (LCons x ` A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma open_Ici: \"lfinite xs \\<Longrightarrow> open {xs ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> open {xs..}", "proof (induct xs rule: lfinite.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. open {LNil..}\n 2. \\<And>xs x.\n       \\<lbrakk>lfinite xs; open {xs..}\\<rbrakk>\n       \\<Longrightarrow> open {LCons x xs..}", "case lfinite_LNil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. open {LNil..}\n 2. \\<And>xs x.\n       \\<lbrakk>lfinite xs; open {xs..}\\<rbrakk>\n       \\<Longrightarrow> open {LCons x xs..}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. open {LNil..}", "by (simp add: atLeast_def)"], ["proof (state)\nthis:\n  open {LNil..}\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>lfinite xs; open {xs..}\\<rbrakk>\n       \\<Longrightarrow> open {LCons x xs..}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>lfinite xs; open {xs..}\\<rbrakk>\n       \\<Longrightarrow> open {LCons x xs..}", "case (lfinite_LConsI xs x)"], ["proof (state)\nthis:\n  lfinite xs\n  open {xs..}\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>lfinite xs; open {xs..}\\<rbrakk>\n       \\<Longrightarrow> open {LCons x xs..}", "moreover"], ["proof (state)\nthis:\n  lfinite xs\n  open {xs..}\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>lfinite xs; open {xs..}\\<rbrakk>\n       \\<Longrightarrow> open {LCons x xs..}", "have \"{LCons x xs ..} = LCons x ` {xs ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {LCons x xs..} = LCons x ` {xs..}", "by (auto simp: LCons_lprefix_conv)"], ["proof (state)\nthis:\n  {LCons x xs..} = LCons x ` {xs..}\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>lfinite xs; open {xs..}\\<rbrakk>\n       \\<Longrightarrow> open {LCons x xs..}", "ultimately"], ["proof (chain)\npicking this:\n  lfinite xs\n  open {xs..}\n  {LCons x xs..} = LCons x ` {xs..}", "show ?case"], ["proof (prove)\nusing this:\n  lfinite xs\n  open {xs..}\n  {LCons x xs..} = LCons x ` {xs..}\n\ngoal (1 subgoal):\n 1. open {LCons x xs..}", "by (auto intro: open_LCons')"], ["proof (state)\nthis:\n  open {LCons x xs..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma open_lfinite[simp]: \"lfinite x \\<Longrightarrow> open {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite x \\<Longrightarrow> open {x}", "proof (induct rule: lfinite.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. open {LNil}\n 2. \\<And>xs x.\n       \\<lbrakk>lfinite xs; open {xs}\\<rbrakk>\n       \\<Longrightarrow> open {LCons x xs}", "show \"open {LNil}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open {LNil}", "using open_ccpo_Iic[of LNil]"], ["proof (prove)\nusing this:\n  open {..LNil}\n\ngoal (1 subgoal):\n 1. open {LNil}", "by (simp add: atMost_def lnull_def)"], ["proof (state)\nthis:\n  open {LNil}\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>lfinite xs; open {xs}\\<rbrakk>\n       \\<Longrightarrow> open {LCons x xs}", "qed (auto dest: open_LCons')"], ["", "lemma open_singleton_iff_lfinite: \"open {x} \\<longleftrightarrow> lfinite x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open {x} = lfinite x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. open {x} \\<Longrightarrow> lfinite x\n 2. lfinite x \\<Longrightarrow> open {x}", "assume \"lfinite x\""], ["proof (state)\nthis:\n  lfinite x\n\ngoal (2 subgoals):\n 1. open {x} \\<Longrightarrow> lfinite x\n 2. lfinite x \\<Longrightarrow> open {x}", "then"], ["proof (chain)\npicking this:\n  lfinite x", "show \"open {x}\""], ["proof (prove)\nusing this:\n  lfinite x\n\ngoal (1 subgoal):\n 1. open {x}", "unfolding compact_eq_lfinite[symmetric] Sup_llist_def[abs_def, symmetric] less_eq_llist_def[abs_def, symmetric]"], ["proof (prove)\nusing this:\n  compact_element x\n\ngoal (1 subgoal):\n 1. open {x}", "by (rule open_singletonI_compact)"], ["proof (state)\nthis:\n  open {x}\n\ngoal (1 subgoal):\n 1. open {x} \\<Longrightarrow> lfinite x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. open {x} \\<Longrightarrow> lfinite x", "assume \"open {x}\""], ["proof (state)\nthis:\n  open {x}\n\ngoal (1 subgoal):\n 1. open {x} \\<Longrightarrow> lfinite x", "show \"lfinite x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite x", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite x \\<Longrightarrow> False", "let ?C = \"{ys. lprefix ys x \\<and> ys \\<noteq> x}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite x \\<Longrightarrow> False", "assume inf: \"\\<not> lfinite x\""], ["proof (state)\nthis:\n  \\<not> lfinite x\n\ngoal (1 subgoal):\n 1. \\<not> lfinite x \\<Longrightarrow> False", "note lSup_strict_prefixes[OF this] \\<open>open {x}\\<close>"], ["proof (state)\nthis:\n  lSup {ys. lprefix ys x \\<and> ys \\<noteq> x} = x\n  open {x}\n\ngoal (1 subgoal):\n 1. \\<not> lfinite x \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  lSup {ys. lprefix ys x \\<and> ys \\<noteq> x} = x\n  open {x}\n\ngoal (1 subgoal):\n 1. \\<not> lfinite x \\<Longrightarrow> False", "have \"chain ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain {ys. lprefix ys x \\<and> ys \\<noteq> x}", "using lprefixes_chain[of x]"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain lprefix {ys. lprefix ys x}\n\ngoal (1 subgoal):\n 1. chain {ys. lprefix ys x \\<and> ys \\<noteq> x}", "by (auto dest: chain_compr)"], ["proof (state)\nthis:\n  chain {ys. lprefix ys x \\<and> ys \\<noteq> x}\n\ngoal (1 subgoal):\n 1. \\<not> lfinite x \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  chain {ys. lprefix ys x \\<and> ys \\<noteq> x}\n\ngoal (1 subgoal):\n 1. \\<not> lfinite x \\<Longrightarrow> False", "have \"?C \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ys. lprefix ys x \\<and> ys \\<noteq> x} \\<noteq> {}", "using inf"], ["proof (prove)\nusing this:\n  \\<not> lfinite x\n\ngoal (1 subgoal):\n 1. {ys. lprefix ys x \\<and> ys \\<noteq> x} \\<noteq> {}", "by (cases x) auto"], ["proof (state)\nthis:\n  {ys. lprefix ys x \\<and> ys \\<noteq> x} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> lfinite x \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  lSup {ys. lprefix ys x \\<and> ys \\<noteq> x} = x\n  open {x}\n  chain {ys. lprefix ys x \\<and> ys \\<noteq> x}\n  {ys. lprefix ys x \\<and> ys \\<noteq> x} \\<noteq> {}", "show False"], ["proof (prove)\nusing this:\n  lSup {ys. lprefix ys x \\<and> ys \\<noteq> x} = x\n  open {x}\n  chain {ys. lprefix ys x \\<and> ys \\<noteq> x}\n  {ys. lprefix ys x \\<and> ys \\<noteq> x} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: open_ccpo Sup_llist_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lfinite x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closure_eq_lfinite:\n  assumes closed_Q: \"closed {xs. Q xs}\"\n  assumes downwards_Q: \"\\<And>xs ys. Q xs \\<Longrightarrow> lprefix ys xs \\<Longrightarrow> Q ys\"\n  shows \"{xs. Q xs} = closure {xs. lfinite xs \\<and> Q xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs. Q xs} = closure {xs. lfinite xs \\<and> Q xs}", "proof (rule closure_unique[symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. {xs. lfinite xs \\<and> Q xs} \\<subseteq> {xs. Q xs}\n 2. closed {xs. Q xs}\n 3. \\<And>T'.\n       \\<lbrakk>{xs. lfinite xs \\<and> Q xs} \\<subseteq> T';\n        closed T'\\<rbrakk>\n       \\<Longrightarrow> {xs. Q xs} \\<subseteq> T'", "fix T"], ["proof (state)\ngoal (3 subgoals):\n 1. {xs. lfinite xs \\<and> Q xs} \\<subseteq> {xs. Q xs}\n 2. closed {xs. Q xs}\n 3. \\<And>T'.\n       \\<lbrakk>{xs. lfinite xs \\<and> Q xs} \\<subseteq> T';\n        closed T'\\<rbrakk>\n       \\<Longrightarrow> {xs. Q xs} \\<subseteq> T'", "assume T: \"{xs. lfinite xs \\<and> Q xs} \\<subseteq> T\" and \"closed T\""], ["proof (state)\nthis:\n  {xs. lfinite xs \\<and> Q xs} \\<subseteq> T\n  closed T\n\ngoal (3 subgoals):\n 1. {xs. lfinite xs \\<and> Q xs} \\<subseteq> {xs. Q xs}\n 2. closed {xs. Q xs}\n 3. \\<And>T'.\n       \\<lbrakk>{xs. lfinite xs \\<and> Q xs} \\<subseteq> T';\n        closed T'\\<rbrakk>\n       \\<Longrightarrow> {xs. Q xs} \\<subseteq> T'", "show \"{xs. Q xs} \\<subseteq> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs. Q xs} \\<subseteq> T", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Q x \\<Longrightarrow> x \\<in> T", "fix xs :: \"'a llist\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Q x \\<Longrightarrow> x \\<in> T", "let ?F = \"{ys. lprefix ys xs \\<and> lfinite ys}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Q x \\<Longrightarrow> x \\<in> T", "assume \"Q xs\""], ["proof (state)\nthis:\n  Q xs\n\ngoal (1 subgoal):\n 1. \\<And>x. Q x \\<Longrightarrow> x \\<in> T", "with T downwards_Q"], ["proof (chain)\npicking this:\n  {xs. lfinite xs \\<and> Q xs} \\<subseteq> T\n  \\<lbrakk>Q ?xs; lprefix ?ys ?xs\\<rbrakk> \\<Longrightarrow> Q ?ys\n  Q xs", "have \"?F \\<subseteq> T\""], ["proof (prove)\nusing this:\n  {xs. lfinite xs \\<and> Q xs} \\<subseteq> T\n  \\<lbrakk>Q ?xs; lprefix ?ys ?xs\\<rbrakk> \\<Longrightarrow> Q ?ys\n  Q xs\n\ngoal (1 subgoal):\n 1. {ys. lprefix ys xs \\<and> lfinite ys} \\<subseteq> T", "by auto"], ["proof (state)\nthis:\n  {ys. lprefix ys xs \\<and> lfinite ys} \\<subseteq> T\n\ngoal (1 subgoal):\n 1. \\<And>x. Q x \\<Longrightarrow> x \\<in> T", "moreover"], ["proof (state)\nthis:\n  {ys. lprefix ys xs \\<and> lfinite ys} \\<subseteq> T\n\ngoal (1 subgoal):\n 1. \\<And>x. Q x \\<Longrightarrow> x \\<in> T", "have \"chain ?F\" \"?F \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain {ys. lprefix ys xs \\<and> lfinite ys} &&&\n    {ys. lprefix ys xs \\<and> lfinite ys} \\<noteq> {}", "by (auto intro: lprefixes_chain chain_subset)"], ["proof (state)\nthis:\n  chain {ys. lprefix ys xs \\<and> lfinite ys}\n  {ys. lprefix ys xs \\<and> lfinite ys} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x. Q x \\<Longrightarrow> x \\<in> T", "moreover"], ["proof (state)\nthis:\n  chain {ys. lprefix ys xs \\<and> lfinite ys}\n  {ys. lprefix ys xs \\<and> lfinite ys} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x. Q x \\<Longrightarrow> x \\<in> T", "have \"lSup ?F = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lSup {ys. lprefix ys xs \\<and> lfinite ys} = xs", "by (rule lSup_finite_prefixes)"], ["proof (state)\nthis:\n  lSup {ys. lprefix ys xs \\<and> lfinite ys} = xs\n\ngoal (1 subgoal):\n 1. \\<And>x. Q x \\<Longrightarrow> x \\<in> T", "ultimately"], ["proof (chain)\npicking this:\n  {ys. lprefix ys xs \\<and> lfinite ys} \\<subseteq> T\n  chain {ys. lprefix ys xs \\<and> lfinite ys}\n  {ys. lprefix ys xs \\<and> lfinite ys} \\<noteq> {}\n  lSup {ys. lprefix ys xs \\<and> lfinite ys} = xs", "show \"xs \\<in> T\""], ["proof (prove)\nusing this:\n  {ys. lprefix ys xs \\<and> lfinite ys} \\<subseteq> T\n  chain {ys. lprefix ys xs \\<and> lfinite ys}\n  {ys. lprefix ys xs \\<and> lfinite ys} \\<noteq> {}\n  lSup {ys. lprefix ys xs \\<and> lfinite ys} = xs\n\ngoal (1 subgoal):\n 1. xs \\<in> T", "using \\<open>closed T\\<close>"], ["proof (prove)\nusing this:\n  {ys. lprefix ys xs \\<and> lfinite ys} \\<subseteq> T\n  chain {ys. lprefix ys xs \\<and> lfinite ys}\n  {ys. lprefix ys xs \\<and> lfinite ys} \\<noteq> {}\n  lSup {ys. lprefix ys xs \\<and> lfinite ys} = xs\n  closed T\n\ngoal (1 subgoal):\n 1. xs \\<in> T", "by (auto simp: closed_ccpo Sup_llist_def)"], ["proof (state)\nthis:\n  xs \\<in> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {xs. Q xs} \\<subseteq> T\n\ngoal (2 subgoals):\n 1. {xs. lfinite xs \\<and> Q xs} \\<subseteq> {xs. Q xs}\n 2. closed {xs. Q xs}", "qed (auto simp: closed_Q)"], ["", "lemma closure_lfinite: \"closure {xs. lfinite xs} = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closure {xs. lfinite xs} = UNIV", "using closure_eq_lfinite[of \"\\<lambda>_. True\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed {xs. True};\n   \\<And>xs ys.\n      \\<lbrakk>True; lprefix ys xs\\<rbrakk> \\<Longrightarrow> True\\<rbrakk>\n  \\<Longrightarrow> {xs. True} = closure {xs. lfinite xs \\<and> True}\n\ngoal (1 subgoal):\n 1. closure {xs. lfinite xs} = UNIV", "by auto"], ["", "lemma closed_ldistinct: \"closed {xs. ldistinct xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {xs. ldistinct xs}", "unfolding closed_ccpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       chain C \\<longrightarrow>\n       C \\<noteq> {} \\<longrightarrow>\n       C \\<subseteq> Collect ldistinct \\<longrightarrow>\n       \\<Squnion> C \\<in> Collect ldistinct", "by (auto simp: ldistinct_lSup Sup_llist_def subset_eq)"], ["", "lemma ldistinct_closure: \"{xs. ldistinct xs} = closure {xs. lfinite xs \\<and> ldistinct xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs. ldistinct xs} = closure {xs. lfinite xs \\<and> ldistinct xs}", "by (rule closure_eq_lfinite[OF closed_ldistinct ldistinct_lprefix])"], ["", "lemma closed_ldistinct': \"(\\<And>x. isCont f x) \\<Longrightarrow> closed {xs. ldistinct (f xs)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. isCont f x) \\<Longrightarrow> closed {xs. ldistinct (f xs)}", "using continuous_closed_vimage[of _ f, OF closed_ldistinct]"], ["proof (prove)\nusing this:\n  (\\<And>x. isCont f x) \\<Longrightarrow> closed (f -` {xs. ldistinct xs})\n\ngoal (1 subgoal):\n 1. (\\<And>x. isCont f x) \\<Longrightarrow> closed {xs. ldistinct (f xs)}", "by auto"], ["", "lemma closed_lsorted: \"closed {xs. lsorted xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {xs. lsorted xs}", "unfolding closed_ccpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       chain C \\<longrightarrow>\n       C \\<noteq> {} \\<longrightarrow>\n       C \\<subseteq> Collect lsorted \\<longrightarrow>\n       \\<Squnion> C \\<in> Collect lsorted", "by (auto simp: lsorted_lSup Sup_llist_def subset_eq)"], ["", "lemma lsorted_closure: \"{xs. lsorted xs} = closure {xs. lfinite xs \\<and> lsorted xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs. lsorted xs} = closure {xs. lfinite xs \\<and> lsorted xs}", "by (rule closure_eq_lfinite[OF closed_lsorted lsorted_lprefixD])"], ["", "lemma closed_lsorted': \"(\\<And>x. isCont f x) \\<Longrightarrow> closed {xs. lsorted (f xs)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. isCont f x) \\<Longrightarrow> closed {xs. lsorted (f xs)}", "using continuous_closed_vimage[of _ f, OF closed_lsorted]"], ["proof (prove)\nusing this:\n  (\\<And>x. isCont f x) \\<Longrightarrow> closed (f -` {xs. lsorted xs})\n\ngoal (1 subgoal):\n 1. (\\<And>x. isCont f x) \\<Longrightarrow> closed {xs. lsorted (f xs)}", "by auto"], ["", "lemma closed_in_lset: \"closed {l. x \\<in> lset l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {l. x \\<in> lset l}", "unfolding closed_ccpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       chain C \\<longrightarrow>\n       C \\<noteq> {} \\<longrightarrow>\n       C \\<subseteq> {l. x \\<in> lset l} \\<longrightarrow>\n       \\<Squnion> C \\<in> {l. x \\<in> lset l}", "by (auto simp add: subset_eq lset_lSup Sup_llist_def)"], ["", "lemma closed_llist_all2:\n  \"closed {(x, y). llist_all2 R x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {(x, y). llist_all2 R x y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closed {(x, y). llist_all2 R x y}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. closed {(x, y). llist_all2 R x y}", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. closed {(x, y). llist_all2 R x y}", "assume *: \"\\<And>A B. open A \\<Longrightarrow> open B \\<Longrightarrow> a \\<in> A \\<Longrightarrow> b \\<in> B \\<Longrightarrow> (\\<exists>x\\<in>A. \\<exists>y\\<in>B. llist_all2 R x y)\""], ["proof (state)\nthis:\n  \\<lbrakk>open ?A; open ?B; a \\<in> ?A; b \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>?A. \\<exists>y\\<in>?B. llist_all2 R x y\n\ngoal (1 subgoal):\n 1. closed {(x, y). llist_all2 R x y}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>open ?A; open ?B; a \\<in> ?A; b \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>?A. \\<exists>y\\<in>?B. llist_all2 R x y", "have \"llist_all2 R a b\""], ["proof (prove)\nusing this:\n  \\<lbrakk>open ?A; open ?B; a \\<in> ?A; b \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>?A. \\<exists>y\\<in>?B. llist_all2 R x y\n\ngoal (1 subgoal):\n 1. llist_all2 R a b", "proof (coinduction arbitrary: a b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<forall>A B.\n          open A \\<longrightarrow>\n          open B \\<longrightarrow>\n          a \\<in> A \\<longrightarrow>\n          b \\<in> B \\<longrightarrow>\n          (\\<exists>x\\<in>A. Bex B (llist_all2 R x)) \\<Longrightarrow>\n       lnull a = lnull b\n 2. \\<And>a b.\n       \\<lbrakk>\\<forall>A B.\n                   open A \\<longrightarrow>\n                   open B \\<longrightarrow>\n                   a \\<in> A \\<longrightarrow>\n                   b \\<in> B \\<longrightarrow>\n                   (\\<exists>x\\<in>A. Bex B (llist_all2 R x));\n        \\<not> lnull a; \\<not> lnull b\\<rbrakk>\n       \\<Longrightarrow> R (lhd a) (lhd b) \\<and>\n                         ((\\<exists>aa ba.\n                              ltl a = aa \\<and>\n                              ltl b = ba \\<and>\n                              (\\<forall>A B.\n                                  open A \\<longrightarrow>\n                                  open B \\<longrightarrow>\n                                  aa \\<in> A \\<longrightarrow>\n                                  ba \\<in> B \\<longrightarrow>\n                                  (\\<exists>x\\<in>A.\nBex B (llist_all2 R x)))) \\<or>\n                          llist_all2 R (ltl a) (ltl b))", "case LNil"], ["proof (state)\nthis:\n  \\<forall>A B.\n     open A \\<longrightarrow>\n     open B \\<longrightarrow>\n     a \\<in> A \\<longrightarrow>\n     b \\<in> B \\<longrightarrow> (\\<exists>x\\<in>A. Bex B (llist_all2 R x))\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<forall>A B.\n          open A \\<longrightarrow>\n          open B \\<longrightarrow>\n          a \\<in> A \\<longrightarrow>\n          b \\<in> B \\<longrightarrow>\n          (\\<exists>x\\<in>A. Bex B (llist_all2 R x)) \\<Longrightarrow>\n       lnull a = lnull b\n 2. \\<And>a b.\n       \\<lbrakk>\\<forall>A B.\n                   open A \\<longrightarrow>\n                   open B \\<longrightarrow>\n                   a \\<in> A \\<longrightarrow>\n                   b \\<in> B \\<longrightarrow>\n                   (\\<exists>x\\<in>A. Bex B (llist_all2 R x));\n        \\<not> lnull a; \\<not> lnull b\\<rbrakk>\n       \\<Longrightarrow> R (lhd a) (lhd b) \\<and>\n                         ((\\<exists>aa ba.\n                              ltl a = aa \\<and>\n                              ltl b = ba \\<and>\n                              (\\<forall>A B.\n                                  open A \\<longrightarrow>\n                                  open B \\<longrightarrow>\n                                  aa \\<in> A \\<longrightarrow>\n                                  ba \\<in> B \\<longrightarrow>\n                                  (\\<exists>x\\<in>A.\nBex B (llist_all2 R x)))) \\<or>\n                          llist_all2 R (ltl a) (ltl b))", "from LNil[rule_format, of \"{LNil}\" \"- {LNil}\"] LNil[rule_format, of \"- {LNil}\" \"{LNil}\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>open {LNil}; open (- {LNil}); a \\<in> {LNil};\n   b \\<in> - {LNil}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{LNil}. Bex (- {LNil}) (llist_all2 R x)\n  \\<lbrakk>open (- {LNil}); open {LNil}; a \\<in> - {LNil};\n   b \\<in> {LNil}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>- {LNil}. Bex {LNil} (llist_all2 R x)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>open {LNil}; open (- {LNil}); a \\<in> {LNil};\n   b \\<in> - {LNil}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{LNil}. Bex (- {LNil}) (llist_all2 R x)\n  \\<lbrakk>open (- {LNil}); open {LNil}; a \\<in> - {LNil};\n   b \\<in> {LNil}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>- {LNil}. Bex {LNil} (llist_all2 R x)\n\ngoal (1 subgoal):\n 1. lnull a = lnull b", "by (auto simp: closed_def[symmetric] lnull_def)"], ["proof (state)\nthis:\n  lnull a = lnull b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>A B.\n                   open A \\<longrightarrow>\n                   open B \\<longrightarrow>\n                   a \\<in> A \\<longrightarrow>\n                   b \\<in> B \\<longrightarrow>\n                   (\\<exists>x\\<in>A. Bex B (llist_all2 R x));\n        \\<not> lnull a; \\<not> lnull b\\<rbrakk>\n       \\<Longrightarrow> R (lhd a) (lhd b) \\<and>\n                         ((\\<exists>aa ba.\n                              ltl a = aa \\<and>\n                              ltl b = ba \\<and>\n                              (\\<forall>A B.\n                                  open A \\<longrightarrow>\n                                  open B \\<longrightarrow>\n                                  aa \\<in> A \\<longrightarrow>\n                                  ba \\<in> B \\<longrightarrow>\n                                  (\\<exists>x\\<in>A.\nBex B (llist_all2 R x)))) \\<or>\n                          llist_all2 R (ltl a) (ltl b))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>A B.\n                   open A \\<longrightarrow>\n                   open B \\<longrightarrow>\n                   a \\<in> A \\<longrightarrow>\n                   b \\<in> B \\<longrightarrow>\n                   (\\<exists>x\\<in>A. Bex B (llist_all2 R x));\n        \\<not> lnull a; \\<not> lnull b\\<rbrakk>\n       \\<Longrightarrow> R (lhd a) (lhd b) \\<and>\n                         ((\\<exists>aa ba.\n                              ltl a = aa \\<and>\n                              ltl b = ba \\<and>\n                              (\\<forall>A B.\n                                  open A \\<longrightarrow>\n                                  open B \\<longrightarrow>\n                                  aa \\<in> A \\<longrightarrow>\n                                  ba \\<in> B \\<longrightarrow>\n                                  (\\<exists>x\\<in>A.\nBex B (llist_all2 R x)))) \\<or>\n                          llist_all2 R (ltl a) (ltl b))", "case LCons"], ["proof (state)\nthis:\n  \\<forall>A B.\n     open A \\<longrightarrow>\n     open B \\<longrightarrow>\n     a \\<in> A \\<longrightarrow>\n     b \\<in> B \\<longrightarrow> (\\<exists>x\\<in>A. Bex B (llist_all2 R x))\n  \\<not> lnull a\n  \\<not> lnull b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>A B.\n                   open A \\<longrightarrow>\n                   open B \\<longrightarrow>\n                   a \\<in> A \\<longrightarrow>\n                   b \\<in> B \\<longrightarrow>\n                   (\\<exists>x\\<in>A. Bex B (llist_all2 R x));\n        \\<not> lnull a; \\<not> lnull b\\<rbrakk>\n       \\<Longrightarrow> R (lhd a) (lhd b) \\<and>\n                         ((\\<exists>aa ba.\n                              ltl a = aa \\<and>\n                              ltl b = ba \\<and>\n                              (\\<forall>A B.\n                                  open A \\<longrightarrow>\n                                  open B \\<longrightarrow>\n                                  aa \\<in> A \\<longrightarrow>\n                                  ba \\<in> B \\<longrightarrow>\n                                  (\\<exists>x\\<in>A.\nBex B (llist_all2 R x)))) \\<or>\n                          llist_all2 R (ltl a) (ltl b))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (lhd a) (lhd b) \\<and>\n    ((\\<exists>a b.\n         ltl a = a \\<and>\n         ltl b = b \\<and>\n         (\\<forall>A B.\n             open A \\<longrightarrow>\n             open B \\<longrightarrow>\n             a \\<in> A \\<longrightarrow>\n             b \\<in> B \\<longrightarrow>\n             (\\<exists>x\\<in>A. Bex B (llist_all2 R x)))) \\<or>\n     llist_all2 R (ltl a) (ltl b))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. R (lhd a) (lhd b)\n 2. (\\<exists>a b.\n        ltl a = a \\<and>\n        ltl b = b \\<and>\n        (\\<forall>A B.\n            open A \\<longrightarrow>\n            open B \\<longrightarrow>\n            a \\<in> A \\<longrightarrow>\n            b \\<in> B \\<longrightarrow>\n            (\\<exists>x\\<in>A. Bex B (llist_all2 R x)))) \\<or>\n    llist_all2 R (ltl a) (ltl b)", "show ?lhd"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (lhd a) (lhd b)", "using LCons(1)[rule_format, OF open_lhd open_lhd, of \"lhd a\" \"lhd b\"] LCons(2,3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<in> {l. \\<not> lnull l \\<and> lhd l = lhd a};\n   b \\<in> {l. \\<not> lnull l \\<and> lhd l = lhd b}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{l. \\<not> lnull l \\<and> lhd l = lhd a}.\n                       Bex {l. \\<not> lnull l \\<and> lhd l = lhd b}\n                        (llist_all2 R x)\n  \\<not> lnull a\n  \\<not> lnull b\n\ngoal (1 subgoal):\n 1. R (lhd a) (lhd b)", "by (auto dest: llist_all2_lhdD)"], ["proof (state)\nthis:\n  R (lhd a) (lhd b)\n\ngoal (1 subgoal):\n 1. (\\<exists>a b.\n        ltl a = a \\<and>\n        ltl b = b \\<and>\n        (\\<forall>A B.\n            open A \\<longrightarrow>\n            open B \\<longrightarrow>\n            a \\<in> A \\<longrightarrow>\n            b \\<in> B \\<longrightarrow>\n            (\\<exists>x\\<in>A. Bex B (llist_all2 R x)))) \\<or>\n    llist_all2 R (ltl a) (ltl b)", "show ?ltl"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a b.\n        ltl a = a \\<and>\n        ltl b = b \\<and>\n        (\\<forall>A B.\n            open A \\<longrightarrow>\n            open B \\<longrightarrow>\n            a \\<in> A \\<longrightarrow>\n            b \\<in> B \\<longrightarrow>\n            (\\<exists>x\\<in>A. Bex B (llist_all2 R x)))) \\<or>\n    llist_all2 R (ltl a) (ltl b)", "proof (rule, simp, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>open A; open B; ltl a \\<in> A; ltl b \\<in> B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A.\n                            \\<exists>xa\\<in>B. llist_all2 R x xa", "fix A B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>open A; open B; ltl a \\<in> A; ltl b \\<in> B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A.\n                            \\<exists>xa\\<in>B. llist_all2 R x xa", "assume \"open A\" \"open B\" \"ltl a \\<in> A\" \"ltl b \\<in> B\""], ["proof (state)\nthis:\n  open A\n  open B\n  ltl a \\<in> A\n  ltl b \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>open A; open B; ltl a \\<in> A; ltl b \\<in> B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A.\n                            \\<exists>xa\\<in>B. llist_all2 R x xa", "with LCons(1)[rule_format, OF open_LCons' open_LCons', of A B \"lhd a\" \"lhd b\"] LCons(2,3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>open A; open B; a \\<in> LCons (lhd a) ` A;\n   b \\<in> LCons (lhd b) ` B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>LCons (lhd a) ` A.\n                       Bex (LCons (lhd b) ` B) (llist_all2 R x)\n  \\<not> lnull a\n  \\<not> lnull b\n  open A\n  open B\n  ltl a \\<in> A\n  ltl b \\<in> B", "show \"\\<exists>a'\\<in>A. \\<exists>b'\\<in>B. llist_all2 R a' b'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>open A; open B; a \\<in> LCons (lhd a) ` A;\n   b \\<in> LCons (lhd b) ` B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>LCons (lhd a) ` A.\n                       Bex (LCons (lhd b) ` B) (llist_all2 R x)\n  \\<not> lnull a\n  \\<not> lnull b\n  open A\n  open B\n  ltl a \\<in> A\n  ltl b \\<in> B\n\ngoal (1 subgoal):\n 1. \\<exists>a'\\<in>A. \\<exists>b'\\<in>B. llist_all2 R a' b'", "by (auto simp: not_lnull_conv)"], ["proof (state)\nthis:\n  \\<exists>a'\\<in>A. \\<exists>b'\\<in>B. llist_all2 R a' b'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>a b.\n      ltl a = a \\<and>\n      ltl b = b \\<and>\n      (\\<forall>A B.\n          open A \\<longrightarrow>\n          open B \\<longrightarrow>\n          a \\<in> A \\<longrightarrow>\n          b \\<in> B \\<longrightarrow>\n          (\\<exists>x\\<in>A. Bex B (llist_all2 R x)))) \\<or>\n  llist_all2 R (ltl a) (ltl b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R (lhd a) (lhd b) \\<and>\n  ((\\<exists>a b.\n       ltl a = a \\<and>\n       ltl b = b \\<and>\n       (\\<forall>A B.\n           open A \\<longrightarrow>\n           open B \\<longrightarrow>\n           a \\<in> A \\<longrightarrow>\n           b \\<in> B \\<longrightarrow>\n           (\\<exists>x\\<in>A. Bex B (llist_all2 R x)))) \\<or>\n   llist_all2 R (ltl a) (ltl b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  llist_all2 R a b\n\ngoal (1 subgoal):\n 1. closed {(x, y). llist_all2 R x y}", "}"], ["proof (state)\nthis:\n  (\\<And>A B.\n      \\<lbrakk>open A; open B; ?a2 \\<in> A; ?b2 \\<in> B\\<rbrakk>\n      \\<Longrightarrow> \\<exists>x\\<in>A.\n                           \\<exists>y\\<in>B.\n                              llist_all2 R x y) \\<Longrightarrow>\n  llist_all2 R ?a2 ?b2\n\ngoal (1 subgoal):\n 1. closed {(x, y). llist_all2 R x y}", "then"], ["proof (chain)\npicking this:\n  (\\<And>A B.\n      \\<lbrakk>open A; open B; ?a2 \\<in> A; ?b2 \\<in> B\\<rbrakk>\n      \\<Longrightarrow> \\<exists>x\\<in>A.\n                           \\<exists>y\\<in>B.\n                              llist_all2 R x y) \\<Longrightarrow>\n  llist_all2 R ?a2 ?b2", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>A B.\n      \\<lbrakk>open A; open B; ?a2 \\<in> A; ?b2 \\<in> B\\<rbrakk>\n      \\<Longrightarrow> \\<exists>x\\<in>A.\n                           \\<exists>y\\<in>B.\n                              llist_all2 R x y) \\<Longrightarrow>\n  llist_all2 R ?a2 ?b2\n\ngoal (1 subgoal):\n 1. closed {(x, y). llist_all2 R x y}", "unfolding closed_def open_prod_def"], ["proof (prove)\nusing this:\n  (\\<And>A B.\n      \\<lbrakk>open A; open B; ?a2 \\<in> A; ?b2 \\<in> B\\<rbrakk>\n      \\<Longrightarrow> \\<exists>x\\<in>A.\n                           \\<exists>y\\<in>B.\n                              llist_all2 R x y) \\<Longrightarrow>\n  llist_all2 R ?a2 ?b2\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>- {(x, y). llist_all2 R x y}.\n       \\<exists>A B.\n          open A \\<and>\n          open B \\<and>\n          x \\<in> A \\<times> B \\<and>\n          A \\<times> B \\<subseteq> - {(x, y). llist_all2 R x y}", "by (auto simp: subset_eq)"], ["proof (state)\nthis:\n  closed {(x, y). llist_all2 R x y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_list_all2:\n  fixes f g :: \"'b::t2_space \\<Rightarrow> 'a llist\"\n  assumes f: \"\\<And>x. isCont f x\" and g: \"\\<And>x. isCont g x\"\n  shows \"closed {x. llist_all2 R (f x) (g x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {x. llist_all2 R (f x) (g x)}", "using  continuous_closed_vimage[OF closed_llist_all2  isCont_Pair[OF f g]]"], ["proof (prove)\nusing this:\n  closed ((\\<lambda>x. (f x, g x)) -` {(x, y). llist_all2 ?R4 x y})\n\ngoal (1 subgoal):\n 1. closed {x. llist_all2 R (f x) (g x)}", "by simp"], ["", "lemma at_botI_lfinite[simp]: \"lfinite l \\<Longrightarrow> at l = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite l \\<Longrightarrow> at l = \\<bottom>", "by (simp add: at_eq_bot_iff)"], ["", "lemma at_eq_lfinite: \"at l = (if lfinite l then bot else at' l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. at l = (if lfinite l then \\<bottom> else at' l)", "by (auto simp: at'_def open_singleton_iff_lfinite)"], ["", "lemma eventually_lfinite: \"eventually lfinite (at' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually lfinite (at' x)", "apply (simp add: at'_def open_singleton_iff_lfinite eventually_principal eventually_at_topological)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite x \\<longrightarrow>\n    (\\<exists>S.\n        open S \\<and>\n        x \\<in> S \\<and>\n        (\\<forall>xa\\<in>S. xa \\<noteq> x \\<longrightarrow> lfinite xa))", "apply (intro exI[of _ \"{.. x}\"] impI conjI open_ccpo_Iic)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> lfinite x \\<Longrightarrow> x \\<in> {..x}\n 2. \\<not> lfinite x \\<Longrightarrow>\n    \\<forall>xa\\<in>{..x}. xa \\<noteq> x \\<longrightarrow> lfinite xa", "apply (auto simp: lstrict_prefix_def intro!: lstrict_prefix_lfinite1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eventually_nhds_llist:\n  \"eventually P (nhds l) \\<longleftrightarrow> (\\<exists>xs\\<le>l. lfinite xs \\<and> (\\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually P (nhds l) =\n    (\\<exists>xs\\<le>l.\n        lfinite xs \\<and>\n        (\\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys))", "unfolding eventually_nhds"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P) =\n    (\\<exists>xs\\<le>l.\n        lfinite xs \\<and>\n        (\\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys))", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>open S; l \\<in> S; Ball S P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs\\<le>l.\n                            lfinite xs \\<and>\n                            (\\<forall>ys\\<ge>xs.\n                                ys \\<le> l \\<longrightarrow> P ys)\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<le> l; lfinite xs;\n        \\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P", "let ?F = \"{l'. lprefix l' l \\<and> lfinite l'}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>open S; l \\<in> S; Ball S P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs\\<le>l.\n                            lfinite xs \\<and>\n                            (\\<forall>ys\\<ge>xs.\n                                ys \\<le> l \\<longrightarrow> P ys)\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<le> l; lfinite xs;\n        \\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P", "fix A"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>open S; l \\<in> S; Ball S P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs\\<le>l.\n                            lfinite xs \\<and>\n                            (\\<forall>ys\\<ge>xs.\n                                ys \\<le> l \\<longrightarrow> P ys)\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<le> l; lfinite xs;\n        \\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P", "assume \"open A\" \"l \\<in> A\" \"\\<forall>l\\<in>A. P l\""], ["proof (state)\nthis:\n  open A\n  l \\<in> A\n  \\<forall>l\\<in>A. P l\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>open S; l \\<in> S; Ball S P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs\\<le>l.\n                            lfinite xs \\<and>\n                            (\\<forall>ys\\<ge>xs.\n                                ys \\<le> l \\<longrightarrow> P ys)\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<le> l; lfinite xs;\n        \\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P", "moreover"], ["proof (state)\nthis:\n  open A\n  l \\<in> A\n  \\<forall>l\\<in>A. P l\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>open S; l \\<in> S; Ball S P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs\\<le>l.\n                            lfinite xs \\<and>\n                            (\\<forall>ys\\<ge>xs.\n                                ys \\<le> l \\<longrightarrow> P ys)\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<le> l; lfinite xs;\n        \\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P", "have \"chain ?F\" \"?F \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain {l'. lprefix l' l \\<and> lfinite l'} &&&\n    {l'. lprefix l' l \\<and> lfinite l'} \\<noteq> {}", "by (auto simp: chain_def dest: lprefix_down_linear)"], ["proof (state)\nthis:\n  chain {l'. lprefix l' l \\<and> lfinite l'}\n  {l'. lprefix l' l \\<and> lfinite l'} \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>open S; l \\<in> S; Ball S P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs\\<le>l.\n                            lfinite xs \\<and>\n                            (\\<forall>ys\\<ge>xs.\n                                ys \\<le> l \\<longrightarrow> P ys)\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<le> l; lfinite xs;\n        \\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P", "moreover"], ["proof (state)\nthis:\n  chain {l'. lprefix l' l \\<and> lfinite l'}\n  {l'. lprefix l' l \\<and> lfinite l'} \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>open S; l \\<in> S; Ball S P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs\\<le>l.\n                            lfinite xs \\<and>\n                            (\\<forall>ys\\<ge>xs.\n                                ys \\<le> l \\<longrightarrow> P ys)\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<le> l; lfinite xs;\n        \\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P", "have \"Sup ?F = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {l'. lprefix l' l \\<and> lfinite l'} = l", "unfolding Sup_llist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lSup {l'. lprefix l' l \\<and> lfinite l'} = l", "by (rule lSup_finite_prefixes)"], ["proof (state)\nthis:\n  \\<Squnion> {l'. lprefix l' l \\<and> lfinite l'} = l\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>open S; l \\<in> S; Ball S P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs\\<le>l.\n                            lfinite xs \\<and>\n                            (\\<forall>ys\\<ge>xs.\n                                ys \\<le> l \\<longrightarrow> P ys)\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<le> l; lfinite xs;\n        \\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P", "ultimately"], ["proof (chain)\npicking this:\n  open A\n  l \\<in> A\n  \\<forall>l\\<in>A. P l\n  chain {l'. lprefix l' l \\<and> lfinite l'}\n  {l'. lprefix l' l \\<and> lfinite l'} \\<noteq> {}\n  \\<Squnion> {l'. lprefix l' l \\<and> lfinite l'} = l", "have \"\\<exists>xs. xs \\<in> ?F \\<and> (\\<forall>ys\\<ge>xs. ys \\<in> ?F \\<longrightarrow> P ys)\""], ["proof (prove)\nusing this:\n  open A\n  l \\<in> A\n  \\<forall>l\\<in>A. P l\n  chain {l'. lprefix l' l \\<and> lfinite l'}\n  {l'. lprefix l' l \\<and> lfinite l'} \\<noteq> {}\n  \\<Squnion> {l'. lprefix l' l \\<and> lfinite l'} = l\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       xs \\<in> {l'. lprefix l' l \\<and> lfinite l'} \\<and>\n       (\\<forall>ys\\<ge>xs.\n           ys \\<in> {l'. lprefix l' l \\<and> lfinite l'} \\<longrightarrow>\n           P ys)", "using open_ccpoD[of A ?F]"], ["proof (prove)\nusing this:\n  open A\n  l \\<in> A\n  \\<forall>l\\<in>A. P l\n  chain {l'. lprefix l' l \\<and> lfinite l'}\n  {l'. lprefix l' l \\<and> lfinite l'} \\<noteq> {}\n  \\<Squnion> {l'. lprefix l' l \\<and> lfinite l'} = l\n  \\<lbrakk>open A; chain {l'. lprefix l' l \\<and> lfinite l'};\n   {l'. lprefix l' l \\<and> lfinite l'} \\<noteq> {};\n   \\<Squnion> {l'. lprefix l' l \\<and> lfinite l'} \\<in> A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c\\<in>{l'. lprefix l' l \\<and> lfinite l'}.\n                       \\<forall>c'\\<in>{l'. lprefix l' l \\<and> lfinite l'}.\n                          c \\<le> c' \\<longrightarrow> c' \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       xs \\<in> {l'. lprefix l' l \\<and> lfinite l'} \\<and>\n       (\\<forall>ys\\<ge>xs.\n           ys \\<in> {l'. lprefix l' l \\<and> lfinite l'} \\<longrightarrow>\n           P ys)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     xs \\<in> {l'. lprefix l' l \\<and> lfinite l'} \\<and>\n     (\\<forall>ys\\<ge>xs.\n         ys \\<in> {l'. lprefix l' l \\<and> lfinite l'} \\<longrightarrow>\n         P ys)\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>open S; l \\<in> S; Ball S P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs\\<le>l.\n                            lfinite xs \\<and>\n                            (\\<forall>ys\\<ge>xs.\n                                ys \\<le> l \\<longrightarrow> P ys)\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<le> l; lfinite xs;\n        \\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs.\n     xs \\<in> {l'. lprefix l' l \\<and> lfinite l'} \\<and>\n     (\\<forall>ys\\<ge>xs.\n         ys \\<in> {l'. lprefix l' l \\<and> lfinite l'} \\<longrightarrow>\n         P ys)", "show \"\\<exists>xs\\<le>l. lfinite xs \\<and> (\\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys)\""], ["proof (prove)\nusing this:\n  \\<exists>xs.\n     xs \\<in> {l'. lprefix l' l \\<and> lfinite l'} \\<and>\n     (\\<forall>ys\\<ge>xs.\n         ys \\<in> {l'. lprefix l' l \\<and> lfinite l'} \\<longrightarrow>\n         P ys)\n\ngoal (1 subgoal):\n 1. \\<exists>xs\\<le>l.\n       lfinite xs \\<and>\n       (\\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys)", "by (metis (lifting) \\<open>l \\<in> A\\<close> \\<open>\\<forall>l\\<in>A. P l\\<close> le_llist_conv_lprefix mem_Collect_eq not_lfinite_lprefix_conv_eq)"], ["proof (state)\nthis:\n  \\<exists>xs\\<le>l.\n     lfinite xs \\<and>\n     (\\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<le> l; lfinite xs;\n        \\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<le> l; lfinite xs;\n        \\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<le> l; lfinite xs;\n        \\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P", "assume \"xs \\<le> l\" \"lfinite xs\" \"\\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys\""], ["proof (state)\nthis:\n  xs \\<le> l\n  lfinite xs\n  \\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<le> l; lfinite xs;\n        \\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P", "then"], ["proof (chain)\npicking this:\n  xs \\<le> l\n  lfinite xs\n  \\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys", "show \"\\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P\""], ["proof (prove)\nusing this:\n  xs \\<le> l\n  lfinite xs\n  \\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys\n\ngoal (1 subgoal):\n 1. \\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P", "by (intro exI[of _ \"{xs ..} \\<inter> {.. l}\"] conjI open_Int open_Ici open_ccpo_Iic) auto"], ["proof (state)\nthis:\n  \\<exists>S. open S \\<and> l \\<in> S \\<and> Ball S P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nhds_lfinite: \"lfinite l \\<Longrightarrow> nhds l = principal {l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite l \\<Longrightarrow> nhds l = principal {l}", "unfolding filter_eq_iff eventually_principal eventually_nhds_llist"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite l \\<Longrightarrow>\n    \\<forall>P.\n       (\\<exists>xs\\<le>l.\n           lfinite xs \\<and>\n           (\\<forall>ys\\<ge>xs. ys \\<le> l \\<longrightarrow> P ys)) =\n       Ball {l} P", "by (auto simp del: le_llist_conv_lprefix)"], ["", "lemma eventually_at'_llist:\n  \"eventually P (at' l) \\<longleftrightarrow> (\\<exists>xs\\<le>l. lfinite xs \\<and> (\\<forall>ys\\<ge>xs. lfinite ys \\<longrightarrow> ys \\<le> l \\<longrightarrow> P ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually P (at' l) =\n    (\\<exists>xs\\<le>l.\n        lfinite xs \\<and>\n        (\\<forall>ys\\<ge>xs.\n            lfinite ys \\<longrightarrow> ys \\<le> l \\<longrightarrow> P ys))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    eventually P (at' l) =\n    (\\<exists>xs\\<le>l.\n        lfinite xs \\<and>\n        (\\<forall>ys\\<ge>xs.\n            lfinite ys \\<longrightarrow> ys \\<le> l \\<longrightarrow> P ys))\n 2. \\<not> ?P \\<Longrightarrow>\n    eventually P (at' l) =\n    (\\<exists>xs\\<le>l.\n        lfinite xs \\<and>\n        (\\<forall>ys\\<ge>xs.\n            lfinite ys \\<longrightarrow> ys \\<le> l \\<longrightarrow> P ys))", "assume \"lfinite l\""], ["proof (state)\nthis:\n  lfinite l\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    eventually P (at' l) =\n    (\\<exists>xs\\<le>l.\n        lfinite xs \\<and>\n        (\\<forall>ys\\<ge>xs.\n            lfinite ys \\<longrightarrow> ys \\<le> l \\<longrightarrow> P ys))\n 2. \\<not> ?P \\<Longrightarrow>\n    eventually P (at' l) =\n    (\\<exists>xs\\<le>l.\n        lfinite xs \\<and>\n        (\\<forall>ys\\<ge>xs.\n            lfinite ys \\<longrightarrow> ys \\<le> l \\<longrightarrow> P ys))", "then"], ["proof (chain)\npicking this:\n  lfinite l", "show ?thesis"], ["proof (prove)\nusing this:\n  lfinite l\n\ngoal (1 subgoal):\n 1. eventually P (at' l) =\n    (\\<exists>xs\\<le>l.\n        lfinite xs \\<and>\n        (\\<forall>ys\\<ge>xs.\n            lfinite ys \\<longrightarrow> ys \\<le> l \\<longrightarrow> P ys))", "by (auto simp add: eventually_filtermap at'_def open_singleton_iff_lfinite\n                       eventually_principal lfinite_eq_range_llist_of)"], ["proof (state)\nthis:\n  eventually P (at' l) =\n  (\\<exists>xs\\<le>l.\n      lfinite xs \\<and>\n      (\\<forall>ys\\<ge>xs.\n          lfinite ys \\<longrightarrow> ys \\<le> l \\<longrightarrow> P ys))\n\ngoal (1 subgoal):\n 1. \\<not> lfinite l \\<Longrightarrow>\n    eventually P (at' l) =\n    (\\<exists>xs\\<le>l.\n        lfinite xs \\<and>\n        (\\<forall>ys\\<ge>xs.\n            lfinite ys \\<longrightarrow> ys \\<le> l \\<longrightarrow> P ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite l \\<Longrightarrow>\n    eventually P (at' l) =\n    (\\<exists>xs\\<le>l.\n        lfinite xs \\<and>\n        (\\<forall>ys\\<ge>xs.\n            lfinite ys \\<longrightarrow> ys \\<le> l \\<longrightarrow> P ys))", "assume \"\\<not> lfinite l\""], ["proof (state)\nthis:\n  \\<not> lfinite l\n\ngoal (1 subgoal):\n 1. \\<not> lfinite l \\<Longrightarrow>\n    eventually P (at' l) =\n    (\\<exists>xs\\<le>l.\n        lfinite xs \\<and>\n        (\\<forall>ys\\<ge>xs.\n            lfinite ys \\<longrightarrow> ys \\<le> l \\<longrightarrow> P ys))", "then"], ["proof (chain)\npicking this:\n  \\<not> lfinite l", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lfinite l\n\ngoal (1 subgoal):\n 1. eventually P (at' l) =\n    (\\<exists>xs\\<le>l.\n        lfinite xs \\<and>\n        (\\<forall>ys\\<ge>xs.\n            lfinite ys \\<longrightarrow> ys \\<le> l \\<longrightarrow> P ys))", "by (auto simp: eventually_filtermap at'_def open_singleton_iff_lfinite\n                   eventually_at_filter eventually_nhds_llist)\n       (metis not_lfinite_lprefix_conv_eq)"], ["proof (state)\nthis:\n  eventually P (at' l) =\n  (\\<exists>xs\\<le>l.\n      lfinite xs \\<and>\n      (\\<forall>ys\\<ge>xs.\n          lfinite ys \\<longrightarrow> ys \\<le> l \\<longrightarrow> P ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eventually_at'_llistI: \"(\\<And>xs. lfinite xs \\<Longrightarrow> xs \\<le> l \\<Longrightarrow> P xs) \\<Longrightarrow> eventually P (at' l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>lfinite xs; xs \\<le> l\\<rbrakk>\n        \\<Longrightarrow> P xs) \\<Longrightarrow>\n    eventually P (at' l)", "by (auto simp: eventually_at'_llist)"], ["", "lemma Lim_at'_lfinite: \"lfinite xs \\<Longrightarrow> Lim (at' xs) f = f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> Lim (at' xs) f = f xs", "by (rule tendsto_Lim[OF at'_bot]) (auto simp add: at'_def topological_tendstoI eventually_principal)"], ["", "lemma filterlim_at'_list:\n  \"(f \\<longlongrightarrow> y) (at' (x::'a llist)) \\<Longrightarrow> f \\<midarrow>x\\<rightarrow> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> y) (at' x) \\<Longrightarrow>\n    f \\<midarrow>x\\<rightarrow> y", "unfolding at'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> y)\n     (if open {x} then principal {x} else at x) \\<Longrightarrow>\n    f \\<midarrow>x\\<rightarrow> y", "by (auto split: if_split_asm simp: open_singleton_iff_lfinite)"], ["", "lemma tendsto_mcont_llist': \"mcont lSup lprefix lSup lprefix f \\<Longrightarrow> (f \\<longlongrightarrow> f x) (at' (x :: 'a llist))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup lprefix lSup lprefix f \\<Longrightarrow>\n    (f \\<longlongrightarrow> f x) (at' x)", "by(auto simp add: at'_def nhds_lfinite[symmetric] open_singleton_iff_lfinite tendsto_at_iff_tendsto_nhds[symmetric] intro: tendsto_mcont_llist)"], ["", "lemma tendsto_closed:\n  assumes eq: \"closed {x. P x}\"\n  assumes ev: \"\\<And>ys. lfinite ys \\<Longrightarrow> ys \\<le> x \\<Longrightarrow> P ys\"\n  shows \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P x", "have \"x \\<in> {x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x. P x}", "proof (rule Lim_in_closed_set)"], ["proof (state)\ngoal (4 subgoals):\n 1. closed {x. P x}\n 2. \\<forall>\\<^sub>F x in ?F. ?f x \\<in> {x. P x}\n 3. ?F \\<noteq> \\<bottom>\n 4. (?f \\<longlongrightarrow> x) ?F", "show \"eventually (\\<lambda>x. x \\<in> {x. P x}) (at' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at' x. x \\<in> {x. P x}", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at' x. x \\<in> {x. P x}", "using ev"], ["proof (prove)\nusing this:\n  \\<lbrakk>lfinite ?ys; ?ys \\<le> x\\<rbrakk> \\<Longrightarrow> P ?ys\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at' x. x \\<in> {x. P x}", "by (force intro!: eventually_at'_llistI)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at' x. x \\<in> {x. P x}\n\ngoal (3 subgoals):\n 1. closed {x. P x}\n 2. at' x \\<noteq> \\<bottom>\n 3. ((\\<lambda>x. x) \\<longlongrightarrow> x) (at' x)", "qed (rule assms tendsto_id_at' at'_bot)+"], ["proof (state)\nthis:\n  x \\<in> {x. P x}\n\ngoal (1 subgoal):\n 1. P x", "then"], ["proof (chain)\npicking this:\n  x \\<in> {x. P x}", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> {x. P x}\n\ngoal (1 subgoal):\n 1. P x", "by simp"], ["proof (state)\nthis:\n  P x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tendsto_Sup_at':\n  fixes f :: \"'a llist \\<Rightarrow> 'b::ccpo_topology\"\n  assumes f: \"\\<And>x y. x \\<le> y \\<Longrightarrow> lfinite x \\<Longrightarrow> lfinite y \\<Longrightarrow> f x \\<le> f y\"\n  shows \"(f \\<longlongrightarrow> (Sup (f`{xs. lfinite xs \\<and> xs \\<le> l}))) (at' l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow>\n     \\<Squnion> (f ` {xs. lfinite xs \\<and> xs \\<le> l}))\n     (at' l)", "proof (rule topological_tendstoI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>open S;\n        \\<Squnion> (f ` {xs. lfinite xs \\<and> xs \\<le> l}) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F x in at' l. f x \\<in> S", "let ?F = \"{xs. lfinite xs \\<and> xs \\<le> l}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>open S;\n        \\<Squnion> (f ` {xs. lfinite xs \\<and> xs \\<le> l}) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F x in at' l. f x \\<in> S", "have ch_F: \"chain (f`?F)\" \"f`?F \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain (f ` {xs. lfinite xs \\<and> xs \\<le> l}) &&&\n    f ` {xs. lfinite xs \\<and> xs \\<le> l} \\<noteq> {}", "by (rule chain_imageI[OF chain_subset, OF lprefixes_chain]) (auto simp: f)"], ["proof (state)\nthis:\n  chain (f ` {xs. lfinite xs \\<and> xs \\<le> l})\n  f ` {xs. lfinite xs \\<and> xs \\<le> l} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>open S;\n        \\<Squnion> (f ` {xs. lfinite xs \\<and> xs \\<le> l}) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F x in at' l. f x \\<in> S", "fix A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>open S;\n        \\<Squnion> (f ` {xs. lfinite xs \\<and> xs \\<le> l}) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F x in at' l. f x \\<in> S", "assume A: \"open A\" \"Sup (f`?F) \\<in> A\""], ["proof (state)\nthis:\n  open A\n  \\<Squnion> (f ` {xs. lfinite xs \\<and> xs \\<le> l}) \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>open S;\n        \\<Squnion> (f ` {xs. lfinite xs \\<and> xs \\<le> l}) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F x in at' l. f x \\<in> S", "then"], ["proof (chain)\npicking this:\n  open A\n  \\<Squnion> (f ` {xs. lfinite xs \\<and> xs \\<le> l}) \\<in> A", "show \"eventually (\\<lambda>x. f x \\<in> A) (at' l)\""], ["proof (prove)\nusing this:\n  open A\n  \\<Squnion> (f ` {xs. lfinite xs \\<and> xs \\<le> l}) \\<in> A\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at' l. f x \\<in> A", "using open_ccpoD[OF _ ch_F, OF A]"], ["proof (prove)\nusing this:\n  open A\n  \\<Squnion> (f ` {xs. lfinite xs \\<and> xs \\<le> l}) \\<in> A\n  \\<exists>c\\<in>f ` {xs. lfinite xs \\<and> xs \\<le> l}.\n     \\<forall>c'\\<in>f ` {xs. lfinite xs \\<and> xs \\<le> l}.\n        c \\<le> c' \\<longrightarrow> c' \\<in> A\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at' l. f x \\<in> A", "by (auto simp: eventually_at'_llist f simp del: le_llist_conv_lprefix)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at' l. f x \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tendsto_Lim_at':\n  fixes f :: \"'a llist \\<Rightarrow> 'b::ccpo_topology\"\n  assumes f: \"\\<And>l. f l = Lim (at' l) f'\"\n  assumes mono: \"\\<And>x y. x \\<le> y \\<Longrightarrow> lfinite x \\<Longrightarrow> lfinite y \\<Longrightarrow> f' x \\<le> f' y\"\n  shows \"(f \\<longlongrightarrow> f l) (at' l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f l) (at' l)", "unfolding f[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>l. Lim (at' l) f') \\<longlongrightarrow> Lim (at' l) f')\n     (at' l)", "apply (subst filterlim_cong[OF refl refl eventually_mono[OF eventually_lfinite Lim_at'_lfinite]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. lfinite x \\<Longrightarrow> lfinite x\n 2. (f' \\<longlongrightarrow> Lim (at' l) f') (at' l)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f' \\<longlongrightarrow> Lim (at' l) f') (at' l)", "apply (rule tendsto_LimI[OF tendsto_Sup_at'[OF mono]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; lfinite x; lfinite y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; lfinite x; lfinite y\\<rbrakk>\n       \\<Longrightarrow> lfinite x\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; lfinite x; lfinite y\\<rbrakk>\n       \\<Longrightarrow> lfinite y", "apply assumption+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma isCont_LCons[THEN isCont_o2[rotated]]: \"isCont (LCons x) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (LCons x) l", "by (simp add: isCont_def tendsto_LCons tendsto_ident_at)"], ["", "lemma isCont_lmap[THEN isCont_o2[rotated]]: \"isCont (lmap f) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (lmap f) l", "by (simp add: isCont_def tendsto_lmap tendsto_ident_at)"], ["", "lemma isCont_lappend[THEN isCont_o2[rotated]]: \"isCont (lappend xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (lappend xs) ys", "by (simp add: isCont_def tendsto_lappend2 tendsto_ident_at)"], ["", "lemma isCont_lset[THEN isCont_o2[rotated]]: \"isCont lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont lset xs", "by(simp add: isCont_def tendsto_lset tendsto_ident_at)"], ["", "subsection \\<open>Define @{term lfilter} as continuous extension\\<close>"], ["", "definition \"lfilter' P l = Lim (at' l) (\\<lambda>xs. llist_of (filter P (list_of xs)))\""], ["", "lemma tendsto_lfilter: \"(lfilter' P \\<longlongrightarrow> lfilter' P xs) (at' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lfilter' P \\<longlongrightarrow> lfilter' P xs) (at' xs)", "by (rule tendsto_Lim_at'[OF lfilter'_def]) (auto simp add: lfinite_eq_range_llist_of less_eq_list_def prefix_def)"], ["", "lemma isCont_lfilter[THEN isCont_o2[rotated]]: \"isCont (lfilter' P) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (lfilter' P) l", "by (simp add: isCont_def filterlim_at'_list tendsto_lfilter)"], ["", "lemma lfilter'_lfinite[simp]: \"lfinite xs \\<Longrightarrow> lfilter' P xs = llist_of (filter P (list_of xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    lfilter' P xs = llist_of (filter P (list_of xs))", "by (simp add: lfilter'_def Lim_at'_lfinite)"], ["", "lemma lfilter'_LNil: \"lfilter' P LNil = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter' P LNil = LNil", "by simp"], ["", "lemma lfilter'_LCons [simp]: \"lfilter' P (LCons a xs) = (if P a then LCons a (lfilter' P xs) else lfilter' P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter' P (LCons a xs) =\n    (if P a then LCons a (lfilter' P xs) else lfilter' P xs)", "by (rule tendsto_closed[where x=xs, OF closed_Collect_eq_isCont])\n     (auto intro!: isCont_lfilter isCont_LCons isCont_If)"], ["", "lemma ldistinct_lfilter': \"ldistinct l \\<Longrightarrow> ldistinct (lfilter' P l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct l \\<Longrightarrow> ldistinct (lfilter' P l)", "by (rule tendsto_closed[OF closed_ldistinct', OF isCont_lfilter])\n     (auto intro!: distinct_filter dest: ldistinct_lprefix simp: lfinite_eq_range_llist_of)"], ["", "lemma lfilter'_lmap: \"lfilter' P (lmap f xs) = lmap f (lfilter' (P \\<circ> f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter' P (lmap f xs) = lmap f (lfilter' (P \\<circ> f) xs)", "by (rule tendsto_closed[where x=xs, OF closed_Collect_eq_isCont])\n     (auto simp add: filter_map comp_def intro!: isCont_lmap isCont_lfilter)"], ["", "lemma lfilter'_lfilter': \"lfilter' P (lfilter' Q xs) = lfilter' (\\<lambda>x. Q x \\<and> P x) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter' P (lfilter' Q xs) = lfilter' (\\<lambda>x. Q x \\<and> P x) xs", "by (rule tendsto_closed[where x=xs, OF closed_Collect_eq_isCont]) (auto intro!: isCont_lfilter)"], ["", "lemma lfilter'_LNil_I[simp]: \"(\\<forall>x \\<in> lset xs. \\<not> P x) \\<Longrightarrow> lfilter' P xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    lfilter' P xs = LNil", "by (rule tendsto_closed[where x=xs, OF closed_Collect_eq_isCont])\n     (auto simp add: lfinite_eq_range_llist_of llist_of_eq_LNil_conv filter_empty_conv intro: isCont_lfilter dest!: lprefix_lsetD)"], ["", "lemma lset_lfilter': \"lset (lfilter' P xs) = lset xs \\<inter> {x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lfilter' P xs) = lset xs \\<inter> {x. P x}", "by(rule tendsto_closed[OF closed_Collect_eq_isCont])\n    (auto 4 3 intro: isCont_lset isCont_lfilter isCont_inf2)"], ["", "lemma lfilter'_eq_LNil_iff: \"lfilter' P xs = LNil \\<longleftrightarrow> (\\<forall>x\\<in>lset xs. \\<not> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lfilter' P xs = LNil) = (\\<forall>x\\<in>lset xs. \\<not> P x)", "using lset_lfilter'[of P xs]"], ["proof (prove)\nusing this:\n  lset (lfilter' P xs) = lset xs \\<inter> {x. P x}\n\ngoal (1 subgoal):\n 1. (lfilter' P xs = LNil) = (\\<forall>x\\<in>lset xs. \\<not> P x)", "by auto"], ["", "lemma lfilter'_eq_lfilter: \"lfilter' P xs = lfilter P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter' P xs = lfilter P xs", "using isCont_lfilter"], ["proof (prove)\nusing this:\n  isCont ?f ?a \\<Longrightarrow> isCont (\\<lambda>x. lfilter' ?P1 (?f x)) ?a\n\ngoal (1 subgoal):\n 1. lfilter' P xs = lfilter P xs", "proof(rule tendsto_closed[where x=xs, OF closed_Collect_eq_isCont])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. isCont (\\<lambda>x. x) x\n 2. \\<And>x. isCont (lfilter P) x\n 3. \\<And>ys.\n       \\<lbrakk>lfinite ys; ys \\<le> xs\\<rbrakk>\n       \\<Longrightarrow> lfilter' P ys = lfilter P ys", "fix ys :: \"'a llist\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. isCont (\\<lambda>x. x) x\n 2. \\<And>x. isCont (lfilter P) x\n 3. \\<And>ys.\n       \\<lbrakk>lfinite ys; ys \\<le> xs\\<rbrakk>\n       \\<Longrightarrow> lfilter' P ys = lfilter P ys", "assume \"lfinite ys\""], ["proof (state)\nthis:\n  lfinite ys\n\ngoal (3 subgoals):\n 1. \\<And>x. isCont (\\<lambda>x. x) x\n 2. \\<And>x. isCont (lfilter P) x\n 3. \\<And>ys.\n       \\<lbrakk>lfinite ys; ys \\<le> xs\\<rbrakk>\n       \\<Longrightarrow> lfilter' P ys = lfilter P ys", "thus \"lfilter' P ys = lfilter P ys\""], ["proof (prove)\nusing this:\n  lfinite ys\n\ngoal (1 subgoal):\n 1. lfilter' P ys = lfilter P ys", "by induction simp_all"], ["proof (state)\nthis:\n  lfilter' P ys = lfilter P ys\n\ngoal (2 subgoals):\n 1. \\<And>x. isCont (\\<lambda>x. x) x\n 2. \\<And>x. isCont (lfilter P) x", "qed(simp_all add: isCont_def tendsto_mcont_llist mcont_lfilter)"], ["", "subsection \\<open>Define @{term lconcat} as continuous extension\\<close>"], ["", "definition \"lconcat' xs = Lim (at' xs) (\\<lambda>xs. foldr lappend (list_of xs) LNil)\""], ["", "lemma tendsto_lconcat': \"(lconcat' \\<longlongrightarrow> lconcat' xss) (at' xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lconcat' \\<longlongrightarrow> lconcat' xss) (at' xss)", "apply (rule tendsto_Lim_at'[OF lconcat'_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; lfinite x; lfinite y\\<rbrakk>\n       \\<Longrightarrow> foldr lappend (list_of x) LNil\n                         \\<le> foldr lappend (list_of y) LNil", "apply (auto simp add: lfinite_eq_range_llist_of less_eq_list_def prefix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa zs.\n       lprefix (foldr lappend xa LNil)\n        (foldr lappend xa (foldr lappend zs LNil))", "apply (induct_tac xa)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa zs.\n       lprefix (foldr lappend [] LNil)\n        (foldr lappend [] (foldr lappend zs LNil))\n 2. \\<And>xa zs a list.\n       lprefix (foldr lappend list LNil)\n        (foldr lappend list (foldr lappend zs LNil)) \\<Longrightarrow>\n       lprefix (foldr lappend (a # list) LNil)\n        (foldr lappend (a # list) (foldr lappend zs LNil))", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma isCont_lconcat'[THEN isCont_o2[rotated]]: \"isCont lconcat' l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont lconcat' l", "by (simp add: isCont_def filterlim_at'_list tendsto_lconcat')"], ["", "lemma lconcat'_lfinite[simp]: \"lfinite xs \\<Longrightarrow> lconcat' xs = foldr lappend (list_of xs) LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    lconcat' xs = foldr lappend (list_of xs) LNil", "by (simp add: lconcat'_def Lim_at'_lfinite)"], ["", "lemma lconcat'_LNil: \"lconcat' LNil = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat' LNil = LNil", "by simp"], ["", "lemma lconcat'_LCons [simp]: \"lconcat' (LCons l xs) = lappend l (lconcat' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat' (LCons l xs) = lappend l (lconcat' xs)", "by (rule tendsto_closed[where x=xs, OF closed_Collect_eq_isCont])\n     (auto intro!: isCont_lconcat' isCont_lappend isCont_LCons)"], ["", "lemma lmap_lconcat: \"lmap f (lconcat' xss) = lconcat' (lmap (lmap f) (xss::'a llist llist))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (lconcat' xss) = lconcat' (lmap (lmap f) xss)", "proof (rule tendsto_closed[where x=xss, OF closed_Collect_eq_isCont])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. isCont (\\<lambda>a. lmap f (lconcat' a)) x\n 2. \\<And>x. isCont (\\<lambda>a. lconcat' (lmap (lmap f) a)) x\n 3. \\<And>ys.\n       \\<lbrakk>lfinite ys; ys \\<le> xss\\<rbrakk>\n       \\<Longrightarrow> lmap f (lconcat' ys) = lconcat' (lmap (lmap f) ys)", "fix xs :: \"'a llist llist\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. isCont (\\<lambda>a. lmap f (lconcat' a)) x\n 2. \\<And>x. isCont (\\<lambda>a. lconcat' (lmap (lmap f) a)) x\n 3. \\<And>ys.\n       \\<lbrakk>lfinite ys; ys \\<le> xss\\<rbrakk>\n       \\<Longrightarrow> lmap f (lconcat' ys) = lconcat' (lmap (lmap f) ys)", "assume \"lfinite xs\""], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (3 subgoals):\n 1. \\<And>x. isCont (\\<lambda>a. lmap f (lconcat' a)) x\n 2. \\<And>x. isCont (\\<lambda>a. lconcat' (lmap (lmap f) a)) x\n 3. \\<And>ys.\n       \\<lbrakk>lfinite ys; ys \\<le> xss\\<rbrakk>\n       \\<Longrightarrow> lmap f (lconcat' ys) = lconcat' (lmap (lmap f) ys)", "then"], ["proof (chain)\npicking this:\n  lfinite xs", "show \"lmap f (lconcat' xs) = lconcat' (lmap (lmap f) xs)\""], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lmap f (lconcat' xs) = lconcat' (lmap (lmap f) xs)", "by (induct xs rule: lfinite.induct) (auto simp: lmap_lappend_distrib)"], ["proof (state)\nthis:\n  lmap f (lconcat' xs) = lconcat' (lmap (lmap f) xs)\n\ngoal (2 subgoals):\n 1. \\<And>x. isCont (\\<lambda>a. lmap f (lconcat' a)) x\n 2. \\<And>x. isCont (\\<lambda>a. lconcat' (lmap (lmap f) a)) x", "qed (intro isCont_lconcat' isCont_lappend isCont_LCons continuous_ident isCont_lmap)+"], ["", "lemmas tendsto_Sup[THEN tendsto_compose, tendsto_intros] =\n  mcont_SUP[OF mcont_id' mcont_const, THEN tendsto_mcont]"], ["", "lemma\n  assumes fin: \"\\<forall>xs\\<in>lset xss. lfinite xs\"\n  shows \"lset (lconcat' xss) = (\\<Union>xs\\<in>lset xss. lset xs)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lconcat' xss) = \\<Union> (lset ` lset xss)", "proof(rule tendsto_unique_eventually[OF at'_bot])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F x in at' ?x1. ?f x = ?g x\n 2. (?f \\<longlongrightarrow> lset (lconcat' xss)) (at' ?x1)\n 3. (?g \\<longlongrightarrow> \\<Union> (lset ` lset xss)) (at' ?x1)", "show \"eventually (\\<lambda>x. lset (lconcat' x) = (\\<Union>y\\<in>lset x. lset y)) (at' xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at' xss.\n       lset (lconcat' x) = \\<Union> (lset ` lset x)", "proof(rule eventually_at'_llistI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite xs; xs \\<le> xss\\<rbrakk>\n       \\<Longrightarrow> lset (lconcat' xs) = \\<Union> (lset ` lset xs)", "fix xss'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite xs; xs \\<le> xss\\<rbrakk>\n       \\<Longrightarrow> lset (lconcat' xs) = \\<Union> (lset ` lset xs)", "assume \"lfinite xss'\" \"xss' \\<le> xss\""], ["proof (state)\nthis:\n  lfinite xss'\n  xss' \\<le> xss\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite xs; xs \\<le> xss\\<rbrakk>\n       \\<Longrightarrow> lset (lconcat' xs) = \\<Union> (lset ` lset xs)", "hence \"\\<forall>xs\\<in>lset xss'. lfinite xs\""], ["proof (prove)\nusing this:\n  lfinite xss'\n  xss' \\<le> xss\n\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>lset xss'. lfinite xs", "using fin"], ["proof (prove)\nusing this:\n  lfinite xss'\n  xss' \\<le> xss\n  \\<forall>xs\\<in>lset xss. lfinite xs\n\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>lset xss'. lfinite xs", "by (auto dest!: lprefix_lsetD)"], ["proof (state)\nthis:\n  \\<forall>xs\\<in>lset xss'. lfinite xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite xs; xs \\<le> xss\\<rbrakk>\n       \\<Longrightarrow> lset (lconcat' xs) = \\<Union> (lset ` lset xs)", "with \\<open>lfinite xss'\\<close>"], ["proof (chain)\npicking this:\n  lfinite xss'\n  \\<forall>xs\\<in>lset xss'. lfinite xs", "show \"lset (lconcat' xss') = (\\<Union>xs\\<in>lset xss'. lset xs)\""], ["proof (prove)\nusing this:\n  lfinite xss'\n  \\<forall>xs\\<in>lset xss'. lfinite xs\n\ngoal (1 subgoal):\n 1. lset (lconcat' xss') = \\<Union> (lset ` lset xss')", "by (induct xss') auto"], ["proof (state)\nthis:\n  lset (lconcat' xss') = \\<Union> (lset ` lset xss')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at' xss.\n     lset (lconcat' x) = \\<Union> (lset ` lset x)\n\ngoal (2 subgoals):\n 1. ((\\<lambda>x. lset (lconcat' x)) \\<longlongrightarrow>\n     lset (lconcat' xss))\n     (at' xss)\n 2. ((\\<lambda>x. \\<Union> (lset ` lset x)) \\<longlongrightarrow>\n     \\<Union> (lset ` lset xss))\n     (at' xss)", "qed (rule tendsto_intros tendsto_lconcat' tendsto_id_at')+"], ["", "subsection \\<open>Define @{term ldropWhile} as continuous extension\\<close>"], ["", "definition \"ldropWhile' P xs = Lim (at' xs) (\\<lambda>xs. llist_of (dropWhile P (list_of xs)))\""], ["", "lemma tendsto_ldropWhile':\n  \"(ldropWhile' P \\<longlongrightarrow> ldropWhile' P xs) (at' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ldropWhile' P \\<longlongrightarrow> ldropWhile' P xs) (at' xs)", "by (rule tendsto_Lim_at'[OF ldropWhile'_def])\n     (auto simp add: lfinite_eq_range_llist_of less_eq_list_def prefix_def dropWhile_append dropWhile_False)"], ["", "lemma isCont_ldropWhile'[THEN isCont_o2[rotated]]: \"isCont (ldropWhile' P) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (ldropWhile' P) l", "by (simp add: isCont_def filterlim_at'_list tendsto_ldropWhile')"], ["", "lemma ldropWhile'_lfinite[simp]: \"lfinite xs \\<Longrightarrow> ldropWhile' P xs = llist_of (dropWhile P (list_of xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    ldropWhile' P xs = llist_of (dropWhile P (list_of xs))", "by (simp add: ldropWhile'_def Lim_at'_lfinite)"], ["", "lemma ldropWhile'_LNil: \"ldropWhile' P LNil = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropWhile' P LNil = LNil", "by simp"], ["", "lemma ldropWhile'_LCons [simp]: \"ldropWhile' P (LCons l xs) = (if P l then ldropWhile' P xs else LCons l xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropWhile' P (LCons l xs) =\n    (if P l then ldropWhile' P xs else LCons l xs)", "by (rule tendsto_closed[where x=xs, OF closed_Collect_eq_isCont])\n     (auto intro!: isCont_ldropWhile' isCont_If isCont_LCons)"], ["", "lemma \"ldropWhile' P (lmap f xs) = lmap f (ldropWhile' (P \\<circ> f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropWhile' P (lmap f xs) = lmap f (ldropWhile' (P \\<circ> f) xs)", "by (rule tendsto_closed[where x=xs, OF closed_Collect_eq_isCont])\n     (auto simp add: dropWhile_map comp_def intro!: isCont_lmap isCont_ldropWhile')"], ["", "lemma ldropWhile'_LNil_I[simp]: \"\\<forall>x \\<in> lset xs. P x \\<Longrightarrow> ldropWhile' P xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>lset xs. P x \\<Longrightarrow> ldropWhile' P xs = LNil", "by (rule tendsto_closed[where x=xs, OF closed_Collect_eq_isCont])\n     (auto simp add: llist_of_eq_LNil_conv intro!: isCont_lmap isCont_ldropWhile' dest!: lprefix_lsetD)"], ["", "lemma lnull_ldropWhile': \"lnull (ldropWhile' P xs) \\<longleftrightarrow> (\\<forall>x \\<in> lset xs. P x)\" (is \"?lhs \\<longleftrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (ldropWhile' P xs) = (\\<forall>x\\<in>lset xs. P x)", "proof (intro iffI ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>lnull (ldropWhile' P xs); x \\<in> lset xs\\<rbrakk>\n       \\<Longrightarrow> P x\n 2. \\<forall>x\\<in>lset xs. P x \\<Longrightarrow> lnull (ldropWhile' P xs)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>lnull (ldropWhile' P xs); x \\<in> lset xs\\<rbrakk>\n       \\<Longrightarrow> P x\n 2. \\<forall>x\\<in>lset xs. P x \\<Longrightarrow> lnull (ldropWhile' P xs)", "assume \"x \\<in> lset xs\" ?lhs"], ["proof (state)\nthis:\n  x \\<in> lset xs\n  lnull (ldropWhile' P xs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>lnull (ldropWhile' P xs); x \\<in> lset xs\\<rbrakk>\n       \\<Longrightarrow> P x\n 2. \\<forall>x\\<in>lset xs. P x \\<Longrightarrow> lnull (ldropWhile' P xs)", "then"], ["proof (chain)\npicking this:\n  x \\<in> lset xs\n  lnull (ldropWhile' P xs)", "show \"P x\""], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n  lnull (ldropWhile' P xs)\n\ngoal (1 subgoal):\n 1. P x", "by induct (simp_all split: if_split_asm)"], ["proof (state)\nthis:\n  P x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>lset xs. P x \\<Longrightarrow> lnull (ldropWhile' P xs)", "qed simp"], ["", "lemma lhd_lfilter': \"lhd (lfilter' P xs) = lhd (ldropWhile' (Not \\<circ> P) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd (lfilter' P xs) = lhd (ldropWhile' (Not \\<circ> P) xs)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    lhd (lfilter' P xs) = lhd (ldropWhile' (Not \\<circ> P) xs)\n 2. \\<not> ?P \\<Longrightarrow>\n    lhd (lfilter' P xs) = lhd (ldropWhile' (Not \\<circ> P) xs)", "assume \"\\<exists>x\\<in>lset xs. P x\""], ["proof (state)\nthis:\n  \\<exists>x\\<in>lset xs. P x\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    lhd (lfilter' P xs) = lhd (ldropWhile' (Not \\<circ> P) xs)\n 2. \\<not> ?P \\<Longrightarrow>\n    lhd (lfilter' P xs) = lhd (ldropWhile' (Not \\<circ> P) xs)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>lset xs. P x", "obtain x where \"x \\<in> lset xs\" and \"P x\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>lset xs. P x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> lset xs; P x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> lset xs\n  P x\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    lhd (lfilter' P xs) = lhd (ldropWhile' (Not \\<circ> P) xs)\n 2. \\<not> ?P \\<Longrightarrow>\n    lhd (lfilter' P xs) = lhd (ldropWhile' (Not \\<circ> P) xs)", "from \\<open>x \\<in> lset xs\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> lset xs", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n\ngoal (1 subgoal):\n 1. lhd (lfilter' P xs) = lhd (ldropWhile' (Not \\<circ> P) xs)", "by induct (simp_all add: \\<open>P x\\<close>)"], ["proof (state)\nthis:\n  lhd (lfilter' P xs) = lhd (ldropWhile' (Not \\<circ> P) xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>lset xs. P x) \\<Longrightarrow>\n    lhd (lfilter' P xs) = lhd (ldropWhile' (Not \\<circ> P) xs)", "qed simp"], ["", "subsection \\<open>Define \\<open>ldrop\\<close> as continuous extension\\<close>"], ["", "primrec edrop where\n  \"edrop n [] = []\"\n| \"edrop n (x # xs) = (case n of eSuc n \\<Rightarrow> edrop n xs | 0 \\<Rightarrow> x # xs)\""], ["", "lemma mono_edrop: \"edrop n xs \\<le> edrop n (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edrop n xs \\<le> edrop n (xs @ ys)", "by (induct xs arbitrary: n) (auto split: enat_cosplit)"], ["", "lemma edrop_mono: \"xs \\<le> ys \\<Longrightarrow> edrop n xs \\<le> edrop n ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<le> ys \\<Longrightarrow> edrop n xs \\<le> edrop n ys", "using mono_edrop[of n xs]"], ["proof (prove)\nusing this:\n  edrop n xs \\<le> edrop n (xs @ ?ys)\n\ngoal (1 subgoal):\n 1. xs \\<le> ys \\<Longrightarrow> edrop n xs \\<le> edrop n ys", "by (auto simp add: less_eq_list_def prefix_def)"], ["", "definition \"ldrop' n xs = Lim (at' xs) (llist_of \\<circ> edrop n \\<circ> list_of)\""], ["", "lemma ldrop'_lfinite[simp]: \"lfinite xs \\<Longrightarrow> ldrop' n xs = llist_of (edrop n (list_of xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    ldrop' n xs = llist_of (edrop n (list_of xs))", "by (simp add: ldrop'_def Lim_at'_lfinite)"], ["", "lemma tendsto_ldrop': \"(ldrop' n \\<longlongrightarrow> ldrop' n l) (at' l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ldrop' n \\<longlongrightarrow> ldrop' n l) (at' l)", "by (rule tendsto_Lim_at'[OF ldrop'_def]) (auto simp add: lfinite_eq_range_llist_of intro!: edrop_mono)"], ["", "lemma isCont_ldrop'[THEN isCont_o2[rotated]]: \"isCont (ldrop' n) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (ldrop' n) l", "by (simp add: isCont_def filterlim_at'_list tendsto_ldrop')"], ["", "lemma \"ldrop' n LNil = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop' n LNil = LNil", "by simp"], ["", "lemma \"ldrop' n (LCons x xs) = (case n of 0 \\<Rightarrow> LCons x xs | eSuc n \\<Rightarrow> ldrop' n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop' n (LCons x xs) =\n    (case n of 0 \\<Rightarrow> LCons x xs\n     | eSuc n \\<Rightarrow> ldrop' n xs)", "by (rule tendsto_closed[where x=xs, OF closed_Collect_eq_isCont])\n     (auto intro!: isCont_ldrop' isCont_enat_case isCont_LCons split: enat_cosplit)"], ["", "primrec up :: \"'a :: order \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"up a [] = []\"\n| \"up a (x # xs) = (if a < x then x # up x xs else up a xs)\""], ["", "lemma set_upD: \"x \\<in> set (up y xs) \\<Longrightarrow> x \\<in> set xs \\<and> y < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (up y xs) \\<Longrightarrow> x \\<in> set xs \\<and> y < x", "by (induct xs arbitrary: y) (auto split: if_split_asm intro: less_trans)"], ["", "lemma prefix_up: \"prefix (up a xs) (up a (xs @  ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (up a xs) (up a (xs @ ys))", "by (induction xs arbitrary: a) auto"], ["", "lemma mono_up: \"xs \\<le> ys \\<Longrightarrow> up a xs \\<le> up a ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<le> ys \\<Longrightarrow> up a xs \\<le> up a ys", "unfolding less_eq_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs ys \\<Longrightarrow> prefix (up a xs) (up a ys)", "by (subst (asm) prefix_def) (auto intro!: prefix_up)"], ["", "lemma sorted_up: \"sorted (up a xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (up a xs)", "by (induction xs arbitrary: a) (auto dest: set_upD intro: less_imp_le)"], ["", "subsection \\<open>Define more functions on lazy lists as continuous extensions\\<close>"], ["", "definition \"lup a xs = Lim (at' xs) (\\<lambda>xs. llist_of (up a (list_of xs)))\""], ["", "lemma tendsto_lup: \"(lup a \\<longlongrightarrow> lup a xs) (at' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lup a \\<longlongrightarrow> lup a xs) (at' xs)", "by (rule tendsto_Lim_at'[OF lup_def]) (auto simp: lfinite_eq_range_llist_of mono_up)"], ["", "lemma isCont_lup[THEN isCont_o2[rotated]]: \"isCont (lup a) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (lup a) l", "by (simp add: isCont_def filterlim_at'_list tendsto_lup)"], ["", "lemma lup_lfinite[simp]: \"lfinite xs \\<Longrightarrow> lup a xs = llist_of (up a (list_of xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> lup a xs = llist_of (up a (list_of xs))", "by (simp add: lup_def Lim_at'_lfinite)"], ["", "lemma lup_LNil: \"lup a LNil = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lup a LNil = LNil", "by simp"], ["", "lemma lup_LCons [simp]: \"lup a (LCons x xs) = (if a < x then LCons x (lup x xs) else lup a xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lup a (LCons x xs) = (if a < x then LCons x (lup x xs) else lup a xs)", "by (rule tendsto_closed[where x=xs, OF closed_Collect_eq_isCont])\n     (auto intro!: isCont_lup isCont_If isCont_LCons)"], ["", "lemma lset_lup: \"lset (lup x xs) \\<subseteq> lset xs \\<inter> {y. x < y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lup x xs) \\<subseteq> lset xs \\<inter> {y. x < y}", "by (rule tendsto_le_ccpo[where g=\"\\<lambda>xs. lset (lup x xs)\" and f=\"\\<lambda>xs. lset xs \\<inter> {y. x < y}\" and F=\"at' xs\"])\n     (auto dest!: lprefix_lsetD set_upD intro!:  tendsto_intros at'_bot tendsto_lup eventually_at'_llistI)"], ["", "lemma lsorted_lup: \"lsorted (lup (a::'a::linorder) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted (lup a l)", "by (rule tendsto_closed[OF closed_lsorted', OF isCont_lup])\n     (auto intro!: sorted_up simp: lprefix_conv_lappend)"], ["", "context notes [[function_internals]]\nbegin"], ["", "partial_function (llist) lup' :: \"'a :: ord \\<Rightarrow> 'a llist \\<Rightarrow> 'a llist\" where\n  \"lup' a xs = (case xs of LNil \\<Rightarrow> LNil | LCons x xs \\<Rightarrow> if a < x then LCons x (lup' x xs) else lup' a xs)\""], ["", "end"], ["", "declare lup'.mono[cont_intro]"], ["", "lemma monotone_lup': \"monotone (rel_prod (=) lprefix) lprefix (\\<lambda>(a, xs). lup' a xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (rel_prod (=) lprefix) lprefix (\\<lambda>(a, xs). lup' a xs)", "by(rule llist.fixp_preserves_mono2[OF lup'.mono lup'_def]) simp"], ["", "lemma mono2mono_lup'2[THEN llist.mono2mono, simp, cont_intro]:\n  shows monotone_lup'2: \"monotone lprefix lprefix (lup' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone lprefix lprefix (lup' a)", "using monotone_lup'"], ["proof (prove)\nusing this:\n  monotone (rel_prod (=) lprefix) lprefix (\\<lambda>(a, xs). lup' a xs)\n\ngoal (1 subgoal):\n 1. monotone lprefix lprefix (lup' a)", "by auto"], ["", "lemma mcont_lup': \"mcont (prod_lub the_Sup lSup) (rel_prod (=) lprefix) lSup lprefix (\\<lambda>(a, xs). lup' a xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont (prod_lub the_Sup lSup) (rel_prod (=) lprefix) lSup lprefix\n     (\\<lambda>(a, xs). lup' a xs)", "by(rule llist.fixp_preserves_mcont2[OF lup'.mono lup'_def]) simp"], ["", "lemma mcont2mcont_lup'2[THEN llist.mcont2mcont, simp, cont_intro]:\n  shows mcont_lup'2: \"mcont lSup lprefix lSup lprefix (lup' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup lprefix lSup lprefix (lup' a)", "using mcont_lup'"], ["proof (prove)\nusing this:\n  mcont (prod_lub the_Sup lSup) (rel_prod (=) lprefix) lSup lprefix\n   (\\<lambda>(a, xs). lup' a xs)\n\ngoal (1 subgoal):\n 1. mcont lSup lprefix lSup lprefix (lup' a)", "by auto"], ["", "simps_of_case lup'_simps [simp]: lup'.simps"], ["", "lemma lset_lup'_subset:\n  fixes x :: \"_ :: preorder\"\n  shows \"lset (lup' x xs) \\<subseteq> lset xs \\<inter> {y. x < y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lup' x xs) \\<subseteq> lset xs \\<inter> {y. x < y}", "by(induction xs arbitrary: x)(auto intro: less_trans)"], ["", "lemma in_lset_lup'D:\n  fixes x :: \"_ :: preorder\"\n  assumes \"y \\<in> lset (lup' x xs)\"\n  shows \"y \\<in> lset xs \\<and> x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> lset xs \\<and> x < y", "using lset_lup'_subset[of x xs] assms"], ["proof (prove)\nusing this:\n  lset (lup' x xs) \\<subseteq> lset xs \\<inter> {y. x < y}\n  y \\<in> lset (lup' x xs)\n\ngoal (1 subgoal):\n 1. y \\<in> lset xs \\<and> x < y", "by auto"], ["", "lemma lsorted_lup':\n  fixes x :: \"_ :: preorder\"\n  shows \"lsorted (lup' x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted (lup' x xs)", "by(induction xs arbitrary: x)(auto simp add: lsorted_LCons dest: in_lset_lup'D intro: less_imp_le)"], ["", "lemma ldistinct_lup':\n  fixes x :: \"_ :: preorder\"\n  shows \"ldistinct (lup' x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct (lup' x xs)", "by(induction xs arbitrary: x)(auto dest: in_lset_lup'D)"], ["", "context fixes f :: \"'a \\<Rightarrow> 'a\" begin"], ["", "partial_function (llist) iterate :: \"'a \\<Rightarrow> 'a llist\"\nwhere \"iterate x = LCons x (iterate (f x))\""], ["", "lemma lmap_iterate: \"lmap f (iterate x) = iterate (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (local.iterate x) = local.iterate (f x)", "by(induction arbitrary: x rule: iterate.fixp_induct) simp_all"], ["", "end"], ["", "fun extup extdown  :: \"int \\<Rightarrow> int list \\<Rightarrow> int list\" where\n  \"extup i [] = []\"\n| \"extup i (x # xs) = (if i \\<le> x then extup x xs else i # extdown x xs)\"\n| \"extdown i [] = []\"\n| \"extdown i (x # xs) = (if i \\<ge> x then extdown x xs else i # extup x xs)\""], ["", "lemma prefix_ext:\n  \"prefix (extup a xs) (extup a (xs @  ys))\"\n  \"prefix (extdown a xs) (extdown a (xs @  ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (extup a xs) (extup a (xs @ ys)) &&&\n    prefix (extdown a xs) (extdown a (xs @ ys))", "by (induction xs arbitrary: a) auto"], ["", "lemma mono_ext: assumes \"xs \\<le> ys\" shows \"extup a xs \\<le> extup a ys\" \"extdown a xs \\<le> extdown a ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extup a xs \\<le> extup a ys &&& extdown a xs \\<le> extdown a ys", "using assms[unfolded less_eq_list_def prefix_def]"], ["proof (prove)\nusing this:\n  \\<exists>zs. ys = xs @ zs\n\ngoal (1 subgoal):\n 1. extup a xs \\<le> extup a ys &&& extdown a xs \\<le> extdown a ys", "by (auto simp: less_eq_list_def prefix_ext)"], ["", "lemma set_ext: \"set (extup a xs) \\<subseteq> {a} \\<union> set xs\" \"set (extdown a xs) \\<subseteq> {a} \\<union> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (extup a xs) \\<subseteq> {a} \\<union> set xs &&&\n    set (extdown a xs) \\<subseteq> {a} \\<union> set xs", "by (induction xs arbitrary: a) auto"], ["", "definition \"lextup i l = Lim (at' l) (llist_of \\<circ> extup i \\<circ> list_of)\""], ["", "definition \"lextdown i l = Lim (at' l) (llist_of \\<circ> extdown i \\<circ> list_of)\""], ["", "lemma tendsto_lextup[tendsto_intros]: \"(lextup i \\<longlongrightarrow> lextup i xs) (at' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lextup i \\<longlongrightarrow> lextup i xs) (at' xs)", "by (rule tendsto_Lim_at'[OF lextup_def]) (auto simp: lfinite_eq_range_llist_of mono_ext)"], ["", "lemma tendsto_lextdown[tendsto_intros]: \"(lextdown i \\<longlongrightarrow> lextdown i xs) (at' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lextdown i \\<longlongrightarrow> lextdown i xs) (at' xs)", "by (rule tendsto_Lim_at'[OF lextdown_def]) (auto simp: lfinite_eq_range_llist_of mono_ext)"], ["", "lemma isCont_lextup[THEN isCont_o2[rotated]]: \"isCont (lextup a) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (lextup a) l", "by (simp add: isCont_def filterlim_at'_list tendsto_lextup)"], ["", "lemma isCont_lextdown[THEN isCont_o2[rotated]]: \"isCont (lextdown a) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (lextdown a) l", "by (simp add: isCont_def filterlim_at'_list tendsto_lextdown)"], ["", "lemma lextup_lfinite[simp]: \"lfinite xs \\<Longrightarrow> lextup i xs = llist_of (extup i (list_of xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    lextup i xs = llist_of (extup i (list_of xs))", "by (simp add: lextup_def Lim_at'_lfinite)"], ["", "lemma lextdown_lfinite[simp]: \"lfinite xs \\<Longrightarrow> lextdown i xs = llist_of (extdown i (list_of xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    lextdown i xs = llist_of (extdown i (list_of xs))", "by (simp add: lextdown_def Lim_at'_lfinite)"], ["", "lemma \"lextup i LNil = LNil\" \"lextdown i LNil = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lextup i LNil = LNil &&& lextdown i LNil = LNil", "by simp_all"], ["", "lemma \"lextup i (LCons x xs) = (if i \\<le> x then lextup x xs else LCons i (lextdown x xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lextup i (LCons x xs) =\n    (if i \\<le> x then lextup x xs else LCons i (lextdown x xs))", "by (rule tendsto_closed[where x=xs, OF closed_Collect_eq_isCont])\n     (auto intro!: isCont_lextdown isCont_lextup isCont_If isCont_LCons)"], ["", "lemma \"lextdown i (LCons x xs) = (if x \\<le> i then lextdown x xs else LCons i (lextup x xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lextdown i (LCons x xs) =\n    (if x \\<le> i then lextdown x xs else LCons i (lextup x xs))", "by (rule tendsto_closed[where x=xs, OF closed_Collect_eq_isCont])\n     (auto intro!: isCont_lextdown isCont_lextup isCont_If isCont_LCons)"], ["", "lemma \"lset (lextup a xs) \\<subseteq> {a} \\<union> lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lextup a xs) \\<subseteq> {a} \\<union> lset xs", "apply (rule tendsto_le_ccpo[where g=\"\\<lambda>xs. lset (lextup a xs)\" and f=\"\\<lambda>xs. {a} \\<union> lset xs\" and F=\"at' xs\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. at' xs \\<noteq> \\<bottom>\n 2. ((\\<lambda>xs. {a} \\<union> lset xs) \\<longlongrightarrow>\n     {a} \\<union> lset xs)\n     (at' xs)\n 3. ((\\<lambda>xs. lset (lextup a xs)) \\<longlongrightarrow>\n     lset (lextup a xs))\n     (at' xs)\n 4. \\<forall>\\<^sub>F x in at' xs.\n       lset (lextup a x) \\<subseteq> {a} \\<union> lset x", "apply (rule tendsto_intros at'_bot tendsto_lup eventually_at'_llistI tendsto_id_at')+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xsa.\n       \\<lbrakk>lfinite xsa; xsa \\<le> xs\\<rbrakk>\n       \\<Longrightarrow> lset (lextup a xsa)\n                         \\<subseteq> {a} \\<union> lset xsa", "apply (auto dest!: lprefix_lsetD set_ext[THEN subsetD])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"lset (lextdown a xs) \\<subseteq> {a} \\<union> lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lextdown a xs) \\<subseteq> {a} \\<union> lset xs", "apply (rule tendsto_le_ccpo[where g=\"\\<lambda>xs. lset (lextdown a xs)\" and f=\"\\<lambda>xs. {a} \\<union> lset xs\" and F=\"at' xs\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. at' xs \\<noteq> \\<bottom>\n 2. ((\\<lambda>xs. {a} \\<union> lset xs) \\<longlongrightarrow>\n     {a} \\<union> lset xs)\n     (at' xs)\n 3. ((\\<lambda>xs. lset (lextdown a xs)) \\<longlongrightarrow>\n     lset (lextdown a xs))\n     (at' xs)\n 4. \\<forall>\\<^sub>F x in at' xs.\n       lset (lextdown a x) \\<subseteq> {a} \\<union> lset x", "apply (rule tendsto_intros at'_bot tendsto_lup eventually_at'_llistI tendsto_id_at')+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xsa.\n       \\<lbrakk>lfinite xsa; xsa \\<le> xs\\<rbrakk>\n       \\<Longrightarrow> lset (lextdown a xsa)\n                         \\<subseteq> {a} \\<union> lset xsa", "apply (auto dest!: lprefix_lsetD set_ext[THEN subsetD])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distinct_ext:\n  assumes \"distinct xs\" \"a \\<notin> set xs\"\n  shows \"distinct (extup a xs)\" \"distinct (extdown a xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (extup a xs) &&& distinct (extdown a xs)", "using assms set_ext"], ["proof (prove)\nusing this:\n  distinct xs\n  a \\<notin> set xs\n  set (extup ?a ?xs) \\<subseteq> {?a} \\<union> set ?xs\n  set (extdown ?a ?xs) \\<subseteq> {?a} \\<union> set ?xs\n\ngoal (1 subgoal):\n 1. distinct (extup a xs) &&& distinct (extdown a xs)", "apply (induction xs arbitrary: a)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>distinct []; a \\<notin> set [];\n        \\<And>a xs. set (extup a xs) \\<subseteq> {a} \\<union> set xs;\n        \\<And>a xs.\n           set (extdown a xs) \\<subseteq> {a} \\<union> set xs\\<rbrakk>\n       \\<Longrightarrow> distinct (extup a [])\n 2. \\<And>a.\n       \\<lbrakk>distinct []; a \\<notin> set [];\n        \\<And>a xs. set (extup a xs) \\<subseteq> {a} \\<union> set xs;\n        \\<And>a xs.\n           set (extdown a xs) \\<subseteq> {a} \\<union> set xs\\<rbrakk>\n       \\<Longrightarrow> distinct (extdown a [])\n 3. \\<And>a xs aa.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>distinct xs; a \\<notin> set xs;\n                    \\<And>a xs.\n                       set (extup a xs) \\<subseteq> {a} \\<union> set xs;\n                    \\<And>a xs.\n                       set (extdown a xs)\n                       \\<subseteq> {a} \\<union> set xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (extup a xs);\n        \\<And>a.\n           \\<lbrakk>distinct xs; a \\<notin> set xs;\n            \\<And>a xs. set (extup a xs) \\<subseteq> {a} \\<union> set xs;\n            \\<And>a xs.\n               set (extdown a xs) \\<subseteq> {a} \\<union> set xs\\<rbrakk>\n           \\<Longrightarrow> distinct (extdown a xs);\n        distinct (a # xs); aa \\<notin> set (a # xs);\n        \\<And>a xs. set (extup a xs) \\<subseteq> {a} \\<union> set xs;\n        \\<And>a xs.\n           set (extdown a xs) \\<subseteq> {a} \\<union> set xs\\<rbrakk>\n       \\<Longrightarrow> distinct (extup aa (a # xs))\n 4. \\<And>a xs aa.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>distinct xs; a \\<notin> set xs;\n                    \\<And>a xs.\n                       set (extup a xs) \\<subseteq> {a} \\<union> set xs;\n                    \\<And>a xs.\n                       set (extdown a xs)\n                       \\<subseteq> {a} \\<union> set xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (extup a xs);\n        \\<And>a.\n           \\<lbrakk>distinct xs; a \\<notin> set xs;\n            \\<And>a xs. set (extup a xs) \\<subseteq> {a} \\<union> set xs;\n            \\<And>a xs.\n               set (extdown a xs) \\<subseteq> {a} \\<union> set xs\\<rbrakk>\n           \\<Longrightarrow> distinct (extdown a xs);\n        distinct (a # xs); aa \\<notin> set (a # xs);\n        \\<And>a xs. set (extup a xs) \\<subseteq> {a} \\<union> set xs;\n        \\<And>a xs.\n           set (extdown a xs) \\<subseteq> {a} \\<union> set xs\\<rbrakk>\n       \\<Longrightarrow> distinct (extdown aa (a # xs))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs aa.\n       \\<lbrakk>\\<And>a.\n                   a \\<notin> set xs \\<Longrightarrow>\n                   distinct (extup a xs);\n        \\<And>a.\n           a \\<notin> set xs \\<Longrightarrow> distinct (extdown a xs);\n        \\<And>a xs. set (extup a xs) \\<subseteq> insert a (set xs);\n        \\<And>a xs. set (extdown a xs) \\<subseteq> insert a (set xs);\n        a \\<notin> set xs; distinct xs; aa \\<notin> set xs;\n        \\<not> aa \\<le> a; aa \\<in> set (extdown a xs)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a xs aa.\n       \\<lbrakk>\\<And>a.\n                   a \\<notin> set xs \\<Longrightarrow>\n                   distinct (extup a xs);\n        \\<And>a.\n           a \\<notin> set xs \\<Longrightarrow> distinct (extdown a xs);\n        \\<And>a xs. set (extup a xs) \\<subseteq> insert a (set xs);\n        \\<And>a xs. set (extdown a xs) \\<subseteq> insert a (set xs);\n        a \\<notin> set xs; distinct xs; aa \\<notin> set xs;\n        \\<not> a \\<le> aa; aa \\<in> set (extup a xs)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis eq_iff insert_iff subset_iff)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"ldistinct xs \\<Longrightarrow> a \\<notin> lset xs \\<Longrightarrow> ldistinct (lextup a xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ldistinct xs; a \\<notin> lset xs\\<rbrakk>\n    \\<Longrightarrow> ldistinct (lextup a xs)", "by (rule_tac tendsto_closed[OF closed_ldistinct', OF isCont_lextup])\n     (force simp: lfinite_eq_range_llist_of intro!: distinct_ext dest: ldistinct_lprefix dest: lprefix_lsetD)+"], ["", "definition esum_list :: \"ereal llist \\<Rightarrow> ereal\" where\n  \"esum_list xs = Lim (at' xs) (sum_list \\<circ> list_of)\""], ["", "lemma esum_list_lfinite[simp]: \"lfinite xs \\<Longrightarrow> esum_list xs = sum_list (list_of xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> esum_list xs = sum_list (list_of xs)", "by (simp add: esum_list_def Lim_at'_lfinite)"], ["", "lemma esum_list_LNil: \"esum_list LNil = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esum_list LNil = 0", "by simp"], ["", "context\n  fixes xs :: \"ereal llist\"\n  assumes xs: \"\\<And>x. x \\<in> lset xs \\<Longrightarrow> 0 \\<le> x\"\nbegin"], ["", "lemma esum_list_tendsto_SUP:\n  \"((sum_list\\<circ>list_of) \\<longlongrightarrow> (SUP ys \\<in> {ys. lfinite ys \\<and> ys \\<le> xs}. esum_list ys)) (at' xs)\"\n    (is \"(_ \\<longlongrightarrow> ?y) _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((sum_list \\<circ> list_of) \\<longlongrightarrow>\n     \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs}))\n     (at' xs)", "proof (rule order_tendstoI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       a < \\<Squnion> (esum_list `\n                       {ys.\n                        lfinite ys \\<and> ys \\<le> xs}) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x\n 2. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       a < \\<Squnion> (esum_list `\n                       {ys.\n                        lfinite ys \\<and> ys \\<le> xs}) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x\n 2. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "assume \"a < ?y\""], ["proof (state)\nthis:\n  a < \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a < \\<Squnion> (esum_list `\n                       {ys.\n                        lfinite ys \\<and> ys \\<le> xs}) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x\n 2. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "then"], ["proof (chain)\npicking this:\n  a < \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})", "obtain ys where \"llist_of ys \\<le> xs\" \"a < sum_list ys\""], ["proof (prove)\nusing this:\n  a < \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>llist_of ys \\<le> xs; a < sum_list ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: less_SUP_iff lfinite_eq_range_llist_of)"], ["proof (state)\nthis:\n  llist_of ys \\<le> xs\n  a < sum_list ys\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a < \\<Squnion> (esum_list `\n                       {ys.\n                        lfinite ys \\<and> ys \\<le> xs}) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x\n 2. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "moreover"], ["proof (state)\nthis:\n  llist_of ys \\<le> xs\n  a < sum_list ys\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a < \\<Squnion> (esum_list `\n                       {ys.\n                        lfinite ys \\<and> ys \\<le> xs}) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x\n 2. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "{"], ["proof (state)\nthis:\n  llist_of ys \\<le> xs\n  a < sum_list ys\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a < \\<Squnion> (esum_list `\n                       {ys.\n                        lfinite ys \\<and> ys \\<le> xs}) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x\n 2. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "fix zs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       a < \\<Squnion> (esum_list `\n                       {ys.\n                        lfinite ys \\<and> ys \\<le> xs}) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x\n 2. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "assume \"ys \\<le> zs\" \"llist_of zs \\<le> xs\""], ["proof (state)\nthis:\n  ys \\<le> zs\n  llist_of zs \\<le> xs\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a < \\<Squnion> (esum_list `\n                       {ys.\n                        lfinite ys \\<and> ys \\<le> xs}) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x\n 2. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "then"], ["proof (chain)\npicking this:\n  ys \\<le> zs\n  llist_of zs \\<le> xs", "obtain ys' where zs: \"zs = ys @ ys'\""], ["proof (prove)\nusing this:\n  ys \\<le> zs\n  llist_of zs \\<le> xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys'. zs = ys @ ys' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: prefix_def less_eq_list_def)"], ["proof (state)\nthis:\n  zs = ys @ ys'\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a < \\<Squnion> (esum_list `\n                       {ys.\n                        lfinite ys \\<and> ys \\<le> xs}) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x\n 2. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "with \\<open>llist_of zs \\<le> xs\\<close>"], ["proof (chain)\npicking this:\n  llist_of zs \\<le> xs\n  zs = ys @ ys'", "have nonneg: \"0 \\<le> sum_list ys'\""], ["proof (prove)\nusing this:\n  llist_of zs \\<le> xs\n  zs = ys @ ys'\n\ngoal (1 subgoal):\n 1. 0 \\<le> sum_list ys'", "using xs"], ["proof (prove)\nusing this:\n  llist_of zs \\<le> xs\n  zs = ys @ ys'\n  ?x \\<in> lset xs \\<Longrightarrow> 0 \\<le> ?x\n\ngoal (1 subgoal):\n 1. 0 \\<le> sum_list ys'", "by (auto simp: lprefix_conv_lappend sum_list_sum_nth intro: sum_nonneg)"], ["proof (state)\nthis:\n  0 \\<le> sum_list ys'\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a < \\<Squnion> (esum_list `\n                       {ys.\n                        lfinite ys \\<and> ys \\<le> xs}) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x\n 2. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "note \\<open>a < sum_list ys\\<close>"], ["proof (state)\nthis:\n  a < sum_list ys\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a < \\<Squnion> (esum_list `\n                       {ys.\n                        lfinite ys \\<and> ys \\<le> xs}) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x\n 2. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "also"], ["proof (state)\nthis:\n  a < sum_list ys\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a < \\<Squnion> (esum_list `\n                       {ys.\n                        lfinite ys \\<and> ys \\<le> xs}) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x\n 2. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "have \"sum_list ys \\<le> sum_list zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list ys \\<le> sum_list zs", "using zs add_mono[OF order_refl nonneg]"], ["proof (prove)\nusing this:\n  zs = ys @ ys'\n  ?a + 0 \\<le> ?a + sum_list ys'\n\ngoal (1 subgoal):\n 1. sum_list ys \\<le> sum_list zs", "by auto"], ["proof (state)\nthis:\n  sum_list ys \\<le> sum_list zs\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a < \\<Squnion> (esum_list `\n                       {ys.\n                        lfinite ys \\<and> ys \\<le> xs}) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x\n 2. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "finally"], ["proof (chain)\npicking this:\n  a < sum_list zs", "have \"a < sum_list zs\""], ["proof (prove)\nusing this:\n  a < sum_list zs\n\ngoal (1 subgoal):\n 1. a < sum_list zs", "."], ["proof (state)\nthis:\n  a < sum_list zs\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a < \\<Squnion> (esum_list `\n                       {ys.\n                        lfinite ys \\<and> ys \\<le> xs}) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x\n 2. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "}"], ["proof (state)\nthis:\n  \\<lbrakk>ys \\<le> ?zs2; llist_of ?zs2 \\<le> xs\\<rbrakk>\n  \\<Longrightarrow> a < sum_list ?zs2\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a < \\<Squnion> (esum_list `\n                       {ys.\n                        lfinite ys \\<and> ys \\<le> xs}) \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x\n 2. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "ultimately"], ["proof (chain)\npicking this:\n  llist_of ys \\<le> xs\n  a < sum_list ys\n  \\<lbrakk>ys \\<le> ?zs2; llist_of ?zs2 \\<le> xs\\<rbrakk>\n  \\<Longrightarrow> a < sum_list ?zs2", "show \"eventually (\\<lambda>x. a < (sum_list\\<circ>list_of) x) (at' xs)\""], ["proof (prove)\nusing this:\n  llist_of ys \\<le> xs\n  a < sum_list ys\n  \\<lbrakk>ys \\<le> ?zs2; llist_of ?zs2 \\<le> xs\\<rbrakk>\n  \\<Longrightarrow> a < sum_list ?zs2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x", "unfolding eventually_at'_llist"], ["proof (prove)\nusing this:\n  llist_of ys \\<le> xs\n  a < sum_list ys\n  \\<lbrakk>ys \\<le> ?zs2; llist_of ?zs2 \\<le> xs\\<rbrakk>\n  \\<Longrightarrow> a < sum_list ?zs2\n\ngoal (1 subgoal):\n 1. \\<exists>xsa\\<le>xs.\n       lfinite xsa \\<and>\n       (\\<forall>ys\\<ge>xsa.\n           lfinite ys \\<longrightarrow>\n           ys \\<le> xs \\<longrightarrow> a < (sum_list \\<circ> list_of) ys)", "by (auto simp: lfinite_eq_range_llist_of)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at' xs. a < (sum_list \\<circ> list_of) x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "assume \"?y < a\""], ["proof (state)\nthis:\n  \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs}) < a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs})\n       < a \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "then"], ["proof (chain)\npicking this:\n  \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs}) < a", "show \"eventually (\\<lambda>x. (sum_list\\<circ>list_of) x < a) (at' xs)\""], ["proof (prove)\nusing this:\n  \\<Squnion> (esum_list ` {ys. lfinite ys \\<and> ys \\<le> xs}) < a\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a", "by (auto intro!: eventually_at'_llistI dest: SUP_lessD)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at' xs. (sum_list \\<circ> list_of) x < a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tendsto_esum_list: \"(esum_list \\<longlongrightarrow> esum_list xs) (at' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (esum_list \\<longlongrightarrow> esum_list xs) (at' xs)", "apply (rule filterlim_cong[where g=\"sum_list \\<circ> list_of\", THEN iffD2, OF refl refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at' xs.\n       esum_list x = (sum_list \\<circ> list_of) x\n 2. ((sum_list \\<circ> list_of) \\<longlongrightarrow> esum_list xs) (at' xs)", "apply (rule eventually_mono[OF eventually_lfinite])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       lfinite x \\<Longrightarrow>\n       esum_list x = (sum_list \\<circ> list_of) x\n 2. ((sum_list \\<circ> list_of) \\<longlongrightarrow> esum_list xs) (at' xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((sum_list \\<circ> list_of) \\<longlongrightarrow> esum_list xs) (at' xs)", "unfolding esum_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((sum_list \\<circ> list_of) \\<longlongrightarrow>\n     Lim (at' xs) (sum_list \\<circ> list_of))\n     (at' xs)", "apply (rule tendsto_LimI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((sum_list \\<circ> list_of) \\<longlongrightarrow> ?y10) (at' xs)", "apply (rule esum_list_tendsto_SUP)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma isCont_esum_list: \"isCont esum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont esum_list xs", "by (simp add: isCont_def filterlim_at'_list tendsto_esum_list)"], ["", "end"], ["", "lemma esum_list_nonneg:\n  \"(\\<And>x. x \\<in> lset xs \\<Longrightarrow> 0 \\<le> x) \\<Longrightarrow> 0 \\<le> esum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> lset xs \\<Longrightarrow> 0 \\<le> x) \\<Longrightarrow>\n    0 \\<le> esum_list xs", "by (rule tendsto_le[OF at'_bot tendsto_esum_list tendsto_const])\n     (auto intro!: eventually_at'_llistI sum_nonneg\n           simp: lprefix_conv_lappend sum_list_sum_nth lfinite_eq_range_llist_of)"], ["", "lemma esum_list_LCons:\n  assumes x: \"0 \\<le> x\" \"\\<And>x. x \\<in> lset xs \\<Longrightarrow> 0 \\<le> x\" shows \"esum_list (LCons x xs) = x + esum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esum_list (LCons x xs) = x + esum_list xs", "proof (rule tendsto_unique_eventually[OF at'_bot])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F x in at' ?x1. ?f x = ?g x\n 2. (?f \\<longlongrightarrow> esum_list (LCons x xs)) (at' ?x1)\n 3. (?g \\<longlongrightarrow> x + esum_list xs) (at' ?x1)", "from x"], ["proof (chain)\npicking this:\n  0 \\<le> x\n  ?x \\<in> lset xs \\<Longrightarrow> 0 \\<le> ?x", "show \"((\\<lambda>xs. esum_list (LCons x xs)) \\<longlongrightarrow> esum_list (LCons x xs)) (at' xs)\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n  ?x \\<in> lset xs \\<Longrightarrow> 0 \\<le> ?x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>xs. esum_list (LCons x xs)) \\<longlongrightarrow>\n     esum_list (LCons x xs))\n     (at' xs)", "by (intro tendsto_compose[OF filterlim_at'_list[OF tendsto_esum_list] tendsto_LCons]) auto"], ["proof (state)\nthis:\n  ((\\<lambda>xs. esum_list (LCons x xs)) \\<longlongrightarrow>\n   esum_list (LCons x xs))\n   (at' xs)\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F xa in at' xs. esum_list (LCons x xa) = ?g xa\n 2. (?g \\<longlongrightarrow> x + esum_list xs) (at' xs)", "show \"eventually (\\<lambda>xa. esum_list (LCons x xa) = x + esum_list xa) (at' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F xa in at' xs.\n       esum_list (LCons x xa) = x + esum_list xa", "using eventually_lfinite"], ["proof (prove)\nusing this:\n  eventually lfinite (at' ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F xa in at' xs.\n       esum_list (LCons x xa) = x + esum_list xa", "by eventually_elim simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F xa in at' xs. esum_list (LCons x xa) = x + esum_list xa\n\ngoal (1 subgoal):\n 1. ((\\<lambda>xa. x + esum_list xa) \\<longlongrightarrow> x + esum_list xs)\n     (at' xs)", "from x"], ["proof (chain)\npicking this:\n  0 \\<le> x\n  ?x \\<in> lset xs \\<Longrightarrow> 0 \\<le> ?x", "show \"((\\<lambda>xa. x + esum_list xa) \\<longlongrightarrow> x + esum_list xs) (at' xs)\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n  ?x \\<in> lset xs \\<Longrightarrow> 0 \\<le> ?x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>xa. x + esum_list xa) \\<longlongrightarrow> x + esum_list xs)\n     (at' xs)", "by (intro esum_list_nonneg tendsto_esum_list tendsto_add_ereal) auto"], ["proof (state)\nthis:\n  ((\\<lambda>xa. x + esum_list xa) \\<longlongrightarrow> x + esum_list xs)\n   (at' xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma esum_list_lfilter':\n  assumes nn: \"\\<And>x. x \\<in> lset xs \\<Longrightarrow> 0 \\<le> x\" shows \"esum_list (lfilter' (\\<lambda>x. x \\<noteq> 0) xs) = esum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esum_list (lfilter' (\\<lambda>x. x \\<noteq> 0) xs) = esum_list xs", "proof (rule tendsto_unique_eventually[OF at'_bot])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F x in at' ?x1. ?f x = ?g x\n 2. (?f \\<longlongrightarrow>\n     esum_list (lfilter' (\\<lambda>x. x \\<noteq> 0) xs))\n     (at' ?x1)\n 3. (?g \\<longlongrightarrow> esum_list xs) (at' ?x1)", "show \"(esum_list \\<longlongrightarrow> esum_list xs) (at' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (esum_list \\<longlongrightarrow> esum_list xs) (at' xs)", "using nn"], ["proof (prove)\nusing this:\n  ?x \\<in> lset xs \\<Longrightarrow> 0 \\<le> ?x\n\ngoal (1 subgoal):\n 1. (esum_list \\<longlongrightarrow> esum_list xs) (at' xs)", "by (rule tendsto_esum_list)"], ["proof (state)\nthis:\n  (esum_list \\<longlongrightarrow> esum_list xs) (at' xs)\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at' xs. ?f x = esum_list x\n 2. (?f \\<longlongrightarrow>\n     esum_list (lfilter' (\\<lambda>x. x \\<noteq> 0) xs))\n     (at' xs)", "from nn"], ["proof (chain)\npicking this:\n  ?x \\<in> lset xs \\<Longrightarrow> 0 \\<le> ?x", "show \"((\\<lambda>xs. esum_list (lfilter' (\\<lambda>x. x \\<noteq> 0) xs)) \\<longlongrightarrow> esum_list (lfilter' (\\<lambda>x. x \\<noteq> 0) xs)) (at' xs)\""], ["proof (prove)\nusing this:\n  ?x \\<in> lset xs \\<Longrightarrow> 0 \\<le> ?x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>xs.\n         esum_list\n          (lfilter' (\\<lambda>x. x \\<noteq> 0) xs)) \\<longlongrightarrow>\n     esum_list (lfilter' (\\<lambda>x. x \\<noteq> 0) xs))\n     (at' xs)", "by (intro tendsto_compose[OF filterlim_at'_list[OF tendsto_esum_list] tendsto_lfilter]) (auto simp: lset_lfilter')"], ["proof (state)\nthis:\n  ((\\<lambda>xs.\n       esum_list\n        (lfilter' (\\<lambda>x. x \\<noteq> 0) xs)) \\<longlongrightarrow>\n   esum_list (lfilter' (\\<lambda>x. x \\<noteq> 0) xs))\n   (at' xs)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at' xs.\n       esum_list (lfilter' (\\<lambda>x. x \\<noteq> 0) x) = esum_list x", "show \"eventually (\\<lambda>xs. esum_list (lfilter' (\\<lambda>x. x \\<noteq> 0) xs) = esum_list xs) (at' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F xs in at' xs.\n       esum_list (lfilter' (\\<lambda>x. x \\<noteq> 0) xs) = esum_list xs", "using eventually_lfinite"], ["proof (prove)\nusing this:\n  eventually lfinite (at' ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F xs in at' xs.\n       esum_list (lfilter' (\\<lambda>x. x \\<noteq> 0) xs) = esum_list xs", "by eventually_elim (simp add: sum_list_map_filter[where f = \"\\<lambda>x. x\" and P=\"\\<lambda>x. x \\<noteq> 0\", simplified])"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F xs in at' xs.\n     esum_list (lfilter' (\\<lambda>x. x \\<noteq> 0) xs) = esum_list xs\n\ngoal:\nNo subgoals!", "qed"], ["", "function f:: \"nat list \\<Rightarrow> nat list\" where\n  \"f [] = []\"\n| \"f (x#xs) = (x * 2) # f (f xs)\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = [] \\<Longrightarrow> P;\n        \\<And>xa xs. x = xa # xs \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. [] = [] \\<Longrightarrow> [] = []\n 3. \\<And>x xs.\n       [] = x # xs \\<Longrightarrow> [] = x * 2 # f_sumC (f_sumC xs)\n 4. \\<And>x xs xa xsa.\n       x # xs = xa # xsa \\<Longrightarrow>\n       x * 2 # f_sumC (f_sumC xs) = xa * 2 # f_sumC (f_sumC xsa)", "by auto pat_completeness"], ["", "termination f"], ["proof (prove)\ngoal (1 subgoal):\n 1. All f_dom", "proof (relation \"inv_image natLess length\")"], ["proof (state)\ngoal (3 subgoals):\n 1. wf (inv_image natLess length)\n 2. \\<And>x xs. (xs, x # xs) \\<in> inv_image natLess length\n 3. \\<And>x xs.\n       f_dom xs \\<Longrightarrow>\n       (f xs, x # xs) \\<in> inv_image natLess length", "fix x xs"], ["proof (state)\ngoal (3 subgoals):\n 1. wf (inv_image natLess length)\n 2. \\<And>x xs. (xs, x # xs) \\<in> inv_image natLess length\n 3. \\<And>x xs.\n       f_dom xs \\<Longrightarrow>\n       (f xs, x # xs) \\<in> inv_image natLess length", "assume \"f_dom xs\""], ["proof (state)\nthis:\n  f_dom xs\n\ngoal (3 subgoals):\n 1. wf (inv_image natLess length)\n 2. \\<And>x xs. (xs, x # xs) \\<in> inv_image natLess length\n 3. \\<And>x xs.\n       f_dom xs \\<Longrightarrow>\n       (f xs, x # xs) \\<in> inv_image natLess length", "then"], ["proof (chain)\npicking this:\n  f_dom xs", "show \"(f xs, x # xs) \\<in> inv_image natLess length\""], ["proof (prove)\nusing this:\n  f_dom xs\n\ngoal (1 subgoal):\n 1. (f xs, x # xs) \\<in> inv_image natLess length", "by induct (auto simp: f.psimps natLess_def)"], ["proof (state)\nthis:\n  (f xs, x # xs) \\<in> inv_image natLess length\n\ngoal (2 subgoals):\n 1. wf (inv_image natLess length)\n 2. \\<And>x xs. (xs, x # xs) \\<in> inv_image natLess length", "qed (auto intro: wf_less simp add: natLess_def)"], ["", "lemma length_f[simp]: \"length (f xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (f xs) = length xs", "by (induct rule: f.induct) simp_all"], ["", "lemma f_mono': \"\\<exists>ys'. f (xs @ ys) = f xs @ ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys'. f (xs @ ys) = f xs @ ys'", "proof (induct \"length xs\" arbitrary: xs ys rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       (\\<And>xsa ys.\n           length xsa < length xs \\<Longrightarrow>\n           \\<exists>ys'. f (xsa @ ys) = f xsa @ ys') \\<Longrightarrow>\n       \\<exists>ys'. f (xs @ ys) = f xs @ ys'", "case less"], ["proof (state)\nthis:\n  length ?xs < length xs \\<Longrightarrow>\n  \\<exists>ys'. f (?xs @ ?ys) = f ?xs @ ys'\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       (\\<And>xsa ys.\n           length xsa < length xs \\<Longrightarrow>\n           \\<exists>ys'. f (xsa @ ys) = f xsa @ ys') \\<Longrightarrow>\n       \\<exists>ys'. f (xs @ ys) = f xs @ ys'", "then"], ["proof (chain)\npicking this:\n  length ?xs < length xs \\<Longrightarrow>\n  \\<exists>ys'. f (?xs @ ?ys) = f ?xs @ ys'", "show ?case"], ["proof (prove)\nusing this:\n  length ?xs < length xs \\<Longrightarrow>\n  \\<exists>ys'. f (?xs @ ?ys) = f ?xs @ ys'\n\ngoal (1 subgoal):\n 1. \\<exists>ys'. f (xs @ ys) = f xs @ ys'", "apply (cases xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs ys.\n                length xs < length xs \\<Longrightarrow>\n                \\<exists>ys'. f (xs @ ys) = f xs @ ys';\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys'. f (xs @ ys) = f xs @ ys'\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>xs ys.\n                   length xs < length xs \\<Longrightarrow>\n                   \\<exists>ys'. f (xs @ ys) = f xs @ ys';\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys'. f (xs @ ys) = f xs @ ys'", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>xs ys.\n                   length xs < Suc (length list) \\<Longrightarrow>\n                   \\<exists>ys'. f (xs @ ys) = f xs @ ys';\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys'. f (f (list @ ys)) = f (f list) @ ys'", "apply (metis length_f lessI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>ys'. f (xs @ ys) = f xs @ ys'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma f_mono: \"xs \\<le> ys \\<Longrightarrow> f xs \\<le> f ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<le> ys \\<Longrightarrow> f xs \\<le> f ys", "by (auto simp: less_eq_list_def prefix_def f_mono')"], ["", "definition \"f' l = Lim (at' l) (\\<lambda>l. llist_of (f (list_of l)))\""], ["", "lemma f'_lfinite[simp]: \"lfinite xs \\<Longrightarrow> f' xs = llist_of (f (list_of xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> f' xs = llist_of (f (list_of xs))", "by (simp add: f'_def Lim_at'_lfinite)"], ["", "lemma tendsto_f': \"(f' \\<longlongrightarrow> f' l) (at' l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f' \\<longlongrightarrow> f' l) (at' l)", "by (rule tendsto_Lim_at'[OF f'_def]) (auto simp add: lfinite_eq_range_llist_of intro!: f_mono)"], ["", "lemma isCont_f'[THEN isCont_o2[rotated]]: \"isCont f' l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont f' l", "by (simp add: isCont_def filterlim_at'_list tendsto_f')"], ["", "lemma \"f' LNil = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' LNil = LNil", "by simp"], ["", "lemma \"f' (LCons x xs) = LCons (x * 2) (f' (f' xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' (LCons x xs) = LCons (x * 2) (f' (f' xs))", "by (rule tendsto_closed[where x=xs, OF closed_Collect_eq_isCont])\n     (auto intro!: isCont_f' isCont_LCons)"], ["", "end"]]}