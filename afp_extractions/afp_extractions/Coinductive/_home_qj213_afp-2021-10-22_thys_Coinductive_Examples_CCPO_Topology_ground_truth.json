{"file_name": "/home/qj213/afp-2021-10-22/thys/Coinductive/Examples/CCPO_Topology.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Coinductive", "problem_names": ["lemma dropWhile_append:\n  \"dropWhile P (xs @ ys) = (if \\<forall>x\\<in>set xs. P x then dropWhile P ys else dropWhile P xs @ ys)\"", "lemma dropWhile_False: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> P x) \\<Longrightarrow> dropWhile P xs = []\"", "lemma (in linorder) chain_linorder: \"chain C\"", "lemma continuous_add_ereal:\n  assumes \"0 \\<le> t\"\n  shows \"continuous_on {-\\<infinity>::ereal <..} (\\<lambda>x. t + x)\"", "lemma tendsto_add_ereal:\n  \"0 \\<le> x \\<Longrightarrow> 0 \\<le> y \\<Longrightarrow> (f \\<longlongrightarrow> y) F \\<Longrightarrow> ((\\<lambda>z. x + f z :: ereal) \\<longlongrightarrow> x + y) F\"", "lemma tendsto_LimI: \"(f \\<longlongrightarrow> y) F \\<Longrightarrow> (f \\<longlongrightarrow> Lim F f) F\"", "lemma tendsto_unique_eventually:\n  fixes x x' :: \"'a :: t2_space\"\n  shows \"F \\<noteq> bot \\<Longrightarrow> eventually (\\<lambda>x. f x = g x) F \\<Longrightarrow> (f \\<longlongrightarrow> x) F \\<Longrightarrow> (g \\<longlongrightarrow> x') F \\<Longrightarrow> x = x'\"", "lemma (in ccpo) ccpo_Sup_upper2: \"chain C \\<Longrightarrow> x \\<in> C \\<Longrightarrow> y \\<le> x \\<Longrightarrow> y \\<le> Sup C\"", "lemma tendsto_open_vimage: \"(\\<And>B. open B \\<Longrightarrow> open (f -` B)) \\<Longrightarrow> f \\<midarrow>l\\<rightarrow> f l\"", "lemma open_vimageI: \"(\\<And>x. f \\<midarrow>x\\<rightarrow> f x) \\<Longrightarrow> open A \\<Longrightarrow> open (f -` A)\"", "lemma principal_bot: \"principal x = bot \\<longleftrightarrow> x = {}\"", "lemma at'_bot: \"at' x \\<noteq> bot\"", "lemma tendsto_id_at'[simp, intro]: \"((\\<lambda>x. x) \\<longlongrightarrow> x) (at' x)\"", "lemma cont_at': \"(f \\<longlongrightarrow> f x) (at' x) \\<longleftrightarrow> f \\<midarrow>x\\<rightarrow> f x\"", "lemma open_ccpoD:\n  assumes \"open A\" \"chain C\" \"C \\<noteq> {}\" \"Sup C \\<in> A\"\n  shows \"\\<exists>c\\<in>C. \\<forall>c'\\<in>C. c \\<le> c' \\<longrightarrow> c' \\<in> A\"", "lemma open_ccpo_Iic: \"open {.. b}\"", "lemma closed_ccpo: \"closed A \\<longleftrightarrow> (\\<forall>C. chain C \\<longrightarrow> C \\<noteq> {} \\<longrightarrow> C \\<subseteq> A \\<longrightarrow> Sup C \\<in> A)\"", "lemma closed_admissible: \"closed {x. P x} \\<longleftrightarrow> ccpo.admissible Sup (\\<le>) P\"", "lemma open_singletonI_compact: \"compact_element x \\<Longrightarrow> open {x}\"", "lemma closed_Ici: \"closed {.. b}\"", "lemma closed_Iic: \"closed {b ..}\"", "lemma tendsto_le_ccpo:\n  fixes f g :: \"'a \\<Rightarrow> 'b::ccpo_topology\"\n  assumes F: \"\\<not> trivial_limit F\"\n  assumes x: \"(f \\<longlongrightarrow> x) F\" and y: \"(g \\<longlongrightarrow> y) F\"\n  assumes ev: \"eventually (\\<lambda>x. g x \\<le> f x) F\"\n  shows \"y \\<le> x\"", "lemma tendsto_ccpoI:\n  fixes f :: \"'a::ccpo_topology \\<Rightarrow> 'b::ccpo_topology\"\n  shows \"(\\<And>C. chain C \\<Longrightarrow> C \\<noteq> {} \\<Longrightarrow> chain (f ` C) \\<and> f (Sup C) = Sup (f`C)) \\<Longrightarrow> f \\<midarrow>x\\<rightarrow> f x\"", "lemma tendsto_mcont:\n  assumes mcont: \"mcont Sup (\\<le>) Sup (\\<le>) (f :: 'a :: ccpo_topology \\<Rightarrow> 'b :: ccpo_topology)\"\n  shows \"f \\<midarrow>l\\<rightarrow> f l\"", "lemmas tendsto_inf2[THEN tendsto_compose, tendsto_intros] =\n  tendsto_mcont[OF mcont_inf2]", "lemma isCont_inf2[THEN isCont_o2[rotated]]:\n  \"isCont (\\<lambda>x. x \\<sqinter> y) (z :: _ :: {ccpo_topology, complete_distrib_lattice})\"", "lemmas tendsto_sup1[THEN tendsto_compose, tendsto_intros] =\n  tendsto_mcont[OF mcont_sup1]", "lemma isCont_If: \"isCont f x \\<Longrightarrow> isCont g x \\<Longrightarrow> isCont (\\<lambda>x. if Q then f x else g x) x\"", "lemma isCont_enat_case: \"isCont (f (epred n)) x \\<Longrightarrow> isCont g x \\<Longrightarrow> isCont (\\<lambda>x. co.case_enat (g x) (\\<lambda>n. f n x) n) x\""], "translations": [["", "lemma dropWhile_append:\n  \"dropWhile P (xs @ ys) = (if \\<forall>x\\<in>set xs. P x then dropWhile P ys else dropWhile P xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dropWhile P (xs @ ys) =\n    (if \\<forall>x\\<in>set xs. P x then dropWhile P ys\n     else dropWhile P xs @ ys)", "by auto"], ["", "lemma dropWhile_False: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> P x) \\<Longrightarrow> dropWhile P xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> set xs \\<Longrightarrow> P x) \\<Longrightarrow>\n    dropWhile P xs = []", "by simp"], ["", "abbreviation (in order) \"chain \\<equiv> Complete_Partial_Order.chain (\\<le>)\""], ["", "lemma (in linorder) chain_linorder: \"chain C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain C", "by (simp add: chain_def linear)"], ["", "lemma continuous_add_ereal:\n  assumes \"0 \\<le> t\"\n  shows \"continuous_on {-\\<infinity>::ereal <..} (\\<lambda>x. t + x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {- \\<infinity><..} ((+) t)", "proof (subst continuous_on_open_vimage, (intro open_greaterThan allI impI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B.\n       open B \\<Longrightarrow>\n       open ((+) t -` B \\<inter> {- \\<infinity><..})", "fix B :: \"ereal set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B.\n       open B \\<Longrightarrow>\n       open ((+) t -` B \\<inter> {- \\<infinity><..})", "assume \"open B\""], ["proof (state)\nthis:\n  open B\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       open B \\<Longrightarrow>\n       open ((+) t -` B \\<inter> {- \\<infinity><..})", "show \"open ((\\<lambda>x. t + x) -` B \\<inter> {- \\<infinity><..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open ((+) t -` B \\<inter> {- \\<infinity><..})", "proof (cases t)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>r.\n       t = ereal r \\<Longrightarrow>\n       open ((+) t -` B \\<inter> {- \\<infinity><..})\n 2. t = \\<infinity> \\<Longrightarrow>\n    open ((+) t -` B \\<inter> {- \\<infinity><..})\n 3. t = - \\<infinity> \\<Longrightarrow>\n    open ((+) t -` B \\<inter> {- \\<infinity><..})", "case (real t')"], ["proof (state)\nthis:\n  t = ereal t'\n\ngoal (3 subgoals):\n 1. \\<And>r.\n       t = ereal r \\<Longrightarrow>\n       open ((+) t -` B \\<inter> {- \\<infinity><..})\n 2. t = \\<infinity> \\<Longrightarrow>\n    open ((+) t -` B \\<inter> {- \\<infinity><..})\n 3. t = - \\<infinity> \\<Longrightarrow>\n    open ((+) t -` B \\<inter> {- \\<infinity><..})", "then"], ["proof (chain)\npicking this:\n  t = ereal t'", "have *: \"(\\<lambda>x. t + x) -` B \\<inter> {- \\<infinity><..} = (\\<lambda>x. 1 * x + (-t)) ` (B \\<inter> {-\\<infinity> <..})\""], ["proof (prove)\nusing this:\n  t = ereal t'\n\ngoal (1 subgoal):\n 1. (+) t -` B \\<inter> {- \\<infinity><..} =\n    (\\<lambda>x. 1 * x + - t) ` (B \\<inter> {- \\<infinity><..})", "apply (simp add: set_eq_iff image_iff Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. t = ereal t' \\<Longrightarrow>\n    \\<forall>x.\n       (ereal t' + x \\<in> B \\<and> x \\<noteq> - \\<infinity>) =\n       (\\<exists>xa.\n           xa \\<in> B \\<and>\n           xa \\<noteq> - \\<infinity> \\<and> x = xa + ereal (- t'))", "apply (intro allI iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>t = ereal t';\n        ereal t' + x \\<in> B \\<and> x \\<noteq> - \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> B \\<and>\n                            xa \\<noteq> - \\<infinity> \\<and>\n                            x = xa + ereal (- t')\n 2. \\<And>x.\n       \\<lbrakk>t = ereal t';\n        \\<exists>xa.\n           xa \\<in> B \\<and>\n           xa \\<noteq> - \\<infinity> \\<and> x = xa + ereal (- t')\\<rbrakk>\n       \\<Longrightarrow> ereal t' + x \\<in> B \\<and>\n                         x \\<noteq> - \\<infinity>", "apply (rule_tac x= \"x + ereal t'\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>t = ereal t';\n        ereal t' + x \\<in> B \\<and> x \\<noteq> - \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> x + ereal t' \\<in> B \\<and>\n                         x + ereal t' \\<noteq> - \\<infinity> \\<and>\n                         x = x + ereal t' + ereal (- t')\n 2. \\<And>x.\n       \\<lbrakk>t = ereal t';\n        \\<exists>xa.\n           xa \\<in> B \\<and>\n           xa \\<noteq> - \\<infinity> \\<and> x = xa + ereal (- t')\\<rbrakk>\n       \\<Longrightarrow> ereal t' + x \\<in> B \\<and>\n                         x \\<noteq> - \\<infinity>", "apply (case_tac x)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x r.\n       \\<lbrakk>t = ereal t';\n        ereal t' + x \\<in> B \\<and> x \\<noteq> - \\<infinity>;\n        x = ereal r\\<rbrakk>\n       \\<Longrightarrow> x + ereal t' \\<in> B \\<and>\n                         x + ereal t' \\<noteq> - \\<infinity> \\<and>\n                         x = x + ereal t' + ereal (- t')\n 2. \\<And>x.\n       \\<lbrakk>t = ereal t';\n        ereal t' + x \\<in> B \\<and> x \\<noteq> - \\<infinity>;\n        x = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> x + ereal t' \\<in> B \\<and>\n                         x + ereal t' \\<noteq> - \\<infinity> \\<and>\n                         x = x + ereal t' + ereal (- t')\n 3. \\<And>x.\n       \\<lbrakk>t = ereal t';\n        ereal t' + x \\<in> B \\<and> x \\<noteq> - \\<infinity>;\n        x = - \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> x + ereal t' \\<in> B \\<and>\n                         x + ereal t' \\<noteq> - \\<infinity> \\<and>\n                         x = x + ereal t' + ereal (- t')\n 4. \\<And>x.\n       \\<lbrakk>t = ereal t';\n        \\<exists>xa.\n           xa \\<in> B \\<and>\n           xa \\<noteq> - \\<infinity> \\<and> x = xa + ereal (- t')\\<rbrakk>\n       \\<Longrightarrow> ereal t' + x \\<in> B \\<and>\n                         x \\<noteq> - \\<infinity>", "apply (auto simp: ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (+) t -` B \\<inter> {- \\<infinity><..} =\n  (\\<lambda>x. 1 * x + - t) ` (B \\<inter> {- \\<infinity><..})\n\ngoal (3 subgoals):\n 1. \\<And>r.\n       t = ereal r \\<Longrightarrow>\n       open ((+) t -` B \\<inter> {- \\<infinity><..})\n 2. t = \\<infinity> \\<Longrightarrow>\n    open ((+) t -` B \\<inter> {- \\<infinity><..})\n 3. t = - \\<infinity> \\<Longrightarrow>\n    open ((+) t -` B \\<inter> {- \\<infinity><..})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. open ((+) t -` B \\<inter> {- \\<infinity><..})", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. open ((\\<lambda>x. 1 * x + - t) ` (B \\<inter> {- \\<infinity><..}))", "apply (rule ereal_open_affinity_pos)"], ["proof (prove)\ngoal (4 subgoals):\n 1. open (B \\<inter> {- \\<infinity><..})\n 2. 1 \\<noteq> \\<infinity>\n 3. 0 < 1\n 4. \\<bar>- t\\<bar> \\<noteq> \\<infinity>", "using \\<open>open B\\<close>"], ["proof (prove)\nusing this:\n  open B\n\ngoal (4 subgoals):\n 1. open (B \\<inter> {- \\<infinity><..})\n 2. 1 \\<noteq> \\<infinity>\n 3. 0 < 1\n 4. \\<bar>- t\\<bar> \\<noteq> \\<infinity>", "apply (auto simp: real)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  open ((+) t -` B \\<inter> {- \\<infinity><..})\n\ngoal (2 subgoals):\n 1. t = \\<infinity> \\<Longrightarrow>\n    open ((+) t -` B \\<inter> {- \\<infinity><..})\n 2. t = - \\<infinity> \\<Longrightarrow>\n    open ((+) t -` B \\<inter> {- \\<infinity><..})", "qed (insert \\<open>0 \\<le> t\\<close>, auto)"], ["proof (state)\nthis:\n  open ((+) t -` B \\<inter> {- \\<infinity><..})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tendsto_add_ereal:\n  \"0 \\<le> x \\<Longrightarrow> 0 \\<le> y \\<Longrightarrow> (f \\<longlongrightarrow> y) F \\<Longrightarrow> ((\\<lambda>z. x + f z :: ereal) \\<longlongrightarrow> x + y) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> y; (f \\<longlongrightarrow> y) F\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>z. x + f z) \\<longlongrightarrow> x + y) F", "apply (rule tendsto_compose[where f=f])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> y; (f \\<longlongrightarrow> y) F\\<rbrakk>\n    \\<Longrightarrow> (+) x \\<midarrow>y\\<rightarrow> x + y\n 2. \\<lbrakk>0 \\<le> x; 0 \\<le> y; (f \\<longlongrightarrow> y) F\\<rbrakk>\n    \\<Longrightarrow> (f \\<longlongrightarrow> y) F", "using continuous_add_ereal[where t=x]"], ["proof (prove)\nusing this:\n  0 \\<le> x \\<Longrightarrow> continuous_on {- \\<infinity><..} ((+) x)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> y; (f \\<longlongrightarrow> y) F\\<rbrakk>\n    \\<Longrightarrow> (+) x \\<midarrow>y\\<rightarrow> x + y\n 2. \\<lbrakk>0 \\<le> x; 0 \\<le> y; (f \\<longlongrightarrow> y) F\\<rbrakk>\n    \\<Longrightarrow> (f \\<longlongrightarrow> y) F", "unfolding continuous_on_def"], ["proof (prove)\nusing this:\n  0 \\<le> x \\<Longrightarrow>\n  \\<forall>xa\\<in>{- \\<infinity><..}.\n     ((+) x \\<longlongrightarrow> x + xa) (at xa within {- \\<infinity><..})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> y; (f \\<longlongrightarrow> y) F\\<rbrakk>\n    \\<Longrightarrow> (+) x \\<midarrow>y\\<rightarrow> x + y\n 2. \\<lbrakk>0 \\<le> x; 0 \\<le> y; (f \\<longlongrightarrow> y) F\\<rbrakk>\n    \\<Longrightarrow> (f \\<longlongrightarrow> y) F", "apply (auto simp add: at_within_open[where S=\"{- \\<infinity> <..}\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tendsto_LimI: \"(f \\<longlongrightarrow> y) F \\<Longrightarrow> (f \\<longlongrightarrow> Lim F f) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> y) F \\<Longrightarrow>\n    (f \\<longlongrightarrow> Lim F f) F", "by (metis tendsto_Lim tendsto_bot)"], ["", "subsection \\<open>The filter \\<open>at'\\<close>\\<close>"], ["", "abbreviation (in ccpo) \"compact_element \\<equiv> ccpo.compact Sup (\\<le>)\""], ["", "lemma tendsto_unique_eventually:\n  fixes x x' :: \"'a :: t2_space\"\n  shows \"F \\<noteq> bot \\<Longrightarrow> eventually (\\<lambda>x. f x = g x) F \\<Longrightarrow> (f \\<longlongrightarrow> x) F \\<Longrightarrow> (g \\<longlongrightarrow> x') F \\<Longrightarrow> x = x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>F \\<noteq> \\<bottom>; \\<forall>\\<^sub>F x in F. f x = g x;\n     (f \\<longlongrightarrow> x) F; (g \\<longlongrightarrow> x') F\\<rbrakk>\n    \\<Longrightarrow> x = x'", "by (metis tendsto_unique filterlim_cong)"], ["", "lemma (in ccpo) ccpo_Sup_upper2: \"chain C \\<Longrightarrow> x \\<in> C \\<Longrightarrow> y \\<le> x \\<Longrightarrow> y \\<le> Sup C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chain C; x \\<in> C; y \\<le> x\\<rbrakk>\n    \\<Longrightarrow> y \\<le> \\<Squnion> C", "by (blast intro: ccpo_Sup_upper order_trans)"], ["", "lemma tendsto_open_vimage: \"(\\<And>B. open B \\<Longrightarrow> open (f -` B)) \\<Longrightarrow> f \\<midarrow>l\\<rightarrow> f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B. open B \\<Longrightarrow> open (f -` B)) \\<Longrightarrow>\n    f \\<midarrow>l\\<rightarrow> f l", "using continuous_on_open_vimage[of UNIV f] continuous_on_def[of UNIV f]"], ["proof (prove)\nusing this:\n  open UNIV \\<Longrightarrow>\n  continuous_on UNIV f =\n  (\\<forall>B. open B \\<longrightarrow> open (f -` B \\<inter> UNIV))\n  continuous_on UNIV f =\n  (\\<forall>x\\<in>UNIV. f \\<midarrow>x\\<rightarrow> f x)\n\ngoal (1 subgoal):\n 1. (\\<And>B. open B \\<Longrightarrow> open (f -` B)) \\<Longrightarrow>\n    f \\<midarrow>l\\<rightarrow> f l", "by simp"], ["", "lemma open_vimageI: \"(\\<And>x. f \\<midarrow>x\\<rightarrow> f x) \\<Longrightarrow> open A \\<Longrightarrow> open (f -` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. f \\<midarrow>x\\<rightarrow> f x; open A\\<rbrakk>\n    \\<Longrightarrow> open (f -` A)", "using continuous_on_open_vimage[of UNIV f] continuous_on_def[of UNIV f]"], ["proof (prove)\nusing this:\n  open UNIV \\<Longrightarrow>\n  continuous_on UNIV f =\n  (\\<forall>B. open B \\<longrightarrow> open (f -` B \\<inter> UNIV))\n  continuous_on UNIV f =\n  (\\<forall>x\\<in>UNIV. f \\<midarrow>x\\<rightarrow> f x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. f \\<midarrow>x\\<rightarrow> f x; open A\\<rbrakk>\n    \\<Longrightarrow> open (f -` A)", "by simp"], ["", "lemma principal_bot: \"principal x = bot \\<longleftrightarrow> x = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (principal x = \\<bottom>) = (x = {})", "by (auto simp: filter_eq_iff eventually_principal)"], ["", "definition \"at' x = (if open {x} then principal {x} else at x)\""], ["", "lemma at'_bot: \"at' x \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. at' x \\<noteq> \\<bottom>", "by (simp add: at'_def at_eq_bot_iff principal_bot)"], ["", "lemma tendsto_id_at'[simp, intro]: \"((\\<lambda>x. x) \\<longlongrightarrow> x) (at' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x) \\<longlongrightarrow> x) (at' x)", "by (simp add: at'_def topological_tendstoI eventually_principal tendsto_ident_at)"], ["", "lemma cont_at': \"(f \\<longlongrightarrow> f x) (at' x) \\<longleftrightarrow> f \\<midarrow>x\\<rightarrow> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f x) (at' x) = f \\<midarrow>x\\<rightarrow> f x", "using at_eq_bot_iff[of x]"], ["proof (prove)\nusing this:\n  (at x = \\<bottom>) = open {x}\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f x) (at' x) = f \\<midarrow>x\\<rightarrow> f x", "by (auto split: if_split_asm intro!: topological_tendstoI simp: eventually_principal at'_def)"], ["", "subsection \\<open>The type class \\<open>ccpo_topology\\<close>\\<close>"], ["", "text \\<open>Temporarily relax type constraints for @{term \"open\"}.\\<close>"], ["", "setup \\<open>Sign.add_const_constraint\n  (@{const_name \"open\"}, SOME @{typ \"'a::open set \\<Rightarrow> bool\"})\\<close>"], ["", "class ccpo_topology = \"open\" + ccpo +\n  assumes open_ccpo: \"open A \\<longleftrightarrow> (\\<forall>C. chain C \\<longrightarrow> C \\<noteq> {} \\<longrightarrow> Sup C \\<in> A \\<longrightarrow> C \\<inter> A \\<noteq> {})\"\nbegin"], ["", "lemma open_ccpoD:\n  assumes \"open A\" \"chain C\" \"C \\<noteq> {}\" \"Sup C \\<in> A\"\n  shows \"\\<exists>c\\<in>C. \\<forall>c'\\<in>C. c \\<le> c' \\<longrightarrow> c' \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>C.\n       \\<forall>c'\\<in>C. c \\<le> c' \\<longrightarrow> c' \\<in> A", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>c\\<in>C.\n               \\<forall>c'\\<in>C.\n                  c \\<le> c' \\<longrightarrow> c' \\<in> A) \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>c\\<in>C.\n             \\<forall>c'\\<in>C. c \\<le> c' \\<longrightarrow> c' \\<in> A)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>c\\<in>C.\n               \\<forall>c'\\<in>C.\n                  c \\<le> c' \\<longrightarrow> c' \\<in> A) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>c\\<in>C.\n             \\<forall>c'\\<in>C. c \\<le> c' \\<longrightarrow> c' \\<in> A)", "have *: \"\\<And>c. c \\<in> C \\<Longrightarrow> \\<exists>c'\\<in>C. c \\<le> c' \\<and> c' \\<notin> A\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>c\\<in>C.\n             \\<forall>c'\\<in>C. c \\<le> c' \\<longrightarrow> c' \\<in> A)\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> C \\<Longrightarrow>\n       \\<exists>c'\\<in>C. c \\<le> c' \\<and> c' \\<notin> A", "by auto"], ["proof (state)\nthis:\n  ?c \\<in> C \\<Longrightarrow>\n  \\<exists>c'\\<in>C. ?c \\<le> c' \\<and> c' \\<notin> A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>c\\<in>C.\n               \\<forall>c'\\<in>C.\n                  c \\<le> c' \\<longrightarrow> c' \\<in> A) \\<Longrightarrow>\n    False", "with \\<open>chain C\\<close> \\<open>C \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  chain C\n  C \\<noteq> {}\n  ?c \\<in> C \\<Longrightarrow>\n  \\<exists>c'\\<in>C. ?c \\<le> c' \\<and> c' \\<notin> A", "have \"chain (C - A)\" \"C - A \\<noteq> {}\""], ["proof (prove)\nusing this:\n  chain C\n  C \\<noteq> {}\n  ?c \\<in> C \\<Longrightarrow>\n  \\<exists>c'\\<in>C. ?c \\<le> c' \\<and> c' \\<notin> A\n\ngoal (1 subgoal):\n 1. chain (C - A) &&& C - A \\<noteq> {}", "by (auto intro: chain_Diff)"], ["proof (state)\nthis:\n  chain (C - A)\n  C - A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>c\\<in>C.\n               \\<forall>c'\\<in>C.\n                  c \\<le> c' \\<longrightarrow> c' \\<in> A) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  chain (C - A)\n  C - A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>c\\<in>C.\n               \\<forall>c'\\<in>C.\n                  c \\<le> c' \\<longrightarrow> c' \\<in> A) \\<Longrightarrow>\n    False", "have \"Sup C = Sup (C - A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> C = \\<Squnion> (C - A)", "proof (safe intro!: antisym ccpo_Sup_least \\<open>chain C\\<close> chain_Diff)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> x \\<le> \\<Squnion> (C - A)\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> C; x \\<notin> A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> \\<Squnion> C", "fix c"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> x \\<le> \\<Squnion> (C - A)\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> C; x \\<notin> A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> \\<Squnion> C", "assume \"c \\<in> C\""], ["proof (state)\nthis:\n  c \\<in> C\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> x \\<le> \\<Squnion> (C - A)\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> C; x \\<notin> A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> \\<Squnion> C", "with *"], ["proof (chain)\npicking this:\n  ?c \\<in> C \\<Longrightarrow>\n  \\<exists>c'\\<in>C. ?c \\<le> c' \\<and> c' \\<notin> A\n  c \\<in> C", "obtain c' where \"c' \\<in> C\" \"c \\<le> c'\" \"c' \\<notin> A\""], ["proof (prove)\nusing this:\n  ?c \\<in> C \\<Longrightarrow>\n  \\<exists>c'\\<in>C. ?c \\<le> c' \\<and> c' \\<notin> A\n  c \\<in> C\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        \\<lbrakk>c' \\<in> C; c \\<le> c'; c' \\<notin> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c' \\<in> C\n  c \\<le> c'\n  c' \\<notin> A\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> x \\<le> \\<Squnion> (C - A)\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> C; x \\<notin> A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> \\<Squnion> C", "with \\<open>c\\<in>C\\<close>"], ["proof (chain)\npicking this:\n  c \\<in> C\n  c' \\<in> C\n  c \\<le> c'\n  c' \\<notin> A", "show \"c \\<le> \\<Squnion>(C - A)\""], ["proof (prove)\nusing this:\n  c \\<in> C\n  c' \\<in> C\n  c \\<le> c'\n  c' \\<notin> A\n\ngoal (1 subgoal):\n 1. c \\<le> \\<Squnion> (C - A)", "by (intro ccpo_Sup_upper2 \\<open>chain (C - A)\\<close>) auto"], ["proof (state)\nthis:\n  c \\<le> \\<Squnion> (C - A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> C; x \\<notin> A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> \\<Squnion> C", "qed (auto intro: \\<open>chain C\\<close> ccpo_Sup_upper)"], ["proof (state)\nthis:\n  \\<Squnion> C = \\<Squnion> (C - A)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>c\\<in>C.\n               \\<forall>c'\\<in>C.\n                  c \\<le> c' \\<longrightarrow> c' \\<in> A) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  chain (C - A)\n  C - A \\<noteq> {}\n  \\<Squnion> C = \\<Squnion> (C - A)", "show False"], ["proof (prove)\nusing this:\n  chain (C - A)\n  C - A \\<noteq> {}\n  \\<Squnion> C = \\<Squnion> (C - A)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>open A\\<close> \\<open>Sup C \\<in> A\\<close>"], ["proof (prove)\nusing this:\n  chain (C - A)\n  C - A \\<noteq> {}\n  \\<Squnion> C = \\<Squnion> (C - A)\n  open A\n  \\<Squnion> C \\<in> A\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: open_ccpo)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma open_ccpo_Iic: \"open {.. b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open {..b}", "by (auto simp: open_ccpo) (metis Int_iff atMost_iff ccpo_Sup_upper empty_iff order_trans)"], ["", "subclass topological_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.topological_space open", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. open UNIV\n 2. \\<And>S T.\n       \\<lbrakk>open S; open T\\<rbrakk>\n       \\<Longrightarrow> open (S \\<inter> T)\n 3. \\<And>K. Ball K open \\<Longrightarrow> open (\\<Union> K)", "show \"open (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open UNIV", "unfolding open_ccpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       chain C \\<longrightarrow>\n       C \\<noteq> {} \\<longrightarrow>\n       \\<Squnion> C \\<in> UNIV \\<longrightarrow> C \\<inter> UNIV \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  open UNIV\n\ngoal (2 subgoals):\n 1. \\<And>S T.\n       \\<lbrakk>open S; open T\\<rbrakk>\n       \\<Longrightarrow> open (S \\<inter> T)\n 2. \\<And>K. Ball K open \\<Longrightarrow> open (\\<Union> K)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S T.\n       \\<lbrakk>open S; open T\\<rbrakk>\n       \\<Longrightarrow> open (S \\<inter> T)\n 2. \\<And>K. Ball K open \\<Longrightarrow> open (\\<Union> K)", "fix S T :: \"'a set\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S T.\n       \\<lbrakk>open S; open T\\<rbrakk>\n       \\<Longrightarrow> open (S \\<inter> T)\n 2. \\<And>K. Ball K open \\<Longrightarrow> open (\\<Union> K)", "assume \"open S\" \"open T\""], ["proof (state)\nthis:\n  open S\n  open T\n\ngoal (2 subgoals):\n 1. \\<And>S T.\n       \\<lbrakk>open S; open T\\<rbrakk>\n       \\<Longrightarrow> open (S \\<inter> T)\n 2. \\<And>K. Ball K open \\<Longrightarrow> open (\\<Union> K)", "show \"open (S \\<inter> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (S \\<inter> T)", "unfolding open_ccpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       chain C \\<longrightarrow>\n       C \\<noteq> {} \\<longrightarrow>\n       \\<Squnion> C \\<in> S \\<inter> T \\<longrightarrow>\n       C \\<inter> (S \\<inter> T) \\<noteq> {}", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain C; C \\<noteq> {};\n        \\<Squnion> C \\<in> S \\<inter> T\\<rbrakk>\n       \\<Longrightarrow> C \\<inter> (S \\<inter> T) \\<noteq> {}", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain C; C \\<noteq> {};\n        \\<Squnion> C \\<in> S \\<inter> T\\<rbrakk>\n       \\<Longrightarrow> C \\<inter> (S \\<inter> T) \\<noteq> {}", "assume C: \"chain C\" \"C \\<noteq> {}\" and \"\\<Squnion>C \\<in> S \\<inter> T\""], ["proof (state)\nthis:\n  chain C\n  C \\<noteq> {}\n  \\<Squnion> C \\<in> S \\<inter> T\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain C; C \\<noteq> {};\n        \\<Squnion> C \\<in> S \\<inter> T\\<rbrakk>\n       \\<Longrightarrow> C \\<inter> (S \\<inter> T) \\<noteq> {}", "with open_ccpoD[OF \\<open>open S\\<close> C] open_ccpoD[OF \\<open>open T\\<close> C]"], ["proof (chain)\npicking this:\n  \\<Squnion> C \\<in> S \\<Longrightarrow>\n  \\<exists>c\\<in>C.\n     \\<forall>c'\\<in>C. c \\<le> c' \\<longrightarrow> c' \\<in> S\n  \\<Squnion> C \\<in> T \\<Longrightarrow>\n  \\<exists>c\\<in>C.\n     \\<forall>c'\\<in>C. c \\<le> c' \\<longrightarrow> c' \\<in> T\n  chain C\n  C \\<noteq> {}\n  \\<Squnion> C \\<in> S \\<inter> T", "show \"C \\<inter> (S \\<inter> T) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<Squnion> C \\<in> S \\<Longrightarrow>\n  \\<exists>c\\<in>C.\n     \\<forall>c'\\<in>C. c \\<le> c' \\<longrightarrow> c' \\<in> S\n  \\<Squnion> C \\<in> T \\<Longrightarrow>\n  \\<exists>c\\<in>C.\n     \\<forall>c'\\<in>C. c \\<le> c' \\<longrightarrow> c' \\<in> T\n  chain C\n  C \\<noteq> {}\n  \\<Squnion> C \\<in> S \\<inter> T\n\ngoal (1 subgoal):\n 1. C \\<inter> (S \\<inter> T) \\<noteq> {}", "unfolding chain_def"], ["proof (prove)\nusing this:\n  \\<Squnion> C \\<in> S \\<Longrightarrow>\n  \\<exists>c\\<in>C.\n     \\<forall>c'\\<in>C. c \\<le> c' \\<longrightarrow> c' \\<in> S\n  \\<Squnion> C \\<in> T \\<Longrightarrow>\n  \\<exists>c\\<in>C.\n     \\<forall>c'\\<in>C. c \\<le> c' \\<longrightarrow> c' \\<in> T\n  \\<forall>x\\<in>C. \\<forall>y\\<in>C. x \\<le> y \\<or> y \\<le> x\n  C \\<noteq> {}\n  \\<Squnion> C \\<in> S \\<inter> T\n\ngoal (1 subgoal):\n 1. C \\<inter> (S \\<inter> T) \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  C \\<inter> (S \\<inter> T) \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  open (S \\<inter> T)\n\ngoal (1 subgoal):\n 1. \\<And>K. Ball K open \\<Longrightarrow> open (\\<Union> K)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>K. Ball K open \\<Longrightarrow> open (\\<Union> K)", "fix K :: \"'a set set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>K. Ball K open \\<Longrightarrow> open (\\<Union> K)", "assume *: \"\\<forall>D\\<in>K. open D\""], ["proof (state)\nthis:\n  Ball K open\n\ngoal (1 subgoal):\n 1. \\<And>K. Ball K open \\<Longrightarrow> open (\\<Union> K)", "show \"open (\\<Union>K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (\\<Union> K)", "unfolding open_ccpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       chain C \\<longrightarrow>\n       C \\<noteq> {} \\<longrightarrow>\n       \\<Squnion> C \\<in> \\<Union> K \\<longrightarrow>\n       C \\<inter> \\<Union> K \\<noteq> {}", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain C; C \\<noteq> {};\n        \\<Squnion> C \\<in> \\<Union> K\\<rbrakk>\n       \\<Longrightarrow> C \\<inter> \\<Union> K \\<noteq> {}", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain C; C \\<noteq> {};\n        \\<Squnion> C \\<in> \\<Union> K\\<rbrakk>\n       \\<Longrightarrow> C \\<inter> \\<Union> K \\<noteq> {}", "assume \"chain C\" \"C \\<noteq> {}\" \"\\<Squnion>C \\<in> (\\<Union>K)\""], ["proof (state)\nthis:\n  chain C\n  C \\<noteq> {}\n  \\<Squnion> C \\<in> \\<Union> K\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain C; C \\<noteq> {};\n        \\<Squnion> C \\<in> \\<Union> K\\<rbrakk>\n       \\<Longrightarrow> C \\<inter> \\<Union> K \\<noteq> {}", "with *"], ["proof (chain)\npicking this:\n  Ball K open\n  chain C\n  C \\<noteq> {}\n  \\<Squnion> C \\<in> \\<Union> K", "obtain D where \"D \\<in> K\" \"\\<Squnion>C \\<in> D\" \"C \\<inter> D \\<noteq> {}\""], ["proof (prove)\nusing this:\n  Ball K open\n  chain C\n  C \\<noteq> {}\n  \\<Squnion> C \\<in> \\<Union> K\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> K; \\<Squnion> C \\<in> D;\n         C \\<inter> D \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: open_ccpo)"], ["proof (state)\nthis:\n  D \\<in> K\n  \\<Squnion> C \\<in> D\n  C \\<inter> D \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain C; C \\<noteq> {};\n        \\<Squnion> C \\<in> \\<Union> K\\<rbrakk>\n       \\<Longrightarrow> C \\<inter> \\<Union> K \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  D \\<in> K\n  \\<Squnion> C \\<in> D\n  C \\<inter> D \\<noteq> {}", "show \"C \\<inter> (\\<Union>K) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  D \\<in> K\n  \\<Squnion> C \\<in> D\n  C \\<inter> D \\<noteq> {}\n\ngoal (1 subgoal):\n 1. C \\<inter> \\<Union> K \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  C \\<inter> \\<Union> K \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  open (\\<Union> K)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_ccpo: \"closed A \\<longleftrightarrow> (\\<forall>C. chain C \\<longrightarrow> C \\<noteq> {} \\<longrightarrow> C \\<subseteq> A \\<longrightarrow> Sup C \\<in> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed A =\n    (\\<forall>C.\n        chain C \\<longrightarrow>\n        C \\<noteq> {} \\<longrightarrow>\n        C \\<subseteq> A \\<longrightarrow> \\<Squnion> C \\<in> A)", "unfolding closed_def open_ccpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>C.\n        chain C \\<longrightarrow>\n        C \\<noteq> {} \\<longrightarrow>\n        \\<Squnion> C \\<in> - A \\<longrightarrow>\n        C \\<inter> - A \\<noteq> {}) =\n    (\\<forall>C.\n        chain C \\<longrightarrow>\n        C \\<noteq> {} \\<longrightarrow>\n        C \\<subseteq> A \\<longrightarrow> \\<Squnion> C \\<in> A)", "by auto"], ["", "lemma closed_admissible: \"closed {x. P x} \\<longleftrightarrow> ccpo.admissible Sup (\\<le>) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {x. P x} = ccpo.admissible Sup (\\<le>) P", "unfolding closed_ccpo ccpo.admissible_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>C.\n        chain C \\<longrightarrow>\n        C \\<noteq> {} \\<longrightarrow>\n        C \\<subseteq> Collect P \\<longrightarrow>\n        \\<Squnion> C \\<in> Collect P) =\n    (\\<forall>A.\n        chain A \\<longrightarrow>\n        A \\<noteq> {} \\<longrightarrow>\n        Ball A P \\<longrightarrow> P (\\<Squnion> A))", "by auto"], ["", "lemma open_singletonI_compact: \"compact_element x \\<Longrightarrow> open {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compact_element x \\<Longrightarrow> open {x}", "using admissible_compact_neq[of Sup \"(\\<le>)\" x]"], ["proof (prove)\nusing this:\n  compact_element x \\<Longrightarrow>\n  ccpo.admissible Sup (\\<le>) ((\\<noteq>) x)\n\ngoal (1 subgoal):\n 1. compact_element x \\<Longrightarrow> open {x}", "by (simp add: closed_admissible[symmetric] open_closed Collect_neg_eq)"], ["", "lemma closed_Ici: \"closed {.. b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {..b}", "by (auto simp: closed_ccpo intro: ccpo_Sup_least)"], ["", "lemma closed_Iic: \"closed {b ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {b..}", "by (auto simp: closed_ccpo intro: ccpo_Sup_upper2)"], ["", "text \\<open>\n  @{class ccpo_topology}s are also @{class t2_space}s.\n  This is necessary to have a unique continuous extension.\n\\<close>"], ["", "subclass t2_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.t2_space open", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "fix x y :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "show \"\\<exists>U V. open U \\<and> open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x__ \\<in> U \\<and> y__ \\<in> V \\<and> U \\<inter> V = {}\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x__ \\<in> U \\<and> y__ \\<in> V \\<and> U \\<inter> V = {}", "assume \"x \\<noteq> y\" \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x__ \\<in> U \\<and> y__ \\<in> V \\<and> U \\<inter> V = {}\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x__ \\<in> U \\<and> y__ \\<in> V \\<and> U \\<inter> V = {}", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  x \\<le> y", "have \"open {..x} \\<and> open (- {..x}) \\<and> x \\<in> {..x} \\<and> y \\<in> - {..x} \\<and> {..x} \\<inter> - {..x} = {}\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. open {..x} \\<and>\n    open (- {..x}) \\<and>\n    x \\<in> {..x} \\<and> y \\<in> - {..x} \\<and> {..x} \\<inter> - {..x} = {}", "by (auto intro: open_ccpo_Iic closed_Ici)"], ["proof (state)\nthis:\n  open {..x} \\<and>\n  open (- {..x}) \\<and>\n  x \\<in> {..x} \\<and> y \\<in> - {..x} \\<and> {..x} \\<inter> - {..x} = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x__ \\<in> U \\<and> y__ \\<in> V \\<and> U \\<inter> V = {}\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x__ \\<in> U \\<and> y__ \\<in> V \\<and> U \\<inter> V = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2; ?xa2 \\<le> ?ya2\\<rbrakk>\n  \\<Longrightarrow> open {..?xa2} \\<and>\n                    open (- {..?xa2}) \\<and>\n                    ?xa2 \\<in> {..?xa2} \\<and>\n                    ?ya2 \\<in> - {..?xa2} \\<and>\n                    {..?xa2} \\<inter> - {..?xa2} = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2; ?xa2 \\<le> ?ya2\\<rbrakk>\n  \\<Longrightarrow> open {..?xa2} \\<and>\n                    open (- {..?xa2}) \\<and>\n                    ?xa2 \\<in> {..?xa2} \\<and>\n                    ?ya2 \\<in> - {..?xa2} \\<and>\n                    {..?xa2} \\<inter> - {..?xa2} = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "assume \"x \\<le> y \\<or> y \\<le> x\""], ["proof (state)\nthis:\n  x \\<le> y \\<or> y \\<le> x\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2; ?xa2 \\<le> ?ya2\\<rbrakk>\n  \\<Longrightarrow> open {..?xa2} \\<and>\n                    open (- {..?xa2}) \\<and>\n                    ?xa2 \\<in> {..?xa2} \\<and>\n                    ?ya2 \\<in> - {..?xa2} \\<and>\n                    {..?xa2} \\<inter> - {..?xa2} = {}\n  x \\<le> y \\<or> y \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2; ?xa2 \\<le> ?ya2\\<rbrakk>\n  \\<Longrightarrow> open {..?xa2} \\<and>\n                    open (- {..?xa2}) \\<and>\n                    ?xa2 \\<in> {..?xa2} \\<and>\n                    ?ya2 \\<in> - {..?xa2} \\<and>\n                    {..?xa2} \\<inter> - {..?xa2} = {}\n  x \\<le> y \\<or> y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "using \\<open>x \\<noteq> y\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa2 \\<noteq> ?ya2; ?xa2 \\<le> ?ya2\\<rbrakk>\n  \\<Longrightarrow> open {..?xa2} \\<and>\n                    open (- {..?xa2}) \\<and>\n                    ?xa2 \\<in> {..?xa2} \\<and>\n                    ?ya2 \\<in> - {..?xa2} \\<and>\n                    {..?xa2} \\<inter> - {..?xa2} = {}\n  x \\<le> y \\<or> y \\<le> x\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "by (metis Int_commute)"], ["proof (state)\nthis:\n  \\<exists>U V.\n     open U \\<and>\n     open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<le> y \\<or> y \\<le> x) \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (x \\<le> y \\<or> y \\<le> x) \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "assume \"\\<not> (x \\<le> y \\<or> y \\<le> x)\""], ["proof (state)\nthis:\n  \\<not> (x \\<le> y \\<or> y \\<le> x)\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<le> y \\<or> y \\<le> x) \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "then"], ["proof (chain)\npicking this:\n  \\<not> (x \\<le> y \\<or> y \\<le> x)", "have \"open ({..x} \\<inter> - {..y}) \\<and> open ({..y} \\<inter> - {..x}) \\<and>\n        x \\<in> {..x} \\<inter> - {..y} \\<and> y \\<in> {..y} \\<inter> - {..x} \\<and> ({..x} \\<inter> - {..y}) \\<inter> ({..y} \\<inter> - {..x}) = {}\""], ["proof (prove)\nusing this:\n  \\<not> (x \\<le> y \\<or> y \\<le> x)\n\ngoal (1 subgoal):\n 1. open ({..x} \\<inter> - {..y}) \\<and>\n    open ({..y} \\<inter> - {..x}) \\<and>\n    x \\<in> {..x} \\<inter> - {..y} \\<and>\n    y \\<in> {..y} \\<inter> - {..x} \\<and>\n    {..x} \\<inter> - {..y} \\<inter> ({..y} \\<inter> - {..x}) = {}", "by (auto intro: open_ccpo_Iic closed_Ici)"], ["proof (state)\nthis:\n  open ({..x} \\<inter> - {..y}) \\<and>\n  open ({..y} \\<inter> - {..x}) \\<and>\n  x \\<in> {..x} \\<inter> - {..y} \\<and>\n  y \\<in> {..y} \\<inter> - {..x} \\<and>\n  {..x} \\<inter> - {..y} \\<inter> ({..y} \\<inter> - {..x}) = {}\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<le> y \\<or> y \\<le> x) \\<Longrightarrow>\n    \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "then"], ["proof (chain)\npicking this:\n  open ({..x} \\<inter> - {..y}) \\<and>\n  open ({..y} \\<inter> - {..x}) \\<and>\n  x \\<in> {..x} \\<inter> - {..y} \\<and>\n  y \\<in> {..y} \\<inter> - {..x} \\<and>\n  {..x} \\<inter> - {..y} \\<inter> ({..y} \\<inter> - {..x}) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  open ({..x} \\<inter> - {..y}) \\<and>\n  open ({..y} \\<inter> - {..x}) \\<and>\n  x \\<in> {..x} \\<inter> - {..y} \\<and>\n  y \\<in> {..y} \\<inter> - {..x} \\<and>\n  {..x} \\<inter> - {..y} \\<inter> ({..y} \\<inter> - {..x}) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "by auto"], ["proof (state)\nthis:\n  \\<exists>U V.\n     open U \\<and>\n     open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>U V.\n     open U \\<and>\n     open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma tendsto_le_ccpo:\n  fixes f g :: \"'a \\<Rightarrow> 'b::ccpo_topology\"\n  assumes F: \"\\<not> trivial_limit F\"\n  assumes x: \"(f \\<longlongrightarrow> x) F\" and y: \"(g \\<longlongrightarrow> y) F\"\n  assumes ev: \"eventually (\\<lambda>x. g x \\<le> f x) F\"\n  shows \"y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x \\<Longrightarrow> False", "assume \"\\<not> y \\<le> x\""], ["proof (state)\nthis:\n  \\<not> y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with \\<open>\\<not> y \\<le> x\\<close>"], ["proof (chain)\npicking this:\n  \\<not> y \\<le> x\n  x \\<le> y", "have \"open {..x}\" \"open (- {..x})\" \"x \\<in> {..x}\" \"y \\<in> - {..x}\" \"{..x} \\<inter> - {..x} = {}\""], ["proof (prove)\nusing this:\n  \\<not> y \\<le> x\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. (open {..x} &&& open (- {..x})) &&&\n    x \\<in> {..x} &&& y \\<in> - {..x} &&& {..x} \\<inter> - {..x} = {}", "by (auto intro: open_ccpo_Iic closed_Ici)"], ["proof (state)\nthis:\n  open {..x}\n  open (- {..x})\n  x \\<in> {..x}\n  y \\<in> - {..x}\n  {..x} \\<inter> - {..x} = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with topological_tendstoD[OF x, of \"{..x}\"] topological_tendstoD[OF y, of \"- {..x}\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>open {..x}; x \\<in> {..x}\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F xa in F. f xa \\<in> {..x}\n  \\<lbrakk>open (- {..x}); y \\<in> - {..x}\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F xa in F. g xa \\<in> - {..x}\n  open {..x}\n  open (- {..x})\n  x \\<in> {..x}\n  y \\<in> - {..x}\n  {..x} \\<inter> - {..x} = {}", "have \"eventually (\\<lambda>z. f z \\<le> x) F\" \"eventually (\\<lambda>z. \\<not> g z \\<le> x) F\""], ["proof (prove)\nusing this:\n  \\<lbrakk>open {..x}; x \\<in> {..x}\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F xa in F. f xa \\<in> {..x}\n  \\<lbrakk>open (- {..x}); y \\<in> - {..x}\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F xa in F. g xa \\<in> - {..x}\n  open {..x}\n  open (- {..x})\n  x \\<in> {..x}\n  y \\<in> - {..x}\n  {..x} \\<inter> - {..x} = {}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in F. f z \\<le> x &&&\n    \\<forall>\\<^sub>F z in F. \\<not> g z \\<le> x", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F z in F. f z \\<le> x\n  \\<forall>\\<^sub>F z in F. \\<not> g z \\<le> x\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with ev"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. g x \\<le> f x\n  \\<forall>\\<^sub>F z in F. f z \\<le> x\n  \\<forall>\\<^sub>F z in F. \\<not> g z \\<le> x", "have \"eventually (\\<lambda>x. False) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. g x \\<le> f x\n  \\<forall>\\<^sub>F z in F. f z \\<le> x\n  \\<forall>\\<^sub>F z in F. \\<not> g z \\<le> x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. False", "by eventually_elim (auto intro: order_trans)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. False\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with F"], ["proof (chain)\npicking this:\n  F \\<noteq> \\<bottom>\n  \\<forall>\\<^sub>F x in F. False", "show False"], ["proof (prove)\nusing this:\n  F \\<noteq> \\<bottom>\n  \\<forall>\\<^sub>F x in F. False\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: eventually_False)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> False", "assume \"\\<not> x \\<le> y\""], ["proof (state)\nthis:\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> False", "with \\<open>\\<not> y \\<le> x\\<close>"], ["proof (chain)\npicking this:\n  \\<not> y \\<le> x\n  \\<not> x \\<le> y", "have \"open ({..x} \\<inter> - {..y})\" \"open ({..y} \\<inter> - {..x})\"\n        \"x \\<in> {..x} \\<inter> - {..y}\" \"y \\<in> {..y} \\<inter> - {..x}\" \"({..x} \\<inter> - {..y}) \\<inter> ({..y} \\<inter> - {..x}) = {}\""], ["proof (prove)\nusing this:\n  \\<not> y \\<le> x\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. (open ({..x} \\<inter> - {..y}) &&& open ({..y} \\<inter> - {..x})) &&&\n    x \\<in> {..x} \\<inter> - {..y} &&&\n    y \\<in> {..y} \\<inter> - {..x} &&&\n    {..x} \\<inter> - {..y} \\<inter> ({..y} \\<inter> - {..x}) = {}", "by (auto intro: open_ccpo_Iic closed_Ici)"], ["proof (state)\nthis:\n  open ({..x} \\<inter> - {..y})\n  open ({..y} \\<inter> - {..x})\n  x \\<in> {..x} \\<inter> - {..y}\n  y \\<in> {..y} \\<inter> - {..x}\n  {..x} \\<inter> - {..y} \\<inter> ({..y} \\<inter> - {..x}) = {}\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> False", "with topological_tendstoD[OF x, of \"{..x} \\<inter> - {..y}\"]\n         topological_tendstoD[OF y, of \"{..y} \\<inter> - {..x}\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>open ({..x} \\<inter> - {..y});\n   x \\<in> {..x} \\<inter> - {..y}\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F xa in F.\n                       f xa \\<in> {..x} \\<inter> - {..y}\n  \\<lbrakk>open ({..y} \\<inter> - {..x});\n   y \\<in> {..y} \\<inter> - {..x}\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F xa in F.\n                       g xa \\<in> {..y} \\<inter> - {..x}\n  open ({..x} \\<inter> - {..y})\n  open ({..y} \\<inter> - {..x})\n  x \\<in> {..x} \\<inter> - {..y}\n  y \\<in> {..y} \\<inter> - {..x}\n  {..x} \\<inter> - {..y} \\<inter> ({..y} \\<inter> - {..x}) = {}", "have \"eventually (\\<lambda>z. f z \\<le> x \\<and> \\<not> f z \\<le> y) F\" \"eventually (\\<lambda>z. g z \\<le> y \\<and> \\<not> g z \\<le> x) F\""], ["proof (prove)\nusing this:\n  \\<lbrakk>open ({..x} \\<inter> - {..y});\n   x \\<in> {..x} \\<inter> - {..y}\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F xa in F.\n                       f xa \\<in> {..x} \\<inter> - {..y}\n  \\<lbrakk>open ({..y} \\<inter> - {..x});\n   y \\<in> {..y} \\<inter> - {..x}\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F xa in F.\n                       g xa \\<in> {..y} \\<inter> - {..x}\n  open ({..x} \\<inter> - {..y})\n  open ({..y} \\<inter> - {..x})\n  x \\<in> {..x} \\<inter> - {..y}\n  y \\<in> {..y} \\<inter> - {..x}\n  {..x} \\<inter> - {..y} \\<inter> ({..y} \\<inter> - {..x}) = {}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in F. f z \\<le> x \\<and> \\<not> f z \\<le> y &&&\n    \\<forall>\\<^sub>F z in F. g z \\<le> y \\<and> \\<not> g z \\<le> x", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F z in F. f z \\<le> x \\<and> \\<not> f z \\<le> y\n  \\<forall>\\<^sub>F z in F. g z \\<le> y \\<and> \\<not> g z \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> False", "with ev"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. g x \\<le> f x\n  \\<forall>\\<^sub>F z in F. f z \\<le> x \\<and> \\<not> f z \\<le> y\n  \\<forall>\\<^sub>F z in F. g z \\<le> y \\<and> \\<not> g z \\<le> x", "have \"eventually (\\<lambda>x. False) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. g x \\<le> f x\n  \\<forall>\\<^sub>F z in F. f z \\<le> x \\<and> \\<not> f z \\<le> y\n  \\<forall>\\<^sub>F z in F. g z \\<le> y \\<and> \\<not> g z \\<le> x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. False", "by eventually_elim (auto intro: order_trans)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. False\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> False", "with F"], ["proof (chain)\npicking this:\n  F \\<noteq> \\<bottom>\n  \\<forall>\\<^sub>F x in F. False", "show False"], ["proof (prove)\nusing this:\n  F \\<noteq> \\<bottom>\n  \\<forall>\\<^sub>F x in F. False\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: eventually_False)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tendsto_ccpoI:\n  fixes f :: \"'a::ccpo_topology \\<Rightarrow> 'b::ccpo_topology\"\n  shows \"(\\<And>C. chain C \\<Longrightarrow> C \\<noteq> {} \\<Longrightarrow> chain (f ` C) \\<and> f (Sup C) = Sup (f`C)) \\<Longrightarrow> f \\<midarrow>x\\<rightarrow> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>chain C; C \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> chain (f ` C) \\<and>\n                          f (\\<Squnion> C) =\n                          \\<Squnion> (f ` C)) \\<Longrightarrow>\n    f \\<midarrow>x\\<rightarrow> f x", "by (intro tendsto_open_vimage) (auto simp: open_ccpo)"], ["", "lemma tendsto_mcont:\n  assumes mcont: \"mcont Sup (\\<le>) Sup (\\<le>) (f :: 'a :: ccpo_topology \\<Rightarrow> 'b :: ccpo_topology)\"\n  shows \"f \\<midarrow>l\\<rightarrow> f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<midarrow>l\\<rightarrow> f l", "proof (intro tendsto_ccpoI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>chain C; C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> chain (f ` C)\n 2. \\<And>C.\n       \\<lbrakk>chain C; C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f (\\<Squnion> C) = \\<Squnion> (f ` C)", "fix C :: \"'a set\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>chain C; C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> chain (f ` C)\n 2. \\<And>C.\n       \\<lbrakk>chain C; C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f (\\<Squnion> C) = \\<Squnion> (f ` C)", "assume C: \"chain C\" \"C \\<noteq> {}\""], ["proof (state)\nthis:\n  chain C\n  C \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>chain C; C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> chain (f ` C)\n 2. \\<And>C.\n       \\<lbrakk>chain C; C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f (\\<Squnion> C) = \\<Squnion> (f ` C)", "show \"chain (f`C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain (f ` C)", "using mcont"], ["proof (prove)\nusing this:\n  mcont Sup (\\<le>) Sup (\\<le>) f\n\ngoal (1 subgoal):\n 1. chain (f ` C)", "by (intro chain_imageI[where le_a=\"(\\<le>)\"] C) (simp add: mcont_def monotone_def)"], ["proof (state)\nthis:\n  chain (f ` C)\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain C; C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f (\\<Squnion> C) = \\<Squnion> (f ` C)", "show \"f (\\<Squnion>C) = \\<Squnion>(f ` C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<Squnion> C) = \\<Squnion> (f ` C)", "using mcont C"], ["proof (prove)\nusing this:\n  mcont Sup (\\<le>) Sup (\\<le>) f\n  chain C\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. f (\\<Squnion> C) = \\<Squnion> (f ` C)", "by (simp add: mcont_def cont_def)"], ["proof (state)\nthis:\n  f (\\<Squnion> C) = \\<Squnion> (f ` C)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Instances for @{class ccpo_topology}s and continuity theorems\\<close>"], ["", "instantiation set :: (type) ccpo_topology\nbegin"], ["", "definition open_set :: \"'a set set \\<Rightarrow> bool\" where\n  \"open_set A \\<longleftrightarrow> (\\<forall>C. chain C \\<longrightarrow> C \\<noteq> {} \\<longrightarrow> Sup C \\<in> A \\<longrightarrow> C \\<inter> A \\<noteq> {})\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, ccpo_topology_class)", "by intro_classes (simp add: open_set_def)"], ["", "end"], ["", "instantiation enat :: ccpo_topology\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(enat, ccpo_topology_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       open A =\n       (\\<forall>C.\n           chain C \\<longrightarrow>\n           C \\<noteq> {} \\<longrightarrow>\n           \\<Squnion> C \\<in> A \\<longrightarrow> C \\<inter> A \\<noteq> {})", "fix A :: \"enat set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       open A =\n       (\\<forall>C.\n           chain C \\<longrightarrow>\n           C \\<noteq> {} \\<longrightarrow>\n           \\<Squnion> C \\<in> A \\<longrightarrow> C \\<inter> A \\<noteq> {})", "show \"open A = (\\<forall>C. chain C \\<longrightarrow> C \\<noteq> {} \\<longrightarrow> \\<Squnion>C \\<in> A \\<longrightarrow> C \\<inter> A \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open A =\n    (\\<forall>C.\n        chain C \\<longrightarrow>\n        C \\<noteq> {} \\<longrightarrow>\n        \\<Squnion> C \\<in> A \\<longrightarrow> C \\<inter> A \\<noteq> {})", "proof (intro iffI allI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>open A; chain C; C \\<noteq> {};\n        \\<Squnion> C \\<in> A\\<rbrakk>\n       \\<Longrightarrow> C \\<inter> A \\<noteq> {}\n 2. \\<forall>C.\n       chain C \\<longrightarrow>\n       C \\<noteq> {} \\<longrightarrow>\n       \\<Squnion> C \\<in> A \\<longrightarrow>\n       C \\<inter> A \\<noteq> {} \\<Longrightarrow>\n    open A", "fix C x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>open A; chain C; C \\<noteq> {};\n        \\<Squnion> C \\<in> A\\<rbrakk>\n       \\<Longrightarrow> C \\<inter> A \\<noteq> {}\n 2. \\<forall>C.\n       chain C \\<longrightarrow>\n       C \\<noteq> {} \\<longrightarrow>\n       \\<Squnion> C \\<in> A \\<longrightarrow>\n       C \\<inter> A \\<noteq> {} \\<Longrightarrow>\n    open A", "assume \"open A\" \"chain C\" \"C \\<noteq> {}\" \"\\<Squnion>C \\<in> A\""], ["proof (state)\nthis:\n  open A\n  chain C\n  C \\<noteq> {}\n  \\<Squnion> C \\<in> A\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>open A; chain C; C \\<noteq> {};\n        \\<Squnion> C \\<in> A\\<rbrakk>\n       \\<Longrightarrow> C \\<inter> A \\<noteq> {}\n 2. \\<forall>C.\n       chain C \\<longrightarrow>\n       C \\<noteq> {} \\<longrightarrow>\n       \\<Squnion> C \\<in> A \\<longrightarrow>\n       C \\<inter> A \\<noteq> {} \\<Longrightarrow>\n    open A", "show \"C \\<inter> A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<inter> A \\<noteq> {}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> C \\<inter> A \\<noteq> {}\n 2. \\<not> ?P \\<Longrightarrow> C \\<inter> A \\<noteq> {}", "assume \"\\<Squnion>C = \\<infinity>\""], ["proof (state)\nthis:\n  \\<Squnion> C = \\<infinity>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> C \\<inter> A \\<noteq> {}\n 2. \\<not> ?P \\<Longrightarrow> C \\<inter> A \\<noteq> {}", "with \\<open>\\<Squnion>C \\<in> A\\<close> \\<open>open A\\<close>"], ["proof (chain)\npicking this:\n  \\<Squnion> C \\<in> A\n  open A\n  \\<Squnion> C = \\<infinity>", "obtain n where \"{enat n <..} \\<subseteq> A\""], ["proof (prove)\nusing this:\n  \\<Squnion> C \\<in> A\n  open A\n  \\<Squnion> C = \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        {enat n<..} \\<subseteq> A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding open_enat_iff"], ["proof (prove)\nusing this:\n  \\<Squnion> C \\<in> A\n  \\<infinity> \\<in> A \\<longrightarrow>\n  (\\<exists>x. {enat x<..} \\<subseteq> A)\n  \\<Squnion> C = \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        {enat n<..} \\<subseteq> A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  {enat n<..} \\<subseteq> A\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> C \\<inter> A \\<noteq> {}\n 2. \\<not> ?P \\<Longrightarrow> C \\<inter> A \\<noteq> {}", "with \\<open>\\<Squnion>C = \\<infinity>\\<close> Sup_eq_top_iff[of C]"], ["proof (chain)\npicking this:\n  \\<Squnion> C = \\<infinity>\n  (\\<Squnion> C = \\<top>) = (\\<forall>x<\\<top>. \\<exists>i\\<in>C. x < i)\n  {enat n<..} \\<subseteq> A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Squnion> C = \\<infinity>\n  (\\<Squnion> C = \\<top>) = (\\<forall>x<\\<top>. \\<exists>i\\<in>C. x < i)\n  {enat n<..} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. C \\<inter> A \\<noteq> {}", "by (auto simp: top_enat_def)"], ["proof (state)\nthis:\n  C \\<inter> A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<Squnion> C \\<noteq> \\<infinity> \\<Longrightarrow>\n    C \\<inter> A \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Squnion> C \\<noteq> \\<infinity> \\<Longrightarrow>\n    C \\<inter> A \\<noteq> {}", "assume \"\\<Squnion>C \\<noteq> \\<infinity>\""], ["proof (state)\nthis:\n  \\<Squnion> C \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<Squnion> C \\<noteq> \\<infinity> \\<Longrightarrow>\n    C \\<inter> A \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  \\<Squnion> C \\<noteq> \\<infinity>", "obtain n where \"C \\<subseteq> {.. enat n}\""], ["proof (prove)\nusing this:\n  \\<Squnion> C \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        C \\<subseteq> {..enat n} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Sup_eq_top_iff top_enat_def[symmetric]"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x<\\<top>. Bex C ((<) x))\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        C \\<subseteq> {..enat n} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: not_less top_enat_def)"], ["proof (state)\nthis:\n  C \\<subseteq> {..enat n}\n\ngoal (1 subgoal):\n 1. \\<Squnion> C \\<noteq> \\<infinity> \\<Longrightarrow>\n    C \\<inter> A \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  C \\<subseteq> {..enat n}\n\ngoal (1 subgoal):\n 1. \\<Squnion> C \\<noteq> \\<infinity> \\<Longrightarrow>\n    C \\<inter> A \\<noteq> {}", "have \"finite {.. enat n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {..enat n}", "by (auto intro: finite_enat_bounded)"], ["proof (state)\nthis:\n  finite {..enat n}\n\ngoal (1 subgoal):\n 1. \\<Squnion> C \\<noteq> \\<infinity> \\<Longrightarrow>\n    C \\<inter> A \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  C \\<subseteq> {..enat n}\n  finite {..enat n}", "have \"finite C\""], ["proof (prove)\nusing this:\n  C \\<subseteq> {..enat n}\n  finite {..enat n}\n\ngoal (1 subgoal):\n 1. finite C", "by (auto intro: finite_subset)"], ["proof (state)\nthis:\n  finite C\n\ngoal (1 subgoal):\n 1. \\<Squnion> C \\<noteq> \\<infinity> \\<Longrightarrow>\n    C \\<inter> A \\<noteq> {}", "from in_chain_finite[OF \\<open>chain C\\<close> \\<open>finite C\\<close> \\<open>C \\<noteq> {}\\<close>] \\<open>\\<Squnion>C \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  \\<Squnion> C \\<in> C\n  \\<Squnion> C \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Squnion> C \\<in> C\n  \\<Squnion> C \\<in> A\n\ngoal (1 subgoal):\n 1. C \\<inter> A \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  C \\<inter> A \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C \\<inter> A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>C.\n       chain C \\<longrightarrow>\n       C \\<noteq> {} \\<longrightarrow>\n       \\<Squnion> C \\<in> A \\<longrightarrow>\n       C \\<inter> A \\<noteq> {} \\<Longrightarrow>\n    open A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       chain C \\<longrightarrow>\n       C \\<noteq> {} \\<longrightarrow>\n       \\<Squnion> C \\<in> A \\<longrightarrow>\n       C \\<inter> A \\<noteq> {} \\<Longrightarrow>\n    open A", "assume C: \"\\<forall>C. chain C \\<longrightarrow> C \\<noteq> {} \\<longrightarrow> \\<Squnion>C \\<in> A \\<longrightarrow> C \\<inter> A \\<noteq> {}\""], ["proof (state)\nthis:\n  \\<forall>C.\n     chain C \\<longrightarrow>\n     C \\<noteq> {} \\<longrightarrow>\n     \\<Squnion> C \\<in> A \\<longrightarrow> C \\<inter> A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>C.\n       chain C \\<longrightarrow>\n       C \\<noteq> {} \\<longrightarrow>\n       \\<Squnion> C \\<in> A \\<longrightarrow>\n       C \\<inter> A \\<noteq> {} \\<Longrightarrow>\n    open A", "show \"open A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open A", "unfolding open_enat_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> \\<in> A \\<longrightarrow>\n    (\\<exists>x. {enat x<..} \\<subseteq> A)", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<infinity> \\<in> A \\<Longrightarrow>\n    \\<exists>x. {enat x<..} \\<subseteq> A", "assume \"\\<infinity> \\<in> A\""], ["proof (state)\nthis:\n  \\<infinity> \\<in> A\n\ngoal (1 subgoal):\n 1. \\<infinity> \\<in> A \\<Longrightarrow>\n    \\<exists>x. {enat x<..} \\<subseteq> A", "{"], ["proof (state)\nthis:\n  \\<infinity> \\<in> A\n\ngoal (1 subgoal):\n 1. \\<infinity> \\<in> A \\<Longrightarrow>\n    \\<exists>x. {enat x<..} \\<subseteq> A", "fix C :: \"enat set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<infinity> \\<in> A \\<Longrightarrow>\n    \\<exists>x. {enat x<..} \\<subseteq> A", "assume \"infinite C\""], ["proof (state)\nthis:\n  infinite C\n\ngoal (1 subgoal):\n 1. \\<infinity> \\<in> A \\<Longrightarrow>\n    \\<exists>x. {enat x<..} \\<subseteq> A", "then"], ["proof (chain)\npicking this:\n  infinite C", "have \"\\<Squnion>C = \\<infinity>\""], ["proof (prove)\nusing this:\n  infinite C\n\ngoal (1 subgoal):\n 1. \\<Squnion> C = \\<infinity>", "by (auto simp: Sup_enat_def)"], ["proof (state)\nthis:\n  \\<Squnion> C = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<infinity> \\<in> A \\<Longrightarrow>\n    \\<exists>x. {enat x<..} \\<subseteq> A", "with \\<open>infinite C\\<close> C[THEN spec, of C] \\<open>\\<infinity> \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  infinite C\n  chain C \\<longrightarrow>\n  C \\<noteq> {} \\<longrightarrow>\n  \\<Squnion> C \\<in> A \\<longrightarrow> C \\<inter> A \\<noteq> {}\n  \\<infinity> \\<in> A\n  \\<Squnion> C = \\<infinity>", "have \"C \\<inter> A \\<noteq> {}\""], ["proof (prove)\nusing this:\n  infinite C\n  chain C \\<longrightarrow>\n  C \\<noteq> {} \\<longrightarrow>\n  \\<Squnion> C \\<in> A \\<longrightarrow> C \\<inter> A \\<noteq> {}\n  \\<infinity> \\<in> A\n  \\<Squnion> C = \\<infinity>\n\ngoal (1 subgoal):\n 1. C \\<inter> A \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  C \\<inter> A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<infinity> \\<in> A \\<Longrightarrow>\n    \\<exists>x. {enat x<..} \\<subseteq> A", "}"], ["proof (state)\nthis:\n  infinite ?C2 \\<Longrightarrow> ?C2 \\<inter> A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<infinity> \\<in> A \\<Longrightarrow>\n    \\<exists>x. {enat x<..} \\<subseteq> A", "note inf_C = this"], ["proof (state)\nthis:\n  infinite ?C2 \\<Longrightarrow> ?C2 \\<inter> A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<infinity> \\<in> A \\<Longrightarrow>\n    \\<exists>x. {enat x<..} \\<subseteq> A", "show \"\\<exists>x. {enat x<..} \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. {enat x<..} \\<subseteq> A", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x. {enat x<..} \\<subseteq> A \\<Longrightarrow> False", "assume \"\\<not> (\\<exists>x. {enat x<..} \\<subseteq> A)\""], ["proof (state)\nthis:\n  \\<nexists>x. {enat x<..} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<nexists>x. {enat x<..} \\<subseteq> A \\<Longrightarrow> False", "with \\<open>\\<infinity> \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  \\<infinity> \\<in> A\n  \\<nexists>x. {enat x<..} \\<subseteq> A", "have \"\\<And>x. \\<exists>y>x. enat y \\<notin> A\""], ["proof (prove)\nusing this:\n  \\<infinity> \\<in> A\n  \\<nexists>x. {enat x<..} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>y>x. enat y \\<notin> A", "by (simp add: subset_eq Bex_def) (metis enat.exhaust enat_ord_simps(2))"], ["proof (state)\nthis:\n  \\<exists>y>?x. enat y \\<notin> A\n\ngoal (1 subgoal):\n 1. \\<nexists>x. {enat x<..} \\<subseteq> A \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>y>?x. enat y \\<notin> A", "have \"infinite {n. enat n \\<notin> A}\""], ["proof (prove)\nusing this:\n  \\<exists>y>?x. enat y \\<notin> A\n\ngoal (1 subgoal):\n 1. infinite {n. enat n \\<notin> A}", "unfolding infinite_nat_iff_unbounded"], ["proof (prove)\nusing this:\n  \\<exists>y>?x. enat y \\<notin> A\n\ngoal (1 subgoal):\n 1. \\<forall>m. \\<exists>n>m. n \\<in> {n. enat n \\<notin> A}", "by auto"], ["proof (state)\nthis:\n  infinite {n. enat n \\<notin> A}\n\ngoal (1 subgoal):\n 1. \\<nexists>x. {enat x<..} \\<subseteq> A \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  infinite {n. enat n \\<notin> A}", "have \"infinite (enat ` {n. enat n \\<notin> A})\""], ["proof (prove)\nusing this:\n  infinite {n. enat n \\<notin> A}\n\ngoal (1 subgoal):\n 1. infinite (enat ` {n. enat n \\<notin> A})", "by (auto dest!: finite_imageD)"], ["proof (state)\nthis:\n  infinite (enat ` {n. enat n \\<notin> A})\n\ngoal (1 subgoal):\n 1. \\<nexists>x. {enat x<..} \\<subseteq> A \\<Longrightarrow> False", "from inf_C[OF this]"], ["proof (chain)\npicking this:\n  enat ` {n. enat n \\<notin> A} \\<inter> A \\<noteq> {}", "show False"], ["proof (prove)\nusing this:\n  enat ` {n. enat n \\<notin> A} \\<inter> A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. {enat x<..} \\<subseteq> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  open A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  open A =\n  (\\<forall>C.\n      chain C \\<longrightarrow>\n      C \\<noteq> {} \\<longrightarrow>\n      \\<Squnion> C \\<in> A \\<longrightarrow> C \\<inter> A \\<noteq> {})\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemmas tendsto_inf2[THEN tendsto_compose, tendsto_intros] =\n  tendsto_mcont[OF mcont_inf2]"], ["", "lemma isCont_inf2[THEN isCont_o2[rotated]]:\n  \"isCont (\\<lambda>x. x \\<sqinter> y) (z :: _ :: {ccpo_topology, complete_distrib_lattice})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. x \\<sqinter> y) z", "by(simp add: isCont_def tendsto_inf2 tendsto_ident_at)"], ["", "lemmas tendsto_sup1[THEN tendsto_compose, tendsto_intros] =\n  tendsto_mcont[OF mcont_sup1]"], ["", "lemma isCont_If: \"isCont f x \\<Longrightarrow> isCont g x \\<Longrightarrow> isCont (\\<lambda>x. if Q then f x else g x) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isCont f x; isCont g x\\<rbrakk>\n    \\<Longrightarrow> isCont (\\<lambda>x. if Q then f x else g x) x", "by (cases Q) auto"], ["", "lemma isCont_enat_case: \"isCont (f (epred n)) x \\<Longrightarrow> isCont g x \\<Longrightarrow> isCont (\\<lambda>x. co.case_enat (g x) (\\<lambda>n. f n x) n) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isCont (f (epred n)) x; isCont g x\\<rbrakk>\n    \\<Longrightarrow> isCont\n                       (\\<lambda>x.\n                           case n of 0 \\<Rightarrow> g x\n                           | eSuc n \\<Rightarrow> f n x)\n                       x", "by (cases n rule: enat_coexhaust) auto"], ["", "end"]]}