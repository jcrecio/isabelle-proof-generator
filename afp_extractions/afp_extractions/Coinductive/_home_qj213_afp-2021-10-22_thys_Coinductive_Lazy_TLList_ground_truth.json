{"file_name": "/home/qj213/afp-2021-10-22/thys/Coinductive/Lazy_TLList.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Coinductive", "problem_names": ["lemma partial_term_of_tllist_code [code]:\n  fixes tytok :: \"('a :: partial_term_of, 'b :: partial_term_of) tllist itself\" shows\n  \"partial_term_of tytok (Quickcheck_Narrowing.Narrowing_variable p tt) \\<equiv>\n   Code_Evaluation.Free (STR ''_'') (Typerep.typerep TYPE(('a, 'b) tllist))\"\n  \"partial_term_of tytok (Quickcheck_Narrowing.Narrowing_constructor 0 [b]) \\<equiv>\n   Code_Evaluation.App\n     (Code_Evaluation.Const (STR ''TLList.tllist.TNil'') (Typerep.typerep TYPE('b \\<Rightarrow> ('a, 'b) tllist)))\n     (partial_term_of TYPE('b) b)\"\n  \"partial_term_of tytok (Quickcheck_Narrowing.Narrowing_constructor 1 [head, tail]) \\<equiv>\n   Code_Evaluation.App\n     (Code_Evaluation.App\n        (Code_Evaluation.Const\n           (STR ''TLList.tllist.TCons'')\n           (Typerep.typerep TYPE('a \\<Rightarrow> ('a, 'b) tllist \\<Rightarrow> ('a, 'b) tllist)))\n        (partial_term_of TYPE('a) head))\n     (partial_term_of TYPE(('a, 'b) tllist) tail)\"", "lemma TNil_Lazy_tllist [code]: \n  \"TNil b = Lazy_tllist (\\<lambda>_. Inr b)\"", "lemma TCons_Lazy_tllist [code, code_unfold]:\n  \"TCons x xs = Lazy_tllist (\\<lambda>_. Inl (x, xs))\"", "lemma Lazy_tllist_inverse [simp, code]:\n  \"force (Lazy_tllist xs) = xs ()\"", "lemma equal_tllist_Lazy_tllist [code]:\n  \"equal_class.equal (Lazy_tllist xs) (Lazy_tllist ys) =\n  (case xs () of \n     Inr b \\<Rightarrow> (case ys () of Inr b' \\<Rightarrow> b = b' | _ \\<Rightarrow> False)\n   | Inl (x, xs') \\<Rightarrow>\n     (case ys () of Inr b' \\<Rightarrow> False | Inl (y, ys') \\<Rightarrow> if x = y then equal_class.equal xs' ys' else False))\"", "lemma is_TNil_code [code]:\n  \"is_TNil (Lazy_tllist xs) \\<longleftrightarrow> \n  (case xs () of Inl _ \\<Rightarrow> False | Inr _ \\<Rightarrow> True)\"", "lemma corec_tllist_Lazy_tllist [code]:\n  \"corec_tllist IS_TNIL TNIL THD endORmore TTL_end TTL_more b = Lazy_tllist\n  (\\<lambda>_. if IS_TNIL b then Inr (TNIL b)\n       else Inl (THD b, if endORmore b then TTL_end b else corec_tllist IS_TNIL TNIL THD endORmore TTL_end TTL_more (TTL_more b)))\"", "lemma unfold_tllist_Lazy_tllist [code]:\n  \"unfold_tllist IS_TNIL TNIL THD TTL b = Lazy_tllist\n  (\\<lambda>_. if IS_TNIL b then Inr (TNIL b)\n       else Inl (THD b, unfold_tllist IS_TNIL TNIL THD TTL (TTL b)))\"", "lemma case_tllist_Lazy_tllist [code]:\n  \"case_tllist n c (Lazy_tllist xs) = \n  (case xs () of Inl (x, ys) \\<Rightarrow> c x ys | Inr b \\<Rightarrow> n b)\"", "lemma tllist_of_llist_Lazy_llist [code]:\n  \"tllist_of_llist b (Lazy_llist xs) =\n  Lazy_tllist (\\<lambda>_. case xs () of None \\<Rightarrow> Inr b | Some (x, ys) \\<Rightarrow> Inl (x, tllist_of_llist b ys))\"", "lemma terminal_Lazy_tllist [code]:\n  \"terminal (Lazy_tllist xs) = \n  (case xs () of Inl (_, ys) \\<Rightarrow> terminal ys | Inr b \\<Rightarrow> b)\"", "lemma tmap_Lazy_tllist [code]:\n  \"tmap f g (Lazy_tllist xs) =\n  Lazy_tllist (\\<lambda>_. case xs () of Inl (x, ys) \\<Rightarrow> Inl (f x, tmap f g ys) | Inr b \\<Rightarrow> Inr (g b))\"", "lemma tappend_Lazy_tllist [code]:\n  \"tappend (Lazy_tllist xs) ys =\n  Lazy_tllist (\\<lambda>_. case xs () of Inl (x, xs') \\<Rightarrow> Inl (x, tappend xs' ys) | Inr b \\<Rightarrow> force (ys b))\"", "lemma lappendt_Lazy_llist [code]:\n  \"lappendt (Lazy_llist xs) ys =\n  Lazy_tllist (\\<lambda>_. case xs () of None \\<Rightarrow> force ys | Some (x, xs') \\<Rightarrow> Inl (x, lappendt xs' ys))\"", "lemma tfilter'_Lazy_tllist [code]:\n  \"TLList.tfilter' b P (Lazy_tllist xs) =\n   Lazy_tllist (\\<lambda>_. case xs () of Inl (x, xs') \\<Rightarrow> if P x then Inl (x, TLList.tfilter' b P xs') else force (TLList.tfilter' b P xs') | Inr b' \\<Rightarrow> Inr b')\"", "lemma tconcat_Lazy_tllist [code]:\n  \"TLList.tconcat' b (Lazy_tllist xss) =\n  Lazy_tllist (\\<lambda>_. case xss () of Inr b' \\<Rightarrow> Inr b' | Inl (xs, xss') \\<Rightarrow> force (lappendt xs (TLList.tconcat' b xss')))\"", "lemma tllist_all2_Lazy_tllist [code]:\n  \"tllist_all2 P Q (Lazy_tllist xs) (Lazy_tllist ys) \\<longleftrightarrow>\n  (case xs () of \n    Inr b \\<Rightarrow> (case ys () of Inr b' \\<Rightarrow> Q b b' | Inl _ \\<Rightarrow> False)\n  | Inl (x, xs') \\<Rightarrow> (case ys () of Inr _ \\<Rightarrow> False | Inl (y, ys') \\<Rightarrow> P x y \\<and> tllist_all2 P Q xs' ys'))\"", "lemma llist_of_tllist_Lazy_tllist [code]:\n  \"llist_of_tllist (Lazy_tllist xs) =\n  Lazy_llist (\\<lambda>_. case xs () of Inl (x, ys) \\<Rightarrow> Some (x, llist_of_tllist ys) | Inr b \\<Rightarrow> None)\"", "lemma tnth_Lazy_tllist [code]:\n  \"tnth (Lazy_tllist xs) n =\n  (case xs () of Inr b \\<Rightarrow> undefined n | Inl (x, ys) \\<Rightarrow> if n = 0 then x else tnth ys (n - 1))\"", "lemma gen_tlength_Lazy_tllist [code]:\n  \"gen_tlength n (Lazy_tllist xs) =\n  (case xs () of Inr b \\<Rightarrow> enat n | Inl (_, xs') \\<Rightarrow> gen_tlength (n + 1) xs')\"", "lemma tdropn_Lazy_tllist [code]:\n  \"tdropn n (Lazy_tllist xs) =\n  Lazy_tllist (\\<lambda>_. if n = 0 then xs () else case xs () of Inr b \\<Rightarrow> Inr b | Inl (x, xs') \\<Rightarrow> force (tdropn (n - 1) xs'))\""], "translations": [["", "lemma partial_term_of_tllist_code [code]:\n  fixes tytok :: \"('a :: partial_term_of, 'b :: partial_term_of) tllist itself\" shows\n  \"partial_term_of tytok (Quickcheck_Narrowing.Narrowing_variable p tt) \\<equiv>\n   Code_Evaluation.Free (STR ''_'') (Typerep.typerep TYPE(('a, 'b) tllist))\"\n  \"partial_term_of tytok (Quickcheck_Narrowing.Narrowing_constructor 0 [b]) \\<equiv>\n   Code_Evaluation.App\n     (Code_Evaluation.Const (STR ''TLList.tllist.TNil'') (Typerep.typerep TYPE('b \\<Rightarrow> ('a, 'b) tllist)))\n     (partial_term_of TYPE('b) b)\"\n  \"partial_term_of tytok (Quickcheck_Narrowing.Narrowing_constructor 1 [head, tail]) \\<equiv>\n   Code_Evaluation.App\n     (Code_Evaluation.App\n        (Code_Evaluation.Const\n           (STR ''TLList.tllist.TCons'')\n           (Typerep.typerep TYPE('a \\<Rightarrow> ('a, 'b) tllist \\<Rightarrow> ('a, 'b) tllist)))\n        (partial_term_of TYPE('a) head))\n     (partial_term_of TYPE(('a, 'b) tllist) tail)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (partial_term_of tytok (narrowing_term.Narrowing_variable p tt) \\<equiv>\n     Code_Evaluation.Free STR ''_'' TYPEREP(('a, 'b) tllist)) &&&\n    (partial_term_of tytok\n      (narrowing_term.Narrowing_constructor 0 [b]) \\<equiv>\n     Code_Evaluation.App\n      (Code_Evaluation.Const STR ''TLList.tllist.TNil''\n        TYPEREP('b \\<Rightarrow> ('a, 'b) tllist))\n      (partial_term_of TYPE('b) b)) &&&\n    partial_term_of tytok\n     (narrowing_term.Narrowing_constructor 1 [head, tail]) \\<equiv>\n    Code_Evaluation.App\n     (Code_Evaluation.App\n       (Code_Evaluation.Const STR ''TLList.tllist.TCons''\n         TYPEREP\n          ('a \\<Rightarrow> ('a, 'b) tllist \\<Rightarrow> ('a, 'b) tllist))\n       (partial_term_of TYPE('a) head))\n     (partial_term_of TYPE(('a, 'b) tllist) tail)", "by-(rule partial_term_of_anything)+"], ["", "declare Lazy_tllist_def [simp]"], ["", "declare sum.splits [split]"], ["", "lemma TNil_Lazy_tllist [code]: \n  \"TNil b = Lazy_tllist (\\<lambda>_. Inr b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TNil b = Lazy_tllist (\\<lambda>_. Inr b)", "by simp"], ["", "lemma TCons_Lazy_tllist [code, code_unfold]:\n  \"TCons x xs = Lazy_tllist (\\<lambda>_. Inl (x, xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TCons x xs = Lazy_tllist (\\<lambda>_. Inl (x, xs))", "by simp"], ["", "lemma Lazy_tllist_inverse [simp, code]:\n  \"force (Lazy_tllist xs) = xs ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. force (Lazy_tllist xs) = xs ()", "by(simp)"], ["", "declare [[code drop: \"equal_class.equal :: (_, _) tllist \\<Rightarrow> _\"]]"], ["", "lemma equal_tllist_Lazy_tllist [code]:\n  \"equal_class.equal (Lazy_tllist xs) (Lazy_tllist ys) =\n  (case xs () of \n     Inr b \\<Rightarrow> (case ys () of Inr b' \\<Rightarrow> b = b' | _ \\<Rightarrow> False)\n   | Inl (x, xs') \\<Rightarrow>\n     (case ys () of Inr b' \\<Rightarrow> False | Inl (y, ys') \\<Rightarrow> if x = y then equal_class.equal xs' ys' else False))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal (Lazy_tllist xs) (Lazy_tllist ys) =\n    (case xs () of\n     Inl (x, xs') \\<Rightarrow>\n       case ys () of\n       Inl (y, ys') \\<Rightarrow>\n         if x = y then equal_class.equal xs' ys' else False\n       | Inr b' \\<Rightarrow> False\n     | Inr b \\<Rightarrow>\n         case ys () of Inl a \\<Rightarrow> False\n         | Inr b' \\<Rightarrow> b = b')", "by(auto simp add: equal_tllist_def)"], ["", "declare\n  [[code drop: thd ttl]]\n  thd_def [code]\n  ttl_def [code]"], ["", "declare [[code drop: is_TNil]]"], ["", "lemma is_TNil_code [code]:\n  \"is_TNil (Lazy_tllist xs) \\<longleftrightarrow> \n  (case xs () of Inl _ \\<Rightarrow> False | Inr _ \\<Rightarrow> True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_TNil (Lazy_tllist xs) =\n    (case xs () of Inl x \\<Rightarrow> False | Inr x \\<Rightarrow> True)", "by simp"], ["", "declare [[code drop: corec_tllist]]"], ["", "lemma corec_tllist_Lazy_tllist [code]:\n  \"corec_tllist IS_TNIL TNIL THD endORmore TTL_end TTL_more b = Lazy_tllist\n  (\\<lambda>_. if IS_TNIL b then Inr (TNIL b)\n       else Inl (THD b, if endORmore b then TTL_end b else corec_tllist IS_TNIL TNIL THD endORmore TTL_end TTL_more (TTL_more b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. corec_tllist IS_TNIL TNIL THD endORmore TTL_end TTL_more b =\n    Lazy_tllist\n     (\\<lambda>_.\n         if IS_TNIL b then Inr (TNIL b)\n         else Inl (THD b,\n                   if endORmore b then TTL_end b\n                   else corec_tllist IS_TNIL TNIL THD endORmore TTL_end\n                         TTL_more (TTL_more b)))", "by(rule tllist.expand) simp_all"], ["", "declare [[code drop: unfold_tllist]]"], ["", "lemma unfold_tllist_Lazy_tllist [code]:\n  \"unfold_tllist IS_TNIL TNIL THD TTL b = Lazy_tllist\n  (\\<lambda>_. if IS_TNIL b then Inr (TNIL b)\n       else Inl (THD b, unfold_tllist IS_TNIL TNIL THD TTL (TTL b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold_tllist IS_TNIL TNIL THD TTL b =\n    Lazy_tllist\n     (\\<lambda>_.\n         if IS_TNIL b then Inr (TNIL b)\n         else Inl (THD b, unfold_tllist IS_TNIL TNIL THD TTL (TTL b)))", "by(rule tllist.expand) auto"], ["", "declare [[code drop: case_tllist]]"], ["", "lemma case_tllist_Lazy_tllist [code]:\n  \"case_tllist n c (Lazy_tllist xs) = \n  (case xs () of Inl (x, ys) \\<Rightarrow> c x ys | Inr b \\<Rightarrow> n b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case Lazy_tllist xs of TNil x \\<Rightarrow> n x\n     | TCons x xa \\<Rightarrow> c x xa) =\n    (case xs () of Inl (x, ys) \\<Rightarrow> c x ys\n     | Inr b \\<Rightarrow> n b)", "by simp"], ["", "declare [[code drop: tllist_of_llist]]"], ["", "lemma tllist_of_llist_Lazy_llist [code]:\n  \"tllist_of_llist b (Lazy_llist xs) =\n  Lazy_tllist (\\<lambda>_. case xs () of None \\<Rightarrow> Inr b | Some (x, ys) \\<Rightarrow> Inl (x, tllist_of_llist b ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_of_llist b (Lazy_llist xs) =\n    Lazy_tllist\n     (\\<lambda>_.\n         case xs () of None \\<Rightarrow> Inr b\n         | Some (x, ys) \\<Rightarrow> Inl (x, tllist_of_llist b ys))", "by(simp add: Lazy_llist_def split: option.splits)"], ["", "declare [[code drop: terminal]]"], ["", "lemma terminal_Lazy_tllist [code]:\n  \"terminal (Lazy_tllist xs) = \n  (case xs () of Inl (_, ys) \\<Rightarrow> terminal ys | Inr b \\<Rightarrow> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal (Lazy_tllist xs) =\n    (case xs () of Inl (x, ys) \\<Rightarrow> terminal ys\n     | Inr b \\<Rightarrow> b)", "by simp"], ["", "declare [[code drop: tmap]]"], ["", "lemma tmap_Lazy_tllist [code]:\n  \"tmap f g (Lazy_tllist xs) =\n  Lazy_tllist (\\<lambda>_. case xs () of Inl (x, ys) \\<Rightarrow> Inl (f x, tmap f g ys) | Inr b \\<Rightarrow> Inr (g b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tmap f g (Lazy_tllist xs) =\n    Lazy_tllist\n     (\\<lambda>_.\n         case xs () of Inl (x, ys) \\<Rightarrow> Inl (f x, tmap f g ys)\n         | Inr b \\<Rightarrow> Inr (g b))", "by simp"], ["", "declare [[code drop: tappend]]"], ["", "lemma tappend_Lazy_tllist [code]:\n  \"tappend (Lazy_tllist xs) ys =\n  Lazy_tllist (\\<lambda>_. case xs () of Inl (x, xs') \\<Rightarrow> Inl (x, tappend xs' ys) | Inr b \\<Rightarrow> force (ys b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tappend (Lazy_tllist xs) ys =\n    Lazy_tllist\n     (\\<lambda>_.\n         case xs () of Inl (x, xs') \\<Rightarrow> Inl (x, tappend xs' ys)\n         | Inr b \\<Rightarrow> force (ys b))", "by(auto split: tllist.split)"], ["", "declare [[code drop: lappendt]]"], ["", "lemma lappendt_Lazy_llist [code]:\n  \"lappendt (Lazy_llist xs) ys =\n  Lazy_tllist (\\<lambda>_. case xs () of None \\<Rightarrow> force ys | Some (x, xs') \\<Rightarrow> Inl (x, lappendt xs' ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappendt (Lazy_llist xs) ys =\n    Lazy_tllist\n     (\\<lambda>_.\n         case xs () of None \\<Rightarrow> force ys\n         | Some (x, xs') \\<Rightarrow> Inl (x, lappendt xs' ys))", "by(auto simp add: Lazy_llist_def split: option.split tllist.split)"], ["", "declare [[code drop: TLList.tfilter']]"], ["", "lemma tfilter'_Lazy_tllist [code]:\n  \"TLList.tfilter' b P (Lazy_tllist xs) =\n   Lazy_tllist (\\<lambda>_. case xs () of Inl (x, xs') \\<Rightarrow> if P x then Inl (x, TLList.tfilter' b P xs') else force (TLList.tfilter' b P xs') | Inr b' \\<Rightarrow> Inr b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TLList.tfilter' b P (Lazy_tllist xs) =\n    Lazy_tllist\n     (\\<lambda>_.\n         case xs () of\n         Inl (x, xs') \\<Rightarrow>\n           if P x then Inl (x, TLList.tfilter' b P xs')\n           else force (TLList.tfilter' b P xs')\n         | Inr b' \\<Rightarrow> Inr b')", "by(simp split: tllist.split)"], ["", "declare [[code drop: TLList.tconcat']]"], ["", "lemma tconcat_Lazy_tllist [code]:\n  \"TLList.tconcat' b (Lazy_tllist xss) =\n  Lazy_tllist (\\<lambda>_. case xss () of Inr b' \\<Rightarrow> Inr b' | Inl (xs, xss') \\<Rightarrow> force (lappendt xs (TLList.tconcat' b xss')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TLList.tconcat' b (Lazy_tllist xss) =\n    Lazy_tllist\n     (\\<lambda>_.\n         case xss () of\n         Inl (xs, xss') \\<Rightarrow>\n           force (lappendt xs (TLList.tconcat' b xss'))\n         | Inr b' \\<Rightarrow> Inr b')", "by(simp split: tllist.split)"], ["", "declare [[code drop: tllist_all2]]"], ["", "lemma tllist_all2_Lazy_tllist [code]:\n  \"tllist_all2 P Q (Lazy_tllist xs) (Lazy_tllist ys) \\<longleftrightarrow>\n  (case xs () of \n    Inr b \\<Rightarrow> (case ys () of Inr b' \\<Rightarrow> Q b b' | Inl _ \\<Rightarrow> False)\n  | Inl (x, xs') \\<Rightarrow> (case ys () of Inr _ \\<Rightarrow> False | Inl (y, ys') \\<Rightarrow> P x y \\<and> tllist_all2 P Q xs' ys'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 P Q (Lazy_tllist xs) (Lazy_tllist ys) =\n    (case xs () of\n     Inl (x, xs') \\<Rightarrow>\n       case ys () of\n       Inl (y, ys') \\<Rightarrow> P x y \\<and> tllist_all2 P Q xs' ys'\n       | Inr x \\<Rightarrow> False\n     | Inr b \\<Rightarrow>\n         case ys () of Inl x \\<Rightarrow> False\n         | Inr b' \\<Rightarrow> Q b b')", "by(simp add: tllist_all2_TNil1 tllist_all2_TNil2)"], ["", "declare [[code drop: llist_of_tllist]]"], ["", "lemma llist_of_tllist_Lazy_tllist [code]:\n  \"llist_of_tllist (Lazy_tllist xs) =\n  Lazy_llist (\\<lambda>_. case xs () of Inl (x, ys) \\<Rightarrow> Some (x, llist_of_tllist ys) | Inr b \\<Rightarrow> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_of_tllist (Lazy_tllist xs) =\n    Lazy_llist\n     (\\<lambda>_.\n         case xs () of\n         Inl (x, ys) \\<Rightarrow> Some (x, llist_of_tllist ys)\n         | Inr x \\<Rightarrow> Map.empty x)", "by(simp add: Lazy_llist_def)"], ["", "declare [[code drop: tnth]]"], ["", "lemma tnth_Lazy_tllist [code]:\n  \"tnth (Lazy_tllist xs) n =\n  (case xs () of Inr b \\<Rightarrow> undefined n | Inl (x, ys) \\<Rightarrow> if n = 0 then x else tnth ys (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tnth (Lazy_tllist xs) n =\n    (case xs () of\n     Inl (x, ys) \\<Rightarrow> if n = 0 then x else tnth ys (n - 1)\n     | Inr b \\<Rightarrow> undefined n)", "by(cases n)(auto simp add: tnth_TNil)"], ["", "declare [[code drop: gen_tlength]]"], ["", "lemma gen_tlength_Lazy_tllist [code]:\n  \"gen_tlength n (Lazy_tllist xs) =\n  (case xs () of Inr b \\<Rightarrow> enat n | Inl (_, xs') \\<Rightarrow> gen_tlength (n + 1) xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_tlength n (Lazy_tllist xs) =\n    (case xs () of Inl (x, xs') \\<Rightarrow> gen_tlength (n + 1) xs'\n     | Inr b \\<Rightarrow> enat n)", "by(simp add: gen_tlength_code)"], ["", "declare [[code drop: tdropn]]"], ["", "lemma tdropn_Lazy_tllist [code]:\n  \"tdropn n (Lazy_tllist xs) =\n  Lazy_tllist (\\<lambda>_. if n = 0 then xs () else case xs () of Inr b \\<Rightarrow> Inr b | Inl (x, xs') \\<Rightarrow> force (tdropn (n - 1) xs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tdropn n (Lazy_tllist xs) =\n    Lazy_tllist\n     (\\<lambda>_.\n         if n = 0 then xs ()\n         else case xs () of\n              Inl (x, xs') \\<Rightarrow> force (tdropn (n - 1) xs')\n              | Inr b \\<Rightarrow> Inr b)", "by(cases n)(auto split: tllist.split)"], ["", "declare Lazy_tllist_def [simp del]"], ["", "declare sum.splits [split del]"], ["", "text \\<open>Simple ML test for laziness\\<close>"], ["", "ML_val \\<open>\n  val zeros = @{code unfold_tllist} (K false) (K 0) (K 0) I ();\n  val thd = @{code thd} zeros;\n  val ttl = @{code ttl} zeros;\n  val ttl' = @{code force} ttl;\n  \n  val tdropn = @{code tdropn} (@{code Suc} @{code \"0::nat\"}) zeros;\n  \n  val tfilter = @{code tfilter} 1 (K false) zeros;\n\\<close>"], ["", "hide_const (open) force"], ["", "end"]]}