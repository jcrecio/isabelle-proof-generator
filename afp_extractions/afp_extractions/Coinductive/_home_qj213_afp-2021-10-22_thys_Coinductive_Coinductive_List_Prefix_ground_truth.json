{"file_name": "/home/qj213/afp-2021-10-22/thys/Coinductive/Coinductive_List_Prefix.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Coinductive", "problem_names": ["lemma le_llist_conv_lprefix [iff]: \"(\\<le>) = lprefix\"", "lemma less_llist_conv_lstrict_prefix [iff]: \"(<) = lstrict_prefix\"", "lemma llist_of_lprefix_llist_of [simp]:\n  \"lprefix (llist_of xs) (llist_of ys) \\<longleftrightarrow> xs \\<le> ys\"", "lemma llist_inf_simps [simp, code, nitpick_simp]:\n  \"inf LNil xs = LNil\"\n  \"inf xs LNil = LNil\"\n  \"inf (LCons x xs) (LCons y ys) = (if x = y then LCons x (inf xs ys) else LNil)\"", "lemma llist_inf_eq_LNil [simp]:\n  \"lnull (inf xs ys) \\<longleftrightarrow> (xs \\<noteq> LNil \\<longrightarrow> ys \\<noteq> LNil \\<longrightarrow> lhd xs \\<noteq> lhd ys)\"", "lemma [simp]: assumes \"xs \\<noteq> LNil\" \"ys \\<noteq> LNil\" \"lhd xs = lhd ys\"\n  shows lhd_llist_inf: \"lhd (inf xs ys) = lhd ys\"\n  and  ltl_llist_inf: \"ltl (inf xs ys) = inf (ltl xs) (ltl ys)\"", "lemma llength_inf [simp]: \"llength (inf xs ys) = llcp xs ys\""], "translations": [["", "lemma le_llist_conv_lprefix [iff]: \"(\\<le>) = lprefix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<le>) = lprefix", "by(simp add: less_eq_llist_def fun_eq_iff)"], ["", "lemma less_llist_conv_lstrict_prefix [iff]: \"(<) = lstrict_prefix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (<) = lstrict_prefix", "by(simp add: less_llist_def fun_eq_iff)"], ["", "instantiation llist :: (type) order_bot begin"], ["", "definition \"bot = LNil\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a llist, order_bot_class)", "by(intro_classes)(simp add: bot_llist_def)"], ["", "end"], ["", "lemma llist_of_lprefix_llist_of [simp]:\n  \"lprefix (llist_of xs) (llist_of ys) \\<longleftrightarrow> xs \\<le> ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (llist_of xs) (llist_of ys) = (xs \\<le> ys)", "proof(induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. lprefix (llist_of []) (llist_of ys) = ([] \\<le> ys)\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           lprefix (llist_of xs) (llist_of ys) =\n           (xs \\<le> ys)) \\<Longrightarrow>\n       lprefix (llist_of (a # xs)) (llist_of ys) = (a # xs \\<le> ys)", "case (Cons x xs)"], ["proof (state)\nthis:\n  lprefix (llist_of xs) (llist_of ?ys) = (xs \\<le> ?ys)\n\ngoal (2 subgoals):\n 1. \\<And>ys. lprefix (llist_of []) (llist_of ys) = ([] \\<le> ys)\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           lprefix (llist_of xs) (llist_of ys) =\n           (xs \\<le> ys)) \\<Longrightarrow>\n       lprefix (llist_of (a # xs)) (llist_of ys) = (a # xs \\<le> ys)", "thus ?case"], ["proof (prove)\nusing this:\n  lprefix (llist_of xs) (llist_of ?ys) = (xs \\<le> ?ys)\n\ngoal (1 subgoal):\n 1. lprefix (llist_of (x # xs)) (llist_of ys) = (x # xs \\<le> ys)", "by(cases ys)(auto simp add: LCons_lprefix_conv)"], ["proof (state)\nthis:\n  lprefix (llist_of (x # xs)) (llist_of ys) = (x # xs \\<le> ys)\n\ngoal (1 subgoal):\n 1. \\<And>ys. lprefix (llist_of []) (llist_of ys) = ([] \\<le> ys)", "qed simp"], ["", "subsection \\<open>Prefix ordering as a lower semilattice\\<close>"], ["", "instantiation llist :: (type) semilattice_inf begin"], ["", "definition [code del]:\n  \"inf xs ys = \n   unfold_llist (\\<lambda>(xs, ys). xs \\<noteq> LNil \\<longrightarrow> ys \\<noteq> LNil \\<longrightarrow> lhd xs \\<noteq> lhd ys)\n     (lhd \\<circ> snd) (map_prod ltl ltl) (xs, ys)\""], ["", "lemma llist_inf_simps [simp, code, nitpick_simp]:\n  \"inf LNil xs = LNil\"\n  \"inf xs LNil = LNil\"\n  \"inf (LCons x xs) (LCons y ys) = (if x = y then LCons x (inf xs ys) else LNil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LNil \\<sqinter> xs = LNil &&&\n    xs \\<sqinter> LNil = LNil &&&\n    LCons x xs \\<sqinter> LCons y ys =\n    (if x = y then LCons x (xs \\<sqinter> ys) else LNil)", "unfolding inf_llist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold_llist\n     (\\<lambda>(xs, ys).\n         xs \\<noteq> LNil \\<longrightarrow>\n         ys \\<noteq> LNil \\<longrightarrow> lhd xs \\<noteq> lhd ys)\n     (lhd \\<circ> snd) (map_prod ltl ltl) (LNil, xs) =\n    LNil &&&\n    unfold_llist\n     (\\<lambda>(xs, ys).\n         xs \\<noteq> LNil \\<longrightarrow>\n         ys \\<noteq> LNil \\<longrightarrow> lhd xs \\<noteq> lhd ys)\n     (lhd \\<circ> snd) (map_prod ltl ltl) (xs, LNil) =\n    LNil &&&\n    unfold_llist\n     (\\<lambda>(xs, ys).\n         xs \\<noteq> LNil \\<longrightarrow>\n         ys \\<noteq> LNil \\<longrightarrow> lhd xs \\<noteq> lhd ys)\n     (lhd \\<circ> snd) (map_prod ltl ltl) (LCons x xs, LCons y ys) =\n    (if x = y\n     then LCons x\n           (unfold_llist\n             (\\<lambda>(xs, ys).\n                 xs \\<noteq> LNil \\<longrightarrow>\n                 ys \\<noteq> LNil \\<longrightarrow> lhd xs \\<noteq> lhd ys)\n             (lhd \\<circ> snd) (map_prod ltl ltl) (xs, ys))\n     else LNil)", "by simp_all"], ["", "lemma llist_inf_eq_LNil [simp]:\n  \"lnull (inf xs ys) \\<longleftrightarrow> (xs \\<noteq> LNil \\<longrightarrow> ys \\<noteq> LNil \\<longrightarrow> lhd xs \\<noteq> lhd ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (xs \\<sqinter> ys) =\n    (xs \\<noteq> LNil \\<longrightarrow>\n     ys \\<noteq> LNil \\<longrightarrow> lhd xs \\<noteq> lhd ys)", "by(simp add: inf_llist_def)"], ["", "lemma [simp]: assumes \"xs \\<noteq> LNil\" \"ys \\<noteq> LNil\" \"lhd xs = lhd ys\"\n  shows lhd_llist_inf: \"lhd (inf xs ys) = lhd ys\"\n  and  ltl_llist_inf: \"ltl (inf xs ys) = inf (ltl xs) (ltl ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd (xs \\<sqinter> ys) = lhd ys &&&\n    ltl (xs \\<sqinter> ys) = ltl xs \\<sqinter> ltl ys", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> LNil\n  ys \\<noteq> LNil\n  lhd xs = lhd ys\n\ngoal (1 subgoal):\n 1. lhd (xs \\<sqinter> ys) = lhd ys &&&\n    ltl (xs \\<sqinter> ys) = ltl xs \\<sqinter> ltl ys", "by(simp_all add: inf_llist_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a llist, semilattice_inf_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z", "fix xs ys zs :: \"'a llist\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z", "show \"inf xs ys \\<le> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqinter> ys \\<le> xs", "unfolding le_llist_conv_lprefix"], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (xs \\<sqinter> ys) xs", "by(coinduction arbitrary: xs ys) auto"], ["proof (state)\nthis:\n  xs \\<sqinter> ys \\<le> xs\n\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> y\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z", "show \"inf xs ys \\<le> ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqinter> ys \\<le> ys", "unfolding le_llist_conv_lprefix"], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (xs \\<sqinter> ys) ys", "by(coinduction arbitrary: xs ys) auto"], ["proof (state)\nthis:\n  xs \\<sqinter> ys \\<le> ys\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z", "assume \"xs \\<le> ys\" \"xs \\<le> zs\""], ["proof (state)\nthis:\n  xs \\<le> ys\n  xs \\<le> zs\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z", "thus \"xs \\<le> inf ys zs\""], ["proof (prove)\nusing this:\n  xs \\<le> ys\n  xs \\<le> zs\n\ngoal (1 subgoal):\n 1. xs \\<le> ys \\<sqinter> zs", "unfolding le_llist_conv_lprefix"], ["proof (prove)\nusing this:\n  lprefix xs ys\n  lprefix xs zs\n\ngoal (1 subgoal):\n 1. lprefix xs (ys \\<sqinter> zs)", "proof(coinduction arbitrary: xs ys zs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa__ ysa__ zs.\n       \\<lbrakk>lprefix xsa__ ysa__; lprefix xsa__ zs\\<rbrakk>\n       \\<Longrightarrow> (lnull (ysa__ \\<sqinter> zs) \\<longrightarrow>\n                          lnull xsa__) \\<and>\n                         (\\<not> lnull xsa__ \\<longrightarrow>\n                          \\<not> lnull\n                                  (ysa__ \\<sqinter> zs) \\<longrightarrow>\n                          lhd xsa__ = lhd (ysa__ \\<sqinter> zs) \\<and>\n                          ((\\<exists>xs__ ys__ zsa.\n                               ltl xsa__ = xs__ \\<and>\n                               ltl (ysa__ \\<sqinter> zs) =\n                               ys__ \\<sqinter> zsa \\<and>\n                               lprefix xs__ ys__ \\<and>\n                               lprefix xs__ zsa) \\<or>\n                           lprefix (ltl xsa__) (ltl (ysa__ \\<sqinter> zs))))", "case (lprefix xs ys zs)"], ["proof (state)\nthis:\n  lprefix xs ys\n  lprefix xs zs\n\ngoal (1 subgoal):\n 1. \\<And>xsa__ ysa__ zs.\n       \\<lbrakk>lprefix xsa__ ysa__; lprefix xsa__ zs\\<rbrakk>\n       \\<Longrightarrow> (lnull (ysa__ \\<sqinter> zs) \\<longrightarrow>\n                          lnull xsa__) \\<and>\n                         (\\<not> lnull xsa__ \\<longrightarrow>\n                          \\<not> lnull\n                                  (ysa__ \\<sqinter> zs) \\<longrightarrow>\n                          lhd xsa__ = lhd (ysa__ \\<sqinter> zs) \\<and>\n                          ((\\<exists>xs__ ys__ zsa.\n                               ltl xsa__ = xs__ \\<and>\n                               ltl (ysa__ \\<sqinter> zs) =\n                               ys__ \\<sqinter> zsa \\<and>\n                               lprefix xs__ ys__ \\<and>\n                               lprefix xs__ zsa) \\<or>\n                           lprefix (ltl xsa__) (ltl (ysa__ \\<sqinter> zs))))", "thus ?case"], ["proof (prove)\nusing this:\n  lprefix xs ys\n  lprefix xs zs\n\ngoal (1 subgoal):\n 1. (lnull (ys \\<sqinter> zs) \\<longrightarrow> lnull xs) \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull (ys \\<sqinter> zs) \\<longrightarrow>\n     lhd xs = lhd (ys \\<sqinter> zs) \\<and>\n     ((\\<exists>xs__ ys__ zs.\n          ltl xs = xs__ \\<and>\n          ltl (ys \\<sqinter> zs) = ys__ \\<sqinter> zs \\<and>\n          lprefix xs__ ys__ \\<and> lprefix xs__ zs) \\<or>\n      lprefix (ltl xs) (ltl (ys \\<sqinter> zs))))", "by(cases xs)(auto 4 4 simp add: LCons_lprefix_conv)"], ["proof (state)\nthis:\n  (lnull (ys \\<sqinter> zs) \\<longrightarrow> lnull xs) \\<and>\n  (\\<not> lnull xs \\<longrightarrow>\n   \\<not> lnull (ys \\<sqinter> zs) \\<longrightarrow>\n   lhd xs = lhd (ys \\<sqinter> zs) \\<and>\n   ((\\<exists>xs__ ys__ zs.\n        ltl xs = xs__ \\<and>\n        ltl (ys \\<sqinter> zs) = ys__ \\<sqinter> zs \\<and>\n        lprefix xs__ ys__ \\<and> lprefix xs__ zs) \\<or>\n    lprefix (ltl xs) (ltl (ys \\<sqinter> zs))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs \\<le> ys \\<sqinter> zs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma llength_inf [simp]: \"llength (inf xs ys) = llcp xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (xs \\<sqinter> ys) = llcp xs ys", "by(coinduction arbitrary: xs ys rule: enat_coinduct)(auto simp add: llcp_eq_0_iff epred_llength epred_llcp)"], ["", "instantiation llist :: (type) ccpo\nbegin"], ["", "definition \"Sup A = lSup A\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a llist, ccpo_class)", "by intro_classes\n     (auto simp: Sup_llist_def less_eq_llist_def[abs_def] intro!: llist.lub_upper llist.lub_least)"], ["", "end"], ["", "end"]]}